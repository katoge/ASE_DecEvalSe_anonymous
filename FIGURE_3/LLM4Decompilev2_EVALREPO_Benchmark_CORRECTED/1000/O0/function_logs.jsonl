{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)((double)rand() / ((double)(RAND_MAX) + (double)(1)) *\n                        ((double)max - (double)min + 1.0)));\n}","pass":1}
{"function":"bool wait_countDown(struct data_queue *sequence, struct data_channel *channel) {\n    int i;\n    for (i = 0; i < 5; i++) {\n        if (sequence[i].waiting == 1)\n            return 1;\n    }\n    for (i = 0; i < 2; i++) {\n        if (channel[i].countDown > 0)\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"int wait_countDown_name_conflict(int *countDown, int *countUp) {\n  int i;\n  for (i = 0; i < 5; i++) {\n    if (countDown[i] == 1) {\n      return 1;\n    }\n  }\n  for (i = 0; i < 2; i++) {\n    if (countUp[i] > 0) {\n      return 1;\n    }\n  }\n  return 0;\n}","pass":1}
{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)((double)rand() / ((double)(RAND_MAX) + (double)(1)) *\n                        ((double)max - (double)min + 1.0)));\n}","pass":1}
{"function":"bool valid_move(char c, int x, int y) {\n    bool valid = 1;\n    int person, i;\n    char letter[] = {'B', 'D', 'T', 'M'};\n    for (i = 0; i < 4; i++) {\n        if (c == letter[i]) {\n            person = i;\n        }\n    }\n    if (x < 0 || x > 4 || y < 0 || y > 4) {\n        valid = 0;\n    } else if (shared_t.map[x][y] == 'F' && !(shared_t.carrot_holder_t[0] == person || shared_t.carrot_holder_t[1] == person)) {\n        valid = 0;\n    } else if (shared_t.map[x][y] != 'C' && shared_t.map[x][y] != ' ' && person != 3) {\n        valid = 0;\n    } else if ((shared_t.carrot_holder_t[0] == person || shared_t.carrot_holder_t[1] == person) && ((shared_t.carrot_t[0][0] == x && shared_t.carrot_t[0][1] == y) || (shared_t.carrot_t[1][0] == x && shared_t.carrot_t[1][1] == y))) {\n        valid = 0;\n    }\n    return valid;\n}\n","function_prediction":"int valid_move_name_conflict(char player, int row, int col) {\n  int i, p;\n  char p_char[4] = {'B', 'D', 'T', 'M'};\n  int valid = 1;\n\n  for (i = 0; i < 4; i++) {\n    if (player == p_char[i]) {\n      p = i;\n    }\n  }\n\n  if (row < 0 || row > 4 || col < 0 || col > 4) {\n    valid = 0;\n  } else if (board[row][col] == 'F' && p != 3 && p != 2) {\n    valid = 0;\n  } else if (board[row][col] == 'C' || board[row][col] == ' ' || p == 3) {\n    if ((p == 2 || p == 3) && (row == 2 && col == 2 || row == 3 && col == 3)) {\n      valid = 0;\n    }\n  } else {\n    valid = 0;\n  }\n\n  return valid;\n}","pass":0}
{"function":"int check_person(int x, int y) {\n    int id;\n    char person = shared_t.map[x][y];\n    if (person == 'B') {\n        id = 0;\n    } else if (person == 'D') {\n        id = 1;\n    } else if (person == 'T') {\n        id = 2;\n    } else if (person == 'M') {\n        id = 3;\n    } else {\n        id = -1;\n    }\n    return id;\n}\n","function_prediction":"int check_person_name_conflict(int x, int y) {\n  char c = ' ';\n  c = map[x][y];\n  if (c == 'B')\n    return 0;\n  else if (c == 'D')\n    return 1;\n  else if (c == 'T')\n    return 2;\n  else if (c == 'M')\n    return 3;\n  else\n    return -1;\n}","pass":0}
{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)(max - min + 1) * (rand() / (RAND_MAX + 1.0)));\n}","pass":1}
{"function":"bool hasPerson(struct Workspace *map, int x, int y) {\n    bool person = 0;\n    if (map->pos[x][y] == 'B' || map->pos[x][y] == 'D' || map->pos[x][y] == 'M' || map->pos[x][y] == 'T') {\n        person = 1;\n        printf(\"There is someone in the square, not moving.\\n\");\n    }\n    return person;\n}\n","function_prediction":"int hasPerson_name_conflict(char board[5][5], int x, int y) {\n  int hasPerson_name_conflict = 0;\n  if (board[x][y] == 'B' || board[x][y] == 'D' || board[x][y] == 'M' ||\n      board[x][y] == 'T') {\n    hasPerson_name_conflict = 1;\n    puts(\"There is someone in the square, not moving.\");\n  }\n  return hasPerson_name_conflict;\n}","pass":1}
{"function":"bool hasMountain(struct Workspace *map, int x, int y) {\n    bool mtn = 0;\n    if (map->pos[x][y] == 'F') {\n        mtn = 1;\n    }\n    return mtn;\n}\n","function_prediction":"int hasMountain_name_conflict(char map[5][5], int x, int y) {\n  return map[x][y] == 'F';\n}","pass":1}
{"function":"bool invalidMountain(struct Workspace *map, int pos_x, int pos_y) {\n    bool invalid = 0;\n    if (pos_x == map->bun.pos_x && pos_y == map->bun.pos_y && !(map->bun.dead)) {\n        invalid = 1;\n    } else if (pos_x == map->tz.pos_x && pos_y == map->tz.pos_y && !(map->tz.dead)) {\n        invalid = 1;\n    } else if (pos_x == map->tty.pos_x && pos_y == map->tty.pos_y && !(map->tty.dead)) {\n        invalid = 1;\n    } else if (pos_x == map->mvin.pos_x && pos_y == map->mvin.pos_y) {\n        invalid = 1;\n    } else if (pos_x == map->fg1.pos_x && pos_y == map->fg1.pos_y && map->fg1.available) {\n        invalid = 1;\n    } else if (pos_x == map->fg2.pos_x && pos_y == map->fg2.pos_y && map->fg2.available) {\n        invalid = 1;\n    }\n    return invalid;\n}\n","function_prediction":"char invalidMountain_name_conflict(char *board, int x, int y) {\n  char invalid = 0;\n\n  if (x == board[11] && y == board[12] && board[13] != 1)\n    invalid = 1;\n  else if (x == board[15] && y == board[16] && board[17] != 1)\n    invalid = 1;\n  else if (x == board[19] && y == board[20] && board[21] != 1)\n    invalid = 1;\n  else if (x == board[23] && y == board[24])\n    invalid = 1;\n  else if (x == board[25] && y == board[26] && board[27] != 0)\n    invalid = 1;\n  else if (x == board[29] && y == board[30] && board[31] != 0)\n    invalid = 1;\n\n  return invalid;\n}","pass":0}
{"function":"bool hasFlag(struct Workspace *map, int x, int y) {\n    bool fg = 0;\n    if (map->pos[x][y] == 'C') {\n        fg = 1;\n    }\n    return fg;\n}\n","function_prediction":"int hasFlag_name_conflict(char *board, int row, int col) {\n  return board[row * 5 + col] == 'C';\n}","pass":1}
{"function":"bool atMountain(struct Workspace *map, int x, int y) {\n    bool mtn = 0;\n    if ((map->mtn.pos_x == x) && (map->mtn.pos_y == y)) {\n        mtn = 1;\n    }\n    return mtn;\n}\n","function_prediction":"int atMountain_name_conflict(char *map, int x, int y) {\n  int atMountain_name_conflict = 0;\n  if (x == map[15] && y == map[16]) {\n    atMountain_name_conflict = 1;\n  }\n  return atMountain_name_conflict;\n}","pass":0}
{"function":"bool foundPersonhasFlag(struct Workspace *map) {\n    if (map->mvin.tty && map->tty.hasFlag) {\n        return 1;\n    }\n    if (map->mvin.bugs && map->bun.hasFlag) {\n        return 1;\n    }\n    if (map->mvin.tz && map->tz.hasFlag) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int foundPersonhasFlag_name_conflict(char *person) {\n  if (person[83] != '\\0' && person[58] != '\\0') {\n    return 1;\n  }\n  if (person[82] != '\\0' && person[98] != '\\0') {\n    return 1;\n  }\n  if (person[84] != '\\0' && person[70] != '\\0') {\n    return 1;\n  }\n  return 0;\n}","pass":0}
{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)((double)rand() / ((double)(RAND_MAX) + (double)(1)) *\n                        ((double)max - (double)min + 1.0)));\n}","pass":1}
{"function":"int CreateClone(struct data_clone **warrior) {\n    int n_clone = 0;\n    printf(\"Please input the number of clones to spawn: \");\n    scanf(\"%d\", &n_clone);\n    printf(\"Spawning %d clones...\\n\", n_clone);\n    *warrior = malloc(n_clone * sizeof(struct data_clone));\n    if (warrior == ((void *)0)) {\n        printf(\"Does not have enough memory for allocation. Exiting program\\n\");\n        exit(0);\n    }\n    return n_clone;\n}\n","function_prediction":"int CreateClone_name_conflict(struct Clone *clone) {\n  int i, numClones = 0;\n\n  printf(\"Please input the number of clones to spawn: \");\n  __isoc99_scanf(\"%d\", &numClones);\n\n  printf(\"Spawning %d clones...\\n\", numClones);\n\n  clone = (struct Clone *)malloc(numClones * sizeof(struct Clone));\n\n  if (clone == NULL) {\n    printf(\"Does not have enough memory for allocation. Exiting program\\n\");\n    exit(0);\n  }\n\n  return numClones;\n}","pass":0}
{"function":"bool IsAlive(struct data_clone *clone) {\n    return clone->timeCounter > 0;\n}\n","function_prediction":"int IsAlive_name_conflict(struct Player *player) {\n  return (player->health > 0);\n}","pass":0}
{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)((double)rand() / ((double)(RAND_MAX) + (double)(1)) *\n                        ((double)max - (double)min + 1.0)));\n}","pass":1}
{"function":"bool MapHasGold(struct Workspace *map) {\n    printf(\"Map has %d gold bar(s).\\n\", map->n_gold);\n    return (map->n_gold > 0);\n}\n","function_prediction":"bool MapHasGold_name_conflict(Map *map) {\n  printf(\"Map has %d gold bar(s).\\n\", map->gold);\n  return map->gold > 0;\n}","pass":0}
{"function":"bool hasBomb(struct Workspace *map, int x, int y) {\n    bool bmb = 0;\n    if (map->pos[x][y] == 'B') {\n        bmb = 1;\n        printf(\"Bomb has been found, not moving.\\n\");\n    }\n    return bmb;\n}\n","function_prediction":"int hasBomb_name_conflict(char **board, int x, int y) {\n  if (board[x][y] == 'B') {\n    puts(\"Bomb has been found, not moving.\");\n    return 1;\n  }\n  return 0;\n}","pass":1}
{"function":"bool isValidMove(struct Workspace *map, int x, int y) {\n    bool valid;\n    if ((map->wall_e.pos_x + x >= 4) || (map->wall_e.pos_x + x) < 0) {\n        valid = 0;\n    } else if ((map->wall_e.pos_y + y >= 4) || (map->wall_e.pos_y + y < 0)) {\n        valid = 0;\n    } else if (hasBomb(map, map->wall_e.pos_x + x, map->wall_e.pos_y + y)) {\n        valid = 0;\n    } else {\n        valid = 1;\n        printf(\"Safe to move.\\n\");\n    }\n    return valid;\n}\n","function_prediction":"int isValidMove_name_conflict(struct bomb *bomb, int x, int y) {\n  if (bomb->x + x < 0 || bomb->x + x > 3) {\n    return 0;\n  }\n  if (bomb->y + y < 0 || bomb->y + y > 3) {\n    return 0;\n  }\n  if (hasBomb(bomb, bomb->x + x, bomb->y + y)) {\n    return 0;\n  }\n  puts(\"Safe to move.\");\n  return 1;\n}","pass":0}
{"function":"bool hasGold(struct Workspace *map) {\n    printf(\"Checking if gold is encountered.\\n\");\n    updateWorkspace(map);\n    int pos_x = map->wall_e.pos_x;\n    int pos_y = map->wall_e.pos_y;\n    if ((map->gb1.pos_x == pos_x) && (map->gb1.pos_y == pos_y) && map->gb1.available) {\n        printf(\"Found gold!\\n\");\n        return 1;\n    }\n    if ((map->gb2.pos_x == pos_x) && (map->gb2.pos_y == pos_y) && map->gb2.available) {\n        printf(\"Found gold!\\n\");\n        return 1;\n    }\n    printf(\"Gold not found.\\n\");\n    return 0;\n}\n","function_prediction":"int hasGold_name_conflict(struct workspace *ws) {\n  puts(\"Checking if gold is encountered.\");\n  updateWorkspace(ws);\n  if (ws->player.x == ws->gold1.x && ws->player.y == ws->gold1.y &&\n      ws->gold1.visible) {\n    puts(\"Found gold!\");\n    return 1;\n  }\n  if (ws->player.x == ws->gold2.x && ws->player.y == ws->gold2.y &&\n      ws->gold2.visible) {\n    puts(\"Found gold!\");\n    return 1;\n  }\n  puts(\"Gold not found.\");\n  return 0;\n}","pass":0}
{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)((double)rand() / ((double)((unsigned)RAND_MAX + 1)) *\n                        ((double)max - (double)min + 1.0)));\n}","pass":1}
{"function":"bool MapHasGold(struct Workspace *map) {\n    printf(\"Map has %d gold bar(s).\\n\", map->n_gold);\n    return (map->n_gold > 0);\n}\n","function_prediction":"bool MapHasGold_name_conflict(Map *map) {\n  printf(\"Map has %d gold bar(s).\\n\", map->gold);\n  return map->gold > 0;\n}","pass":0}
{"function":"bool hasBomb(struct Workspace *map, int x, int y) {\n    bool bmb = 0;\n    if (map->pos[x][y] == 'B') {\n        bmb = 1;\n        printf(\"Bomb has been found, not moving.\\n\");\n    }\n    return bmb;\n}\n","function_prediction":"int hasBomb_name_conflict(char **board, int x, int y) {\n  if (board[x][y] == 'B') {\n    puts(\"Bomb has been found, not moving.\");\n    return 1;\n  }\n  return 0;\n}","pass":1}
{"function":"bool hasGold(struct Workspace *map, int x, int y) {\n    bool gold = 0;\n    if (map->pos[x][y] == 'G') {\n        gold = 1;\n        printf(\"Bomb has been found, not moving.\\n\");\n    }\n    return gold;\n}\n","function_prediction":"int hasGold_name_conflict(char **map, int x, int y) {\n  if (map[x][y] == 'G') {\n    puts(\"Bomb has been found, not moving.\");\n    return 1;\n  }\n  return 0;\n}","pass":1}
{"function":"bool foundGold(struct Workspace *map) {\n    printf(\"Checking if gold is encountered.\\n\");\n    updateWorkspace(map);\n    int pos_x = map->wall_e.pos_x;\n    int pos_y = map->wall_e.pos_y;\n    if ((map->gb1.pos_x == pos_x) && (map->gb1.pos_y == pos_y) && map->gb1.available) {\n        printf(\"Found gold!\\n\");\n        return 1;\n    }\n    if ((map->gb2.pos_x == pos_x) && (map->gb2.pos_y == pos_y) && map->gb2.available) {\n        printf(\"Found gold!\\n\");\n        return 1;\n    }\n    printf(\"Gold not found.\\n\");\n    return 0;\n}\n","function_prediction":"int foundGold_name_conflict(struct workspace *ws) {\n  puts(\"Checking if gold is encountered.\");\n  updateWorkspace(ws);\n  if (ws->player.x == ws->gold1.x && ws->player.y == ws->gold1.y &&\n      ws->gold1.visible) {\n    puts(\"Found gold!\");\n    return 1;\n  }\n  if (ws->player.x == ws->gold2.x && ws->player.y == ws->gold2.y &&\n      ws->gold2.visible) {\n    puts(\"Found gold!\");\n    return 1;\n  }\n  puts(\"Gold not found.\");\n  return 0;\n}","pass":0}
{"function":"int getRandom(int rangeLow, int rangeHigh) {\n    double myRand = rand() / (1. + 2147483647);\n    int range = rangeHigh - rangeLow + 1;\n    int myRand_scaled = (myRand * range) + rangeLow;\n    return myRand_scaled;\n}\n","function_prediction":"int getRandom_name_conflict(int min, int max) {\n  return (int)((double)min +\n               (double)((double)rand() / ((double)((unsigned)RAND_MAX + 1)) *\n                        ((double)max - (double)min + 1.0)));\n}","pass":1}
{"function":"bool MapHasGold(struct Workspace *map) {\n    printf(\"Map has %d gold bar(s).\\n\", map->n_gold);\n    return (map->n_gold > 0);\n}\n","function_prediction":"bool MapHasGold_name_conflict(Map *map) {\n  printf(\"Map has %d gold bar(s).\\n\", map->gold);\n  return map->gold > 0;\n}","pass":0}
{"function":"bool hasBomb(struct Workspace *map, int x, int y) {\n    bool bmb = 0;\n    if (map->pos[x][y] == 'B') {\n        bmb = 1;\n        printf(\"Bomb has been found, not moving.\\n\");\n    }\n    return bmb;\n}\n","function_prediction":"int hasBomb_name_conflict(char **board, int x, int y) {\n  if (board[x][y] == 'B') {\n    puts(\"Bomb has been found, not moving.\");\n    return 1;\n  }\n  return 0;\n}","pass":1}
{"function":"bool hasGold(struct Workspace *map, int x, int y) {\n    bool gold = 0;\n    if (map->pos[x][y] == 'G') {\n        gold = 1;\n        printf(\"Bomb has been found, not moving.\\n\");\n    }\n    return gold;\n}\n","function_prediction":"int hasGold_name_conflict(char **map, int x, int y) {\n  if (map[x][y] == 'G') {\n    puts(\"Bomb has been found, not moving.\");\n    return 1;\n  }\n  return 0;\n}","pass":1}
{"function":"bool foundGold(struct Workspace *map) {\n    printf(\"Checking if gold is encountered.\\n\");\n    updateWorkspace(map);\n    int pos_x = map->wall_e.pos_x;\n    int pos_y = map->wall_e.pos_y;\n    if ((map->gb1.pos_x == pos_x) && (map->gb1.pos_y == pos_y) && map->gb1.available) {\n        printf(\"Found gold!\\n\");\n        return 1;\n    }\n    if ((map->gb2.pos_x == pos_x) && (map->gb2.pos_y == pos_y) && map->gb2.available) {\n        printf(\"Found gold!\\n\");\n        return 1;\n    }\n    printf(\"Gold not found.\\n\");\n    return 0;\n}\n","function_prediction":"int foundGold_name_conflict(struct workspace *ws) {\n  puts(\"Checking if gold is encountered.\");\n  updateWorkspace(ws);\n  if (ws->player.x == ws->gold1.x && ws->player.y == ws->gold1.y &&\n      ws->gold1.visible) {\n    puts(\"Found gold!\");\n    return 1;\n  }\n  if (ws->player.x == ws->gold2.x && ws->player.y == ws->gold2.y &&\n      ws->gold2.visible) {\n    puts(\"Found gold!\");\n    return 1;\n  }\n  puts(\"Gold not found.\");\n  return 0;\n}","pass":0}
{"function":"compare_t DescendingOrder(unsigned int left, unsigned int right) {\n    compare_t ret;\n    if (left == right)\n        ret = Tie_e;\n    else if (left > right)\n        ret = LeftWins_e;\n    else if (left < right)\n        ret = RightWins_e;\n    return ret;\n}\n","function_prediction":"int DescendingOrder_name_conflict(int a, int b) {\n  int result;\n\n  if (a == b) {\n    result = 0;\n  } else if (a > b) {\n    result = 1;\n  } else if (a < b) {\n    result = 2;\n  }\n\n  return result;\n}","pass":0}
{"function":"compare_t AscendingOrder(unsigned int left, unsigned int right) {\n    compare_t ret;\n    if (left == right)\n        ret = Tie_e;\n    else if (left > right)\n        ret = RightWins_e;\n    else if (left < right)\n        ret = LeftWins_e;\n    return ret;\n}\n","function_prediction":"int AscendingOrder_name_conflict(int a, int b) {\n  int result = 0;\n\n  if (a == b) {\n    result = 0;\n  } else if (a < b) {\n    result = 1;\n  } else if (a > b) {\n    result = 2;\n  }\n\n  return result;\n}","pass":0}
{"function":"unsigned long long fn(int n) {\n    if (!n)\n        return a % 10000007;\n    if (n == 1)\n        return b % 10000007;\n    if (n == 2)\n        return c % 10000007;\n    if (n == 3)\n        return d % 10000007;\n    if (n == 4)\n        return e % 10000007;\n    if (n == 5)\n        return f % 10000007;\n    if (memo[n] != -1)\n        return memo[n];\n    else\n        memo[n] = (fn(n - 1) + fn(n - 2) + fn(n - 3) + fn(n - 4) + fn(n - 5) + fn(n - 6)) % 10000007;\n    return memo[n];\n}\n","function_prediction":"long long fn_name_conflict(int n) {\n  if (n == 0)\n    return a % 1000003;\n  if (n == 1)\n    return b % 1000003;\n  if (n == 2)\n    return c % 1000003;\n  if (n == 3)\n    return d % 1000003;\n  if (n == 4)\n    return e % 1000003;\n  if (n == 5)\n    return f % 1000003;\n  if (memo[n] != -1)\n    return memo[n];\n  memo[n] = (fn_name_conflict(n - 1) + fn_name_conflict(n - 2) +\n             fn_name_conflict(n - 3) + fn_name_conflict(n - 4) +\n             fn_name_conflict(n - 5) + fn_name_conflict(n - 6)) %\n            1000003;\n  return memo[n];\n}","pass":1}
{"function":"int cycle(int a) {\n    int n = 1;\n    while (a != 1)\n        {\n            if (a % 2) {\n                a = 3 * a + 1;\n            } else {\n                a /= 2;\n            }\n            n++;\n        }\n    return n;\n}\n","function_prediction":"int cycle_name_conflict(int n) {\n  int c = 1;\n  while (n != 1) {\n    if (n % 2 == 0) {\n      n /= 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    c++;\n  }\n  return c;\n}","pass":1}
{"function":"unsigned long f91(unsigned long input) {\n    if (input <= 100) {\n        input = input + 11;\n        return f91(f91(input));\n    } else if (input >= 101) {\n        return input - 10;\n    }\n}\n","function_prediction":"int f91_name_conflict(int n) {\n  if (n <= 100)\n    return f91_name_conflict(f91_name_conflict(n + 11));\n  else\n    return n - 10;\n}","pass":0}
{"function":"int leap(unsigned long long n) {\n    return (n % 400 == 0 || n % 100 != 0) && n % 4 == 0 ? 1 : 0;\n}\n","function_prediction":"int leap_name_conflict(int year) {\n  return (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0));\n}","pass":0}
{"function":"int huluculu(unsigned long long n) {\n    return n % 15 ? 0 : 1;\n}\n","function_prediction":"int huluculu_name_conflict(int year) { return (year % 15 == 0); }","pass":0}
{"function":"int bulukulu(unsigned long long n) {\n    return (n % 400 == 0 || n % 100 != 0) && n % 55 == 0 ? 1 : 0;\n}\n","function_prediction":"int bulukulu_name_conflict(int year) {\n  if (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0))\n    return 1;\n  else\n    return 0;\n}","pass":0}
{"function":"int prime(int input) {\n    if (input < 2)\n        return 0;\n    else {\n        int i;\n        for (i = 2; i < input; i++) {\n            if (input % i == 0) {\n                return 0;\n            }\n        }\n        return 1;\n    }\n}\n","function_prediction":"int prime_name_conflict(int n) {\n  int i;\n  if (n < 2)\n    return 0;\n  for (i = 2; i < n; i++)\n    if (n % i == 0)\n      return 0;\n  return 1;\n}","pass":1}
{"function":"char *count_digits(int num, unsigned int count[]) {\n    while (num != 0)\n        {\n            count[num % 10] += 1;\n            num /= 10;\n        }\n}\n","function_prediction":"void count_digits_name_conflict(int n, int *digits) {\n  while (n) {\n    digits[n % 10]++;\n    n /= 10;\n  }\n}","pass":0}
{"function":"int fac(int n) {\n    if (n < 2)\n        return (1);\n    return (n) * fac(n - 1);\n}\n","function_prediction":"int fac_name_conflict(int n) {\n  if (n < 2)\n    return 1;\n  return n * fac_name_conflict(n - 1);\n}","pass":1}
{"function":"char *reverse(char *s) {\n    register char t, *p = s, *q = (s + (strlen(s) - 1));\n    while (p < q)\n        {\n            t = *p;\n            *p++ = *q;\n            *q-- = t;\n        }\n    return (s);\n}\n","function_prediction":"char *reverse_name_conflict(char *s) {\n  char *p = s;\n  char *q = s + strlen(s) - 1;\n  char t;\n\n  while (p < q) {\n    t = *p;\n    *p = *q;\n    *q = t;\n    p++;\n    q--;\n  }\n\n  return s;\n}","pass":1}
{"function":"int *create(int size) {\n    int *arr, i;\n    arr = (int *)malloc(sizeof(int) * size);\n    for (i = 0; i < size; i++) {\n        printf(\"enter the element number %d\\n\", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n    printf(\"\\n\");\n    return arr;\n}\n","function_prediction":"int *create_name_conflict(int n) {\n  int *p, i;\n  p = (int *)malloc(n * sizeof(int));\n  for (i = 0; i < n; i++) {\n    printf(\"enter the element number %d\\n\", i + 1);\n    __isoc99_scanf(\"%d\", p + i);\n  }\n  printf(\"\\n\");\n  return p;\n}","pass":0}
{"function":"int *merge(int *a, int *b, int s1, int s2) {\n    int i, j, k;\n    int *arr;\n    int size = s1 + s2;\n    arr = (int *)malloc(sizeof(int) * (size));\n    for (k = 0 , j = 0 , i = 0; i <= size; i++) {\n        if (a[k] < b[j]) {\n            arr[i] = a[k];\n            k++;\n            if (k >= s1) {\n                for (i++; j < s2; j++ , i++)\n                    arr[i] = b[j];\n            }\n        } else {\n            arr[i] = b[j];\n            j++;\n            if (j >= s2) {\n                for (i++; k < s1; k++ , i++)\n                    arr[i] = a[k];\n            }\n        }\n    }\n    return arr;\n}\n","function_prediction":"int *merge_name_conflict(int *a, int *b, int a_size, int b_size) {\n  int *c = malloc(sizeof(int) * (a_size + b_size));\n  int i = 0, j = 0, k = 0;\n  while (k <= a_size + b_size) {\n    if (a[i] < b[j]) {\n      c[k] = a[i];\n      i++;\n      if (i >= a_size) {\n        for (k++; j < b_size; j++, k++)\n          c[k] = b[j];\n      }\n    } else {\n      c[k] = b[j];\n      j++;\n      if (j >= b_size) {\n        for (k++; i < a_size; i++, k++)\n          c[k] = a[i];\n      }\n    }\n    k++;\n  }\n  return c;\n}","pass":0}
{"function":"int gcd(int a, int b) {\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n","function_prediction":"int gcd_name_conflict(int a, int b) {\n  if (a == 0)\n    return b;\n  return gcd_name_conflict(b % a, a);\n}","pass":1}
{"function":"int lawOfSines(side, angleA, angleC)\n    int side;\n    int angleA;\n    int angleC;\n {\n    int newSide;\n    newSide = side * (sin((angleA * 3.1400000000000001) / 180)) / sin((angleC * 3.1400000000000001) / 180);\n    return abs(newSide);\n}\n","function_prediction":"int lawOfSines_name_conflict(int a, int b, int c) {\n  double x = a * sin(b * 3.14159265358979323846 / 180) /\n             sin(c * 3.14159265358979323846 / 180);\n  return x > 0 ? x : -x;\n}","pass":1}
{"function":"int ThirdAngleCalc(angleA, angleB)\n    int angleA;\n    int angleB;\n {\n    int angleC;\n    angleC = (180 - (angleA + angleB));\n    return angleC;\n}\n","function_prediction":"int ThirdAngleCalc_name_conflict(int angle1, int angle2) {\n  return 180 - (angle1 + angle2);\n}","pass":1}
{"function":"int AAS() {\n    int angleA;\n    int angleB;\n    int angleC;\n    int sidea;\n    int sideb;\n    int sidec;\n    puts(\"Enter your first angle:\");\n    scanf(\" %d\", &angleA);\n    puts(\"Enter your second angle:\");\n    scanf(\" %d\", &angleC);\n    puts(\"Enter your side:\");\n    scanf(\" %d\", &sidec);\n    angleB = (180 - (angleA + angleC));\n    sidea = lawOfSines(sidec, angleA, angleC);\n    sideb = lawOfSines(sidec, angleB, angleC);\n    drawing(sidea, sideb, sidec, angleA, angleB, angleC);\n}\n","function_prediction":"void AAS_name_conflict() {\n  int a, b, c, d, e, f;\n  printf(\"Enter your first angle:\\n\");\n  scanf(\"%d\", &a);\n  printf(\"Enter your second angle:\\n\");\n  scanf(\"%d\", &b);\n  printf(\"Enter your side:\\n\");\n  scanf(\"%d\", &c);\n  d = 180 - (a + b);\n  e = lawOfSines(c, a, b);\n  f = lawOfSines(c, d, b);\n  drawing(e, f, c, a, d, b);\n}","pass":0}
{"function":"int ASA() {\n    int angleA;\n    int angleB;\n    int angleC;\n    int sidea;\n    int sideb;\n    int sidec;\n    puts(\"Enter your first angle:\");\n    scanf(\" %d\", &angleA);\n    puts(\"Enter your second angle:\");\n    scanf(\" %d\", &angleB);\n    puts(\"Enter your side:\");\n    scanf(\" %d\", &sidec);\n    angleC = (180 - (angleA + angleB));\n    sidea = lawOfSines(sidec, angleA, angleC);\n    sideb = lawOfSines(sidec, angleB, angleC);\n    drawing(sidea, sideb, sidec, angleA, angleB, angleC);\n}\n","function_prediction":"void ASA_name_conflict() {\n  int a, b, c, s, A, B;\n  printf(\"Enter your first angle:\\n\");\n  scanf(\"%d\", &a);\n  printf(\"Enter your second angle:\\n\");\n  scanf(\"%d\", &b);\n  printf(\"Enter your side:\\n\");\n  scanf(\"%d\", &s);\n  c = 180 - (a + b);\n  A = lawOfSines(s, a, c);\n  B = lawOfSines(s, b, c);\n  drawing(A, B, s, a, b, c);\n}","pass":0}
{"function":"int SAS() {\n    int angleA;\n    int angleB;\n    int angleC;\n    int sidea;\n    int sideb;\n    int sidec;\n    int hold;\n    puts(\"Enter your first angle:\");\n    scanf(\" %d\", &angleA);\n    puts(\"Enter your first side:\");\n    scanf(\" %d\", &sideb);\n    puts(\"Enter your second side:\");\n    scanf(\" %d\", &sidec);\n    if (sideb > sidec) {\n        hold = sidec;\n        sidec = sideb;\n        sideb = hold;\n    }\n    sidea = sqrt((sideb * sideb) + (sidec * sidec) - ((2 * sideb * sidec) * (cos((3.1400000000000001 / 180) * (angleA)))));\n    angleB = (180 / 3.1400000000000001) * (asin(((sin((3.1400000000000001 / 180) * (angleA)) * sideb) / sidea)));\n    angleC = 180 - (angleA + angleB);\n    drawing(sidea, sideb, sidec, angleA, angleB, angleC);\n}\n","function_prediction":"void SAS_name_conflict() {\n  int a, b, c, A, B, C;\n  double d;\n  puts(\"Enter your first angle:\");\n  scanf(\"%d\", &A);\n  puts(\"Enter your first side:\");\n  scanf(\"%d\", &a);\n  puts(\"Enter your second side:\");\n  scanf(\"%d\", &b);\n  if (a < b) {\n    c = a;\n    a = b;\n    b = c;\n  }\n  c = sqrt(a * a + b * b - 2 * a * b * cos(A * 3.14159265358979323846 / 180));\n  B = asin(a * sin(A * 3.14159265358979323846 / 180) / c) * 180 /\n      3.14159265358979323846;\n  C = 180 - A - B;\n  drawing(a, b, c, A, B, C);\n}","pass":0}
{"function":"int SSS() {\n    float angleA;\n    float angleB;\n    float angleC;\n    float sidea;\n    float sideb;\n    float sidec;\n    puts(\"Enter your first side:\");\n    scanf(\" %f\", &sidea);\n    puts(\"Enter your second side:\");\n    scanf(\" %f\", &sideb);\n    puts(\"Enter your third side:\");\n    scanf(\" %f\", &sidec);\n    angleA = (180 / 3.1400000000000001) * acos((((sideb * sideb) + (sidec * sidec)) - (sidea * sidea)) / (2 * sideb * sidec));\n    angleB = (180 / 3.1400000000000001) * acos((((sidec * sidec) + (sidea * sidea)) - (sideb * sideb)) / (2 * sidec * sidea));\n    angleC = ThirdAngleCalc((int)angleA, (int)angleB);\n    drawing((int)sidea, (int)sideb, (int)sidec, (int)angleA, (int)angleB, (int)angleC);\n}\n","function_prediction":"void SSS_name_conflict() {\n  float a, b, c, A, B, C;\n  puts(\"Enter your first side:\");\n  __isoc99_scanf(\"%f\", &a);\n  puts(\"Enter your second side:\");\n  __isoc99_scanf(\"%f\", &b);\n  puts(\"Enter your third side:\");\n  __isoc99_scanf(\"%f\", &c);\n  A = acos((b * b + c * c - a * a) / (2 * b * c)) * 180 /\n      3.14159265358979323846;\n  B = acos((a * a + c * c - b * b) / (2 * a * c)) * 180 /\n      3.14159265358979323846;\n  C = ThirdAngleCalc(a, b, c);\n  drawing(a, b, c, A, B, C);\n}","pass":0}
{"function":"int drawing(sidea, sideb, sidec, angleA, angleB, angleC)\n    int sidea;\n    int sideb;\n    int sidec;\n    int angleA;\n    int angleB;\n    int angleC;\n {\n    printf(\"Your sides are:\\t %d \\t %d \\t %d \\n\", sidea, sideb, sidec);\n    printf(\"And your angles are:\\t %d \\t %d \\t %d \\n\", angleA, angleB, angleC);\n    if (sidea == sideb && sideb == sidec) {\n        puts(\"You made an equillateral triangle!\");\n    } else if (angleA == 90 || angleB == 90 || angleC == 90) {\n        puts(\"You made a right triangle!\");\n    } else if (angleA == angleB || angleB == angleC || angleC == angleA) {\n        puts(\"You made an isoceles triangle!\");\n    } else if (sidea != sideb && sideb != sidec && sidec != sidea) {\n        puts(\"You made a scalene triangle!\");\n    }\n}\n","function_prediction":"void drawing_name_conflict(int a, int b, int c, int A, int B, int C) {\n  printf(\"Your sides are:\\t %d \\t %d \\t %d \\n\", a, b, c);\n  printf(\"And your angles are:\\t %d \\t %d \\t %d \\n\", A, B, C);\n\n  if (a == b && b == c)\n    printf(\"You made an equillateral triangle!\\n\");\n  else if (A == 90 || B == 90 || C == 90)\n    printf(\"You made a right triangle!\\n\");\n  else if (A == B || B == C || C == A)\n    printf(\"You made an isoceles triangle!\\n\");\n  else if (a != b && b != c && c != a)\n    printf(\"You made a scalene triangle!\\n\");\n}","pass":0}
{"function":"int get_huxi(char *cards) {\n    int huxi = get_kan_huxi(cards);\n    int sum = 0;\n    for (int i = 0; i < 20; i++) {\n        sum += cards[i];\n    }\n    if (sum % 3 == 0) {\n        int other_huxi = get_shun_huxi_xiao(cards);\n        if (other_huxi < 0) {\n            return -1;\n        }\n        return huxi + other_huxi;\n    }\n    int max_huxi = -1;\n    char tmp_cards[20];\n    for (int i = 0; i < 20; i++) {\n        if (cards[i] != 2)\n            continue;\n        memcpy(tmp_cards, cards, 20);\n        tmp_cards[i] -= 2;\n        int other_huxi = get_shun_huxi_xiao(tmp_cards);\n        if (other_huxi > max_huxi)\n            max_huxi = other_huxi;\n    }\n    if (max_huxi < 0)\n        return -1;\n    return max_huxi + huxi;\n}\n","function_prediction":"int get_huxi_name_conflict(char *p) {\n  int i, j, k, kan_huxi, shun_huxi, shun_huxi_temp, sum;\n  char temp[20];\n\n  kan_huxi = get_kan_huxi(p);\n\n  sum = 0;\n  for (i = 0; i < 20; i++)\n    sum += p[i];\n\n  if (sum % 3 == 0) {\n    shun_huxi = get_shun_huxi_xiao(p);\n    if (shun_huxi < 0)\n      shun_huxi = -1;\n    else\n      shun_huxi += kan_huxi;\n  } else {\n    shun_huxi = -1;\n    for (i = 0; i < 20; i++) {\n      if (p[i] == 2) {\n        for (j = 0; j < 20; j++)\n          temp[j] = p[j];\n        temp[i] -= 2;\n        shun_huxi_temp = get_shun_huxi_xiao(temp);\n        if (shun_huxi_temp > shun_huxi)\n          shun_huxi = shun_huxi_temp;\n      }\n    }\n    if (shun_huxi < 0)\n      shun_huxi = -1;\n    else\n      shun_huxi += kan_huxi;\n  }\n\n  return shun_huxi;\n}","pass":1}
{"function":"int get_kan_huxi(char *cards) {\n    int huxi = 0;\n    for (int i = 0; i < 10; ++i) {\n        if (cards[i] != 3)\n            continue;\n        cards[i] = 0;\n        huxi += 3;\n    }\n    for (int i = 10; i < 20; ++i) {\n        if (cards[i] != 3)\n            continue;\n        cards[i] = 0;\n        huxi += 6;\n    }\n    return huxi;\n}\n","function_prediction":"int get_kan_huxi_name_conflict(char *str) {\n  int i, j, k;\n  k = 0;\n  for (i = 0; i < 10; i++) {\n    if (str[i] == 3) {\n      str[i] = 0;\n      k += 3;\n    }\n  }\n  for (j = 10; j < 20; j++) {\n    if (str[j] == 3) {\n      str[j] = 0;\n      k += 6;\n    }\n  }\n  return k;\n}","pass":1}
{"function":"int get_shun_huxi_xiao(char *cards) {\n    struct Item items[7];\n    memset(items, 0, sizeof (items));\n    int cur_card = 0;\n    int cur_item = -1;\n    int find = 1;\n    int max_huxi = -1;\n    while (1)\n        {\n            if (find) {\n                find = 0;\n                int finded = 0;\n                if (cur_item == 7) {\n                    *(int *)0 = 0;\n                }\n                for (int i = cur_card; i < 10; i++) {\n                    if (cards[i] != 0) {\n                        cur_card = i;\n                        ++cur_item;\n                        items[cur_item].card = cur_card;\n                        finded = 1;\n                        break;\n                    }\n                }\n                if (finded == 0) {\n                    int huxi = 0;\n                    for (int i = 0; i <= cur_item; ++i) {\n                        huxi += items[i].huxi;\n                    }\n                    int da_huxi = get_shun_huxi_da(cards);\n                    if (da_huxi >= 0) {\n                        if (da_huxi + huxi > max_huxi) {\n                            max_huxi = da_huxi + huxi;\n                        }\n                    }\n                    goto huisu;\n                }\n            }\n            if (items[cur_item].i == 0) {\n                items[cur_item].i = 1;\n                if (cur_card < 8 && cards[cur_card + 1] > 0 && cards[cur_card + 2] > 0) {\n                    items[cur_item].j = 1;\n                    items[cur_item].card = cur_card;\n                    --cards[cur_card];\n                    --cards[cur_card + 1];\n                    --cards[cur_card + 2];\n                    find = 1;\n                    if (cur_card == 0) {\n                        items[cur_item].huxi = 3;\n                    }\n                    continue;\n                }\n            }\n            if (items[cur_item].i == 1) {\n                items[cur_item].i = 2;\n                if (cards[cur_card] == 2 && cards[cur_card + 10] >= 1) {\n                    items[cur_item].j = 2;\n                    cards[cur_card] -= 2;\n                    --cards[cur_card + 10];\n                    find = 1;\n                    continue;\n                }\n            }\n            if (items[cur_item].i == 2) {\n                items[cur_item].i = 3;\n                if (cards[cur_card + 10] == 2) {\n                    items[cur_item].j = 3;\n                    cards[cur_card + 10] -= 2;\n                    --cards[cur_card];\n                    find = 1;\n                    continue;\n                }\n            }\n            if (items[cur_item].i == 3) {\n                items[cur_item].i = 4;\n                if (cur_card == 1 && cards[6] > 0 && cards[9] > 0) {\n                    items[cur_item].j = 4;\n                    items[cur_item].huxi = 3;\n                    find = 1;\n                    --cards[1];\n                    --cards[6];\n                    --cards[9];\n                    continue;\n                }\n            }\n          huisu:\n            if (cur_item < 0)\n                goto finish;\n            if (items[cur_item].i == 0 || (items[cur_item].i == 4 && items[cur_item].j != 4)) {\n                memset(&items[cur_item], 0, sizeof(struct Item));\n                if (cur_item == 0)\n                    goto finish;\n                --cur_item;\n                goto huisu;\n            }\n            cur_card = items[cur_item].card;\n            if (items[cur_item].i > 0 && items[cur_item].i == items[cur_item].j) {\n                items[cur_item].huxi = 0;\n                if (items[cur_item].j == 1) {\n                    ++cards[cur_card];\n                    ++cards[cur_card + 1];\n                    ++cards[cur_card + 2];\n                } else if (items[cur_item].j == 2) {\n                    cards[cur_card] += 2;\n                    ++cards[cur_card + 10];\n                } else if (items[cur_item].j == 3) {\n                    cards[cur_card + 10] += 2;\n                    ++cards[cur_card];\n                } else if (items[cur_item].j == 4) {\n                    ++cards[1];\n                    ++cards[6];\n                    ++cards[9];\n                    memset(&items[cur_item], 0, sizeof(struct Item));\n                    if (cur_item == 0)\n                        goto finish;\n                    --cur_item;\n                    goto huisu;\n                }\n            }\n        }\n  finish:\n    return max_huxi;\n}\n","function_prediction":"int get_shun_huxi_xiao_name_conflict(char *arr) {\n  int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n  int arr_temp[10];\n  int arr_temp_2[10];\n  int arr_temp_3[10];\n  int arr_temp_4[10];\n  int arr_temp_5[10];\n  int arr_temp_6[10];\n  int arr_temp_7[10];\n  int arr_temp_8[10];\n  int arr_temp_9[10];\n  int arr_temp_10[10];\n  int arr_temp_11[10];\n  int arr_temp_12[10];\n  int arr_temp_13[10];\n  int arr_temp_14[10];\n  int arr_temp_15[10];\n  int arr_temp_16[10];\n  int arr_temp_17[10];\n  int arr_temp_18[10];\n  int arr_temp_19[10];\n  int arr_temp_20[10];\n  int arr_temp_21[10];\n  int arr_temp_22[10];\n  int arr_temp_23[10];\n  int arr_temp_24[10];\n  int arr_temp_25[10];\n  int arr_temp_26[10];\n  int arr_temp_27[10];\n  int arr_temp_28[10];\n  int arr_temp_29[10];\n  int arr_temp_30[10];\n  int arr_temp_31[10];\n  int arr_temp_32[10];\n  int arr_temp_33[10];\n  int arr_temp_34[10];\n  int arr_temp_35[10];\n  int arr_temp_36[10];\n  int arr_temp_37[10];\n  int arr_temp_38[10];\n  int arr_temp_39[10];","pass":0}
{"function":"int get_shun_huxi_da(char *cards) {\n    if (cards[10] > cards[11] || cards[10] > cards[12])\n        return -1;\n    int sum = 0;\n    for (int i = 10; i < 20; ++i) {\n        sum += cards[i];\n    }\n    if (sum == 0) {\n        return 0;\n    }\n    char tmp_cards[10];\n    memcpy(tmp_cards, &cards[10], 10);\n    int n_123 = tmp_cards[0];\n    tmp_cards[0] = 0;\n    tmp_cards[1] -= n_123;\n    tmp_cards[2] -= n_123;\n    int max_huxi = -1;\n    for (int i = 0; i < 5; ++i) {\n        memcpy(tmp_cards, &cards[10], 10);\n        tmp_cards[0] = 0;\n        tmp_cards[1] -= n_123;\n        tmp_cards[2] -= n_123;\n        if (tmp_cards[1] < i || tmp_cards[6] < i || tmp_cards[9] < i) {\n            break;\n        }\n        int huxi = get_shun_huxi_da_without_2_7_10(tmp_cards, i);\n        if (huxi < 0)\n            continue;\n        if (huxi + n_123 * 6 > max_huxi)\n            max_huxi = huxi + n_123 * 6;\n    }\n    return max_huxi;\n}\n","function_prediction":"int get_shun_huxi_da_without_2_7_10(char *p, int da) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int sum, max, temp;\n\n  if (p[10] > p[11] || p[12] > p[11])\n    return -1;\n\n  sum = 0;\n  for (i = 10; i < 19; i++)\n    sum += p[i];\n\n  if (sum == 0)\n    return 0;\n\n  max = -1;\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 3; j++) {\n      if (p[11] - i < 0 || p[11] - i < i)\n        return max;\n      if (p[14] - i < 0 || p[14] - i < i)\n        return max;\n      if (p[16] - i < 0 || p[16] - i < i)\n        return max;\n    }\n\n    temp = get_shun_huxi_da_without_2_7_10(p, i);\n    if (temp >= 0) {\n      if (temp + i * 6 > max)\n        max = temp + i * 6;\n    }\n  }\n\n  return max;\n}","pass":0}
{"function":"int get_shun_huxi_da_without_2_7_10(char *cards, int num) {\n    char tmp_cards[10];\n    memcpy(tmp_cards, cards, 10);\n    tmp_cards[1] -= num;\n    tmp_cards[6] -= num;\n    tmp_cards[9] -= num;\n    for (int i = 0; i < 10; ++i) {\n        int n = tmp_cards[i];\n        if (n == 0)\n            continue;\n        if (i + 2 >= 10)\n            return -1;\n        if (tmp_cards[i + 1] < n || tmp_cards[i + 2] < tmp_cards[i + 1])\n            return -1;\n        tmp_cards[i + 1] -= n;\n        tmp_cards[i + 2] -= n;\n    }\n    return num * 6;\n}\n","function_prediction":"int get_shun_huxi_da_without_2_7_10_name_conflict(const int *hand, int num) {\n  int i;\n  int count = 0;\n  int temp[6];\n\n  temp[0] = hand[0] / 256;\n  temp[1] = hand[0] / 4096;\n  temp[2] = hand[1] / 256;\n\n  for (i = 0; i < 6; i++) {\n    if (temp[i] == 0)\n      continue;\n    if (i >= 7)\n      return -1;\n    if (temp[i] > temp[i + 1] || temp[i] > temp[i + 2])\n      return -1;\n    temp[i + 1] -= temp[i];\n    temp[i + 2] -= temp[i];\n    count++;\n  }\n\n  return count * num;\n}","pass":1}
{"function":"int test_all(char *name) {\n    read_all(name);\n    for (int i = 0; i < cards_buf_len; ++i) {\n        int huxi = get_huxi(&cards_buf[i * 21]);\n        int table_huxi = cards_buf[i * 21 + 20];\n        if (huxi != table_huxi) {\n            printf(\"\\350\\203\\241\\346\\201\\257\\345\\210\\244\\346\\226\\255\\344\\270\\215\\345\\257\\271, \\350\\241\\250%s, \\345\\272\\217\\345\\217\\267%d, \\350\\256\\241\\347\\256\\227%d\\357\\274\\214\\350\\241\\250%d\\n\", name, i + 1, huxi, table_huxi);\n        }\n    }\n    printf(\"test_all\\346\\265\\213\\350\\257\\225%s\\345\\256\\214\\346\\210\\220\\n\", name);\n    return cards_buf_len;\n}\n","function_prediction":"int test_all_name_conflict(char *filename) {\n  int i;\n  char huxi;\n\n  read_all(filename);\n  for (i = 0; i < cards_buf_len; i++) {\n    huxi = get_huxi(cards_buf + i * 21);\n    if (huxi != cards_buf[i * 21 + 20]) {\n      printf(\"%s:%d:%c:%c\\n\", filename, i + 1, huxi, cards_buf[i * 21 + 20]);\n    }\n  }\n  printf(\"%s:done\\n\", filename);\n  return cards_buf_len;\n}","pass":1}
{"function":"int binsearch(int x, int v[], int n) {\n    int low, mid, high;\n    low = 0;\n    high = n - 1;\n    while (low <= high)\n        {\n            mid = (low + high) / 2;\n            if (x < v[mid])\n                high = mid - 1;\n            else if (x > v[mid])\n                low = mid + 1;\n            else\n                return mid;\n        }\n    return -1;\n}\n","function_prediction":"int binsearch2(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (x < v[mid])\n      high = mid - 1;\n    else if (x > v[mid])\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}","pass":0}
{"function":"int binsearch2(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    mid = (low + high) / 2;\n    while (low <= high && x != v[mid])\n        {\n            if (x < v[mid])\n                high = mid - 1;\n            else\n                low = mid + 1;\n            mid = (low + high) / 2;\n        }\n    if (x == v[mid])\n        return mid;\n    else\n        return -1;\n}\n","function_prediction":"int binsearch2_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (x < v[mid])\n      high = mid - 1;\n    else if (x > v[mid])\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}","pass":1}
{"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    while (low < high)\n        {\n            mid = (low + high) / 2;\n            if (x <= v[mid])\n                high = mid;\n            else\n                low = mid + 1;\n        }\n    return (x == v[low]) ? low : -1;\n}\n","function_prediction":"int binsearch_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  while (low < high) {\n    mid = (low + high) / 2;\n    if (x <= v[mid])\n      high = mid;\n    else\n      low = mid + 1;\n  }\n  if (x == v[low])\n    return low;\n  else\n    return -1;\n}","pass":1}
{"function":"int binsearch(int x, int v[], int n) {\n    int low, mid, high;\n    low = 0;\n    high = n - 1;\n    while (low <= high)\n        {\n            mid = (low + high) / 2;\n            if (x < v[mid])\n                high = mid - 1;\n            else if (x > v[mid])\n                low = mid + 1;\n            else\n                return mid;\n        }\n    return -1;\n}\n","function_prediction":"int binsearch2(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = -1;\n  high = n;\n  while (low + 1 < high) {\n    mid = (low + high) / 2;\n    if (x > v[mid])\n      low = mid;\n    else\n      high = mid;\n  }\n  if (high == n || x != v[high])\n    return -1;\n  else\n    return high;\n}","pass":0}
{"function":"int binsearch2(int x, int v[], int n) {\n    int low, high, mid;\n    low = -1;\n    high = n;\n    while (low + 1 < high)\n        {\n            mid = (low + high) / 2;\n            if (v[mid] < x)\n                low = mid;\n            else\n                high = mid;\n        }\n    if (high == n || v[high] != x)\n        return -1;\n    else\n        return high;\n}\n","function_prediction":"int binsearch2_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = -1;\n  high = n;\n  while (low + 1 < high) {\n    mid = (low + high) / 2;\n    if (x > v[mid])\n      low = mid;\n    else\n      high = mid;\n  }\n  return (high == n || x != v[high]) ? -1 : high;\n}","pass":1}
{"function":"int can_print(int ch) {\n    char *printable = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 !\\\"#%&'()*+,-./:;<=>?[\\\\]^_{|}~\\t\\f\\v\\r\\n\";\n    char *s;\n    int found = 0;\n    for (s = printable; !found && *s; s++) {\n        if (*s == ch) {\n            found = 1;\n        }\n    }\n    return found;\n}\n","function_prediction":"int can_print_name_conflict(char c) {\n  int ret = 0;\n  char *str = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 \"\n              \"!\\\"#%&'()*+,-./:;<=>?[\\\\]^_{|}~\\t\\f\\v\\r\\n\";\n\n  while (!ret && *str) {\n    if (*str == c)\n      ret = 1;\n    str++;\n  }\n  return (ret);\n}","pass":0}
{"function":"char *dupstr(char *s) {\n    char *p = ((void *)0);\n    if (s) {\n        p = malloc(strlen(s) + 1);\n        if (p) {\n            strcpy(p, s);\n        }\n    }\n    return p;\n}\n","function_prediction":"char *dupstr_name_conflict(const char *s) {\n  char *p = NULL;\n  if (s) {\n    p = malloc(strlen(s) + 1);\n    if (p)\n      strcpy(p, s);\n  }\n  return p;\n}","pass":1}
{"function":"struct linelist *addlink(int line) {\n    struct linelist *new;\n    new = malloc(sizeof *new);\n    if (new != ((void *)0)) {\n        new->line = line;\n        new->next = ((void *)0);\n    }\n    return new;\n}\n","function_prediction":"link *addlink_name_conflict(int data) {\n  link *newlink = malloc(sizeof(link));\n  if (newlink) {\n    newlink->data = data;\n    newlink->next = NULL;\n  }\n  return newlink;\n}","pass":0}
{"function":"char *char_in_string(char *s, int c) {\n    char *p = ((void *)0);\n    if (s != ((void *)0)) {\n        if (c) {\n            while (*s && *s != c)\n                {\n                    ++s;\n                }\n            if (*s == c) {\n                p = s;\n            }\n        }\n    }\n    return p;\n}\n","function_prediction":"char *char_in_string_name_conflict(char *str, int c) {\n  char *p = NULL;\n\n  if (str && c) {\n    for (p = str; *p && *p != c; p++)\n      ;\n    if (*p == c)\n      return p;\n  }\n  return NULL;\n}","pass":1}
{"function":"char *tokenise(char **s, char *delims) {\n    char *p = ((void *)0);\n    char *q = ((void *)0);\n    if (s && *s && delims) {\n        while (((void *)0) != char_in_string(delims, **s))\n            {\n                ++*s;\n            }\n        if (**s) {\n            q = *s + 1;\n            p = *s;\n            while (*q && ((void *)0) == char_in_string(delims, *q))\n                {\n                    ++q;\n                }\n            *s = q + (*q != '\\x00');\n            *q = '\\x00';\n        }\n    }\n    return p;\n}\n","function_prediction":"char *tokenise_name_conflict(char **str, const char *delim) {\n  char *ret = NULL;\n\n  if (str && *str && delim) {\n    while (char_in_string(delim, **str))\n      (*str)++;\n\n    if (**str) {\n      char *p = *str;\n\n      ret = *str;\n\n      while (*++p && !char_in_string(delim, *p))\n        ;\n\n      *str = p + (*p != '\\0');\n      *p = '\\0';\n    }\n  }\n\n  return ret;\n}","pass":1}
{"function":"int NoiseWord(char *s) {\n    int found = 0;\n    int giveup = 0;\n    char *list[] = {\"a\", \"an\", \"and\", \"be\", \"but\", \"by\", \"he\", \"I\", \"off\", \"on\", \"she\", \"so\", \"the\", \"they\", \"you\"};\n    int top = sizeof list / sizeof list[0] - 1;\n    int bottom = 0;\n    int guess = top / 2;\n    int diff = 0;\n    if (s) {\n        while (!found && !giveup)\n            {\n                diff = strcmp(list[guess], s);\n                if (0 == diff) {\n                    found = 1;\n                } else if (0 < diff) {\n                    top = guess - 1;\n                } else {\n                    bottom = guess + 1;\n                }\n                if (top < bottom) {\n                    giveup = 1;\n                } else {\n                    guess = (top + bottom) / 2;\n                }\n            }\n    }\n    return found;\n}\n","function_prediction":"int NoiseWord_name_conflict(char *word) {\n  int found = 0;\n  int notfound = 0;\n  int cmp;\n  int low = 0;\n  int high = 14;\n  int mid = (low + high) / 2;\n  char *words[15] = {\"a\",   \"an\", \"and\", \"are\",  \"as\",   \"at\",\n                     \"be\",  \"by\", \"for\", \"from\", \"has\",  \"he\",\n                     \"in\",  \"is\", \"it\",  \"of\",   \"on\",   \"that\",\n                     \"the\", \"to\", \"was\", \"were\", \"will\", \"with\"};\n\n  if (word == NULL)\n    return 0;\n\n  while (!found && !notfound) {\n    cmp = strcmp(words[mid], word);\n    if (cmp == 0)\n      found = 1;\n    else if (cmp > 0)\n      high = mid - 1;\n    else\n      low = mid + 1;\n\n    if (low > high)\n      notfound = 1;\n    else\n      mid = (low + high) / 2;\n  }\n\n  return found;\n}","pass":0}
{"function":"enum token getword(char *word, int lim) {\n    int beg_line, c;\n    for (;;) {\n        beg_line = skipws();\n        c = getch();\n        if (!beg_line || c != '#')\n            break;\n        do {\n            c = getch();\n            if (c == (-1))\n                return TOK_EOF;\n        } while (c != '\\n');\n        ungetch('\\n');\n    }\n    if (c == (-1))\n        return TOK_EOF;\n    else if (c == '_' || ((*__ctype_b_loc())[(int)(((unsigned char)c))] & (unsigned short)_ISalpha)) {\n        do {\n            putch(&word, &lim, c);\n            c = getch();\n        } while (((*__ctype_b_loc())[(int)(((unsigned char)c))] & (unsigned short)_ISalnum) || c == '_');\n        ungetch(c);\n        return TOK_ID;\n    } else if (c == '\\'' || c == '\"') {\n        int quote = c;\n        word[0] = '\\x00';\n        while (getstelem(&word, &lim, quote))\n            ;\n        return quote == '\\'' ? TOK_CHAR : TOK_STRING;\n    } else\n        return (unsigned char)c;\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  int skipws(void);\n\n  while (skipws()) {\n    c = getch();\n    if (c == '#') {\n      while ((c = getch()) != EOF && c != '\\n')\n        ;\n      if (c == EOF)\n        return 259;\n      ungetch(c);\n    } else if (c == EOF)\n      return 259;\n    else if (isalpha(c) || c == '_' || c == '\"' || c == '\\'')\n      break;\n    else\n      return c;\n  }\n\n  if (c == EOF)\n    return 259;\n\n  if (isalpha(c) || c == '_') {\n    do {\n      putch(word, lim, c);\n      c = getch();\n    } while (isalnum(c) || c == '_');\n    ungetch(c);\n    return 256;\n  }\n\n  if (c == '\"' || c == '\\'') {\n    int quote = c;\n    *word = '\\0';\n    while (getstelem(&word, &lim, quote))\n      ;\n    if (quote == '\\'')\n      return 258;\n    return 257;\n  }\n\n  return c;\n}","pass":1}
{"function":"static int skipws(void) {\n    enum class {\n        CLS_WS = 0,\n        CLS_BEG_CMT,\n        CLS_END_CMT,\n        CLS_OTHER,\n        CLS_IN_CMT = 4\n    };\n    enum class in_comment = 0;\n    int beg_line = 0;\n    for (;;) {\n        int c;\n        enum class class;\n        c = getch();\n        switch (c) {\n          case '\\n':\n            if (!in_comment)\n                beg_line = 1;\n          case ' ':\n          case '\\f':\n          case '\\r':\n          case '\\t':\n          case '\\v':\n            class = CLS_WS;\n            break;\n          case '/':\n            if (!in_comment) {\n                c = getch();\n                if (c == '*')\n                    class = CLS_BEG_CMT;\n                else {\n                    ungetch(c);\n                    c = '/';\n                    class = CLS_OTHER;\n                }\n            } else\n                class = CLS_OTHER;\n            break;\n          case '*':\n            if (in_comment) {\n                c = getch();\n                if (c == '/')\n                    class = CLS_END_CMT;\n                else {\n                    ungetch(c);\n                    class = CLS_OTHER;\n                }\n            } else\n                class = CLS_OTHER;\n            break;\n          default:\n            if (c == (-1))\n                return 0;\n            class = CLS_OTHER;\n        }\n        switch (class | in_comment) {\n          case CLS_WS:\n          case CLS_WS | CLS_IN_CMT:\n          case CLS_OTHER | CLS_IN_CMT:\n            break;\n          case CLS_BEG_CMT:\n            in_comment = CLS_IN_CMT;\n            break;\n          case CLS_OTHER:\n            ungetch(c);\n            return beg_line;\n          case CLS_END_CMT | CLS_IN_CMT:\n            in_comment = 0;\n            break;\n          case CLS_BEG_CMT | CLS_IN_CMT:\n          case CLS_END_CMT:\n          default:\n            printf(\"can't happen\\n\");\n            break;\n        }\n    }\n}\n","function_prediction":"int skipws_name_conflict(void) {\n  int c;\n  int state;\n\n  while (1) {\n    c = getch();\n    switch (c) {\n    case ' ':\n    case '\\t':\n    case '\\n':\n    case '\\r':\n    case '\\f':\n    case '\\v':\n      state = 0;\n      break;\n    case '*':\n      state = 3;\n      break;\n    case '/':\n      c = getch();\n      if (c == '*')\n        state = 1;\n      else {\n        ungetch(c);\n        state = 3;\n      }\n      break;\n    case EOF:\n      return 0;\n    default:\n      state = 3;\n      break;\n    }\n    switch (state) {\n    case 0:\n      return 0;\n    case 1:\n      return 1;\n    case 3:\n      break;\n    default:\n      puts(\"can't happen\");\n      break;\n    }\n  }\n}","pass":1}
{"function":"static int getstelem(char **wordp, int *limp, int quote) {\n    int c;\n    c = getch();\n    if (c == quote || c == (-1))\n        return 0;\n    if (c != '\\\\') {\n        putch(wordp, limp, c);\n        return 1;\n    }\n    c = getch();\n    if (c == (-1))\n        return 0;\n    {\n        static const char escapes[] = {\"''??\\\"\\\"\\\\\\\\a\\ab\\bf\\fn\\nr\\rt\\tv\\v\"};\n        const char *cp = strchr(escapes, c);\n        if (cp != ((void *)0)) {\n            putch(wordp, limp, cp[1]);\n            return 1;\n        }\n    }\n    {\n        unsigned char v = 0;\n        if (c == 'x' || c == 'X')\n            for (;;) {\n                static const char hexits[] = \"0123456789abcdef\";\n                const char *p;\n                c = getch();\n                p = strchr(hexits, tolower((unsigned char)c));\n                if (p == ((void *)0))\n                    break;\n                v = v * 16 + (p - hexits);\n            }\n        else {\n            int i;\n            for (i = 0; i < 3; i++) {\n                v = v * 8 + (c - '0');\n                c = getch();\n                if (c < '0' || c > '7')\n                    break;\n            }\n        }\n        putch(wordp, limp, v);\n        ungetch(c);\n    }\n    return 1;\n}\n","function_prediction":"int getstelem_name_conflict(char *s, int *i, int delim) {\n  static struct {\n    char c;\n    char r;\n  } escapes[] = {\n      {'n', '\\n'},  {'r', '\\r'},  {'t', '\\t'},  {'v', '\\v'},\n      {'b', '\\b'},  {'f', '\\f'},  {'a', '\\a'},  {'\\\\', '\\\\'},\n      {'\\'', '\\''}, {'\\\"', '\\\"'}, {'\\?', '\\?'},\n  };\n  int c, j, k;\n\n  c = getch();\n  if (c == delim || c == -1)\n    return 0;\n  if (c == '\\\\') {\n    c = getch();\n    if (c == -1)\n      return 0;\n    for (j = 0; j < sizeof(escapes) / sizeof(escapes[0]); j++)\n      if (escapes[j].c == c) {\n        putch(s, i, escapes[j].r);\n        return 1;\n      }\n    k = 0;\n    if (c == 'x' || c == 'X') {\n      while ((c = getch()) != -1 &&\n             strchr(\"0123456789abcdef\", tolower(c)) != NULL)\n        k = k * 16 +\n            (strchr(\"0123456789abcdef\", tolower(c)) - \"0123456789abcdef\");\n    } else {\n      for (j = 0; j < 3; j++) {\n        k = k * 8 + c - '0';\n        c = getch();\n        if (c < '0' || c > '7')\n          break;\n      }\n    }\n    putch(s, i, k);\n    ungetch(c);\n    return 1;\n  }\n  putch(s, i, c);\n  return 1;\n}","pass":1}
{"function":"int getch(void) {\n    return bufp > 0 ? buf[--bufp] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  return (bufp > 0) ? buf[--bufp] : getch_name_conflictar();\n}","pass":1}
{"function":"long htoi(char s[]) {\n    char *p = &s[strlen(s) - 1];\n    long deci = 0, dig = 0;\n    int pos = 0;\n    while (p >= s)\n        {\n            if ((dig = hchartoi(*p, pos)) < 0) {\n                printf(\"Error\\n\");\n                return -1;\n            }\n            deci += dig;\n            --p;\n            ++pos;\n        }\n    return deci;\n}\n","function_prediction":"long htoi_name_conflict(char *s) {\n  char *p = s + strlen(s) - 1;\n  long n = 0;\n  int i = 0;\n  while (p >= s) {\n    long v = hchartoi(*p, i);\n    if (v < 0) {\n      puts(\"Error\");\n      return -1;\n    }\n    n += v;\n    p--;\n    i++;\n  }\n  return n;\n}","pass":0}
{"function":"long hchartoi(char hexdig, int pos) {\n    char hexdigits[] = \"0123456789ABCDEF\";\n    char *p = &hexdigits[0];\n    long deci = 0;\n    int i;\n    while (*p != toupper(hexdig) && deci < 16)\n        {\n            ++p;\n            ++deci;\n        }\n    if (*p == toupper(hexdig)) {\n        for (i = 0; i < pos; i++)\n            deci *= 16;\n        return deci;\n    }\n    return -1;\n}\n","function_prediction":"long hchartoi_name_conflict(char c, int n) {\n  char *hex = \"0123456789ABCDEF\";\n  char *p = hex;\n  long i = 0;\n  int j;\n\n  while (*p != toupper(c) && i < 16)\n    p++, i++;\n\n  if (*p != toupper(c))\n    return -1;\n\n  for (j = 0; j < n; j++)\n    i <<= 4;\n\n  return i;\n}","pass":0}
{"function":"int any(char s1[], char s2[]) {\n    int i;\n    int j;\n    int pos;\n    pos = -1;\n    for (i = 0; pos == -1 && s1[i] != '\\x00'; i++) {\n        for (j = 0; pos == -1 && s2[j] != '\\x00'; j++) {\n            if (s2[j] == s1[i]) {\n                pos = i;\n            }\n        }\n    }\n    return pos;\n}\n","function_prediction":"int any_name_conflict(char s1[], char s2[]) {\n  int i, j, k;\n\n  k = -1;\n  for (i = 0; k == -1 && s1[i] != '\\0'; i++)\n    for (j = 0; k == -1 && s2[j] != '\\0'; j++)\n      if (s1[i] == s2[j])\n        k = i;\n  return k;\n}","pass":1}
{"function":"int any(char *s1, char *s2) {\n    char array[256];\n    int i;\n    if (s1 == ((void *)0)) {\n        if (s2 == ((void *)0)) {\n            return (0);\n        } else {\n            return (-1);\n        }\n    }\n    for (i = 0; i < 256; i++) {\n        array[i] = 0;\n    }\n    while (*s2 != '\\x00')\n        {\n            array[*s2] = 1;\n            s2++;\n        }\n    i = 0;\n    while (s1[i] != '\\x00')\n        {\n            if (array[s1[i]] == 1) {\n                return (i);\n            }\n            i++;\n        }\n    return (-1);\n}\n","function_prediction":"int any_name_conflict(char *s1, char *s2) {\n  int i, j;\n  char c[256];\n\n  if (s1 == NULL)\n    return (s2 == NULL) ? 0 : -1;\n\n  for (i = 0; i < 256; i++)\n    c[i] = 0;\n\n  for (i = 0; s2[i] != '\\0'; i++)\n    c[s2[i]] = 1;\n\n  for (i = 0; s1[i] != '\\0'; i++)\n    if (c[s1[i]] == 1)\n      return i;\n\n  return -1;\n}","pass":1}
{"function":"unsigned int rightrot(unsigned int x, unsigned int n) {\n    while (n > 0)\n        {\n            if ((x & 1) == 1)\n                x = (x >> 1) | ~(~0U >> 1);\n            else\n                x = (x >> 1);\n            n--;\n        }\n    return x;\n}\n","function_prediction":"unsigned rightrot_name_conflict(unsigned x, int n) {\n  int i;\n  for (i = n; i != 0; --i)\n    if ((x & 01) == 0)\n      x >>= 1;\n    else\n      x = (x >> 1) | (~(~0U >> 1));\n  return x;\n}","pass":1}
{"function":"int lower(int c) {\n    return c >= 'A' && c <= 'Z' ? c + 'a' - 'A' : c;\n}\n","function_prediction":"int lower_name_conflict(int c) {\n  if (c >= 'A' && c <= 'Z')\n    return c + 'a' - 'A';\n  return c;\n}","pass":1}
{"function":"int hexalpha_to_int(int c) {\n    char hexalpha[] = \"aAbBcCdDeEfF\";\n    int i;\n    int answer = 0;\n    for (i = 0; answer == 0 && hexalpha[i] != '\\x00'; i++) {\n        if (hexalpha[i] == c) {\n            answer = 10 + (i / 2);\n        }\n    }\n    return answer;\n}\n","function_prediction":"int hexalpha_to_int_name_conflict(char c) {\n  char hexalpha[] = \"abcdefABCDEF\";\n  int i, ret = 0;\n\n  for (i = 0; !ret && hexalpha[i]; i++)\n    if (c == hexalpha[i])\n      ret = i / 2 + 10;\n\n  return ret;\n}","pass":0}
{"function":"unsigned int htoi(const char s[]) {\n    unsigned int answer = 0;\n    int i = 0;\n    int valid = 1;\n    int hexit;\n    if (s[i] == '0') {\n        ++i;\n        if (s[i] == 'x' || s[i] == 'X') {\n            ++i;\n        }\n    }\n    while (valid && s[i] != '\\x00')\n        {\n            answer = answer * 16;\n            if (s[i] >= '0' && s[i] <= '9') {\n                answer = answer + (s[i] - '0');\n            } else {\n                hexit = hexalpha_to_int(s[i]);\n                if (hexit == 0) {\n                    valid = 0;\n                } else {\n                    answer = answer + hexit;\n                }\n            }\n            ++i;\n        }\n    if (!valid) {\n        answer = 0;\n    }\n    return answer;\n}\n","function_prediction":"int htoi_name_conflict(char s[]) {\n  int i, n, inword, hexdigit;\n\n  i = 0;\n  if (s[i] == '0') {\n    ++i;\n    if (s[i] == 'x' || s[i] == 'X')\n      ++i;\n  }\n  n = 0;\n  inword = 1;\n  for (; inword && (s[i] != '\\0'); ++i) {\n    n = n * 16;\n    if (s[i] >= '0' && s[i] <= '9')\n      n = n + s[i] - '0';\n    else if ((hexdigit = hexalpha_to_int(s[i])) != 0)\n      n = n + hexdigit;\n    else\n      inword = 0;\n  }\n  if (!inword)\n    n = 0;\n  return n;\n}","pass":1}
{"function":"unsigned int invert(unsigned int x, int p, int n) {\n    return x ^ (~(~0U << n) << p);\n}\n","function_prediction":"uint32_t invert_name_conflict(uint32_t x, uint32_t p, uint32_t n) {\n  return x ^ (~(~0 << n) << p);\n}","pass":0}
{"function":"unsigned int setbits(unsigned int x, int p, int n, unsigned int y) {\n    return (x & ((~0 << (p + 1)) | (~(~0 << (p + 1 - n))))) | ((y & ~(~0 << n)) << (p + 1 - n));\n}\n","function_prediction":"unsigned int setbits(unsigned int x, unsigned int p, unsigned int n,\n                     unsigned int y) {\n  return (x & ~(~(~0U << n) << (p + 1 - n))) |\n         ((~(~0U << n) & y) << (p + 1 - n));\n}","pass":0}
{"function":"int strrindex(char s[], char t) {\n    int i;\n    int count = -1;\n    for (i = 0; s[i] != '\\x00'; i++) {\n        if (s[i] == t) {\n            count = i;\n        }\n    }\n    return count;\n}\n","function_prediction":"int strrindex_name_conflict(char s[], char t) {\n  int i, j;\n\n  j = -1;\n  for (i = 0; s[i] != '\\0'; i++)\n    if (s[i] == t)\n      j = i;\n  return j;\n}","pass":1}
{"function":"int readbuff(char *buffer) {\n    size_t i = 0;\n    int c;\n    while (i < 81)\n        {\n            c = getchar();\n            if (c == (-1))\n                return -1;\n            if (c == '\\n')\n                return 0;\n            buffer[i++] = c;\n        }\n    return 1;\n}\n","function_prediction":"int readbuff_name_conflict(char *buff) {\n  size_t i = 0;\n  int c;\n\n  while (i < 80) {\n    c = getchar();\n    if (c == -1)\n      return -1;\n    if (c == '\\n')\n      return 0;\n    buff[i++] = c;\n  }\n  return 1;\n}","pass":1}
{"function":"int copyline(char *buffer) {\n    size_t i;\n    int c;\n    int status = 1;\n    for (i = 0; i < 81; i++)\n        putchar(buffer[i]);\n    while (status == 1)\n        {\n            c = getchar();\n            if (c == (-1))\n                status = -1;\n            else if (c == '\\n')\n                status = 0;\n            else\n                putchar(c);\n        }\n    putchar('\\n');\n    return status;\n}\n","function_prediction":"int copyline_name_conflict(char *line) {\n  int c;\n  int i;\n  int status = 1;\n\n  for (i = 0; i < 81; i++)\n    putchar(line[i]);\n\n  while (status == 1) {\n    c = getchar();\n    if (c == -1)\n      status = -1;\n    else if (c == '\\n')\n      status = 0;\n    else\n      putchar(c);\n  }\n  putchar('\\n');\n  return status;\n}","pass":1}
{"function":"int power(int base, int n) {\n    int i, p;\n    p = 1;\n    for (i = 1; i <= n; ++i)\n        p = p * base;\n    return p;\n}\n","function_prediction":"int power_name_conflict(int base, int exponent) {\n  int result = 1;\n  for (int i = 1; i <= exponent; i++) {\n    result *= base;\n  }\n  return result;\n}","pass":1}
{"function":"int options(const char *afterdash, char **moreargs) {\n    int nmore = 0, c;\n    while ((c = *afterdash++) != '\\x00')\n        {\n            if (c == 'o') {\n                if (*afterdash) {\n                    outname = afterdash;\n                    afterdash = \"\";\n                } else if (moreargs[nmore] != ((void *)0))\n                    outname = moreargs[nmore++];\n                else\n                    usage();\n            } else if (c == 't')\n                trigraphs = 0;\n            else if (c == 'w')\n                whitespace = 0;\n            else if (c == '9')\n                c99 = 1;\n            else\n                usage();\n        }\n    return nmore;\n}\n","function_prediction":"int options_name_conflict(char *arg, char **argv) {\n  int i;\n\n  i = 0;\n  while (*arg) {\n    switch (*arg++) {\n    case 'o':\n      if (*arg) {\n        arg = \"\";\n        outname = arg;\n        break;\n      }\n      if (argv[i]) {\n        outname = argv[i];\n        i++;\n        break;\n      }\n      usage();\n\n    case 't':\n      trigraphs = 0;\n      break;\n\n    case 'w':\n      whitespace = 0;\n      break;\n\n    case '9':\n      c99 = 1;\n      break;\n\n    default:\n      usage();\n    }\n  }\n  return i;\n}","pass":1}
{"function":"int advance(int pointer) {\n    if (pointer < 1001 - 1)\n        return pointer + 1;\n    else\n        return 0;\n}\n","function_prediction":"int advance_name_conflict(int i) {\n  if (i < 1000) {\n    return i + 1;\n  } else {\n    return 0;\n  }\n}","pass":1}
{"function":"int advance(int pointer) {\n    if (pointer < 1001 - 1)\n        return pointer + 1;\n    else\n        return 0;\n}\n","function_prediction":"int advance_name_conflict(int i) {\n  if (i < 1000) {\n    return i + 1;\n  } else {\n    return 0;\n  }\n}","pass":1}
{"function":"static int print_mode(enum state_t s) {\n    return (s == normal || s == string || s == character);\n}\n","function_prediction":"int print_mode_name_conflict(int mode) {\n  if (mode == 0 || mode == 1 || mode == 2)\n    return 1;\n  return 0;\n}","pass":1}
{"function":"int day_of_year(int year, int month, int day) {\n    int i, leap;\n    leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n    for (i = 1; i < month; i++)\n        day += daytab[leap][i];\n    return day;\n}\n","function_prediction":"int day_of_year_name_conflict(int year, int month, int day) {\n  int i, leap;\n\n  leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  for (i = 1; i < month; i++)\n    day += daytab[leap][i];\n  return day;\n}","pass":1}
{"function":"int day_of_year_pointer(int year, int month, int day) {\n    int i, leap;\n    char *p;\n    leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n    p = &daytab[leap][1];\n    for (i = 1; i < month; i++) {\n        day += *p;\n        ++p;\n    }\n    return day;\n}\n","function_prediction":"int day_of_year_pointer_name_conflict(int year, int month, int day) {\n  int i, leap;\n  char *p;\n\n  leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  p = &daytab[leap][1];\n  for (i = 1; i < month; i++)\n    day += *p++;\n  return day;\n}","pass":1}
{"function":"int getint(int *pn) {\n    int c, sign;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit) && c != (-1) && c != '+' && c != '-') {\n        ungetch(c);\n        return 0;\n    }\n    sign = (c == '-') ? -1 : 1;\n    if (c == '+' || c == '-')\n        c = getch();\n    for (*pn = 0; ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit); c = getch())\n        *pn = 10 * *pn + (c - '0');\n    *pn *= sign;\n    if (c != (-1))\n        ungetch(c);\n    return c;\n}\n","function_prediction":"int getint_name_conflict(int *pn) {\n  int c, sign;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (!isdigit(c) && c != EOF && c != '+' && c != '-') {\n    ungetch(c);\n    return 0;\n  }\n\n  sign = (c == '-') ? -1 : 1;\n\n  if (c == '+' || c == '-')\n    c = getch();\n\n  for (*pn = 0; isdigit(c); c = getch())\n    *pn = 10 * *pn + (c - '0');\n\n  *pn *= sign;\n\n  if (c != EOF)\n    ungetch(c);\n\n  return c;\n}","pass":1}
{"function":"int getch(void) {\n    return (bufp > 0) ? buf[--bufp] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  return (bufp > 0) ? buf[--bufp] : getch_name_conflictar();\n}","pass":1}
{"function":"int strlen(char *s) {\n    int n;\n    for (n = 0; *s != '\\x00'; s++) {\n        n++;\n    }\n    return n;\n}\n","function_prediction":"size_t strlen_name_conflict(const char *s) {\n  size_t len = 0;\n  while (*s++)\n    len++;\n  return len;\n}","pass":0}
{"function":"int strcmp(char *s, char *t) {\n    for (; *s == *t; s++ , t++)\n        if (*s == '\\x00')\n            return 0;\n    return *s - *t;\n}\n","function_prediction":"int strcmp_name_conflict(const char *s1, const char *s2) {\n  while (*s1 == *s2) {\n    if (*s1 == '\\0')\n      return 0;\n    s1++;\n    s2++;\n  }\n  return *s1 - *s2;\n}","pass":0}
{"function":"int strend(char *s, char *t) {\n    int Result = 0;\n    int s_length = 0;\n    int t_length = 0;\n    s_length = strlen(s);\n    t_length = strlen(t);\n    if (t_length <= s_length) {\n        s += s_length - t_length;\n        if (0 == strcmp(s, t)) {\n            Result = 1;\n        }\n    }\n    return Result;\n}\n","function_prediction":"int strend_name_conflict(char *s, char *t) {\n  int ret = 0;\n  int slen = strlen(s);\n  int tlen = strlen(t);\n\n  if (slen >= tlen) {\n    if (!strcmp(s + slen - tlen, t))\n      ret = 1;\n  }\n\n  return ret;\n}","pass":0}
{"function":"char *liw_strncpy(char *s, const char *ct, size_t n) {\n    char *p;\n    p = s;\n    for (; n > 0 && *ct != '\\x00'; --n)\n        *p++ = *ct++;\n    for (; n > 0; --n)\n        *p++ = '\\x00';\n    return s;\n}\n","function_prediction":"char *liw_strncpy_name_conflict(char *dest, const char *src, size_t n) {\n  char *d = dest;\n  const char *s = src;\n\n  while (n && *s) {\n    *d = *s;\n    d++;\n    s++;\n    n--;\n  }\n\n  while (n) {\n    *d = '\\0';\n    d++;\n    n--;\n  }\n\n  return dest;\n}","pass":1}
{"function":"char *liw_strncat(char *s, const char *ct, size_t n) {\n    char *p;\n    p = s;\n    while (*p != '\\x00')\n        ++p;\n    for (; n > 0 && *ct != '\\x00'; --n)\n        *p++ = *ct++;\n    *p = '\\x00';\n    return s;\n}\n","function_prediction":"char *liw_strncat_name_conflict(char *dest, const char *src, size_t n) {\n  char *ret = dest;\n  while (*dest)\n    dest++;\n  while (n-- && *src)\n    *dest++ = *src++;\n  *dest = '\\0';\n  return ret;\n}","pass":1}
{"function":"int liw_strncmp(const char *cs, const char *ct, size_t n) {\n    while (n > 0 && *cs == *ct && *cs != '\\x00')\n        {\n            ++cs;\n            ++ct;\n            --n;\n        }\n    if (n == 0 || *cs == *ct)\n        return 0;\n    if (*(unsigned char *)cs < *(unsigned char *)ct)\n        return -1;\n    return 1;\n}\n","function_prediction":"int liw_strncmp_name_conflict(const char *s1, const char *s2, size_t n) {\n  while (n && *s1 == *s2 && *s1) {\n    s1++;\n    s2++;\n    n--;\n  }\n\n  if (n == 0 || *s1 == *s2)\n    return 0;\n\n  if (*s1 < *s2)\n    return -1;\n\n  return 1;\n}","pass":0}
{"function":"int day_of_year(int year, int month, int day) {\n    int i, leap;\n    if (year < 1752 || month < 1 || month > 12 || day < 1)\n        return -1;\n    leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n    if (day > daytab[leap][month])\n        return -1;\n    for (i = 1; i < month; i++)\n        day += daytab[leap][i];\n    return day;\n}\n","function_prediction":"int day_of_year_name_conflict(int year, int month, int day) {\n  int i, leap;\n\n  if (year < 1752 || month < 1 || month > 12 || day < 1)\n    return -1;\n  leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  if (day > daytab[leap][month])\n    return -1;\n  for (i = 1; i < month; i++)\n    day += daytab[leap][i];\n  return day;\n}","pass":1}
{"function":"int month_day(int year, int yearday, int *pmonth, int *pday) {\n    int i, leap;\n    if (year < 1752 || yearday < 1)\n        return -1;\n    leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n    if ((leap && yearday > 366) || (!leap && yearday > 365))\n        return -1;\n    for (i = 1; yearday > daytab[leap][i]; i++)\n        yearday -= daytab[leap][i];\n    *pmonth = i;\n    *pday = yearday;\n    return 0;\n}\n","function_prediction":"int month_day_name_conflict(int year, int yearday, int *pmonth, int *pday) {\n  int i, leap;\n\n  if (year < 1752 || yearday < 1)\n    return -1;\n\n  leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  if (leap && yearday > 365)\n    return -1;\n  if (!leap && yearday > 366)\n    return -1;\n\n  for (i = 1; yearday > daytab[leap][i]; i++)\n    yearday -= daytab[leap][i];\n  *pmonth = i;\n  *pday = yearday;\n  return 0;\n}","pass":0}
{"function":"struct Node *buildBST(int a[], int start, int end) {\n    if (start <= end) {\n        int mid = (start + end) / 2;\n        struct Node *root = (struct Node *)malloc(sizeof(struct Node));\n        root->val = a[mid];\n        root->left = buildBST(a, start, mid - 1);\n        root->right = buildBST(a, mid + 1, end);\n        return root;\n    }\n    return ((void *)0);\n}\n","function_prediction":"struct node *buildBST_name_conflict(int *arr, int start, int end) {\n  if (start > end)\n    return NULL;\n\n  int mid = (start + end) / 2;\n  struct node *root = (struct node *)malloc(sizeof(struct node));\n  root->data = arr[mid];\n  root->left = buildBST_name_conflict(arr, start, mid - 1);\n  root->right = buildBST_name_conflict(arr, mid + 1, end);\n\n  return root;\n}","pass":0}
{"function":"int isBSTUtil(struct Node *node, int min, int max) {\n    if (node == ((void *)0))\n        return 1;\n    if (node->val < min || node->val > max)\n        return 0;\n    int leftIsBST = isBSTUtil(node->left, min, node->val - 1);\n    int rightIsBST = isBSTUtil(node->right, node->val + 1, max);\n    return leftIsBST && rightIsBST;\n}\n","function_prediction":"int isBSTUtil_name_conflict(struct node *root, int min, int max) {\n\n  if (root == NULL)\n    return 1;\n\n  if (root->data < min || root->data > max)\n    return 0;\n\n  return isBSTUtil_name_conflict(root->left, min, root->data - 1) &&\n         isBSTUtil_name_conflict(root->right, root->data + 1, max);\n}","pass":0}
{"function":"int isBST(struct Node *root) {\n    return isBSTUtil(root, 0, 1000000);\n}\n","function_prediction":"int isBSTUtil(struct node *node, int min, int max) {\n\n  if (node == NULL)\n    return 1;\n\n  if (node->data < min || node->data > max)\n    return 0;\n\n  return isBSTUtil(node->left, min, node->data - 1) &&\n         isBSTUtil(node->right, node->data + 1, max);\n}","pass":0}
{"function":"struct Node *newNode(int data) {\n    struct Node *node = (struct Node *)malloc(sizeof(struct Node));\n    node->val = data;\n    node->left = ((void *)0);\n    node->right = ((void *)0);\n    return (node);\n}\n","function_prediction":"struct node *newNode_name_conflict(int data) {\n  struct node *temp = (struct node *)malloc(sizeof(struct node));\n  temp->data = data;\n  temp->left = NULL;\n  temp->right = NULL;\n  return temp;\n}","pass":0}
{"function":"int displaylist(struct node *mylist) {\n    struct node *head = mylist;\n    if (head == ((void *)0))\n        return -1;\n    while (head != ((void *)0))\n        {\n            printf(\"%d, %p ==>\", head->val, head->next);\n            head = head->next;\n        }\n    return 0;\n}\n","function_prediction":"int displaylist_name_conflict(struct node *head) {\n  if (head == NULL)\n    return -1;\n\n  while (head != NULL) {\n    printf(\"%d, %p ==>\", head->data, head->next);\n    head = head->next;\n  }\n\n  return 0;\n}","pass":0}
{"function":"struct node *reverse(struct node *list) {\n    struct node *prev = 0;\n    struct node *current = list;\n    while (current != 0)\n        {\n            struct node *saved_next_link = current->next;\n            current->next = prev;\n            prev = current;\n            current = saved_next_link;\n        }\n    return current;\n}\n","function_prediction":"struct node *reverse_name_conflict(struct node *head) {\n  struct node *prev = NULL;\n  struct node *curr = head;\n  struct node *next = NULL;\n\n  while (curr != NULL) {\n    next = curr->next;\n    curr->next = prev;\n    prev = curr;\n    curr = next;\n  }\n\n  return prev;\n}","pass":0}
{"function":"int isBST(struct node *node) {\n    return (isBSTUtil(node, (-2147483647 - 1), 2147483647));\n}\n","function_prediction":"int isBSTUtil(struct node *node, int min, int max) {\n  if (node == NULL)\n    return 1;\n\n  if (node->data < min || node->data > max)\n    return 0;\n\n  return isBSTUtil(node->left, min, node->data - 1) &&\n         isBSTUtil(node->right, node->data + 1, max);\n}","pass":0}
{"function":"int isBSTUtil(struct node *node, int min, int max) {\n    if (node == ((void *)0))\n        return 1;\n    if (node->data < min || node->data > max)\n        return 0;\n    return isBSTUtil(node->left, min, node->data - 1) && isBSTUtil(node->right, node->data + 1, max);\n}\n","function_prediction":"int isBSTUtil_name_conflict(struct node *node, int min, int max) {\n\n  if (node == NULL)\n    return 1;\n\n  if (node->data < min || node->data > max)\n    return 0;\n\n  return isBSTUtil_name_conflict(node->left, min, node->data - 1) &&\n         isBSTUtil_name_conflict(node->right, node->data + 1, max);\n}","pass":1}
{"function":"struct node *newNode(int data) {\n    struct node *node = (struct node *)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = ((void *)0);\n    node->right = ((void *)0);\n    return (node);\n}\n","function_prediction":"struct node *newNode_name_conflict(int data) {\n  struct node *temp = (struct node *)malloc(sizeof(struct node));\n  temp->data = data;\n  temp->left = NULL;\n  temp->right = NULL;\n  return temp;\n}","pass":0}
{"function":"int binarySearch(int arr[], int low, int high, int val) {\n    if (low <= high) {\n        int mid = (low + high) >> 1;\n        if (arr[mid] == val)\n            return mid;\n        if (arr[mid] > val)\n            binarySearch(arr, 0, mid - 1, val);\n        else\n            binarySearch(arr, mid + 1, high, val);\n    }\n    return -1;\n}\n","function_prediction":"int binarySearch_name_conflict(int *arr, int low, int high, int key) {\n  if (high < low)\n    return -1;\n\n  int mid = low + (high - low) / 2;\n  if (arr[mid] == key)\n    return mid;\n\n  if (arr[mid] > key)\n    return binarySearch_name_conflict(arr, low, mid - 1, key);\n  else\n    return binarySearch_name_conflict(arr, mid + 1, high, key);\n}","pass":1}
{"function":"int hisatoi(char *pointer) {\n    int mul = 1;\n    int result = 0;\n    char *current = pointer;\n    while (*current != '\\x00')\n        {\n            if (*current >= '0' && *current <= '9')\n                mul = mul * 10;\n            current++;\n        }\n    mul = mul / 10;\n    current = pointer;\n    while (*pointer != '\\x00')\n        {\n            result = result + ((*pointer % 48) * mul);\n            mul = mul / 10;\n            pointer++;\n        }\n    return result;\n}\n","function_prediction":"int hisatoi_name_conflict(char *str) {\n  int i, n;\n  char *p;\n\n  n = 0;\n  for (p = str; *p != '\\0'; p++)\n    if (*p >= '0' && *p <= '9')\n      i *= 10;\n  for (p = str; *p != '\\0'; p++) {\n    n += (*p - '0') * i;\n    i /= 10;\n  }\n  return n;\n}","pass":0}
{"function":"int myatoi(char *str) {\n    int value;\n    char *current = str;\n    while (((*__ctype_b_loc())[(int)((*current))] & (unsigned short)_ISdigit))\n        {\n            value = value * 10;\n            value = value + (*current - '0');\n            current++;\n        }\n    return value;\n}\n","function_prediction":"int myatoi_name_conflict(char *str) {\n  int num = 0;\n  while (__ctype_b_loc().n[*str] & 0x800)\n    num = num * 10 + *str++ - '0';\n  return num;\n}","pass":0}
{"function":"int getSingle(int a[], int n) {\n    int num = a[0];\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        result = num ^ a[i];\n        num = a[i];\n    }\n    return result;\n}\n","function_prediction":"int getSingle_name_conflict(int *nums, int numsSize) {\n  int i, res = 0, tmp;\n  for (i = 1; i < numsSize; i++) {\n    tmp = res;\n    res = res ^ nums[i];\n    nums[i] = tmp;\n  }\n  return res;\n}","pass":0}
{"function":"char *reverse_string(char *str, int strlen) {\n    char temp = '\\x00';\n    int i = 0;\n    int j = 0;\n    for (i = 0 , j = strlen - 1; i < strlen / 2; i++ , j--) {\n        temp = str[i];\n        str[i] = str[j];\n        str[j] = temp;\n    }\n    return str;\n}\n","function_prediction":"char *reverse_string_name_conflict(char *str, int len) {\n  int i, j;\n  char tmp;\n\n  j = len - 1;\n  for (i = 0; i < len / 2; i++) {\n    tmp = str[i];\n    str[i] = str[j];\n    str[j] = tmp;\n    j--;\n  }\n\n  return str;\n}","pass":1}
{"function":"int is_supp_ref(s1)\n    char *s1;\n {\n    int i, x;\n    if (strlen(s1) < 6)\n        return (0);\n    if (!(s1[0] == '*' && s1[1] == '*'))\n        return (0);\n    i = 2;\n    while (((*__ctype_b_loc())[(int)((s1[i]))] & (unsigned short)_ISdigit))\n        i++;\n    if (i == 2 || s1[i] != ';')\n        return (0);\n    i++;\n    x = i;\n    while (((*__ctype_b_loc())[(int)((s1[i]))] & (unsigned short)_ISdigit))\n        i++;\n    if (i == x || s1[i] != ';')\n        return (0);\n    return (1);\n}\n","function_prediction":"int is_supp_ref_name_conflict(char *ref) {\n  int i, j;\n\n  if (strlen(ref) < 6)\n    return 0;\n\n  if (ref[0] != '*' || ref[1] != '*')\n    return 0;\n\n  for (i = 2; __ctype_b_loc()[(unsigned char)ref[i]] & 0x0800; i++)\n    ;\n\n  if (i == 2 || ref[i] != ';')\n    return 0;\n\n  j = i + 1;\n\n  for (i = j; __ctype_b_loc()[(unsigned char)ref[i]] & 0x0800; i++)\n    ;\n\n  if (i == j || ref[i] != ';')\n    return 0;\n\n  return 1;\n}","pass":0}
{"function":"static int strdelete(char *dest, int len) {\n    char *p = dest;\n    for (; *p; p++)\n        *p = *(p + len);\n    return (0);\n}\n","function_prediction":"int strdelete_name_conflict(char *str, int pos) {\n  char *p = str;\n  while (*p) {\n    *p = *(p + pos);\n    p++;\n  }\n  return 0;\n}","pass":0}
{"function":"int RegExpMatch(char *str) {\n    lbuf = str;\n    if (pmatch(str, pbuf))\n        return (1);\n    return (0);\n}\n","function_prediction":"int RegExpMatch_name_conflict(char *regexp) {\n  lbuf = regexp;\n  return (pmatch(regexp, pbuf) != NULL);\n}","pass":0}
{"function":"int RegExpCompile(char *source) {\n    register char *s;\n    register char *lp;\n    register int c;\n    int o;\n    char *spp;\n    s = source;\n    lp = pp = pbuf;\n    while (c = *s++)\n        {\n            if (c == 20) {\n                lp = pp;\n                if (!store(4))\n                    return (0);\n                if (!store(15))\n                    return (0);\n                if (!store(15))\n                    return (0);\n                spp = pp;\n                while (--pp > lp)\n                    *pp = pp[-1];\n                *pp = 7;\n                pp = spp;\n                continue;\n            }\n            if (c == 7 || c == 8) {\n                if (pp == pbuf || (o = pp[-1]) == 2 || o == 3 || o == 7 || o == 8 || o == 9)\n                    return (0);\n                if (!store(15))\n                    return (0);\n                if (!store(15))\n                    return (0);\n                spp = pp;\n                while (--pp > lp)\n                    *pp = pp[-1];\n                *pp = c;\n                pp = spp;\n                continue;\n            }\n            lp = pp;\n            switch (c) {\n              case '^':\n                if (!store(2))\n                    return (0);\n                break;\n              case 3:\n                if (!store(3))\n                    return (0);\n                break;\n              case 4:\n                if (!store(4))\n                    return (0);\n                break;\n              case 16:\n                if (!(s = cclass(source, s)))\n                    return (0);\n                break;\n              case 19:\n                if (*s)\n                    c = *s++;\n              default:\n                if (!store(1))\n                    return (0);\n                if (!store(tolower(c)))\n                    return (0);\n            }\n        }\n    if (!store(15))\n        return (0);\n    if (!store(0))\n        return (0);\n    return (1);\n}\n","function_prediction":"int RegExpCompile_name_conflict(char *p) {\n  char *p1, *p2;\n  int c;\n\n  pp = pbuf;\n  for (;;) {\n    switch (c = *p++) {\n    case 0:\n      if (!store(15))\n        return 0;\n      if (!store(0))\n        return 0;\n      return 1;\n    case 20:\n      if (!store(4))\n        return 0;\n      if (!store(15))\n        return 0;\n      if (!store(15))\n        return 0;\n      for (p1 = pp, p2 = pp - 1; p1 < p2; p1++, p2--)\n        *p1 = *(p2 - 1);\n      *p1 = '\\a';\n      break;\n    case 7:\n    case 8:\n      if (pp != pbuf && (pp[-1] == 2 || pp[-1] == 3 || pp[-1] == '\\a' ||\n                         pp[-1] == '\\b' || pp[-1] == '\\t'))\n        return 0;\n      if (!store(15))\n        return 0;\n      if (!store(15))\n        return 0;\n      for (p1 = pp, p2 = pp - 1; p1 < p2; p1++, p2--)\n        *p1 = *(p2 - 1);\n      *p1 = c;\n      break;\n    case 94:\n      if (!store(2))\n        return 0;\n      break;\n    case 19:\n      if (*p)\n        c = *p++;\n      if (!store(1))\n        return 0;\n      if (!store(tolower(c)))\n        return 0;\n      break;\n    case 16:\n      if (!cclass(p, p))\n        return 0;\n      break;\n    case 3:\n      if (!store(3))\n        return 0;\n      break;\n    case 4:\n      if (!store(4))\n      return 0","pass":0}
{"function":"int RegExpStrip(char *ss) {\n    char *s = ss;\n    while (*s)\n        {\n            if (*s == 19) {\n                strdelete(s, 1);\n            } else if (*s == 7) {\n                if (s != ss)\n                    *(s - 1) = '\\x00';\n                else\n                    *s = '\\x00';\n                return (1);\n            } else {\n                if (*s == 4 || *s == 3 || *s == 17 || *s == 16 || *s == 8 || *s == 20) {\n                    *s = '\\x00';\n                    return (1);\n                }\n            }\n            s++;\n        }\n    return (1);\n}\n","function_prediction":"int RegExpStrip_name_conflict(char *str) {\n  char *p;\n\n  for (p = str; *p; p++) {\n    switch (*p) {\n    case '\\004':\n    case '\\003':\n    case '\\017':\n    case '\\016':\n    case '\\012':\n    case '\\007':\n    case '\\020':\n      *p = '\\0';\n      return 1;\n    case '\\013':\n      strdelete(p, 1);\n      break;\n    case '\\001':\n      if (p == str) {\n        *p = '\\0';\n        return 1;\n      }\n      p[-1] = '\\0';\n      return 1;\n    }\n  }\n  return 1;\n}","pass":0}
{"function":"int IsRegExp(char *s) {\n    while (*s)\n        {\n            if (*s == '\\\\')\n                s++;\n            else {\n                if (*s == '?' || *s == '[' || *s == ']' || *s == '*' || *s == '+' || *s == '@')\n                    return (1);\n            }\n            s++;\n        }\n    return (0);\n}\n","function_prediction":"int IsRegExp_name_conflict(char *s) {\n  while (*s) {\n    if (*s == '\\\\') {\n      s++;\n    } else if (*s == '?' || *s == '[' || *s == ']' || *s == '*' || *s == '+' ||\n               *s == '@') {\n      return 1;\n    }\n    s++;\n  }\n  return 0;\n}","pass":0}
{"function":"static char *cclass(char *source, char *src) {\n    register char *s;\n    register char *cp;\n    register int c;\n    int o;\n    s = src;\n    o = 5;\n    if (*s == 18) {\n        ++s;\n        o = 6;\n    }\n    if (!store(o))\n        return (((void *)0));\n    cp = pp;\n    if (!store(0))\n        return (((void *)0));\n    while ((c = *s++) && c != 17)\n        {\n            if (c == 19) {\n                if ((c = *s++) == '\\x00')\n                    return (((void *)0));\n                else {\n                    if (!store(tolower(c)))\n                        return (((void *)0));\n                }\n            } else if (c == '-' && (pp - cp) > 1 && *s != 17 && *s != '\\x00') {\n                c = pp[-1];\n                pp[-1] = 14;\n                if (!store(c))\n                    return (((void *)0));\n                c = *s++;\n                if (!store(tolower(c)))\n                    return (((void *)0));\n            } else {\n                if (!store(tolower(c)))\n                    return (((void *)0));\n            }\n        }\n    if (c != 17)\n        return (((void *)0));\n    if ((c = (pp - cp)) >= 256)\n        return (((void *)0));\n    if (c == 0)\n        return (((void *)0));\n    *cp = c;\n    return (s);\n}\n","function_prediction":"char *cclass_name_conflict(int n, char *p) {\n  char *s;\n  int c;\n  int len;\n  char *start;\n\n  s = p;\n  c = 5;\n  if (*p == '\\f') {\n    p++;\n    c = 6;\n  }\n  if (!store(c))\n    return NULL;\n  if (!store('\\0'))\n    return NULL;\n  start = pp;\n  while ((c = *p++) != '\\0' && c != '\\x11') {\n    if (c == '\\x13') {\n      if (*p == '\\0')\n        return NULL;\n      if (!store(tolower(*p++)))\n        return NULL;\n      continue;\n    }\n    if (c == '-' && pp - start > 1 && *p != '\\x11' && *p != '\\0') {\n      c = *--pp;\n      *pp = '\\x0e';\n      if (!store(c))\n        return NULL;\n      if (!store(tolower(*p++)))\n        return NULL;\n      continue;\n    }\n    if (!store(tolower(c)))\n      return NULL;\n  }\n  if (c != '\\x11')\n    return NULL;\n  len = pp - start;\n  if (len > 255 || len == 0)\n    return NULL;\n  *start = len;\n  return p;\n}","pass":0}
{"function":"static int store(char op) {\n    if (pp >= &pbuf[256])\n        return (0);\n    *pp++ = op;\n    return (1);\n}\n","function_prediction":"int store_name_conflict(char c) {\n  if (pp >= &lbuf)\n    return 0;\n  *pp++ = c;\n  return 1;\n}","pass":0}
{"function":"static char *pmatch(char *line, char *pattern) {\n    register char *l;\n    register char *p;\n    register char c;\n    char *e;\n    int op;\n    int n;\n    char *are;\n    l = line;\n    p = pattern;\n    while ((op = *p++) != 15)\n        {\n            switch (op) {\n              case 1:\n                if (tolower(*l) != *p++)\n                    return (0);\n                l++;\n                break;\n              case 2:\n                if (l != lbuf)\n                    return (0);\n                break;\n              case 3:\n                if (*l != '\\x00')\n                    return (0);\n                break;\n              case 4:\n                if (*l++ == '\\x00')\n                    return (0);\n                break;\n              case 11:\n                if ((c = *l++) < '0' || (c > '9'))\n                    return (0);\n                break;\n              case 10:\n                c = tolower(*l);\n                l++;\n                if (c < 'a' || c > 'z')\n                    return (0);\n                break;\n              case 12:\n                c = tolower(*l);\n                l++;\n                if (c >= 'a' && c <= 'z')\n                    break;\n                else if (c < '0' || c > '9')\n                    return (0);\n                break;\n              case 13:\n                c = *l++;\n                if (c == 0 || c > ' ')\n                    return (0);\n                break;\n              case 5:\n              case 6:\n                c = tolower(*l);\n                l++;\n                n = *p++ & 255;\n                do {\n                    if (*p == 14) {\n                        p += 3;\n                        n -= 2;\n                        if (c >= p[-2] && c <= p[-1])\n                            break;\n                    } else if (c == *p++)\n                        break;\n                } while (--n > 1);\n                if ((op == 5) == (n <= 1))\n                    return (0);\n                if (op == 5)\n                    p += n - 2;\n                break;\n              case 9:\n                e = pmatch(l, p);\n                while (*p++ != 15)\n                    ;\n                if (e)\n                    l = e;\n                break;\n              case 8:\n                if ((l = pmatch(l, p)) == 0)\n                    return (0);\n              case 7:\n                are = l;\n                while (*l && (e = pmatch(l, p)))\n                    l = e;\n                while (*p++ != 15)\n                    ;\n                while (l >= are)\n                    {\n                        if (e = pmatch(l, p))\n                            return (e);\n                        --l;\n                    }\n                return (0);\n              default:\n                return (0);\n            }\n        }\n    return (l);\n}\n","function_prediction":"char *pmatch_name_conflict(char *s, char *p) {\n  char *s1, *s2;\n  int c, c1, c2, n;\n\n  for (;;) {\n    switch (c = *p++) {\n    case 0:\n      return NULL;\n    case 1:\n      if (tolower(*s) != *p++)\n        return NULL;\n      s++;\n      break;\n    case 2:\n      if (s != lbuf)\n        return NULL;\n      break;\n    case 3:\n      if (*s)\n        return NULL;\n      break;\n    case 4:\n      if (!*s++)\n        return NULL;\n      break;\n    case 5:\n    case 6:\n      c1 = tolower(*s++);\n      n = *p++;\n      do {\n        switch (*p) {\n        case 14:\n          c2 = *++p;\n          if (c1 >= c2 && c1 <= *++p)\n            goto found;\n          p++;\n          break;\n        default:\n          if (c1 == *p++)\n            goto found;\n          break;\n        }\n        n--;\n      } while (n > 1);\n      return NULL;\n    found:\n      if (c == (n > 1) ^ 1)\n        p += n - 2;\n      break;\n    case 7:\n      return s;\n    case 8:\n      s1 = pmatch_name_conflict(s, p);\n      if (!s1)\n        return NULL;\n      s = s1;\n      break;\n    case 9:\n      s1 = pmatch_name_conflict(s, p);\n      while (*p++ != 15)\n        ;\n      if (s1)\n        s = s1;\n      break;\n    case 10:\n      c = tolower(*s);\n      if (c < 'a' || c > 'z')\n        return NULL;\n      s++;\n      break;\n    case 11:\n      c = *s;\n      if (c < '0' || c > '9')\n","pass":0}
{"function":"char *re_comp(const char *string) {\n    char str[500];\n    strncpy(str, string, 499);\n    RegExpPreprocess(str);\n    if (!RegExpCompile(str))\n        return (((void *)0));\n    return (pbuf);\n}\n","function_prediction":"char *re_comp_name_conflict(char *str) {\n  char buf[512];\n  int r;\n\n  strncpy(buf, str, 512 - 1);\n  RegExpPreprocess(buf);\n  r = RegExpCompile(buf);\n  if (r)\n    return pbuf;\n  else\n    return NULL;\n}","pass":0}
{"function":"int re_exec(const char *string) {\n    return (RegExpMatch((char *)string));\n}\n","function_prediction":"int re_exec_name_conflict(struct re_guts *g, const char *s) {\n  return RegExpMatch(g, s);\n}","pass":0}
{"function":"int is_punc(syntag)\n    char syntag[10];\n {\n    int i = 0, found = 0;\n    while ((!found) && (i < 13))\n        {\n            if (strcmp(syntag, punc[i].item) == 0)\n                found = 1;\n            i++;\n        }\n    return (found);\n}\n","function_prediction":"int is_punc_name_conflict(char *s) {\n  int i, found = 0;\n\n  for (i = 0; !found && i < 13; i++)\n    if (!strcmp(s, punc[i]))\n      found = 1;\n\n  return found;\n}","pass":0}
{"function":"int member(c, s1)\n    char c;\n    char *s1;\n {\n    int i, ln;\n    ln = strlen(s1);\n    for (i = 0; i < ln; i++) {\n        if (c == s1[i])\n            return (1);\n        else if (s1[i] == '\\x00')\n            return (0);\n    }\n    return (0);\n}\n","function_prediction":"int member_name_conflict(char c, char *s) {\n  int i, len;\n\n  len = strlen(s);\n  for (i = 0; i < len; i++)\n    if (c == s[i] || !s[i])\n      return 1;\n  return 0;\n}","pass":0}
{"function":"int tenpow(power)\n    int power;\n {\n    if (power == 0)\n        return (1);\n    else\n        return (10 * tenpow(power - 1));\n}\n","function_prediction":"int tenpow_name_conflict(int n) {\n  if (n == 0)\n    return 1;\n  return tenpow_name_conflict(n - 1) * 10;\n}","pass":0}
{"function":"int read_map(mapfn)\n    char *mapfn;\n {\n    FILE *mfp;\n    int count = 0, pos, pos2;\n    char line[300];\n    if ((mfp = fopen(mapfn, \"r\")) == ((void *)0)) {\n        rep_err(\"Mapping file not found.\");\n    }\n    fgets(line, 300, mfp);\n    pos = 0;\n    pos2 = 0;\n    while (line[pos] != '\\t' && line[pos] != '\\n')\n        {\n            mapping[count].from[pos] = line[pos];\n            pos++;\n        }\n    mapping[count].from[pos] = '\\x00';\n    pos++;\n    while (line[pos] != '\\n' && line[pos] != '\\x00')\n        {\n            mapping[count].to[pos2] = line[pos];\n            pos++;\n            pos2++;\n        }\n    mapping[count].to[pos2] = '\\x00';\n    while (!feof(mfp))\n        {\n            count++;\n            fgets(line, 300, mfp);\n            pos = 0;\n            pos2 = 0;\n            while (line[pos] != '\\t' && line[pos] != '\\n')\n                {\n                    mapping[count].from[pos] = line[pos];\n                    pos++;\n                }\n            mapping[count].from[pos] = '\\x00';\n            pos++;\n            while (line[pos] != '\\n' && line[pos] != '\\x00')\n                {\n                    mapping[count].to[pos2] = line[pos];\n                    pos++;\n                    pos2++;\n                }\n            mapping[count].to[pos2] = '\\x00';\n        }\n    printf(\"%d entries found in mapping file.\\n\", count);\n    return (count - 1);\n}\n","function_prediction":"int read_map3(char *filename) {\n  FILE *fp;\n  char line[300];\n  int i, j, k, l;\n\n  fp = fopen(filename, \"r\");\n  if (fp == NULL)\n    rep_err(\"Mapping file not found.\");\n\n  fgets(line, 300, fp);\n\n  i = 0;\n  j = 0;\n  k = 0;\n  while (line[k] != '\\t' && line[k] != '\\n') {\n    mapping[i * 3000 + k + 2000] = line[k];\n    k++;\n  }\n  mapping[i * 3000 + k + 2000] = '\\0';\n\n  k++;\n  while (line[k] != '\\t' && line[k] != '\\n') {\n    mapping[i * 3000 + j] = line[k];\n    j++;\n    k++;\n  }\n  mapping[i * 3000 + j] = '\\0';\n\n  k++;\n  while (line[k] != '\\n' && line[k] != '\\0') {\n    mapping[i * 3000 + l + 1000] = line[k];\n    l++;\n    k++;\n  }\n  mapping[i * 3000 + l + 1000] = '\\0';\n\n  while (!feof(fp)) {\n    i++;\n    fgets(line, 300, fp);\n\n    j = 0;\n    l = 0;\n    k = 0;\n    while (line[k] != '\\t' && line[k] != '\\n') {\n      mapping[i * 3000 + k + 2000] = line[k];\n      k++;\n    }\n    mapping[i * 3000 + k + 2000] = '\\0';\n\n    k++;\n    while (line[k] != '\\t' && line[k] != '\\n') {\n","pass":0}
{"function":"int read_map3(mapfn)\n    char *mapfn;\n {\n    FILE *mfp;\n    int count = 0, pos, pos1, pos2, pos3;\n    char line[300];\n    if ((mfp = fopen(mapfn, \"r\")) == ((void *)0)) {\n        rep_err(\"Mapping file not found.\");\n    }\n    fgets(line, 300, mfp);\n    pos = 0;\n    pos1 = 0;\n    pos2 = 0;\n    pos3 = 0;\n    while (line[pos] != '\\t' && line[pos] != '\\n')\n        {\n            mapping[count].type[pos3] = line[pos];\n            pos++;\n            pos3++;\n        }\n    mapping[count].type[pos3] = '\\x00';\n    pos++;\n    while (line[pos] != '\\t' && line[pos] != '\\n')\n        {\n            mapping[count].from[pos1] = line[pos];\n            pos++;\n            pos1++;\n        }\n    mapping[count].from[pos1] = '\\x00';\n    pos++;\n    while (line[pos] != '\\n' && line[pos] != '\\x00')\n        {\n            mapping[count].to[pos2] = line[pos];\n            pos++;\n            pos2++;\n        }\n    mapping[count].to[pos2] = '\\x00';\n    while (!feof(mfp))\n        {\n            count++;\n            fgets(line, 300, mfp);\n            pos = 0;\n            pos1 = 0;\n            pos2 = 0;\n            pos3 = 0;\n            while (line[pos] != '\\t' && line[pos] != '\\n')\n                {\n                    mapping[count].type[pos3] = line[pos];\n                    pos++;\n                    pos3++;\n                }\n            mapping[count].type[pos3] = '\\x00';\n            pos++;\n            while (line[pos] != '\\t' && line[pos] != '\\n')\n                {\n                    mapping[count].from[pos1] = line[pos];\n                    pos++;\n                    pos1++;\n                }\n            mapping[count].from[pos1] = '\\x00';\n            pos++;\n            while (line[pos] != '\\n' && line[pos] != '\\x00')\n                {\n                    mapping[count].to[pos2] = line[pos];\n                    pos++;\n                    pos2++;\n                }\n            mapping[count].to[pos2] = '\\x00';\n        }\n    printf(\"%d entries found in mapping file.\\n\", count);\n    return (count - 1);\n}\n","function_prediction":"int read_map3_name_conflict(char *filename) {\n  FILE *fp;\n  char line[300];\n  int i, j, k, l, m;\n\n  fp = fopen(filename, \"r\");\n  if (fp == NULL)\n    rep_err(\"Mapping file not found.\");\n\n  fgets(line, 300, fp);\n  i = 0;\n  j = 0;\n  k = 0;\n  m = 0;\n  while (line[m] != '\\t' && line[m] != '\\n') {\n    mapping[m + 2000 + i] = line[m];\n    m++;\n  }\n  mapping[m + 2000 + i] = '\\0';\n  while (line[m] != '\\t' && line[m] != '\\n') {\n    mapping[i + j] = line[m];\n    m++;\n    j++;\n  }\n  mapping[i + j] = '\\0';\n  while (line[m] != '\\n' && line[m] != '\\0') {\n    mapping[i + 1000 + k] = line[m];\n    m++;\n    k++;\n  }\n  mapping[i + 1000 + k] = '\\0';\n\n  while (!feof(fp)) {\n    i++;\n    fgets(line, 300, fp);\n    j = 0;\n    k = 0;\n    l = 0;\n    while (line[l] != '\\t' && line[l] != '\\n') {\n      mapping[l + 2000 + i] = line[l];\n      l++;\n    }\n    mapping[l + 2000 + i] = '\\0';\n    while (line[l] != '\\t' && line[l] != '\\n') {\n      mapping[i + j] = line[l];\n      l++;\n      j++;\n    }\n    mapping[i + j] = '\\0';\n      while (line[l] != '\\n' && line[l","pass":0}
{"function":"char *STRAPP(s1, s2)\n    char *s1;\n    char *s2;\n {\n    char *p;\n    p = (char *)strcat((char *)strcpy((char *)myalloc(strlen(s1) + strlen(s2) + 1), s1), s2);\n    myfree(s1);\n    return (p);\n}\n","function_prediction":"char *STRAPP_name_conflict(char *s1, char *s2) {\n  char *s;\n\n  s = myalloc(strlen(s1) + strlen(s2) + 1);\n  s = strcpy(s, s1);\n  s = strcat(s, s2);\n  myfree(s1);\n  return s;\n}","pass":0}
{"function":"char *MYSTRAPP(s1, s2)\n    char *s1;\n    char *s2;\n {\n    char *p;\n    p = (char *)strcat((char *)strcpy((char *)myalloc(strlen(s1) + strlen(s2) + 1), s1), s2);\n    myfree(s1);\n    return (p);\n}\n","function_prediction":"char *MYSTRAPP_name_conflict(char *s1, char *s2) {\n  char *s;\n\n  s = myalloc(strlen(s1) + strlen(s2) + 1);\n  s = strcpy(s, s1);\n  s = strcat(s, s2);\n  myfree(s1);\n  return s;\n}","pass":0}
{"function":"char *timestamp() {\n    time_t tm;\n    time(&tm);\n    return (ctime(&tm));\n}\n","function_prediction":"char *timestamp_name_conflict() {\n  time_t t;\n  time(&t);\n  return ctime(&t);\n}","pass":0}
{"function":"int regular_expression_cmp(sreg, scur)\n    char *sreg;\n    char *scur;\n {\n    char *exp;\n    int value;\n    regular_expression_compile(sreg, exp);\n    value = regular_expression_compare(exp, scur);\n    regular_expression_free(exp);\n    return (value);\n}\n","function_prediction":"int regular_expression_cmp_name_conflict(const char *regexp,\n                                         const char *string) {\n  int result;\n  struct regular_expression *re;\n\n  regular_expression_compile(regexp, &re);\n  result = regular_expression_compare(re, string);\n  regular_expression_free(re);\n\n  return result;\n}","pass":0}
{"function":"int get_no_lines_infile(fname)\n    char *fname;\n {\n    FILE *pfp;\n    char command[100], temp[100];\n    sprintf(command, \"wc -l %s\", fname);\n    pfp = popen(command, \"r\");\n    if (!pfp)\n        return (0);\n    fscanf(pfp, \"%s\", temp);\n    pclose(pfp);\n    return (atoi(temp));\n}\n","function_prediction":"int get_no_lines_infile_name_conflict(char *filename) {\n  FILE *fp;\n  char cmd[100];\n  char line[100];\n\n  sprintf(cmd, \"wc -l %s\", filename);\n  fp = popen(cmd, \"r\");\n  if (fp == NULL)\n    return 0;\n  __isoc99_fscanf(fp, \"%s\", line);\n  pclose(fp);\n  return atoi(line);\n}","pass":0}
{"function":"int get_no_words_infile(fname)\n    char *fname;\n {\n    FILE *pfp;\n    char command[100], temp[100];\n    sprintf(command, \"wc -w %s\", fname);\n    pfp = popen(command, \"r\");\n    if (!pfp)\n        return (0);\n    fscanf(pfp, \"%s\", temp);\n    pclose(pfp);\n    return (atoi(temp));\n}\n","function_prediction":"int get_no_words_infile_name_conflict(char *filename) {\n  FILE *fp;\n  char cmd[100];\n  char buf[100];\n\n  sprintf(cmd, \"wc -w %s\", filename);\n  fp = popen(cmd, \"r\");\n  if (fp == NULL)\n    return 0;\n  __isoc99_fscanf(fp, \"%s\", buf);\n  pclose(fp);\n  return atoi(buf);\n}","pass":0}
{"function":"char plural(number)\n    int number;\n {\n    if (number == 1)\n        return (' ');\n    else\n        return ('s');\n}\n","function_prediction":"char plural_name_conflict(int n) { return n == 1 ? ' ' : 's'; }","pass":0}
{"function":"int regular_expression_compile(sreg, exp)\n    char *sreg;\n    char *exp;\n {\n    extern char *re_comp();\n    if (exp = re_comp(sreg)) {\n        printf(\"Error with re_comp(%s): %s\\n\", sreg, exp);\n        return (0);\n    } else\n        return (1);\n}\n","function_prediction":"int regular_expression_compile_name_conflict(const char *regex) {\n  const char *err = re_comp(regex);\n  if (err) {\n    printf(\"Error with re_comp(%s): %s\\n\", regex, err);\n    return 0;\n  }\n  return 1;\n}","pass":0}
{"function":"int regular_expression_compare(exp, stext)\n    char *exp;\n    char *stext;\n {\n    return (re_exec(stext) > 0);\n}\n","function_prediction":"int regular_expression_compare_name_conflict(const char *string,\n                                             const char *regex) {\n  return re_exec(regex, string) > 0;\n}","pass":0}
{"function":"linkent *semtag_strip_marker(s1, idcn, idno, idpo, slash_prefer_first, strip_gender_marker)\n    char *s1;\n    int *idcn;\n    int *idno;\n    int *idpo;\n    int slash_prefer_first;\n    int strip_gender_marker;\n {\n    int x, smln, endpt, templn = -1;\n    char temp[300];\n    linkent *new, *end, *link;\n    link = ((void *)0);\n    end = link;\n    *idcn = *idno = *idpo = 0;\n    endpt = smln = strlen(s1);\n    for (x = 0; x <= smln; x++) {\n        if (s1[x] == '[') {\n            if (x < endpt)\n                endpt = x;\n            x++;\n            if (s1[x] == 'i') {\n                templn = -1;\n                temp[++templn] = s1[++x];\n                while (temp[templn] != '.')\n                    temp[++templn] = s1[++x];\n                temp[templn] = '\\x00';\n                *idcn = atoi(temp);\n                templn = -1;\n                temp[++templn] = s1[++x];\n                while (temp[templn] != '.')\n                    temp[++templn] = s1[++x];\n                temp[templn] = '\\x00';\n                *idno = atoi(temp);\n                templn = -1;\n                temp[++templn] = s1[++x];\n                while ((temp[templn] != '\\x00') && (temp[templn] != '['))\n                    temp[++templn] = s1[++x];\n                temp[templn] = '\\x00';\n                *idpo = atoi(temp);\n                x--;\n            } else if (strchr(\"mashd\", s1[x])) {\n                templn = -1;\n                new = (linkent *)myalloc(sizeof(linkent));\n                new->linktype = s1[x];\n                temp[++templn] = s1[++x];\n                while (temp[templn] != '.')\n                    temp[++templn] = s1[++x];\n                temp[templn] = '\\x00';\n                new->linkcn = atoi(temp);\n                templn = -1;\n                temp[++templn] = s1[++x];\n                while (temp[templn] != '.')\n                    temp[++templn] = s1[++x];\n                temp[templn] = '\\x00';\n                new->linkno = atoi(temp);\n                templn = -1;\n                temp[++templn] = s1[++x];\n                while ((temp[templn] != '\\x00') && (temp[templn] != '['))\n                    temp[++templn] = s1[++x];\n                temp[templn] = '\\x00';\n                new->linkpo = atoi(temp);\n                new->next = ((void *)0);\n                if (link == ((void *)0)) {\n                    link = new;\n                    end = link;\n                } else {\n                    end->next = new;\n                    end = end->next;\n                }\n                x--;\n            }\n        } else if (((*__ctype_b_loc())[(int)((s1[x]))] & (unsigned short)_ISlower) && strip_gender_marker) {\n            if (x < endpt)\n                endpt = x;\n        } else if (slash_prefer_first && s1[x] == '/') {\n            if (x < endpt)\n                endpt = x;\n        } else if (s1[x] == '{') {\n            if (x < endpt)\n                endpt = x;\n        }\n    }\n    s1[endpt] = '\\x00';\n    return (link);\n}\n","function_prediction":"struct semtag *semtag_strip_marker(char *s, int *i, int *j, int *k,\n                                   int strip_slash, int strip_space) {\n  int l, m, n, o, p, q, r, t, u, v, w, x, y, z;\n  char *a, *b, *c, *d, *e, *f, *g, *h, *i, *j, *k, *l, *m, *n, *o, *p, *q, *r,\n      *s, *t, *u, *v, *w, *x, *y, *z;\n  char *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L, *M, *N, *O, *P, *Q, *R,\n      *S, *T, *U, *V, *W, *X, *Y, *Z;\n  char *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i1, *j1, *k1, *l1, *m1, *n1,\n      *o1, *p1, *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n  char *A1, *B1, *C1, *D1, *E1, *F1, *G1, *H1, *I1, *J1, *K1, *L1, *M1, *N1,\n      *O1, *P1, *Q1, *R1, *S1, *T1, *U1, *V1, *W1, *X1, *Y1, *Z1;\n  char *a2, *b2, *c2, *d2, *e2, *f2, *g2, *h2, *i2, *j2, *k2, *l2, *m2, *n2,\n      *o2, *p","pass":0}
{"function":"int power(int m, int n) {\n    int i, p;\n    p = 1;\n    for (i = 1; i <= n; i++)\n        p *= m;\n    return p;\n}\n","function_prediction":"int power_name_conflict(int base, int exponent) {\n  int result = 1;\n  for (int i = 1; i <= exponent; i++) {\n    result *= base;\n  }\n  return result;\n}","pass":1}
{"function":"int magnitude(int x, int y) {\n    return floatToInt(sqrt(x * x + y * y));\n}\n","function_prediction":"int magnitude_name_conflict(int x, int y) {\n  return floatToInt(sqrt(x * x + y * y));\n}","pass":1}
{"function":"int fileLength() {\n    FILE *fp = fopen(FILENAME, \"r+\");\n    fseek(fp, 0, 2);\n    int length = ftell(fp);\n    length = (length / 37) - 1;\n    return length;\n}\n","function_prediction":"int fileLength_name_conflict() {\n  FILE *fp;\n  fp = fopen(\"Registers.txt\", \"r+\");\n  fseek(fp, 0, 2);\n  int length = ftell(fp);\n  length = length / 37;\n  length--;\n  return length;\n}","pass":0}
{"function":"int exists(const char *fileN) {\n    FILE *file;\n    if (file = fopen(fileN, \"r\")) {\n        fclose(file);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int exists_name_conflict(const char *filename) {\n  FILE *file = fopen(filename, \"r\");\n  if (file) {\n    fclose(file);\n    return 1;\n  }\n  return 0;\n}","pass":0}
{"function":"int *twoSum_heapSort(int *nums, int numsSize, int target) {\n    int *result;\n    int i, j, s;\n    Element *A;\n    result = (int *)malloc(sizeof(int) * 2);\n    A = (Element *)malloc(sizeof(Element) * numsSize);\n    for (i = 0; i < numsSize; i++) {\n        A[i].pos = i;\n        A[i].value = nums[i];\n    }\n    heapSort(A, numsSize);\n    i = 0;\n    j = numsSize - 1;\n    while (1)\n        {\n            s = A[i].value + A[j].value;\n            if (s == target) {\n                result[0] = A[i].pos;\n                result[1] = A[j].pos;\n                break;\n            } else if (s > target) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n    return result;\n}\n","function_prediction":"int *twoSum_heapSort_name_conflict(int *nums, int numsSize, int target) {\n  int *result = (int *)malloc(sizeof(int) * 2);\n  struct HeapNode *heap =\n      (struct HeapNode *)malloc(sizeof(struct HeapNode) * numsSize);\n  for (int i = 0; i < numsSize; i++) {\n    heap[i].index = i;\n    heap[i].val = nums[i];\n  }\n  heapSort(heap, numsSize);\n  int i = 0, j = numsSize - 1;\n  while (heap[i].val + heap[j].val != target) {\n    if (heap[i].val + heap[j].val > target) {\n      j--;\n    } else {\n      i++;\n    }\n  }\n  result[0] = heap[i].index;\n  result[1] = heap[j].index;\n  return result;\n}","pass":0}
{"function":"int *twoSum(int *nums, int numsSize, int target) {\n    int *result;\n    register int i, j, s;\n    register list **pList;\n    result = (int *)malloc(sizeof(int) * 2);\n    pList = (list **)malloc(sizeof(list *) * numsSize);\n    for (i = 0; i < numsSize; i++) {\n        pList[i] = (list *)malloc(sizeof(list));\n        pList[i]->value = nums[i];\n        pList[i]->pos = i;\n        pList[i]->next = ((void *)0);\n    }\n    mergeSort(pList, numsSize);\n    i = 0;\n    j = numsSize - 1;\n    while (1)\n        {\n            s = pList[i]->value + pList[j]->value;\n            if (s == target) {\n                if (pList[i]->pos <= pList[j]->pos) {\n                    result[0] = pList[i]->pos;\n                    result[1] = pList[j]->pos;\n                } else {\n                    result[0] = pList[j]->pos;\n                    result[1] = pList[i]->pos;\n                }\n                break;\n            } else if (s > target) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n    return result;\n}\n","function_prediction":"int *twoSum_heapSort(int *nums, int numsSize, int target) {\n  int *result = (int *)malloc(sizeof(int) * 2);\n  struct HeapNode *heap =\n      (struct HeapNode *)malloc(sizeof(struct HeapNode) * numsSize);\n  for (int i = 0; i < numsSize; i++) {\n    heap[i].index = i;\n    heap[i].val = nums[i];\n  }\n  heapSort(heap, numsSize);\n  int i = 0, j = numsSize - 1;\n  while (heap[i].val + heap[j].val != target) {\n    if (heap[i].val + heap[j].val > target) {\n      j--;\n    } else {\n      i++;\n    }\n  }\n  result[0] = heap[i].index;\n  result[1] = heap[j].index;\n  return result;\n}","pass":0}
{"function":"int foo() {\n    return 0;\n}\n","function_prediction":"int foo_name_conflict(void) {\n  int x;\n  int y;\n  int z;\n  int w;\n  int a;\n  int b;\n  int c;\n  int d;\n  int e;\n  int f;\n  int g;\n  int h;\n  int i;\n  int j;\n  int k;\n  int l;\n  int m;\n  int n;\n  int o;\n  int p;\n  int q;\n  int r;\n  int s;\n  int t;\n  int u;\n  int v;\n  int ww;\n  int xy;\n  int yz;\n  int zw;\n  int ww1;\n  int xy1;\n  int yz1;\n  int zw1;\n  int ww2;\n  int xy2;\n  int yz2;\n  int zw2;\n  int ww3;\n  int xy3;\n  int yz3;\n  int zw3;\n  int ww4;\n  int xy4;\n  int yz4;\n  int zw4;\n  int ww5;\n  int xy5;\n  int yz5;\n  int zw5;\n  int ww6;\n  int xy6;\n  int yz6;\n  int zw6;\n  int ww7;\n  int xy7;\n  int yz7;\n  int zw7;\n  int ww8;\n  int xy8;\n  int yz8;\n  int zw8;\n  int ww9;\n  int xy9;\n  int yz9;\n  int zw9;\n  int ww10;\n  int xy10;\n  int yz10;\n  int zw10;\n  int ww11;\n  int xy11;\n  int yz11;\n  int zw11;\n  int ww12;\n  int xy12;\n  int yz12;\n  int zw12;\n  int","pass":0}
{"function":"int Partition(int a[], int p, int r) {\n    int x = a[r];\n    int i = p - 1;\n    int temp = 0;\n    for (int j = p; j < r - 1; j++) {\n        if (a[j] <= x) {\n            i++;\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    }\n    temp = a[i + 1];\n    a[i + 1] = a[r];\n    a[r] = temp;\n    return (i + 1);\n}\n","function_prediction":"int Partition_name_conflict(int *A, int p, int r) {\n  int x = A[r];\n  int i = p - 1;\n  int j;\n  int temp;\n  for (j = p; j < r; j++) {\n    if (A[j] <= x) {\n      i++;\n      temp = A[i];\n      A[i] = A[j];\n      A[j] = temp;\n    }\n  }\n  temp = A[i + 1];\n  A[i + 1] = A[r];\n  A[r] = temp;\n  return i + 1;\n}","pass":1}
{"function":"int get_value() {\n    int value = 1;\n    return 0;\n}\n","function_prediction":"int get_value_name_conflict(int *a, int *b) {\n  int *c = a;\n  int *d = b;\n  int *e = c;\n  int *f = d;\n  int *g = e;\n  int *h = f;\n  int *i = g;\n  int *j = h;\n  int *k = i;\n  int *l = j;\n  int *m = k;\n  int *n = l;\n  int *o = m;\n  int *p = n;\n  int *q = o;\n  int *r = p;\n  int *s = q;\n  int *t = r;\n  int *u = s;\n  int *v = t;\n  int *w = u;\n  int *x = v;\n  int *y = w;\n  int *z = x;\n  int *aa = y;\n  int *bb = z;\n  int *cc = aa;\n  int *dd = bb;\n  int *ee = cc;\n  int *ff = dd;\n  int *gg = ee;\n  int *hh = ff;\n  int *ii = gg;\n  int *jj = hh;\n  int *kk = ii;\n  int *ll = jj;\n  int *mm = ll;\n  int *nn = mm;\n  int *oo = nn;\n  int *pp = oo;\n  int *qq = pp;\n  int *rr = qq;\n  int *ss = rr;\n  int *tt = ss;\n  int *uu = tt;\n  int *vv = uu;\n  int *ww = vv;\n  int *xx = ww;\n  int *yy = xx;\n  int *zz = yy;\n  int *aaa = zz;\n  int *bbb = aaa;\n  int *ccc = bbb;\n  int *ddd = ccc;\n  int *eee = ddd;\n  int *fff = eee;\n  int *ggg = fff;\n  int *hhh = ggg;\n","pass":0}
{"function":"int foo() {\n    return 1;\n}\n","function_prediction":"int foo_name_conflict(void) {\n  int x = 1;\n  return x;\n}","pass":1}
{"function":"int condition(int a, int b) {\n    return a > b;\n}\n","function_prediction":"int condition_name_conflict(int a, int b) { return a > b; }","pass":1}
{"function":"const char *get_the_good_string(Corde corde, Accord accord) {\n    switch (corde) {\n      case THIRD:\n        return c_forms_third[accord];\n      case FOURTH:\n        return c_forms_fourth[accord];\n      case FIFTH:\n        return c_forms_fifth[accord];\n      case SIXTH:\n        return c_forms_sixth[accord];\n      default:\n        return ((void *)0);\n    }\n}\n","function_prediction":"char *get_the_good_string_name_conflict(int i, int j) {\n  switch (i) {\n  case 0:\n    return c_forms_third[j];\n  case 1:\n    return c_forms_fourth[j];\n  case 2:\n    return c_forms_fifth[j];\n  case 3:\n    return c_forms_sixth[j];\n  default:\n    return NULL;\n  }\n}","pass":0}
{"function":"char get_the_good_fret(Note note, Corde corde) {\n    switch (corde) {\n      case THIRD:\n        return array_frette[((note + 9) % 12)];\n      case FOURTH:\n        return array_frette[((note + 2) % 12)];\n      case FIFTH:\n        return array_frette[((note + 7) % 12)];\n      case SIXTH:\n        return array_frette[note];\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int get_the_good_fret_name_conflict(int fret, int string) {\n  switch (string) {\n  case 0:\n    return array_frette[(fret + 9) % 12];\n  case 1:\n    return array_frette[(fret + 2) % 12];\n  case 2:\n    return array_frette[(fret + 7) % 12];\n  case 3:\n    return array_frette[fret];\n  default:\n    return 0;\n  }\n}","pass":1}
{"function":"int rng(const int limit) {\n    return rand() % limit;\n}\n","function_prediction":"void rng_init() {\n  time_t t;\n  srand((unsigned)time(&t));\n}","pass":0}
{"function":"tel *search(char keyword[20], tel *telBook, int length) {\n    int i;\n    for (i = 0; i < length; i++) {\n        if (strncmp(keyword, (telBook + i)->name, 20) == 0) {\n            return telBook + i;\n        }\n    }\n    return ((void *)0);\n}\n","function_prediction":"struct entry *search_name_conflict(char *name, struct entry *p, int n) {\n  int i;\n\n  for (i = 0; i < n; i++)\n    if (!strncmp(name, &p[i].name, 20))\n      return &p[i];\n  return NULL;\n}","pass":0}
{"function":"int diff(int a, int b) {\n    return a - b;\n}\n","function_prediction":"int diff_name_conflict(int a, int b) { return a - b; }","pass":1}
{"function":"int search(char keyword[30], char *datas[], int datalen) {\n    int i;\n    for (i = 0; i < datalen; i++) {\n        if (strncmp(keyword, datas[i], strlen(datas[i])) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int search_name_conflict(char *str, char *list[], int n) {\n  int i;\n  for (i = 0; i < n; i++)\n    if (!strncmp(str, list[i], strlen(list[i])))\n      return i;\n  return -1;\n}","pass":1}
{"function":"int addRecord(struct record **startptr, int uaccountno, char uname[], char uaddr[], int uyob) {\n    struct record *newRecord = ((void *)0);\n    int found = -2;\n    newRecord = malloc(sizeof(struct record));\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: addRecord\");\n        printf(\"Parameters: startptr = %u, uaccountno = %i, \", startptr, uaccountno);\n        printf(\"uname = %s, uaddr = %s, uyob = %i\", uname, uaddr, uyob);\n        puts(\"\");\n        puts(\"\");\n    }\n    (*newRecord).accountno = uaccountno;\n    strncpy((*newRecord).name, uname, 25);\n    strncpy((*newRecord).address, uaddr, 80);\n    (*newRecord).yearofbirth = uyob;\n    (*newRecord).next = ((void *)0);\n    if (*startptr == ((void *)0)) {\n        *startptr = newRecord;\n        found = 0;\n    } else if ((*startptr) != ((void *)0)) {\n        struct record *currentRecord;\n        currentRecord = *startptr;\n        found = -2;\n        if ((*newRecord).accountno <= (**startptr).accountno) {\n            (*newRecord).next = *startptr;\n            *startptr = newRecord;\n            found = 0;\n        }\n        while ((*currentRecord).next != ((void *)0) && found != 0)\n            {\n                if ((*newRecord).accountno <= (*((*currentRecord).next)).accountno) {\n                    (*newRecord).next = (*currentRecord).next;\n                    (*currentRecord).next = newRecord;\n                    found = 0;\n                }\n                if ((*newRecord).accountno > (*((*currentRecord).next)).accountno) {\n                    currentRecord = (*currentRecord).next;\n                }\n            }\n        if (found == -2) {\n            (*currentRecord).next = newRecord;\n            found = 0;\n        }\n    }\n    return found;\n}\n","function_prediction":"int addRecord(struct record **startptr, int uaccountno, char *uname,\n              char *uaddr, int uyob) {\n  int retval = -2;\n  struct record *newptr = NULL;\n  struct record *tempptr = NULL;\n\n  newptr = (struct record *)malloc(sizeof(struct record));\n\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: addRecord\\n\");\n    printf(\"Parameters: startptr = %u, uaccountno = %i, \", startptr,\n           uaccountno);\n    printf(\"uname = %s, uaddr = %s, uyob = %i\", uname, uaddr, uyob);\n    printf(\"\\n\\n\");\n  }\n\n  newptr->accountno = uaccountno;\n  strncpy(newptr->name, uname, 25);\n  strncpy(newptr->addr, uaddr, 80);\n  newptr->yob = uyob;\n  newptr->next = NULL;\n\n  if (*startptr == NULL) {\n    *startptr = newptr;\n    retval = 0;\n  } else if (*startptr != NULL) {\n    tempptr = *startptr;\n    retval = -2;\n\n    if (newptr->accountno <= tempptr->accountno) {\n      newptr->next = *startptr;\n      *startptr = newptr;\n      retval = 0;\n    }\n\n    while (tempptr->next != NULL && retval != 0) {\n      if (newptr->accountno <= tempptr->next->accountno) {\n        newptr->next = tempptr->next;\n        tempptr->next = newptr;\n        retval = 0;\n      }\n\n      if (tempptr->next->accountno < newptr->accountno) {\n        tempptr = tempptr->next;\n      }\n    }\n\n        if (","pass":0}
{"function":"int modifyRecord(struct record *start, int uaccountno, char input[]) {\n    int found = 0;\n    int done = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: modifyRecord\");\n        printf(\"Parameters: start = %u, uaccountno = %i, \", start, uaccountno);\n        printf(\"input = %s\", input);\n        puts(\"\");\n        puts(\"\");\n    }\n    if (start != ((void *)0)) {\n        struct record *currentRecord;\n        currentRecord = start;\n        if ((*start).accountno == uaccountno) {\n            while (currentRecord != ((void *)0) && done != 1)\n                {\n                    if ((*currentRecord).accountno == uaccountno) {\n                        strncpy((*currentRecord).address, input, 80);\n                        currentRecord = (*currentRecord).next;\n                        found = found + 1;\n                    } else {\n                        done = 1;\n                    }\n                }\n        } else {\n            if ((*currentRecord).next != ((void *)0)) {\n                currentRecord = (*currentRecord).next;\n                while (currentRecord != ((void *)0))\n                    {\n                        if ((*currentRecord).accountno == uaccountno) {\n                            strncpy((*currentRecord).address, input, 80);\n                            currentRecord = (*currentRecord).next;\n                            found = found + 1;\n                        } else if ((*currentRecord).accountno != uaccountno) {\n                            currentRecord = (*currentRecord).next;\n                        }\n                    }\n            }\n        }\n    }\n    return found;\n}\n","function_prediction":"int modifyRecord_name_conflict(struct record *start, unsigned int uaccountno,\n                               char *input) {\n  int count = 0;\n  int found = 0;\n  struct record *p;\n\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: modifyRecord_name_conflict\\n\");\n    printf(\"Parameters: start = %u, uaccountno = %i, \", start, uaccountno);\n    printf(\"input = %s\", input);\n    printf(\"\\n\\n\");\n  }\n\n  if (start == NULL) {\n    return 0;\n  }\n\n  if (start->uaccountno == uaccountno) {\n    p = start;\n    while (p != NULL && found == 0) {\n      if (p->uaccountno == uaccountno) {\n        strncpy(p->name, input, 80);\n        p = p->next;\n        count++;\n      } else {\n        found = 1;\n      }\n    }\n  } else if (start->next != NULL) {\n    p = start->next;\n    while (p != NULL) {\n      if (p->uaccountno == uaccountno) {\n        strncpy(p->name, input, 80);\n        p = p->next;\n        count++;\n      } else if (p->uaccountno != uaccountno) {\n        p = p->next;\n      }\n    }\n  }\n\n  return count;\n}","pass":0}
{"function":"int printRecord(struct record *start, int uaccountno) {\n    int found = 0;\n    int done = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: printRecord\");\n        printf(\"Parameters: start = %u, uaccountno = %i, \", start, uaccountno);\n        puts(\"\");\n        puts(\"\");\n    }\n    if (start != ((void *)0)) {\n        struct record *currentRecord;\n        currentRecord = start;\n        if ((*start).accountno == uaccountno) {\n            while (currentRecord != ((void *)0) && done != 1)\n                {\n                    if ((*currentRecord).accountno == uaccountno) {\n                        fprintf(stdout, \"%i\\n\", (*currentRecord).accountno);\n                        fprintf(stdout, \"%s\\n\", (*currentRecord).name);\n                        fprintf(stdout, \"%s\\n\", (*currentRecord).address);\n                        fprintf(stdout, \"%i\\n\", (*currentRecord).yearofbirth);\n                        puts(\"\");\n                        currentRecord = (*currentRecord).next;\n                        found = found + 1;\n                    } else {\n                        done = 1;\n                    }\n                }\n        } else {\n            if ((*currentRecord).next != ((void *)0)) {\n                currentRecord = (*currentRecord).next;\n                while (currentRecord != ((void *)0))\n                    {\n                        if ((*currentRecord).accountno == uaccountno) {\n                            fprintf(stdout, \"%i\\n\", (*currentRecord).accountno);\n                            fprintf(stdout, \"%s\\n\", (*currentRecord).name);\n                            fprintf(stdout, \"%s\\n\", (*currentRecord).address);\n                            fprintf(stdout, \"%i\\n\", (*currentRecord).yearofbirth);\n                            puts(\"\");\n                            currentRecord = (*currentRecord).next;\n                            found = found + 1;\n                        } else if ((*currentRecord).accountno != uaccountno) {\n                            currentRecord = (*currentRecord).next;\n                        }\n                    }\n            }\n        }\n    }\n    return found;\n}\n","function_prediction":"int printRecord_name_conflict(struct record *start, int uaccountno) {\n  int count = 0;\n  int found = 0;\n  struct record *current = NULL;\n\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: printRecord_name_conflict\\n\");\n    printf(\"Parameters: start = %u, uaccountno = %i, \", start, uaccountno);\n    printf(\"\\n\\n\");\n  }\n\n  if (start != NULL) {\n    if (start->accountno == uaccountno) {\n      current = start;\n      while (current != NULL && !found) {\n        if (current->accountno == uaccountno) {\n          fprintf(stdout, \"%i\\n\", current->accountno);\n          fprintf(stdout, \"%s\\n\", current->name);\n          fprintf(stdout, \"%s\\n\", current->address);\n          fprintf(stdout, \"%i\\n\", current->year);\n          printf(\"\\n\");\n          current = current->next;\n          count++;\n        } else {\n          found = 1;\n        }\n      }\n    } else if (start->next != NULL) {\n      current = start->next;\n      while (current != NULL) {\n        if (current->accountno == uaccountno) {\n          fprintf(stdout, \"%i\\n\", current->accountno);\n          fprintf(stdout, \"%s\\n\", current->name);\n          fprintf(stdout, \"%s\\n\", current->address);\n          fprintf(stdout, \"%i\\n\", current->year);\n          printf(\"\\n\");\n          current = current->next;\n          count++;\n        } else {\n          current = current->next;\n        }\n      }\n    }\n  }\n\n  return count;\n}","pass":0}
{"function":"int deleteRecord(struct record **startptr, int uaccountno) {\n    int found = 0;\n    int done = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: deleteRecord\");\n        printf(\"Parameters: startptr = %u, uaccountno = %i, \", startptr, uaccountno);\n        puts(\"\");\n        puts(\"\");\n    }\n    if (*startptr != ((void *)0)) {\n        if ((**startptr).accountno == uaccountno) {\n            while (*startptr != ((void *)0) && done != 1)\n                {\n                    if ((**startptr).accountno == uaccountno) {\n                        struct record *tempRecord;\n                        tempRecord = *startptr;\n                        *startptr = (**startptr).next;\n                        (*tempRecord).next = ((void *)0);\n                        free(tempRecord);\n                        found = found + 1;\n                    } else {\n                        done = 1;\n                    }\n                }\n        } else {\n            if ((**startptr).next != ((void *)0)) {\n                struct record *previous = *startptr;\n                struct record *current = (**startptr).next;\n                while (current != ((void *)0))\n                    {\n                        if ((*current).accountno == uaccountno) {\n                            struct record *temp;\n                            (*previous).next = (*current).next;\n                            (*current).next = ((void *)0);\n                            temp = current;\n                            current = (*previous).next;\n                            free(temp);\n                            found = found + 1;\n                        } else if ((*current).accountno != uaccountno) {\n                            current = (*current).next;\n                            previous = (*previous).next;\n                        }\n                    }\n            }\n        }\n    }\n    return found;\n}\n","function_prediction":"int deleteRecord_name_conflict(struct record **startptr, int uaccountno) {\n  int count = 0;\n  int found = 0;\n  struct record *temp;\n  struct record *temp2;\n\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: deleteRecord_name_conflict\\n\");\n    printf(\"Parameters: startptr = %u, uaccountno = %i, \", startptr,\n           uaccountno);\n    printf(\"\\n\\n\");\n  }\n\n  if (*startptr != NULL) {\n    if (uaccountno == (*startptr)->accountno) {\n      while (*startptr != NULL && found == 0) {\n        if (uaccountno == (*startptr)->accountno) {\n          temp = *startptr;\n          *startptr = (*startptr)->next;\n          temp->next = NULL;\n          free(temp);\n          count++;\n        } else {\n          found = 1;\n        }\n      }\n    } else if ((*startptr)->next != NULL) {\n      temp = *startptr;\n      temp2 = (*startptr)->next;\n      while (temp2 != NULL) {\n        if (uaccountno == temp2->accountno) {\n          temp->next = temp2->next;\n          temp2->next = NULL;\n          temp = temp->next;\n          free(temp2);\n          count++;\n          temp2 = temp->next;\n        } else if (uaccountno != temp2->accountno) {\n          temp2 = temp2->next;\n          temp = temp->next;\n        }\n      }\n    }\n  }\n  return count;\n}","pass":1}
{"function":"int isListEmpty(struct record *start) {\n    int status;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: isListEmpty\");\n        printf(\"Parameters: start = %u\", start);\n        puts(\"\");\n        puts(\"\");\n    }\n    if (start == ((void *)0)) {\n        status = 1;\n    } else {\n        status = 0;\n    }\n    return status;\n}\n","function_prediction":"int isListEmpty_name_conflict(unsigned int start) {\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: isListEmpty_name_conflict\\n\");\n    printf(\"Parameters: start = %u\", start);\n    printf(\"\\n\\n\");\n  }\n\n  if (start == 0)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"int getChoice() {\n    int i, input;\n    char str[25] = \"\";\n    i = 0;\n    input = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: getChoice\");\n        printf(\"Parameters: NONE\");\n        puts(\"\");\n        puts(\"\");\n    }\n    printf(\"Please select an option by typing in the associated option #, then pressing the ENTER key. Options are represented by numbers 1-6: \");\n    scanf(\"%24s\", &str);\n    eatTrash();\n    input = atoi(str);\n    while (str[i] != '\\x00')\n        {\n            if (((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit)) {\n                if (input < 1 || input > 6) {\n                    printf(\"Sorry... please enter a number from 1 to 6: \");\n                    scanf(\"%24s\", &str);\n                    eatTrash();\n                    input = atoi(str);\n                    i = 0;\n                } else {\n                    i++;\n                }\n            } else {\n                printf(\"Sorry... please enter a number from 1 to 6: \");\n                scanf(\"%24s\", &str);\n                eatTrash();\n                input = atoi(str);\n                i = 0;\n            }\n        }\n    puts(\"\");\n    printf(\"Input accepted: %d\\n\\n\", input);\n    puts(\"\");\n    puts(\"\");\n    return input;\n}\n","function_prediction":"int getChoice_name_conflict() {\n  char input[100] = {0};\n  int choice = 0;\n  int i = 0;\n\n  if (debugmode == 1) {\n    printf(\"\\n\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: getChoice_name_conflict\\n\");\n    printf(\"Parameters: NONE\");\n    printf(\"\\n\\n\");\n    printf(\"\\n\\n\");\n  }\n\n  printf(\"Please select an option by typing in the associated option #, then \"\n         \"pressing the ENTER key. Options are represented by numbers 1-6: \");\n  __isoc99_scanf(\"%s\", input);\n  eatTrash();\n  choice = atoi(input);\n\n  while (input[i] != '\\0') {\n    if (isdigit(input[i]) == 0) {\n      printf(\"Sorry... please enter a number from 1 to 6: \");\n      __isoc99_scanf(\"%s\", input);\n      eatTrash();\n      choice = atoi(input);\n      i = 0;\n    } else if (choice < 1 || choice > 6) {\n      printf(\"Sorry... please enter a number from 1 to 6: \");\n      __isoc99_scanf(\"%s\", input);\n      eatTrash();\n      choice = atoi(input);\n      i = 0;\n    } else {\n      i++;\n    }\n  }\n\n  printf(\"\\n\");\n  printf(\"Input accepted: %d\\n\\n\", choice);\n  printf(\"\\n\\n\");\n\n  return choice;\n}","pass":1}
{"function":"int getAccountNo() {\n    int i, input;\n    char str[10] = \"\";\n    i = 0;\n    input = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: getAccountNo\");\n        printf(\"Parameters: NONE\");\n        puts(\"\");\n        puts(\"\");\n    }\n    printf(\"Please enter the customer's account number (greater than zero) followed by the ENTER key: \");\n    scanf(\"%9s\", &str);\n    eatTrash();\n    input = atoi(str);\n    while (str[i] != '\\x00')\n        {\n            if (((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit)) {\n                if (input <= 0) {\n                    printf(\"Sorry... please enter a number greater than zero: \");\n                    scanf(\"%9s\", &str);\n                    eatTrash();\n                    input = atoi(str);\n                    i = 0;\n                } else {\n                    i++;\n                }\n            } else {\n                printf(\"Sorry... please enter an account number: \");\n                scanf(\"%9s\", &str);\n                eatTrash();\n                input = atoi(str);\n                i = 0;\n            }\n        }\n    puts(\"\");\n    printf(\"Input accepted: %d\\n\\n\", input);\n    puts(\"\");\n    puts(\"\");\n    return input;\n}\n","function_prediction":"int getAccountNo_name_conflict() {\n  char accountNo[100] = \"\";\n  int i = 0;\n  int accountNoInt = 0;\n\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: getAccountNo_name_conflict\\n\");\n    printf(\"Parameters: NONE\");\n    printf(\"\\n\\n\");\n    printf(\"\\n\");\n  }\n\n  printf(\"Please enter the customer's account number (greater than zero) \"\n         \"followed by the ENTER key: \");\n  __isoc99_scanf(\"%s\", accountNo);\n  eatTrash();\n  accountNoInt = atoi(accountNo);\n\n  while (accountNo[i] != '\\0') {\n    if (isdigit(accountNo[i]) == 0) {\n      printf(\"Sorry... please enter an account number: \");\n      __isoc99_scanf(\"%s\", accountNo);\n      eatTrash();\n      accountNoInt = atoi(accountNo);\n      i = 0;\n    } else if (accountNoInt <= 0) {\n      printf(\"Sorry... please enter a number greater than zero: \");\n      __isoc99_scanf(\"%s\", accountNo);\n      eatTrash();\n      accountNoInt = atoi(accountNo);\n      i = 0;\n    } else {\n      i++;\n    }\n  }\n\n  printf(\"\\n\");\n  printf(\"Input accepted: %d\\n\\n\", accountNoInt);\n  printf(\"\\n\");\n  printf(\"\\n\");\n\n  return accountNoInt;\n}","pass":1}
{"function":"int getBirthYear() {\n    int i, input;\n    char str[6] = \"\";\n    i = 0;\n    input = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: getBirthYear\");\n        printf(\"Parameters: NONE\");\n        puts(\"\");\n        puts(\"\");\n    }\n    printf(\"Please enter the customer's year of birth followed by the ENTER key: \");\n    scanf(\"%5s\", &str);\n    eatTrash();\n    input = atoi(str);\n    while (str[i] != '\\x00')\n        {\n            if (((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit)) {\n                if (input < (1) || input >= 10000) {\n                    printf(\"Sorry... please enter a year greater than %i and less than %i: \", (1 - 1), 10000);\n                    scanf(\"%5s\", &str);\n                    eatTrash();\n                    input = atoi(str);\n                    i = 0;\n                } else {\n                    i++;\n                }\n            } else {\n                printf(\"Sorry... please enter a year: \");\n                scanf(\"%5s\", &str);\n                eatTrash();\n                input = atoi(str);\n                i = 0;\n            }\n        }\n    puts(\"\");\n    printf(\"Input accepted: %d\\n\\n\", input);\n    puts(\"\");\n    puts(\"\");\n    return input;\n}\n","function_prediction":"int getBirthYear_name_conflict(void) {\n  char birthYear[5] = {0};\n  int i = 0;\n  int birthYearInt = 0;\n\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: getBirthYear_name_conflict\\n\");\n    printf(\"Parameters: NONE\");\n    printf(\"\\n\\n\");\n    printf(\"\\n\");\n  }\n\n  printf(\n      \"Please enter the customer's year of birth followed by the ENTER key: \");\n  __isoc99_scanf(\"%s\", birthYear);\n  eatTrash();\n  birthYearInt = atoi(birthYear);\n\n  while (birthYear[i] != '\\0') {\n    if (isdigit(birthYear[i]) == 0) {\n      printf(\"Sorry... please enter a year: \");\n      __isoc99_scanf(\"%s\", birthYear);\n      eatTrash();\n      birthYearInt = atoi(birthYear);\n      i = 0;\n    } else if (birthYearInt < 1 || birthYearInt > 9999) {\n      printf(\"Sorry... please enter a year greater than %i and less than %i: \",\n             0, 10000);\n      __isoc99_scanf(\"%s\", birthYear);\n      eatTrash();\n      birthYearInt = atoi(birthYear);\n      i = 0;\n    } else {\n      i++;\n    }\n  }\n\n  printf(\"\\n\");\n  printf(\"Input accepted: %d\\n\\n\", birthYearInt);\n  printf(\"\\n\");\n  printf(\"\\n\");\n\n  return birthYearInt;\n}","pass":1}
{"function":"int readfile(struct record **linkedList, char filename[]) {\n    char file[100] = \"\\000\";\n    char line[100] = \"\\000\";\n    char empty[2] = \"\";\n    FILE *infilebuffer;\n    int status;\n    int accountno;\n    char name[25];\n    char address[80];\n    int yearofbirth;\n    char tempString[2] = \"\\000\";\n    int c = 0;\n    if (debugmode == 1) {\n        puts(\"\");\n        puts(\"**DEBUG**\");\n        puts(\"Function name: readfile\");\n        printf(\"Parameters: linkedList = %u, filename = %s, \", linkedList, filename);\n        puts(\"\");\n        puts(\"\");\n    }\n    strncpy(file, filename, 99);\n    infilebuffer = fopen(file, \"r\");\n    if (infilebuffer != ((void *)0)) {\n        while (!feof(infilebuffer))\n            {\n                strncpy(line, empty, 10);\n                fgets(line, 9, infilebuffer);\n                if (!feof(infilebuffer)) {\n                    removeTrailingSpace(line);\n                    accountno = atoi(line);\n                    strncpy(line, empty, 10);\n                    fgets(line, 99, infilebuffer);\n                    removeTrailingSpace(line);\n                    strncpy(name, line, (25 - 1));\n                    strncpy(line, empty, 10);\n                    while ((c != 94))\n                        {\n                            c = fgetc(infilebuffer);\n                            if (c != 94) {\n                                tempString[0] = (char)c;\n                                strcat(line, tempString);\n                            }\n                        }\n                    strncpy(address, line, (80 - 1));\n                    while ((c != 10))\n                        {\n                            c = fgetc(infilebuffer);\n                        }\n                    strncpy(line, empty, 10);\n                    fgets(line, 99, infilebuffer);\n                    removeTrailingSpace(line);\n                    yearofbirth = atoi(line);\n                    addRecord(linkedList, accountno, name, address, yearofbirth);\n                }\n            }\n        status = 0;\n        fclose(infilebuffer);\n    } else {\n        status = -1;\n    }\n    return (status);\n}\n","function_prediction":"int readfile_name_conflict(struct node *linkedList, char *filename) {\n  if (debugmode == 1) {\n    printf(\"\\n\");\n    printf(\"**DEBUG**\\n\");\n    printf(\"Function name: readfile_name_conflict\\n\");\n    printf(\"Parameters: linkedList = %u, filename = %s, \", linkedList,\n           filename);\n    printf(\"\\n\\n\");\n  }\n\n  FILE *fp;\n  char fileName[100] = \"\";\n  char temp[100] = \"\";\n  char temp2[100] = \"\";\n  char temp3[100] = \"\";\n  char temp4[100] = \"\";\n  char temp5[100] = \"\";\n  char temp6[100] = \"\";\n  char temp7[100] = \"\";\n  char temp8[100] = \"\";\n  char temp9[100] = \"\";\n  char temp10[100] = \"\";\n  char temp11[100] = \"\";\n  char temp12[100] = \"\";\n  char temp13[100] = \"\";\n  char temp14[100] = \"\";\n  char temp15[100] = \"\";\n  char temp16[100] = \"\";\n  char temp17[100] = \"\";\n  char temp18[100] = \"\";\n  char temp19[100] = \"\";\n  char temp20[100] = \"\";\n  char temp21[100] = \"\";\n  char temp22[100] = \"\";\n  char temp23[100] = \"\";\n  char temp24[100] = \"\";\n  char temp25[100] = \"\";\n  char temp26[100] = \"\";\n  char temp27[100] = \"\";\n  char temp28[100] = \"\";\n  char temp29[100] = \"\";\n  char temp30[100] = \"\";\n  char temp31[100] = \"\";\n    char temp32[100","pass":0}
{"function":"int is_strings_equals(char *a, char *b) {\n    int i = 0;\n    while ((a[i] == b[i]) && (a[i] != '\\x00'))\n        {\n            i += 1;\n        }\n    return (a[i] == b[i]);\n}\n","function_prediction":"int is_strings_equals_name_conflict(char *str1, char *str2) {\n  int i;\n\n  for (i = 0; str1[i] == str2[i] && str1[i] != '\\0'; i++)\n    ;\n  return (str1[i] == str2[i]);\n}","pass":1}
{"function":"int *add(int *number, int adder) {\n    int mul = (*number) + adder;\n    *number = mul;\n    return number;\n}\n","function_prediction":"struct A *add_name_conflict(struct A *a, int b) {\n  a->a += b;\n  return a;\n}","pass":0}
{"function":"int sum_sized_array(int a[3]) {\n    int sum = 0;\n    for (int i = 0; i < 3; i++) {\n        sum += a[i];\n    }\n    return sum;\n}\n","function_prediction":"int sum_sized_array_name_conflict(int a[3]) {\n  int i, sum;\n  sum = 0;\n  for (i = 0; i < 3; i++) {\n    sum += a[i];\n  }\n  return sum;\n}","pass":1}
{"function":"int sum_nonsized_array(int a[], int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    return sum;\n}\n","function_prediction":"int sum_nonsized_array_name_conflict(int *a, int n) {\n  int i, sum = 0;\n  for (i = 0; i < n; i++)\n    sum += a[i];\n  return sum;\n}","pass":1}
{"function":"int sum_pointer_array(int *a, int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    return sum;\n}\n","function_prediction":"int sum_pointer_array_name_conflict(int *array, int size) {\n  int i, sum = 0;\n  for (i = 0; i < size; i++)\n    sum += array[i];\n  return sum;\n}","pass":1}
{"function":"int *multiply_pointer_array_by(int *array, int array_size, int multiplier) {\n    for (int i = 0; i < array_size; i++) {\n        array[i] *= multiplier;\n    }\n    return array;\n}\n","function_prediction":"int *multiply_pointer_array_by_name_conflict(int *array, int size,\n                                             int multiplier) {\n  for (int i = 0; i < size; i++) {\n    array[i] *= multiplier;\n  }\n  return array;\n}","pass":0}
{"function":"int compare_ascend(int one, int other) {\n    return other - one;\n}\n","function_prediction":"int compare_ascend_name_conflict(const void *a, const void *b) {\n  return *(int *)b - *(int *)a;\n}","pass":1}
{"function":"int compare_descend(int one, int other) {\n    return one - other;\n}\n","function_prediction":"int compare_descend_name_conflict(const void *a, const void *b) {\n  return *(int *)a - *(int *)b;\n}","pass":1}
{"function":"struct point build_point(int x, int y) {\n    struct point p = {x, y};\n    return p;\n}\n","function_prediction":"point build_point_name_conflict(int x, int y) {\n  point p;\n  p.x = x;\n  p.y = y;\n  return p;\n}","pass":0}
{"function":"static int wait_for_child() {\n    int exit_read = 0;\n    char exit_value = 0;\n    int wait_status;\n    while (1)\n        {\n            struct timeval tv;\n            fd_set rfds;\n            do {\n                unsigned int __i;\n                fd_set *__arr = (&rfds);\n                for (__i = 0; __i < sizeof(fd_set) / sizeof(__fd_mask); ++__i)\n                    ((__arr)->fds_bits)[__i] = 0;\n            } while (0);\n            tv.tv_sec = 1;\n            tv.tv_usec = 0;\n            ((void)(((&rfds)->fds_bits)[((exit_pipe[0]) / (8 * (int)sizeof(__fd_mask)))] |= ((__fd_mask)(1UL << ((exit_pipe[0]) % (8 * (int)sizeof(__fd_mask)))))));\n            if (select(exit_pipe[0] + 1, &rfds, ((void *)0), ((void *)0), &tv) < 0)\n                fatal(\"select: %s\", strerror((*__errno_location())));\n            if (waitpid(daemon_pid, &wait_status, 1) > 0)\n                fatal(\"daemon shut down unexpectedly\");\n            if (((((&rfds)->fds_bits)[((exit_pipe[0]) / (8 * (int)sizeof(__fd_mask)))] & ((__fd_mask)(1UL << ((exit_pipe[0]) % (8 * (int)sizeof(__fd_mask)))))) != 0))\n                break;\n        }\n    exit_read = read(exit_pipe[0], &exit_value, 1);\n    if (exit_read < 0)\n        fatal(\"read: %s\", strerror((*__errno_location())));\n    return exit_value;\n}\n","function_prediction":"int wait_for_child_name_conflict(void) {\n  int ret = 0;\n  char c = 0;\n\n  do {\n    fd_set fds;\n    struct timeval tv;\n    int status;\n\n    for (unsigned int i = 0; i < sizeof(fds.fds_bits); i++)\n      fds.fds_bits[i] = 0;\n\n    tv.tv_sec = 1;\n    tv.tv_usec = 0;\n\n    fds.fds_bits[exit_pipe / (8 * sizeof(long))] |=\n        (1UL << (exit_pipe % (8 * sizeof(long))));\n\n    if (select(exit_pipe + 1, &fds, NULL, NULL, &tv) < 0)\n      fatal(\"select: %s\", strerror(*__errno_location()));\n\n    if (waitpid(daemon_pid, &status, 1) > 0)\n      fatal(\"daemon shut down unexpectedly\");\n  } while (!(fds.fds_bits[exit_pipe / (8 * sizeof(long))] &\n             (1UL << (exit_pipe % (8 * sizeof(long))))));\n\n  ret = read(exit_pipe, &c, 1);\n  if (ret < 0)\n    fatal(\"read: %s\", strerror(*__errno_location()));\n\n  return c;\n}","pass":0}
{"function":"char *pretty_print_size(int64_t inp) {\n    static char output[100];\n    if (inp < 1024) {\n        snprintf(output, sizeof (output), \"%ld\", inp);\n        return output;\n    }\n    inp /= 1024;\n    if (inp < 1024) {\n        snprintf(output, sizeof (output), \"%ldK\", inp);\n        return output;\n    }\n    inp /= 1024;\n    if (inp < 1024) {\n        snprintf(output, sizeof (output), \"%ldM\", inp);\n        return output;\n    }\n    inp /= 1024;\n    snprintf(output, sizeof (output), \"%ldG\", inp);\n    return output;\n}\n","function_prediction":"char *pretty_print_size_name_conflict(long size) {\n  static char output[100];\n\n  if (size < 1024) {\n    snprintf(output, 100, \"%ld\", size);\n  } else if (size < 1024 * 1024) {\n    snprintf(output, 100, \"%ldK\", size / 1024);\n  } else if (size < 1024 * 1024 * 1024) {\n    snprintf(output, 100, \"%ldM\", size / (1024 * 1024));\n  } else {\n    snprintf(output, 100, \"%ldG\", size / (1024 * 1024 * 1024));\n  }\n\n  return output;\n}","pass":0}
{"function":"int64_t parse_size(char *inp) {\n    char *tp;\n    int len = strlen(inp);\n    char *errstr = \"bad size. examples: 4096, 4k, 100M, 1.5G\";\n    char mult_char;\n    int mult = 1;\n    double val;\n    if (len < 1)\n        fatal(errstr);\n    mult_char = tolower(inp[len - 1]);\n    if (((*__ctype_b_loc())[(int)((mult_char))] & (unsigned short)_ISalpha)) {\n        switch (mult_char) {\n          case 'k':\n            mult = 1024;\n            break;\n          case 'm':\n            mult = 1024 * 1024;\n            break;\n          case 'g':\n            mult = 1024 * 1024 * 1024;\n            break;\n          default:\n            fatal(\"unknown size multiplier: %c\", mult_char);\n        }\n        inp[len - 1] = '\\x00';\n    }\n    val = strtod(inp, &tp);\n    if (val <= 0 || *tp != '\\x00')\n        fatal(errstr);\n    return (int64_t)(mult * val);\n}\n","function_prediction":"size_t parse_size_name_conflict(char *str) {\n  int len = strlen(str);\n  char *end;\n  double size;\n  char multiplier;\n  int multiplier_value = 1;\n  const char *err_msg = \"bad size. examples: 4096, 4k, 100M, 1.5G\";\n\n  if (len < 1)\n    fatal(err_msg);\n\n  multiplier = tolower(str[len - 1]);\n  if (__ctype_b_loc().__mb_cur_max == 1 &&\n      (__ctype_b_loc().__b[((unsigned char)(multiplier))] & 0x400)) {\n    switch (multiplier) {\n    case 'k':\n      multiplier_value = 1024;\n      break;\n    case 'm':\n      multiplier_value = 1024 * 1024;\n      break;\n    case 'g':\n      multiplier_value = 1024 * 1024 * 1024;\n      break;\n    default:\n      fatal(\"unknown size multiplier: %c\", multiplier);\n    }\n    str[len - 1] = '\\0';\n  }\n\n  size = strtod(str, &end);\n  if (size <= 0 || *end != '\\0')\n    fatal(err_msg);\n\n  return (size_t)(size * multiplier_value);\n}","pass":0}
{"function":"int64_t bytes2pages(int64_t bytes) {\n    return (bytes + pagesize - 1) / pagesize;\n}\n","function_prediction":"size_t bytes2pages_name_conflict(size_t bytes) {\n  return (bytes + pagesize - 1) / pagesize;\n}","pass":1}
{"function":"int is_mincore_page_resident(char p) {\n    return p & 1;\n}\n","function_prediction":"int is_mincore_page_resident_name_conflict(unsigned char mincore_byte) {\n  return mincore_byte & 0x01;\n}","pass":1}
{"function":"static int wait_for_child() {\n    int exit_read = 0;\n    char exit_value = 0;\n    int wait_status;\n    while (1)\n        {\n            struct timeval tv;\n            fd_set rfds;\n            do {\n                unsigned int __i;\n                fd_set *__arr = (&rfds);\n                for (__i = 0; __i < sizeof(fd_set) / sizeof(__fd_mask); ++__i)\n                    ((__arr)->fds_bits)[__i] = 0;\n            } while (0);\n            tv.tv_sec = 1;\n            tv.tv_usec = 0;\n            ((void)(((&rfds)->fds_bits)[((exit_pipe[0]) / (8 * (int)sizeof(__fd_mask)))] |= ((__fd_mask)(1UL << ((exit_pipe[0]) % (8 * (int)sizeof(__fd_mask)))))));\n            if (select(exit_pipe[0] + 1, &rfds, ((void *)0), ((void *)0), &tv) < 0)\n                fatal(\"select: %s\", strerror((*__errno_location())));\n            if (waitpid(daemon_pid, &wait_status, 1) > 0)\n                fatal(\"daemon shut down unexpectedly\");\n            if (((((&rfds)->fds_bits)[((exit_pipe[0]) / (8 * (int)sizeof(__fd_mask)))] & ((__fd_mask)(1UL << ((exit_pipe[0]) % (8 * (int)sizeof(__fd_mask)))))) != 0))\n                break;\n        }\n    exit_read = read(exit_pipe[0], &exit_value, 1);\n    if (exit_read < 0)\n        fatal(\"read: %s\", strerror((*__errno_location())));\n    return exit_value;\n}\n","function_prediction":"int wait_for_child_name_conflict(void) {\n  int ret = 0;\n  char c = 0;\n\n  do {\n    fd_set fds;\n    struct timeval tv;\n    int status;\n\n    for (unsigned int i = 0; i < sizeof(fds.fds_bits); i++)\n      fds.fds_bits[i] = 0;\n\n    tv.tv_sec = 1;\n    tv.tv_usec = 0;\n\n    fds.fds_bits[exit_pipe / (8 * sizeof(long))] |=\n        (1UL << (exit_pipe % (8 * sizeof(long))));\n\n    if (select(exit_pipe + 1, &fds, NULL, NULL, &tv) < 0)\n      fatal(\"select: %s\", strerror(*__errno_location()));\n\n    if (waitpid(daemon_pid, &status, 1) > 0)\n      fatal(\"daemon shut down unexpectedly\");\n  } while (!(fds.fds_bits[exit_pipe / (8 * sizeof(long))] &\n             (1UL << (exit_pipe % (8 * sizeof(long))))));\n\n  ret = read(exit_pipe, &c, 1);\n  if (ret < 0)\n    fatal(\"read: %s\", strerror(*__errno_location()));\n\n  return c;\n}","pass":0}
{"function":"char *pretty_print_size(int64_t inp) {\n    static char output[100];\n    if (inp < 1024) {\n        snprintf(output, sizeof (output), \"%ld\", inp);\n        return output;\n    }\n    inp /= 1024;\n    if (inp < 1024) {\n        snprintf(output, sizeof (output), \"%ldK\", inp);\n        return output;\n    }\n    inp /= 1024;\n    if (inp < 1024) {\n        snprintf(output, sizeof (output), \"%ldM\", inp);\n        return output;\n    }\n    inp /= 1024;\n    snprintf(output, sizeof (output), \"%ldG\", inp);\n    return output;\n}\n","function_prediction":"char *pretty_print_size_name_conflict(long size) {\n  static char output[100];\n\n  if (size < 1024) {\n    snprintf(output, 100, \"%ld\", size);\n  } else if (size < 1024 * 1024) {\n    snprintf(output, 100, \"%ldK\", size / 1024);\n  } else if (size < 1024 * 1024 * 1024) {\n    snprintf(output, 100, \"%ldM\", size / (1024 * 1024));\n  } else {\n    snprintf(output, 100, \"%ldG\", size / (1024 * 1024 * 1024));\n  }\n\n  return output;\n}","pass":0}
{"function":"int64_t parse_size(char *inp) {\n    char *tp;\n    int len = strlen(inp);\n    char *errstr = \"bad size. examples: 4096, 4k, 100M, 1.5G\";\n    char mult_char;\n    int mult = 1;\n    double val;\n    if (len < 1)\n        fatal(errstr);\n    mult_char = tolower(inp[len - 1]);\n    if (((*__ctype_b_loc())[(int)((mult_char))] & (unsigned short)_ISalpha)) {\n        switch (mult_char) {\n          case 'k':\n            mult = 1024;\n            break;\n          case 'm':\n            mult = 1024 * 1024;\n            break;\n          case 'g':\n            mult = 1024 * 1024 * 1024;\n            break;\n          default:\n            fatal(\"unknown size multiplier: %c\", mult_char);\n        }\n        inp[len - 1] = '\\x00';\n    }\n    val = strtod(inp, &tp);\n    if (val <= 0 || *tp != '\\x00')\n        fatal(errstr);\n    return (int64_t)(mult * val);\n}\n","function_prediction":"size_t parse_size_name_conflict(char *str) {\n  int len = strlen(str);\n  char *end;\n  double size;\n  char multiplier;\n  int multiplier_value = 1;\n  const char *err_msg = \"bad size. examples: 4096, 4k, 100M, 1.5G\";\n\n  if (len < 1)\n    fatal(err_msg);\n\n  multiplier = tolower(str[len - 1]);\n  if (__ctype_b_loc().__mb_cur_max == 1 &&\n      (__ctype_b_loc().__b[((unsigned char)(multiplier))] & 0x400)) {\n    switch (multiplier) {\n    case 'k':\n      multiplier_value = 1024;\n      break;\n    case 'm':\n      multiplier_value = 1024 * 1024;\n      break;\n    case 'g':\n      multiplier_value = 1024 * 1024 * 1024;\n      break;\n    default:\n      fatal(\"unknown size multiplier: %c\", multiplier);\n    }\n    str[len - 1] = '\\0';\n  }\n\n  size = strtod(str, &end);\n  if (size <= 0 || *end != '\\0')\n    fatal(err_msg);\n\n  return (size_t)(size * multiplier_value);\n}","pass":0}
{"function":"int64_t bytes2pages(int64_t bytes) {\n    return (bytes + pagesize - 1) / pagesize;\n}\n","function_prediction":"size_t bytes2pages_name_conflict(size_t bytes) {\n  return (bytes + pagesize - 1) / pagesize;\n}","pass":1}
{"function":"int is_mincore_page_resident(char p) {\n    return p & 1;\n}\n","function_prediction":"int is_mincore_page_resident_name_conflict(unsigned char mincore_byte) {\n  return mincore_byte & 0x01;\n}","pass":1}
{"function":"long total_days(struct date a_date) {\n    long days;\n    if (a_date.month <= 2) {\n        a_date.year -= 1;\n        a_date.month += 13;\n    } else\n        a_date.month += 1;\n    days = (1461 * a_date.year / 4) + ((153 * a_date.month) / 5) + a_date.day;\n    return (days);\n}\n","function_prediction":"long total_days_name_conflict(long year, long month, long day) {\n  long y, m, d;\n\n  y = year - 1;\n  m = month - 3;\n  d = day;\n\n  if (m < 0) {\n    m += 12;\n    y--;\n  }\n\n  return (y * 365) + (y / 4) - (y / 100) + (y / 400) + (m * 306) / 10 + d;\n}","pass":0}
{"function":"long total_days(struct date a_date) {\n    long days;\n    if (a_date.month <= 2) {\n        a_date.year -= 1;\n        a_date.month += 13;\n    } else\n        a_date.month += 1;\n    days = (1461 * a_date.year / 4) + ((153 * a_date.month) / 5) + a_date.day;\n    return (days);\n}\n","function_prediction":"long total_days_name_conflict(long year, long month, long day) {\n  long y, m, d;\n\n  y = year - 1;\n  m = month - 3;\n  d = day;\n\n  if (m < 0) {\n    m += 12;\n    y--;\n  }\n\n  return (y * 365) + (y / 4) - (y / 100) + (y / 400) + (m * 306) / 10 + d;\n}","pass":0}
{"function":"int median(int a[], int i, int j, int k) {\n    if (a[i] > a[j] && a[i] > a[k])\n        return (a[j] > a[k]) ? j : k;\n    if (a[i] < a[j] && a[i] < a[k])\n        return (a[j] > a[k]) ? k : j;\n    return i;\n}\n","function_prediction":"int median_name_conflict(int *a, int i, int j, int k) {\n  if (a[i] < a[j]) {\n    if (a[i] < a[k]) {\n      if (a[j] < a[k])\n        return j;\n      else\n        return k;\n    } else\n      return i;\n  } else {\n    if (a[j] < a[k]) {\n      if (a[i] < a[k])\n        return i;\n      else\n        return k;\n    } else\n      return j;\n  }\n}","pass":1}
{"function":"int fib(int n) {\n    if (n < 2)\n        return n;\n    int last = 1;\n    int old_last = 0;\n    int i;\n    for (i = 2; i <= n; i++) {\n        int temp = last;\n        last = last + old_last;\n        old_last = temp;\n    }\n    return last;\n}\n","function_prediction":"int fib_name_conflict(int n) {\n  if (n <= 1)\n    return n;\n\n  int a = 0, b = 1, c;\n  for (int i = 2; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}","pass":1}
{"function":"int fib(int n) {\n    if (n == 0 || n == 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n","function_prediction":"int fib_name_conflict(int n) {\n  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib_name_conflict(n - 1) + fib_name_conflict(n - 2);\n}","pass":1}
{"function":"int fib(int n) {\n    if (n == 0 || n == 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n","function_prediction":"int fib_name_conflict(int n) {\n  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib_name_conflict(n - 1) + fib_name_conflict(n - 2);\n}","pass":1}
{"function":"int fib_r(int n, int a, int b) {\n    if (n == 0)\n        return a;\n    if (n == 1)\n        return b;\n    if (n == 2)\n        return a + b;\n    return fib_r(n - 1, b, a + b);\n}\n","function_prediction":"int fib_r_name_conflict(int n, int a, int b) {\n  if (n == 0)\n    return a;\n  if (n == 1)\n    return b;\n  if (n == 2)\n    return a + b;\n  return fib_r_name_conflict(n - 1, b, a + b);\n}","pass":1}
{"function":"int fib(int n) {\n    return fib_r(n, 0, 1);\n}\n","function_prediction":"int fib_name_conflict(int n) { return fib_name_conflict_r(n, 0, 1); }","pass":1}
{"function":"int factorial(int n) {\n    if (n < 2)\n        return 1;\n    return n * factorial(n - 1);\n}\n","function_prediction":"int factorial_name_conflict(int n) {\n  return n < 2 ? 1 : n * factorial_name_conflict(n - 1);\n}","pass":1}
{"function":"int factorial_tenary(int n) {\n    return (n < 2) ? 1 : n * factorial_tenary(n - 1);\n}\n","function_prediction":"int factorial_tenary_name_conflict(int n) {\n  return n < 2 ? 1 : n * factorial_tenary_name_conflict(n - 1);\n}","pass":1}
{"function":"int factorial_tail_r(int n, int big_n) {\n    if (n < 2)\n        return big_n;\n    return factorial_tail_r(n - 1, n * big_n);\n}\n","function_prediction":"int factorial_tail_r_name_conflict(int n, int acc) {\n  if (n < 2)\n    return acc;\n  else\n    return factorial_tail_r_name_conflict(n - 1, n * acc);\n}","pass":1}
{"function":"int factorial_tail(int n) {\n    factorial_tail_r(n, 1);\n}\n","function_prediction":"int factorial_tail_name_conflict(int n) {\n  return factorial_tail_name_conflict_r(n, 1);\n}","pass":1}
{"function":"int search(int a[], int n, int val) {\n    return search_recursion(a, n, val, 0, n - 1);\n}\n","function_prediction":"int search_name_conflict(int *array, int size, int value) {\n  return search_name_conflict_recursion(array, size, value, 0, size - 1);\n}\n\nint search_name_conflict_recursion(int *array, int size, int value, int start,\n                                   int end) {\n  if (start > end)\n    return -1;\n\n  int mid = (start + end) / 2;\n\n  if (array[mid] == value)\n    return mid;\n  else if (array[mid] < value)\n    return search_name_conflict_recursion(array, size, value, mid + 1, end);\n  else\n    return search_name_conflict_recursion(array, size, value, start, mid - 1);\n}","pass":1}
{"function":"int search_recursion(int a[], int n, int val, int low, int high) {\n    if (high < low)\n        return -1;\n    int mid = (high + low) / 2;\n    if (a[mid] == val)\n        return mid;\n    if (val > a[mid])\n        return search_recursion(a, n, val, mid + 1, high);\n    return search_recursion(a, n, val, low, mid - 1);\n}\n","function_prediction":"int search_recursion_name_conflict(int *array, int size, int value, int start,\n                                   int end) {\n  int mid;\n\n  if (start > end)\n    return (-1);\n  mid = (start + end) / 2;\n  if (array[mid] == value)\n    return (mid);\n  if (array[mid] < value)\n    return (search_recursion_name_conflict(array, size, value, mid + 1, end));\n  return (search_recursion_name_conflict(array, size, value, start, mid - 1));\n}","pass":1}
{"function":"int search(int a[], int n, int val) {\n    int mid;\n    int low = 0;\n    int high = n - 1;\n    while (low <= high)\n        {\n            mid = (low + high) / 2;\n            if (a[mid] == val)\n                return mid;\n            else if (val > a[mid])\n                low = mid + 1;\n            else\n                high = mid - 1;\n        }\n    return -1;\n}\n","function_prediction":"int search_name_conflict(int *arr, int n, int key) {\n  int low = 0;\n  int high = n - 1;\n  int mid;\n\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (arr[mid] == key)\n      return mid;\n    else if (arr[mid] < key)\n      low = mid + 1;\n    else\n      high = mid - 1;\n  }\n\n  return -1;\n}","pass":1}
{"function":"int search(int a[], int n, int val) {\n    int i;\n    for (i = 0; i < n; i++) {\n        if (a[i] == val)\n            return i;\n    }\n    return -1;\n}\n","function_prediction":"int search_name_conflict(int *array, int size, int value) {\n  int i;\n  for (i = 0; i < size; i++) {\n    if (array[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}","pass":1}
{"function":"int search(int a[], int n) {\n    int i;\n    int best_val = a[0];\n    for (i = 1; i < n; i++) {\n        if (a[i] > best_val)\n            best_val = a[i];\n    }\n    return best_val;\n}\n","function_prediction":"int search_name_conflict(int *arr, int n) {\n  int i, max = arr[0];\n  for (i = 1; i < n; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n}","pass":1}
{"function":"int is_leaf(struct node *here) {\n    if (here->left == ((void *)0) && here->right == ((void *)0))\n        return 1;\n    return 0;\n}\n","function_prediction":"int is_leaf_name_conflict(struct node *n) {\n  return (n->left == NULL && n->right == NULL);\n}","pass":1}
{"function":"struct node *make_node(int new_entry) {\n    struct node *a_node = (struct node *)malloc(sizeof(struct node));\n    a_node->entry = new_entry;\n    a_node->balance = 0;\n    a_node->right = ((void *)0);\n    a_node->left = ((void *)0);\n    return a_node;\n}\n","function_prediction":"struct node *make_node_name_conflict(int value) {\n  struct node *new_node = malloc(sizeof(struct node));\n  new_node->value = value;\n  new_node->next = NULL;\n  new_node->prev = NULL;\n  return new_node;\n}","pass":0}
{"function":"int is_entry(struct node *root, int a_entry) {\n    if (root == ((void *)0))\n        return 0;\n    else if (root->entry == a_entry)\n        return 1;\n    if (root->entry > a_entry)\n        return is_entry(root->left, a_entry);\n    return is_entry(root->right, a_entry);\n}\n","function_prediction":"int is_entry_name_conflict(struct node *root, int val) {\n  if (root == NULL)\n    return 0;\n\n  if (root->val == val)\n    return 1;\n\n  if (val < root->val)\n    return is_entry_name_conflict(root->left, val);\n  else\n    return is_entry_name_conflict(root->right, val);\n}","pass":0}
{"function":"struct node *find_entry(struct node *root, int a_entry) {\n    if (root == ((void *)0))\n        return root;\n    else if (root->entry == a_entry)\n        return root;\n    if (root->entry > a_entry)\n        return find_entry(root->left, a_entry);\n    return find_entry(root->right, a_entry);\n}\n","function_prediction":"struct bst_node *find_entry_name_conflict(struct bst_node *node, int key) {\n  if (node == NULL)\n    return NULL;\n\n  if (node->key == key)\n    return node;\n\n  if (key < node->key)\n    return find_entry_name_conflict(node->left, key);\n  else\n    return find_entry_name_conflict(node->right, key);\n}","pass":0}
{"function":"struct node *add_node(struct node *root, int new_entry) {\n    int work_needed;\n    return add_node_r(root, new_entry, &work_needed);\n}\n","function_prediction":"node *add_node_r(node *root, int data, int *height) {\n  if (root == NULL) {\n    *height = 1;\n    return make_node(data);\n  }\n\n  if (data < root->data) {\n    root->left = add_node_r(root->left, data, height);\n    if (*height) {\n      switch (root->balance) {\n      case 1:\n        root->balance = 0;\n        *height = 0;\n        break;\n      case 0:\n        root->balance = -1;\n        break;\n      case -1:\n        if (root->left->balance == 1) {\n          root = rotate_ll(root);\n        } else {\n          root = rotate_lr(root);\n        }\n        *height = 0;\n        break;\n      }\n    }\n  } else {\n    root->right = add_node_r(root->right, data, height);\n    if (*height) {\n      switch (root->balance) {\n      case 1:\n        root->balance = 0;\n        *height = 0;\n        break;\n      case 0:\n        root->balance = 1;\n        break;\n      case -1:\n        if (root->right->balance == -1) {\n          root = rotate_rr(root);\n        } else {\n          root = rotate_rl(root);\n        }\n        *height = 0;\n        break;\n      }\n    }\n  }\n\n  return root;\n}","pass":0}
{"function":"struct node *add_node_r(struct node *here, int new_entry, int *work_needed) {\n    if (here == ((void *)0)) {\n        *work_needed = 1;\n        return make_node(new_entry);\n    }\n    if (new_entry < here->entry) {\n        here->left = add_node_r(here->left, new_entry, work_needed);\n        if (*work_needed) {\n            switch (here->balance) {\n              case -1:\n                here->balance = 0;\n                *work_needed = 0;\n                return here;\n              case 0:\n                here->balance = 1;\n                return here;\n              case 1:\n                if (here->left->balance == 1)\n                    here = rotate_ll(here);\n                else\n                    here = rotate_lr(here);\n                *work_needed = 0;\n                return here;\n            }\n        }\n    } else {\n        here->right = add_node_r(here->right, new_entry, work_needed);\n        if (*work_needed) {\n            switch (here->balance) {\n              case 1:\n                here->balance = 0;\n                *work_needed = 0;\n                return here;\n              case 0:\n                here->balance = -1;\n                return here;\n              case -1:\n                if (here->right->balance == -1)\n                    here = rotate_rr(here);\n                else\n                    here = rotate_rl(here);\n                *work_needed = 0;\n                return here;\n            }\n        }\n    }\n    return here;\n}\n","function_prediction":"node *add_node_r_name_conflict(node *root, int data, int *height) {\n  if (root == NULL) {\n    *height = 1;\n    return make_node(data);\n  }\n\n  if (data < root->data) {\n    root->left = add_node_r_name_conflict(root->left, data, height);\n\n    if (*height) {\n      if (root->balance_factor == 1) {\n        if (root->left->balance_factor == 1) {\n          root = rotate_ll(root);\n        } else {\n          root = rotate_lr(root);\n        }\n        *height = 0;\n      } else if (root->balance_factor == 0) {\n        root->balance_factor = 1;\n      } else if (root->balance_factor == -1) {\n        root->balance_factor = 0;\n        *height = 0;\n      }\n    }\n  } else {\n    root->right = add_node_r_name_conflict(root->right, data, height);\n\n    if (*height) {\n      if (root->balance_factor == 1) {\n        root->balance_factor = 0;\n        *height = 0;\n      } else if (root->balance_factor == 0) {\n        root->balance_factor = -1;\n      } else if (root->balance_factor == -1) {\n        if (root->right->balance_factor == -1) {\n          root = rotate_rr(root);\n        } else {\n          root = rotate_rl(root);\n        }\n        *height = 0;\n      }\n    }\n  }\n\n  return root;\n}","pass":0}
{"function":"int max(int a, int b) {\n    return a > b ? a : b;\n}\n","function_prediction":"int max_name_conflict(int a, int b) { return a > b ? a : b; }","pass":1}
{"function":"struct node *rotate_ll(struct node *here) {\n    struct node *left = here->left;\n    here->left = left->right;\n    left->right = here;\n    here->balance = 0;\n    here = left;\n    here->balance = 0;\n    return here;\n}\n","function_prediction":"struct ll_node *rotate_ll_name_conflict(struct ll_node *node) {\n  struct ll_node *new_root = node->next;\n\n  node->next = new_root->next;\n  new_root->next = node;\n\n  node->is_root = 0;\n  new_root->is_root = 0;\n\n  return new_root;\n}","pass":0}
{"function":"struct node *rotate_rr(struct node *here) {\n    struct node *right = here->right;\n    here->right = right->left;\n    right->left = here;\n    here->balance = 0;\n    here = right;\n    here->balance = 0;\n    return here;\n}\n","function_prediction":"struct node *rotate_rr_name_conflict(struct node *root) {\n  struct node *new_root = root->right;\n  root->right = new_root->left;\n  new_root->left = root;\n  root->height = 0;\n  new_root->height = 0;\n  return new_root;\n}","pass":0}
{"function":"struct node *rotate_lr(struct node *here) {\n    struct node *left = here->left;\n    struct node *left_right = left->right;\n    left->right = left_right->left;\n    left_right->left = left;\n    here->left = left_right->right;\n    left_right->right = here;\n    if (left_right->balance == 1)\n        here->balance = -1;\n    else\n        here->balance = 0;\n    if (left_right->balance == -1)\n        left->balance = 1;\n    else\n        left->balance = 0;\n    here = left_right;\n    here->balance = 0;\n    return here;\n}\n","function_prediction":"struct node *rotate_lr_name_conflict(struct node *x) {\n  struct node *y = x->left;\n  struct node *b = y->right;\n\n  y->right = b->left;\n  b->left = y;\n  x->left = b->right;\n  b->right = x;\n\n  if (b->balance == 1)\n    x->balance = -1;\n  else\n    x->balance = 0;\n\n  if (b->balance == -1)\n    y->balance = 1;\n  else\n    y->balance = 0;\n\n  b->balance = 0;\n\n  return b;\n}","pass":0}
{"function":"struct node *rotate_rl(struct node *here) {\n    struct node *right = here->right;\n    struct node *right_left = right->left;\n    right->left = right_left->right;\n    right_left->right = right;\n    here->right = right_left->left;\n    right_left->left = here;\n    if (right_left->balance == -1)\n        here->balance = 1;\n    else\n        here->balance = 0;\n    if (right_left->balance == 1)\n        right->balance = -1;\n    else\n        right->balance = 0;\n    here = right_left;\n    here->balance = 0;\n    return here;\n}\n","function_prediction":"struct node *rotate_rl_name_conflict(struct node *root) {\n  struct node *temp = root->right;\n  root->right = temp->left;\n  temp->left = root;\n  root->parent = temp;\n  root->parent->parent = root;\n  if (root->parent->parent->balance == -1)\n    root->balance = 1;\n  else\n    root->balance = 0;\n  if (root->parent->parent->balance == 1)\n    root->parent->balance = -1;\n  else\n    root->parent->balance = 0;\n  root->parent->parent->balance = 0;\n  return temp;\n}","pass":0}
{"function":"struct node *latex_print(struct node *head, char *filename) {\n    FILE *fil;\n    fil = fopen(filename, \"wt\");\n    fprintf(fil, \"\\\\documentclass[11pt,a4paper]{scrartcl}\\n\");\n    fprintf(fil, \"\\\\typearea{12}\\n\");\n    fprintf(fil, \"\\\\usepackage{tikz-qtree}\\n\");\n    fprintf(fil, \"\\\\begin{document}\\n\");\n    fprintf(fil, \"\\\\tikzset{every tree node/.style={minimum width=2em,draw,circle},\\n\");\n    fprintf(fil, \"blank/.style={draw=none},\\n\");\n    fprintf(fil, \"edge from parent/.style=\\n\");\n    fprintf(fil, \"{draw,->, edge from parent path={(\\\\tikzparentnode) -- (\\\\tikzchildnode)}},\\n\");\n    fprintf(fil, \"level distance=1.5cm}\\n\");\n    fprintf(fil, \"\\\\begin{figure}\\n\");\n    fprintf(fil, \"\\\\begin{center}\\n\");\n    fprintf(fil, \"\\\\begin{tikzpicture}\\n\");\n    fprintf(fil, \"\\\\Tree\\n\");\n    head = latex_print_r(head, fil);\n    fprintf(fil, \"\\\\end{tikzpicture}\\n\");\n    fprintf(fil, \"\\\\end{center}\\n\");\n    fprintf(fil, \"\\\\end{figure}\\n\");\n    fprintf(fil, \"\\\\end{document}\\n\");\n    fclose(fil);\n    return head;\n}\n","function_prediction":"uint *latex_print_r(uint *tree, char *filename) {\n  FILE *fp;\n\n  fp = fopen(filename, \"wt\");\n\n  fprintf(fp, \"\\\\documentclass[11pt,a4paper]{scrartcl}\\n\");\n  fprintf(fp, \"\\\\typearea{12}\\n\");\n  fprintf(fp, \"\\\\usepackage{tikz-qtree}\\n\");\n  fprintf(fp, \"\\\\begin{document}\\n\");\n  fprintf(\n      fp,\n      \"\\\\tikzset{every tree node/.style={minimum width=2em,draw,circle},\\n\");\n  fprintf(fp, \"blank/.style={draw=none},\\n\");\n  fprintf(fp, \"edge from parent/.style=\\n\");\n  fprintf(fp, \"{draw,->, edge from parent path={(\\\\tikzparentnode) -- \"\n              \"(\\\\tikzchildnode)}},\\n\");\n  fprintf(fp, \"level distance=1.5cm}\\n\");\n  fprintf(fp, \"\\\\begin{figure}\\n\");\n  fprintf(fp, \"\\\\begin{center}\\n\");\n  fprintf(fp, \"\\\\begin{tikzpicture}\\n\");\n  fprintf(fp, \"\\\\Tree\\n\");\n\n  if (tree == NULL) {\n    fprintf(fp, \"\\\\edge[blank]; \\\\node[blank]{};\\n\");\n  } else if (tree->left == NULL && tree->right == NULL) {\n    fprintf(fp, \"\\\\edge;{%i}\\n\", tree->data);\n  } else {\n    fprintf(fp, \"[.%i \\n\", tree->data);\n    tree->left = latex_print_r(tree->left, fp);\n    tree->right = latex_print_r(tree->right, fp);\n    fprintf(fp, \"]\\n\");\n  }\n\n  fprintf(fp, \"\\\\end{tikzpicture}\\n\");\n  fprintf(fp, \"\\\\end{center}\\n\");\n  fprintf(fp, \"\\\\end{figure}\\n\");\n  fprintf(fp, \"\\\\end{document}\\n\");\n\n  fclose(fp);\n\n  return tree;\n}","pass":0}
{"function":"struct node *make_head(int new_entry) {\n    struct node *head = (struct node *)malloc(sizeof(struct node));\n    head->entry = new_entry;\n    head->next = ((void *)0);\n    return head;\n}\n","function_prediction":"head_t *make_head_name_conflict(int value) {\n  head_t *head = malloc(sizeof(head_t));\n  head->value = value;\n  head->next = NULL;\n  return head;\n}","pass":0}
{"function":"struct node *locate(struct node *iterator, int target) {\n    while (iterator->next != ((void *)0))\n        {\n            if (iterator->entry == target)\n                return iterator;\n            iterator = iterator->next;\n        }\n    if (iterator->entry == target)\n        return iterator;\n    return ((void *)0);\n}\n","function_prediction":"struct node *locate_name_conflict(struct node *head, int value) {\n  struct node *p;\n\n  p = head;\n  while (p->next != NULL) {\n    if (p->value == value)\n      return p;\n    p = p->next;\n  }\n  if (p->value == value)\n    return p;\n  return NULL;\n}","pass":0}
{"function":"struct node *make_node(int new_entry, int height, int *max_height) {\n    struct node *a_node = (struct node *)malloc(sizeof(struct node));\n    a_node->entry = new_entry;\n    a_node->height = height;\n    if (height > *max_height)\n        *max_height = height;\n    return a_node;\n}\n","function_prediction":"struct node *make_node_name_conflict(int value, int depth, int *max_depth) {\n  struct node *n = malloc(sizeof(struct node));\n  n->value = value;\n  n->depth = depth;\n  if (depth > *max_depth)\n    *max_depth = depth;\n  return n;\n}","pass":0}
{"function":"struct node *add_node(struct node *here, int new_entry, int height, int *max_height) {\n    if (here == ((void *)0))\n        return make_node(new_entry, height, max_height);\n    if (new_entry < here->entry)\n        here->left = add_node(here->left, new_entry, height + 1, max_height);\n    else\n        here->right = add_node(here->right, new_entry, height + 1, max_height);\n    return here;\n}\n","function_prediction":"struct node *add_node_name_conflict(struct node *root, int key, int depth,\n                                    char *name) {\n  if (root == NULL)\n    return make_node(key, depth, name);\n\n  if (key < root->key)\n    root->left = add_node_name_conflict(root->left, key, depth + 1, name);\n  else\n    root->right = add_node_name_conflict(root->right, key, depth + 1, name);\n\n  return root;\n}","pass":0}
{"function":"int is_leaf(struct node *here) {\n    if (here->left == ((void *)0) && here->right == ((void *)0))\n        return 1;\n    return 0;\n}\n","function_prediction":"int is_leaf_name_conflict(struct node *n) {\n  return (n->left == NULL && n->right == NULL);\n}","pass":1}
{"function":"struct node *make_node(int new_entry) {\n    struct node *a_node = (struct node *)malloc(sizeof(struct node));\n    a_node->entry = new_entry;\n    return a_node;\n}\n","function_prediction":"struct node *make_node_name_conflict(int value) {\n  struct node *new_node = malloc(sizeof(struct node));\n  new_node->value = value;\n  return new_node;\n}","pass":0}
{"function":"int is_entry(struct node *root, int a_entry) {\n    if (root == ((void *)0))\n        return 0;\n    else if (root->entry == a_entry)\n        return 1;\n    if (root->entry > a_entry)\n        return is_entry(root->left, a_entry);\n    return is_entry(root->right, a_entry);\n}\n","function_prediction":"int is_entry_name_conflict(struct node *root, int val) {\n  if (root == NULL)\n    return 0;\n\n  if (root->val == val)\n    return 1;\n\n  if (val < root->val)\n    return is_entry_name_conflict(root->left, val);\n  else\n    return is_entry_name_conflict(root->right, val);\n}","pass":0}
{"function":"struct node *find_entry(struct node *root, int a_entry) {\n    if (root == ((void *)0))\n        return root;\n    else if (root->entry == a_entry)\n        return root;\n    if (root->entry > a_entry)\n        return find_entry(root->left, a_entry);\n    return find_entry(root->right, a_entry);\n}\n","function_prediction":"struct bst_node *find_entry_name_conflict(struct bst_node *node, int key) {\n  if (node == NULL)\n    return NULL;\n\n  if (node->key == key)\n    return node;\n\n  if (key < node->key)\n    return find_entry_name_conflict(node->left, key);\n  else\n    return find_entry_name_conflict(node->right, key);\n}","pass":0}
{"function":"int rand_print(int big_n) {\n    int a = rand() % big_n;\n    printf(\"%d \", a);\n    return a;\n}\n","function_prediction":"int rand_print_name_conflict(int max) {\n  int r = rand() % max;\n  printf(\"%d \", r);\n  return r;\n}","pass":1}
{"function":"struct node *add_node(struct node *here, int new_entry) {\n    if (here == ((void *)0))\n        return make_node(new_entry);\n    if (new_entry < here->entry)\n        here->left = add_node(here->left, new_entry);\n    else\n        here->right = add_node(here->right, new_entry);\n    return here;\n}\n","function_prediction":"struct node *add_node_name_conflict(struct node *root, int data) {\n  if (root == NULL)\n    return make_node(data);\n  if (data < root->data)\n    root->left = add_node_name_conflict(root->left, data);\n  else\n    root->right = add_node_name_conflict(root->right, data);\n  return root;\n}","pass":0}
{"function":"int median(int a[], int i, int j, int k) {\n    if (a[i] > a[j] && a[i] > a[k])\n        return (a[j] > a[k]) ? j : k;\n    if (a[i] < a[j] && a[i] < a[k])\n        return (a[j] > a[k]) ? k : j;\n    return i;\n}\n","function_prediction":"int median_name_conflict(int *a, int i, int j, int k) {\n  if (a[i] < a[j]) {\n    if (a[i] < a[k]) {\n      if (a[j] < a[k])\n        return j;\n      else\n        return k;\n    } else\n      return i;\n  } else {\n    if (a[j] < a[k]) {\n      if (a[i] < a[k])\n        return i;\n      else\n        return k;\n    } else\n      return j;\n  }\n}","pass":1}
{"function":"int good_port(const int port) {\n    if (port >= 1024 && port <= 65535) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int good_port_name_conflict(int port) {\n  return (port >= 0 && port <= 1023 && port <= 65535);\n}","pass":0}
{"function":"int good_ip_addr(const char *ip) {\n    struct sockaddr_in sa;\n    int res = inet_pton(2, ip, &(sa.sin_addr));\n    return res != 0;\n}\n","function_prediction":"int good_ip_addr_name_conflict(const char *addr) {\n  struct sockaddr_in sa;\n  return inet_pton(2, addr, &sa.sin_addr) != 0;\n}","pass":1}
{"function":"int hostname_to_ip(char *hostname, char *ip) {\n    struct hostent *he;\n    struct in_addr **addr_list;\n    int i;\n    if ((he = gethostbyname(hostname)) == ((void *)0)) {\n        printf(\"Couldn't retrive the hostname from the machine...\\n\");\n        return 1;\n    }\n    addr_list = (struct in_addr **)he->h_addr_list;\n    for (i = 0; addr_list[i] != ((void *)0); i++) {\n        strcpy(ip, inet_ntoa(*addr_list[i]));\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int hostname_to_ip_name_conflict(char *hostname, char *ip) {\n  struct hostent *he;\n  struct in_addr **addr_list;\n  int i;\n\n  if ((he = gethostbyname(hostname)) == NULL) {\n    puts(\"Couldn't retrive the hostname from the machine...\");\n    return 1;\n  }\n\n  addr_list = (struct in_addr **)he->h_addr_list;\n\n  for (i = 0; addr_list[i] != NULL; i++) {\n    strcpy(ip, inet_ntoa(*addr_list[i]));\n    return 0;\n  }\n\n  return 1;\n}","pass":1}
{"function":"int verify_input(const short input_length) {\n    if (input_length > 140) {\n        printf(\"Error: Input too long.\\n\");\n        printf(\"You: \");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int verify_input_name_conflict(short input_length) {\n  if (input_length > 140) {\n    printf(\"Error: Input too long.\\n\");\n    printf(\"You: \");\n    return 1;\n  }\n  return 0;\n}","pass":0}
{"function":"SBTNode *SBT_CreateNode(ElementType NewData) {\n    SBTNode *NewNode = (SBTNode *)calloc(1, sizeof(SBTNode));\n    NewNode->Left = ((void *)0);\n    NewNode->Right = ((void *)0);\n    NewNode->Data = NewData;\n    return NewNode;\n}\n","function_prediction":"SBT_Node *SBT_CreateNode_name_conflict(char data) {\n  SBT_Node *node = (SBT_Node *)calloc(1, sizeof(SBT_Node));\n  node->left = NULL;\n  node->right = NULL;\n  node->data = data;\n  return node;\n}","pass":0}
{"function":"int OAHT_Hash(KeyType Key, int KeyLength, int TableSize) {\n    int i = 0;\n    int HashValue = 0;\n    for (i = 0; i < KeyLength; i++) {\n        HashValue = (HashValue << 3) + Key[i];\n    }\n    HashValue = HashValue % TableSize;\n    return HashValue;\n}\n","function_prediction":"int OAHT_Hash_name_conflict(char *key, int len, int size) {\n  int i, hash = 0;\n\n  for (i = 0; i < len; i++)\n    hash = hash * 8 + key[i];\n\n  return hash % size;\n}","pass":1}
{"function":"int OAHT_Hash2(KeyType Key, int KeyLength, int TableSize) {\n    int i = 0;\n    int HashValue = 0;\n    for (i = 0; i < KeyLength; i++) {\n        HashValue = (HashValue << 2) + Key[i];\n    }\n    HashValue = HashValue % (TableSize - 3);\n    return HashValue + 1;\n}\n","function_prediction":"int OAHT_Hash2_name_conflict(char *key, int len, int size) {\n  int i, sum = 0;\n  for (i = 0; i < len; i++)\n    sum += key[i];\n  return (sum % (size - 3)) + 1;\n}","pass":1}
{"function":"int SHT_Hash(KeyType Key, int TableSize) {\n    return Key % TableSize;\n}\n","function_prediction":"int SHT_Hash_name_conflict(int key, int size) { return key % size; }","pass":1}
{"function":"int CHT_Hash(int Key, int TableSize) {\n    return Key % TableSize;\n}\n","function_prediction":"int CHT_Hash_name_conflict(int key, int size) { return key % size; }","pass":1}
{"function":"int hashCode(int key) {\n    return key % 5;\n}\n","function_prediction":"int hashCode_name_conflict(int key) { return key % 5; }","pass":1}
{"function":"struct HashData *Hash_search(int key) {\n    int count;\n    count = 0;\n    int hashIndex = hashCode(key);\n    while (hashArray[hashIndex] != ((void *)0))\n        {\n            if (hashArray[hashIndex]->key == key)\n                return hashArray[hashIndex];\n            ++hashIndex;\n            hashIndex %= 5;\n            count++;\n            if (count > 5) {\n                printf(\"hash search fail! \\n\");\n                return ((void *)0);\n            }\n        }\n    return ((void *)0);\n}\n","function_prediction":"struct node *Hash_search_name_conflict(int key) {\n  int hashIndex = hashCode(key);\n  int count = 0;\n\n  while (hashArray[hashIndex] != NULL) {\n    if (hashArray[hashIndex]->key == key)\n      return hashArray[hashIndex];\n\n    hashIndex++;\n    hashIndex %= 5;\n\n    if (count++ > 5) {\n      puts(\"hash search fail! \");\n      return NULL;\n    }\n  }\n\n  return NULL;\n}","pass":1}
{"function":"int Hash_insert(int key, int data) {\n    int count;\n    count = 0;\n    struct HashData *item = (struct HashData *)malloc(sizeof(struct HashData));\n    item->data = data;\n    item->key = key;\n    int hashIndex = hashCode(key);\n    while (hashArray[hashIndex] != ((void *)0) && hashArray[hashIndex]->key != -1)\n        {\n            ++hashIndex;\n            hashIndex %= 5;\n            count++;\n            if (count > 5) {\n                printf(\"hash full! \\n\");\n                return -1;\n            }\n        }\n    hashArray[hashIndex] = item;\n    printf(\"Hash_inserted! \\n\");\n    return 0;\n}\n","function_prediction":"int Hash_insert_name_conflict(int key, int value) {\n  int hashIndex = hashCode(key);\n  int i = 0;\n  HashNode *newNode = (HashNode *)malloc(sizeof(HashNode));\n  newNode->key = key;\n  newNode->value = value;\n\n  while (hashArray[hashIndex] != NULL && hashArray[hashIndex]->key != -1) {\n    ++hashIndex;\n    hashIndex %= 5;\n    if (i > 5) {\n      printf(\"hash full! \\n\");\n      return -1;\n    }\n  }\n\n  hashArray[hashIndex] = newNode;\n  printf(\"Hash_insert_name_conflicted!\\n\");\n  return 0;\n}","pass":0}
{"function":"struct HashData *Hash_delete(struct HashData *item) {\n    int key = item->key;\n    int count;\n    count = 0;\n    int hashIndex = hashCode(key);\n    while (hashArray[hashIndex] != ((void *)0))\n        {\n            if (hashArray[hashIndex]->key == key) {\n                struct HashData *temp = hashArray[hashIndex];\n                hashArray[hashIndex] = dummyItem;\n                return temp;\n            }\n            ++hashIndex;\n            hashIndex %= 5;\n            count++;\n            if (count > 5) {\n                printf(\"hash delete fail! \\n\");\n                return ((void *)0);\n            }\n        }\n    return ((void *)0);\n}\n","function_prediction":"Item *Hash_delete_name_conflict(Item *item) {\n  int key = item->key;\n  int hashIndex = hashCode(key);\n\n  int count = 0;\n\n  while (hashArray[hashIndex] != NULL && hashArray[hashIndex]->key != key) {\n    hashIndex++;\n    hashIndex %= 5;\n    count++;\n    if (count > 5) {\n      puts(\"hash delete fail! \");\n      return NULL;\n    }\n  }\n\n  if (hashArray[hashIndex] == NULL) {\n    return NULL;\n  } else {\n    Item *tempItem = hashArray[hashIndex];\n    hashArray[hashIndex] = &dummyItem;\n    return tempItem;\n  }\n}","pass":0}
{"function":"LCRSNode *LCRS_CreateNode(ElementType NewData) {\n    LCRSNode *NewNode = (LCRSNode *)calloc(1, sizeof(LCRSNode));\n    NewNode->LeftChild = ((void *)0);\n    NewNode->RightSibling = ((void *)0);\n    NewNode->Data = NewData;\n    return NewNode;\n}\n","function_prediction":"LCRSNode *LCRS_CreateNode_name_conflict(char data) {\n  LCRSNode *newNode = calloc(1, sizeof(LCRSNode));\n\n  newNode->LeftChild = NULL;\n  newNode->RightSibling = NULL;\n  newNode->Data = data;\n\n  return newNode;\n}","pass":0}
{"function":"int BruteForce(char *Text, int TextSize, int Start, char *Pattern, int PatternSize) {\n    int i = 0;\n    int j = 0;\n    for (i = Start; i <= TextSize - PatternSize; i++) {\n        for (j = 0; j < PatternSize; j++) {\n            if (Text[i + j] != Pattern[j]) {\n                break;\n            }\n        }\n        if (j >= PatternSize) {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int BruteForce(char *text, int text_len, int pos, char *pattern,\n               int pattern_len) {\n  int i, j;\n  for (i = pos; i <= text_len - pattern_len; i++) {\n    for (j = 0; j < pattern_len; j++) {\n      if (text[i + j] != pattern[j])\n        break;\n    }\n    if (j >= pattern_len)\n      return i;\n  }\n  return -1;\n}","pass":0}
{"function":"int Partition(int Dataset[], int left, int right) {\n    int first = left;\n    int pivot = Dataset[first];\n    printf(\"\\n\");\n    printf(\"left :%d , right:%d, pivot:%d\", left, right, pivot);\n    printf(\"======\\n\");\n    for (int i = 0; i < 6; i++) {\n        printf(\"%d \\n\", Dataset[i]);\n    }\n    printf(\"======\\n\");\n    ++left;\n    while (left <= right)\n        {\n            while (Dataset[left] <= pivot && left < right)\n                ++left;\n            while (Dataset[right] > pivot && left <= right)\n                --right;\n            printf(\"left :%d , right:%d\\n\", left, right);\n            if (left < right)\n                swap(&Dataset[left], &Dataset[right]);\n            else\n                break;\n        }\n    swap(&Dataset[first], &Dataset[right]);\n    return right;\n}\n","function_prediction":"int Partition_name_conflict(int *arr, int left, int right) {\n  int pivot = arr[left];\n  int l = left + 1;\n  int r = right;\n  int i;\n  printf(\"\\n\");\n  printf(\"left :%d , right:%d, pivot:%d\", left, right, pivot);\n  printf(\"======\\n\");\n  for (i = 0; i < 6; i++) {\n    printf(\"%d \\n\", arr[i]);\n  }\n  printf(\"======\\n\");\n  while (l <= r) {\n    while (arr[l] <= pivot && l < r) {\n      l++;\n    }\n    while (arr[r] > pivot && l <= r) {\n      r--;\n    }\n    printf(\"left :%d , right:%d\\n\", l, r);\n    if (l < r) {\n      swap(&arr[l], &arr[r]);\n    }\n  }\n  swap(&arr[left], &arr[r]);\n  return r;\n}","pass":1}
{"function":"ULONG Fibonacci(int N) {\n    int i;\n    ULONG Result;\n    ULONG *FibonacciTable;\n    if (N == 0 || N == 1) {\n        return N;\n    }\n    FibonacciTable = (ULONG *)malloc(sizeof(ULONG) * (N + 1));\n    FibonacciTable[0] = 0;\n    FibonacciTable[1] = 1;\n    for (i = 2; i <= N; i++) {\n        FibonacciTable[i] = FibonacciTable[i - 1] + FibonacciTable[i - 2];\n    }\n    Result = FibonacciTable[N];\n    free(FibonacciTable);\n    return Result;\n}\n","function_prediction":"long long Fibonacci_name_conflict(int n) {\n  if (n == 0 || n == 1)\n    return n;\n\n  long long *fib = (long long *)malloc(sizeof(long long) * (n + 1));\n  fib[0] = 0;\n  fib[1] = 1;\n\n  for (int i = 2; i <= n; i++)\n    fib[i] = fib[i - 2] + fib[i - 1];\n\n  long long result = fib[n];\n  free(fib);\n  return result;\n}","pass":1}
{"function":"int isEmpty(struct stack *s) {\n    return s->top == -1;\n}\n","function_prediction":"int isEmpty_name_conflict(struct stack *s) {\n  if (s->top == -1)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"int isEmpty(struct stack *s) {\n    return s->top == -1;\n}\n","function_prediction":"int isEmpty_name_conflict(struct stack *s) {\n  if (s->top == -1)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"char pop(struct stack *s) {\n    if (!isEmpty(s))\n        return s->A[s->top--];\n    return '$';\n}\n","function_prediction":"int pop_name_conflict(Stack *stack) {\n  if (!isEmpty(stack)) {\n    return stack->data[stack->top--];\n  } else {\n    return 36;\n  }\n}","pass":0}
{"function":"char peek(struct stack *s) {\n    return s->A[s->top];\n}\n","function_prediction":"int peek_name_conflict(struct stack *s) { return s->data[s->top + 1]; }","pass":0}
{"function":"int evaluatePostfix(char *exp) {\n    struct stack s;\n    s.top = -1;\n    int i;\n    for (i = 0; exp[i] != '\\x00'; ++i) {\n        if (((*__ctype_b_loc())[(int)((exp[i]))] & (unsigned short)_ISdigit))\n            push(&s, exp[i] - '0');\n        else {\n            int val1 = pop(&s);\n            int val2 = pop(&s);\n            switch (exp[i]) {\n              case '+':\n                push(&s, val2 + val1);\n                break;\n              case '-':\n                push(&s, val2 - val1);\n                break;\n              case '*':\n                push(&s, val2 * val1);\n                break;\n              case '/':\n                push(&s, val2 / val1);\n                break;\n            }\n        }\n    }\n    return pop(&s);\n}\n","function_prediction":"int evaluatePostfix_name_conflict(char *postfix) {\n  int i, op1, op2;\n  char c;\n  int stack[16];\n  stack[0] = -1;\n  for (i = 0; postfix[i] != '\\0'; i++) {\n    c = postfix[i];\n    if ((__ctype_b_loc()[c] & 02000) != 0) {\n      push(stack, c - '0');\n    } else {\n      op1 = pop(stack);\n      op2 = pop(stack);\n      switch (c) {\n      case '+':\n        push(stack, op2 + op1);\n        break;\n      case '-':\n        push(stack, op2 - op1);\n        break;\n      case '*':\n        push(stack, op2 * op1);\n        break;\n      case '/':\n        push(stack, op2 / op1);\n        break;\n      }\n    }\n  }\n  return pop(stack);\n}","pass":0}
{"function":"int isEmpty(struct stack *s) {\n    return s->top == -1;\n}\n","function_prediction":"int isEmpty_name_conflict(struct stack *s) {\n  if (s->top == -1)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"char pop(struct stack *s) {\n    if (!isEmpty(s))\n        return s->A[s->top--];\n    return '$';\n}\n","function_prediction":"char pop_name_conflict(Stack *stack) {\n  if (!isEmpty(stack)) {\n    return stack->data[stack->top--];\n  } else {\n    return '$';\n  }\n}","pass":0}
{"function":"char peek(struct stack *s) {\n    return s->A[s->top];\n}\n","function_prediction":"char peek_name_conflict(struct stack *s) { return s->data[s->top + 1]; }","pass":0}
{"function":"int isOperand(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n","function_prediction":"int isOperand_name_conflict(char c) {\n  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n    return 1;\n  return 0;\n}","pass":1}
{"function":"int prec(char c) {\n    if (c == '^')\n        return 3;\n    else if (c == '*' || c == '/')\n        return 2;\n    else if (c == '+' || c == '-')\n        return 1;\n    else\n        return -1;\n}\n","function_prediction":"int prec_name_conflict(char op) {\n  if (op == '^')\n    return 3;\n  else if (op == '*' || op == '/')\n    return 2;\n  else if (op == '+' || op == '-')\n    return 1;\n  else\n    return -1;\n}","pass":1}
{"function":"int infixToPostfix(char *exp) {\n    int i, k;\n    struct stack s;\n    s.top = -1;\n    for (i = 0 , k = -1; exp[i]; ++i) {\n        if (isOperand(exp[i]))\n            exp[++k] = exp[i];\n        else if (exp[i] == '(')\n            push(&s, exp[i]);\n        else if (exp[i] == ')') {\n            while (!isEmpty(&s) && peek(&s) != '(')\n                exp[++k] = pop(&s);\n            if (!isEmpty(&s) && peek(&s) != '(')\n                return -1;\n            else\n                pop(&s);\n        } else {\n            while (!isEmpty(&s) && prec(exp[i]) <= prec(peek(&s)))\n                exp[++k] = pop(&s);\n            push(&s, exp[i]);\n        }\n    }\n    while (!isEmpty(&s))\n        exp[++k] = pop(&s);\n    exp[++k] = '\\x00';\n    printf(\"\\n\\tPostfix expression: %s\\n\", exp);\n    return 0;\n}\n","function_prediction":"int infixToPostfix_name_conflict(char *infix) {\n  int i = 0, j = -1;\n  char c;\n  char stack[100] = {'\\0'};\n\n  do {\n    if (infix[i] == '\\0') {\n      while (!isEmpty(stack)) {\n        j++;\n        infix[j] = pop(stack);\n      }\n      j++;\n      infix[j] = '\\0';\n      printf(\"\\n\\tPostfix expression: %s\\n\", infix);\n      return 0;\n    }\n\n    if (!isOperand(infix[i])) {\n      if (infix[i] == '(')\n        push(stack, infix[i]);\n      else if (infix[i] == ')') {\n        while (!isEmpty(stack) && peek(stack) != '(') {\n          j++;\n          infix[j] = pop(stack);\n        }\n        if (!isEmpty(stack) && peek(stack) != '(')\n          return -1;\n        else\n          pop(stack);\n      } else {\n        while (!isEmpty(stack) && prec(infix[i]) <= prec(peek(stack))) {\n          j++;\n          infix[j] = pop(stack);\n        }\n        push(stack, infix[i]);\n      }\n    } else {\n      j++;\n      infix[j] = infix[i];\n    }\n    i++;\n  } while (1);\n}","pass":1}
{"function":"int isEmpty(struct stack *s) {\n    return s->top == -1;\n}\n","function_prediction":"int isEmpty_name_conflict(struct stack *s) {\n  if (s->top == -1)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"char peek(struct stack *s) {\n    return s->A[s->top];\n}\n","function_prediction":"char peek_name_conflict(struct stack *s) { return s->data[s->top + 1]; }","pass":0}
{"function":"int isMatchingPair(char character1, char character2) {\n    if (character1 == '(' && character2 == ')')\n        return 1;\n    else if (character1 == '{' && character2 == '}')\n        return 1;\n    else if (character1 == '[' && character2 == ']')\n        return 1;\n    else\n        return 0;\n}\n","function_prediction":"bool isMatchingPair_name_conflict(char character1, char character2) {\n  if (character1 == '(' && character2 == ')')\n    return true;\n  else if (character1 == '{' && character2 == '}')\n    return true;\n  else if (character1 == '[' && character2 == ']')\n    return true;\n  else\n    return false;\n}","pass":0}
{"function":"int partition(int arr[], int l, int r) {\n    int pivotEl = arr[r];\n    int Pindex = l;\n    int i;\n    for (i = l; i < r; i++) {\n        if (arr[i] <= pivotEl) {\n            swap(&arr[Pindex], &arr[i]);\n            Pindex++;\n        }\n    }\n    swap(&arr[Pindex], &arr[r]);\n    return Pindex;\n}\n","function_prediction":"int partition_name_conflict(int *arr, int low, int high) {\n  int pivot = arr[high];\n  int i = low;\n  for (int j = low; j < high; j++) {\n    if (arr[j] <= pivot) {\n      swap(&arr[i], &arr[j]);\n      i++;\n    }\n  }\n  swap(&arr[i], &arr[high]);\n  return i;\n}","pass":1}
{"function":"int retTop(struct stack *s) {\n    return (s->A)[s->top];\n}\n","function_prediction":"int retTop_name_conflict(int *stack) { return stack[stack[10]]; }","pass":1}
{"function":"int isEmpty(struct stack *s) {\n    if (s->top == -1)\n        return 1;\n    return 0;\n}\n","function_prediction":"int isEmpty_name_conflict(struct stack *s) {\n  if (s->top == -1)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"int searchList(struct Node *start, int key) {\n    struct Node *temp = start;\n    printf(\"\\nTraversal in forward direction \\n\");\n    while (temp->next != start)\n        {\n            if (temp->data == key)\n                return 1;\n            temp = temp->next;\n        }\n    return -1;\n}\n","function_prediction":"int searchList_name_conflict(struct node *head, int key) {\n  struct node *p;\n  p = head;\n  printf(\"\\nTraversal in forward direction \\n\");\n  while (p->next != NULL) {\n    if (p->data == key) {\n      return 1;\n    }\n    p = p->next;\n  }\n  return -1;\n}","pass":0}
{"function":"bool isEmpty() {\n    return head == ((void *)0);\n}\n","function_prediction":"int isEmpty_name_conflict() {\n  if (head == NULL)\n    return 1;\n  else\n    return 0;\n}","pass":1}
{"function":"int getword(char *word) {\n    int i = 0;\n    char c = ' ';\n    while (c != (-1) && c <= ' ')\n        c = getc(stdin);\n    if (c == (-1))\n        return 0;\n    while (c != (-1) && c > ' ')\n        {\n            if (i >= 100 - 1)\n                return -1;\n            i++;\n            *word++ = c;\n            if (c == '(' || c == ')')\n                break;\n            c = getc(stdin);\n            if (c == '(' || c == ')') {\n                ungetc(c, stdin);\n                break;\n            }\n        }\n    *word = '\\x00';\n    return 1;\n}\n","function_prediction":"int getword_name_conflict(char *word) {\n  int c, len;\n  char *p;\n\n  len = 0;\n  c = ' ';\n  while (c != EOF && c <= ' ')\n    c = getc(stdin);\n  if (c == EOF)\n    return 0;\n  p = word;\n  while (c != EOF && c > ' ') {\n    if (len++ >= 100)\n      return -1;\n    *p++ = c;\n    if (c == '(' || c == ')')\n      break;\n    c = getc(stdin);\n  }\n  if (c != EOF && c > ' ')\n    ungetc(c, stdin);\n  *p = '\\0';\n  return 1;\n}","pass":1}
{"function":"int indent(int n) {\n    int d;\n    for (d = 0; d < n; d++)\n        putchar(' ');\n}\n","function_prediction":"void indent_name_conflict(int n) {\n  int i;\n  for (i = 0; i < n; i++)\n    putchar(' ');\n}","pass":0}
{"function":"int partition(char *arr[], int l, int r) {\n    char *pivot = arr[l];\n    char *temp;\n    int low = l;\n    int high = r;\n    while (1)\n        {\n            low++;\n            while (low < r && strcmp(arr[low], pivot) <= 0)\n                {\n                    low++;\n                }\n            high--;\n            while (high > l && strcmp(arr[high], pivot) > 0)\n                {\n                    high--;\n                }\n            if (low < high) {\n                temp = arr[low];\n                arr[low] = arr[high];\n                arr[high] = temp;\n            } else {\n                temp = arr[l];\n                arr[l] = arr[high];\n                arr[high] = temp;\n                return (high);\n            }\n        }\n}\n","function_prediction":"int partition_name_conflict(char **a, int l, int r) {\n  char *pivot = a[l];\n  int i = l;\n  int j = r;\n  char *temp;\n\n  while (i < j) {\n    while (i < j && strcmp(a[j], pivot) <= 0)\n      j--;\n    while (i < j && strcmp(a[i], pivot) > 0)\n      i++;\n    if (i < j) {\n      temp = a[i];\n      a[i] = a[j];\n      a[j] = temp;\n    }\n  }\n\n  if (i > l) {\n    temp = a[l];\n    a[l] = a[i];\n    a[i] = temp;\n  }\n\n  return i;\n}","pass":1}
{"function":"int partitionPlus(char *arr[], int l, int r) {\n    char *it[] = {arr[l], arr[r - 1], arr[(l + r) / 2]};\n    insertionsort(it, 0, 3);\n    char *pivot = it[1];\n    char *temp;\n    int low = l;\n    int high = r;\n    while (1)\n        {\n            low++;\n            while (low < r && strcmp(arr[low], pivot) <= 0)\n                {\n                    low++;\n                }\n            high--;\n            while (high > l && strcmp(arr[high], pivot) > 0)\n                {\n                    high--;\n                }\n            if (low < high) {\n                temp = arr[low];\n                arr[low] = arr[high];\n                arr[high] = temp;\n            } else {\n                temp = arr[l];\n                arr[l] = arr[high];\n                arr[high] = temp;\n                return (high);\n            }\n        }\n}\n","function_prediction":"int partitionPlus_name_conflict(char **A, int p, int r) {\n  char *pivot[3];\n  pivot[0] = A[p];\n  pivot[1] = A[r - 1];\n  pivot[2] = A[(p + r) / 2];\n  insertionsort(pivot, 0, 3);\n  char *piv = pivot[1];\n  int i = p;\n  int j = r;\n  while (1) {\n    while (strcmp(A[++i], piv) > 0)\n      if (i >= r)\n        break;\n    while (strcmp(A[--j], piv) > 0)\n      if (j <= p)\n        break;\n    if (i >= j)\n      break;\n    char *temp = A[i];\n    A[i] = A[j];\n    A[j] = temp;\n  }\n  if (j > i) {\n    char *temp = A[p];\n    A[p] = A[j];\n    A[j] = temp;\n  }\n  return j;\n}","pass":1}
{"function":"int partition(int arr[], int l, int r) {\n    int pivot = arr[l];\n    int temp = 0;\n    int low = l - 1;\n    int high = r + 1;\n    while (1)\n        {\n            low++;\n            while (low < r && arr[low] < pivot)\n                {\n                    low++;\n                }\n            high--;\n            while (high > l && arr[high] > pivot)\n                {\n                    high--;\n                }\n            if (low < high) {\n                temp = arr[low];\n                arr[low] = arr[high];\n                arr[high] = temp;\n            } else {\n                return (high);\n            }\n        }\n}\n","function_prediction":"int partition_name_conflict(int *a, int l, int r) {\n  int pivot = a[l];\n  int i = l - 1;\n  int j = r + 1;\n  while (1) {\n    do {\n      i++;\n    } while (a[i] < pivot);\n    do {\n      j--;\n    } while (a[j] > pivot);\n    if (i < j) {\n      int tmp = a[i];\n      a[i] = a[j];\n      a[j] = tmp;\n    } else {\n      return j;\n    }\n  }\n}","pass":1}
{"function":"int compute_fibonacci(int n) {\n    int temp;\n    int a = 1;\n    int b = 1;\n    for (int x = 0; x < n; x++) {\n        temp = a;\n        a += b;\n        b = temp;\n    }\n    return a;\n}\n","function_prediction":"int compute_fibonacci_name_conflict(int n) {\n  int i;\n  int a = 1;\n  int b = 1;\n  int c;\n\n  for (i = 0; i < n; i++) {\n    c = a + b;\n    b = a;\n    a = c;\n  }\n\n  return a;\n}","pass":1}
{"function":"int print(num, n)\n    int num;\n    int n;\n {\n    if (num <= 8) {\n        int result = 0;\n        result = ((pow(2, num)) * n);\n        printf(\"%d \", (result));\n        print(num + 1, n);\n    }\n}\n","function_prediction":"void print_name_conflict(int i, int n) {\n  if (i < 9) {\n    print_name_conflictf(\"%d \", (int)(pow(2, i) * n));\n    print_name_conflict(i + 1, n);\n  }\n}","pass":0}
{"function":"int main1(int argc, const char *argv[]) {\n    int c;\n    int state = 1;\n    while ((c = getchar()) != (-1))\n        {\n            if (c != ' ') {\n                putchar(c);\n                state = 0;\n            } else if (state == 0) {\n                state = 1;\n                putchar(c);\n            }\n        }\n    return 0;\n}\n","function_prediction":"int main1_name_conflict() {\n  int c, state;\n\n  state = 1;\n  while ((c = getchar()) != EOF) {\n    if (c == ' ') {\n      if (state == 0) {\n        putchar(c);\n        state = 1;\n      }\n    } else {\n      putchar(c);\n      state = 0;\n    }\n  }\n  return 0;\n}","pass":1}
{"function":"int mai2(int argc, const char *argv[]) {\n    int c;\n    int prev = (-1);\n    while ((c = getchar()) != (-1))\n        {\n            if (c == ' ') {\n                if (prev != ' ') {\n                    putchar(c);\n                }\n            } else {\n                putchar(c);\n            }\n            prev = c;\n        }\n    return 0;\n}\n","function_prediction":"int mai2_name_conflict() {\n  int c, last;\n\n  last = -1;\n  while ((c = getchar()) != -1) {\n    if (c == ' ') {\n      if (last != ' ') {\n        putchar(c);\n      }\n      last = c;\n    } else {\n      putchar(c);\n      last = c;\n    }\n  }\n  return 0;\n}","pass":1}
{"function":"int str_len(char *s) {\n    int n;\n    for (n = 0; *s != '\\x00'; s++)\n        n++;\n    return n;\n}\n","function_prediction":"int str_len_name_conflict(char *str) {\n  int len = 0;\n  char *p = str;\n  while (*p++)\n    len++;\n  return len;\n}","pass":1}
{"function":"ptrdiff_t str_len2(char *s) {\n    char *p = s;\n    while (*p != '\\x00')\n        p++;\n    return p - s;\n}\n","function_prediction":"size_t str_len2_name_conflict(const char *str) {\n  const char *p = str;\n  while (*p)\n    p++;\n  return p - str;\n}","pass":1}
{"function":"unsigned int hash(char *s) {\n    unsigned int hashval;\n    for (hashval = 0UL; *s != '\\x00'; s++)\n        hashval = *s + 31 * hashval;\n    return hashval % 1;\n}\n","function_prediction":"int hash_name_conflict(char *str) {\n  int i = 0;\n  while (str[i] != '\\0')\n    i++;\n  return 0;\n}","pass":1}
{"function":"int uninstall(char *name) {\n    struct nlist *np1, *np2;\n    unsigned int hashval = hash(name);\n    for (np1 = hashtable[hashval] , np2 = ((void *)0); np1 != ((void *)0); np2 = np1 , np1 = np1->next) {\n        if (strcmp(name, np1->name) == 0) {\n            if (np2 == ((void *)0))\n                hashtable[hashval] = np1->next;\n            else\n                np2->next = np1->next;\n            free(np1->name);\n            free(np1->defn);\n            free(np1);\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int uninstall_name_conflict(const char *name) {\n  int h = hash(name);\n  struct entry *e = hashtable[h], *prev = NULL;\n\n  while (e) {\n    if (!strcmp(name, e->name)) {\n      if (prev)\n        prev->next = e->next;\n      else\n        hashtable[h] = e->next;\n      free(e->name);\n      free(e->value);\n      free(e);\n      return 1;\n    }\n    prev = e;\n    e = e->next;\n  }\n  return 0;\n}","pass":0}
{"function":"int get_line(char *line, int lim) {\n    int i, c;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        *line++ = c;\n    }\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *s, int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    *s++ = c;\n  if (c == '\\n') {\n    *s++ = c;\n    ++i;\n  }\n  *s = '\\0';\n  return i;\n}","pass":1}
{"function":"char *month_name(int n) {\n    static char *names[] = {\"\\351\\235\\236\\346\\263\\225\", \"\\344\\270\\200\", \"\\344\\272\\214\", \"\\344\\270\\211\", \"\\345\\233\\233\", \"\\344\\272\\224\", \"\\345\\205\\255\", \"\\344\\270\\203\", \"\\345\\205\\253\", \"\\344\\271\\235\", \"\\345\\215\\201\", \"\\345\\215\\201\\344\\270\\200\", \"\\345\\215\\201\\344\\272\\214\"};\n    return (n >= 1 && n <= 12) ? names[n] : names[0];\n}\n","function_prediction":"const char *month_name_name_conflict(int n) {\n  static const char *const names[] = {\n      \"Illegal month\", \"January\",  \"February\", \"March\",  \"April\",\n      \"May\",           \"June\",     \"July\",     \"August\", \"September\",\n      \"October\",       \"November\", \"December\"};\n\n  return (n > 0 && n < 13) ? names[n] : names[0];\n}","pass":0}
{"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    while (low <= high)\n        {\n            mid = (low + high) / 2;\n            if (x < v[mid]) {\n                high = mid - 1;\n            } else if (x > v[mid]) {\n                low = mid + 1;\n            } else {\n                return mid;\n            }\n        }\n    return -1;\n}\n","function_prediction":"int binsearch_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (x < v[mid])\n      high = mid - 1;\n    else if (x > v[mid])\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}","pass":1}
{"function":"char *str_dup(char *s) {\n    char *p = (char *)malloc(strlen(s) + 1);\n    strcpy(p, s);\n    return p;\n}\n","function_prediction":"char *str_dup_name_conflict(const char *s) {\n  char *p = malloc(strlen(s) + 1);\n  strcpy(p, s);\n  return p;\n}","pass":0}
{"function":"int getword(char *word, int lim) {\n    int getch(void);\n    void ungetch(int);\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISblank))\n        ;\n    if (c != (-1)) {\n        *word++ = c;\n    }\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --lim; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (isalpha(c) || c == '_' || c == '#')\n    for (; --lim > 0; w++)\n      if (!isalnum(*w = getch()) && *w != '_') {\n        ungetch(*w);\n        break;\n      }\n  *w = '\\0';\n  return c;\n}","pass":1}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > buffer)\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":0}
{"function":"unsigned int invert(unsigned int x, int p, int n) {\n    return setbits(x, p, n, getbits(~x, p, n));\n}\n","function_prediction":"unsigned int invert_name_conflict(unsigned int x, int p, int n) {\n  return setbits(x, p, n, getbits(~x, p, n));\n}","pass":0}
{"function":"unsigned int getbits(unsigned int x, int p, int n) {\n    return (x >> (p + 1 - n)) & ~(~0 << n);\n}\n","function_prediction":"unsigned int getbits_name_conflict(unsigned int x, unsigned int p,\n                                   unsigned int n) {\n  return (x >> (p + 1 - n)) & ~(~0 << n);\n}","pass":0}
{"function":"unsigned int setbits(unsigned int x, int p, int n, unsigned int y) {\n    unsigned int padding = p + 1 - n;\n    unsigned int target = (~(~0 << n) & y) << padding;\n    unsigned int empty = ((~0 << (p + 1)) | ~(~0 << padding)) & x;\n    return target | empty;\n}\n","function_prediction":"unsigned int setbits(unsigned int x, unsigned int p, unsigned int n,\n                     unsigned int y) {\n  return (x & ~(~(~0U << n) << (p + 1 - n))) |\n         ((y & ~(~0U << n)) << (p + 1 - n));\n}","pass":0}
{"function":"int gettoken(void) {\n    int c;\n    char *p = token;\n    while ((c = getch()) == ' ' || c == '\\t')\n        ;\n    if (c == '(') {\n        if ((c = getch()) == ')') {\n            strcpy(token, \"()\");\n            tokentype = PARENS;\n        } else {\n            ungetch(c);\n            tokentype = '(';\n        }\n    } else if (c == '[') {\n        for (*p++ = c; (*p++ = getch()) != ']';)\n            ;\n        *p = '\\x00';\n        tokentype = BRACKETS;\n    } else if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        for (*p++ = c; ((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISalnum);)\n            *p++ = c;\n        *p = '\\x00';\n        ungetch(c);\n        tokentype = NAME;\n    } else\n        tokentype = c;\n    return tokentype;\n}\n","function_prediction":"int gettoken_name_conflict(void) {\n  int c, getch(void);\n  void ungetch(int);\n  char *p = token;\n\n  while ((c = getch()) == ' ' || c == '\\t')\n    ;\n\n  if (c == '(') {\n    if ((c = getch()) == ')') {\n      _token = (c << 8) | c;\n      *p = '\\0';\n      return tokentype = 1;\n    } else {\n      ungetch(c);\n      return tokentype = '(';\n    }\n  } else if (c == '[') {\n    for (*p++ = c; (*p++ = getch()) != ']';)\n      ;\n    *p = '\\0';\n    return tokentype = 2;\n  } else if (isalpha(c)) {\n    for (*p++ = c; isalnum(c = getch());)\n      *p++ = c;\n    *p = '\\0';\n    ungetch(c);\n    return tokentype = 0;\n  } else\n    return tokentype = c;\n}","pass":0}
{"function":"int getch(void) {\n    return buffp > buffer ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > buffer)\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int lower(int c) {\n    if (c >= 'A' && c <= 'Z') {\n        return c + ('a' - 'A');\n    } else {\n        return c;\n    }\n}\n","function_prediction":"void lower_line(char *line) {\n  int i;\n\n  for (i = 0; line[i]; i++)\n    line[i] = lower(line[i]);\n}","pass":0}
{"function":"int get_line(char line[], int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int get_line(char *line, int lim) {\n    int i, c;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        *line++ = c;\n    }\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *s, int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    *s++ = c;\n  if (c == '\\n') {\n    *s++ = c;\n    ++i;\n  }\n  *s = '\\0';\n  return i;\n}","pass":1}
{"function":"int get_line(void) {\n    int c, i;\n    extern char line[];\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; ++i)\n        line[i] = c;\n    if (c == '\\n') {\n        line[i] = c;\n        ++i;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(void) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1; ++i) {\n    c = getchar();\n    if (c == EOF || c == '\\n')\n      break;\n    line[i] = c;\n  }\n  if (c == '\\n') {\n    line[i] = c;\n    ++i;\n  }\n  line[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int getword(char *word, int lim) {\n    int getch(void);\n    void ungetch(int);\n    int c;\n    while ((c = getch()) == ' ' || c == '\\t')\n        ;\n    if (c != (-1)) {\n        *word++ = c;\n    }\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --lim > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n\n  while (isspace(c = getch()) || c == '\\t')\n    ;\n\n  if (c != EOF)\n    *word++ = c;\n\n  if (!isalpha(c) && c != '_' && c != '#') {\n    *word = '\\0';\n    return c;\n  }\n\n  for (; --lim > 0; word++) {\n    if (!isalnum(*word = getch()) && *word != '_') {\n      ungetch(*word);\n      break;\n    }\n  }\n\n  *word = '\\0';\n  return word[0];\n}","pass":1}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > \"\")\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int day_of_year(int year, int month, int day) {\n    int i;\n    int leap = (((year) % 4 == 0 && (year) % 100 != 0) || (year) % 400 == 0);\n    for (i = 1; i < month; i++) {\n        day += daytab[leap][i];\n    }\n    return day;\n}\n","function_prediction":"int day_of_year_name_conflict(int year, int month, int day) {\n  int i, leap;\n\n  leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  for (i = 1; i < month; i++)\n    day += daytab[leap][i];\n  return day;\n}","pass":1}
{"function":"unsigned int setbits(unsigned int x, int p, int n, unsigned int y) {\n    unsigned int padding = p + 1 - n;\n    unsigned int target = (~(~0 << n) & y) << padding;\n    unsigned int empty = ((~0 << (p + 1)) | ~(~0 << padding)) & x;\n    return target | empty;\n}\n","function_prediction":"unsigned int setbits(unsigned int x, unsigned int p, unsigned int n,\n                     unsigned int y) {\n  return (x & ~(~(~0U << n) << (p + 1 - n))) |\n         ((y & ~(~0U << n)) << (p + 1 - n));\n}","pass":0}
{"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    mid = (low + high) / 2;\n    while (low <= high && x != v[mid])\n        {\n            mid = (low + high) / 2;\n            printf(\"low=%d high=%d mid=%d\\n\", low, high, mid);\n            if (x < v[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    return (x = v[mid]) ? mid : -1;\n}\n","function_prediction":"int binsearch_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  mid = (low + high) / 2;\n  while (low <= high && x != v[mid]) {\n    mid = (low + high) / 2;\n    printf(\"low=%d high=%d mid=%d\\n\", low, high, mid);\n    if (x < v[mid])\n      high = mid - 1;\n    else\n      low = mid + 1;\n  }\n  if (v[mid] == 0)\n    return -1;\n  else\n    return mid;\n}","pass":1}
{"function":"unsigned int hash(char *s) {\n    unsigned int hashval;\n    for (hashval = 0UL; *s != '\\x00'; s++)\n        hashval = hashval + *s + 31 * hashval;\n    return hashval % 1;\n}\n","function_prediction":"int hash_name_conflict(char *str) {\n  int i = 0;\n  while (str[i] != '\\0')\n    i++;\n  return 0;\n}","pass":1}
{"function":"int uninstall(char *name) {\n    Nlist *np1, *np2;\n    unsigned int hashval = hash(name);\n    for (np1 = hashtable[hashval] , np2 = ((void *)0); np1 != ((void *)0); np2 = np1 , np1 = np1->next) {\n        if (strcmp(name, np1->name) == 0) {\n            if (np2 == ((void *)0))\n                hashtable[hashval] = np1->next;\n            else\n                np2->next = np1->next;\n            free(np1->name);\n            free(np1->defn);\n            free(np1);\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int uninstall_name_conflict(const char *name) {\n  int h = hash(name);\n  struct entry *e = hashtable[h], *prev = NULL;\n\n  while (e) {\n    if (!strcmp(name, e->name)) {\n      if (prev)\n        prev->next = e->next;\n      else\n        hashtable[h] = e->next;\n      free(e->name);\n      free(e->value);\n      free(e);\n      return 1;\n    }\n    prev = e;\n    e = e->next;\n  }\n  return 0;\n}","pass":0}
{"function":"int get_line(char *line, int lim) {\n    int i, c;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        *line++ = c;\n    }\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *s, int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    *s++ = c;\n  if (c == '\\n') {\n    *s++ = c;\n    ++i;\n  }\n  *s = '\\0';\n  return i;\n}","pass":1}
{"function":"int lower(int c) {\n    return (c >= 'A' && c <= 'Z') ? (c + ('a' - 'A')) : c;\n}\n","function_prediction":"void lower_line(char *line) {\n  int i;\n\n  for (i = 0; line[i]; i++)\n    line[i] = lower(line[i]);\n}","pass":0}
{"function":"int get_line(char line[], int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int my_htoi(char line[]) {\n    int i, n, c;\n    for (i = 0; ((*__ctype_b_loc())[(int)((line[i]))] & (unsigned short)_ISspace); i++)\n        ;\n    if (line[i] != '0' || tolower(line[i + 1]) != 'x') {\n        printf(\"\\344\\270\\215\\346\\230\\25716\\350\\277\\233\\345\\210\\266\\346\\240\\274\\345\\274\\217\\n\");\n        return 0;\n    }\n    i++ , i++;\n    printf(\"i=%d c=%c\\n\", i, line[i]);\n    for (n = 0; c = line[i] , ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISxdigit); i++) {\n        if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)) {\n            n = 16 * n + (c - '0');\n        } else {\n            n = 16 * n + (10 + (c - 'a'));\n        }\n    }\n    return n;\n}\n","function_prediction":"int my_htoi_name_conflict(char s[]) {\n  int i, n;\n\n  i = 0;\n  while (__ctype_b_loc().__sb[s[i]] & 0x002000)\n    i++;\n  if (s[i] != '0' || tolower(s[i + 1]) != 'x')\n    printf(\"Not a hexadecimal number\\n\");\n  else\n    i += 2;\n  printf(\"i=%d c=%c\\n\", i, s[i]);\n  n = 0;\n  while (__ctype_b_loc().__sb[s[i]] & 0x001000) {\n    if (__ctype_b_loc().__sb[s[i]] & 0x000800)\n      n = 16 * n + (s[i] - '0');\n    else\n      n = 16 * n + (s[i] - 'a' + 10);\n    i++;\n  }\n  return n;\n}","pass":0}
{"function":"int get_line(char line[], int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int str_index(char source[], char pattern[]) {\n    int source_len = strlen(source);\n    int pattern_len = strlen(pattern);\n    int i, j, k;\n    for (i = source_len - 1; i >= pattern_len - 1; i--) {\n        for (j = i , k = pattern_len - 1; k >= 0 && pattern[k] == source[j]; j-- , k--)\n            ;\n        if (k == -1) {\n            return j;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int str_index_name_conflict(char *s, char *t) {\n  int i, j, k;\n\n  for (i = strlen(s) - 1; i >= strlen(t) - 1; --i) {\n    for (j = i, k = strlen(t) - 1; k >= 0 && s[j] == t[k]; --j, --k)\n      ;\n    if (k < 0)\n      return j;\n  }\n  return -1;\n}","pass":1}
{"function":"int get_line(char line[], int lim) {\n    int i, c;\n    i = 0;\n    while (--lim && (c = getchar()) != (-1) && c != '\\n')\n        {\n            line[i++] = c;\n        }\n    if (c == '\\n') {\n        line[i++] = c;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  i = 0;\n  while (--lim > 0 && (c = getchar()) != EOF && c != '\\n')\n    s[i++] = c;\n  if (c == '\\n')\n    s[i++] = c;\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int bitcount(unsigned int x) {\n    int b;\n    for (b = 0; x != 0; x &= (x - 1)) {\n        b++;\n    }\n    return b;\n}\n","function_prediction":"int bitcount_name_conflict(uint32_t x) {\n  int n;\n  for (n = 0; x; n++)\n    x &= x - 1;\n  return n;\n}","pass":1}
{"function":"int get_line(char line[]) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int getint(int *pn) {\n    int c;\n    int sign;\n    int minus_or_plus;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit) && c != '+' && c != '-') {\n        ungetch(c);\n        return 0;\n    }\n    sign = c == '-' ? -1 : 1;\n    if (c == '+' || c == '-') {\n        c = getch();\n        minus_or_plus = 1;\n    }\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)) {\n        if (minus_or_plus) {\n            ungetch(sign < 0 ? '-' : '+');\n        }\n        ungetch(c);\n        return 0;\n    }\n    for (*pn = 0; ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit); c = getch()) {\n        *pn = (*pn * 10) + (c - '0');\n    }\n    *pn *= sign;\n    if (c != (-1)) {\n        ungetch(c);\n    }\n    return c;\n}\n","function_prediction":"int getint_name_conflict(int *pn) {\n  int c, sign;\n\n  while (isspace(c = getch()))\n    ;\n  if (c != '-' && c != '+' && !isdigit(c)) {\n    ungetch(c);\n    return 0;\n  }\n  sign = (c == '-') ? -1 : 1;\n  if (c == '+' || c == '-') {\n    c = getch();\n    if (!isdigit(c)) {\n      if (sign < 0)\n        ungetch('-');\n      else\n        ungetch('+');\n      ungetch(c);\n      return 0;\n    }\n  }\n  for (*pn = 0; isdigit(c); c = getch())\n    *pn = 10 * *pn + (c - '0');\n  *pn *= sign;\n  if (c != EOF)\n    ungetch(c);\n  return c;\n}","pass":1}
{"function":"int getch(void) {\n    return buffer_i > 0 ? buffer[--buffer_i] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffer_i > 0)\n    return buffer[--buffer_i];\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int any(char line1[], char line2[]) {\n    int i, j;\n    int c1, c2;\n    for (i = 0; (c2 = line2[i]) != '\\x00'; i++) {\n        for (j = 0; (c1 = line1[j]) != '\\x00'; j++) {\n            if (c1 == c2) {\n                return j;\n            }\n        }\n    }\n    return -1;\n}\n","function_prediction":"int any_name_conflict(char s1[], char s2[]) {\n  int i, j;\n\n  for (i = 0; s2[i] != '\\0'; i++)\n    for (j = 0; s1[j] != '\\0'; j++)\n      if (s1[j] == s2[i])\n        return j;\n  return -1;\n}","pass":1}
{"function":"int str_end(char *s, char *t) {\n    int len_s = strlen(s);\n    int len_t = strlen(t);\n    int i = len_t;\n    for (s += len_s - 1 , t += len_t - 1; i > 0; i-- , s-- , t--) {\n        if (*s != *t)\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int str_end_name_conflict(char *str, char *end) {\n  char *p = str + strlen(str) - 1;\n  char *q = end + strlen(end) - 1;\n  int len = strlen(end);\n\n  while (len > 0) {\n    if (*p != *q)\n      return 0;\n    p--;\n    q--;\n    len--;\n  }\n  return 1;\n}","pass":1}
{"function":"int str_len(char str[]) {\n    int i;\n    for (i = 0; str[i] != '\\x00'; i++)\n        ;\n    return i;\n}\n","function_prediction":"int str_len_name_conflict(char *str) {\n  int i;\n  for (i = 0; str[i] != '\\0'; i++)\n    ;\n  return i;\n}","pass":1}
{"function":"int get_line(char line[]) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int get_line(char line[]) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"unsigned int rightrot(unsigned int x, int n) {\n    unsigned int temp_left, temp_right;\n    int i;\n    for (i = 0; i < n; i++ , n--) {\n        temp_right = getbits(x, i, 1);\n        temp_left = getbits(x, n - 1, 1);\n        x = setbits(x, i, 1, temp_left);\n        x = setbits(x, n - 1, 1, temp_right);\n    }\n    return x;\n}\n","function_prediction":"int rightrot_name_conflict(int x, int n) {\n  int i;\n  for (i = 0; i < n; ++i) {\n    int lastbit = getbits(x, i, 1);\n    int firstbit = getbits(x, n - 1, 1);\n    x = setbits(x, i, 1, firstbit);\n    x = setbits(x, n - 1, 1, lastbit);\n    --n;\n  }\n  return x;\n}","pass":1}
{"function":"unsigned int getbits(unsigned int x, int p, int n) {\n    return (x >> (p + 1 - n)) & ~(~0 << n);\n}\n","function_prediction":"unsigned int getbits_name_conflict(unsigned int x, unsigned int p,\n                                   unsigned int n) {\n  return (x >> (p + 1 - n)) & ~(~0 << n);\n}","pass":0}
{"function":"unsigned int setbits(unsigned int x, int p, int n, unsigned int y) {\n    unsigned int padding = p + 1 - n;\n    unsigned int target = (~(~0 << n) & y) << padding;\n    unsigned int empty = ((~0 << (p + 1)) | ~(~0 << padding)) & x;\n    return target | empty;\n}\n","function_prediction":"unsigned int setbits(unsigned int x, unsigned int p, unsigned int n,\n                     unsigned int y) {\n  return (x & ~(~(~0U << n) << (p + 1 - n))) |\n         ((y & ~(~0U << n)) << (p + 1 - n));\n}","pass":0}
{"function":"int get_line(char line[]) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int is_in_blacklist(char *s) {\n    char *t;\n    char *tmp;\n    for (size_t i = 0; i < sizeof (blacklist) / sizeof(char *); i++) {\n        t = blacklist[i];\n        tmp = s;\n        while (tolower(*tmp++) == *t++)\n            {\n                if (*tmp == '\\x00')\n                    return 1;\n            }\n    }\n    return 0;\n}\n","function_prediction":"int is_in_blacklist_name_conflict(char *str) {\n  size_t i;\n  for (i = 0; i < 29; i++) {\n    char *s = str;\n    char *b = blacklist[i];\n    while (tolower(*s) == *b) {\n      s++;\n      b++;\n      if (*s == '\\0')\n        return 1;\n    }\n  }\n  return 0;\n}","pass":1}
{"function":"int getword(char *word, int lim) {\n    int getch(void);\n    void ungetch(int c);\n    int c;\n    while (((*__ctype_b_loc())[(int)(((c = getch())))] & (unsigned short)_ISblank))\n        ;\n    if (c != (-1)) {\n        *word++ = c;\n    }\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --lim; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (isalpha(c) || c == '_' || c == '#')\n    for (; --lim > 0; w++)\n      if (!isalnum(*w = getch()) && *w != '_') {\n        ungetch(*w);\n        break;\n      }\n  *w = '\\0';\n  return c;\n}","pass":1}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > buffer)\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":0}
{"function":"int abs(int x) {\n    return x < 0 ? -x : x;\n}\n","function_prediction":"int abs_name_conflict(int x) { return x < 0 ? -x : x; }","pass":1}
{"function":"int getword(char *word, int lim) {\n    int getch(void);\n    void ungetch(int);\n    int c;\n    static int prev;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISblank))\n        ;\n    if (c != (-1)) {\n        *word++ = c;\n    }\n    if (!(((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha) || (c == '#') || (c == '\"') || (c == '_') || (c == '/'))) {\n        *word = '\\x00';\n        prev = c;\n        return c;\n    }\n    switch (c) {\n      case '#':\n        *--word = '\\x00';\n        return getword(word, lim);\n        break;\n      case '\"':\n        if (prev == '\\'') {\n            *word = c;\n            return c;\n        } else {\n            while (getch() != '\"')\n                ;\n            *--word = '\\x00';\n            return getword(word, lim);\n        }\n        break;\n      case '/':\n        c = getch();\n        if (c == '/') {\n            while (getch() != '\\n')\n                ;\n            *--word = '\\x00';\n            return getword(word, lim);\n        } else if (c == '*') {\n            while (getch() != '*')\n                ;\n            c = getch();\n            if (c == '/') {\n            } else {\n                ungetch('/');\n                ungetch('*');\n                ungetch(c);\n            }\n            *--word = '\\x00';\n            return getword(word, lim);\n        } else {\n            *word = '\\x00';\n            return c;\n        }\n        break;\n      default:\n        for (; --lim; word++) {\n            if (!(((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum) || *word == '_')) {\n                ungetch(*word);\n                break;\n            }\n        }\n        break;\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (isalpha(c) || c == '_' || c == '#' || c == '\"') {\n    for (; --lim > 0; w++)\n      if (!isalnum(*w = getch()) && *w != '_') {\n        ungetch(*w);\n        break;\n      }\n  } else if (c == '/') {\n    if ((c = getch()) == '/') {\n      while ((c = getch()) != '\\n')\n        ;\n      *--w = '\\0';\n      return getword_name_conflict(w, lim);\n    } else if (c == '*') {\n      while ((c = getch()) != '*')\n        ;\n      if ((c = getch()) != '/') {\n        ungetch('/');\n        ungetch('*');\n        ungetch(c);\n      }\n      *--w = '\\0';\n      return getword_name_conflict(w, lim);\n    } else {\n      *w = '\\0';\n      return c;\n    }\n  } else if (c == '\"' && prev_0 == '\\'') {\n    *w++ = c;\n    return c;\n  } else if (c == '\"') {\n    while ((c = getch()) != '\"')\n      ;\n    *--w = '\\0';\n    return getword_name_conflict(w, lim);\n  } else if (c == '#') {\n    *--w = '\\0';\n    return getword_name_conflict(w, lim);\n  } else {\n    *w = '\\0';\n    return c;\n  }\n\n  *w = '\\0';\n  return word[0];\n}","pass":0}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > \"\")\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int atoi(char *s) {\n    int sign;\n    int n = 0;\n    while (((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        s++;\n    sign = *s == '-' ? -1 : 1;\n    if (*s == '+' || *s == '-')\n        s++;\n    while (((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISdigit))\n        {\n            n = n * 10 + (*s - '0');\n            s++;\n        }\n    return n * sign;\n}\n","function_prediction":"int atoi_name_conflict(const char *str) {\n  int res = 0;\n  int sign = 1;\n\n  while (__ctype_b_loc()->isspace(*str))\n    str++;\n\n  if (*str == '-')\n    sign = -1;\n\n  if (*str == '+' || *str == '-')\n    str++;\n\n  while (__ctype_b_loc()->isdigit(*str)) {\n    res = res * 10 + *str - '0';\n    str++;\n  }\n\n  return res * sign;\n}","pass":0}
{"function":"int getlines2(char lines[][200], int maxlines) {\n    printf(\"\\tgetlines: V2\\n\\n\");\n    int len;\n    int nlines = 0;\n    while ((len = get_line(lines[nlines], 200)) > 0)\n        {\n            if (nlines >= maxlines) {\n                return -1;\n            } else {\n                lines[nlines++][len - 1] = '\\x00';\n            }\n        }\n    return nlines;\n}\n","function_prediction":"int getlines2_name_conflict(char *lineptr[], int maxlines) {\n  int len, nlines;\n\n  puts(\"\\tgetlines: V2\\n\");\n\n  nlines = 0;\n  while ((len = get_line(lineptr[nlines], 200)) > 0) {\n    if (nlines >= maxlines)\n      return -1;\n    else {\n      lineptr[nlines++][len - 1] = '\\0';\n    }\n  }\n  return nlines;\n}","pass":0}
{"function":"int getlines(char *lineptr[], int maxlines) {\n    int len;\n    char line[200];\n    int nlines = 0;\n    char *p;\n    while ((len = get_line(line, 200)) > 0)\n        {\n            if (nlines >= maxlines || (p = (char *)malloc(len)) == ((void *)0)) {\n                return -1;\n            } else {\n                line[len - 1] = '\\x00';\n                strcpy(p, line);\n                lineptr[nlines++] = p;\n            }\n        }\n    return nlines;\n}\n","function_prediction":"int getlines_name_conflict(char *lineptr[], int maxlines) {\n  int len, nlines;\n  char *p, line[200];\n\n  nlines = 0;\n  puts(\"\\tgetlines_name_conflict: V2\\n\");\n  while ((len = get_line(line, 200)) > 0) {\n    if (nlines >= maxlines || (p = (char *)malloc(len)) == NULL)\n      return -1;\n    else {\n      line[len - 1] = '\\0';\n      strcpy(p, line);\n      lineptr[nlines++] = p;\n    }\n  }\n  return nlines;\n}","pass":1}
{"function":"int get_line(char *line, int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        *line++ = c;\n    }\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i;\n  int c;\n\n  for (i = 0; i < max_len - 1; i++) {\n    c = getchar();\n    if (c == -1 || c == '\\n')\n      break;\n    line[i] = c;\n  }\n\n  if (c == '\\n') {\n    line[i] = c;\n    i++;\n    line++;\n  }\n\n  line[i] = '\\0';\n\n  return i;\n}","pass":1}
{"function":"char *alloc(int n) {\n    if (allocbuff + (30000 * 200) - allocp >= n) {\n        allocp += n;\n        return allocp - n;\n    } else {\n        return ((void *)0);\n    }\n}\n","function_prediction":"char *alloc_name_conflict(int n) {\n  if (alloc_name_conflictp + n > (char *)&_end)\n    return 0;\n  alloc_name_conflictp += n;\n  return alloc_name_conflictp - n;\n}","pass":0}
{"function":"Line *alloc_line(void) {\n    return (Line *)malloc(sizeof(Line));\n}\n","function_prediction":"line_t *alloc_line_name_conflict() { return malloc(sizeof(line_t)); }","pass":0}
{"function":"Line *add_line(Line *line, int line_num) {\n    int cond;\n    if (line == ((void *)0)) {\n        line = (Line *)malloc(sizeof(Line));\n        line->num = line_num;\n        line->count = 1;\n        line->left = line->right = ((void *)0);\n    } else if ((cond = line_num - line->num > 0)) {\n        line->right = add_line(line->right, line_num);\n    } else if (cond < 0) {\n        line->left = add_line(line->left, line_num);\n    } else {\n        line->count++;\n    }\n    return line;\n}\n","function_prediction":"struct line *add_line_name_conflict(struct line *l, int n) {\n  if (l == NULL) {\n    l = malloc(sizeof(struct line));\n    l->n = n;\n    l->count = 1;\n    l->next = l->prev = NULL;\n  } else {\n    if (l->n == n)\n      l->count++;\n    else\n      l->next = add_line_name_conflict(l->next, n);\n  }\n  return l;\n}","pass":0}
{"function":"int getword(char *word, int lim) {\n    int getch(void);\n    void ungetch(int c);\n    static int line = 0;\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        {\n            if (((c) == '\\n')) {\n                line++;\n                if (line > total_lines)\n                    total_lines = line;\n            }\n        }\n    if (c != (-1)) {\n        *word++ = c;\n    }\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        if (c == (-1))\n            return (-1);\n        else\n            return line;\n    }\n    for (; --lim; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return line;\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    if (c == '\\n')\n      if (++line_0 > total_lines)\n        total_lines = line_0;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (!isalpha(c) && c != '_' && c != '#') {\n    *w = '\\0';\n    return (c == EOF) ? EOF : line_0;\n  }\n\n  for (; --lim > 0; w++)\n    if (!isalnum(*w = getch()) && *w != '_') {\n      ungetch(*w);\n      break;\n    }\n\n  *w = '\\0';\n  return line_0;\n}","pass":0}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > buffer)\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":0}
{"function":"char *get_line(void) {\n    int chars = 0;\n    char *line = (char *)malloc(sizeof(char) * chars);\n    int c, i;\n    for (i = 0; (c = getchar()) != (-1) && c != '\\n'; i++) {\n        chars++;\n        line = (char *)realloc(line, chars);\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        chars++;\n        line = (char *)realloc(line, chars);\n        line[i] = '\\n';\n        i++;\n    }\n    chars++;\n    line = (char *)realloc(line, chars);\n    line[i] = '\\x00';\n    return line;\n}\n","function_prediction":"char *get_line_name_conflict() {\n  int c, i;\n  char *line;\n\n  line = malloc(0);\n  i = 0;\n  while ((c = getchar()) != -1 && c != '\\n') {\n    line = realloc(line, ++i);\n    line[i - 1] = c;\n    i++;\n  }\n  if (c == '\\n') {\n    line = realloc(line, ++i);\n    line[i - 1] = c;\n    i++;\n  }\n  line = realloc(line, i + 1);\n  line[i] = '\\0';\n  return line;\n}","pass":0}
{"function":"int str_len(char *s) {\n    int i;\n    int c;\n    for (i = 0; (c = *(s++)) != '\\x00'; i++)\n        ;\n    return i;\n}\n","function_prediction":"int str_len_name_conflict(char *str) {\n  int len = 0;\n  while (*str++)\n    len++;\n  return len;\n}","pass":1}
{"function":"int get_line(char *line) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int get_line(char line[]) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int day_of_year(int year, int month, int day) {\n    int i;\n    int leap = (((year) % 4 == 0 && (year) % 100 != 0) || (year) % 400 == 0);\n    if (month <= 0 || month > 12) {\n        printf(\"error\\357\\274\\232\\346\\234\\210\\344\\273\\275\\350\\266\\205\\350\\277\\20712\\346\\210\\226<=0\\357\\274\\232%d\\n\", month);\n        exit(1);\n    }\n    if (day <= 0 || daytab[leap][month] < day) {\n        printf(\"error\\357\\274\\232%d\\346\\234\\210\\345\\244\\251\\346\\225\\260\\344\\270\\215\\350\\203\\275\\350\\266\\205\\350\\277\\207%d\\345\\244\\251\\346\\210\\226<=0\\357\\274\\232%d\\n\", month, daytab[leap][month], day);\n        exit(1);\n    }\n    for (i = 1; i < month; i++) {\n        day += daytab[leap][i];\n    }\n    return day;\n}\n","function_prediction":"int day_of_year_name_conflict(int year, int month, int day) {\n  int i, leap;\n\n  leap = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n  if (month < 1 || month > 12) {\n    printf(\"day_of_year_name_conflict: invalid month %d\\n\", month);\n    exit(1);\n  }\n  if (day < 1 || day > daytab[leap][month]) {\n    printf(\"day_of_year_name_conflict: invalid day %d for month %d\\n\", day,\n           month);\n    exit(1);\n  }\n  for (i = 1; i < month; i++)\n    day += daytab[leap][i];\n  return day;\n}","pass":1}
{"function":"int str_ncmp(char *s, char *t, int n) {\n    int i;\n    for (i = 1; *s == *t; i++ , s++ , t++) {\n        if (*s == '\\x00' || i == n)\n            return 0;\n    }\n    return *s - *t;\n}\n","function_prediction":"int str_ncmp_name_conflict(const char *s1, const char *s2, int n) {\n  int i = 1;\n\n  while (*s1 == *s2) {\n    if (*s1 == '\\0' || i == n)\n      return 0;\n    s1++;\n    s2++;\n    i++;\n  }\n  return *s1 - *s2;\n}","pass":1}
{"function":"int getch(void) {\n    return buffer_i > 0 ? buffer[--buffer_i] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffer_i > 0)\n    return buffer[--buffer_i];\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int day_of_year(int year, int month, int day) {\n    int leap = (((year) % 4 == 0 && (year) % 100 != 0) || (year) % 400 == 0);\n    int i;\n    char *p = *(daytab + leap);\n    if (year <= 0 || month <= 0 || month > 12 || day <= 0 || day > p[month])\n        return -1;\n    for (i = 1; i < month; i++)\n        day += p[i];\n    return day;\n}\n","function_prediction":"int day_of_year_name_conflict(int year, int month, int day) {\n  int i, leap;\n\n  leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  if (year < 1 || month < 1 || month > 12 || day < 1 ||\n      day > daytab[leap][month])\n    return -1;\n  for (i = 1; i < month; i++)\n    day += daytab[leap][i];\n  return day;\n}","pass":1}
{"function":"int get_line(char line[]) {\n    int i, c;\n    for (i = 0; i < 1000 - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    if (c == '\\n') {\n        line[i] = '\\n';\n        i++;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[]) {\n  int c, i;\n\n  for (i = 0; i < 1000 - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int gettoken(void) {\n    int c;\n    char *p = token;\n    while ((c = getch()) == ' ' || c == '\\t')\n        ;\n    if (c == '(') {\n        if ((c = getch()) == ')') {\n            strcpy(token, \"()\");\n            tokentype = PARENS;\n        } else {\n            ungetch(c);\n            tokentype = '(';\n        }\n    } else if (c == '[') {\n        for (*p++ = c; (*p++ = getch()) != ']';)\n            ;\n        *p = '\\x00';\n        tokentype = BRACKETS;\n    } else if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        for (*p++ = c; ((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISalnum);)\n            *p++ = c;\n        ungetch(c);\n        *p = '\\x00';\n        tokentype = NAME;\n    } else {\n        tokentype = c;\n    }\n    return tokentype;\n}\n","function_prediction":"int gettoken_name_conflict(void) {\n  int c, getch(void);\n  void ungetch(int);\n  char *p = token;\n\n  while ((c = getch()) == ' ' || c == '\\t')\n    ;\n  if (c == '(') {\n    if ((c = getch()) == ')') {\n      _token = (c << 8) | '(';\n      *p = '\\0';\n      return tokentype = 1;\n    } else {\n      ungetch(c);\n      return tokentype = '(';\n    }\n  } else if (c == '[') {\n    for (*p++ = c; (*p++ = getch()) != ']';)\n      ;\n    *p = '\\0';\n    return tokentype = 2;\n  } else if (isalpha(c) || c == '_' || c == '#') {\n    for (*p++ = c; isalnum(c = getch()) || c == '_' || c == '#';)\n      *p++ = c;\n    *p = '\\0';\n    ungetch(c);\n    return tokentype = 0;\n  } else\n    return tokentype = c;\n}","pass":0}
{"function":"int getch(void) {\n    int c = buffp > buff ? *--buffp : *linep++;\n    return c;\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > &buff[0])\n    return *--buffp;\n  else\n    return *linep++;\n}","pass":1}
{"function":"int get_line(char *line, int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        *line++ = c;\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i;\n  int c;\n\n  for (i = 0; i < max_len - 1; i++) {\n    c = getchar();\n    if (c == -1 || c == '\\n')\n      break;\n    line[i] = c;\n  }\n\n  if (c == '\\n') {\n    line[i] = c;\n    i++;\n    line++;\n  }\n\n  line[i] = '\\0';\n\n  return i;\n}","pass":1}
{"function":"int strindex(char s[], char t[]) {\n    int i, j, k;\n    for (i = 0; s[i] != '\\x00'; i++) {\n        for (j = i , k = 0; t[k] != '\\x00' && s[j] == t[k]; j++ , k++)\n            ;\n        if (k > 0 && t[k] == '\\x00')\n            return i;\n    }\n    return -1;\n}\n","function_prediction":"int strindex_name_conflict(char s[], char t[]) {\n  int i, j, k;\n\n  for (i = 0; s[i] != '\\0'; i++) {\n    for (j = i, k = 0; t[k] != '\\0' && s[j] == t[k]; j++, k++)\n      ;\n    if (k > 0 && t[k] == '\\0')\n      return i;\n  }\n  return -1;\n}","pass":1}
{"function":"int str_index(char *s, char *t) {\n    int i;\n    char *tmp_t;\n    char *tmp_s;\n    for (i = 0 , tmp_t = t , tmp_s = s; *s != '\\x00'; i++ , t = tmp_t , s = ++tmp_s) {\n        while (*t != '\\x00' && *t == *s)\n            {\n                t++ , s++;\n            }\n        if (t > tmp_t && *t == '\\x00') {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int str_index_name_conflict(char *s, char *t) {\n  char *p, *q;\n  int i;\n\n  for (i = 0; *s; s++, i++) {\n    for (p = s, q = t; *q && *p == *q; p++, q++)\n      ;\n    if (q > t && !*q)\n      return i;\n  }\n  return -1;\n}","pass":1}
{"function":"int gettoken(void) {\n    int c;\n    char *p = token;\n    while ((c = getch()) == ' ' || c == '\\t')\n        ;\n    ;\n    if (c == '(') {\n        while ((c = getch()) == ' ' || c == '\\t')\n            ;\n        ;\n        if (c == ')') {\n            strcpy(token, \"()\");\n            tokentype = PARENS;\n        } else {\n            ungetch(c);\n            tokentype = '(';\n        }\n    } else if (c == '[') {\n        for (*p++ = c; (*p++ = getch()) != ']';)\n            ;\n        *p = '\\x00';\n        tokentype = BRACKETS;\n    } else if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        for (*p++ = c; ((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISalnum);)\n            *p++ = c;\n        ungetch(c);\n        *p = '\\x00';\n        tokentype = NAME;\n    } else {\n        tokentype = c;\n    }\n    return tokentype;\n}\n","function_prediction":"int gettoken_name_conflict(void) {\n  int c, getch(void);\n  void ungetch(int);\n  char *p = token;\n\n  while ((c = getch()) == ' ' || c == '\\t')\n    ;\n\n  if (c == '(') {\n    while ((c = getch()) == ' ' || c == '\\t')\n      ;\n    if (c == ')') {\n      _token = (c << 8) | ')';\n      *p = '\\0';\n      tokentype = 1;\n    } else\n      ungetch(c);\n    tokentype = '(';\n  } else if (c == '[') {\n    for (*p++ = c; (*p++ = getch()) != ']';)\n      ;\n    *p = '\\0';\n    tokentype = 2;\n  } else if (isalpha(c)) {\n    for (*p++ = c; isalnum(c = getch());)\n      *p++ = c;\n    *p = '\\0';\n    tokentype = 0;\n  } else\n    tokentype = c;\n  return tokentype;\n}","pass":0}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : *linep++;\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > &buff[0])\n    return *--buffp;\n  else\n    return *linep++;\n}","pass":1}
{"function":"int get_line(char *line, int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        *line++ = c;\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i;\n  int c;\n\n  for (i = 0; i < max_len - 1; i++) {\n    c = getchar();\n    if (c == -1 || c == '\\n')\n      break;\n    line[i] = c;\n  }\n\n  if (c == '\\n') {\n    line[i] = c;\n    i++;\n    line++;\n  }\n\n  line[i] = '\\0';\n\n  return i;\n}","pass":1}
{"function":"int readlines(char *lineptr[], int maxlines) {\n    int nlines, len;\n    char line[1000];\n    char *p;\n    nlines = 0;\n    while ((len = get_line(line, 1000)) > 0)\n        {\n            if (nlines >= maxlines || (p = alloc(len)) == ((void *)0)) {\n                return -1;\n            } else {\n                line[len - 1] = '\\x00';\n                strcpy(p, line);\n                lineptr[nlines++] = p;\n            }\n        }\n    return nlines;\n}\n","function_prediction":"int readlines_name_conflict(char *lineptr[], int maxlines) {\n  int len, nlines;\n  char *p, line[1000];\n\n  nlines = 0;\n  while ((len = get_line(line, 1000)) > 0) {\n    if (nlines >= maxlines || (p = alloc(len)) == NULL)\n      return -1;\n    else {\n      line[len - 1] = '\\0';\n      strcpy(p, line);\n      lineptr[nlines++] = p;\n    }\n  }\n  return nlines;\n}","pass":1}
{"function":"int get_line(char *line, int lim) {\n    int i, c;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        *line++ = c;\n    }\n    if (c == '\\n') {\n        *line++ = c;\n        i++;\n    }\n    *line = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *s, int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    *s++ = c;\n  if (c == '\\n') {\n    *s++ = c;\n    ++i;\n  }\n  *s = '\\0';\n  return i;\n}","pass":1}
{"function":"char *alloc(int n) {\n    if (allocbuf + 50000 * 1000 - allocp >= n) {\n        allocp += n;\n        return allocp - n;\n    } else {\n        return ((void *)0);\n    }\n}\n","function_prediction":"char *alloc_name_conflict(int n) {\n  if (alloc_name_conflictp + n > (char *)&_end)\n    return 0;\n  alloc_name_conflictp += n;\n  return alloc_name_conflictp - n;\n}","pass":0}
{"function":"int getword(char *word, int lim) {\n    int c;\n    static int prev;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISblank))\n        ;\n    if (c != (-1)) {\n        *word++ = c;\n    }\n    if (!(((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha) || c == '#' || c == '\"' || c == '/' || c == '_')) {\n        *word = '\\x00';\n        prev = c;\n        return c;\n    }\n    switch (c) {\n      case '#':\n        *--word = '\\x00';\n        return getword(word, lim);\n        break;\n      case '\"':\n        if (prev == '\\'') {\n            *--word = '\\x00';\n            return getword(word, lim);\n        } else {\n            while (getch() != '\"')\n                ;\n            *--word = '\\x00';\n            return getword(word, lim);\n        }\n        break;\n      case '/':\n        c = getch();\n        if (c == '/') {\n            while (getch() != '\\n')\n                ;\n            *--word = '\\x00';\n            return getword(word, lim);\n        } else if (c == '*') {\n            while (getch() != '*')\n                ;\n            c = getch();\n            if (c != '/') {\n                ungetch('/');\n                ungetch('*');\n                ungetch(c);\n            }\n            *--word = '\\x00';\n            return getword(word, lim);\n        } else {\n            ungetch(c);\n            *word = '\\x00';\n            return word[0];\n        }\n        break;\n      default:\n        for (; --lim > 0; word++) {\n            if (!(((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum) || *word == '_')) {\n                ungetch(*word);\n                break;\n            }\n        }\n        break;\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (isalpha(c) || c == '_' || c == '#' || c == '\"' || c == '/') {\n    for (; --lim > 0; w++) {\n      if (!isalnum(*w = getch()) && *w != '_') {\n        ungetch(*w);\n        break;\n      }\n    }\n  } else if (c == '/') {\n    if ((c = getch()) == '/') {\n      while ((c = getch()) != '\\n')\n        ;\n      *--w = '\\0';\n      return getword_name_conflict(w, lim);\n    } else if (c == '*') {\n      while ((c = getch()) != '*')\n        ;\n      if ((c = getch()) != '/') {\n        ungetch('/');\n        ungetch('*');\n        ungetch(c);\n      }\n      *--w = '\\0';\n      return getword_name_conflict(w, lim);\n    } else {\n      ungetch(c);\n    }\n  } else if (c == '\"' && prev_0 == '\\'') {\n    *--w = '\\0';\n    return getword_name_conflict(w, lim);\n  } else if (c == '\"') {\n    while ((c = getch()) != '\"')\n      ;\n    *--w = '\\0';\n    return getword_name_conflict(w, lim);\n  } else if (c == '#') {\n    *--w = '\\0';\n    return getword_name_conflict(w, lim);\n  }\n\n  *w = '\\0';\n  return c;\n}","pass":0}
{"function":"int getch(void) {\n    return buffp > buff ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > buffer)\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":0}
{"function":"int getint(int *pn) {\n    int c;\n    int sign;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit) && c != '+' && c != '-') {\n        ungetch(c);\n        return 0;\n    }\n    sign = c == '-' ? -1 : 1;\n    if (c == '+' || c == '-')\n        c = getch();\n    for (*pn = 0; ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit); c = getch()) {\n        *pn = (*pn * 10) + (c - '0');\n    }\n    *pn *= sign;\n    if (c != (-1)) {\n        ungetch(c);\n    }\n    return c;\n}\n","function_prediction":"int getint_name_conflict(int *pn) {\n  int c, sign;\n\n  while (isspace(c = getch()))\n    ;\n  if (!isdigit(c) && c != EOF && c != '+' && c != '-') {\n    ungetch(c);\n    return 0;\n  }\n  sign = (c == '-') ? -1 : 1;\n  if (c == '+' || c == '-')\n    c = getch();\n  for (*pn = 0; isdigit(c); c = getch())\n    *pn = 10 * *pn + (c - '0');\n  *pn *= sign;\n  if (c != EOF)\n    ungetch(c);\n  return c;\n}","pass":1}
{"function":"int getch(void) {\n    return buffer_i > 0 ? buffer[--buffer_i] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffer_i > 0)\n    return buffer[--buffer_i];\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int gettoken(void) {\n    int c;\n    char *p = token;\n    while ((c = getch()) == ' ' || c == '\\t')\n        ;\n    if (c == '(') {\n        if ((c = getch()) == ')') {\n            strcpy(token, \"()\");\n            tokentype = PARENS;\n        } else {\n            ungetch(c);\n            tokentype = '(';\n        }\n    } else if (c == '[') {\n        for (*p++ = c; (*p++ = getch()) != ']';)\n            ;\n        *p = '\\x00';\n        tokentype = BRACKETS;\n    } else if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        for (*p++ = c; ((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISalnum);)\n            *p++ = c;\n        *p = '\\x00';\n        ungetch(c);\n        tokentype = NAME;\n    } else\n        tokentype = c;\n    return tokentype;\n}\n","function_prediction":"int gettoken_name_conflict(void) {\n  int c, getch(void);\n  void ungetch(int);\n  char *p = token;\n\n  while ((c = getch()) == ' ' || c == '\\t')\n    ;\n\n  if (c == '(') {\n    if ((c = getch()) == ')') {\n      _token = (c << 8) | c;\n      *p = '\\0';\n      return tokentype = 1;\n    } else {\n      ungetch(c);\n      return tokentype = '(';\n    }\n  } else if (c == '[') {\n    for (*p++ = c; (*p++ = getch()) != ']';)\n      ;\n    *p = '\\0';\n    return tokentype = 2;\n  } else if (isalpha(c)) {\n    for (*p++ = c; isalnum(c = getch());)\n      *p++ = c;\n    *p = '\\0';\n    ungetch(c);\n    return tokentype = 0;\n  } else\n    return tokentype = c;\n}","pass":0}
{"function":"int getch(void) {\n    return buffp > buffer ? *--buffp : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (buffp > buffer)\n    return *--buffp;\n  else\n    return getch_name_conflictar();\n}","pass":1}
{"function":"int atoi(char line[]) {\n    int i, n, c;\n    int sign;\n    for (i = 0; ((*__ctype_b_loc())[(int)((line[i]))] & (unsigned short)_ISspace); i++)\n        ;\n    sign = line[i] == '-' ? -1 : 1;\n    if (line[i] == '+' || line[i] == '-') {\n        i++;\n    }\n    for (n = 0; c = line[i] , ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit); i++) {\n        n = 10 * n + (c - '0');\n    }\n    return n * sign;\n}\n","function_prediction":"int atoi_name_conflict(const char *str) {\n  int i = 0;\n  int sign = 1;\n  int num = 0;\n\n  while (__ctype_b_loc()[(unsigned char)str[i]] & 0x00002000)\n    i++;\n\n  if (str[i] == '-')\n    sign = -1;\n\n  if (str[i] == '+' || str[i] == '-')\n    i++;\n\n  while (__ctype_b_loc()[(unsigned char)str[i]] & 0x00000800) {\n    num = num * 10 + str[i] - '0';\n    i++;\n  }\n\n  return num * sign;\n}","pass":0}
{"function":"int get_line(char line[], int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int get_line(char *s, int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        *s++ = c;\n    if (c == '\\n') {\n        *s++ = c;\n        i++;\n    }\n    *s = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i;\n  int c;\n\n  for (i = 0; i < max_len - 1; i++) {\n    c = getchar();\n    if (c == -1 || c == '\\n')\n      break;\n    line[i] = c;\n  }\n\n  if (c == '\\n') {\n    line[i] = c;\n    i++;\n    line++;\n  }\n\n  line[i] = '\\0';\n\n  return i;\n}","pass":1}
{"function":"struct point makepoint(int x, int y) {\n    struct point tmp;\n    tmp.x = x;\n    tmp.y = y;\n    return tmp;\n}\n","function_prediction":"struct point makepoint_name_conflict(int x, int y) {\n  struct point temp;\n\n  temp.x = x;\n  temp.y = y;\n  return temp;\n}","pass":0}
{"function":"struct point addpoint(struct point p1, struct point p2) {\n    p1.x += p2.x;\n    p1.y += p2.y;\n    return p1;\n}\n","function_prediction":"struct point addpoint_name_conflict(struct point p1, struct point p2) {\n  struct point p;\n  p.x = p1.x + p2.x;\n  p.y = p1.y + p2.y;\n  return p;\n}","pass":0}
{"function":"int ptinrect(struct point p, struct rect r) {\n    return p.x >= r.pt1.x && p.x < r.pt2.x && p.y >= r.pt1.y && p.y < r.pt2.y;\n}\n","function_prediction":"int ptinrect_name_conflict(point p, rect r) {\n  return p.x >= r.origin.x && p.x < r.opposite.x && p.y >= r.origin.y &&\n         p.y < r.opposite.y;\n}","pass":0}
{"function":"struct rect canonrect(struct rect r) {\n    struct rect tmp;\n    tmp.pt1.x = ((r.pt1.x) < (r.pt2.x) ? (r.pt1.x) : (r.pt2.x));\n    tmp.pt1.y = ((r.pt1.y) < (r.pt2.y) ? (r.pt1.y) : (r.pt2.y));\n    tmp.pt2.x = ((r.pt1.x) > (r.pt2.x) ? (r.pt1.x) : (r.pt2.x));\n    tmp.pt2.y = ((r.pt1.y) > (r.pt2.y) ? (r.pt1.y) : (r.pt2.y));\n    return tmp;\n}\n","function_prediction":"rect canonrect_name_conflict(rect r) {\n  if (r.p.x > r.q.x)\n    r.p.x = r.q.x;\n  if (r.p.y > r.q.y)\n    r.p.y = r.q.y;\n  if (r.q.x < r.p.x)\n    r.q.x = r.p.x;\n  if (r.q.y < r.p.y)\n    r.q.y = r.p.y;\n  return r;\n}","pass":0}
{"function":"int str_cmp1(char *s, char *t) {\n    int i;\n    for (i = 0; s[i] == t[i]; i++) {\n        if (s[i] == '\\x00')\n            return 0;\n    }\n    return s[i] - t[i];\n}\n","function_prediction":"int str_cmp1_name_conflict(char *s1, char *s2) {\n  int i = 0;\n  while (s1[i] == s2[i]) {\n    if (s1[i] == '\\0')\n      return 0;\n    i++;\n  }\n  return s1[i] - s2[i];\n}","pass":1}
{"function":"int str_cmp2(char *s, char *t) {\n    for (; *s == *t; s++ , t++) {\n        if (*s == '\\x00')\n            return 0;\n    }\n    return *s - *t;\n}\n","function_prediction":"int str_cmp2_name_conflict(const char *s1, const char *s2) {\n  while (*s1 == *s2) {\n    if (*s1 == '\\0')\n      return 0;\n    s1++;\n    s2++;\n  }\n  return *s1 - *s2;\n}","pass":1}
{"function":"int atoi(char line[]) {\n    int i, n, c;\n    for (i = 0 , n = 0; c = line[i] , c >= '0' && c <= '9'; i++) {\n        n = 10 * n + (c - '0');\n    }\n    return n;\n}\n","function_prediction":"int atoi_name_conflict(char *str) {\n  int i = 0;\n  int n = 0;\n  while (str[i] >= '0' && str[i] <= '9') {\n    n = n * 10 + str[i] - '0';\n    i++;\n  }\n  return n;\n}","pass":1}
{"function":"int get_line(char line[], int lim) {\n    int c, i;\n    for (i = 0; i < lim - 1 && (c = getchar()) != (-1) && c != '\\n'; i++) {\n        line[i] = c;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"int strindex(char source[], char searchfor[]) {\n    int i, j, k;\n    for (i = 0; source[i] != '\\x00'; i++) {\n        for (j = i , k = 0; searchfor[k] != '\\x00' && source[j] == searchfor[k]; k++ , j++)\n            ;\n        if (k > 0 && searchfor[k] == '\\x00') {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int strindex_name_conflict(char s[], char t[]) {\n  int i, j, k;\n\n  for (i = 0; s[i] != '\\0'; i++) {\n    for (j = i, k = 0; t[k] != '\\0' && s[j] == t[k]; j++, k++)\n      ;\n    if (k > 0 && t[k] == '\\0')\n      return i;\n  }\n  return -1;\n}","pass":1}
{"function":"int get_line(char line[], int lim) {\n    int i, c;\n    i = 0;\n    while (--lim && (c = getchar()) != (-1) && c != '\\n')\n        {\n            line[i++] = c;\n        }\n    if (c == '\\n') {\n        line[i++] = c;\n    }\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  i = 0;\n  while (--lim > 0 && (c = getchar()) != EOF && c != '\\n')\n    s[i++] = c;\n  if (c == '\\n')\n    s[i++] = c;\n  s[i] = '\\0';\n  return i;\n}","pass":1}
{"function":"long long pop() {\n    long long r = arr[--size];\n    if (size < (1 * arrSize) / 3) {\n        arr = (long long *)realloc(arr, (arrSize * sizeof(long long)) >> 1);\n        arrSize = arrSize >> 1;\n    }\n    return r;\n}\n","function_prediction":"int pop_name_conflict() {\n  int ret = arr[--size];\n  if (size < arrSize / 3) {\n    arr = realloc(arr, arrSize / 2);\n    arrSize /= 2;\n  }\n  return ret;\n}","pass":1}
{"function":"static inline int hexVal(char c) {\n    if ('0' <= c && c <= '9')\n        return c - '0';\n    return 10 + c - 'A';\n}\n","function_prediction":"int hexVal_name_conflict(char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else {\n    return c - 'A' + 10;\n  }\n}","pass":1}
{"function":"int read_int() {\n    int o = 0;\n    char c;\n    while (1)\n        {\n            c = getchar_unlocked();\n            if (c >= '0' && c <= '9')\n                break;\n        }\n    while (c >= '0' && c <= '9')\n        {\n            o = o * 10 + c - '0';\n            c = getchar_unlocked();\n        }\n    return o;\n}\n","function_prediction":"int read_int_name_conflict() {\n  int c, n = 0;\n  while (((c = getchar_unlocked()) < '0') || (c > '9'))\n    ;\n  while ((c >= '0') && (c <= '9')) {\n    n = (n << 3) + (n << 1) + c - '0';\n    c = getchar_unlocked();\n  }\n  return n;\n}","pass":1}
{"function":"int max_element(int *A, int N) {\n    int max = (-2147483647 - 1);\n    for (int i = 0; i < N; ++i)\n        if (A[i] > max)\n            max = A[i];\n    return max;\n}\n","function_prediction":"int max_element_name_conflict(int *arr, int n) {\n  int i, max = -2147483647;\n  for (i = 0; i < n; i++)\n    if (arr[i] > max)\n      max = arr[i];\n  return max;\n}","pass":0}
{"function":"int min_element(int *A, int N) {\n    int min = 2147483647;\n    for (int i = 0; i < N; ++i)\n        if (A[i] < min)\n            min = A[i];\n    return min;\n}\n","function_prediction":"int min_element_name_conflict(int *arr, int n) {\n  int min = 0x7fffffff;\n  for (int i = 0; i < n; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n}","pass":1}
{"function":"int check(int num) {\n    int num1 = 0;\n    int i = 0, j = 0, k = 0, l = 0;\n    int total[300] = {0};\n    int temp = 0, num2 = 0, check1 = 0;\n    for (i = 0; i < 17; i++) {\n        for (j = 0; j < 12; j++) {\n            for (k = 0; k < 6; k++) {\n                num1 = (6 * i) + (9 * j) + (20 * k);\n                if (num1 <= num && num1 > 0) {\n                    total[l] = num1;\n                    l++;\n                }\n            }\n        }\n    }\n    for (i = 1; i < l; i++) {\n        for (j = 0; j < l - 1; j++) {\n            if (total[j] > total[j + 1]) {\n                temp = total[j];\n                total[j] = total[j + 1];\n                total[j + 1] = temp;\n            }\n        }\n    }\n    for (i = 0; i < l; i++) {\n        check1 = 1;\n        for (j = i - 1; j > 0; j--) {\n            if (total[i] == total[j]) {\n                check1 = 0;\n            }\n        }\n        if (check1 == 1) {\n            printf(\"%d\\n\", total[i]);\n        }\n    }\n}\n","function_prediction":"void check_name_conflict(int n) {\n int i,j,k,m,p,q,r,s,t,u,v,w,x,y,z,a[100],b[100],c[100],d[100],e[100],f[100],g[100],h[100],i1[100],j1[100],k1[100],l[100],m1[100],n1[100],o[100],p1[100],q1[100],r1[100],s1[100],t1[100],u1[100],v1[100],w1[100],x1[100],y1[100],z1[100],a1[100],b1[100],c1[100],d1[100],e1[100],f1[100],g1[100],h1[100],i2[100],j2[100],k2[100],l2[100],m2[100],n2[100],o2[100],p2[100],q2[100],r2[100],s2[100],t2[100],u2[100],v2[100],w2[100],x2[100],y2[100],z2[100],a2[100],b2[100],c2[100],d2[100],e2[100],f2[100],g2[100],h2[100],i3[100],j3[100],k3[100],l3[100],m3[100],n3[100],o3[100],p3[100],q3[100","pass":0}
{"function":"int absolute(int a) {\n    if (a < 0) {\n        return a * -1;\n    } else {\n        return a;\n    }\n}\n","function_prediction":"int absolute_name_conflict(int x) {\n  if (x < 0)\n    return -x;\n  else\n    return x;\n}","pass":1}
