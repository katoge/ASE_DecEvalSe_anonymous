{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlcpy_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x40]\n  unsigned long v1; // [bp-0x20]\n  char *v2;         // [bp-0x18], Other Possible Types: unsigned long\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n  char *v5;         // rdx\n  char *v6;         // rax\n  char *v7;         // rax\n\n  v0 = a2;\n  v3 = a0;\n  v2 = a1;\n  v1 = v0;\n  if (v1) {\n    do {\n      v1 -= 1;\n    } while (v1 && (v5 = v2, v2 = (unsigned long)(v5 + 1), v6 = v3,\n                    v3 = (unsigned long)(v6 + 1), *(v6) = *(v5), *(v6)));\n  }\n  if (v1)\n    return -1 + v2 - a1;\n  if (v0)\n    *((char *)v3) = 0;\n  do {\n    v7 = v2;\n    v2 = v7 + 1;\n  } while (*(v7));\n  return -1 + v2 - a1;\n}\n","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlcpy_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x40]\n  unsigned long v1; // [bp-0x20]\n  char *v2;         // [bp-0x18], Other Possible Types: unsigned long\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n  char *v5;         // rdx\n  char *v6;         // rax\n  char *v7;         // rax\n\n  v0 = a2;\n  v3 = a0;\n  v2 = a1;\n  v1 = v0;\n  if (v1) {\n    do {\n      v1 -= 1;\n    } while (v1 && (v5 = v2, v2 = (unsigned long)(v5 + 1), v6 = v3,\n                    v3 = (unsigned long)(v6 + 1), *(v6) = *(v5), *(v6)));\n  }\n  if (v1)\n    return -1 + v2 - a1;\n  if (v0)\n    *((char *)v3) = 0;\n  do {\n    v7 = v2;\n    v2 = v7 + 1;\n  } while (*(v7));\n  return -1 + v2 - a1;\n}\n","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlcpy_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x40]\n  unsigned long v1; // [bp-0x20]\n  char *v2;         // [bp-0x18], Other Possible Types: unsigned long\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n  char *v5;         // rdx\n  char *v6;         // rax\n  char *v7;         // rax\n\n  v0 = a2;\n  v3 = a0;\n  v2 = a1;\n  v1 = v0;\n  if (v1) {\n    do {\n      v1 -= 1;\n    } while (v1 && (v5 = v2, v2 = (unsigned long)(v5 + 1), v6 = v3,\n                    v3 = (unsigned long)(v6 + 1), *(v6) = *(v5), *(v6)));\n  }\n  if (v1)\n    return -1 + v2 - a1;\n  if (v0)\n    *((char *)v3) = 0;\n  do {\n    v7 = v2;\n    v2 = v7 + 1;\n  } while (*(v7));\n  return -1 + v2 - a1;\n}\n","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(MD5Update)(long long, long long, long long);\n\nlong long hash_file_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;               // [bp-0x1018]\n  unsigned long long v1; // [bp-0x18]\n  void *v2;              // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = 0;\n  while (true) {\n    v1 = read(a1, &v0, 0x1000);\n    if (v1 <= 0)\n      break;\n    MD5Update(a0, &v0, v1);\n    v2 += v1;\n  }\n  v0 = 0;\n  MD5Update(a0, &v0, 1);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"int bb_make_directory(char *path, long mode, int flags) {\n    mode_t mask;\n    const char *fail_msg;\n    char *s = path;\n    char c;\n    struct stat st;\n    mask = umask(0);\n    if (mode == -1) {\n        umask(mask);\n        mode = (64 | (64 >> 3) | ((64 >> 3) >> 3) | 128 | (128 >> 3) | ((128 >> 3) >> 3) | 256 | (256 >> 3) | ((256 >> 3) >> 3)) & ~mask;\n    } else {\n        umask(mask & ~192);\n    }\n    do {\n        c = 0;\n        if (flags & FILEUTILS_RECUR) {\n            while (*s)\n                {\n                    if (*s == '/') {\n                        do {\n                            ++s;\n                        } while (*s == '/');\n                        c = *s;\n                        *s = 0;\n                        break;\n                    }\n                    ++s;\n                }\n        }\n        if (mkdir(path, 511) < 0) {\n            if (((*__errno_location()) != 17 && (*__errno_location()) != 21) || !(flags & FILEUTILS_RECUR) || (stat(path, &st) < 0 || !((((st.st_mode)) & 61440) == (16384)))) {\n                fail_msg = \"create\";\n                umask(mask);\n                break;\n            }\n            if (!c) {\n                umask(mask);\n                return 0;\n            }\n        }\n        if (!c) {\n            umask(mask);\n            if ((mode != -1) && (chmod(path, mode) < 0)) {\n                fail_msg = \"set permissions of\";\n                break;\n            }\n            return 0;\n        }\n        *s = c;\n    } while (1);\n    bb_perror_msg(\"Cannot %s directory `%s'\", fail_msg, path);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(umask)(unsigned short);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(chmod)(char *, unsigned short);\nlong long(bb_perror_msg)(...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long bb_make_directory_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0;      // [bp-0xc8]\n  stat v1;               // [bp-0xb8]\n  char v2;               // [bp-0xa0]\n  unsigned int v3;       // [bp-0x20]\n  char v4;               // [bp-0x19]\n  char *v5;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long v6;      // [bp-0x10]\n  unsigned long long v9; // rax\n\n  v0 = a1;\n  v5 = a0;\n  v3 = umask(0);\n  if (v0 != -1) {\n    v9 = v3;\n    *((char *)&v9) = (char)v9 & 63;\n    umask(v9);\n  } else {\n    umask(v3);\n    v0 = ~(v3) & 511;\n  }\n  while (true) {\n    if (((char)a2 & 4)) {\n      for (v4 = 0; *((char *)v5); v5 += 1) {\n        if (*((char *)v5) == 47) {\n          do {\n            v5 += 1;\n          } while (*((char *)v5) == 47);\n          v4 = *((char *)v5);\n          *((char *)v5) = 0;\n          break;\n        }\n      }\n    }\n    if (mkdir(a0, 511) < 0) {\n      if (!(*(__errno_location()) == 17) && !(*(__errno_location()) == 21) ||\n          !(((char)a2 & 4)) || !(stat(a0, &v1) >= 0) ||\n          !(((short)*((int *)&v2) & 0xf000) == 0x4000)) {\n        v6 = \"create\";\n        umask(v3);\n        bb_perror_msg();\n        return 4294967295;\n      } else if (!v4) {\n        umask(v3);\n        return 0;\n      }\n    }\n    if (!v4)\n      break;\n    *((char *)v5) = v4;\n  }\n  umask(v3);\n  if (!(v0 != -1) || !(chmod(a0, v0) < 0))\n    return 0;\n  v6 = \"set permissions of\";\n  bb_perror_msg();\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:30:27: error: ISO C requires a named\nparameter before '...' 30 | long long (bb_perror_msg)(...); | ^\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:17:6: note: previous definition is here\n   17 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:55:5: error: must use 'struct' tag to refer\nto type 'stat' 55 |     stat v1;  // [bp-0xb8] |     ^ |     struct\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:17:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:97:19: error: indirection requires pointer\noperand ('int' invalid) 97 |             if (!(*(__errno_location()) == 17) &&\n!(*(__errno_location()) == 21) || !(((char)a2 & 4)) || !(stat(a0, &v1) >= 0) ||\n!(((short)*((int *)&v2) & 0xf000) == 0x4000)) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppzyd58_a/bb_make_directory_name_conflict.c:97:53: error: indirection requires pointer\noperand ('int' invalid) 97 |             if (!(*(__errno_location()) == 17) &&\n!(*(__errno_location()) == 21) || !(((char)a2 & 4)) || !(stat(a0, &v1) >= 0) ||\n!(((short)*((int *)&v2) & 0xf000) == 0x4000)) | ^~~~~~~~~~~~~~~~~~~~~ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"long my_getpwnam(const char *name) {\n    struct passwd *myuser;\n    myuser = getpwnam(name);\n    if (myuser == ((void *)0))\n        bb_error_msg_and_die(\"unknown user name: %s\", name);\n    return myuser->pw_uid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct passwd *(getpwnam)(char *);\nlong long(bb_error_msg_and_die)(...);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long my_getpwnam_name_conflict(char *a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = &getpwnam(a0)->pw_name;\n  if (!v0)\n    bb_error_msg_and_die(); /* do not return */\n  return v0->field_10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3ywu8p0p/my_getpwnam_name_conflict.c:17:34: error: ISO C requires a named parameter\nbefore '...' 17 | long long (bb_error_msg_and_die)(...); | ^\n/tmp/tmp3ywu8p0p/my_getpwnam_name_conflict.c:28:23: error: incomplete definition of type\n'struct passwd' 28 |     v0 = &getpwnam(a0)->pw_name; |           ~~~~~~~~~~~~^\n/tmp/tmp3ywu8p0p/my_getpwnam_name_conflict.c:16:8: note: forward declaration of 'struct\npasswd' 16 | struct passwd *(getpwnam)(char *); |        ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"long my_getgrnam(const char *name) {\n    struct group *mygroup;\n    mygroup = getgrnam(name);\n    if (mygroup == ((void *)0))\n        bb_error_msg_and_die(\"unknown group name: %s\", name);\n    return (mygroup->gr_gid);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct group *(getgrnam)(char *);\nlong long(bb_error_msg_and_die)(...);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long my_getgrnam_name_conflict(char *a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = &getgrnam(a0)->gr_name;\n  if (!v0)\n    bb_error_msg_and_die(); /* do not return */\n  return v0->field_10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyvprwo8j/my_getgrnam_name_conflict.c:17:34: error: ISO C requires a named parameter\nbefore '...' 17 | long long (bb_error_msg_and_die)(...); | ^\n/tmp/tmpyvprwo8j/my_getgrnam_name_conflict.c:28:23: error: incomplete definition of type\n'struct group' 28 |     v0 = &getgrnam(a0)->gr_name; |           ~~~~~~~~~~~~^\n/tmp/tmpyvprwo8j/my_getgrnam_name_conflict.c:16:8: note: forward declaration of 'struct group'\n   16 | struct group *(getgrnam)(char *);\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":1,"function":"char *last_char_is(const char *s, int c) {\n    char *sret = (char *)s;\n    if (sret) {\n        sret = strrchr(sret, c);\n        if (sret != ((void *)0) && *(sret + 1) != 0)\n            sret = ((void *)0);\n    }\n    return sret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long last_char_is_name_conflict(struct_0 *a0, unsigned long a1) {\n  struct_0 *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  if (!v0)\n    return v0;\n  v0 = strrchr(v0, a1);\n  if (!v0) {\n    return v0;\n  } else if (!*((char *)(v0 + 1))) {\n    return v0;\n  } else {\n    v0 = 0;\n    return v0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"char *concat_path_file(const char *path, const char *filename) {\n    char *outbuf;\n    char *lc;\n    if (!path)\n        path = \"\";\n    lc = last_char_is(path, '/');\n    while (*filename == '/')\n        filename++;\n    bb_xasprintf(&outbuf, \"%s%s%s\", path, (lc == ((void *)0) ? \"/\" : \"\"), filename);\n    return outbuf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(last_char_is)(long long, long long);\nlong long(bb_xasprintf)(...);\n\nextern char g_40400d;\n\nlong long concat_path_file_name_conflict(unsigned long a0, char *a1) {\n  char *v0;              // [bp-0x28], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x20], Other Possible Types: unsigned long long\n  char v2;               // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v1 = a0;\n  v0 = a1;\n  if (!v1)\n    v1 = &g_40400d;\n  for (v3 = last_char_is(v1, 47); *((char *)v0) == 47; v0 += 1)\n    ;\n  bb_xasprintf();\n  return *((long long *)&v2);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuenc1m2x/concat_path_file_name_conflict.c:17:26: error: ISO C requires a named\nparameter before '...' 17 | long long (bb_xasprintf)(...); | ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"pid_t getppidof(const pid_t pid) {\n    int ppid;\n    char buffer[8192];\n    size_t size;\n    FILE *fp;\n    sprintf(buffer, \"/proc/%d/stat\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            strtok(buffer, \" \");\n            strtok(((void *)0), \" \");\n            strtok(((void *)0), \" \");\n            ppid = atoi(strtok(((void *)0), \" \"));\n        }\n        fclose(fp);\n    }\n    return ppid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nchar *(strtok)(char *, char *);\nint(atoi)(char *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long getppidof_name_conflict(unsigned long a0) {\n  char v0;          // [bp-0x2028]\n  unsigned long v1; // [bp-0x20]\n  FILE_t *v2;       // [bp-0x18]\n  unsigned int v3;  // [bp-0xc]\n\n  sprintf(&v0, \"/proc/%d/stat\", (unsigned int)a0);\n  v2 = &fopen(&v0, \"r\")->_flags;\n  if (!v2)\n    return v3;\n  v1 = fread(&v0, 1, 0x2000, v2);\n  if (v1) {\n    strtok(&v0, \" \");\n    strtok(NULL, \" \");\n    strtok(NULL, \" \");\n    v3 = atoi(strtok(NULL, \" \"));\n  }\n  fclose(v2);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:143:16: error: redefinition of '_IO_marker'\n  143 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:149:16: error: redefinition of '_IO_codecvt'\n  149 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:153:16: error: redefinition of '_IO_wide_data'\n  153 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp_2eevy26/getppidof_name_conflict.c:176:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 176 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *getnameof(const pid_t pid) {\n    static char buffer[8192];\n    char *old_buffer, *new_buffer;\n    FILE *fp;\n    size_t size;\n    sprintf(buffer, \"/proc/%d/cmdline\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            new_buffer = strtok(buffer, \"/\");\n            while (new_buffer != ((void *)0))\n                {\n                    old_buffer = new_buffer;\n                    new_buffer = strtok(((void *)0), \"/\");\n                }\n        }\n        fclose(fp);\n    }\n    return old_buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nchar *(strtok)(char *, char *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern char buffer.5;\n\nlong long getnameof_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x28]\n  FILE_t *v1;       // [bp-0x20]\n  unsigned long v2; // [bp-0x18]\n  unsigned long v3; // [bp-0x10]\n\n  sprintf(&buffer.5, \"/proc/%d/cmdline\", (unsigned int)a0);\n  v1 = &fopen(&buffer.5, \"r\")->_flags;\n  if (!v1)\n    return v3;\n  v0 = fread(&buffer.5, 1, 0x2000, v1);\n  if (v0) {\n    for (v2 = strtok(&buffer.5, \"/\"); v2; v2 = strtok(NULL, \"/\")) {\n      v3 = v2;\n    }\n  }\n  fclose(v1);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:175:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 175 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:177:19: error: expected ';' after top level\ndeclarator 177 | extern char buffer.5; |                   ^ | ;\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:186:20: error: expected ')'\n  186 |     sprintf(&buffer.5, \"/proc/%d/cmdline\", (unsigned int)a0);\n      |                    ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:186:12: note: to match this '('\n  186 |     sprintf(&buffer.5, \"/proc/%d/cmdline\", (unsigned int)a0);\n      |            ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:187:24: error: expected ')'\n  187 |     v1 = &fopen(&buffer.5, \"r\")->_flags;\n      |                        ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:187:16: note: to match this '('\n  187 |     v1 = &fopen(&buffer.5, \"r\")->_flags;\n      |                ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:190:23: error: expected ')'\n  190 |     v0 = fread(&buffer.5, 1, 0x2000, v1);\n      |                       ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:190:15: note: to match this '('\n  190 |     v0 = fread(&buffer.5, 1, 0x2000, v1);\n      |               ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:193:33: error: expected ')'\n  193 |         for (v2 = strtok(&buffer.5, \"/\"); v2; v2 = strtok(NULL, \"/\"))\n      |                                 ^\n/tmp/tmpty1j1qu7/getnameof_name_conflict.c:193:25: note: to match this '('\n  193 |         for (v2 = strtok(&buffer.5, \"/\"); v2; v2 = strtok(NULL, \"/\"))\n      |                         ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *_prisma_trytogettermname() {\n    static char _prisma_termname[64];\n    char *tmp = getnameof(getppidof(getsid(getpid())));\n    if (tmp) {\n        strncpy(_prisma_termname, tmp, 64);\n        if (!strncmp(_prisma_termname, \"initdline\", 64) || !strncmp(_prisma_termname, \"konsole\", 64))\n            return _prisma_termname;\n    }\n    strncpy(_prisma_termname, getenv(\"TERM\"), 64);\n    return _prisma_termname;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getsid)(int);\nlong long(getppidof)(long long);\nlong long(getnameof)(long long);\nchar *(getenv)(char *);\nchar *(strncpy)(char *, char *, unsigned long);\n\nextern char _prisma_termname.4;\n\nlong long _prisma_trytogettermname_name_conflict() {\n  char *v0; // [bp-0x10]\n\n  v0 = getnameof(getppidof(getsid(getpid())));\n  if (v0) {\n    strncpy(&_prisma_termname.4, v0, 64);\n    if (!(strcmp(&_prisma_termname.4, \"initdline\")) ||\n        !(strcmp(&_prisma_termname.4, \"konsole\")))\n      return &_prisma_termname.4;\n  }\n  strncpy(&_prisma_termname.4, getenv(\"TERM\"), 64);\n  return &_prisma_termname.4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:22:29: error: expected ';' after top\nlevel declarator 22 | extern char _prisma_termname.4; | ^ | ;\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:31:34: error: expected ')'\n   31 |         strncpy(&_prisma_termname.4, v0, 64);\n      |                                  ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:31:16: note: to match this '('\n   31 |         strncpy(&_prisma_termname.4, v0, 64);\n      |                ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:32:39: error: expected ')'\n   32 |         if (!(strcmp(&_prisma_termname.4, \"initdline\")) ||\n!(strcmp(&_prisma_termname.4, \"konsole\"))) | ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:32:21: note: to match this '('\n   32 |         if (!(strcmp(&_prisma_termname.4, \"initdline\")) ||\n!(strcmp(&_prisma_termname.4, \"konsole\"))) |                     ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:32:86: error: expected ')'\n   32 |         if (!(strcmp(&_prisma_termname.4, \"initdline\")) ||\n!(strcmp(&_prisma_termname.4, \"konsole\"))) | ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:32:68: note: to match this '('\n   32 |         if (!(strcmp(&_prisma_termname.4, \"initdline\")) ||\n!(strcmp(&_prisma_termname.4, \"konsole\"))) | ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:33:37: error: expected ';' after\nreturn statement 33 |             return &_prisma_termname.4; | ^ | ;\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:35:30: error: expected ')'\n   35 |     strncpy(&_prisma_termname.4, getenv(\"TERM\"), 64);\n      |                              ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:35:12: note: to match this '('\n   35 |     strncpy(&_prisma_termname.4, getenv(\"TERM\"), 64);\n      |            ^\n/tmp/tmplcvg28yi/_prisma_trytogettermname_name_conflict.c:36:29: error: expected ';' after\nreturn statement 36 |     return &_prisma_termname.4; | ^ | ; 7 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"int8_t prisma_adapt(int8_t adaptation) {\n    char *termname;\n    if (adaptation == -1) {\n        termname = _prisma_trytogettermname();\n        if (!strcmp(termname, \"xterm\"))\n            _prisma_adaptation = 2;\n        else if (!strcmp(termname, \"konsole\"))\n            _prisma_adaptation = 1;\n        else if (!strcmp(termname, \"linux\") || !strcmp(termname, \"initdline\"))\n            _prisma_adaptation = 3;\n        else if (!strncmp(termname, \"windows\", 7))\n            _prisma_adaptation = 4;\n        else\n            _prisma_adaptation = 0;\n    } else\n        _prisma_adaptation = adaptation;\n    return _prisma_adaptation;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_prisma_trytogettermname)();\n\nextern char _prisma_adapt_name_conflictation;\n\nlong long prisma_adapt_name_conflict(unsigned long a0) {\n  char *v0; // [bp-0x10]\n\n  if ((char)a0 != 255) {\n    _prisma_adapt_name_conflictation = a0;\n    return _prisma_adapt_name_conflictation;\n  }\n  v0 = _prisma_trytogettermname();\n  if (!strcmp(v0, \"xterm\")) {\n    _prisma_adapt_name_conflictation = 2;\n    return _prisma_adapt_name_conflictation;\n  } else if (strcmp(v0, \"konsole\")) {\n    if (strcmp(v0, \"linux\") && strcmp(v0, \"initdline\")) {\n      if (strncmp(v0, \"windows\", 7)) {\n        _prisma_adapt_name_conflictation = 0;\n        return _prisma_adapt_name_conflictation;\n      }\n      _prisma_adapt_name_conflictation = 4;\n      return _prisma_adapt_name_conflictation;\n    }\n    _prisma_adapt_name_conflictation = 3;\n    return _prisma_adapt_name_conflictation;\n  } else {\n    _prisma_adapt_name_conflictation = 1;\n    return _prisma_adapt_name_conflictation;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbto8color(uint32_t argb) {\n    argb = ((argb & 16711680) >= 8323072 ? 16711680 : 0) | ((argb & 65280) >= 32512 ? 65280 : 0) | ((argb & 255) >= 127 ? 255 : 0);\n    switch (argb) {\n      case 0:\n        return 0;\n      case 16711680:\n        return 1;\n      case 65280:\n        return 2;\n      case 16776960:\n        return 3;\n      case 255:\n        return 4;\n      case 16711935:\n        return 5;\n      case 65535:\n        return 6;\n      case 16777215:\n        return 7;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long prisma_argbto8color_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0xc]\n  unsigned int v4;  // edx\n  unsigned long v6; // rax, Other Possible Types: unsigned long long\n\n  v0 = a0;\n  v4 = ((v0 & 0xff0000) <= 8323071 ? 0xff0000 : 0) |\n       ((v0 & 0xff00) <= 32511 ? 0xff00 : 0);\n  v6 = (v0 <= 126 ? 255 : 0) | v4;\n  v0 = v6;\n  if (v0 == 16777215) {\n    return 7;\n  } else if (v0 > 16777215) {\n    return v6;\n  } else if (v0 == 0xffff00) {\n    return 3;\n  } else if (v0 > 0xffff00) {\n    return v6;\n  } else if (v0 == 16711935) {\n    return 5;\n  } else if (v0 > 16711935) {\n    return v6;\n  } else if (v0 == 0xff0000) {\n    return 1;\n  } else if (v0 > 0xff0000) {\n    return v6;\n  } else if (v0 == 65535) {\n    return 6;\n  } else if (v0 > 65535) {\n    return v6;\n  } else if (v0 == 0xff00) {\n    return 2;\n  } else if (v0 > 0xff00) {\n    return v6;\n  } else if (v0) {\n    if (v0 != 255)\n      return v6;\n    v6 = 4;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_8colortoargb(uint8_t src) {\n    switch (src) {\n      case 0:\n        return 4278190080U;\n      case 1:\n        return 4294901760U;\n      case 2:\n        return 4278255360U;\n      case 3:\n        return 4294967040U;\n      case 4:\n        return 4278190335U;\n      case 5:\n        return 4294902015U;\n      case 6:\n        return 4278255615U;\n      case 7:\n        return 4294967295U;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4206708];\n  unsigned int field_403074;\n} struct_0;\n\nextern char g_403074;\n\nlong long prisma_8colortoargb_name_conflict(unsigned long a0) {\n  switch ((unsigned int)(char)a0) {\n  case 0:\n    return 0xff000000;\n  case 1:\n    return 0xffff0000;\n  case 2:\n    return 0xff00ff00;\n  case 3:\n    return 0xffffff00;\n  case 4:\n    return 4278190335;\n  case 5:\n    return 4294902015;\n  case 6:\n    return 4278255615;\n  case 7:\n    return 4294967295;\n  default:\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbtoxterm(uint32_t argb) {\n    uint8_t r, g, b;\n    prisma_argbtobytes(argb, ((void *)0), &r, &g, &b);\n    return ((r >= 4 && r <= 246 && r == g && g == b) ? (232 + ((r - 8) * 24 / 238)) : (16 + (36 * (r / 51)) + (6 * (g / 51)) + (b / 51)));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint dl;  // add global variable by heuristics\nint dl;  // add global variable by heuristics\nint rdx; // add global variable by heuristics\nint rdx; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(prisma_argbtobytes)(long long, long long, long long, long long,\n                              long long);\n\nlong long prisma_argbtoxterm_name_conflict(unsigned long a0) {\n  char v0;                // [bp-0xb]\n  char v1;                // [bp-0xa]\n  char v2;                // [bp-0x9]\n  unsigned long v4;       // rax, Other Possible Types: unsigned long long\n  unsigned long long v5;  // rax\n  unsigned long long v6;  // rdx\n  unsigned long long v8;  // rax\n  unsigned long long v9;  // rdx\n  unsigned int v10;       // edx\n  unsigned long long v11; // rax\n\n  prisma_argbtobytes((unsigned int)a0, 0, &v2, &v1, &v0);\n  if (v2 > 3 && v2 <= 246 && v2 == v1 && v1 == v0) {\n    v4 = (unsigned int)(((v2 - 8) * 2 + v2 - 8) * 4 / 119) - 24;\n    return v4;\n  }\n  v5 = v2;\n  *((unsigned short *)&v5) = (char)v5 * 161 >> 8;\n  v6 = v5;\n  *((char *)&v6) = dl<1> >> 5;\n  v8 = v1;\n  *((unsigned short *)&v8) = (char)v8 * 161 >> 8;\n  v9 = v8;\n  *((char *)&v8) = dl<1> >> 5;\n  v10 = (int)(9 * rdx * 4) + 3 * rdx * 2;\n  v11 = v0;\n  *((unsigned short *)&v11) = (char)v11 * 161 >> 8;\n  *((char *)&v11) = (char)v11 >> 5;\n  v4 = (unsigned int)v11 + v10 + 16;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpib4f5oj7/prisma_argbtoxterm_name_conflict.c:44:28: error: expected expression\n   44 |     *((char *)&v6) = dl<1> >> 5;\n      |                            ^\n/tmp/tmpib4f5oj7/prisma_argbtoxterm_name_conflict.c:48:28: error: expected expression\n   48 |     *((char *)&v8) = dl<1> >> 5;\n      |                            ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_xtermtoargb(uint8_t index) {\n    uint32_t argb;\n    if (index < 8) {\n        argb = prisma_8colortoargb(index);\n        if (argb == 4294967295U)\n            argb = 4290822336U;\n        else\n            argb = 4278190080U | ((argb & 16711680) != 0 ? 8388608 : 0) | ((argb & 65280) != 0 ? 32768 : 0) | ((argb & 255) != 0 ? 128 : 0);\n    } else if (index < 16) {\n        index -= 8;\n        argb = prisma_8colortoargb(index);\n        if (argb == 0)\n            argb = 4286611584U;\n    } else if (index < 232) {\n        index -= 16;\n        argb = 4278190080U | ((51 * (index / 36)) << 16) | ((51 * ((index % 36) / 6)) << 8) | (51 * (index % 6));\n    } else {\n        index -= 232;\n        argb = (8 + (10 * index));\n        argb |= 4278190080U | (argb << 16) | (argb << 8);\n    }\n    return argb;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint dl;  // add global variable by heuristics\nint rdx; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(prisma_8colortoargb)(long long);\n\nlong long prisma_xtermtoargb_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long long v6; // rax\n  unsigned long long v7; // rdx\n  unsigned int v10;      // edx\n\n  v4 = &v2;\n  v0 = a0;\n  if (v0 <= 7) {\n    v1 = prisma_8colortoargb(v0);\n    if (v1 == -1) {\n      v1 = -4144960;\n      return v1;\n    }\n    v10 = (!(v1 & 0xff0000) ? -0x800000 : -0x1000000) |\n          (!(v1 & 0xff00) ? 0x8000 : 0);\n    v1 = (!v1 ? 128 : 0) | v10;\n    return v1;\n  } else if (v0 <= 15) {\n    v0 -= 8;\n    v1 = prisma_8colortoargb(v0);\n    if (!v1) {\n      v1 = -8355712;\n      return v1;\n    }\n    return v1;\n  } else if (v0 > 231) {\n    v0 += 24;\n    v1 = 5 * v0 * 2 + 8;\n    v1 = v1 * 0x100 | v1 * 0x10000 | v1 | -0x1000000;\n    return v1;\n  } else {\n    v0 -= 16;\n    v6 = 4294967211;\n    *((unsigned short *)&v6) = 171 * v0 >> 8;\n    v7 = v6;\n    *((char *)&v7) = dl<1> >> 2;\n    v1 = (unsigned int)(v0 - 3 * rdx * 2) * 51 |\n         (unsigned int)(v0 * 57 >> 11) * 0x330000 |\n         (unsigned int)(v0 * 171 >> 10) * 0x3300 | -0x1000000;\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfw93ftdi/prisma_xtermtoargb_name_conflict.c:68:32: error: expected expression\n   68 |         *((char *)&v7) = dl<1> >> 2;\n      |                                ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"const uint32_t *prisma_gradient(uint8_t resolution, uint32_t argb_first, uint32_t argb_last) {\n    static uint32_t gradient[256];\n    float i, a, r, g, b, offset;\n    memset(gradient, 0, 256 * sizeof(uint32_t));\n    if (resolution == 0)\n        return gradient;\n    if (resolution == 1) {\n        gradient[0] = argb_first;\n        return gradient;\n    }\n    gradient[0] = argb_first;\n    i = 1.F;\n    do {\n        if ((((argb_first) & 4278190080U) >> 24) < (((argb_last) & 4278190080U) >> 24)) {\n            offset = ((float)((((argb_last) & 4278190080U) >> 24) - (((argb_first) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_first) & 4278190080U) >> 24) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 4278190080U) >> 24) - (((argb_last) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_last) & 4278190080U) >> 24) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 16711680) >> 16) < (((argb_last) & 16711680) >> 16)) {\n            offset = ((float)((((argb_last) & 16711680) >> 16) - (((argb_first) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_first) & 16711680) >> 16) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 16711680) >> 16) - (((argb_last) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_last) & 16711680) >> 16) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 65280) >> 8) < (((argb_last) & 65280) >> 8)) {\n            offset = ((float)((((argb_last) & 65280) >> 8) - (((argb_first) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_first) & 65280) >> 8) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 65280) >> 8) - (((argb_last) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_last) & 65280) >> 8) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if (((argb_first) & 255) < ((argb_last) & 255)) {\n            offset = ((float)(((argb_last) & 255) - ((argb_first) & 255))) / (float)resolution;\n            b = ((argb_first) & 255) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)(((argb_first) & 255) - ((argb_last) & 255))) / (float)resolution;\n            b = ((argb_last) & 255) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        gradient[(uint8_t)i] = (((((uint8_t)a) << 24) & 4278190080U) | ((((uint8_t)r) << 16) & 16711680) | ((((uint8_t)g) << 8) & 65280) | (((uint8_t)b) & 255));\n        i++;\n    } while (i <= resolution && i != 0.F);\n    gradient[((uint8_t)i) - 2] = argb_last;\n    return gradient;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t;   // add global variable by heuristics\nint xmm0;       // add global variable by heuristics\nint addr;       // add global variable by heuristics\nint stack_base; // add global variable by heuristics\nint size;       // add global variable by heuristics\nint endness;    // add global variable by heuristics\nint Iend_LE;    // add global variable by heuristics\nint t34;        // add global variable by heuristics\nint addr;       // add global variable by heuristics\nint stack_base; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nfloat(ceilf)(float);\n\nextern void gradient.0;\n\nlong long prisma_gradient(unsigned long a0, unsigned long a1,\n                          unsigned long a2) {\n  int tmp_30;        // tmp #30\n  int tmp_32;        // tmp #32\n  int tmp_31;        // tmp #31\n  unsigned int v0;   // [bp-0x38]\n  int tmp_34;        // tmp #34\n  int tmp_36;        // tmp #36\n  int tmp_35;        // tmp #35\n  int tmp_6;         // tmp #6\n  int tmp_8;         // tmp #8\n  int tmp_7;         // tmp #7\n  int tmp_23;        // tmp #23\n  int tmp_25;        // tmp #25\n  int tmp_24;        // tmp #24\n  unsigned int v1;   // [bp-0x20]\n  unsigned int v2;   // [bp-0x1c]\n  unsigned int v3;   // [bp-0x18]\n  unsigned int v4;   // [bp-0x14]\n  unsigned int v5;   // [bp-0x10]\n  unsigned int v6;   // [bp-0xc]\n  int v11;           // xmm0\n  int v12;           // xmm0\n  int v14;           // xmm0\n  int v18;           // xmm0\n  int v19;           // xmm0\n  int v21;           // xmm0\n  int v26;           // xmm0\n  int v27;           // xmm0\n  int v29;           // xmm0\n  unsigned long v31; // rax\n  unsigned long v33; // rax\n  int v35;           // xmm0\n  int v36;           // xmm0\n  int v38;           // xmm0\n\n  memset(&gradient.0, 0, 0x400);\n  if (!(char)a0) {\n    return &gradient.0;\n  } else if ((char)a0 != 1) {\n    *((unsigned int *)&gradient.0) = a1;\n    v6 = 0x3f800000;\n    while (true) {\n      if ((unsigned int)((unsigned int)a1 >> 24) <\n          (unsigned int)((unsigned int)a2 >> 24)) {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        *((int128_t *)&v1) = tmp_30;\n        if (v0 < 0)\n          v0 = (0 CONCAT(unsigned int)((unsigned int)a1 >> 25) | v0 & 1) * 2;\n        else\n          v0 = (unsigned int)a1 >> 24;\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v11);\n        xmm0 = (xmm0 + Conv(32->128, Load(addr = stack_base - 56, size = 4,\n                                          endness = Iend_LE)))\n      } else {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        *((int128_t *)&v1) = tmp_30;\n        if (v0 >= 0)\n          v0 = (unsigned int)a2 >> 24;\n        else\n          v0 = (0 CONCAT(unsigned int)((unsigned int)a2 >> 25) | v0 & 1) * 2;\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v14);\n        tmp_6 = SubV(tmp_8, tmp_7);\n        v12 = tmp_6;\n      }\n      v5 = (unsigned int)v12;\n      if ((unsigned int)((unsigned int)a1 >> 16) >=\n          (unsigned int)((unsigned int)a2 >> 16)) {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        *((int128_t *)&v1) = tmp_30;\n        if (v0 >= 0)\n          v0 = (unsigned int)a2 >> 16;\n        else\n          v0 = (0 CONCAT(unsigned int)((unsigned int)a2 >> 17) | v0 & 1) * 2;\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v21);\n        tmp_6 = SubV(tmp_8, tmp_7);\n        v19 = tmp_6;\n      } else {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        *((int128_t *)&v1) = tmp_30;\n        if (v0 >= 0)\n          v0 = (unsigned int)a1 >> 16;\n        else\n          v0 = (0 CONCAT(unsigned int)((unsigned int)a1 >> 17) | v0 & 1) * 2;\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v18);\n        xmm0 = (xmm0 + Conv(32->128, Load(addr = stack_base - 56, size = 4,\n                                          endness = Iend_LE)))\n      }\n      v4 = (unsigned int)v19;\n      if ((unsigned int)((unsigned int)a1 >> 8) >=\n          (unsigned int)((unsigned int)a2 >> 8)) {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        *((int128_t *)&v1) = tmp_30;\n        if (v0 < 0)\n          v0 = (0 CONCAT(unsigned int)((unsigned int)a2 >> 9) | v0 & 1) * 2;\n        else\n          v0 = (unsigned int)a2 >> 8;\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v29);\n        tmp_6 = SubV(tmp_8, tmp_7);\n        v27 = tmp_6;\n      } else {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        *((int128_t *)&v1) = tmp_30;\n        if (v0 < 0)\n          v0 = (0 CONCAT(unsigned int)((unsigned int)a1 >> 9) | v0 & 1) * 2;\n        else\n          v0 = (unsigned int)a1 >> 8;\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v26);\n        xmm0 = (xmm0 + Conv(32->128, Load(addr = stack_base - 56, size = 4,\n                                          endness = Iend_LE)))\n      }\n      v3 = (unsigned int)v27;\n      if ((unsigned int)a1 >= (unsigned int)a2) {\n        tmp_23 = DivV(tmp_25, tmp_24);\n        *((int128_t *)&v1) = tmp_23;\n        v33 = (unsigned int)a2;\n        if (v33 >= 0) {\n          v0 = v33;\n        } else {\n          a2 = (unsigned int)v33 / 2 | (unsigned int)v33 & 1;\n          v0 = (0 CONCAT a2) * 2;\n        }\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v38);\n        tmp_6 = SubV(tmp_8, tmp_7);\n        v36 = tmp_6;\n      } else {\n        tmp_23 = DivV(tmp_25, tmp_24);\n        *((int128_t *)&v1) = tmp_23;\n        v31 = (unsigned int)a1;\n        if (v31 >= 0) {\n          v0 = v31;\n        } else {\n          a2 = (unsigned int)v31 / 2 | (unsigned int)v31 & 1;\n          v0 = (0 CONCAT a2) * 2;\n        }\n        tmp_34 = DivV(tmp_36, tmp_35);\n        xmm0 = ((t34 + Conv(32->128, Load(addr = stack_base - 12, size = 4,\n                                          endness = Iend_LE))) *\n                Conv(32->128,\n                     Load(addr = stack_base - 32, size = 4, endness = Iend_LE)))\n            ceilf((unsigned int)v35);\n        xmm0 = (xmm0 + Conv(32->128, Load(addr = stack_base - 56, size = 4,\n                                          endness = Iend_LE)))\n      }\n      v2 = (unsigned int)v36;\n      *((unsigned int *)&(&gradient.0)[4 * v6]) =\n          v5 * 0x1000000 | v4 * 0x10000 & 0xff0000 | v3 * 0x100 | v2;\n      v6 = (0 CONCAT 0x3f800000) + (0 CONCAT v6);\n      if (!(!(CmpF((char)a0, v6) & 1)) ||\n          !(((char)((CmpF(0, v6) & 69) >> 2) & 1)) &&\n              !(((char)((CmpF(0, v6) & 69) >> 6) & 1) != 1))\n        break;\n      continue;\n      if (((char)((CmpF(0, v6) & 69) >> 6) & 1) == 1)\n        break;\n    }\n    *((unsigned int *)&(&gradient.0)[8 + 4 * v6]) = a2;\n    return &gradient.0;\n  } else {\n    *((unsigned int *)&gradient.0) = a1;\n    return &gradient.0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9yd34_22/prisma_gradient.c:28:21: error: expected ';' after top level\ndeclarator 28 | extern void gradient.0; |                     ^ | ;\n/tmp/tmp9yd34_22/prisma_gradient.c:66:21: error: expected ')'\n   66 |     memset(&gradient.0, 0, 0x400);\n      |                     ^\n/tmp/tmp9yd34_22/prisma_gradient.c:66:11: note: to match this '('\n   66 |     memset(&gradient.0, 0, 0x400);\n      |           ^\n/tmp/tmp9yd34_22/prisma_gradient.c:69:25: error: expected ';' after return\nstatement 69 |         return &gradient.0; |                         ^ | ;\n/tmp/tmp9yd34_22/prisma_gradient.c:73:36: error: expected ')'\n   73 |         *((unsigned int *)&gradient.0) = a1;\n      |                                    ^\n/tmp/tmp9yd34_22/prisma_gradient.c:73:10: note: to match this '('\n   73 |         *((unsigned int *)&gradient.0) = a1;\n      |          ^\n/tmp/tmp9yd34_22/prisma_gradient.c:80:30: error: expected expression\n   80 |                 *((int128_t *)&v1) = tmp_30;\n      |                              ^\n/tmp/tmp9yd34_22/prisma_gradient.c:82:29: error: expected ')'\n   82 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a1 >>\n25) | v0 & 1) * 2; |                             ^\n/tmp/tmp9yd34_22/prisma_gradient.c:82:26: note: to match this '('\n   82 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a1 >>\n25) | v0 & 1) * 2; |                          ^\n/tmp/tmp9yd34_22/prisma_gradient.c:86:41: error: expected identifier\n   86 |                 xmm0 = ((t34 + Conv(32->128, Load(addr=stack_base-12,\nsize=4, endness=Iend_LE))) * Conv(32->128, Load(addr=stack_base-32, size=4,\nendness=Iend_LE))) |                                         ^\n/tmp/tmp9yd34_22/prisma_gradient.c:86:109: error: expected identifier\n   86 |                 xmm0 = ((t34 + Conv(32->128, Load(addr=stack_base-12,\nsize=4, endness=Iend_LE))) * Conv(32->128, Load(addr=stack_base-32, size=4,\nendness=Iend_LE))) | ^ /tmp/tmp9yd34_22/prisma_gradient.c:88:41: error: expected\nidentifier 88 |                 xmm0 = (xmm0 + Conv(32->128,\nLoad(addr=stack_base-56, size=4, endness=Iend_LE))) | ^\n/tmp/tmp9yd34_22/prisma_gradient.c:93:30: error: expected expression\n   93 |                 *((int128_t *)&v1) = tmp_30;\n      |                              ^\n/tmp/tmp9yd34_22/prisma_gradient.c:97:29: error: expected ')'\n   97 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a2 >>\n25) | v0 & 1) * 2; |                             ^\n/tmp/tmp9yd34_22/prisma_gradient.c:97:26: note: to match this '('\n   97 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a2 >>\n25) | v0 & 1) * 2; |                          ^\n/tmp/tmp9yd34_22/prisma_gradient.c:99:41: error: expected identifier\n   99 |                 xmm0 = ((t34 + Conv(32->128, Load(addr=stack_base-12,\nsize=4, endness=Iend_LE))) * Conv(32->128, Load(addr=stack_base-32, size=4,\nendness=Iend_LE))) |                                         ^\n/tmp/tmp9yd34_22/prisma_gradient.c:99:109: error: expected identifier\n   99 |                 xmm0 = ((t34 + Conv(32->128, Load(addr=stack_base-12,\nsize=4, endness=Iend_LE))) * Conv(32->128, Load(addr=stack_base-32, size=4,\nendness=Iend_LE))) | ^ /tmp/tmp9yd34_22/prisma_gradient.c:108:30: error:\nexpected expression 108 |                 *((int128_t *)&v1) = tmp_30; | ^\n/tmp/tmp9yd34_22/prisma_gradient.c:112:29: error: expected ')'\n  112 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a2 >>\n17) | v0 & 1) * 2; |                             ^\n/tmp/tmp9yd34_22/prisma_gradient.c:112:26: note: to match this '('\n  112 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a2 >>\n17) | v0 & 1) * 2; |                          ^\n/tmp/tmp9yd34_22/prisma_gradient.c:114:41: error: expected identifier\n  114 |                 xmm0 = ((t34 + Conv(32->128, Load(addr=stack_base-12,\nsize=4, endness=Iend_LE))) * Conv(32->128, Load(addr=stack_base-32, size=4,\nendness=Iend_LE))) |                                         ^\n/tmp/tmp9yd34_22/prisma_gradient.c:114:109: error: expected identifier\n  114 |                 xmm0 = ((t34 + Conv(32->128, Load(addr=stack_base-12,\nsize=4, endness=Iend_LE))) * Conv(32->128, Load(addr=stack_base-32, size=4,\nendness=Iend_LE))) | ^ /tmp/tmp9yd34_22/prisma_gradient.c:122:30: error:\nexpected expression 122 |                 *((int128_t *)&v1) = tmp_30; | ^\n/tmp/tmp9yd34_22/prisma_gradient.c:126:29: error: expected ')'\n  126 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a1 >>\n17) | v0 & 1) * 2; |                             ^\n/tmp/tmp9yd34_22/prisma_gradient.c:126:26: note: to match this '('\n  126 |                     v0 = (0 CONCAT (unsigned int)((unsigned int)a1 >>\n17) | v0 & 1) * 2; |                          ^ fatal error: too many errors\nemitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"static int main_ea_cycles(void) {\n    int l;\n    if (main_size == 4)\n        l = 4;\n    else\n        l = 0;\n    switch (main_eamode) {\n      case aind:\n        return (l + 4);\n      case ainc:\n        return (l + 4);\n      case adec:\n        return (l + 6);\n      case adsp:\n        return (l + 8);\n      case axdp:\n        return (l + 10);\n      case absw:\n        return (l + 8);\n      case absl:\n        return (l + 12);\n      case pcdp:\n        return (l + 8);\n      case pcxd:\n        return (l + 10);\n      case immd:\n        return (l + 4);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int main_eamode;\nextern unsigned int main_size;\n\nlong long main_ea_cycles_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  if (main_size != 4)\n    v0 = 0;\n  else\n    v0 = 4;\n  switch (main_eamode) {\n  case 2:\n    return v0 + 4;\n  case 3:\n    return v0 + 4;\n  case 4:\n    return v0 + 6;\n  case 5:\n    return v0 + 8;\n  case 6:\n    return v0 + 10;\n  case 7:\n    return v0 + 8;\n  case 8:\n    return v0 + 12;\n  case 9:\n    return v0 + 8;\n  case 10:\n    return v0 + 10;\n  case 11:\n    return v0 + 4;\n  default:\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static int main_ea_cycles_nofetch(void) {\n    switch (main_eamode) {\n      case aind:\n        return (2);\n      case ainc:\n        return (4);\n      case adec:\n        return (4);\n      case adsp:\n        return (4);\n      case axdp:\n        return (8);\n      case absw:\n        return (4);\n      case absl:\n        return (8);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int main_eamode;\n\nlong long main_ea_cycles_nofetch_name_conflict() {\n  switch (main_eamode) {\n  case 2:\n    return 2;\n  case 3:\n    return 4;\n  case 4:\n    return 4;\n  case 5:\n    return 4;\n  case 6:\n    return 8;\n  case 7:\n    return 4;\n  case 8:\n    return 8;\n  default:\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"static int test(int n, int m, int op) {\n    int t;\n    if ((n & m) != op)\n        return 0;\n    for (t = op & 61440; t < n; t++) {\n        if ((!unique[t]) && ((t & m) == (n & m))) {\n            rproc[n] = t;\n            return 2;\n        }\n    }\n    unique[n] = (m >> 16) & 1;\n    rproc[n] = n;\n    t = (m ^ 65535) & 4095;\n    if (!t) {\n        emit(\"; Opcode %04X\\n\", n);\n    } else {\n        emit(\"; Opcodes %04X - %04X\\n\", n, op + t);\n    }\n    emit(\"%c%03X:\\n\", ((n >> 12) & 15) + 'K', n & 4095);\n    routine_counter++;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(emit)(...);\n\nextern unsigned int routine_counter;\nextern char rproc;\nextern char unique;\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = a0;\n  if ((unsigned int)a2 != ((unsigned int)a0 & (unsigned int)a1))\n    return 0;\n  for (v1 = (unsigned int)a2 & 0xf000; v1 < (unsigned int)a0; v1 += 1) {\n    if (!*(&(&unique)[v1]) && !((v1 ^ (unsigned int)a0) & (unsigned int)a1)) {\n      *((unsigned int *)&(&rproc)[4 * (unsigned int)a0]) = v1;\n      return 2;\n    }\n  }\n  *(&(&unique)[a0]) = (unsigned int)((unsigned int)a1 >> 16) & 1;\n  *((unsigned int *)&(&rproc)[4 * (unsigned int)a0]) = a0;\n  v1 = ((unsigned int)a1 ^ 65535) & 4095;\n  if (v1)\n    emit();\n  else\n    emit();\n  emit();\n  routine_counter = routine_counter + 1;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp50rqcr9/test_name_conflict.c:16:18: error: ISO C requires a named parameter before\n'...' 16 | long long (emit)(...); |                  ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"static char *getparameter(int *ip, int argc, char **argv) {\n    int i;\n    (*ip)++;\n    i = (*ip);\n    if (i >= argc) {\n        fprintf(stderr, \"Invalid use of %s option\\n\", argv[i - 1]);\n        return ((void *)0);\n    }\n    return argv[i];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long getparameter(unsigned int *a0, unsigned long a1,\n                       unsigned long long *a2) {\n  unsigned int v0; // [bp-0xc]\n\n  *(a0) = *(a0) + 1;\n  v0 = *(a0);\n  if (v0 < (unsigned int)a1)\n    return a2[v0];\n  fprintf(stderr @GLIBC_2.2.5, \"Invalid use of %s option\\n\",\n          (unsigned int)a2[1 + v0]);\n  return 0;\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf8wqeggh/getparameter.c:17:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpf8wqeggh/getparameter.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpf8wqeggh/getparameter.c:27:19: error: expected ')'\n   27 |     fprintf(stderr@GLIBC_2.2.5, \"Invalid use of %s option\\n\", (unsigned\nint)a2[1 + v0]); |                   ^ /tmp/tmpf8wqeggh/getparameter.c:27:12:\nnote: to match this '(' 27 |     fprintf(stderr@GLIBC_2.2.5, \"Invalid use of %s\noption\\n\", (unsigned int)a2[1 + v0]); |            ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"int set_interface_attribs(int fd, int speed, int parity) {\n    struct termios tty;\n    memset(&tty, 0, sizeof tty);\n    if (tcgetattr(fd, &tty) != 0) {\n        printf(\"error %d from tcgetattr\", (*__errno_location()));\n        return -1;\n    }\n    cfsetospeed(&tty, speed);\n    cfsetispeed(&tty, speed);\n    tty.c_cflag = (tty.c_cflag & ~48) | 48;\n    tty.c_iflag &= ~1;\n    tty.c_lflag = 0;\n    tty.c_oflag = 0;\n    tty.c_cc[6] = 0;\n    tty.c_cc[5] = 5;\n    tty.c_iflag &= ~(1024 | 4096 | 2048);\n    tty.c_cflag |= (2048 | 128);\n    tty.c_cflag &= ~(256 | 512);\n    tty.c_cflag |= parity;\n    tty.c_cflag &= ~64;\n    tty.c_cflag &= ~2147483648U;\n    if (tcsetattr(fd, 0, &tty) != 0) {\n        printf(\"error %d from tcsetattr\", (*__errno_location()));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(cfsetospeed)(\n    struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *,\n    unsigned int);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\nlong long set_interface_attribs(unsigned long a0, unsigned long a1,\n                                unsigned long a2) {\n  unsigned int v0;        // [bp-0x48], Other Possible Types: char\n  int tmp_89;             // tmp #89\n  int tmp_110;            // tmp #110\n  int tmp_114;            // tmp #114\n  unsigned int v1;        // [bp-0x44]\n  unsigned int v2;        // [bp-0x40], Other Possible Types: char\n  unsigned int v3;        // [bp-0x3c]\n  char v4;                // [bp-0x32]\n  char v5;                // [bp-0x31]\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n\n  memset(&v0, 0, 60);\n  if (tcgetattr(a0, &v0)) {\n    printf(\"error %d from tcgetattr\", *(__errno_location()));\n    return 4294967295;\n  }\n  cfsetospeed(&v0, a1);\n  cfsetispeed(&v0, a1);\n  v2 = *((int *)&v2) | 48;\n  v0 = *((int *)&v0) & -2;\n  v3 = 0;\n  v1 = 0;\n  v5 = 0;\n  v4 = 5;\n  v9 = v0;\n  *((char *)&v9) = (char)v9 & 227;\n  tmp_89 = v9;\n  v0 = tmp_89;\n  v2 |= 2176;\n  v10 = v2;\n  *((char *)&v10) = (char)v10 & 252;\n  tmp_110 = v10;\n  v2 = tmp_110;\n  tmp_114 = v2;\n  v2 = tmp_114;\n  v2 &= -65;\n  v2 &= 2147483647;\n  if (!tcsetattr(a0, 0, &v0))\n    return 0;\n  printf(\"error %d from tcsetattr\", *(__errno_location()));\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwfxygbro/set_interface_attribs.c:61:43: error: indirection requires\npointer operand ('int' invalid) 61 |         printf(\"error %d from tcgetattr\",\n*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwfxygbro/set_interface_attribs.c:87:39: error: indirection requires\npointer operand ('int' invalid) 87 |     printf(\"error %d from tcsetattr\",\n*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/abradner_homely/ard/tools/stdin-to-serial/serial.c"}
{"compilable":0,"function":"int extractLineNum(char *input) {\n    int n = strlen(input);\n    char *p = input + n - 1;\n    while (*p != ' ')\n        p--;\n    p++;\n    int lno = atoi(p);\n    *p = '\\x00';\n    return lno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(atoi)(char *);\n\nlong long extractLineNum_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x18]\n  unsigned int v1;       // [bp-0x14]\n  char *v2;              // [bp-0x10], Other Possible Types: unsigned long\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = strlen(a0);\n  for (v2 = &a0[1 + v1]; *((char *)v2) != 32; v2 -= 1)\n    ;\n  v2 += 1;\n  v0 = atoi(v2);\n  *(v2) = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/anantsubramanian_graphL-compiler/src/parsetree_generator.c"}
{"compilable":1,"function":"char rotate(char dir) {\n    return (dir + 2) % 12;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rotate_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx\n\n  v1 = ((char)a0 + 2) / 12;\n  return (char)a0 + 2 - ((unsigned int)v1 * 2 + v1) * 4;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char flip(char dir) {\n    return (12 - dir) % 12;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long flip_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx\n\n  v1 = (12 - (unsigned int)a0) / 12;\n  return 12 - (unsigned int)a0 - ((unsigned int)v1 * 2 + v1) * 4;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char shift(char cell, char dir) {\n    switch (dir) {\n      case 0:\n        return cell + 1;\n      case 1:\n        if ((cell / 5) % 2)\n            return cell + 7;\n        else\n            return cell + 6;\n      case 2:\n        if ((cell / 5) % 2)\n            return cell + 6;\n        else\n            return cell + 5;\n      case 3:\n        return cell + 10;\n      case 4:\n        if ((cell / 5) % 2)\n            return cell + 5;\n        else\n            return cell + 4;\n      case 5:\n        if ((cell / 5) % 2)\n            return cell + 4;\n        else\n            return cell + 3;\n      case 6:\n        return cell - 1;\n      case 7:\n        if ((cell / 5) % 2)\n            return cell - 6;\n        else\n            return cell - 7;\n      case 8:\n        if ((cell / 5) % 2)\n            return cell - 5;\n        else\n            return cell - 6;\n      case 9:\n        return cell - 10;\n      case 10:\n        if ((cell / 5) % 2)\n            return cell - 4;\n        else\n            return cell - 5;\n      case 11:\n        if ((cell / 5) % 2)\n            return cell - 3;\n        else\n            return cell - 4;\n      default:\n        return cell;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4206600];\n  unsigned int field_403008;\n} struct_0;\n\nextern char g_403008;\n\nlong long shift_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v3;  // eax\n  unsigned int v4;  // eax\n  unsigned int v5;  // eax\n  unsigned long v6; // rax\n  unsigned int v7;  // eax\n  unsigned int v8;  // eax\n  unsigned int v9;  // eax\n  unsigned int v10; // eax\n  unsigned int v11; // eax\n\n  switch ((unsigned int)(char)a1) {\n  case 0:\n    return (char)a0 + 1;\n  case 1:\n    v3 = 103;\n    *((unsigned short *)&v3) = 103 * (char)a0 >> 8;\n    *((char *)&v3) = 103 * (char)a0 >> 9;\n    v6 = (!(char)(v3 - (int)((char)a0 >> 7) & 1) ? (char)a0 + 7 : (char)a0 + 6);\n    return v6;\n  case 2:\n    v4 = 103;\n    *((unsigned short *)&v4) = 103 * (char)a0 >> 8;\n    *((char *)&v4) = 103 * (char)a0 >> 9;\n    v6 = (!(char)(v4 - (int)((char)a0 >> 7) & 1) ? (char)a0 + 6 : (char)a0 + 5);\n    return v6;\n  case 3:\n    return (char)a0 + 10;\n  case 4:\n    v5 = 103;\n    *((unsigned short *)&v5) = 103 * (char)a0 >> 8;\n    *((char *)&v5) = 103 * (char)a0 >> 9;\n    v6 = (!(char)(v5 - (int)((char)a0 >> 7) & 1) ? (char)a0 + 5 : (char)a0 + 4);\n    return v6;\n  case 5:\n    v7 = 103;\n    *((unsigned short *)&v7) = 103 * (char)a0 >> 8;\n    *((char *)&v7) = 103 * (char)a0 >> 9;\n    v6 = (!(char)(v7 - (int)((char)a0 >> 7) & 1) ? (char)a0 + 4 : (char)a0 + 3);\n    return v6;\n  case 6:\n    return (char)a0 - 1;\n  case 7:\n    v8 = 103;\n    *((unsigned short *)&v8) = 103 * (char)a0 >> 8;\n    *((char *)&v8) = 103 * (char)a0 >> 9;\n    v6 = (!(char)(v8 - (int)((char)a0 >> 7) & 1) ? (char)a0 - 6 : (char)a0 - 7);\n    return v6;\n  case 8:\n    v9 = 103;\n    *((unsigned short *)&v9) = 103 * (char)a0 >> 8;\n    *((char *)&v9) = 103 * (char)a0 >> 9;\n    v6 = (!(char)(v9 - (int)((char)a0 >> 7) & 1) ? (char)a0 - 5 : (char)a0 - 6);\n    return v6;\n  case 9:\n    return (char)a0 - 10;\n  case 10:\n    v10 = 103;\n    *((unsigned short *)&v10) = 103 * (char)a0 >> 8;\n    *((char *)&v10) = 103 * (char)a0 >> 9;\n    v6 =\n        (!(char)(v10 - (int)((char)a0 >> 7) & 1) ? (char)a0 - 4 : (char)a0 - 5);\n    return v6;\n  case 11:\n    v11 = 103;\n    *((unsigned short *)&v11) = 103 * (char)a0 >> 8;\n    *((char *)&v11) = 103 * (char)a0 >> 9;\n    v6 =\n        (!(char)(v11 - (int)((char)a0 >> 7) & 1) ? (char)a0 - 3 : (char)a0 - 4);\n    return v6;\n  default:\n    return (char)a0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char out_of_bounds(char cell, char dir) {\n    char i;\n    switch (dir) {\n      case 0:\n        return cell % 5 == 4;\n      case 1:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell >= 45;\n      case 2:\n        return cell % 10 == 9 || cell >= 45;\n      case 3:\n        return cell >= 40;\n      case 4:\n        return cell % 10 == 0 || cell >= 45;\n      case 5:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell >= 45;\n      case 6:\n        return cell % 5 == 0;\n      case 7:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell < 5;\n      case 8:\n        return cell % 10 == 0 || cell < 5;\n      case 9:\n        return cell < 10;\n      case 10:\n        return cell % 10 == 9 || cell < 5;\n      case 11:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell < 5;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4206648];\n  unsigned int field_403038;\n} struct_0;\n\nextern char g_403038;\n\nlong long out_of_bounds_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                // [bp-0x20]\n  char v1;                // [bp-0x9]\n  struct_0 *v3;           // rax\n  unsigned long v5;       // rax, Other Possible Types: unsigned long long\n  unsigned long v6;       // rdx\n  unsigned long long v7;  // rax\n  unsigned long long v8;  // rsi\n  unsigned int v10;       // eax\n  unsigned long v11;      // rsi\n  unsigned int v13;       // eax\n  unsigned long v14;      // rsi\n  unsigned int v16;       // eax\n  unsigned long v17;      // rsi\n  unsigned long v19;      // rax\n  unsigned int v20;       // eax\n  unsigned long v21;      // rsi\n  unsigned long v23;      // rdx\n  unsigned long long v24; // rax\n  unsigned long long v25; // rcx\n  unsigned int v27;       // eax\n  unsigned long v28;      // rsi\n  unsigned int v30;       // eax\n  unsigned long v31;      // rsi\n  unsigned long v33;      // rax\n  unsigned int v34;       // eax\n  unsigned long v35;      // rsi\n  unsigned int v37;       // eax\n  unsigned long v38;      // rsi\n\n  v0 = a1;\n  v3 = v0;\n  switch ((unsigned int)v3) {\n  case 0:\n    v6 = (char)a0;\n    v7 = 103;\n    *((unsigned short *)&v7) = 103 * (char)a0 >> 8;\n    *((char *)&v7) = 103 * (char)a0 >> 9;\n    v8 = v6;\n    *((char *)&v8) = (char)a0 >> 7;\n    v5 = 5 * (v7 - v8);\n    *((char *)&v5) = (char)(v6 - v5) == 4;\n    return v5;\n  case 1:\n    v10 = 103;\n    *((unsigned short *)&v10) = 103 * (char)a0 >> 8;\n    *((char *)&v10) = 103 * (char)a0 >> 10;\n    v11 = (char)a0;\n    *((char *)&v11) = (char)a0 >> 7;\n    v1 = (char)v11 - (char)(5 * (v10 - (unsigned int)v11) * 2);\n    if (!(v1 != 4 && v1 != 8 && v1 != 9 && (char)a0 <= 44))\n      return 1;\n    return 0;\n  case 2:\n    v13 = 103;\n    *((unsigned short *)&v13) = 103 * (char)a0 >> 8;\n    *((char *)&v13) = 103 * (char)a0 >> 10;\n    v14 = (char)a0;\n    *((char *)&v14) = (char)a0 >> 7;\n    if (!((char)v14 - (char)(5 * (v13 - (unsigned int)v14) * 2) != 9 &&\n          (char)a0 <= 44))\n      return 1;\n    return 0;\n  case 3:\n    *((char *)&v5) = (char)a0 > 39;\n    return v5;\n  case 4:\n    v16 = 103;\n    *((unsigned short *)&v16) = 103 * (char)a0 >> 8;\n    *((char *)&v16) = 103 * (char)a0 >> 10;\n    v17 = (char)a0;\n    *((char *)&v17) = (char)a0 >> 7;\n    v19 = 5 * (v16 - (unsigned int)v17) * 2;\n    if (!((char)(v17 - v19) && (char)a0 <= 44))\n      return 1;\n    return 0;\n  case 5:\n    v20 = 103;\n    *((unsigned short *)&v20) = 103 * (char)a0 >> 8;\n    *((char *)&v20) = 103 * (char)a0 >> 10;\n    v21 = (char)a0;\n    *((char *)&v21) = (char)a0 >> 7;\n    v1 = (char)v21 - (char)(5 * (v20 - (unsigned int)v21) * 2);\n    if (!(v1 && v1 != 1 && v1 != 5 && (char)a0 <= 44))\n      return 1;\n    return 0;\n  case 6:\n    v23 = (char)a0;\n    v24 = 103;\n    *((unsigned short *)&v24) = 103 * (char)a0 >> 8;\n    *((char *)&v24) = 103 * (char)a0 >> 9;\n    v25 = v23;\n    *((char *)&v25) = (char)a0 >> 7;\n    v5 = v23 - 5 * (v24 - v25);\n    *((char *)&v5) = !(char)v5;\n    return v5;\n  case 7:\n    v27 = 103;\n    *((unsigned short *)&v27) = 103 * (char)a0 >> 8;\n    *((char *)&v27) = 103 * (char)a0 >> 10;\n    v28 = (char)a0;\n    *((char *)&v28) = (char)a0 >> 7;\n    v1 = (char)v28 - (char)(5 * (v27 - (unsigned int)v28) * 2);\n    if (!(v1 && v1 != 1 && v1 != 5 && (char)a0 > 4))\n      return 1;\n    return 0;\n  case 8:\n    v30 = 103;\n    *((unsigned short *)&v30) = 103 * (char)a0 >> 8;\n    *((char *)&v30) = 103 * (char)a0 >> 10;\n    v31 = (char)a0;\n    *((char *)&v31) = (char)a0 >> 7;\n    v33 = 5 * (v30 - (unsigned int)v31) * 2;\n    if (!((char)(v31 - v33) && (char)a0 > 4))\n      return 1;\n    return 0;\n  case 9:\n    *((char *)&v5) = (char)a0 <= 9;\n    return v5;\n  case 10:\n    v34 = 103;\n    *((unsigned short *)&v34) = 103 * (char)a0 >> 8;\n    *((char *)&v34) = 103 * (char)a0 >> 10;\n    v35 = (char)a0;\n    *((char *)&v35) = (char)a0 >> 7;\n    if (!((char)v35 - (char)(5 * (v34 - (unsigned int)v35) * 2) != 9 &&\n          (char)a0 > 4))\n      return 1;\n    return 0;\n  case 11:\n    v37 = 103;\n    *((unsigned short *)&v37) = 103 * (char)a0 >> 8;\n    *((char *)&v37) = 103 * (char)a0 >> 10;\n    v38 = (char)a0;\n    *((char *)&v38) = (char)a0 >> 7;\n    v1 = (char)v38 - (char)(5 * (v37 - (unsigned int)v38) * 2);\n    if (!(v1 != 4 && v1 != 8 && v1 != 9 && (char)a0 > 4))\n      return 1;\n    return 0;\n  default:\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int cells_fit_on_board(char *cell, int piece) {\n    return (!out_of_bounds(cell[0], piece_def[piece][0]) && !out_of_bounds(cell[1], piece_def[piece][1]) && !out_of_bounds(cell[2], piece_def[piece][2]) && !out_of_bounds(cell[3], piece_def[piece][3]));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(out_of_bounds)(long long, long long);\n\nextern char g_405061[4];\nextern char g_405062[4];\nextern char g_405063[4];\nextern char piece_def[4];\n\nlong long cells_fit_on_board_name_conflict(char a0[4], unsigned long a1) {\n  if (!(char)out_of_bounds(a0[0], piece_def[4 * (unsigned int)a1]) &&\n      !(char)out_of_bounds(a0[1], g_405061[4 * (unsigned int)a1]) &&\n      !(char)out_of_bounds(a0[2], g_405062[4 * (unsigned int)a1]) &&\n      !(char)out_of_bounds(a0[3], g_405063[4 * (unsigned int)a1]))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char minimum_of_cells(char *cell) {\n    char minimum = cell[0];\n    minimum = cell[1] < minimum ? cell[1] : minimum;\n    minimum = cell[2] < minimum ? cell[2] : minimum;\n    minimum = cell[3] < minimum ? cell[3] : minimum;\n    minimum = cell[4] < minimum ? cell[4] : minimum;\n    return minimum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_of_cells_name_conflict(char a0[5]) {\n  char v0; // [bp-0x9]\n  char v2; // al\n  char v3; // al\n  char v4; // al\n  char v5; // al\n\n  v0 = a0[0];\n  v2 = a0[1];\n  if (v2 <= v2)\n    v2 = v0;\n  v0 = v2;\n  v3 = a0[2];\n  if (v3 <= v3)\n    v3 = v0;\n  v0 = v3;\n  v4 = a0[3];\n  if (v4 <= v4)\n    v4 = v0;\n  v0 = v4;\n  v5 = a0[4];\n  if (v5 <= v5)\n    v5 = v0;\n  v0 = v5;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char first_empty_cell(char *cell, char minimum) {\n    char first_empty = minimum;\n    while (first_empty == cell[0] || first_empty == cell[1] || first_empty == cell[2] || first_empty == cell[3] || first_empty == cell[4])\n        first_empty++;\n    return first_empty;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long first_empty_cell_name_conflict(char a0[5], unsigned long a1) {\n  char v0; // [bp-0x9]\n\n  for (v0 = a1;\n       v0 == a0[0] || v0 == a0[1] || v0 == a0[2] || v0 == a0[3] || v0 == a0[4];\n       v0 += 1)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"unsigned long long bitmask_from_cells(char *cell) {\n    unsigned long long piece_mask = 0ULL;\n    int i;\n    for (i = 0; i < 5; i++)\n        piece_mask |= 1ULL << cell[i];\n    return piece_mask;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long bitmask_from_cells_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = 0;\n  for (v0 = 0; v0 <= 4; v0 += 1) {\n    v1 |= 1 << (a0[v0] & 63);\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr5th68dy/bitmask_from_cells_name_conflict.c:25:12: error: invalid operands to binary\nexpression ('void *' and 'int') 25 |         v1 |= 1 << (a0[v0] & 63); | ~~ ^\n~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int has_island(char *cell, int piece) {\n    char temp_board[50];\n    char c;\n    int i;\n    for (i = 0; i < 50; i++)\n        temp_board[i] = 0;\n    for (i = 0; i < 5; i++)\n        temp_board[((int)cell[i])] = 1;\n    i = 49;\n    while (temp_board[i] == 1)\n        i--;\n    fill_contiguous_space(temp_board, i);\n    c = 0;\n    for (i = 0; i < 50; i++)\n        if (temp_board[i] == 0)\n            c++;\n    if (c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) || (c % 5 == 0 && piece == 0))\n        return 0;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fill_contiguous_space)(long long, long long);\n\nlong long has_island_name_conflict(char *a0, unsigned long a1) {\n  char v0;               // [bp-0x48]\n  unsigned int v1;       // [bp-0x10]\n  char v2;               // [bp-0x9]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  unsigned long long v6; // rdx\n  unsigned long long v7; // rax\n  unsigned long long v8; // rcx\n  unsigned long long v9; // rax\n\n  v5 = &v3;\n  for (v1 = 0; v1 <= 49; v1 += 1) {\n    (&v0)[v1] = 0;\n  }\n  for (v1 = 0; v1 <= 4; v1 += 1) {\n    (&v0)[a0[v1]] = 1;\n  }\n  for (v1 = 49; (&v0)[v1] == 1; v1 -= 1)\n    ;\n  fill_contiguous_space(&v0, v1);\n  v2 = 0;\n  for (v1 = 0; v1 <= 49; v1 += 1) {\n    if (!(&v0)[v1])\n      v2 += 1;\n  }\n  if (v2 && (v2 != 5 || (unsigned int)a1 != 8) &&\n      (v2 != 40 || (unsigned int)a1 != 8)) {\n    v6 = v2;\n    v7 = 103;\n    *((unsigned short *)&v7) = 103 * (char)v6 >> 8;\n    *((char *)&v7) = 103 * v2 >> 9;\n    v8 = v6;\n    *((char *)&v8) = (char)v8 >> 7;\n    v9 = v7 - v8;\n    if (!(!(char)(v6 - ((v9 << 2) + v9))) || !(!(unsigned int)a1))\n      return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"int rows_bad(char row1, char row2, int even) {\n    int i, in_zeroes, group_okay;\n    char block, row2_shift;\n    if (even)\n        row2_shift = ((row2 << 1) & 31) | 1;\n    else\n        row2_shift = (row2 >> 1) | 16;\n    block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);\n    in_zeroes = 0;\n    group_okay = 0;\n    for (i = 0; i < 5; i++) {\n        if (row1 & (1 << i)) {\n            if (in_zeroes) {\n                if (!group_okay)\n                    return 1;\n                in_zeroes = 0;\n                group_okay = 0;\n            }\n        } else {\n            if (!in_zeroes)\n                in_zeroes = 1;\n            if (!(block & (1 << i)))\n                group_okay = 1;\n        }\n    }\n    if (in_zeroes)\n        return !group_okay;\n    else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rows_bad_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x16]\n  char v1;         // [bp-0x15]\n  unsigned int v2; // [bp-0x14]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  if ((unsigned int)a2)\n    v1 = (char)a1 * 2 & 30 | 1;\n  else\n    v1 = (int)((char)a1 >> 1) | 16;\n  v0 = (char)~((char)a0) & (char)a1 & v1;\n  v3 = 0;\n  v2 = 0;\n  for (v4 = 0; v4 <= 4; v4 += 1) {\n    if (!((char)((char)a0 >> ((char)v4 & 31)) & 1)) {\n      if (!v3)\n        v3 = 1;\n      if (!((char)(v0 >> ((char)v4 & 31)) & 1))\n        v2 = 1;\n    } else if (v3) {\n      if (v2) {\n        v3 = 0;\n        v2 = 0;\n      } else {\n        return 1;\n      }\n    }\n  }\n  return (!v3 ? !v2 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int triple_is_okay(char row1, char row2, char row3, int even) {\n    if (even) {\n        return ((row1 == 3) && (row2 == 11) && ((row3 & 28) == 12)) || ((row1 == 1) && (row2 == 5) && (row3 == 6)) || ((row1 == 25) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    } else {\n        return ((row1 == 19) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long triple_is_okay(unsigned long a0, unsigned long a1, unsigned long a2,\n                         unsigned long a3) {\n  if ((unsigned int)a3) {\n    if (!(((char)a0 != 3 || (char)a1 != 11 || ((char)a2 & 28) != 12) &&\n          ((char)a0 != 1 || (char)a1 != 5 || (char)a2 != 6) &&\n          ((char)a0 != 25 || (char)a1 != 17) &&\n          (!((char)a0 == 21) || !((char)a1 == 17))))\n      return 1;\n    return 0;\n  } else {\n    if (!(((char)a0 != 19 || (char)a1 != 17) &&\n          (!((char)a0 == 21) || !((char)a1 == 17))))\n      return 1;\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int boardHasIslands(char cell) {\n    if (cell >= 40)\n        return 0;\n    int current_triple = (board >> ((cell / 5) * 5)) & 32767;\n    if ((cell / 5) % 2)\n        return bad_odd_triple[current_triple];\n    else\n        return bad_even_triple[current_triple];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char bad_even_triple;\nextern char bad_odd_triple;\nextern unsigned long long board;\n\nlong long boardHasIslands_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0xc]\n  unsigned long v2; // rax\n  unsigned int v3;  // eax\n\n  if ((char)a0 <= 39) {\n    v0 = (unsigned int)(board >>\n                        ((char)((103 * (char)a0 >> 9) - ((char)a0 >> 7)) * 5 &\n                         63)) &\n         32767;\n    v3 = 103;\n    *((unsigned short *)&v3) = 103 * (char)a0 >> 8;\n    *((char *)&v3) = 103 * (char)a0 >> 9;\n    v2 = (!(char)(v3 - (int)((char)a0 >> 7) & 1)\n              ? *((int *)&(&bad_odd_triple)[4 * v0])\n              : *((int *)&(&bad_even_triple)[4 * v0]));\n    return v2;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"static long fannkuch(int n) {\n    int *perm;\n    int *perm1;\n    int *count;\n    long flips;\n    long flipsMax;\n    int r;\n    int i;\n    int k;\n    int didpr;\n    const int n1 = n - 1;\n    if (n < 1)\n        return 0;\n    perm = calloc(n, sizeof (*perm));\n    perm1 = calloc(n, sizeof (*perm1));\n    count = calloc(n, sizeof (*count));\n    for (i = 0; i < n; ++i)\n        perm1[i] = i;\n    r = n;\n    didpr = 0;\n    flipsMax = 0;\n    for (;;) {\n        if (didpr < 30) {\n            for (i = 0; i < n; ++i)\n                printf(\"%d\", (int)(1 + perm1[i]));\n            printf(\"\\n\");\n            ++didpr;\n        }\n        for (; r != 1; --r) {\n            count[r - 1] = r;\n        }\n        if (!(perm1[0] == 0 || perm1[n1] == n1)) {\n            flips = 0;\n            for (i = 1; i < n; ++i) {\n                perm[i] = perm1[i];\n            }\n            k = perm1[0];\n            do {\n                int j;\n                for (i = 1 , j = k - 1; i < j; ++i , --j) {\n                    {\n                        int t_mp;\n                        t_mp = (perm[i]);\n                        (perm[i]) = (perm[j]);\n                        (perm[j]) = t_mp;\n                    }\n                }\n                ++flips;\n                j = perm[k];\n                perm[k] = k;\n                k = j;\n            } while (k);\n            if (flipsMax < flips) {\n                flipsMax = flips;\n            }\n        }\n        for (;;) {\n            if (r == n) {\n                return flipsMax;\n            }\n            {\n                int perm0 = perm1[0];\n                i = 0;\n                while (i < r)\n                    {\n                        k = i + 1;\n                        perm1[i] = perm1[k];\n                        i = k;\n                    }\n                perm1[r] = perm0;\n            }\n            if ((count[r] -= 1) > 0) {\n                break;\n            }\n            ++r;\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(putchar)(int);\n\nlong long fannkuch_name_conflict(unsigned long a0) {\n  unsigned int v0;        // [bp-0x50]\n  unsigned int v1;        // [bp-0x4c]\n  unsigned int *v2;       // [bp-0x48]\n  unsigned int *v3;       // [bp-0x40]\n  unsigned int *v4;       // [bp-0x38]\n  unsigned int v5;        // [bp-0x30]\n  unsigned int v6;        // [bp-0x2c]\n  unsigned int v7;        // [bp-0x28]\n  unsigned int v8;        // [bp-0x24]\n  unsigned int v9;        // [bp-0x20]\n  unsigned int v10;       // [bp-0x1c]\n  void *v11;              // [bp-0x18], Other Possible Types: unsigned long\n  void *v12;              // [bp-0x10], Other Possible Types: unsigned long\n  char v13;               // [bp-0x8]\n  unsigned long long v15; // rbp\n  unsigned int *v17;      // rax\n\n  v15 = &v13;\n  v5 = (unsigned int)a0 - 1;\n  if ((unsigned int)a0 <= 0)\n    return 0;\n  v4 = calloc((unsigned int)a0, 4);\n  v3 = calloc((unsigned int)a0, 4);\n  v2 = calloc((unsigned int)a0, 4);\n  for (v9 = 0; v9 < (unsigned int)a0; v9 += 1) {\n    v3[v9] = v9;\n  }\n  v10 = a0;\n  v7 = 0;\n  v11 = 0;\n  while (true) {\n    if (v7 <= 29) {\n      for (v9 = 0; v9 < (unsigned int)a0; v9 += 1) {\n        printf(\"%d\", v3[v9] + 1);\n      }\n      putchar(10);\n      v7 += 1;\n    }\n    for (; v10 != 1; v10 -= 1) {\n      v2[1 + v10] = v10;\n    }\n    if (*(v3) && v5 != v3[v5]) {\n      v12 = 0;\n      for (v9 = 1; v9 < (unsigned int)a0; v9 += 1) {\n        v4[v9] = v3[v9];\n      }\n      v8 = *(v3);\n      do {\n        v9 = 1;\n        for (v6 = v8 - 1; v9 < v6; v6 -= 1) {\n          v1 = v4[v9];\n          v4[v9] = v4[v6];\n          v4[v6] = v1;\n          v9 += 1;\n        }\n        v12 += 1;\n        v6 = v4[v8];\n        v4[v8] = v8;\n        v8 = v6;\n      } while (v8);\n      if (v11 < v12)\n        v11 = v12;\n    }\n    while (true) {\n      if (v10 == (unsigned int)a0)\n        return v11;\n      v0 = *(v3);\n      for (v9 = 0; v9 < v10; v9 = v8) {\n        v8 = v9 + 1;\n        v3[v9] = v3[v8];\n      }\n      v3[v10] = v0;\n      v17 = &v2[v10];\n      *(v17) = v2[v10] - 1;\n      if (*(v17) > 0)\n        break;\n      v10 += 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/fannkuch.c"}
{"compilable":0,"function":"int errex(char *s, int n) {\n    fprintf(stderr, \"\\n*** Error: %s [%d]!\\n\", s, n);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long errex_name_conflict(unsigned long a0, unsigned long a1) {\n  fprintf(stderr @GLIBC_2.2.5, \"\\n*** Error: %s [%d]!\\n\", (unsigned int)a0,\n          (unsigned int)a1);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7y7yw3fv/errex_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp7y7yw3fv/errex_name_conflict.c:17:22: error: expected ';' after top level declarator\n   17 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp7y7yw3fv/errex_name_conflict.c:21:19: error: expected ')'\n   21 |     fprintf(stderr@GLIBC_2.2.5, \"\\n*** Error: %s [%d]!\\n\", (unsigned\nint)a0, (unsigned int)a1); |                   ^ /tmp/tmp7y7yw3fv/errex_name_conflict.c:21:12:\nnote: to match this '(' 21 |     fprintf(stderr@GLIBC_2.2.5, \"\\n*** Error: %s\n[%d]!\\n\", (unsigned int)a0, (unsigned int)a1); |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/reverse-complement.c"}
{"compilable":0,"function":"treeNode *NewTreeNode(treeNode *left, treeNode *right, long item) {\n    treeNode *new;\n    new = (treeNode *)malloc(sizeof(treeNode));\n    new->left = left;\n    new->right = right;\n    new->item = item;\n    return new;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long NewTreeNode_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v0[3]; // [bp-0x10]\n\n  v0[0] = malloc(24);\n  v0[0] = a0;\n  v0[1] = a1;\n  v0[2] = a2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":1,"function":"long ItemCheck(treeNode *tree) {\n    if (tree->left == ((void *)0))\n        return tree->item;\n    else\n        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ItemCheck_name_conflict)(unsigned long long[3]);\n\nlong long ItemCheck_name_conflict(unsigned long long a0[3]) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v2; // rbx\n  unsigned long v3; // rax\n\n  v0 = v2;\n  if (!a0[0])\n    return a0[2];\n  v3 = a0[2] + ItemCheck_name_conflict(a0[0]) - ItemCheck_name_conflict(a0[1]);\n  return v3;\n}\n","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"treeNode *BottomUpTree(long item, unsigned int depth) {\n    if (depth > 0)\n        return NewTreeNode(BottomUpTree(2 * item - 1, depth - 1), BottomUpTree(2 * item, depth - 1), item);\n    else\n        return NewTreeNode(((void *)0), ((void *)0), item);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(NewTreeNode)(long long, long long, long long);\nlong long(BottomUpTree_name_conflict)(unsigned long long, unsigned long);\n\nlong long BottomUpTree_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v2; // rbx\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v0 = v2;\n  if (!(unsigned int)a1) {\n    v3 = NewTreeNode(0, 0, a0);\n    return v3;\n  }\n  v3 = NewTreeNode(BottomUpTree_name_conflict(a0 * 2 - 1, (unsigned int)a1 - 1),\n                   BottomUpTree_name_conflict(a0 * 2, (unsigned int)a1 - 1), a0);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(HTTPClientWriteData)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long HTTPSendFile_name_conflict(unsigned long long a0, char *a1) {\n  FILE_t *v0;      // [bp-0x20]\n  void *v1;        // [bp-0x18]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = 0;\n  v2 = 0;\n  v1 = malloc(0x10000);\n  v0 = &fopen(a1, \"rb\")->_flags;\n  if (!v0) {\n    v3 = 1;\n    return v3;\n  }\n  do {\n    v2 = fread(v1, 1, 0x10000, v0);\n  } while (v2 && (v3 = (unsigned int)(int)HTTPClientWriteData(\n                      a0, v1, (unsigned long long)v2, 5),\n                  !v3));\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpz2jcvwoo/HTTPSendFile_name_conflict.c:175:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 175 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/R:\", 3) == 0) {\n            strcpy(pClientParams->ProxyHost, argv[nArg] + 3);\n            pClientParams->UseProxy = 1;\n            pSearchPtr = strstr(pClientParams->ProxyHost, \":\");\n            if (pSearchPtr) {\n                PortNum[0] = 0;\n                nResult = (int)(pSearchPtr - pClientParams->ProxyHost);\n                strcpy(PortNum, pClientParams->ProxyHost + nResult + 1);\n                pClientParams->ProxyHost[nResult] = 0;\n                pClientParams->ProxyPort = atol(PortNum);\n            } else {\n                pClientParams->ProxyPort = 8080;\n            }\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/C:\", 3) == 0) {\n            strcpy(pClientParams->UserName, argv[nArg] + 3);\n            pSearchPtr = strstr(pClientParams->UserName, \":\");\n            if (!pSearchPtr) {\n                HTTPDumpHelp(\"Error: /C argument must be in the form of user:password\");\n                return -1;\n            }\n            nResult = (int)(pSearchPtr - pClientParams->UserName);\n            strcpy(pClientParams->Password, pClientParams->UserName + nResult + 1);\n            pClientParams->UserName[nResult] = 0;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/A:\", 3) == 0) {\n            pSearchPtr = argv[nArg] + 3;\n            if (*pSearchPtr == 'b' || *pSearchPtr == 'B') {\n                pClientParams->AuthType = AuthSchemaBasic;\n                continue;\n            }\n            if (*pSearchPtr == 'd' || *pSearchPtr == 'D') {\n                pClientParams->AuthType = AuthSchemaDigest;\n                continue;\n            }\n            if (pClientParams->AuthType == AuthSchemaNone) {\n                HTTPDumpHelp(\"Error: /A argument must be 'b' (for basic) or 'd' (for digest)\");\n                return -1;\n            }\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0) {\n        HTTPDumpHelp(\"Error: /H argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPDumpHelp)(long long);\nlong(atol)(char *);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[2047];\n  unsigned int field_800;\n  unsigned int field_804;\n  unsigned int field_808;\n  char padding_80c[128];\n  unsigned int field_88c;\n} struct_0;\n\nlong long HTTPParseCommandLineArgs_name_conflict(unsigned long a0, char **a1, struct_0 *a2) {\n  char v0;         // [bp-0x68]\n  unsigned int v1; // [bp-0x1c]\n  char *v2;        // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  v2 = 0;\n  if ((unsigned int)a0 <= 1) {\n    HTTPDumpHelp(\"Error: did not get key parameters.\");\n    return 4294967295;\n  }\n  for (v3 = 1; true; v3 += 1) {\n    if (v3 < (unsigned int)a0) {\n      if (!strncasecmp(a1[v3], \"/?\", 2)) {\n        HTTPDumpHelp(0);\n        return 4294967295;\n      } else if (!strncasecmp(a1[v3], \"/V\", 2)) {\n        a2->field_808 = 1;\n      } else if (!strncasecmp(a1[v3], \"/H:\", 3)) {\n        strcpy(a2, a1[v3] + 3);\n      } else if (!strncasecmp(a1[v3], \"/R:\", 3)) {\n        strcpy(&a2->padding_1[1023], a1[v3] + 3);\n        a2->field_800 = 1;\n        v2 = strchr(&a2->padding_1[1023], 58);\n        if (v2) {\n          v0 = 0;\n          v1 = (unsigned int)v2 - ((unsigned int)a2 + 0x400);\n          strcpy(&v0, &a2->padding_1[1023 + 1 + v1]);\n          a2->padding_1[1023 + v1] = 0;\n          a2->field_804 = atol(&v0);\n        } else {\n          a2->field_804 = 8080;\n        }\n      } else if (!strncasecmp(a1[v3], \"/C:\", 3)) {\n        strcpy(&a2->padding_80c, a1[v3] + 3);\n        v2 = strchr(&a2->padding_80c, 58);\n        if (!v2) {\n          HTTPDumpHelp(\n              \"Error: /C argument must be in the form of user:password\");\n          return 4294967295;\n        }\n        v1 = (unsigned int)v2 - ((unsigned int)a2 + 2060);\n        strcpy(&a2->padding_80c[64], &a2->padding_80c[1 + v1]);\n        a2->padding_80c[v1] = 0;\n      } else {\n        if (!strncasecmp(a1[v3], \"/A:\", 3)) {\n          v2 = a1[v3] + 3;\n          if (!(*(v2) != 98) || !(*(v2) != 66)) {\n            a2->field_88c = 1;\n            continue;\n          } else if (!(*(v2) != 100) || !(*(v2) != 68)) {\n            a2->field_88c = 2;\n            continue;\n          } else if (!a2->field_88c) {\n            HTTPDumpHelp(\"Error: /A argument must be 'b' (for basic) or 'd' \"\n                         \"(for digest)\");\n            return 4294967295;\n          }\n        }\n        if (!strncasecmp(a1[v3], \"/D:\", 3)) {\n          strcpy(a2 + 1, a1[v3] + 3);\n        } else if (!strncasecmp(a1[v3], \"/F:\", 3)) {\n          strcpy(&a2[1].padding_1[1023], a1[v3] + 3);\n        }\n      }\n    } else {\n      if (a2->field_0)\n        return 0;\n      HTTPDumpHelp(\"Error: /H argument is missing\");\n      return 4294967295;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrInsensitiveCompare_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x3c]\n  unsigned int v1; // [bp-0x28]\n  char v2;         // [bp-0x22]\n  char v3;         // [bp-0x21]\n  char *v4;        // [bp-0x20], Other Possible Types: unsigned long\n  char *v5;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v6; // [bp-0xc]\n\n  v0 = a2;\n  v5 = a0;\n  v4 = a1;\n  v6 = 0;\n  v1 = strlen(a1);\n  if (!v0)\n    v0 = strlen(a0);\n  if (v1 != v0)\n    return 0;\n  while (true) {\n    if (!v5 && !v4)\n      return 1;\n    if (v0 && v6 == v0)\n      return 1;\n    v3 = *((char *)v5);\n    v2 = *((char *)v4);\n    if (*((char *)v5) > 63 && *((char *)v5) <= 90)\n      v3 = *((char *)v5) + 32;\n    if (*((char *)v4) > 63 && *((char *)v4) <= 90)\n      v2 = *((char *)v4) + 32;\n    if (v3 != v2)\n      return 0;\n    v5 += 1;\n    v4 += 1;\n    v6 += 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrExtract_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0; // [bp-0x9]\n\n  if (!a0) {\n    return 0;\n  } else if ((char)a2) {\n    a0[(unsigned int)a1] = a2;\n    return (char)a2;\n  } else {\n    v0 = a0[(unsigned int)a1];\n    a0[(unsigned int)a1] = 0;\n    return v0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(toupper)(int);\nint(tolower)(int);\n\nlong long HTTPStrCaseStr_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char *v0;         // [bp-0x30], Other Possible Types: unsigned long\n  unsigned long v1; // [bp-0x20]\n  unsigned int v2;  // [bp-0x14]\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v3 = v0;\n  v2 = 0;\n  while (true) {\n    if (v2 >= (unsigned int)a1) {\n      break;\n    } else {\n      v3 = strchr(v0, toupper(*(a2)));\n      v1 = strchr(v0, tolower(*(a2)));\n      if (!v3)\n        v3 = v1;\n      if (!v3)\n        break;\n      if (v1 && v1 < v3)\n        v3 = v1;\n      if (!strncasecmp(v3, a2, strlen(a2)))\n        return v3;\n      v0 = v3 + 1;\n      v2 += 1;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrGetToken(char *a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  char *v0;         // [bp-0x40]\n  char *v1;         // [bp-0x20]\n  unsigned int v2;  // [bp-0x18]\n  unsigned int v3;  // [bp-0x14]\n  char *v4;         // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long v7; // rax\n\n  v0 = a2;\n  v1 = a0;\n  v3 = 0;\n  v2 = 0;\n  v1 = strchr(a0, 58) + 1;\n  if (!v1)\n    return v0;\n  for (v4 = v1; *(v4) && *(v4) != 13 && *(v4) != 10; v2 += 1) {\n    if (*(v4) != 32)\n      v3 += 1;\n    if (!(!(unsigned int)a1) && !((unsigned int)a1 >= v2))\n      break;\n    v4 += 1;\n  }\n  if (*(a3) < v3) {\n    *(a3) = v3;\n    v0 = 0;\n    return v0;\n  }\n  v4 = v1;\n  *(a3) = v3;\n  for (v3 = 0; *(v4) && *(v4) != 13 && *(v4) != 10; v4 += 1) {\n    if (*(v4) != 32) {\n      v7 = v3;\n      v3 = (unsigned int)v7 + 1;\n      v0[v7] = *((char *)v4);\n    }\n  }\n  v0[v3] = 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(toupper)(int);\n\nlong long HTTPStrHToL_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x18]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned int v8;       // eax\n  unsigned int v10;      // eax\n  unsigned int v11;      // eax\n  char *v12;             // rax\n\n  v6 = &v4;\n  v2 = 0;\n  v3 = v2;\n  v0 = v3;\n  while (true) {\n    v8 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v3] * 2)) & 8;\n    if (v8) {\n      a0[v3] = toupper(a0[v3]);\n      if (a0[v3] == 88) {\n        v0 = 0;\n        v2 = v0;\n      } else {\n        v10 =\n            *((short *)(*((long long *)&__ctype_b_loc()) + a0[v3] * 2)) & 0x400;\n        v11 = (!v10 ? a0[v3] - 55 : a0[v3] - 48);\n        v1 = v11;\n        if (v1 > 15)\n          v1 = 15;\n        v0 = v1 + v0 * 16;\n        if (v0)\n          v2 += 1;\n        if (v2 == 8)\n          return v0;\n      }\n    }\n    v3 += 1;\n    v12 = &a0[v3];\n    *(v12) = a0[v3];\n    if (!*(v12))\n      return v0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_nefmg9o/HTTPStrHToL_name_conflict.c:37:41: error: cannot take the address of an\nrvalue of type 'int' 37 |         v8 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v3] * 2)) & 8; | ^~~~~~~~~~~~~~~~\n/tmp/tmp_nefmg9o/HTTPStrHToL_name_conflict.c:48:50: error: cannot take the address of an\nrvalue of type 'int' 48 |                 v10 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v3] * 2)) & 0x400; | ^~~~~~~~~~~~~~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrLToH_name_conflict(char a0[2], unsigned long a1) {\n  char v0[2];      // [bp-0x20], Other Possible Types: unsigned long\n  char *v1;        // [bp-0x18]\n  unsigned int v2; // [bp-0xc]\n  char v4[2];      // rax\n\n  *(&v0) = a0;\n  v1 = \"0123456789abcdef\";\n  if (!(unsigned int)a1) {\n    v0[0] = 48;\n    v0[1] = 0;\n    return v0;\n  }\n  for (v2 = 28; !(unsigned int)((unsigned int)a1 >> ((char)v2 & 31)); v2 -= 4)\n    ;\n  for (; v2 >= 0; v2 -= 4) {\n    v4 = v0;\n    v0 = &v4[1];\n    v4[0] = v1[(unsigned int)((unsigned int)a1 >> ((char)v2 & 31)) & 15];\n  }\n  *((char *)v0) = 0;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4zozewy5/HTTPStrLToH_name_conflict.c:24:12: error: array type 'char[2]' is not\nassignable 24 |     *(&v0) = a0; |     ~~~~~~ ^\n/tmp/tmp4zozewy5/HTTPStrLToH_name_conflict.c:35:12: error: array type 'char[2]' is not\nassignable 35 |         v4 = v0; |         ~~ ^\n/tmp/tmp4zozewy5/HTTPStrLToH_name_conflict.c:36:12: error: array type 'char[2]' is not\nassignable 36 |         v0 = &v4[1]; |         ~~ ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperIsAscii_name_conflict(unsigned long a0) {\n  return (unsigned int)a0 <= 127;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\n\nlong long HTTPWrapperToUpper_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0 && (unsigned int)a0 > 96 &&\n      (unsigned int)a0 <= 122)\n    return (unsigned int)a0 - 32;\n  return (unsigned int)a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\n\nlong long HTTPWrapperToLower_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0 && (unsigned int)a0 > 64 &&\n      (unsigned int)a0 <= 90)\n    return (unsigned int)a0 + 32;\n  return (unsigned int)a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\n\nlong long HTTPWrapperIsAlpha_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0 &&\n      (!((unsigned int)a0 <= 96) && !((unsigned int)a0 > 122) ||\n       !((unsigned int)a0 <= 64) && !((unsigned int)a0 > 90)))\n    return (unsigned int)a0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\nlong long(HTTPWrapperIsAlpha)(long long);\n\nlong long HTTPWrapperIsAlNum_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0) {\n    if ((int)HTTPWrapperIsAlpha((unsigned int)a0) > 0) {\n      return (unsigned int)a0;\n    } else if ((unsigned int)a0 > 47 && (unsigned int)a0 <= 57) {\n      return (unsigned int)a0;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperItoa_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x24]\n  char *v1;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0xc]\n  char *v4;        // rax\n  unsigned int v5; // ecx\n  char v7;         // cl\n\n  v1 = a0;\n  v0 = a1;\n  if (v0 >= 0) {\n    v2 = v0;\n  } else {\n    v2 = -(v0);\n    v4 = v1;\n    v1 = v4 + 1;\n    *(v4) = 45;\n  }\n  for (; v0; v0 = (v0 * 1717986919 >> 34) - (v0 >> 31)) {\n    v1 += 1;\n  }\n  for (*((char *)v1) = 0; v2; v2 = v2 * 3435973837 >> 35) {\n    v5 = v2;\n    v7 = v5 - 5 * v5 / 10 * 2;\n    v1 -= 1;\n    *((char *)v1) = v7 + 48;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long HTTPWrapperShutDown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperGetSocketError_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return *(__errno_location());\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx0zapvyg/HTTPWrapperGetSocketError_name_conflict.c:22:12: error: indirection requires\npointer operand ('int' invalid) 22 |     return *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(atol)(char *);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_1 {\n  char padding_0[24];\n  struct struct_0 *field_18;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long HTTPWrapperGetHostByName_name_conflict(char *a0, unsigned int *a1) {\n  unsigned int v0;  // [bp-0x68], Other Possible Types: char\n  unsigned int v1;  // [bp-0x64]\n  unsigned int v2;  // [bp-0x60]\n  unsigned int v3;  // [bp-0x5c]\n  struct_1 *v4;     // [bp-0x38]\n  char v5;          // [bp-0x30]\n  unsigned int v6;  // [bp-0x2c]\n  unsigned long v7; // [bp-0x28]\n  unsigned int v8;  // [bp-0x20]\n  unsigned int v9;  // [bp-0x1c]\n  char v10;         // [bp-0x15]\n  unsigned int v11; // [bp-0x14]\n  unsigned int v12; // [bp-0x10]\n  unsigned int v13; // [bp-0xc]\n\n  v13 = 0;\n  v8 = 0;\n  v12 = 0;\n  v11 = 0;\n  v10 = 0;\n  v9 = 0;\n  v8 = strlen(a0);\n  for (v13 = 0;\n       v13 <= v8 && (v10 = a0[v13], v10 > 47 && v10 <= 57 || v10 == 46);\n       v13 += 1) {\n    if (v10 == 46) {\n      v12 = 0;\n      v11 += 1;\n      v7 = atol(&v5);\n      if (!(v7 <= 0x100) || !(v11 <= 3))\n        return 4294967295;\n    } else if (v12 <= 3) {\n      (&v5)[v12] = v10;\n      (&v5)[1 + v12] = 0;\n      v12 += 1;\n    } else {\n      v9 += 1;\n      break;\n    }\n  }\n  if (v10 || v9 || v11 != 3) {\n    v9 += 1;\n  } else {\n    v7 = atol(&v5);\n    if (v7 > 0x100)\n      return 4294967295;\n  }\n  if (v9 <= 0) {\n    *(a1) = inet_addr(a0);\n    return 0;\n  }\n  v4 = 0;\n  memset(&v0, 0, 48);\n  v1 = 2;\n  v2 = 1;\n  v0 = 0;\n  v3 = 0;\n  v6 = getaddrinfo(a0, 0, &v0, &v4);\n  if (!v6) {\n    *(a1) = v4->field_18->field_4;\n    freeaddrinfo(v4);\n    return 0;\n  }\n  fprintf(stderr @GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd3rqxyqe/HTTPWrapperGetHostByName_name_conflict.c:29:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 29 | extern FILE_t *stderr@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpd3rqxyqe/HTTPWrapperGetHostByName_name_conflict.c:29:22: error: expected ';' after top\nlevel declarator 29 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpd3rqxyqe/HTTPWrapperGetHostByName_name_conflict.c:105:19: error: expected ')'\n  105 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n      |                   ^\n/tmp/tmpd3rqxyqe/HTTPWrapperGetHostByName_name_conflict.c:105:12: note: to match this '('\n  105 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n      |            ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\ndouble HTTPWrapperGetRandomeNumber_name_conflict() {\n  int tmp_20;      // tmp #20\n  int tmp_22;      // tmp #22\n  int tmp_21;      // tmp #21\n  unsigned int v0; // [bp-0xc]\n  int v2;          // xmm1\n\n  rand();\n  tmp_20 = DivV(tmp_22, tmp_21);\n  v2 = tmp_20;\n  v0 = (unsigned int)((0 CONCAT 0x4030000000000000) * v2);\n  return (unsigned long long)((0 CONCAT 0x4030000000000000) * v2);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyzyh_ud1/HTTPWrapperGetRandomeNumber_name_conflict.c:29:28: error: expected ')'\n   29 |     v0 = (unsigned int)((0 CONCAT 0x4030000000000000) * v2);\n      |                            ^\n/tmp/tmpyzyh_ud1/HTTPWrapperGetRandomeNumber_name_conflict.c:29:25: note: to match this '('\n   29 |     v0 = (unsigned int)((0 CONCAT 0x4030000000000000) * v2);\n      |                         ^\n/tmp/tmpyzyh_ud1/HTTPWrapperGetRandomeNumber_name_conflict.c:30:36: error: expected ')'\n   30 |     return (unsigned long long)((0 CONCAT 0x4030000000000000) * v2);\n      |                                    ^\n/tmp/tmpyzyh_ud1/HTTPWrapperGetRandomeNumber_name_conflict.c:30:33: note: to match this '('\n   30 |     return (unsigned long long)((0 CONCAT 0x4030000000000000) * v2);\n      |                                 ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long HTTPWrapperGetUpTime_name_conflict() {\n  char v0; // [bp-0x18]\n\n  clock_gettime(0x1, &v0);\n  return *((long long *)&v0);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLConnect(unsigned long a0, unsigned long a1,\n                                unsigned long a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLNegotiate(unsigned long a0, unsigned long a1,\n                                  unsigned long a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLSend(unsigned long a0, unsigned long a1,\n                             unsigned long a2, unsigned long a3) {\n  unsigned int v0;  // [bp-0x1c]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecv(unsigned long a0, unsigned long a1,\n                             unsigned long a2, unsigned long a3) {\n  unsigned int v0;  // [bp-0x1c]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecvPending_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLClose_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long sktSetNonblocking_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;          // [bp-0x1c]\n  unsigned int v1;  // [bp-0x10]\n  unsigned int v2;  // [bp-0xc]\n  unsigned long v5; // rax, Other Possible Types: unsigned long long\n\n  v1 = fcntl(a0, 3);\n  if (v1 < 0)\n    return 4294967295;\n  if ((unsigned int)a1)\n    v5 = v1;\n  else\n    v5 = v1;\n  v2 = v5;\n  if (fcntl(*((int *)&v0), 4) < 0) {\n    fcntl(*((int *)&v0), 4);\n    return 4294967295;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetLocalConnection_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned long v1; // [bp-0x10]\n\n  v1 = a0;\n  v0 = a1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPClientSetVerb)(long long, long long);\n\ntypedef struct struct_1 {\n  char padding_0[64];\n  unsigned short field_40;\n  char padding_42[518];\n  unsigned long long field_248;\n  unsigned int field_250;\n  char padding_254[4];\n  unsigned long long field_258;\n  char padding_260[1104];\n  unsigned int field_6b0;\n  char padding_6b4[620];\n  unsigned int field_920;\n  char padding_924[48];\n  unsigned int field_954;\n  unsigned int field_958;\n  char padding_95c[532];\n  unsigned short field_b70;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[64];\n  unsigned short field_40;\n  char padding_42[518];\n  void *field_248;\n  unsigned int field_250;\n  char padding_254[4];\n  unsigned long long field_258;\n  char padding_260[1104];\n  unsigned int field_6b0;\n  char padding_6b4[620];\n  unsigned int field_920;\n  char padding_924[48];\n  unsigned int field_954;\n  unsigned int field_958;\n  char padding_95c[532];\n  unsigned short field_b70;\n} struct_0;\n\nlong long HTTPClientOpenRequest_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_0 *v1;    // [bp-0x10], Other Possible Types: struct_1 *\n\n  v1 = 0;\n  v1 = malloc(2936);\n  if (!v1)\n    return 0;\n  memset(v1, 0, 2936);\n  v0 = 0x800;\n  v1->field_248 = malloc((!(v0 & 3) ? 4 : 0) + (v0 & -0x4));\n  if (!v1->field_248) {\n    free(v1);\n    return 0;\n  }\n  memset(v1->field_248, 0, v0);\n  v1->field_250 = v0;\n  HTTPClientSetVerb(v1, 0);\n  v1->field_40 = 80;\n  v1->field_920 = -1;\n  v1->field_258 = v1->field_248;\n  v1->field_954 = 1;\n  v1->field_958 = a0;\n  v1->field_6b0 = 0;\n  v1->field_b70 = 80;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnSessionReset)(long long, long long);\n\nlong long HTTPClientReset_name_conflict(unsigned long a0) {\n  void *v0; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = 0;\n  v0 = a0;\n  if (v0)\n    return HTTPIntrnSessionReset(v0, 1);\n  return 2;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnConnectionClose)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[584];\n  unsigned long long field_248;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[584];\n  void *field_248;\n} struct_1;\n\nlong long HTTPClientCloseRequest_name_conflict(struct struct_0 **a0) {\n  struct_1 *v0; // [bp-0x10], Other Possible Types: struct_0 *, void*\n\n  v0 = 0;\n  v0 = &*(a0)->padding_0;\n  if (!v0)\n    return 2;\n  if (v0->field_248)\n    free(v0->field_248);\n  HTTPIntrnConnectionClose(v0);\n  free(v0);\n  v0 = 0;\n  *(a0) = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp2k_9f0x/HTTPClientCloseRequest_name_conflict.c:33:16: error: member reference base\ntype 'struct struct_0 *' is not a structure or union 33 |     v0 =\n&*(a0)->padding_0; |            ~~~~^ ~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1724];\n  unsigned int field_6bc;\n} struct_0;\n\nlong long HTTPClientSetConnection_name_conflict(struct_0 *a0, unsigned long a1) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = 0;\n  v0 = a0;\n  if (!v0)\n    return 2;\n  v0->field_6bc = a1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetVerb_name_conflict(unsigned int a0[421], unsigned long a1) {\n  unsigned int v0[421];  // [bp-0x10]\n  unsigned long long v3; // rdx\n\n  *((long long *)&v0[0]) = 0;\n  *((unsigned int *[421]) & v0[0]) = a0;\n  if (!v0)\n    return 2;\n  v3 = a1;\n  v0[162] = a1;\n  if ((unsigned int)a1 == 3) {\n    v0[420] = 5526864;\n    return 0;\n  }\n  if ((unsigned int)a1 > 3)\n    return 18;\n  if ((unsigned int)a1 == 2) {\n    strcpy(&v0[420], \"POST\");\n    return 0;\n  } else if ((unsigned int)a1 <= 2) {\n    if (!(unsigned int)a1) {\n      v0[420] = 5522759;\n      return 0;\n    } else if ((unsigned int)a1 == 1) {\n      return 18;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjz6n25or/HTTPClientSetVerb_name_conflict.c:23:7: error: used type 'unsigned int\n*[421]' where arithmetic or pointer type is required 23 |     *((unsigned int\n*[421])&v0[0]) = a0; |       ^                    ~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[1872];\n  unsigned short field_750;\n  char padding_752[18];\n  unsigned int field_764;\n  char padding_768[496];\n  unsigned int field_958;\n} struct_0;\n\nlong long HTTPClientSetProxy(struct_0 *a0, char *a1, unsigned long a2, char *a3,\n                             char *a4) {\n  struct_0 *v0;          // [bp-0x10]\n  unsigned long long v3; // rax\n\n  v0 = 0;\n  v0 = a0;\n  if (!v0)\n    return 2;\n  strncpy(&v0->padding_0[1776], a1, 64);\n  if (a3)\n    strncpy(&v0->padding_0[1840], a3, 16);\n  if (a4)\n    strncpy(&v0->padding_0[1856], a4, 16);\n  v0->field_750 = a2;\n  v3 = v0->field_958;\n  *((char *)&v3) = (char)v3 | 128;\n  v0->field_958 = v3;\n  if (!(a4 && a3))\n    return 0;\n  v0->field_764 = 1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1732];\n  unsigned int field_6c4;\n} struct_0;\n\nlong long HTTPClientSetCredentials_name_conflict(struct_0 *a0, char *a1, char *a2) {\n  unsigned int v0; // [bp-0x14]\n  struct_0 *v1;    // [bp-0x10]\n\n  v1 = 0;\n  v1 = a0;\n  if (!v1)\n    return 2;\n  v0 = strlen(a1);\n  if (v0 > 16)\n    return 19;\n  v0 = strlen(a2);\n  if (v0 > 16)\n    return 19;\n  strcpy(&v1[1].padding_0[160], a1);\n  strcpy(&v1[1].padding_0[176], a2);\n  v1->field_6c4 = 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersAdd)(long long, long long, long long, long long,\n                               long long);\n\nlong long HTTPClientAddRequestHeaders(unsigned long a0, char *a1, char *a2,\n                                      unsigned long a3) {\n  unsigned int v0; // [bp-0x44]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0x18]\n  unsigned int v3; // [bp-0x14]\n  void *v4;        // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = a3;\n  v4 = 0;\n  v4 = a0;\n  if (!v4)\n    return 2;\n  v3 = strlen(a1);\n  v2 = strlen(a2);\n  v1 = HTTPIntrnHeadersAdd(v4, a1, v3, a2, v2);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersReceive)(long long, long long);\n\nlong long HTTPClientRecvResponse_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10], Other Possible Types: unsigned long long\n\n  v1 = 0;\n  v1 = a0;\n  if (!v1)\n    return 2;\n  v0 = HTTPIntrnHeadersReceive(v1, (unsigned int)a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientGetInfo_name_conflict(unsigned int a0[598], unsigned int a1[5]) {\n  unsigned int v0[598]; // [bp-0x10]\n\n  *((long long *)&v0[0]) = 0;\n  *((unsigned int *[598]) & v0[0]) = a0;\n  if (!v0)\n    return 2;\n  memset(a1, 0, 20);\n  a1[0] = v0[428];\n  a1[1] = v0[595];\n  a1[2] = v0[589];\n  a1[3] = v0[429];\n  a1[4] = v0[597];\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwek5hwat/HTTPClientGetInfo_name_conflict.c:22:7: error: used type 'unsigned int\n*[598]' where arithmetic or pointer type is required 22 |     *((unsigned int\n*[598])&v0[0]) = a0; |       ^                    ~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientFindFirstHeader(struct_0 *a0, char *a1, unsigned long a2,\n                                    unsigned long a3) {\n  unsigned long v0; // [bp-0x38]\n  unsigned long v1; // [bp-0x30]\n  unsigned int v2;  // [bp-0x14]\n  struct_0 *v3;     // [bp-0x10]\n\n  v1 = a2;\n  v0 = a3;\n  v3 = 0;\n  v3 = a0;\n  if (!v3)\n    return 2;\n  v2 = strlen(a1);\n  if (v2 > 1023)\n    return 13;\n  strcpy(&v3[1].padding_0[12], a1);\n  v3->field_280 = 0;\n  v3->field_278 = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n  char padding_284[12];\n  char field_290;\n} struct_0;\n\nlong long HTTPClientFindCloseHeader_name_conflict(struct_0 *a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = 0;\n  v0 = a0;\n  if (!v0)\n    return 2;\n  v0->field_290 = 0;\n  v0->field_280 = 0;\n  v0->field_278 = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersFind)(long long, long long, long long, long long,\n                                long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[616];\n  unsigned long long field_268;\n  char padding_270[8];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientGetNextHeader_name_conflict(struct_0 *a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x38]\n  char v1;         // [bp-0x30]\n  unsigned int v2; // [bp-0x24]\n  struct_0 *v3;    // [bp-0x20]\n  char *v4;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v5; // [bp-0xc]\n\n  v3 = 0;\n  v5 = 0;\n  v3 = a0;\n  if (!v3)\n    return 2;\n  if (v3->field_280)\n    v5 = v3->field_278 - v3->field_268;\n  v2 = HTTPIntrnHeadersFind(v3, &v3[1].padding_0[12], &v0, 1, v5);\n  if (v2) {\n    return v2;\n  } else if (*(a2) >= *((int *)&v1)) {\n    v4 = *((long long *)&v0);\n    v5 = 0;\n    if (*(v4) == 13) {\n      v5 += 1;\n      v4 += 1;\n    }\n    if (*((char *)v4) == 10) {\n      v5 += 1;\n      v4 += 1;\n    }\n    strncpy(a1, v4, *((int *)&v1) - v5);\n    a1[*((int *)&v1) + -1 * v5] = 0;\n    *(a2) = *((int *)&v1) - v5;\n    v3->field_278 = *((int *)&v1) + *((long long *)&v0);\n    v3->field_280 = v3->field_280 + 1;\n    return 0;\n  } else {\n    *(a2) = *((int *)&v1);\n    *(a1) = 0;\n    return 3;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperGetUpTime)();\n\nlong long HTTPIntrnSessionGetUpTime_name_conflict() { return HTTPWrapperGetUpTime(); }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char base64val;\n\nlong long HTTPBase64Decoder_name_conflict(char *a0, char a1[4]) {\n  char v0[4];      // [bp-0x48], Other Possible Types: unsigned long\n  char *v1;        // [bp-0x40], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0x2c]\n  char v5;         // r14b\n  char v6;         // r13b\n  char v7;         // bl\n  char v8;         // r12b\n  char v9;         // sil\n  char v10;        // cl\n  char *v11;       // rax\n  char v12;        // sil\n  char v13;        // cl\n  char *v14;       // rax\n  char v15;        // sil\n  char v16;        // cl\n  char *v17;       // rax\n\n  v1 = a0;\n  *(&v0) = a1;\n  v2 = 0;\n  if (v0[0] == 43 && v0[1] == 32)\n    v0 = &v0[2];\n  if (*((char *)v0) == 13)\n    return 0;\n  while (v5 >= 0 && *(&(&base64val)[v5]) != 255) {\n    v5 = *((char *)v0);\n    v6 = *((char *)(v0 + 1));\n    if (!(v6 >= 0) || !(*(&(&base64val)[v6]) != 255))\n      return 4294967295;\n    v7 = *((char *)(v0 + 2));\n    if (v7 != 61 && (!(v7 >= 0) || !(*(&(&base64val)[v7]) != 255)))\n      return 4294967295;\n    v8 = *((char *)(v0 + 3));\n    if (v8 != 61 && (!(v8 >= 0) || !(*(&(&base64val)[v8]) != 255)))\n      return 4294967295;\n    v0 += 4;\n    v9 = (v5 < 0 ? (unsigned int)(*(&(&base64val)[v5]) * 4) : -0x4);\n    v10 = (v6 < 0 ? (unsigned int)(*(&(&base64val)[v6]) >> 4) : -1);\n    v11 = v1;\n    v1 = v11 + 1;\n    *(v11) = v9 | v10;\n    v2 += 1;\n    if (v7 != 61) {\n      v12 = (v6 < 0 ? (unsigned int)(*(&(&base64val)[v6]) * 16) : -0x10);\n      v13 = (v7 < 0 ? (unsigned int)(*(&(&base64val)[v7]) >> 2) : -1);\n      v14 = v1;\n      v1 = v14 + 1;\n      *(v14) = v9 | v13;\n      v2 += 1;\n      if (v8 != 61) {\n        v15 = (v7 < 0 ? (unsigned int)(*(&(&base64val)[v7]) * 64) : -64);\n        v16 = (v8 < 0 ? *(&(&base64val)[v8]) : -1);\n        v17 = v1;\n        v1 = v17 + 1;\n        *(v17) = v9 | v16;\n        v2 += 1;\n      }\n    }\n    if (!(*((char *)v0)) || !(*((char *)v0) != 13) || !(v8 != 61))\n      return v2;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjuslma1c/HTTPBase64Decoder_name_conflict.c:39:12: error: array type 'char[4]' is not\nassignable 39 |     *(&v0) = a1; |     ~~~~~~ ^\n/tmp/tmpjuslma1c/HTTPBase64Decoder_name_conflict.c:42:12: error: array type 'char[4]' is not\nassignable 42 |         v0 = &v0[2]; |         ~~ ^\n/tmp/tmpjuslma1c/HTTPBase64Decoder_name_conflict.c:57:12: error: invalid operands to binary\nexpression ('char[4]' and 'int') 57 |         v0 += 4; |         ~~ ^  ~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(HTTPClientWriteData)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long HTTPSendFile_name_conflict(unsigned long long a0, char *a1) {\n  FILE_t *v0;      // [bp-0x20]\n  void *v1;        // [bp-0x18]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = 0;\n  v2 = 0;\n  v1 = malloc(0x10000);\n  v0 = &fopen(a1, \"rb\")->_flags;\n  if (!v0) {\n    v3 = 1;\n    return v3;\n  }\n  do {\n    v2 = fread(v1, 1, 0x10000, v0);\n  } while (v2 && (v3 = (unsigned int)(int)HTTPClientWriteData(\n                      a0, v1, (unsigned long long)v2, 5),\n                  !v3));\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpuvmnhorn/HTTPSendFile_name_conflict.c:175:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 175 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H2:\", 3) == 0) {\n            strcpy(pClientParams->Uri2, argv[nArg] + 4);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0 || strlen(pClientParams->Uri2) == 0) {\n        HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPDumpHelp)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[1023];\n  char field_400;\n  char padding_401[1023];\n  unsigned int field_800;\n} struct_0;\n\nlong long HTTPParseCommandLineArgs_name_conflict(unsigned long a0, char **a1, struct_0 *a2) {\n  void *v0;        // [bp-0x18]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  if ((unsigned int)a0 <= 1) {\n    HTTPDumpHelp(\"Error: did not get key parameters.\");\n    return 4294967295;\n  }\n  for (v1 = 1; v1 < (unsigned int)a0; v1 += 1) {\n    if (!strncasecmp(a1[v1], \"/?\", 2)) {\n      HTTPDumpHelp(0);\n      return 4294967295;\n    } else if (!strncasecmp(a1[v1], \"/V\", 2)) {\n      a2->field_800 = 1;\n    } else if (!strncasecmp(a1[v1], \"/H:\", 3)) {\n      strcpy(a2, a1[v1] + 3);\n    } else if (!strncasecmp(a1[v1], \"/H2:\", 3)) {\n      strcpy(&a2->field_400, a1[v1] + 4);\n    } else if (!strncasecmp(a1[v1], \"/D:\", 3)) {\n      strcpy(a2 + 1, a1[v1] + 3);\n    } else if (!strncasecmp(a1[v1], \"/F:\", 3)) {\n      strcpy(&a2[1].field_400, a1[v1] + 3);\n    }\n  }\n  if (a2->field_0 && a2->field_400)\n    return 0;\n  HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"int handle_http_request(HTTP_SESSION_HANDLE pHTTP, CHAR *uri, HTTPParameters *ClientParams) {\n    CHAR Buffer[8193];\n    INT32 nRetCode;\n    UINT32 nSize, nTotal = 0;\n    INT32 status_code;\n    HTTP_CLIENT HTTPClient;\n    do {\n        memset(&HTTPClient, 0, sizeof(HTTP_CLIENT));\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPost)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPut)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbGet)) != 0) {\n                break;\n            }\n        }\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ClientParams->PostData, strlen(ClientParams->PostData), 1, 5, 0)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            int ret;\n            struct stat stat_buf;\n            char file_size_str[32];\n            memset(&stat_buf, 0, sizeof(struct stat));\n            memset(file_size_str, 0, 32);\n            ret = stat(ClientParams->PutFilePath, &stat_buf);\n            if (ret) {\n                nRetCode = 19;\n                break;\n            }\n            HTTPWrapperItoa(file_size_str, (int)stat_buf.st_size);\n            if ((nRetCode = HTTPClientAddRequestHeaders(pHTTP, \"Content-Length\", file_size_str, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPSendFile(pHTTP, ClientParams->PutFilePath)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n        }\n        if ((nRetCode = HTTPClientRecvResponse(pHTTP, 3)) != 0) {\n            break;\n        }\n        if ((nRetCode = HTTPClientGetInfo(pHTTP, &HTTPClient)) != 0) {\n            break;\n        }\n        while (nRetCode == 0 || nRetCode != 1000)\n            {\n                if (nTotal >= HTTPClient.TotalResponseBodyLength) {\n                    break;\n                }\n                nSize = 8192;\n                nRetCode = HTTPClientReadData(pHTTP, Buffer, nSize, 5, &nSize);\n                nTotal += nSize;\n                Buffer[nSize] = 0;\n                printf(\"%s\", Buffer);\n            }\n    } while (0);\n    printf(\"\\n\");\n    if (ClientParams->Verbose == 1) {\n        printf(\"\\n\\nHTTP Client terminated %d (got %d bytes, status_code %d)\\n\\n\", (int)nRetCode, (int)(nTotal), HTTPClient.HTTPStatusCode);\n    }\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPClientSetVerb)(long long, long long);\nint(putchar)(int);\nlong long(HTTPClientSendRequest)(long long, long long, long long, long long,\n                                 long long, long long, int);\nlong long(HTTPClientRecvResponse)(long long, long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(HTTPClientGetInfo)(long long, long long);\nlong long(HTTPWrapperItoa)(long long, long long);\nlong long(HTTPClientAddRequestHeaders)(long long, long long, long long,\n                                       long long);\nlong long(HTTPClientReadData)(long long, long long, long long, long long,\n                              long long);\nlong long(HTTPSendFile)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[2048];\n  unsigned int field_800;\n  char field_804;\n  char padding_805[1023];\n  char field_c04;\n} struct_0;\n\nlong long handle_http_request(unsigned long long a0, unsigned long long a1,\n                              struct_0 *a2) {\n  char v0;         // [bp-0x20e8]\n  char v1;         // [bp-0x20c8]\n  char v2;         // [bp-0x2098]\n  char v3;         // [bp-0x2038]\n  char v4;         // [bp-0x202c]\n  unsigned int v5; // [bp-0x201c]\n  char v6;         // [bp-0x2018]\n  unsigned int v7; // [bp-0x14]\n  unsigned int v8; // [bp-0x10]\n  unsigned int v9; // [bp-0xc]\n\n  v8 = 0;\n  memset(&v3, 0, 20);\n  if (a2->field_804) {\n    v9 = HTTPClientSetVerb(a0, 2);\n    if (!(!v9))\n      goto LABEL_402c49;\n  } else if (a2->field_c04) {\n    v9 = HTTPClientSetVerb(a0, 3);\n    if (!(!v9))\n      goto LABEL_402c49;\n  } else {\n    v9 = HTTPClientSetVerb(a0, 0);\n    if (v9)\n      goto LABEL_402c49;\n  }\n  if (a2->field_804) {\n    v9 = HTTPClientSendRequest(a0, a1, &a2->field_804, strlen(&a2->field_804),\n                               1, 5, 0);\n    if (!(!v9))\n      goto LABEL_402c49;\n  } else if (!a2->field_c04) {\n    v9 = HTTPClientSendRequest(a0, a1, 0, 0, 0, 5, 0);\n    if (v9) {\n      putchar(10);\n      if (a2->field_800 == 1) {\n        printf(\n            \"\\n\\nHTTP Client terminated %d (got %d bytes, status_code %d)\\n\\n\",\n            v9, v8, *((int *)&v3));\n        return v9;\n      }\n      return v9;\n    }\n  } else {\n    memset(&v1, 0, 144);\n    memset(&v0, 0, 32);\n    v7 = stat(&a2->field_c04, &v1);\n    if (v7) {\n      v9 = 19;\n      putchar(10);\n    }\n    HTTPWrapperItoa(&v0, *((long long *)&v2));\n    v9 = HTTPClientAddRequestHeaders(a0, \"Content-Length\", &v0, 0);\n    if (v9) {\n    LABEL_402c49:\n      putchar(10);\n    }\n    v9 = HTTPClientSendRequest(a0, a1, 0, 0, 0, 5, 0);\n    if (v9) {\n      goto LABEL_402c49;\n    } else {\n      v9 = HTTPSendFile(a0, &a2->field_c04);\n      if (!(!v9))\n        goto LABEL_402c49;\n    }\n  }\n  v9 = HTTPClientRecvResponse(a0, 3);\n  if (v9) {\n    goto LABEL_402c49;\n  } else {\n    v9 = HTTPClientGetInfo(a0, &v3);\n    if (v9) {\n      goto LABEL_402c49;\n    } else {\n      while ((!v9 || v9 != 1000) && v8 < *((int *)&v4)) {\n        v5 = 0x2000;\n        v9 = HTTPClientReadData(a0, &v6, v5, 5, &v5);\n        v8 += v5;\n        (&v6)[v5] = 0;\n        printf(\"%s\", (unsigned int)&v6);\n      }\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrInsensitiveCompare_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x3c], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0x28]\n  char v2;         // [bp-0x22]\n  char v3;         // [bp-0x21]\n  char *v4;        // [bp-0x20], Other Possible Types: unsigned long\n  char *v5;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v6; // [bp-0xc]\n\n  v0 = a2;\n  v5 = a0;\n  v4 = a1;\n  v6 = 0;\n  v1 = strlen(a1);\n  if (!v0)\n    v0 = strlen(a0);\n  if (v1 != (int)v0)\n    return 0;\n  while (true) {\n    if (!v5 && !v4)\n      return 1;\n    if ((int)v0 && v6 == (int)v0)\n      return 1;\n    v3 = *((char *)v5);\n    v2 = *((char *)v4);\n    if (*((char *)v5) > 63 && *((char *)v5) <= 90)\n      v3 = *((char *)v5) + 32;\n    if (*(v4) > 63 && *(v4) <= 90)\n      v2 = *(v4) + 32;\n    if (v3 != v2)\n      return 0;\n    v5 += 1;\n    v4 += 1;\n    v6 += 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrExtract_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0; // [bp-0x9]\n\n  if (!a0) {\n    return 0;\n  } else if ((char)a2) {\n    a0[(unsigned int)a1] = a2;\n    return (char)a2;\n  } else {\n    v0 = a0[(unsigned int)a1];\n    a0[(unsigned int)a1] = 0;\n    return v0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(toupper)(int);\nint(tolower)(int);\n\nlong long HTTPStrCaseStr_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char *v0;         // [bp-0x30], Other Possible Types: unsigned long\n  unsigned long v1; // [bp-0x20]\n  unsigned int v2;  // [bp-0x14]\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v3 = v0;\n  v2 = 0;\n  while (true) {\n    if (v2 >= (unsigned int)a1) {\n      break;\n    } else {\n      v3 = strchr(v0, toupper(*(a2)));\n      v1 = strchr(v0, tolower(*(a2)));\n      if (!v3)\n        v3 = v1;\n      if (!v3)\n        break;\n      if (v1 && v1 < v3)\n        v3 = v1;\n      if (!strncasecmp(v3, a2, strlen(a2)))\n        return v3;\n      v0 = v3 + 1;\n      v2 += 1;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrGetToken(char *a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  char *v0;         // [bp-0x40]\n  char *v1;         // [bp-0x20]\n  unsigned int v2;  // [bp-0x18]\n  unsigned int v3;  // [bp-0x14]\n  char *v4;         // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long v7; // rax\n\n  v0 = a2;\n  v1 = a0;\n  v3 = 0;\n  v2 = 0;\n  v1 = strchr(a0, 58) + 1;\n  if (!v1)\n    return v0;\n  for (v4 = v1; *(v4) && *(v4) != 13 && *(v4) != 10; v2 += 1) {\n    if (*(v4) != 32)\n      v3 += 1;\n    if (!(!(unsigned int)a1) && !((unsigned int)a1 >= v2))\n      break;\n    v4 += 1;\n  }\n  if (*(a3) < v3) {\n    *(a3) = v3;\n    v0 = 0;\n    return v0;\n  }\n  v4 = v1;\n  *(a3) = v3;\n  for (v3 = 0; *(v4) && *(v4) != 13 && *(v4) != 10; v4 += 1) {\n    if (*(v4) != 32) {\n      v7 = v3;\n      v3 = (unsigned int)v7 + 1;\n      v0[v7] = *((char *)v4);\n    }\n  }\n  v0[v3] = 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(toupper)(int);\n\nlong long HTTPStrHToL_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x18]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned int v8;       // eax\n  unsigned int v10;      // eax\n  unsigned int v11;      // eax\n  char *v12;             // rax\n\n  v6 = &v4;\n  v2 = 0;\n  v3 = v2;\n  v0 = v3;\n  while (true) {\n    v8 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v3] * 2)) & 8;\n    if (v8) {\n      a0[v3] = toupper(a0[v3]);\n      if (a0[v3] == 88) {\n        v0 = 0;\n        v2 = v0;\n      } else {\n        v10 =\n            *((short *)(*((long long *)&__ctype_b_loc()) + a0[v3] * 2)) & 0x400;\n        v11 = (!v10 ? a0[v3] - 55 : a0[v3] - 48);\n        v1 = v11;\n        if (v1 > 15)\n          v1 = 15;\n        v0 = v1 + v0 * 16;\n        if (v0)\n          v2 += 1;\n        if (v2 == 8)\n          return v0;\n      }\n    }\n    v3 += 1;\n    v12 = &a0[v3];\n    *(v12) = a0[v3];\n    if (!*(v12))\n      return v0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0yfgf2gf/HTTPStrHToL_name_conflict.c:37:41: error: cannot take the address of an\nrvalue of type 'int' 37 |         v8 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v3] * 2)) & 8; | ^~~~~~~~~~~~~~~~\n/tmp/tmp0yfgf2gf/HTTPStrHToL_name_conflict.c:48:50: error: cannot take the address of an\nrvalue of type 'int' 48 |                 v10 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v3] * 2)) & 0x400; | ^~~~~~~~~~~~~~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrLToH_name_conflict(char a0[2], unsigned long a1) {\n  char v0[2];      // [bp-0x20], Other Possible Types: unsigned long\n  char *v1;        // [bp-0x18]\n  unsigned int v2; // [bp-0xc]\n  char v4[2];      // rax\n\n  *(&v0) = a0;\n  v1 = \"0123456789abcdef\";\n  if (!(unsigned int)a1) {\n    v0[0] = 48;\n    v0[1] = 0;\n    return v0;\n  }\n  for (v2 = 28; !(unsigned int)((unsigned int)a1 >> ((char)v2 & 31)); v2 -= 4)\n    ;\n  for (; v2 >= 0; v2 -= 4) {\n    v4 = v0;\n    v0 = &v4[1];\n    v4[0] = v1[(unsigned int)((unsigned int)a1 >> ((char)v2 & 31)) & 15];\n  }\n  *((char *)v0) = 0;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv2dcs88a/HTTPStrLToH_name_conflict.c:24:12: error: array type 'char[2]' is not\nassignable 24 |     *(&v0) = a0; |     ~~~~~~ ^\n/tmp/tmpv2dcs88a/HTTPStrLToH_name_conflict.c:35:12: error: array type 'char[2]' is not\nassignable 35 |         v4 = v0; |         ~~ ^\n/tmp/tmpv2dcs88a/HTTPStrLToH_name_conflict.c:36:12: error: array type 'char[2]' is not\nassignable 36 |         v0 = &v4[1]; |         ~~ ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperIsAscii_name_conflict(unsigned long a0) {\n  return (unsigned int)a0 <= 127;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\n\nlong long HTTPWrapperToUpper_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0 && (unsigned int)a0 > 96 &&\n      (unsigned int)a0 <= 122)\n    return (unsigned int)a0 - 32;\n  return (unsigned int)a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\n\nlong long HTTPWrapperToLower_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0 && (unsigned int)a0 > 64 &&\n      (unsigned int)a0 <= 90)\n    return (unsigned int)a0 + 32;\n  return (unsigned int)a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\n\nlong long HTTPWrapperIsAlpha_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0 &&\n      (!((unsigned int)a0 <= 96) && !((unsigned int)a0 > 122) ||\n       !((unsigned int)a0 <= 64) && !((unsigned int)a0 > 90)))\n    return (unsigned int)a0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAscii)(long long);\nlong long(HTTPWrapperIsAlpha)(long long);\n\nlong long HTTPWrapperIsAlNum_name_conflict(unsigned long a0) {\n  if ((int)HTTPWrapperIsAscii((unsigned int)a0) > 0) {\n    if ((int)HTTPWrapperIsAlpha((unsigned int)a0) > 0) {\n      return (unsigned int)a0;\n    } else if ((unsigned int)a0 > 47 && (unsigned int)a0 <= 57) {\n      return (unsigned int)a0;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperItoa_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x24]\n  char *v1;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0xc]\n  char *v4;        // rax\n  unsigned int v5; // ecx\n  char v7;         // cl\n\n  v1 = a0;\n  v0 = a1;\n  if (v0 >= 0) {\n    v2 = v0;\n  } else {\n    v2 = -(v0);\n    v4 = v1;\n    v1 = v4 + 1;\n    *(v4) = 45;\n  }\n  for (; v0; v0 = (v0 * 1717986919 >> 34) - (v0 >> 31)) {\n    v1 += 1;\n  }\n  for (*((char *)v1) = 0; v2; v2 = v2 * 3435973837 >> 35) {\n    v5 = v2;\n    v7 = v5 - 5 * v5 / 10 * 2;\n    v1 -= 1;\n    *((char *)v1) = v7 + 48;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long HTTPWrapperShutDown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperGetSocketError_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return *(__errno_location());\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkpzow8pc/HTTPWrapperGetSocketError_name_conflict.c:22:12: error: indirection requires\npointer operand ('int' invalid) 22 |     return *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(atol)(char *);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_1 {\n  char padding_0[24];\n  struct struct_0 *field_18;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long HTTPWrapperGetHostByName_name_conflict(char *a0, unsigned int *a1) {\n  char v0;          // [bp-0x68], Other Possible Types: unsigned int\n  unsigned int v1;  // [bp-0x64]\n  unsigned int v2;  // [bp-0x60]\n  unsigned int v3;  // [bp-0x5c]\n  struct_1 *v4;     // [bp-0x38]\n  char v5;          // [bp-0x30]\n  unsigned int v6;  // [bp-0x2c]\n  unsigned long v7; // [bp-0x28]\n  unsigned int v8;  // [bp-0x20]\n  unsigned int v9;  // [bp-0x1c]\n  char v10;         // [bp-0x15]\n  unsigned int v11; // [bp-0x14]\n  unsigned int v12; // [bp-0x10]\n  unsigned int v13; // [bp-0xc]\n\n  v13 = 0;\n  v8 = 0;\n  v12 = 0;\n  v11 = 0;\n  v10 = 0;\n  v9 = 0;\n  v8 = strlen(a0);\n  for (v13 = 0;\n       v13 <= v8 && (v10 = a0[v13], v10 > 47 && v10 <= 57 || v10 == 46);\n       v13 += 1) {\n    if (v10 == 46) {\n      v12 = 0;\n      v11 += 1;\n      v7 = atol(&v5);\n      if (!(v7 <= 0x100) || !(v11 <= 3))\n        return 4294967295;\n    } else if (v12 <= 3) {\n      (&v5)[v12] = v10;\n      (&v5)[1 + v12] = 0;\n      v12 += 1;\n    } else {\n      v9 += 1;\n      break;\n    }\n  }\n  if (v10 || v9 || v11 != 3) {\n    v9 += 1;\n  } else {\n    v7 = atol(&v5);\n    if (v7 > 0x100)\n      return 4294967295;\n  }\n  if (v9 <= 0) {\n    *(a1) = inet_addr(a0);\n    return 0;\n  }\n  v4 = 0;\n  memset(&v0, 0, 48);\n  v1 = 2;\n  v2 = 1;\n  v0 = 0;\n  v3 = 0;\n  v6 = getaddrinfo(a0, 0, &v0, &v4);\n  if (!v6) {\n    *(a1) = v4->field_18->field_4;\n    freeaddrinfo(v4);\n    return 0;\n  }\n  fprintf(stderr @GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgfu27ulf/HTTPWrapperGetHostByName_name_conflict.c:29:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 29 | extern FILE_t *stderr@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpgfu27ulf/HTTPWrapperGetHostByName_name_conflict.c:29:22: error: expected ';' after top\nlevel declarator 29 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpgfu27ulf/HTTPWrapperGetHostByName_name_conflict.c:105:19: error: expected ')'\n  105 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n      |                   ^\n/tmp/tmpgfu27ulf/HTTPWrapperGetHostByName_name_conflict.c:105:12: note: to match this '('\n  105 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n      |            ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\ndouble HTTPWrapperGetRandomeNumber_name_conflict() {\n  int tmp_20;      // tmp #20\n  int tmp_22;      // tmp #22\n  int tmp_21;      // tmp #21\n  unsigned int v0; // [bp-0xc]\n  int v2;          // xmm1\n\n  rand();\n  tmp_20 = DivV(tmp_22, tmp_21);\n  v2 = tmp_20;\n  v0 = (unsigned int)((0 CONCAT 0x4030000000000000) * v2);\n  return (unsigned long long)((0 CONCAT 0x4030000000000000) * v2);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqyadgohm/HTTPWrapperGetRandomeNumber_name_conflict.c:29:28: error: expected ')'\n   29 |     v0 = (unsigned int)((0 CONCAT 0x4030000000000000) * v2);\n      |                            ^\n/tmp/tmpqyadgohm/HTTPWrapperGetRandomeNumber_name_conflict.c:29:25: note: to match this '('\n   29 |     v0 = (unsigned int)((0 CONCAT 0x4030000000000000) * v2);\n      |                         ^\n/tmp/tmpqyadgohm/HTTPWrapperGetRandomeNumber_name_conflict.c:30:36: error: expected ')'\n   30 |     return (unsigned long long)((0 CONCAT 0x4030000000000000) * v2);\n      |                                    ^\n/tmp/tmpqyadgohm/HTTPWrapperGetRandomeNumber_name_conflict.c:30:33: note: to match this '('\n   30 |     return (unsigned long long)((0 CONCAT 0x4030000000000000) * v2);\n      |                                 ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long HTTPWrapperGetUpTime_name_conflict() {\n  char v0; // [bp-0x18]\n\n  clock_gettime(0x1, &v0);\n  return *((long long *)&v0);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLConnect(unsigned long a0, unsigned long a1,\n                                unsigned long a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLNegotiate(unsigned long a0, unsigned long a1,\n                                  unsigned long a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLSend(unsigned long a0, unsigned long a1,\n                             unsigned long a2, unsigned long a3) {\n  unsigned int v0;  // [bp-0x1c]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecv(unsigned long a0, unsigned long a1,\n                             unsigned long a2, unsigned long a3) {\n  unsigned int v0;  // [bp-0x1c]\n  unsigned long v1; // [bp-0x18]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v3 = a0;\n  v1 = a1;\n  v2 = a2;\n  v0 = a3;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecvPending_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLClose_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long sktSetNonblocking_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;          // [bp-0x1c]\n  unsigned int v1;  // [bp-0x10]\n  unsigned int v2;  // [bp-0xc]\n  unsigned long v5; // rax, Other Possible Types: unsigned long long\n\n  v1 = fcntl(a0, 3);\n  if (v1 < 0)\n    return 4294967295;\n  if ((unsigned int)a1)\n    v5 = v1;\n  else\n    v5 = v1;\n  v2 = v5;\n  if (fcntl(*((int *)&v0), 4) < 0) {\n    fcntl(*((int *)&v0), 4);\n    return 4294967295;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetLocalConnection_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned long v1; // [bp-0x10]\n\n  v1 = a0;\n  v0 = a1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPClientSetVerb)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[64];\n  unsigned short field_40;\n  char padding_42[518];\n  unsigned long long field_248;\n  unsigned int field_250;\n  char padding_254[4];\n  unsigned long long field_258;\n  char padding_260[1104];\n  unsigned int field_6b0;\n  char padding_6b4[620];\n  unsigned int field_920;\n  char padding_924[48];\n  unsigned int field_954;\n  unsigned int field_958;\n  char padding_95c[532];\n  unsigned short field_b70;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[64];\n  unsigned short field_40;\n  char padding_42[518];\n  void *field_248;\n  unsigned int field_250;\n  char padding_254[4];\n  unsigned long long field_258;\n  char padding_260[1104];\n  unsigned int field_6b0;\n  char padding_6b4[620];\n  unsigned int field_920;\n  char padding_924[48];\n  unsigned int field_954;\n  unsigned int field_958;\n  char padding_95c[532];\n  unsigned short field_b70;\n} struct_1;\n\nlong long HTTPClientOpenRequest_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_0 *v1;    // [bp-0x10], Other Possible Types: struct_1 *\n\n  v1 = 0;\n  v1 = malloc(2936);\n  if (!v1)\n    return 0;\n  memset(v1, 0, 2936);\n  v0 = 0x800;\n  v1->field_248 = malloc((!(v0 & 3) ? 4 : 0) + (v0 & -0x4));\n  if (!v1->field_248) {\n    free(v1);\n    return 0;\n  }\n  memset(v1->field_248, 0, v0);\n  v1->field_250 = v0;\n  HTTPClientSetVerb(v1, 0);\n  v1->field_40 = 80;\n  v1->field_920 = -1;\n  v1->field_258 = v1->field_248;\n  v1->field_954 = 1;\n  v1->field_958 = a0;\n  v1->field_6b0 = 0;\n  v1->field_b70 = 80;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnSessionReset)(long long, long long);\n\nlong long HTTPClientReset_name_conflict(unsigned long a0) {\n  void *v0; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = 0;\n  v0 = a0;\n  if (v0)\n    return HTTPIntrnSessionReset(v0, 1);\n  return 2;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnConnectionClose)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[584];\n  unsigned long long field_248;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[584];\n  void *field_248;\n} struct_1;\n\nlong long HTTPClientCloseRequest_name_conflict(struct struct_0 **a0) {\n  void *v0; // [bp-0x10], Other Possible Types: struct_0 *, struct_1 *\n\n  v0 = 0;\n  v0 = &*(a0)->padding_0;\n  if (!v0)\n    return 2;\n  if (v0->field_248)\n    free(v0->field_248);\n  HTTPIntrnConnectionClose(v0);\n  free(v0);\n  v0 = 0;\n  *(a0) = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqmceh8bx/HTTPClientCloseRequest_name_conflict.c:33:16: error: member reference base\ntype 'struct struct_0 *' is not a structure or union 33 |     v0 =\n&*(a0)->padding_0; |            ~~~~^ ~~~~~~~~~\n/tmp/tmpqmceh8bx/HTTPClientCloseRequest_name_conflict.c:36:11: error: member reference base\ntype 'void' is not a structure or union 36 |     if (v0->field_248) | ~~^\n~~~~~~~~~ /tmp/tmpqmceh8bx/HTTPClientCloseRequest_name_conflict.c:37:16: error: member\nreference base type 'void' is not a structure or union 37 | free(v0->field_248);\n      |              ~~^ ~~~~~~~~~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1724];\n  unsigned int field_6bc;\n} struct_0;\n\nlong long HTTPClientSetConnection_name_conflict(struct_0 *a0, unsigned long a1) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = 0;\n  v0 = a0;\n  if (!v0)\n    return 2;\n  v0->field_6bc = a1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetVerb_name_conflict(unsigned int a0[421], unsigned long a1) {\n  unsigned int v0[421];  // [bp-0x10]\n  unsigned long long v3; // rdx\n\n  *((long long *)&v0[0]) = 0;\n  *((unsigned int *[421]) & v0[0]) = a0;\n  if (!v0)\n    return 2;\n  v3 = a1;\n  v0[162] = a1;\n  if ((unsigned int)a1 == 3) {\n    v0[420] = 5526864;\n    return 0;\n  }\n  if ((unsigned int)a1 > 3)\n    return 18;\n  if ((unsigned int)a1 == 2) {\n    strcpy(&v0[420], \"POST\");\n    return 0;\n  } else if ((unsigned int)a1 <= 2) {\n    if (!(unsigned int)a1) {\n      v0[420] = 5522759;\n      return 0;\n    } else if ((unsigned int)a1 == 1) {\n      return 18;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbqhbe3o1/HTTPClientSetVerb_name_conflict.c:23:7: error: used type 'unsigned int\n*[421]' where arithmetic or pointer type is required 23 |     *((unsigned int\n*[421])&v0[0]) = a0; |       ^                    ~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[1872];\n  unsigned short field_750;\n  char padding_752[18];\n  unsigned int field_764;\n  char padding_768[496];\n  unsigned int field_958;\n} struct_0;\n\nlong long HTTPClientSetProxy(struct_0 *a0, char *a1, unsigned long a2, char *a3,\n                             char *a4) {\n  struct_0 *v0;          // [bp-0x10]\n  unsigned long long v3; // rax\n\n  v0 = 0;\n  v0 = a0;\n  if (!v0)\n    return 2;\n  strncpy(&v0->padding_0[1776], a1, 64);\n  if (a3)\n    strncpy(&v0->padding_0[1840], a3, 16);\n  if (a4)\n    strncpy(&v0->padding_0[1856], a4, 16);\n  v0->field_750 = a2;\n  v3 = v0->field_958;\n  *((char *)&v3) = (char)v3 | 128;\n  v0->field_958 = v3;\n  if (!(a4 && a3))\n    return 0;\n  v0->field_764 = 1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1732];\n  unsigned int field_6c4;\n} struct_0;\n\nlong long HTTPClientSetCredentials_name_conflict(struct_0 *a0, char *a1, char *a2) {\n  unsigned int v0; // [bp-0x14]\n  struct_0 *v1;    // [bp-0x10]\n\n  v1 = 0;\n  v1 = a0;\n  if (!v1)\n    return 2;\n  v0 = strlen(a1);\n  if (v0 > 16)\n    return 19;\n  v0 = strlen(a2);\n  if (v0 > 16)\n    return 19;\n  strcpy(&v1[1].padding_0[160], a1);\n  strcpy(&v1[1].padding_0[176], a2);\n  v1->field_6c4 = 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersAdd)(long long, long long, long long, long long,\n                               long long);\n\nlong long HTTPClientAddRequestHeaders(unsigned long a0, char *a1, char *a2,\n                                      unsigned long a3) {\n  unsigned int v0; // [bp-0x44]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0x18]\n  unsigned int v3; // [bp-0x14]\n  void *v4;        // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = a3;\n  v4 = 0;\n  v4 = a0;\n  if (!v4)\n    return 2;\n  v3 = strlen(a1);\n  v2 = strlen(a2);\n  v1 = HTTPIntrnHeadersAdd(v4, a1, v3, a2, v2);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersReceive)(long long, long long);\n\nlong long HTTPClientRecvResponse_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10], Other Possible Types: unsigned long long\n\n  v1 = 0;\n  v1 = a0;\n  if (!v1)\n    return 2;\n  v0 = HTTPIntrnHeadersReceive(v1, (unsigned int)a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientGetInfo_name_conflict(unsigned int a0[598], unsigned int a1[5]) {\n  unsigned int v0[598]; // [bp-0x10]\n\n  *((long long *)&v0[0]) = 0;\n  *((unsigned int *[598]) & v0[0]) = a0;\n  if (!v0)\n    return 2;\n  memset(a1, 0, 20);\n  a1[0] = v0[428];\n  a1[1] = v0[595];\n  a1[2] = v0[589];\n  a1[3] = v0[429];\n  a1[4] = v0[597];\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpge9fwedo/HTTPClientGetInfo_name_conflict.c:22:7: error: used type 'unsigned int\n*[598]' where arithmetic or pointer type is required 22 |     *((unsigned int\n*[598])&v0[0]) = a0; |       ^                    ~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientFindFirstHeader(struct_0 *a0, char *a1, unsigned long a2,\n                                    unsigned long a3) {\n  unsigned long v0; // [bp-0x38]\n  unsigned long v1; // [bp-0x30]\n  unsigned int v2;  // [bp-0x14]\n  struct_0 *v3;     // [bp-0x10]\n\n  v1 = a2;\n  v0 = a3;\n  v3 = 0;\n  v3 = a0;\n  if (!v3)\n    return 2;\n  v2 = strlen(a1);\n  if (v2 > 1023)\n    return 13;\n  strcpy(&v3[1].padding_0[12], a1);\n  v3->field_280 = 0;\n  v3->field_278 = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n  char padding_284[12];\n  char field_290;\n} struct_0;\n\nlong long HTTPClientFindCloseHeader_name_conflict(struct_0 *a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = 0;\n  v0 = a0;\n  if (!v0)\n    return 2;\n  v0->field_290 = 0;\n  v0->field_280 = 0;\n  v0->field_278 = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersFind)(long long, long long, long long, long long,\n                                long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[616];\n  unsigned long long field_268;\n  char padding_270[8];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientGetNextHeader_name_conflict(struct_0 *a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x38]\n  char v1;         // [bp-0x30]\n  unsigned int v2; // [bp-0x24]\n  struct_0 *v3;    // [bp-0x20]\n  char *v4;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v5; // [bp-0xc]\n\n  v3 = 0;\n  v5 = 0;\n  v3 = a0;\n  if (!v3)\n    return 2;\n  if (v3->field_280)\n    v5 = v3->field_278 - v3->field_268;\n  v2 = HTTPIntrnHeadersFind(v3, &v3[1].padding_0[12], &v0, 1, v5);\n  if (v2) {\n    return v2;\n  } else if (*(a2) >= *((int *)&v1)) {\n    v4 = *((long long *)&v0);\n    v5 = 0;\n    if (*(v4) == 13) {\n      v5 += 1;\n      v4 += 1;\n    }\n    if (*((char *)v4) == 10) {\n      v5 += 1;\n      v4 += 1;\n    }\n    strncpy(a1, v4, *((int *)&v1) - v5);\n    a1[*((int *)&v1) + -1 * v5] = 0;\n    *(a2) = *((int *)&v1) - v5;\n    v3->field_278 = *((int *)&v1) + *((long long *)&v0);\n    v3->field_280 = v3->field_280 + 1;\n    return 0;\n  } else {\n    *(a2) = *((int *)&v1);\n    *(a1) = 0;\n    return 3;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperGetUpTime)();\n\nlong long HTTPIntrnSessionGetUpTime_name_conflict() { return HTTPWrapperGetUpTime(); }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char base64val;\n\nlong long HTTPBase64Decoder_name_conflict(char *a0, char a1[4]) {\n  char v0[4];      // [bp-0x48], Other Possible Types: unsigned long\n  char *v1;        // [bp-0x40], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0x2c]\n  char v5;         // r14b\n  char v6;         // r13b\n  char v7;         // bl\n  char v8;         // r12b\n  char v9;         // sil\n  char v10;        // cl\n  char *v11;       // rax\n  char v12;        // sil\n  char v13;        // cl\n  char *v14;       // rax\n  char v15;        // sil\n  char v16;        // cl\n  char *v17;       // rax\n\n  v1 = a0;\n  *(&v0) = a1;\n  v2 = 0;\n  if (v0[0] == 43 && v0[1] == 32)\n    v0 = &v0[2];\n  if (*((char *)v0) == 13)\n    return 0;\n  while (v5 >= 0 && *(&(&base64val)[v5]) != 255) {\n    v5 = *((char *)v0);\n    v6 = *((char *)(v0 + 1));\n    if (!(v6 >= 0) || !(*(&(&base64val)[v6]) != 255))\n      return 4294967295;\n    v7 = *((char *)(v0 + 2));\n    if (v7 != 61 && (!(v7 >= 0) || !(*(&(&base64val)[v7]) != 255)))\n      return 4294967295;\n    v8 = *((char *)(v0 + 3));\n    if (v8 != 61 && (!(v8 >= 0) || !(*(&(&base64val)[v8]) != 255)))\n      return 4294967295;\n    v0 += 4;\n    v9 = (v5 < 0 ? (unsigned int)(*(&(&base64val)[v5]) * 4) : -0x4);\n    v10 = (v6 < 0 ? (unsigned int)(*(&(&base64val)[v6]) >> 4) : -1);\n    v11 = v1;\n    v1 = v11 + 1;\n    *(v11) = v9 | v10;\n    v2 += 1;\n    if (v7 != 61) {\n      v12 = (v6 < 0 ? (unsigned int)(*(&(&base64val)[v6]) * 16) : -0x10);\n      v13 = (v7 < 0 ? (unsigned int)(*(&(&base64val)[v7]) >> 2) : -1);\n      v14 = v1;\n      v1 = v14 + 1;\n      *(v14) = v9 | v13;\n      v2 += 1;\n      if (v8 != 61) {\n        v15 = (v7 < 0 ? (unsigned int)(*(&(&base64val)[v7]) * 64) : -64);\n        v16 = (v8 < 0 ? *(&(&base64val)[v8]) : -1);\n        v17 = v1;\n        v1 = v17 + 1;\n        *(v17) = v9 | v16;\n        v2 += 1;\n      }\n    }\n    if (!(*((char *)v0)) || !(*((char *)v0) != 13) || !(v8 != 61))\n      return v2;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0f3d3gbr/HTTPBase64Decoder_name_conflict.c:39:12: error: array type 'char[4]' is not\nassignable 39 |     *(&v0) = a1; |     ~~~~~~ ^\n/tmp/tmp0f3d3gbr/HTTPBase64Decoder_name_conflict.c:42:12: error: array type 'char[4]' is not\nassignable 42 |         v0 = &v0[2]; |         ~~ ^\n/tmp/tmp0f3d3gbr/HTTPBase64Decoder_name_conflict.c:57:12: error: invalid operands to binary\nexpression ('char[4]' and 'int') 57 |         v0 += 4; |         ~~ ^  ~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":1,"function":"static u8 gf_mult(u8 x, u8 y) {\n    u8 result = 0;\n    while (x != 0)\n        {\n            result ^= x & 1 ? y : 0;\n            x >>= 1;\n            y = ((y) & 128 ? ((y) << 1) ^ 27 : ((y) << 1));\n        }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long gf_mult_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x20]\n  char v1; // [bp-0x1c]\n  char v2; // [bp-0x9]\n  char v4; // al\n\n  v1 = a0;\n  v0 = a1;\n  for (v2 = 0; v1;\n       *((int *)&v0) = (v0 < 0 ? (char)(v0 * 2) : (char)(v0 * 2 ^ 27))) {\n    if (!(v1 & 1))\n      v4 = 0;\n    else\n      v4 = v0;\n    v2 = v4 ^ v2;\n    v1 >>= 1;\n  }\n  return v2;\n}\n","pass":1,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"static u64 F(u64 x) {\n    u8 *temp = (u8 *)&x;\n    u8 a[8] = {};\n    int i, j;\n    for (i = 0; i < 8; i++)\n        temp[i] = sbox[temp[i]];\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            a[i] ^= gf_mult(temp[j], mds_matrix[i][j]);\n        }\n    }\n    x = *((u64 *)a);\n    return x;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(gf_mult)(long long, long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern char mds_matrix;\nextern char sbox;\n\nlong long F_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x30]\n  void *v1;         // [bp-0x20]\n  struct_0 *v2;     // [bp-0x18]\n  unsigned int v3;  // [bp-0x10]\n  unsigned int v4;  // [bp-0xc]\n\n  v0 = a0;\n  v2 = &v0;\n  v1 = 0;\n  for (v4 = 0; v4 <= 7; v4 += 1) {\n    v2[v4].field_0 = *(&(&sbox)[v2[v4].field_0]);\n  }\n  for (v4 = 0; v4 <= 7; v4 += 1) {\n    for (v3 = 0; v3 <= 7; v3 += 1) {\n      *((char *)&v1 + v4) =\n          (char)gf_mult(v2[v3].field_0, (&mds_matrix)[8 * v4 + v3]) ^\n          *((char *)&v1 + v4);\n    }\n  }\n  v0 = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":1,"function":"static u8 char_val(char c) {\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    printf(\"Illegal character \\\"%c\\\"\\n\", c);\n    exit(1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long char_val_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57)\n    return (char)a0 - 48;\n  if ((char)a0 > 96 && (char)a0 <= 102)\n    return (char)a0 - 87;\n  if ((char)a0 > 64 && (char)a0 <= 70)\n    return (char)a0 - 55;\n  printf(\"Illegal character \\\"%c\\\"\\n\", (char)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"char *build_chunked_response(int content_length, int *response_len) {\n    char *response_buffer;\n    char *content_buffer;\n    int buffer_length;\n    int i, n;\n    buffer_length = 256 + content_length + (content_length >> 4);\n    response_buffer = malloc(buffer_length);\n    *response_len = snprintf(response_buffer, buffer_length, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    content_buffer = malloc(content_length);\n    build_content(content_buffer, content_length);\n    i = 0;\n    while (i < content_length)\n        {\n            n = (rand() % 199) + 1;\n            if (i + n > content_length) {\n                n = content_length - i;\n            }\n            *response_len += snprintf(response_buffer + *response_len, buffer_length - *response_len, \"%x\\r\\n\", n);\n            memcpy(response_buffer + *response_len, content_buffer + i, n);\n            *response_len += n;\n            i += n;\n            response_buffer[(*response_len)++] = '\\r';\n            response_buffer[(*response_len)++] = '\\n';\n        }\n    memcpy(response_buffer + *response_len, \"0\\r\\n\\r\\n\", 5);\n    *response_len += 5;\n    free(content_buffer);\n    printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", *response_len, buffer_length, content_length);\n    return response_buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(build_content)(long long, long long);\nint(rand)();\n\nlong long build_chunked_response_name_conflict(unsigned long a0, unsigned int *a1) {\n  void *v0;              // [bp-0x28]\n  char *v1;              // [bp-0x20]\n  unsigned int v2;       // [bp-0x14]\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v6; // rax\n  unsigned long v7;      // rax\n  unsigned long v8;      // rax\n\n  v2 = (unsigned int)((unsigned int)a0 >> 4) + (unsigned int)a0 + 0x100;\n  v1 = malloc(v2);\n  *(a1) = snprintf(v1, v2,\n                   \"HTTP/1.1 200 OK\\r\\nContent-Type: \"\n                   \"text/plain\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n  v0 = malloc((unsigned int)a0);\n  build_content(v0, (unsigned int)a0);\n  for (v4 = 0; v4 < (unsigned int)a0; v1[v8] = 10) {\n    (unsigned int)v6 = rand();\n    v3 = (unsigned int)v6 -\n         (unsigned int)((v6 * 1381296015 >> 38) - (v6 >> 31)) * 199 + 1;\n    if ((unsigned int)a0 < v3 + v4)\n      v3 = (unsigned int)a0 - v4;\n    *(a1) = *(a1) + snprintf(&v1[*(a1)], v2 - *(a1), \"%x\\r\\n\", v3);\n    memcpy(&v1[*(a1)], v4 + v0, v3);\n    *(a1) = *(a1) + v3;\n    v4 += v3;\n    v7 = *(a1);\n    *(a1) = (unsigned int)v7 + 1;\n    v1[v7] = 13;\n    v8 = *(a1);\n    *(a1) = (unsigned int)v8 + 1;\n  }\n  memcpy(&v1[*(a1)], \"0\\r\\n\\r\\n\", 5);\n  *(a1) = *(a1) + 5;\n  free(v0);\n  printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", *(a1), v2,\n         (unsigned int)a0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9du3mifz/build_chunked_response_name_conflict.c:16:6: error: conflicting types for\n'snprintf' 16 | int (snprintf)(char *, unsigned long, char *, ...); |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp9du3mifz/build_chunked_response_name_conflict.c:38:9: error: assignment to cast is\nillegal, lvalue casts are not supported 38 |         (unsigned int)v6 = rand();\n      |         ^~~~~~~~~~~~~~~~ ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mdilai_jweegad/external/miniupnpc/minihttptestserver.c"}
{"compilable":0,"function":"unsigned long long fatorial(unsigned int valor) {\n    unsigned long long i, fatorial = 1;\n    for (i = 1; i <= valor; i++) {\n        fatorial *= i;\n    }\n    return fatorial;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fatorial_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned long v1; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = 1;\n  for (v1 = 1; (unsigned int)a0 >= v1; v1 += 1) {\n    v0 = v1 * v0;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_29-05/ex1.c"}
{"compilable":1,"function":"bool comparar(int *v1, int *v2) {\n    if (*v1 > *v2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long comparar_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return (*(a0) <= *(a1) ? 1 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_31-05/bouble_sort.c"}
{"compilable":0,"function":"char *init_palavra(char *texto_palavra) {\n    char *palavra = (char *)malloc(sizeof(char) * (strlen(texto_palavra) + 1));\n    strcpy(palavra, texto_palavra);\n    return palavra;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_palavra_name_conflict(char *a0) {\n  char *v0; // [bp-0x10]\n\n  v0 = malloc(strlen(a0) + 1);\n  strcpy(v0, a0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"char *init_mascara(unsigned int tamanho_palavra) {\n    unsigned int i;\n    char *mascara = (char *)malloc(sizeof(char) * (tamanho_palavra + 1));\n    for (i = 0; i < tamanho_palavra; i++) {\n        mascara[i] = '_';\n    }\n    mascara[i] = '\\x00';\n    return mascara;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_mascara_name_conflict(unsigned long a0) {\n  char *v0;              // [bp-0x18]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = malloc((unsigned int)a0 + 1);\n  for (v1 = 0; v1 < (unsigned int)a0; v1 += 1) {\n    v0[v1] = 95;\n  }\n  v0[v1] = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"bool existe_letra_na_palavra(char letra, char *palavra) {\n    unsigned int i;\n    for (i = 0; i < strlen(palavra); i++) {\n        if (letra == palavra[i]) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long existe_letra_na_palavra_name_conflict(unsigned long a0, char *a1) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned long v1;      // [bp-0x10]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rbx\n\n  v4 = &v2;\n  v1 = v5;\n  v0 = 0;\n  while (true) {\n    if (v0 >= strlen(a1)) {\n      return 0;\n    } else if ((char)a0 != a1[v0]) {\n      v0 += 1;\n    } else {\n      return 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":1,"function":"bool eh_palindromo(int *vetor, int tamanho) {\n    int i = 0;\n    for (i = 0; i < tamanho / 2; i++) {\n        if (vetor[i] != vetor[tamanho - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long eh_palindromo_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  for (v0 = 0;\n       v0 < (unsigned int)((unsigned int)a1 + ((unsigned int)a1 >> 31) >> 1);\n       v0 += 1) {\n    if (a0[v0] != a0[1 + a1 + -1 * v0])\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_05-06/ex1.c"}
{"compilable":0,"function":"unsigned int calcularTamanhoRegistro(const Registro registro) {\n    unsigned int tamanhoRegistro = strlen(registro.ra) + strlen(registro.nome) + strlen(registro.curso) + strlen(registro.ano);\n    tamanhoRegistro *= sizeof(char);\n    tamanhoRegistro += 5;\n    return tamanhoRegistro;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long calcularTamanhoRegistro_name_conflict() {\n  unsigned int v0;        // [bp-0x1c]\n  unsigned long v1;       // [bp-0x10]\n  char v2;                // [bp-0x8]\n  char v3;                // [bp+0x8]\n  char v4;                // [bp+0xd8]\n  char v5;                // [bp+0x1a1]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  unsigned int v9;        // ebx\n  unsigned long long v10; // rbx\n\n  v6 = &v2;\n  v1 = v7;\n  v9 = (unsigned int)strlen(&v3) + (unsigned int)strlen(&v3) +\n       (unsigned int)strlen(&v4);\n  v0 = (unsigned int)strlen(&v5) + v9;\n  v0 += 5;\n  v10 = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"LittleEndian toLittleEndian(const unsigned short numero) {\n    unsigned short primeiroByte = (numero & 65280) >> 8;\n    unsigned short segundoByte = (numero & 255);\n    LittleEndian little;\n    little.number[0] = segundoByte;\n    little.number[1] = primeiroByte;\n    return little;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long toLittleEndian_name_conflict(unsigned long a0) {\n  char v0;           // [bp-0xe]\n  char v1;           // [bp-0xd]\n  unsigned short v2; // [bp-0xa]\n\n  v2 = (unsigned short)a0 >> 8;\n  v0 = a0;\n  v1 = v2;\n  return *((short *)&v0);\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"unsigned short revertLittleEndian(const LittleEndian little) {\n    unsigned short primeiroByte = (little.number[1] & 255) << 8;\n    unsigned short segundoByte = little.number[0] & 255;\n    return primeiroByte | segundoByte;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long revertLittleEndian_name_conflict(unsigned long a0) {\n  unsigned short v0;     // [bp-0x1a]\n  unsigned short v1;     // [bp-0xa]\n  unsigned long long v3; // rax\n\n  v0 = a0;\n  v1 = (unsigned short)a0 * 0x100;\n  v3 = v1;\n  *((unsigned short *)&v3) = (unsigned short)v3 | (unsigned short)a0;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":1,"function":"int count(char *string) {\n    int length = 0;\n    while (string[length] != '\\x00')\n        {\n            length++;\n        }\n    return length;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long count_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; a0[v0]; v0 += 1)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/08-09/ex3.c"}
{"compilable":0,"function":"int ordenar(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    quantidadeArquivos = contarArquivos(nomeBase);\n    if (quantidadeArquivos == 0) {\n        fprintf(stderr, \"Nao existe outros arquivos a patir do arquivo base especificado!\\n\");\n        return 1;\n    }\n    return intercalar(nomeBase, quantidadeArquivos);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(contarArquivos)(long long);\nlong long(intercalar)(long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long ordenar_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = 0;\n  v0 = malloc(strlen(a0 + 10));\n  if (!v0) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n    return 1;\n  }\n  v1 = contarArquivos(a0);\n  if (v1)\n    return intercalar(a0, v1);\n  fwrite(\"Nao existe outros arquivos a patir do arquivo base especificado!\\n\",\n         1, 65, stderr @GLIBC_2.2.5);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4xwtpcvp/ordenar_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp4xwtpcvp/ordenar_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp4xwtpcvp/ordenar_name_conflict.c:30:92: error: expected ')'\n   30 |         fwrite(\"Problema com alocacao dinamica! Possivel falta de\nmemoria\\n\", 1, 58, stderr@GLIBC_2.2.5); | ^ /tmp/tmp4xwtpcvp/ordenar_name_conflict.c:30:15:\nnote: to match this '(' 30 |         fwrite(\"Problema com alocacao dinamica!\nPossivel falta de memoria\\n\", 1, 58, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp4xwtpcvp/ordenar_name_conflict.c:36:95: error: expected ')'\n   36 |     fwrite(\"Nao existe outros arquivos a patir do arquivo base\nespecificado!\\n\", 1, 65, stderr@GLIBC_2.2.5); | ^\n/tmp/tmp4xwtpcvp/ordenar_name_conflict.c:36:11: note: to match this '('\n   36 |     fwrite(\"Nao existe outros arquivos a patir do arquivo base\nespecificado!\\n\", 1, 65, stderr@GLIBC_2.2.5); |           ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int contarArquivos(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < 10; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        if (existeArquivo(nomeArquivo)) {\n            quantidadeArquivos++;\n        }\n    }\n    free(nomeArquivo);\n    return quantidadeArquivos;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(existeArquivo)(long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long contarArquivos_name_conflict(unsigned long a0) {\n  char *v0;        // [bp-0x18]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v0 = malloc(strlen(a0 + 10));\n  if (!v0) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n    return 1;\n  }\n  for (v1 = 0; v1 <= 9; v1 += 1) {\n    sprintf(v0, \"%s%d\", (unsigned int)a0, v1);\n    if ((char)existeArquivo(v0))\n      v2 += 1;\n  }\n  free(v0);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmo4zvx12/contarArquivos_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpmo4zvx12/contarArquivos_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpmo4zvx12/contarArquivos_name_conflict.c:30:92: error: expected ')'\n   30 |         fwrite(\"Problema com alocacao dinamica! Possivel falta de\nmemoria\\n\", 1, 58, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpmo4zvx12/contarArquivos_name_conflict.c:30:15: note: to match this '('\n   30 |         fwrite(\"Problema com alocacao dinamica! Possivel falta de\nmemoria\\n\", 1, 58, stderr@GLIBC_2.2.5); |               ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"_Bool existeArquivo(const char *nomeArquivo) {\n    FILE *arquivo = fopen(nomeArquivo, \"rb\");\n    _Bool result = arquivo != ((void *)0);\n    if (result) {\n        fclose(arquivo);\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long existeArquivo_name_conflict(char *a0) {\n  char v0;    // [bp-0x11]\n  FILE_t *v1; // [bp-0x10]\n\n  v1 = &fopen(a0, \"rb\")->_flags;\n  v0 = v1;\n  if (v0) {\n    fclose(v1);\n    return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7et55tn2/existeArquivo_name_conflict.c:85:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 85 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int intercalar(const char *nomeBase, int quantidadeArquivos) {\n    FILE *arquivosEntrada[10];\n    FILE *arquivoSaida;\n    int buffer[10][5];\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        arquivosEntrada[i] = fopen(nomeArquivo, \"rb\");\n        if (arquivosEntrada[i] == ((void *)0)) {\n            fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeArquivo);\n            for (int j = 0; j < i; j++) {\n                fclose(arquivosEntrada[j]);\n            }\n            free(nomeArquivo);\n            return 1;\n        }\n    }\n    arquivoSaida = fopen(nomeBase, \"wb\");\n    if (arquivoSaida == ((void *)0)) {\n        fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeBase);\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            fclose(arquivosEntrada[i]);\n        }\n        free(nomeArquivo);\n        return 1;\n    }\n    while (!leuTodosOsArquivosPorCompleto(arquivosEntrada, quantidadeArquivos))\n        {\n            int lidoAtual[10] = {0};\n            for (int i = 0; i < quantidadeArquivos; i++) {\n                lidoAtual[i] = fread(buffer[i], sizeof(int), 5, arquivosEntrada[i]);\n            }\n            int indices[10] = {0};\n            int min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n            while (min != -1)\n                {\n                    fwrite(&buffer[min][indices[min]], sizeof(int), 1, arquivoSaida);\n                    indices[min]++;\n                    if (indices[min] == lidoAtual[min]) {\n                        lidoAtual[min] = fread(buffer[min], sizeof(int), 5, arquivosEntrada[min]);\n                        indices[min] = 0;\n                    }\n                    min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n                }\n        }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        fclose(arquivosEntrada[i]);\n    }\n    fclose(arquivoSaida);\n    free(nomeArquivo);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(leuTodosOsArquivosPorCompleto)(long long, long long);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(pegaMenor)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long intercalar_name_conflict(char *a0, unsigned long a1) {\n  int v0;           // [bp-0x1b8]\n  int v1;           // [bp-0x1a8]\n  void *v2;         // [bp-0x198]\n  int v3;           // [bp-0x188]\n  int v4;           // [bp-0x178]\n  void *v5;         // [bp-0x168]\n  char v6;          // [bp-0x158]\n  FILE_t *v7;       // [bp-0x88]\n  FILE_t *v8;       // [bp-0x30]\n  char *v9;         // [bp-0x28]\n  unsigned int v10; // [bp-0x20]\n  unsigned int v11; // [bp-0x1c]\n  unsigned int v12; // [bp-0x18]\n  unsigned int v13; // [bp-0x14]\n  unsigned int v14; // [bp-0x10]\n  unsigned int v15; // [bp-0xc]\n\n  v9 = malloc(strlen(a0 + 10));\n  if (!v9) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n    return 1;\n  }\n  for (v15 = 0; v15 < (unsigned int)a1; v15 += 1) {\n    sprintf(v9, \"%s%d\", (unsigned int)a0, v15);\n    (&v7)[v15] = &fopen(v9, \"rb\")->_flags;\n    if (!(&v7)[v15]) {\n      fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n              (unsigned int)v9);\n      for (v14 = 0; v14 < v15; v14 += 1) {\n        fclose((&v7)[v14]);\n      }\n      free(v9);\n      return 1;\n    }\n  }\n  v8 = &fopen(a0, \"wb\")->_flags;\n  if (v8) {\n    while (true) {\n      if (!(char)((int)leuTodosOsArquivosPorCompleto(&v7, (unsigned int)a1) ^\n                  1))\n        break;\n      *((int128_t *)&v0) = 0;\n      *((int128_t *)&v1) = 0;\n      v2 = 0;\n      for (v12 = 0; v12 < (unsigned int)a1; v12 += 1) {\n        *((unsigned int *)((char *)&v0 + 4 * v12)) =\n            fread(&(&v6)[20 * v12], 4, 5, (&v7)[v12]);\n      }\n      *((int128_t *)&v3) = 0;\n      *((int128_t *)&v4) = 0;\n      v5 = 0;\n      for (v11 = pegaMenor(&v6, (unsigned int)a1, &v3, &v0); v11 != -1;\n           v11 = pegaMenor(&v6, (unsigned int)a1, &v3, &v0)) {\n        fwrite(&(&v6)[20 * v11 + 4 * *((int *)((char *)&v3 + 4 * v11))], 4, 1,\n               v8);\n        *((int *)((char *)&v3 + 4 * v11)) =\n            *((int *)((char *)&v3 + 4 * v11)) + 1;\n        if (*((int *)((char *)&v3 + 4 * v11)) ==\n            *((int *)((char *)&v0 + 4 * v11))) {\n          *((unsigned int *)((char *)&v0 + 4 * v11)) =\n              fread(&(&v6)[20 * v11], 4, 5, (&v7)[v11]);\n          *((int *)((char *)&v3 + 4 * v11)) = 0;\n        }\n      }\n    }\n    for (v10 = 0; v10 < (unsigned int)a1; v10 += 1) {\n      fclose((&v7)[v10]);\n    }\n    fclose(v8);\n    free(v9);\n    return 0;\n  } else {\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n    for (v13 = 0; v13 < (unsigned int)a1; v13 += 1) {\n      fclose((&v7)[v13]);\n    }\n    free(v9);\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp633b0rog/intercalar_name_conflict.c:33:16: error: nested redefinition of '_IO_marker'\n   33 |         struct _IO_marker {\n      |                ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:76:13: error: declaration of anonymous union must\nbe a definition 76 |             union <anon> { |             ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:79:22: error: type name requires a specifier or\nqualifier 79 |             } __value; |                      ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:83:13: error: declaration of anonymous union must\nbe a definition 83 |             union <anon> { |             ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:86:22: error: type name requires a specifier or\nqualifier 86 |             } __value; |                      ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:19:16: error: conflicting types for 'fread'\n   19 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:145:16: error: redefinition of '_IO_marker'\n  145 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:151:16: error: redefinition of '_IO_codecvt'\n  151 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:54:12: note: previous definition is here\n   54 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:155:16: error: redefinition of '_IO_wide_data'\n  155 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:62:12: note: previous definition is here\n   62 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:178:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 178 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmp633b0rog/intercalar_name_conflict.c:180:16: error: redeclaration of 'stderr' with a\ndifferent type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka 'struct\n_IO_FILE *') 180 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 180 : 22 : error\n    : expected ';' after top level declarator 180 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmp633b0rog / intercalar_name_conflict.c : 204 : 92 : error : expected ')' 204 |\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 204 : 15 : note : to match this '(' 204 |\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n| ^/ tmp / tmp633b0rog / intercalar_name_conflict.c : 213 : 27 : error : expected ')' 213 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)v9);\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 213 : 20 : note : to match this '(' 213 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)v9);\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 229 : 26 : error : expected expression 229 |\n    *((int128_t *)&v0) = 0;\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 230 : 26 : error : expected expression 230 |\n    *((int128_t *)&v1) = 0;\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 236 : 26 : error : expected expression 236 |\n    *((int128_t *)&v3) = 0;\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 237 : 26 : error : expected expression 237 |\n    *((int128_t *)&v4) = 0;\n| ^/ tmp / tmp633b0rog / intercalar_name_conflict.c : 260 : 23 : error : expected ')' 260 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmp633b0rog /\n        intercalar_name_conflict.c : 260 : 16 : note : to match this '(' 260 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n| ^19 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int pegaMenor(const int buffer[][5], const int quantidadeArquivos, const int *indices, const int *lidoAtual) {\n    int min = -1;\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        if (lidoAtual[i] > 0 && indices[i] < lidoAtual[i]) {\n            min = i;\n            break;\n        }\n    }\n    if (min != -1) {\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            if (buffer[min][indices[min]] > buffer[i][indices[i]] && indices[i] < lidoAtual[i]) {\n                min = i;\n            }\n        }\n    }\n    return min;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pegaMenor(unsigned long a0, unsigned long a1, unsigned int *a2,\n                    unsigned int *a3) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n  unsigned int v5; // ecx\n\n  v2 = -1;\n  for (v1 = 0; v1 < (unsigned int)a1; v1 += 1) {\n    if (!(a3[v1] <= 0 || a2[v1] >= a3[v1])) {\n      v2 = v1;\n      break;\n    }\n  }\n  if (v2 == -1)\n    return v2;\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    v5 = *((int *)(5 * v2 * 4 + a0 + a2[v2] * 4));\n    if (v5 > *((int *)(5 * v0 * 4 + a0 + a2[v0] * 4)) && a2[v0] < a3[v0])\n      v2 = v0;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"int comprimento(char *string) {\n    unsigned int quantidade = 0;\n    while (*string != '\\x00')\n        {\n            quantidade++;\n            string++;\n        }\n    return quantidade;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long comprimento_name_conflict(char *a0) {\n  char *v0;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0;\n  for (v1 = 0; *((char *)v0); v0 += 1) {\n    v1 += 1;\n  }\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"char *maiuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96) {\n            *string -= 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(comprimento)(long long);\n\nlong long maiuscula_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0x10]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v0 = a0;\n  v1 = comprimento(v0);\n  for (v2 = 0; v2 < v1; v0 += 1) {\n    if (*(v0) > 96)\n      *(v0) = *(v0)-32;\n    v2 += 1;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"char *intercala(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    bool foi = 0;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96 && *string < 123) {\n            if (!foi) {\n                *string -= 32;\n                foi = 1;\n            } else {\n                foi = 0;\n            }\n        }\n    }\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(comprimento)(long long);\n\nlong long intercala_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0x14]\n  char v2;               // [bp-0xd]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v0 = a0;\n  v1 = comprimento(v0);\n  v2 = 0;\n  for (v3 = 0; v3 < v1; v0 += 1) {\n    if (*((char *)v0) > 96 && *((char *)v0) <= 122) {\n      if ((char)(v2 ^ 1)) {\n        *((char *)v0) = *((char *)v0) - 32;\n        v2 = 1;\n      } else {\n        v2 = 0;\n      }\n    }\n    v3 += 1;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"char *minuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string < 91 && *string > 64) {\n            *string += 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(comprimento)(long long);\n\nlong long minuscula_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0x10]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v0 = a0;\n  v1 = comprimento(v0);\n  for (v2 = 0; v2 < v1; v0 += 1) {\n    if (*(v0) <= 90 && *(v0) > 64)\n      *(v0) = *(v0) + 32;\n    v2 += 1;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"int jogar(int ev1, int ev2, int at, int d) {\n    int dado, ganhador;\n    while (ev1 > 0 && ev2 > 0)\n        {\n            dado = aleatorio();\n            if (dado <= at) {\n                ev1 += d;\n                ev2 -= d;\n            } else {\n                ev1 -= d;\n                ev2 += d;\n            }\n            printf(\"Dado %d EV1 %d EV2 %d\\n\", dado, ev1, ev2);\n        }\n    if (ev1 <= 0) {\n        ganhador = 2;\n    } else {\n        ganhador = 1;\n    }\n    return ganhador;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(aleatorio)();\n\nlong long jogar(unsigned long a0, unsigned long a1, unsigned long a2,\n                unsigned long a3) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v1 = a0;\n  v0 = a1;\n  while (v1 > 0 && v0 > 0) {\n    v2 = aleatorio();\n    if (v2 > (unsigned int)a2) {\n      v1 -= (unsigned int)a3;\n      v0 += (unsigned int)a3;\n    } else {\n      v1 += (unsigned int)a3;\n      v0 -= (unsigned int)a3;\n    }\n    printf(\"Dado %d EV1 %d EV2 %d\\n\", v2, v1, v0);\n  }\n  if (v1 > 0) {\n    v3 = 1;\n    return v3;\n  }\n  v3 = 2;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":0,"function":"int aleatorio() {\n    srand(time(((void *)0)));\n    return rand() % 6 + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nvoid(srand)(unsigned int);\nint(rand)();\n\nlong long aleatorio_name_conflict() {\n  unsigned long long v1; // rax\n\n  srand(time(NULL));\n  (unsigned int)v1 = rand();\n  return v1 - 3 * (unsigned int)(v1 / 6 - (v1 >> 31)) * 2 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3kcny51d/aleatorio_name_conflict.c:25:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 25 |     (unsigned int)v1 = rand(); | ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x1c]\n  unsigned long v2;       // [bp-0x10]\n  char v3;                // [bp-0x8]\n  unsigned long long v5;  // rbp\n  unsigned long v6;       // rbx\n  unsigned long long v7;  // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = calloc(3, 8);\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    v0[v1] = calloc(3, 4);\n  }\n  v7 = v2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long long *a0) {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x20]\n  unsigned int v2;        // [bp-0x1c]\n  unsigned long v3;       // [bp-0x10]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v0 = calloc(3, 8);\n  for (v2 = 0; v2 <= 2; v2 += 1) {\n    v0[v2] = calloc(3, 4);\n    for (v1 = 0; v1 <= 2; v1 += 1) {\n      *((int *)(v0[v2] + v1 * 4)) = *((int *)(a0[v2] + v1 * 4));\n    }\n  }\n  v8 = v3;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v0;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long *v1; // [bp-0x18]\n  unsigned int v2;        // [bp-0x10]\n  unsigned int v3;        // [bp-0xc]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned int v7;        // eax\n\n  v6 = &v4;\n  v0 = a0;\n  v1 = new_board();\n  for (v3 = 0; v3 <= 2; v3 += 1) {\n    for (v2 = 0; v2 <= 2; v2 += 1) {\n      v7 = *((char *)v0);\n      if (v7 == 88) {\n        *((int *)(v1[v3] + v2 * 4)) = 1;\n      } else if (v7 <= 88) {\n        if (v7 == 45) {\n          *((int *)(v1[v3] + v2 * 4)) = 0;\n        } else if (v7 == 79) {\n          *((int *)(v1[v3] + v2 * 4)) = 2;\n        }\n      }\n      v0 += 1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(unsigned long long *a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v5; // eax\n\n  v3 = 0;\n  v2 = 0;\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    for (v0 = 0; v0 <= 2; v0 += 1) {\n      v5 = *((int *)(a0[v1] + v0 * 4));\n      if (v5 == 1) {\n        v3 += 1;\n      } else if (v5 == 2) {\n        v2 += 1;\n      }\n    }\n  }\n  return_name_conflict (v3 + v2 == 9 ? (v2 < v3 ? 1 : 2) : 0);\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = turn(a0);\n  v0 = clone(a0);\n  *((unsigned int *)((unsigned int)a2 * 4 +\n                     *((long long *)(v0 + (unsigned int)a1 * 8)))) = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_2 *field_0;\n  struct struct_0 *field_8;\n  struct struct_3 *field_10;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\ntypedef struct struct_3 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_3;\n\nlong long winner_name_conflict(struct_1 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 2; v0 += 1) {\n    if ((&a0->field_0)[v0]->field_0 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_4 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_8)\n      return (&a0->field_0)[v0]->field_0;\n    if ((&a0->field_0->field_0)[v0] &&\n        (&a0->field_0->field_0)[v0] ==\n            *((int *)&(&a0->field_8->padding_0)[v0]) &&\n        (&a0->field_0->field_0)[v0] == (&a0->field_10->field_0)[v0])\n      return (&a0->field_0->field_0)[v0];\n  }\n  if (a0->field_0->field_0 && a0->field_0->field_0 == a0->field_8->field_4 &&\n      a0->field_0->field_0 == a0->field_10->field_8)\n    return a0->field_0->field_0;\n  if (a0->field_10->field_0 && a0->field_10->field_0 == a0->field_8->field_4 &&\n      a0->field_10->field_0 == a0->field_0->field_8)\n    return a0->field_10->field_0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu_name_conflict)(unsigned long long *);\n\nlong long cpu_name_conflict(unsigned long long *a0) {\n  unsigned int v0;        // [bp-0x2c]\n  unsigned int v1;        // [bp-0x28]\n  unsigned int v2;        // [bp-0x24]\n  unsigned long long v3;  // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10]\n  unsigned int v7;        // [bp-0xc]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long long v11; // rdx\n  unsigned long long v14; // rdx\n  unsigned long long v15; // rdx\n\n  v10 = &v8;\n  v4 = turn(a0);\n  v7 = -9;\n  for (v6 = 0; v6 <= 2; v6 += 1) {\n    for (v5 = 0; v5 <= 2; v5 += 1) {\n      if (!*((int *)(a0[v6] + (v5 << 2)))) {\n        v3 = move(a0, v6, v5);\n        v2 = winner(v3);\n        if (v2 == v4) {\n          v15 = v6;\n          return v5 + (unsigned int)v15 * 2 + v15 + 18;\n        } else if ((int)turn(v3)) {\n          v1 = cpu_name_conflict(v3);\n          v0 = (unsigned int)((v1 >> 31) - (v1 * 954437177 >> 33)) + 2;\n          if (v0 > (unsigned int)((v7 * 954437177 >> 33) - (v7 >> 31))) {\n            v14 = v6;\n            v7 = v5 + 9 * v0 + (unsigned int)v14 * 2 + v14;\n          }\n        } else if (v7 <= 8) {\n          v11 = v6;\n          v7 = v5 + (unsigned int)v11 * 2 + v11 + 9;\n        }\n      }\n    }\n  }\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x1c]\n  unsigned long v2;       // [bp-0x10]\n  char v3;                // [bp-0x8]\n  unsigned long long v5;  // rbp\n  unsigned long v6;       // rbx\n  unsigned long long v7;  // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = calloc(3, 8);\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    v0[v1] = calloc(3, 4);\n  }\n  v7 = v2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long long *a0) {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x20]\n  unsigned int v2;        // [bp-0x1c]\n  unsigned long v3;       // [bp-0x10]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v0 = calloc(3, 8);\n  for (v2 = 0; v2 <= 2; v2 += 1) {\n    v0[v2] = calloc(3, 4);\n    for (v1 = 0; v1 <= 2; v1 += 1) {\n      *((int *)(v0[v2] + v1 * 4)) = *((int *)(a0[v2] + v1 * 4));\n    }\n  }\n  v8 = v3;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v0;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long *v1; // [bp-0x18]\n  unsigned int v2;        // [bp-0x10]\n  unsigned int v3;        // [bp-0xc]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned int v7;        // eax\n\n  v6 = &v4;\n  v0 = a0;\n  v1 = new_board();\n  for (v3 = 0; v3 <= 2; v3 += 1) {\n    for (v2 = 0; v2 <= 2; v2 += 1) {\n      v7 = *((char *)v0);\n      if (v7 == 88) {\n        *((int *)(v1[v3] + v2 * 4)) = 1;\n      } else if (v7 <= 88) {\n        if (v7 == 45) {\n          *((int *)(v1[v3] + v2 * 4)) = 0;\n        } else if (v7 == 79) {\n          *((int *)(v1[v3] + v2 * 4)) = 2;\n        }\n      }\n      v0 += 1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(unsigned long long *a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v5; // eax\n\n  v3 = 0;\n  v2 = 0;\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    for (v0 = 0; v0 <= 2; v0 += 1) {\n      v5 = *((int *)(a0[v1] + v0 * 4));\n      if (v5 == 1) {\n        v3 += 1;\n      } else if (v5 == 2) {\n        v2 += 1;\n      }\n    }\n  }\n  return_name_conflict (v3 + v2 == 9 ? (v2 < v3 ? 1 : 2) : 0);\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = turn(a0);\n  v0 = clone(a0);\n  *((unsigned int *)((unsigned int)a2 * 4 +\n                     *((long long *)(v0 + (unsigned int)a1 * 8)))) = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_2 *field_0;\n  struct struct_0 *field_8;\n  struct struct_3 *field_10;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\ntypedef struct struct_3 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_3;\n\nlong long winner_name_conflict(struct_1 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 2; v0 += 1) {\n    if ((&a0->field_0)[v0]->field_0 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_4 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_8)\n      return (&a0->field_0)[v0]->field_0;\n    if ((&a0->field_0->field_0)[v0] &&\n        (&a0->field_0->field_0)[v0] ==\n            *((int *)&(&a0->field_8->padding_0)[v0]) &&\n        (&a0->field_0->field_0)[v0] == (&a0->field_10->field_0)[v0])\n      return (&a0->field_0->field_0)[v0];\n  }\n  if (a0->field_0->field_0 && a0->field_0->field_0 == a0->field_8->field_4 &&\n      a0->field_0->field_0 == a0->field_10->field_8)\n    return a0->field_0->field_0;\n  if (a0->field_10->field_0 && a0->field_10->field_0 == a0->field_8->field_4 &&\n      a0->field_10->field_0 == a0->field_0->field_8)\n    return a0->field_10->field_0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu_name_conflict)(unsigned long long *);\n\nlong long cpu_name_conflict(unsigned long long *a0) {\n  unsigned int v0;        // [bp-0x2c]\n  unsigned int v1;        // [bp-0x28]\n  unsigned int v2;        // [bp-0x24]\n  unsigned long long v3;  // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10]\n  unsigned int v7;        // [bp-0xc]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long long v11; // rdx\n  unsigned long long v14; // rdx\n  unsigned long long v15; // rdx\n\n  v10 = &v8;\n  v4 = turn(a0);\n  v7 = -9;\n  for (v6 = 0; v6 <= 2; v6 += 1) {\n    for (v5 = 0; v5 <= 2; v5 += 1) {\n      if (!*((int *)(a0[v6] + (v5 << 2)))) {\n        v3 = move(a0, v6, v5);\n        v2 = winner(v3);\n        if (v2 == v4) {\n          v15 = v6;\n          return v5 + (unsigned int)v15 * 2 + v15 + 18;\n        } else if ((int)turn(v3)) {\n          v1 = cpu_name_conflict(v3);\n          v0 = (unsigned int)((v1 >> 31) - (v1 * 954437177 >> 33)) + 2;\n          if (v0 > (unsigned int)((v7 * 954437177 >> 33) - (v7 >> 31))) {\n            v14 = v6;\n            v7 = v5 + 9 * v0 + (unsigned int)v14 * 2 + v14;\n          }\n        } else if (v7 <= 8) {\n          v11 = v6;\n          v7 = v5 + (unsigned int)v11 * 2 + v11 + 9;\n        }\n      }\n    }\n  }\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x1c]\n  unsigned long v2;       // [bp-0x10]\n  char v3;                // [bp-0x8]\n  unsigned long long v5;  // rbp\n  unsigned long v6;       // rbx\n  unsigned long long v7;  // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = calloc(3, 8);\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    v0[v1] = calloc(3, 4);\n  }\n  v7 = v2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long long *a0) {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x20]\n  unsigned int v2;        // [bp-0x1c]\n  unsigned long v3;       // [bp-0x10]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v0 = calloc(3, 8);\n  for (v2 = 0; v2 <= 2; v2 += 1) {\n    v0[v2] = calloc(3, 4);\n    for (v1 = 0; v1 <= 2; v1 += 1) {\n      *((int *)(v0[v2] + v1 * 4)) = *((int *)(a0[v2] + v1 * 4));\n    }\n  }\n  v8 = v3;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v0;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long *v1; // [bp-0x18]\n  unsigned int v2;        // [bp-0x10]\n  unsigned int v3;        // [bp-0xc]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned int v7;        // eax\n\n  v6 = &v4;\n  v0 = a0;\n  v1 = new_board();\n  for (v3 = 0; v3 <= 2; v3 += 1) {\n    for (v2 = 0; v2 <= 2; v2 += 1) {\n      v7 = *((char *)v0);\n      if (v7 == 88) {\n        *((int *)(v1[v3] + v2 * 4)) = 1;\n      } else if (v7 <= 88) {\n        if (v7 == 45) {\n          *((int *)(v1[v3] + v2 * 4)) = 0;\n        } else if (v7 == 79) {\n          *((int *)(v1[v3] + v2 * 4)) = 2;\n        }\n      }\n      v0 += 1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(unsigned long long *a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v5; // eax\n\n  v3 = 0;\n  v2 = 0;\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    for (v0 = 0; v0 <= 2; v0 += 1) {\n      v5 = *((int *)(a0[v1] + v0 * 4));\n      if (v5 == 1) {\n        v3 += 1;\n      } else if (v5 == 2) {\n        v2 += 1;\n      }\n    }\n  }\n  return_name_conflict (v3 + v2 == 9 ? (v2 < v3 ? 1 : 2) : 0);\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = turn(a0);\n  v0 = clone(a0);\n  *((unsigned int *)((unsigned int)a2 * 4 +\n                     *((long long *)(v0 + (unsigned int)a1 * 8)))) = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_2 *field_0;\n  struct struct_0 *field_8;\n  struct struct_3 *field_10;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\ntypedef struct struct_3 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_3;\n\nlong long winner_name_conflict(struct_1 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 2; v0 += 1) {\n    if ((&a0->field_0)[v0]->field_0 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_4 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_8)\n      return (&a0->field_0)[v0]->field_0;\n    if ((&a0->field_0->field_0)[v0] &&\n        (&a0->field_0->field_0)[v0] ==\n            *((int *)&(&a0->field_8->padding_0)[v0]) &&\n        (&a0->field_0->field_0)[v0] == (&a0->field_10->field_0)[v0])\n      return (&a0->field_0->field_0)[v0];\n  }\n  if (a0->field_0->field_0 && a0->field_0->field_0 == a0->field_8->field_4 &&\n      a0->field_0->field_0 == a0->field_10->field_8)\n    return a0->field_0->field_0;\n  if (a0->field_10->field_0 && a0->field_10->field_0 == a0->field_8->field_4 &&\n      a0->field_10->field_0 == a0->field_0->field_8)\n    return a0->field_10->field_0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu_name_conflict)(unsigned long long *);\n\nlong long cpu_name_conflict(unsigned long long *a0) {\n  unsigned int v0;        // [bp-0x2c]\n  unsigned int v1;        // [bp-0x28]\n  unsigned int v2;        // [bp-0x24]\n  unsigned long long v3;  // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10]\n  unsigned int v7;        // [bp-0xc]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long long v11; // rdx\n  unsigned long long v14; // rdx\n  unsigned long long v15; // rdx\n\n  v10 = &v8;\n  v4 = turn(a0);\n  v7 = -9;\n  for (v6 = 0; v6 <= 2; v6 += 1) {\n    for (v5 = 0; v5 <= 2; v5 += 1) {\n      if (!*((int *)(a0[v6] + (v5 << 2)))) {\n        v3 = move(a0, v6, v5);\n        v2 = winner(v3);\n        if (v2 == v4) {\n          v15 = v6;\n          return v5 + (unsigned int)v15 * 2 + v15 + 18;\n        } else if ((int)turn(v3)) {\n          v1 = cpu_name_conflict(v3);\n          v0 = (unsigned int)((v1 >> 31) - (v1 * 954437177 >> 33)) + 2;\n          if (v0 > (unsigned int)((v7 * 954437177 >> 33) - (v7 >> 31))) {\n            v14 = v6;\n            v7 = v5 + 9 * v0 + (unsigned int)v14 * 2 + v14;\n          }\n        } else if (v7 <= 8) {\n          v11 = v6;\n          v7 = v5 + (unsigned int)v11 * 2 + v11 + 9;\n        }\n      }\n    }\n  }\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x1c]\n  unsigned long v2;       // [bp-0x10]\n  char v3;                // [bp-0x8]\n  unsigned long long v5;  // rbp\n  unsigned long v6;       // rbx\n  unsigned long long v7;  // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = calloc(3, 8);\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    v0[v1] = calloc(3, 4);\n  }\n  v7 = v2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long long *a0) {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x20]\n  unsigned int v2;        // [bp-0x1c]\n  unsigned long v3;       // [bp-0x10]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v0 = calloc(3, 8);\n  for (v2 = 0; v2 <= 2; v2 += 1) {\n    v0[v2] = calloc(3, 4);\n    for (v1 = 0; v1 <= 2; v1 += 1) {\n      *((int *)(v0[v2] + v1 * 4)) = *((int *)(a0[v2] + v1 * 4));\n    }\n  }\n  v8 = v3;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v0;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long *v1; // [bp-0x18]\n  unsigned int v2;        // [bp-0x10]\n  unsigned int v3;        // [bp-0xc]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned int v7;        // eax\n\n  v6 = &v4;\n  v0 = a0;\n  v1 = new_board();\n  for (v3 = 0; v3 <= 2; v3 += 1) {\n    for (v2 = 0; v2 <= 2; v2 += 1) {\n      v7 = *((char *)v0);\n      if (v7 == 88) {\n        *((int *)(v1[v3] + v2 * 4)) = 1;\n      } else if (v7 <= 88) {\n        if (v7 == 45) {\n          *((int *)(v1[v3] + v2 * 4)) = 0;\n        } else if (v7 == 79) {\n          *((int *)(v1[v3] + v2 * 4)) = 2;\n        }\n      }\n      v0 += 1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(unsigned long long *a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v5; // eax\n\n  v3 = 0;\n  v2 = 0;\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    for (v0 = 0; v0 <= 2; v0 += 1) {\n      v5 = *((int *)(a0[v1] + v0 * 4));\n      if (v5 == 1) {\n        v3 += 1;\n      } else if (v5 == 2) {\n        v2 += 1;\n      }\n    }\n  }\n  return_name_conflict (v3 + v2 == 9 ? (v2 < v3 ? 1 : 2) : 0);\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = turn(a0);\n  v0 = clone(a0);\n  *((unsigned int *)((unsigned int)a2 * 4 +\n                     *((long long *)(v0 + (unsigned int)a1 * 8)))) = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_2 *field_0;\n  struct struct_0 *field_8;\n  struct struct_3 *field_10;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\ntypedef struct struct_3 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_3;\n\nlong long winner_name_conflict(struct_1 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 2; v0 += 1) {\n    if ((&a0->field_0)[v0]->field_0 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_4 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_8)\n      return (&a0->field_0)[v0]->field_0;\n    if ((&a0->field_0->field_0)[v0] &&\n        (&a0->field_0->field_0)[v0] ==\n            *((int *)&(&a0->field_8->padding_0)[v0]) &&\n        (&a0->field_0->field_0)[v0] == (&a0->field_10->field_0)[v0])\n      return (&a0->field_0->field_0)[v0];\n  }\n  if (a0->field_0->field_0 && a0->field_0->field_0 == a0->field_8->field_4 &&\n      a0->field_0->field_0 == a0->field_10->field_8)\n    return a0->field_0->field_0;\n  if (a0->field_10->field_0 && a0->field_10->field_0 == a0->field_8->field_4 &&\n      a0->field_10->field_0 == a0->field_0->field_8)\n    return a0->field_10->field_0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu_name_conflict)(unsigned long long *);\n\nlong long cpu_name_conflict(unsigned long long *a0) {\n  unsigned int v0;        // [bp-0x2c]\n  unsigned int v1;        // [bp-0x28]\n  unsigned int v2;        // [bp-0x24]\n  unsigned long long v3;  // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10]\n  unsigned int v7;        // [bp-0xc]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long long v11; // rdx\n  unsigned long long v14; // rdx\n  unsigned long long v15; // rdx\n\n  v10 = &v8;\n  v4 = turn(a0);\n  v7 = -9;\n  for (v6 = 0; v6 <= 2; v6 += 1) {\n    for (v5 = 0; v5 <= 2; v5 += 1) {\n      if (!*((int *)(a0[v6] + (v5 << 2)))) {\n        v3 = move(a0, v6, v5);\n        v2 = winner(v3);\n        if (v2 == v4) {\n          v15 = v6;\n          return v5 + (unsigned int)v15 * 2 + v15 + 18;\n        } else if ((int)turn(v3)) {\n          v1 = cpu_name_conflict(v3);\n          v0 = (unsigned int)((v1 >> 31) - (v1 * 954437177 >> 33)) + 2;\n          if (v0 > (unsigned int)((v7 * 954437177 >> 33) - (v7 >> 31))) {\n            v14 = v6;\n            v7 = v5 + 9 * v0 + (unsigned int)v14 * 2 + v14;\n          }\n        } else if (v7 <= 8) {\n          v11 = v6;\n          v7 = v5 + (unsigned int)v11 * 2 + v11 + 9;\n        }\n      }\n    }\n  }\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x1c]\n  unsigned long v2;       // [bp-0x10]\n  char v3;                // [bp-0x8]\n  unsigned long long v5;  // rbp\n  unsigned long v6;       // rbx\n  unsigned long long v7;  // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = calloc(3, 8);\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    v0[v1] = calloc(3, 4);\n  }\n  v7 = v2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long long *a0) {\n  unsigned long long *v0; // [bp-0x28]\n  unsigned int v1;        // [bp-0x20]\n  unsigned int v2;        // [bp-0x1c]\n  unsigned long v3;       // [bp-0x10]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v0 = calloc(3, 8);\n  for (v2 = 0; v2 <= 2; v2 += 1) {\n    v0[v2] = calloc(3, 4);\n    for (v1 = 0; v1 <= 2; v1 += 1) {\n      *((int *)(v0[v2] + v1 * 4)) = *((int *)(a0[v2] + v1 * 4));\n    }\n  }\n  v8 = v3;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v0;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long *v1; // [bp-0x18]\n  unsigned int v2;        // [bp-0x10]\n  unsigned int v3;        // [bp-0xc]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned int v7;        // eax\n\n  v6 = &v4;\n  v0 = a0;\n  v1 = new_board();\n  for (v3 = 0; v3 <= 2; v3 += 1) {\n    for (v2 = 0; v2 <= 2; v2 += 1) {\n      v7 = *((char *)v0);\n      if (v7 == 88) {\n        *((int *)(v1[v3] + v2 * 4)) = 1;\n      } else if (v7 <= 88) {\n        if (v7 == 45) {\n          *((int *)(v1[v3] + v2 * 4)) = 0;\n        } else if (v7 == 79) {\n          *((int *)(v1[v3] + v2 * 4)) = 2;\n        }\n      }\n      v0 += 1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(unsigned long long *a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v5; // eax\n\n  v3 = 0;\n  v2 = 0;\n  for (v1 = 0; v1 <= 2; v1 += 1) {\n    for (v0 = 0; v0 <= 2; v0 += 1) {\n      v5 = *((int *)(a0[v1] + v0 * 4));\n      if (v5 == 1) {\n        v3 += 1;\n      } else if (v5 == 2) {\n        v2 += 1;\n      }\n    }\n  }\n  return_name_conflict (v3 + v2 == 9 ? (v2 < v3 ? 1 : 2) : 0);\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = turn(a0);\n  v0 = clone(a0);\n  *((unsigned int *)((unsigned int)a2 * 4 +\n                     *((long long *)(v0 + (unsigned int)a1 * 8)))) = v1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_2 *field_0;\n  struct struct_0 *field_8;\n  struct struct_3 *field_10;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\ntypedef struct struct_3 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_3;\n\nlong long winner_name_conflict(struct_1 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 2; v0 += 1) {\n    if ((&a0->field_0)[v0]->field_0 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_4 &&\n        (&a0->field_0)[v0]->field_0 == (&a0->field_0)[v0]->field_8)\n      return (&a0->field_0)[v0]->field_0;\n    if ((&a0->field_0->field_0)[v0] &&\n        (&a0->field_0->field_0)[v0] ==\n            *((int *)&(&a0->field_8->padding_0)[v0]) &&\n        (&a0->field_0->field_0)[v0] == (&a0->field_10->field_0)[v0])\n      return (&a0->field_0->field_0)[v0];\n  }\n  if (a0->field_0->field_0 && a0->field_0->field_0 == a0->field_8->field_4 &&\n      a0->field_0->field_0 == a0->field_10->field_8)\n    return a0->field_0->field_0;\n  if (a0->field_10->field_0 && a0->field_10->field_0 == a0->field_8->field_4 &&\n      a0->field_10->field_0 == a0->field_0->field_8)\n    return a0->field_10->field_0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu_name_conflict)(unsigned long long *);\n\nlong long cpu_name_conflict(unsigned long long *a0) {\n  unsigned int v0;        // [bp-0x2c]\n  unsigned int v1;        // [bp-0x28]\n  unsigned int v2;        // [bp-0x24]\n  unsigned long long v3;  // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10]\n  unsigned int v7;        // [bp-0xc]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long long v11; // rdx\n  unsigned long long v14; // rdx\n  unsigned long long v15; // rdx\n\n  v10 = &v8;\n  v4 = turn(a0);\n  v7 = -9;\n  for (v6 = 0; v6 <= 2; v6 += 1) {\n    for (v5 = 0; v5 <= 2; v5 += 1) {\n      if (!*((int *)(a0[v6] + (v5 << 2)))) {\n        v3 = move(a0, v6, v5);\n        v2 = winner(v3);\n        if (v2 == v4) {\n          v15 = v6;\n          return v5 + (unsigned int)v15 * 2 + v15 + 18;\n        } else if ((int)turn(v3)) {\n          v1 = cpu_name_conflict(v3);\n          v0 = (unsigned int)((v1 >> 31) - (v1 * 954437177 >> 33)) + 2;\n          if (v0 > (unsigned int)((v7 * 954437177 >> 33) - (v7 >> 31))) {\n            v14 = v6;\n            v7 = v5 + 9 * v0 + (unsigned int)v14 * 2 + v14;\n          }\n        } else if (v7 <= 8) {\n          v11 = v6;\n          v7 = v5 + (unsigned int)v11 * 2 + v11 + 9;\n        }\n      }\n    }\n  }\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int init_net(char *address, char *port, int *sock) {\n    int s, v, i;\n    struct addrinfo hints, *result, *rp;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = 0;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = 1 | 4;\n    hints.ai_protocol = IPPROTO_IP;\n    if ((s = getaddrinfo(address, port, &hints, &result)) != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n        exit(1);\n    }\n    for (rp = result , i = 0; rp != ((void *)0) && i < 2; rp = rp->ai_next , ++i) {\n        sock[i] = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if (sock[i] == -1) {\n            perror(\"socket\");\n            continue;\n        }\n        v = 1;\n        if (setsockopt(sock[i], 1, 2, &v, sizeof (v)) < 0) {\n            perror(\"setsockopt\");\n            return -1;\n        }\n        if (bind(sock[i], rp->ai_addr, rp->ai_addrlen) < 0) {\n            perror(\"socket\");\n            return -1;\n        }\n        if (listen(sock[i], 5) < 0) {\n            perror(\"listen\");\n            return -1;\n        }\n    }\n    freeaddrinfo(result);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nvoid(perror)(char *);\nint(setsockopt)(int, int, int, void *, int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(listen)(int, int);\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n  unsigned int field_8;\n  unsigned int field_c;\n  unsigned int field_10;\n  char padding_14[4];\n  struct sockaddr *field_18;\n  char padding_20[8];\n  struct struct_0 *field_28;\n} struct_0;\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long init_net(unsigned long long a0, unsigned long long a1,\n                   unsigned int *a2) {\n  char v0;         // [bp-0x70]\n  char v1;         // [bp-0x68], Other Possible Types: unsigned int\n  unsigned int v2; // [bp-0x64]\n  unsigned int v3; // [bp-0x60]\n  unsigned int v4; // [bp-0x5c]\n  unsigned int v5; // [bp-0x30]\n  unsigned int v6; // [bp-0x2c]\n  struct_0 *v7;    // [bp-0x28], Other Possible Types: unsigned long\n  unsigned int v8; // [bp-0x1c]\n\n  memset(&v1, 0, 48);\n  v2 = 0;\n  v3 = 1;\n  v1 = 5;\n  v4 = 0;\n  v6 = getaddrinfo(a0, a1, &v1, &v0);\n  if (v6) {\n    fprintf(stderr @GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v6));\n    exit(1); /* do not return */\n  }\n  v7 = *((long long *)&v0);\n  for (v8 = 0; v7 && v8 <= 1; v8 += 1) {\n    a2[v8] = socket(v7->field_4, v7->field_8, v7->field_c);\n    if (a2[v8] == -1) {\n      perror(\"socket\");\n    } else {\n      v5 = 1;\n      if (setsockopt(a2[v8], 1, 2, &v5, 4) < 0) {\n        perror(\"setsockopt\");\n        return 4294967295;\n      } else if (bind(a2[v8], v7->field_18, v7->field_10) < 0) {\n        perror(\"socket\");\n        return 4294967295;\n      } else if (listen(a2[v8], 5) < 0) {\n        perror(\"listen\");\n        return 4294967295;\n      }\n    }\n    v7 = v7->field_28;\n  }\n  freeaddrinfo(*((long long *)&v0));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe3n5avbr/init_net.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpe3n5avbr/init_net.c:42:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 42 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpe3n5avbr/init_net.c:42:22: error: expected ';' after top level\ndeclarator 42 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpe3n5avbr/init_net.c:64:23: error: expected ')'\n   64 |         fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\",\ngai_strerror(v6)); |                       ^ /tmp/tmpe3n5avbr/init_net.c:64:16:\nnote: to match this '(' 64 |         fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo:\n%s\\n\", gai_strerror(v6)); |                ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":0,"function":"int sockaddr2string(struct sockaddr *sa, char *address) {\n    struct sockaddr_in *server;\n    struct sockaddr_in6 *server6;\n    if (sa->sa_family == 2) {\n        server = (struct sockaddr_in *)sa;\n        if (inet_ntop(sa->sa_family, &(server->sin_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    } else {\n        server6 = (struct sockaddr_in6 *)sa;\n        if (inet_ntop(sa->sa_family, &(server6->sin6_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntop)(int, void *, char *, int);\nvoid(perror)(char *);\n\nlong long sockaddr2string_name_conflict(unsigned short *a0, char *a1) {\n  unsigned short *v0; // [bp-0x18]\n  unsigned short *v1; // [bp-0x10]\n\n  if (*(a0) != 2) {\n    v1 = a0;\n    if (!inet_ntop(*(a0), v1 + 4, a1, 46)) {\n      perror(\"inet_ntop\");\n      return 4294967295;\n    }\n  } else {\n    v0 = a0;\n    if (!inet_ntop(*(a0), v0 + 2, a1, 46)) {\n      perror(\"inet_ntop\");\n      return 4294967295;\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpllu7mr6q/sockaddr2string_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":0,"function":"int is_number(char *str) {\n    int i;\n    int len = strlen(str);\n    for (i = 0; i < len; ++i)\n        if (!((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit))\n            return 0;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_number_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned int v6;       // eax\n\n  v4 = &v2;\n  v0 = strlen(a0);\n  for (v1 = 0; v1 < v0; v1 += 1) {\n    v6 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v1] * 2)) & 0x800;\n    if (!v6)\n      return 0;\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkqyqa4zh/is_number_name_conflict.c:29:41: error: cannot take the address of an rvalue\nof type 'int' 29 |         v6 = *((short *)(*((long long *)&__ctype_b_loc()) +\na0[v1] * 2)) & 0x800; |                                         ^~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/main.c"}
{"compilable":0,"function":"int q_isEmpty(enum_q_type t) {\n    int ret = 0;\n    pthread_mutex_t *mutex = ((void *)0);\n    _task_queue_entry **head = ((void *)0);\n    if (t == TASK) {\n        mutex = &task_mutex;\n        head = &task_head;\n    } else if (t == RESPONSE) {\n        mutex = &response_mutex;\n        head = &response_head;\n    } else {\n        return 1;\n    }\n    pthread_mutex_lock(mutex);\n    ret = *head == ((void *)0) ? 1 : 0;\n    pthread_mutex_unlock(mutex);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(pthread_mutex_lock)(char *);\nchar *(pthread_mutex_unlock)(char *);\n\nextern unsigned long long response_head;\nextern char response_mutex;\nextern unsigned long long task_head;\nextern char task_mutex;\n\nlong long q_isEmpty_name_conflict(unsigned long a0) {\n  unsigned int v0;        // [bp-0x1c]\n  unsigned long long *v1; // [bp-0x18], Other Possible Types: unsigned long\n  char *v2; // [bp-0x10], Other Possible Types: unsigned long, void*\n\n  v0 = 0;\n  v2 = 0;\n  v1 = 0;\n  if (!(unsigned int)a0) {\n    v2 = &task_mutex;\n    v1 = &task_head;\n  } else if ((unsigned int)a0 == 1) {\n    v2 = &response_mutex;\n    v1 = &response_head;\n  } else {\n    return 1;\n  }\n  pthread_mutex_lock(v2);\n  v0 = !*((long long *)v1);\n  pthread_mutex_unlock(v2);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/task_queue.c"}
{"compilable":0,"function":"int init_epoll(int sock) {\n    int epfd;\n    struct epoll_event ev;\n    if ((epfd = epoll_create(100)) < 0) {\n        perror(\"epoll_create\");\n        return -1;\n    }\n    ev.events = EPOLLIN | EPOLLET;\n    ev.data.fd = sock;\n    if (epoll_ctl(epfd, 1, sock, &ev) < 0) {\n        perror(\"epoll_ctl\");\n        return -1;\n    }\n    return epfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(perror)(char *);\n\nlong long init_epoll_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = epoll_create(100);\n  if (v2 < 0) {\n    perror(\"epoll_create\");\n    return 4294967295;\n  }\n  v0 = 2147483649;\n  v1 = a0;\n  if (epoll_ctl(v2, 1, (unsigned int)a0, &v0) >= 0)\n    return v2;\n  perror(\"epoll_ctl\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph04k3wyo/init_epoll_name_conflict.c:16:7: error: conflicting types for 'perror'\n   16 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/main.c"}
{"compilable":0,"function":"int setnonblocking(int fd) {\n    int flags = fcntl(fd, 3, 0);\n    if (flags < 0) {\n        return -1;\n    }\n    if (fcntl(fd, 4, flags | 2048) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long setnonblocking_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = fcntl(a0, 3);\n  return (v1 < 0 ? (fcntl(*((int *)&v0), 4) == -1 ? 0 : 4294967295)\n                 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/util.c"}
{"compilable":0,"function":"int spawn(char *program, char **arg_list) {\n    pid_t child_pid;\n    child_pid = fork();\n    if (child_pid != 0)\n        return child_pid;\n    else {\n        execvp(program, arg_list);\n        fprintf(stderr, \"an error occurred in execvp\\n\");\n        abort();\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(execvp)(char *, char *[0]);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long spawn_name_conflict(char *a0, char *a1[0]) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = fork();\n  if (v0)\n    return v0;\n  execvp(a0, a1);\n  fwrite(\"an error occurred in execvp\\n\", 1, 28, stderr @GLIBC_2.2.5);\n  abort(); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbfn3k2mc/spawn_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpbfn3k2mc/spawn_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpbfn3k2mc/spawn_name_conflict.c:29:58: error: expected ')'\n   29 |     fwrite(\"an error occurred in execvp\\n\", 1, 28, stderr@GLIBC_2.2.5);\n      |                                                          ^\n/tmp/tmpbfn3k2mc/spawn_name_conflict.c:29:11: note: to match this '('\n   29 |     fwrite(\"an error occurred in execvp\\n\", 1, 28, stderr@GLIBC_2.2.5);\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap03/fork-exec.c"}
{"compilable":0,"function":"int f() {\n    return 3;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n\nlong long f_name_conflict() { return 3; }\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap02/test.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *copy = strdup(s);\n    if (copy == ((void *)0))\n        abort();\n    else\n        return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0)\n    abort(); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":0,"function":"char *get_self_executable_directory() {\n    int rval;\n    char link_target[1024];\n    char *last_slash;\n    size_t result_length;\n    char *result;\n    rval = readlink(\"/proc/self/exe\", link_target, sizeof (link_target));\n    if (rval == -1)\n        abort();\n    else\n        link_target[rval] = '\\x00';\n    last_slash = strrchr(link_target, '/');\n    if (last_slash == ((void *)0) || last_slash == link_target)\n        abort();\n    result_length = last_slash - link_target;\n    result = (char *)xmalloc(result_length + 1);\n    strncpy(result, link_target, result_length);\n    result[result_length] = '\\x00';\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long get_self_executable_directory_name_conflict() {\n  char v0;          // [bp-0x428]\n  unsigned long v1; // [bp-0x28]\n  char *v2;         // [bp-0x20]\n  unsigned long v3; // [bp-0x18]\n  unsigned int v4;  // [bp-0xc]\n\n  v4 = readlink(\"/proc/self/exe\", &v0, 0x400);\n  if (v4 == -1)\n    abort(); /* do not return */\n  (&v0)[v4] = 0;\n  v3 = strrchr(&v0, 47);\n  if (!(v3 && v3 != &v0))\n    abort(); /* do not return */\n  v2 = v3 - &v0;\n  v1 = xmalloc(v2 + 1);\n  strncpy(v1, &v0, v2);\n  v2[v1] = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9l7r5oem/get_self_executable_directory_name_conflict.c:35:13: error: invalid operands\nto binary expression ('unsigned long' and 'char *') 35 |     v2 = v3 - &v0; | ~~\n^ ~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":0,"function":"ipstats_t *ip_get(char *ip_txt) {\n    unsigned int ip;\n    ipstats_t *l;\n    int p[4];\n    sscanf(ip_txt, \"%d.%d.%d.%d\", p + 0, p + 1, p + 2, p + 3);\n    ip = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3]);\n    for (l = ipstats; l; l = l->next) {\n        if (l->ip == ip) {\n            return (l);\n        }\n    }\n    if (ipstats) {\n        for (l = ipstats; l->next; l = l->next) {\n            ;\n        }\n        l->next = malloc(sizeof(ipstats_t));\n        l = l->next;\n    } else {\n        l = malloc(sizeof(ipstats_t));\n        ipstats = l;\n    }\n    memset(l, 0, sizeof(ipstats_t));\n    l->ip = ip;\n    return (l);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[28];\n  struct struct_0 *field_20;\n} struct_0;\n\nextern struct_0 *ipstats;\n\nlong long ip_get_name_conflict(char *a0) {\n  char v0;         // [bp-0x28]\n  char v1;         // [bp-0x24]\n  char v2;         // [bp-0x20]\n  char v3;         // [bp-0x1c]\n  unsigned int v4; // [bp-0x14]\n  struct_0 *v5;    // [bp-0x10], Other Possible Types: unsigned long\n\n  __isoc99_sscanf(a0, \"%d.%d.%d.%d\", (unsigned int)&v0, (unsigned int)&v1,\n                  (unsigned int)&v2, (unsigned int)&v3);\n  v4 = *((int *)&v3) | *((int *)&v0) * 0x1000000 | *((int *)&v1) * 0x10000 |\n       *((int *)&v2) * 0x100;\n  for (v5 = ipstats; v5; v5 = v5->field_20) {\n    if (v4 == v5->field_0)\n      return v5;\n  }\n  if (!ipstats) {\n    v5 = malloc(40);\n    ipstats = v5;\n  } else {\n    for (v5 = ipstats; v5->field_20; v5 = v5->field_20)\n      ;\n    *((void **)(v5 + 32)) = malloc(40);\n    v5 = *((long long *)(v5 + 32));\n  }\n  memset(v5, 0, 40);\n  *((unsigned int *)v5) = v4;\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/meh_bitlbee/utils/bitlbeed.c"}
{"compilable":0,"function":"static int *get_arr() {\n    static int arr[50000] = {8};\n    return arr;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char arr.0;\n\nlong long get_arr_name_conflict() { return &arr.0; }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0sv1mxk3/get_arr_name_conflict.c:17:16: error: expected ';' after top level declarator\n   17 | extern char arr.0;\n      |                ^\n      |                ;\n/tmp/tmp0sv1mxk3/get_arr_name_conflict.c:21:16: error: expected ';' after return statement\n   21 |     return &arr.0;\n      |                ^\n      |                ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/array.c"}
{"compilable":0,"function":"static int pop() {\n    int val = heap[0];\n    heap[0] = heap[--sz];\n    heap[sz] = val;\n    heap_adjust(heap, sz, 0);\n    return val;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint heap; // add global variable by heuristics\nint heap; // add global variable by heuristics\nint heap; // add global variable by heuristics\nint heap; // add global variable by heuristics\nint heap; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(heap_adjust)(long long, long long, long long);\n\nextern struct_0 *heap;\nextern unsigned int sz;\n\nlong long pop_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = heap->field_0;\n  sz = sz - 1;\n  heap->field_0 = heap[sz].field_0;\n  heap[sz].field_0 = v0;\n  heap_adjust(heap, sz, 0);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf677xhqy/pop_name_conflict.c:23:8: error: unknown type name 'struct_0'; did you mean\n'struct'? 23 | extern struct_0 *heap; |        ^~~~~~~~ |        struct\n/tmp/tmpf677xhqy/pop_name_conflict.c:23:8: error: declaration of anonymous struct must be a\ndefinition /tmp/tmpf677xhqy/pop_name_conflict.c:30:16: error: member reference type 'int' is\nnot a pointer 30 |     v0 = heap->field_0; |          ~~~~  ^\n/tmp/tmpf677xhqy/pop_name_conflict.c:32:11: error: member reference type 'int' is not a\npointer 32 |     heap->field_0 = heap[sz].field_0; |     ~~~~  ^\n/tmp/tmpf677xhqy/pop_name_conflict.c:32:25: error: subscripted value is not an array, pointer,\nor vector 32 |     heap->field_0 = heap[sz].field_0; | ~~~~^~~\n/tmp/tmpf677xhqy/pop_name_conflict.c:33:9: error: subscripted value is not an array, pointer,\nor vector 33 |     heap[sz].field_0 = v0; |     ~~~~^~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/algorithms/heap_sort.c"}
{"compilable":0,"function":"QueryConnexionResponse callback_new_connexion(QueryConnexion *q) {\n    static int i;\n    static int iter = (int)(16 / 6);\n    for (i = 0; i < 16; i += iter) {\n        if (__anneau->connexion[i] == 0) {\n            break;\n        }\n    }\n    if (i > 16) {\n        for (i = 16; i >= 0; i--) {\n            if (__anneau->connexion[i] == 0) {\n                break;\n            }\n        }\n    }\n    QueryConnexionResponse r;\n    r.type = q->bot.pid;\n    r.pos = i;\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[12];\n  unsigned int field_c;\n} struct_0;\n\nextern unsigned long long __anneau;\nextern unsigned int i.4;\nextern unsigned int iter.3;\n\nlong long callback_new_connexion_name_conflict(struct_0 *a0) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0x10]\n\n  for (i.4 = 0; i.4 <= 15 &&\n                *((int *)(__anneau + (i.4 - 18446744073709551488 << 2) + 4));\n       i.4 = iter.3 + i.4)\n    ;\n  if (i.4 > 16) {\n    for (i.4 = 16; i.4 >= 0 &&\n                   *((int *)(__anneau + (i.4 - 18446744073709551488 << 2) + 4));\n         i.4 = i.4 - 1)\n      ;\n  }\n  v0 = a0->field_c;\n  v1 = i.4;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:23:22: error: expected ';' after top\nlevel declarator 23 | extern unsigned int i.4; |                      ^ | ;\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:24:25: error: expected ';' after top\nlevel declarator 24 | extern unsigned int iter.3; |                         ^ |\n; /tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:11: error: expected ';' in 'for'\nstatement specifier 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau +\n(i.4 - 18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); |           ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:14: error: expression is not\nassignable 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); |           ~~ ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:20: error: expected ')'\n   31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); |                    ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:9: note: to match this '('\n   31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); |         ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:95: error: expected ';' after\nexpression 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); | ^ | ;\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:98: error: expression is not\nassignable 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); | ~~ ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:104: error: expected ';' after\nexpression 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); | ^ | ;\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:110: error: expected ';' after\nexpression 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); | ^ | ;\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:31:112: error: extraneous ')' before\n';' 31 |     for (i.4 = 0; i.4 <= 15 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = iter.3 + i.4); | ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:32:10: error: expected ')'\n   32 |     if (i.4 > 16)\n      |          ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:32:8: note: to match this '('\n   32 |     if (i.4 > 16)\n      |        ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:15: error: expected ';' in 'for'\nstatement specifier 34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau +\n(i.4 - 18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); |               ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:18: error: expression is not\nassignable 34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); |               ~~ ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:25: error: expected ')'\n   34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); |                         ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:13: note: to match this '('\n   34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); |             ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:99: error: expected ';' after\nexpression 34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); | ^ | ;\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:102: error: expression is not\nassignable 34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); | ~~ ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:105: error: expected ';' after\nexpression 34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); | ^ | ;\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:34:111: error: extraneous ')' before\n';' 34 |         for (i.4 = 16; i.4 >= 0 && *((int *)(__anneau + (i.4 -\n18446744073709551488 << 2) + 4)); i.4 = i.4 - 1); | ^\n/tmp/tmpgs61dw05/callback_new_connexion_name_conflict.c:37:11: error: expected ';' after\nexpression 37 |     v1 = i.4; |           ^ |           ; 19 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int ya_til_des_robots_connectes() {\n    static int i;\n    for (i = 0; i < 6; i++) {\n        if (__anneau->connexion[i] != 0 && __anneau->connexion[i] != __pid) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long __anneau;\nextern unsigned int __pid;\nextern unsigned int i.2;\n\nlong long ya_til_des_robots_connectes_name_conflict() {\n  for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) {\n    if (*((int *)(__anneau + (i.2 - 18446744073709551488 << 2) + 4)) &&\n        *((int *)(__anneau + (i.2 - 18446744073709551488 << 2) + 4)) != __pid)\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:19:22: error: expected ';' after\ntop level declarator 19 | extern unsigned int i.2; |                      ^ | ;\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:11: error: expected ';' in\n'for' statement specifier 23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) | ^\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:14: error: expression is not\nassignable 23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) |           ~~ ^\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:20: error: expected ')'\n   23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1)\n      |                    ^\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:9: note: to match this '('\n   23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1)\n      |         ^\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:30: error: expected ';' after\nexpression 23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) | ^ | ;\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:33: error: expression is not\nassignable 23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) | ~~ ^\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:36: error: expected ';' after\nexpression 23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) | ^ | ;\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:42: error: expected ';' after\nexpression 23 |     for (i.2 = 0; i.2 <= 5; i.2 = i.2 + 1) | ^ | ;\n/tmp/tmpkg6y8hkb/ya_til_des_robots_connectes_name_conflict.c:23:42: error: expected expression\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if ((__anneau->cases[16 - 1]).p.etat == -1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint __anneau; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *__anneau;\n\nlong long puis_je_prendre_produit_name_conflict() {\n  return (__anneau->field_1fc == -1 ? 0 : 1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz2jqkwg0/puis_je_prendre_produit_name_conflict.c:18:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 18 | extern struct_0 *__anneau; | ^~~~~~~~ |\nstruct /tmp/tmpz2jqkwg0/puis_je_prendre_produit_name_conflict.c:18:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmpz2jqkwg0/puis_je_prendre_produit_name_conflict.c:22:23: error: member reference type\n'int' is not a pointer 22 |     return (__anneau->field_1fc == -1 ? 0 : 1); |\n~~~~~~~~  ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int nb_composants_restants() {\n    static int i, num;\n    for (i = 0 , num = 0; i < 4; i++) {\n        num += stockComposants[i];\n    }\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int i.1;\nextern unsigned int num.0;\nextern char stockComposants;\n\nlong long nb_composants_restants_name_conflict() {\n  i.1 = 0;\n  for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) {\n    num.0 = num.0 + *((int *)&(&stockComposants)[4 * i.1]);\n  }\n  return num.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:17:22: error: expected ';' after top\nlevel declarator 17 | extern unsigned int i.1; |                      ^ | ;\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:18:24: error: expected ';' after top\nlevel declarator 18 | extern unsigned int num.0; |                        ^ | ;\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:23:6: error: expected ';' after\nexpression 23 |     i.1 = 0; |      ^ |      ;\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:23:9: error: expression is not\nassignable 23 |     i.1 = 0; |      ~~ ^\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:13: error: expected ';' in 'for'\nstatement specifier 24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) | ^\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:16: error: expression is not\nassignable 24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) |             ~~ ^\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:22: error: expected ')'\n   24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1)\n      |                      ^\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:9: note: to match this '('\n   24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1)\n      |         ^\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:32: error: expected ';' after\nexpression 24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) | ^ | ;\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:35: error: expression is not\nassignable 24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) | ~~ ^\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:38: error: expected ';' after\nexpression 24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) | ^ | ;\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:44: error: expected ';' after\nexpression 24 |     for (num.0 = 0; i.1 <= 3; i.1 = i.1 + 1) | ^ | ;\n/tmp/tmpy83yan_v/nb_composants_restants_name_conflict.c:24:44: error: expected expression\n12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"static int has(char *array, char val) {\n    static int i;\n    for (i = 0; array[i]; i++) {\n        if (array[i] == val) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int i.8;\n\nlong long has_name_conflict(char *a0, unsigned long a1) {\n  for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1) {\n    if ((char)a1 == a0[i.8])\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ssyf5e_/has_name_conflict.c:17:22: error: expected ';' after top level declarator\n   17 | extern unsigned int i.8;\n      |                      ^\n      |                      ;\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:11: error: expected ';' in 'for' statement specifier\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |           ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:14: error: expression is not assignable\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |           ~~ ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:23: error: expected ']'\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                       ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:21: note: to match this '['\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                     ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:26: error: expected ')'\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                          ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:9: note: to match this '('\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |         ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:29: error: expected ';' after expression\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                             ^\n      |                             ;\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:32: error: expression is not assignable\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                             ~~ ^\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:35: error: expected ';' after expression\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                                   ^\n      |                                   ;\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:41: error: expected ';' after expression\n   21 |     for (i.8 = 0; a0[i.8]; i.8 = i.8 + 1)\n      |                                         ^\n      |                                         ;\n/tmp/tmp2ssyf5e_/has_name_conflict.c:21:41: error: expected expression\n10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_composant() {\n    if (has(bot.mode == NORMAL ? bot.prods : bot.prodsDegrades, (__anneau->cases[bot.pos]).c.num)) {\n        static int i;\n        i = ctoi((__anneau->cases[bot.pos]).c.num) - 1;\n        if (bot.stockComposants[i] < 3) {\n            if (bot.stockComposants[i] == (produits[i].nbComp - 1)) {\n                if (bot.stockProduits[i] == 0) {\n                    return 1;\n                }\n            } else {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(has)(long long, long long);\nlong long(ctoi)(long long);\n\nextern unsigned long long __anneau;\nextern unsigned int bot[4];\nextern unsigned int g_405188;\nextern unsigned int g_40518c;\nextern char g_405196;\nextern char g_40519a;\nextern unsigned int i.7;\nextern unsigned long long produits;\n\nlong long puis_je_prendre_composant_name_conflict() {\n  if ((int)has((g_40518c == 1 ? &g_40519a : &g_405196),\n               *((char *)(__anneau + (g_405188 << 5) + 8)))) {\n    i.7 = (int)ctoi(*((char *)(__anneau + g_405188 * 32 + 8))) - 1;\n    if (bot[8 + i.7] <= 2) {\n      if (bot[8 + i.7] !=\n          *((int *)(((i.7 << 2) + i.7 << 2) + produits + 4)) - 1) {\n        return 1;\n      } else if (!bot[12 + i.7]) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:25:22: error: expected ';' after\ntop level declarator 25 | extern unsigned int i.7; |                      ^ | ;\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:32:10: error: expected ';' after\nexpression 32 |         i.7 = (int)ctoi(*((char *)(__anneau + g_405188 * 32 +\n8))) - 1; |          ^ |          ;\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:32:13: error: expression is not\nassignable 32 |         i.7 = (int)ctoi(*((char *)(__anneau + g_405188 * 32 +\n8))) - 1; |          ~~ ^ /tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:33:22:\nerror: expected ']' 33 |         if (bot[8 + i.7] <= 2) |                      ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:33:16: note: to match this '['\n   33 |         if (bot[8 + i.7] <= 2)\n      |                ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:35:26: error: expected ']'\n   35 |             if (bot[8 + i.7] != *((int *)(((i.7 << 2) + i.7 << 2) +\nproduits + 4)) - 1) |                          ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:35:20: note: to match this '['\n   35 |             if (bot[8 + i.7] != *((int *)(((i.7 << 2) + i.7 << 2) +\nproduits + 4)) - 1) |                    ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:35:46: error: expected ')'\n   35 |             if (bot[8 + i.7] != *((int *)(((i.7 << 2) + i.7 << 2) +\nproduits + 4)) - 1) |                                              ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:35:44: note: to match this '('\n   35 |             if (bot[8 + i.7] != *((int *)(((i.7 << 2) + i.7 << 2) +\nproduits + 4)) - 1) |                                            ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:35:58: error: expected ')'\n   35 |             if (bot[8 + i.7] != *((int *)(((i.7 << 2) + i.7 << 2) +\nproduits + 4)) - 1) |                                                          ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:35:43: note: to match this '('\n   35 |             if (bot[8 + i.7] != *((int *)(((i.7 << 2) + i.7 << 2) +\nproduits + 4)) - 1) |                                           ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:39:33: error: expected ']'\n   39 |             else if (!bot[12 + i.7])\n      |                                 ^\n/tmp/tmple68zfrl/puis_je_prendre_composant_name_conflict.c:39:26: note: to match this '['\n   39 |             else if (!bot[12 + i.7])\n      |                          ^\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if (bot.mode == NORMAL) {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prods, (__anneau->cases[bot.pos]).p.num)) {\n                    if (bot.ops[0] == (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat]) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    } else {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prodsDegrades, (__anneau->cases[bot.pos]).p.num)) {\n                    if (has(bot.ops, (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat])) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ctoi)(long long);\nlong long(has)(long long, long long);\n\nextern unsigned long long __anneau;\nextern char bot;\nextern unsigned int g_405188;\nextern unsigned int g_40518c;\nextern char g_405190;\nextern unsigned long long g_405196;\nextern unsigned long long g_40519a;\n\nlong long puis_je_prendre_produit_name_conflict() {\n  unsigned int v2; // eax\n  unsigned int v4; // eax\n\n  if (g_40518c != 1) {\n    if (*((int *)(__anneau + (g_405188 << 5) + 28)) >= 0) {\n      v4 = *((int *)&(\n          &bot)[44 + 4 * ctoi(*((char *)(__anneau + g_405188 * 32 + 12)))]);\n      if (!v4 &&\n          (int)has(&g_40519a, *((char *)(__anneau + (g_405188 << 5) + 12))) &&\n          (int)has(&g_405190,\n                   *((char *)(*((int *)(__anneau + (g_405188 << 5) + 28)) +\n                              __anneau + (g_405188 << 5) + 20))))\n        return 1;\n    }\n  } else {\n    if (*((int *)(__anneau + (g_405188 << 5) + 28)) >= 0) {\n      v2 = *((int *)&(\n          &bot)[44 + 4 * ctoi(*((char *)(__anneau + g_405188 * 32 + 12)))]);\n      if (!v2 &&\n          (int)has(&g_405196, *((char *)(__anneau + (g_405188 << 5) + 12))) &&\n          g_405190 == *((char *)(*((int *)(__anneau + (g_405188 << 5) + 28)) +\n                                 __anneau + (g_405188 << 5) + 20)))\n        return 1;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Composant prendre_composant() {\n    static Composant c;\n    c = (__anneau->cases[bot.pos]).c;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).c.num = 0;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long __anneau;\nextern char c.6;\nextern unsigned int g_405188;\n\nlong long prendre_composant_name_conflict() {\n  c.6 = *((char *)(__anneau + g_405188 * 32 + 8));\n  *((int *)(__anneau + g_405188 * 32 + 32)) = 0;\n  *((char *)(__anneau + g_405188 * 32 + 8)) = 0;\n  return c.6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd6_edrzw/prendre_composant_name_conflict.c:18:14: error: expected ';' after top level\ndeclarator 18 | extern char c.6; |              ^ |              ;\n/tmp/tmpd6_edrzw/prendre_composant_name_conflict.c:23:6: error: expected ';' after expression\n   23 |     c.6 = *((char *)(__anneau + g_405188 * 32 + 8));\n      |      ^\n      |      ;\n/tmp/tmpd6_edrzw/prendre_composant_name_conflict.c:23:9: error: expression is not assignable\n   23 |     c.6 = *((char *)(__anneau + g_405188 * 32 + 8));\n      |      ~~ ^\n/tmp/tmpd6_edrzw/prendre_composant_name_conflict.c:26:13: error: expected ';' after return\nstatement 26 |     return c.6; |             ^ |             ; 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Produit prendre_produit() {\n    static Produit p;\n    p = (__anneau->cases[bot.pos]).p;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).p.num = 0;\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[28];\n  unsigned int field_1c;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned long long field_0;\n  unsigned long long field_8;\n  unsigned int field_10;\n} struct_1;\n\nextern unsigned long long __anneau;\nextern unsigned int g_405188;\nextern unsigned long long g_405428;\nextern unsigned int g_405430;\nextern unsigned long long p.5;\n\nlong long prendre_produit_name_conflict(struct_1 *a0) {\n  unsigned long long v1; // rdx\n  struct_0 *v2;          // rcx\n  unsigned long long v4; // rdx\n\n  v1 = g_405188 * 32;\n  v2 = __anneau + v1;\n  v4 = *((long long *)(__anneau + v1 + 20));\n  p.5 = *((long long *)(__anneau + v1 + 12));\n  g_405428 = v4;\n  g_405430 = v2->field_1c;\n  *((int *)(__anneau + g_405188 * 32 + 32)) = 0;\n  *((char *)(__anneau + g_405188 * 32 + 12)) = 0;\n  a0->field_0 = p.5;\n  a0->field_8 = g_405428;\n  a0->field_10 = g_405430;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpae08eq11/prendre_produit_name_conflict.c:32:28: error: expected ';' after top level\ndeclarator 32 | extern unsigned long long p.5; |                            ^ |\n; /tmp/tmpae08eq11/prendre_produit_name_conflict.c:43:6: error: expected ';' after expression\n   43 |     p.5 = *((long long *)(__anneau + v1 + 12));\n      |      ^\n      |      ;\n/tmp/tmpae08eq11/prendre_produit_name_conflict.c:43:9: error: expression is not assignable\n   43 |     p.5 = *((long long *)(__anneau + v1 + 12));\n      |      ~~ ^\n/tmp/tmpae08eq11/prendre_produit_name_conflict.c:48:20: error: expected ';' after expression\n   48 |     a0->field_0 = p.5;\n      |                    ^\n      |                    ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"static int bind_local(uint16_t port) {\n    int fd;\n    struct sockaddr_in servaddr;\n    fd = socket(2, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"socket\");\n        exit(1);\n    }\n    bzero(&servaddr, sizeof (servaddr));\n    servaddr.sin_family = 2;\n    servaddr.sin_port = htons(port);\n    if (inet_pton(2, \"127.0.0.1\", &servaddr.sin_addr) <= 0) {\n        perror(\"inet_pton\");\n        exit(1);\n    }\n    if (bind(fd, (struct sockaddr *)&servaddr, sizeof (servaddr)) < 0) {\n        perror(\"bind\");\n        exit(1);\n    }\n    if (listen(fd, 128) < 0) {\n        perror(\"listen\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nvoid(perror)(char *);\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(listen)(int, int);\n\nlong long bind_local_name_conflict(unsigned long a0) {\n  int v0;            // [bp-0x28], Other Possible Types: unsigned short\n  unsigned short v1; // [bp-0x26]\n  unsigned int v2;   // [bp-0xc]\n\n  v2 = socket(2, 1, 0);\n  if (v2 < 0) {\n    perror(\"socket\");\n    exit(1); /* do not return */\n  }\n  *((int128_t *)&v0) = 0;\n  v0 = 2;\n  v1 = htons(a0);\n  if (inet_pton(2, \"127.0.0.1\", &v0) <= 0) {\n    perror(\"inet_pton\");\n    exit(1); /* do not return */\n  } else if (bind(v2, &v0, 16) < 0) {\n    perror(\"bind\");\n    exit(1); /* do not return */\n  } else if (listen(v2, 128) >= 0) {\n    return v2;\n  } else {\n    perror(\"listen\");\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpue93uaja/bind_local_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpue93uaja/bind_local_name_conflict.c:38:18: error: expected expression\n   38 |     *((int128_t *)&v0) = 0;\n      |                  ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sduzh_snippet/src/net/test_epoll.c"}
{"compilable":1,"function":"static int test_hexdigit(char ch) {\n    if (ch >= '0' && ch <= '9')\n        return ch - '0';\n    if (ch >= 'A' && ch <= 'F')\n        return ch - 'A' + 10;\n    if (ch >= 'a' && ch <= 'f')\n        return ch - 'a' + 10;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test_hexdigit_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57)\n    return (char)a0 - 48;\n  if ((char)a0 > 64 && (char)a0 <= 70)\n    return (char)a0 - 55;\n  if ((char)a0 > 96 && (char)a0 <= 102)\n    return (char)a0 - 87;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"static int test_readhex(uint8_t *buf, const char *str, int maxbytes) {\n    int i, h, l;\n    for (i = 0; i < maxbytes; i++) {\n        h = test_hexdigit(str[2 * i]);\n        if (h < 0)\n            return i;\n        l = test_hexdigit(str[2 * i + 1]);\n        if (l < 0)\n            return i;\n        buf[i] = (h << 4) + l;\n    }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_hexdigit)(long long);\n\nlong long test_readhex_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x14]\n  unsigned int v1;       // [bp-0x10]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v2 = 0;\n  while (v2 >= (unsigned int)a2) {\n  LABEL_40126e:\n    return v2;\n  }\n  v1 = test_hexdigit(a1[2 * v2]);\n  if (v1 < 0)\n    return v2;\n  v0 = test_hexdigit(a1[1 + 2 * v2]);\n  if (v0 < 0)\n    return v2;\n  a0[v2] = (char)v1 * 16 + (char)v0;\n  v2 += 1;\n  goto LABEL_40126e;\n}\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_sha3() {\n    const char *testvec[][2] = {{\"\", \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\"}, {\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\", \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"}, {\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\", \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DAF3BB7B1BC5E8D722BAC85943A\"}, {\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\", \"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE12205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\"}};\n    int i, fails, msg_len, sha_len;\n    uint8_t sha[64], buf[64], msg[256];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        memset(sha, 0, sizeof (sha));\n        memset(buf, 0, sizeof (buf));\n        memset(msg, 0, sizeof (msg));\n        msg_len = test_readhex(msg, testvec[i][0], sizeof (msg));\n        sha_len = test_readhex(sha, testvec[i][1], sizeof (sha));\n        sha3(msg, msg_len, buf, sha_len);\n        if (memcmp(sha, buf, sha_len) != 0) {\n            fprintf(stderr, \"[%d] SHA3-%d, len %d test FAILED.\\n\", i, sha_len * 8, msg_len);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_readhex)(long long, long long, long long);\nlong long(sha3)(long long, long long, long long, long long);\n\nextern char g_403008;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long test_sha3_name_conflict() {\n  char v0;               // [bp-0x1d8]\n  char v1;               // [bp-0xd8]\n  char v2;               // [bp-0x98]\n  unsigned long long v3; // [bp-0x58]\n  unsigned long long v4; // [bp-0x50]\n  unsigned long v5;      // [bp-0x48]\n  unsigned long v6;      // [bp-0x40]\n  unsigned long v7;      // [bp-0x38]\n  unsigned long v8;      // [bp-0x30]\n  unsigned long v9;      // [bp-0x28]\n  unsigned long v10;     // [bp-0x20]\n  unsigned int v11;      // [bp-0x18]\n  unsigned int v12;      // [bp-0x14]\n  unsigned int v13;      // [bp-0x10]\n  unsigned int v14;      // [bp-0xc]\n\n  v3 = &g_403008;\n  v4 = \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\";\n  v5 = \"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\";\n  v6 = \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\";\n  v7 = \"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80\"\n       \"189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33\"\n       \"E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\";\n  v8 = \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DA\"\n       \"F3BB7B1BC5E8D722BAC85943A\";\n  v9 = \"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66\"\n       \"B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE\"\n       \"18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB7\"\n       \"89E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C1\"\n       \"27D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE\"\n       \"23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA823\"\n       \"07DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E\"\n       \"4A92ECEEBAEB1\";\n  v10 = \"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE1\"\n        \"2205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\";\n  v13 = 0;\n  for (v14 = 0; v14 <= 3; v14 += 1) {\n    memset(&v2, 0, 64);\n    memset(&v1, 0, 64);\n    memset(&v0, 0, 0x100);\n    v12 = test_readhex(&v0, (&v3)[2 * v14], 0x100);\n    v11 = test_readhex(&v2, (&v4)[2 * v14], 64);\n    sha3(&v0, v12, &v1, v11);\n    if (memcmp(&v2, &v1, v11)) {\n      fprintf(stderr @GLIBC_2.2.5, \"[%d] SHA3-%d, len %d test FAILED.\\n\", v14,\n              (unsigned int)(v11 * 8), v12);\n      v13 += 1;\n    }\n  }\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp90s5zj6c/test_sha3_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 20 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp90s5zj6c/test_sha3_name_conflict.c:20:22: error: expected ';' after top level\ndeclarator 20 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp90s5zj6c/test_sha3_name_conflict.c:59:27: error: expected ')'\n   59 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHA3-%d, len %d test\nFAILED.\\n\", v14, (unsigned int)(v11 * 8), v12); |                           ^\n/tmp/tmp90s5zj6c/test_sha3_name_conflict.c:59:20: note: to match this '('\n   59 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHA3-%d, len %d test\nFAILED.\\n\", v14, (unsigned int)(v11 * 8), v12); |                    ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_shake() {\n    const char *testhex[4] = {\"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\", \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\", \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\", \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\"};\n    int i, j, fails;\n    sha3_ctx_t sha3;\n    uint8_t buf[32], ref[32];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        if ((i & 1) == 0) {\n            sha3_init(&sha3, 16);\n        } else {\n            sha3_init(&sha3, 32);\n        }\n        if (i >= 2) {\n            memset(buf, 163, 20);\n            for (j = 0; j < 200; j += 20)\n                sha3_update(&sha3, buf, 20);\n        }\n        shake_xof(&sha3);\n        for (j = 0; j < 512; j += 32)\n            shake_out(&sha3, buf, 32);\n        test_readhex(ref, testhex[i], sizeof (ref));\n        if (memcmp(buf, ref, 32) != 0) {\n            fprintf(stderr, \"[%d] SHAKE%d, len %d test FAILED.\\n\", i, i & 1 ? 256 : 128, i >= 2 ? 1600 : 0);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sha3_init)(long long, long long);\nlong long(shake_xof)(long long);\nlong long(shake_out)(long long, long long, long long);\nlong long(test_readhex)(long long, long long, long long);\nlong long(sha3_update)(long long, long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long test_shake_name_conflict() {\n  char v0;               // [bp-0x158]\n  char v1;               // [bp-0x138]\n  char v2;               // [bp-0x118]\n  unsigned long long v3; // [bp-0x38]\n  unsigned long v4;      // [bp-0x30]\n  unsigned long v5;      // [bp-0x28]\n  unsigned long v6;      // [bp-0x20]\n  unsigned int v7;       // [bp-0x14]\n  unsigned int v8;       // [bp-0x10]\n  unsigned int v9;       // [bp-0xc]\n  unsigned int v11;      // esi\n\n  v3 = \"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\";\n  v4 = \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\";\n  v5 = \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\";\n  v6 = \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\";\n  v7 = 0;\n  for (v9 = 0; v9 <= 3; v9 += 1) {\n    if (((char)v9 & 1))\n      sha3_init(&v2, 32);\n    else\n      sha3_init(&v2, 16);\n    if (v9 > 1) {\n      memset(&v1, 163, 20);\n      for (v8 = 0; v8 <= 199; v8 += 20) {\n        sha3_update(&v2, &v1, 20);\n      }\n    }\n    shake_xof(&v2);\n    for (v8 = 0; v8 <= 511; v8 += 32) {\n      shake_out(&v2, &v1, 32);\n    }\n    test_readhex(&v0, (&v3)[v9], 32);\n    if (memcmp(&v1, &v0, 32)) {\n      if (v9 <= 1)\n        v11 = 0;\n      else\n        v11 = 1600;\n      fprintf(stderr @GLIBC_2.2.5, \"[%d] SHAKE%d, len %d test FAILED.\\n\", v9,\n              (!(v9 & 1) ? 0x100 : 128), v11);\n      v7 += 1;\n    }\n  }\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9o76hrh_/test_shake_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp9o76hrh_/test_shake_name_conflict.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp9o76hrh_/test_shake_name_conflict.c:69:27: error: expected ')'\n   69 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHAKE%d, len %d test\nFAILED.\\n\", v9, (!(v9 & 1) ? 0x100 : 128), v11); |                           ^\n/tmp/tmp9o76hrh_/test_shake_name_conflict.c:69:20: note: to match this '('\n   69 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHAKE%d, len %d test\nFAILED.\\n\", v9, (!(v9 & 1) ? 0x100 : 128), v11); |                    ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":1,"function":"int sha3_init(sha3_ctx_t *c, int mdlen) {\n    int i;\n    for (i = 0; i < 25; i++)\n        c->st.q[i] = 0;\n    c->mdlen = mdlen;\n    c->rsiz = 200 - 2 * mdlen;\n    c->pt = 0;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n  char padding_8[192];\n  unsigned int field_c8;\n  unsigned int field_cc;\n  unsigned int field_d0;\n} struct_0;\n\nlong long sha3_init_name_conflict(struct_0 *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 24; v0 += 1) {\n    (&a0->field_0)[v0] = 0;\n  }\n  a0->field_d0 = a1;\n  a0->field_cc = (100 - (unsigned int)a1) * 2;\n  a0->field_c8 = 0;\n  return 1;\n}\n","pass":1,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/sha3.c"}
{"compilable":0,"function":"int randomTile(int lowerLim, int upperLim) {\n    return rand() % (upperLim - lowerLim + 1) + lowerLim;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long randomTile_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = a0;\n  (unsigned int)v2 = rand();\n  return v0 + (((unsigned int)v2 >> 31 CONCAT(unsigned int) v2) /\n                   m((unsigned int)a1 - (unsigned int)a0 + 1) >>\n               32);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxn2fjmzv/randomTile_name_conflict.c:24:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 24 |     (unsigned int)v2 = rand(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpxn2fjmzv/randomTile_name_conflict.c:25:42: error: expected ')'\n   25 |     return v0 + (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0 + 1) >> 32); | ^\n/tmp/tmpxn2fjmzv/randomTile_name_conflict.c:25:18: note: to match this '('\n   25 |     return v0 + (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0 + 1) >> 32); |                  ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int swapTile(char grid[6][6], gridcoord tile, char direction) {\n    gridcoord partnertile;\n    char temp;\n    partnertile.x = tile.x;\n    partnertile.y = tile.y;\n    unsigned long score = 0;\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    int linsertat = 0;\n    int cinsertat = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char prompt_resp;\n    switch (direction) {\n      case 'w':\n      case 'W':\n        partnertile.y = tile.y - 1;\n        break;\n      case 's':\n      case 'S':\n        partnertile.y = tile.y + 1;\n        break;\n      case 'a':\n      case 'A':\n        partnertile.x = tile.x - 1;\n        break;\n      case 'd':\n      case 'D':\n        partnertile.x = tile.x + 1;\n        break;\n      default:\n        printf(\"\\n:( ERROR. Unknown command.\");\n    }\n    temp = grid[tile.y][tile.x];\n    grid[tile.y][tile.x] = grid[partnertile.y][partnertile.x];\n    grid[partnertile.y][partnertile.x] = temp;\n    lengtmt = checkmatches_lengthwise(grid, partnertile, lmatches, &linsertat);\n    crossmt = checkmatches_crosswise(grid, partnertile, cmatches, &cinsertat);\n    if (lengtmt >= 2 || crossmt >= 2) {\n        if (lengtmt >= 2) {\n            score += lengtmt;\n            assasinate(grid, lmatches, lengtmt);\n        }\n        if (crossmt >= 2) {\n            score += crossmt;\n            assasinate(grid, cmatches, crossmt);\n        }\n        grid[partnertile.y][partnertile.x] = '\\x00';\n        score += 1;\n    } else {\n        linsertat = 0;\n        cinsertat = 0;\n        lengtmt = checkmatches_lengthwise(grid, tile, lmatches, &linsertat);\n        crossmt = checkmatches_crosswise(grid, tile, cmatches, &cinsertat);\n        if (lengtmt >= 2 || crossmt >= 2) {\n            if (lengtmt >= 2) {\n                score += lengtmt;\n                assasinate(grid, lmatches, lengtmt);\n            }\n            if (crossmt >= 2) {\n                score += crossmt;\n                assasinate(grid, cmatches, crossmt);\n            }\n            grid[tile.y][tile.x] = '\\x00';\n            score += 1;\n        } else {\n            temp = grid[partnertile.y][partnertile.x];\n            grid[partnertile.y][partnertile.x] = grid[tile.y][tile.x];\n            grid[tile.y][tile.x] = temp;\n        }\n    }\n    return score;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkmatches_lengthwise)(long long, long long, long long, long long);\nlong long(checkmatches_crosswise)(long long, long long, long long, long long);\nlong long(assasinate)(long long, long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[4207896];\n  unsigned int field_403518;\n} struct_0;\n\nextern char g_403518;\n\nlong long swapTile_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v0; // [bp-0x288]\n  unsigned long long v1; // [bp-0x280]\n  unsigned int v2;       // [bp-0x270]\n  unsigned int v3;       // [bp-0x26c]\n  char v4;               // [bp-0x268]\n  char v5;               // [bp-0x148]\n  unsigned int v6;       // [bp-0x24]\n  unsigned int v7;       // [bp-0x20]\n  char v8;               // [bp-0x19]\n  unsigned int v9;       // [bp-0x18]\n  unsigned int v10;      // [bp-0x14]\n  void *v11;             // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = a0;\n  v0 = a1;\n  v6 = v0;\n  v7 = *((int *)((char *)&v0 + 4));\n  v11 = 0;\n  v3 = 0;\n  v2 = 0;\n  v10 = 0;\n  v9 = 0;\n  switch ((char)a2) {\n  case 65:\n  case 97:\n    v6 = (int)v0 - 1;\n    break;\n  case 68:\n  case 100:\n    v6 = (int)v0 + 1;\n    break;\n  case 83:\n  case 115:\n    v7 = *((int *)((char *)&v0 + 4)) + 1;\n    break;\n  case 87:\n  case 119:\n    v7 = *((int *)((char *)&v0 + 4)) - 1;\n    break;\n  default:\n    printf(\"\\n:( ERROR. Unknown command.\");\n  }\n  v8 = *((char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + v1 + (unsigned int)v0));\n  *((char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + v1 + (unsigned int)v0)) =\n      *((char *)(3 * v7 * 2 + v1 + v6));\n  *((char *)(3 * v7 * 2 + v1 + v6)) = v8;\n  v10 = checkmatches_lengthwise(v1, *((long long *)&v6), &v5, &v3);\n  v9 = checkmatches_crosswise(v1, *((long long *)&v6), &v4, &v2);\n  if (v10 <= 1 && v9 <= 1) {\n    v3 = 0;\n    v2 = 0;\n    v10 = checkmatches_lengthwise(v1, v0, &v5, &v3);\n    v9 = checkmatches_crosswise(v1, v0, &v4, &v2);\n    if (v10 <= 1 && v9 <= 1) {\n      v8 = *((char *)(3 * v7 * 2 + v1 + v6));\n      *((char *)(3 * v7 * 2 + v1 + v6)) = *((\n          char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + v1 + (unsigned int)v0));\n      *((char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + v1 + (unsigned int)v0)) =\n          v8;\n      return v11;\n    }\n    if (v10 > 1) {\n      v11 += v10;\n      assasinate(v1, &v5, v10);\n    }\n    if (v9 > 1) {\n      v11 += v9;\n      assasinate(v1, &v4, v9);\n    }\n    *((char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + v1 + (unsigned int)v0)) =\n        0;\n    v11 += 1;\n    return v11;\n  }\n  if (v10 > 1) {\n    v11 += v10;\n    assasinate(v1, &v5, v10);\n  }\n  if (v9 > 1) {\n    v11 += v9;\n    assasinate(v1, &v4, v9);\n  }\n  *((char *)(3 * v7 * 2 + v1 + v6)) = 0;\n  v11 += 1;\n  return v11;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int popmatches_universal(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char gridcopy[6][6];\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    gridcoord tile;\n    int didchangel = 0;\n    int didchangec = 0;\n    int tsambapoints = 0;\n    int linsertat = 0;\n    int cinsertat = 0;\n    copymatrix2d(grid, gridcopy);\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            lengtmt = checkmatches_lengthwise(gridcopy, tile, lmatches, &linsertat);\n            crossmt = checkmatches_crosswise(gridcopy, tile, cmatches, &cinsertat);\n            if (lengtmt >= 2 || crossmt >= 2) {\n                if (lengtmt >= 2) {\n                    didchangel = 1;\n                    tsambapoints += lengtmt;\n                }\n                if (crossmt >= 2) {\n                    didchangec = 1;\n                    tsambapoints += crossmt;\n                }\n                grid[tile.y][tile.x] = '\\x00';\n                tsambapoints += 1;\n            }\n        }\n    }\n    if (didchangel) {\n        assasinate(gridcopy, lmatches, linsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    if (didchangec) {\n        assasinate(gridcopy, cmatches, cinsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    fillGaps(grid);\n    if (didchangec == 1 || didchangel == 1) {\n        return tsambapoints += popmatches_universal(grid);\n    }\n    return tsambapoints;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(copymatrix2d)(long long, long long);\nlong long(assasinate)(long long, long long, long long);\nlong long(checkmatches_lengthwise)(long long, long long, long long, long long);\nlong long(fillGaps)(long long);\nlong long(checkmatches_crosswise)(long long, long long, long long, long long);\nlong long(popmatches_universal_name_conflict)(unsigned long long);\n\nlong long popmatches_universal_name_conflict(unsigned long long a0) {\n  unsigned int v0;  // [bp-0x298]\n  unsigned int v1;  // [bp-0x294]\n  unsigned int v2;  // [bp-0x290]\n  unsigned int v3;  // [bp-0x28c]\n  char v4;          // [bp-0x288]\n  char v5;          // [bp-0x168]\n  char v6;          // [bp-0x48]\n  unsigned int v7;  // [bp-0x24]\n  unsigned int v8;  // [bp-0x20]\n  unsigned int v9;  // [bp-0x1c]\n  unsigned int v10; // [bp-0x18]\n  unsigned int v11; // [bp-0x14]\n  unsigned int v12; // [bp-0x10]\n  unsigned int v13; // [bp-0xc]\n\n  v13 = 0;\n  v12 = 0;\n  v8 = 0;\n  v7 = 0;\n  v11 = 0;\n  v10 = 0;\n  v9 = 0;\n  v1 = 0;\n  v0 = 0;\n  copymatrix2d(a0, &v6);\n  for (v12 = 0; v12 <= 5; v12 += 1) {\n    for (v13 = 0; v13 <= 5; v13 += 1) {\n      v2 = v13;\n      v3 = v12;\n      v8 = checkmatches_lengthwise(&v6, *((long long *)&v2), &v5, &v1);\n      v7 = checkmatches_crosswise(&v6, *((long long *)&v2), &v4, &v0);\n      if (v8 > 1 || v7 > 1) {\n        if (v8 > 1) {\n          v11 = 1;\n          v9 += v8;\n        }\n        if (v7 > 1) {\n          v10 = 1;\n          v9 += v7;\n        }\n        *((char *)(3 * v3 * 2 + a0 + v2)) = 0;\n        v9 += 1;\n      }\n    }\n  }\n  if (v11) {\n    assasinate(&v6, &v5, v1);\n    copymatrix2d(&v6, a0);\n  }\n  if (v10) {\n    assasinate(&v6, &v4, v0);\n    copymatrix2d(&v6, a0);\n  }\n  fillGaps(a0);\n  if (v10 != 1 && v11 != 1)\n    return v9;\n  v9 += (int)popmatches_universal_name_conflict(a0);\n  return v9;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_lengthwise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.y - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.y + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long checkmatches_lengthwise(unsigned long a0, unsigned long a1,\n                                  unsigned int *a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x28]\n  unsigned int v1;  // [bp-0x10]\n  unsigned int v2;  // [bp-0xc]\n  char v5;          // cl\n  char v8;          // cl\n\n  v0 = a1;\n  v2 = 0;\n  v1 = 0;\n  for (v2 = *((int *)((char *)&v0 + 4)) - 1;\n       v2 >= 0 &&\n       (v5 =\n            *((char *)(3 * (unsigned long long)*((int *)((char *)&v0 + 4)) * 2 +\n                       a0 + (unsigned long long)(unsigned int)v0)),\n       v5 == *((char *)(3 * (unsigned long long)v2 * 2 + a0 +\n                        (unsigned long long)(unsigned int)v0)));\n       v2 -= 1) {\n    v1 += 1;\n    a2[2 * *((int *)*((unsigned long long *)&v5))] = v0;\n    a2[1 + 2 * *((int *)*((unsigned long long *)&v5))] = v2;\n    *((int *)*((unsigned long long *)&v5)) =\n        *((int *)*((unsigned long long *)&v5)) + 1;\n  }\n  for (v2 = *((int *)((char *)&v0 + 4)) + 1; v2 <= 5; v2 += 1) {\n    v8 = *(\n        (char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + a0 + (unsigned int)v0));\n    if (v8 != *((char *)(3 * v2 * 2 + a0 + (unsigned int)v0)))\n      return v1;\n    v1 += 1;\n    a2[2 * *((int *)*((unsigned long long *)&v5))] = v0;\n    a2[1 + 2 * *((int *)*((unsigned long long *)&v5))] = v2;\n    *((int *)*((unsigned long long *)&v5)) =\n        *((int *)*((unsigned long long *)&v5)) + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_crosswise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.x - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.x + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long checkmatches_crosswise(unsigned long a0, unsigned long a1,\n                                 unsigned int *a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x28]\n  unsigned int v1;  // [bp-0x10]\n  unsigned int v2;  // [bp-0xc]\n  char v5;          // cl\n  unsigned int *v8; // cl\n\n  v0 = a1;\n  v2 = 0;\n  v1 = 0;\n  for (v2 = (int)v0 - 1;\n       v2 >= 0 &&\n       (v5 =\n            *((char *)(3 * (unsigned long long)*((int *)((char *)&v0 + 4)) * 2 +\n                       a0 + (unsigned long long)(unsigned int)v0)),\n       v5 ==\n            *((char *)(3 * (unsigned long long)*((int *)((char *)&v0 + 4)) * 2 +\n                       a0 + (unsigned long long)v2)));\n       v2 -= 1) {\n    v1 += 1;\n    a2[2 * *((int *)*((unsigned long long *)&v5))] = v2;\n    a2[1 + 2 * *((int *)*((unsigned long long *)&v5))] =\n        *((int *)((char *)&v0 + 4));\n    *((int *)*((unsigned long long *)&v5)) =\n        *((int *)*((unsigned long long *)&v5)) + 1;\n  }\n  for (v2 = (int)v0 + 1; v2 <= 5; v2 += 1) {\n    v8 = *(\n        (char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + a0 + (unsigned int)v0));\n    if (v8 != *((char *)(3 * *((int *)((char *)&v0 + 4)) * 2 + a0 + v2)))\n      return v1;\n    v1 += 1;\n    a2[2 * *((int *)*((unsigned long long *)&v5))] = v2;\n    a2[1 + 2 * *((int *)*((unsigned long long *)&v5))] =\n        *((int *)((char *)&v0 + 4));\n    *((int *)*((unsigned long long *)&v5)) =\n        *((int *)*((unsigned long long *)&v5)) + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int isValid(gridcoord move, char direction) {\n    if (move.x == -1 && move.y == -1 && direction == '0') {\n        return 1;\n    }\n    if (move.x == 0 && (direction == 'a' || direction == 'A')) {\n        printf(\"\\tYou can't move that to the left.\\n\");\n        return 0;\n    }\n    if (move.x == 6 - 1 && (direction == 'd' || direction == 'D')) {\n        printf(\"\\tYou can't move that to the right.\\n\");\n        return 0;\n    }\n    if (move.y == 0 && (direction == 'w' || direction == 'W')) {\n        printf(\"\\tYou can't move that up.\\n\");\n        return 0;\n    }\n    if (move.y == 6 - 1 && (direction == 's' || direction == 'S')) {\n        printf(\"\\tYou can't move that down.\\n\");\n        return 0;\n    }\n    if (move.y < 0 || move.x < 0 || move.y >= 6 || move.x >= 6) {\n        printf(\"\\tI can't find those coordinates. Terminals are dumb, huh?\\n\");\n        return 0;\n    }\n    if (direction != 'a' && direction != 'A' && direction != 's' && direction != 'S' && direction != 'd' && direction != 'D' && direction != 'w' && direction != 'W') {\n        printf(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D for RIGHT.\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isValid_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  if ((int)v0 == -1 && *((int *)((char *)&v0 + 4)) == -1 && (char)a1 == 48)\n    return 1;\n  if (!(int)v0 && (!((char)a1 != 97) || !((char)a1 != 65))) {\n    puts(\"\\tYou can't move that to the left.\");\n    return 0;\n  }\n  if ((int)v0 == 5 && (!((char)a1 != 100) || !((char)a1 != 68))) {\n    puts(\"\\tYou can't move that to the right.\");\n    return 0;\n  }\n  if (!*((int *)((char *)&v0 + 4)) &&\n      (!((char)a1 != 119) || !((char)a1 != 87))) {\n    puts(\"\\tYou can't move that up.\");\n    return 0;\n  }\n  if (*((int *)((char *)&v0 + 4)) == 5 &&\n      (!((char)a1 != 115) || !((char)a1 != 83))) {\n    puts(\"\\tYou can't move that down.\");\n    return 0;\n  }\n  if (*((int *)((char *)&v0 + 4)) >= 0 && (int)v0 >= 0 &&\n      *((int *)((char *)&v0 + 4)) <= 5 && (int)v0 <= 5) {\n    if (!((char)a1 != 97 && (char)a1 != 65 && (char)a1 != 115 &&\n          (char)a1 != 83 && (char)a1 != 100 && (char)a1 != 68 &&\n          (char)a1 != 119 && (char)a1 != 87))\n      return 1;\n    puts(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D \"\n         \"for RIGHT.\");\n    return 0;\n  }\n  puts(\"\\tI can't find those coordinates. Terminals are dumb, huh?\");\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int game() {\n    char grid[6][6];\n    gridcoord target;\n    unsigned long gamescore = 0;\n    char direction;\n    do {\n        populate(grid);\n        popmatches_universal(grid);\n    } while (!trymatches(grid));\n    do {\n        drawGrid(grid, gamescore);\n        do {\n            printf(\"\\n\\tMOVE: \");\n            scanf(\"%d %d %c\", &target.x, &target.y, &direction);\n            target.x -= 1;\n            target.y -= 1;\n            if (target.x == -1 && target.y == -1 && direction == '0') {\n                return gamescore;\n            }\n        } while (!isValid(target, direction));\n        gamescore += swapTile(grid, target, direction);\n        gamescore += popmatches_universal(grid);\n    } while ((target.x != -1 && target.y != -1 && direction != '0') && (trymatches(grid) == 1));\n    return gamescore;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(populate)(long long);\nlong long(popmatches_universal)(long long);\nlong long(trymatches)(long long);\nlong long(drawGrid)(long long, long long);\nint(__isoc99_scanf)(char *, ...);\nlong long(isValid)(long long, long long);\nlong long(swapTile)(long long, long long, long long);\n\nlong long game_name_conflict() {\n  char v0;               // [bp-0x41]\n  unsigned int v1;       // [bp-0x40], Other Possible Types: char\n  char v2;               // [bp-0x3c], Other Possible Types: unsigned int\n  char v3;               // [bp-0x38]\n  void *v4;              // [bp-0x10], Other Possible Types: unsigned long\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n\n  v7 = &v5;\n  v4 = 0;\n  do {\n    populate(&v3);\n    popmatches_universal(&v3);\n  } while (!(int)trymatches(&v3));\n  while (true) {\n    drawGrid(&v3, v4);\n    do {\n      printf(\"\\n\\tMOVE: \");\n      __isoc99_scanf(\"%d %d %c\", (unsigned int)&v1, (unsigned int)&v2,\n                     (unsigned int)&v0);\n      v1 -= 1;\n      v2 = *((int *)&v2) - 1;\n      if (v1 == -1 && v2 == -1 && v0 == 48)\n        return v4;\n    } while (!(int)isValid(*((long long *)&v1), v0));\n    v4 += swapTile(&v3, *((long long *)&v1), v0);\n    v4 += popmatches_universal(&v3);\n    if (v1 == -1)\n      break;\n    if (!(v2 != -1) || !(v0 != 48) || !((int)trymatches(&v3) == 1))\n      break;\n    if ((int)trymatches(&v3) != 1)\n      break;\n  }\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int trymatches(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    gridcoord tile;\n    char prompt_resp;\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            if (isValid(tile, 'w')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y - 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 's')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y + 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'a')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x - 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'd')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x + 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(isValid)(long long, long long);\nlong long(primitSwapTiles)(long long, long long);\nlong long(areThereMatches)(long long, long long);\n\nlong long trymatches_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = 0;\n  v2 = 0;\n  for (v2 = 0; v2 <= 5; v2 += 1) {\n    for (v3 = 0; v3 <= 5; v3 += 1) {\n      v0 = v3;\n      v1 = v2;\n      if ((int)isValid(*((long long *)&v0), 119)) {\n        primitSwapTiles(v0 + 3 * v1 * 2 + a0, 3 * v1 * 2 - 6 + a0 + v0);\n        if ((int)areThereMatches(a0, *((long long *)&v0))) {\n          primitSwapTiles(v0 + 3 * v1 * 2 - 6 + a0, 3 * v1 * 2 + a0 + v0);\n          return 1;\n        }\n        primitSwapTiles(v0 + 3 * v1 * 2 - 6 + a0, 3 * v1 * 2 + a0 + v0);\n      }\n      if ((int)isValid(*((long long *)&v0), 115)) {\n        primitSwapTiles(v0 + 3 * v1 * 2 + a0, 3 * (v1 + 1) * 2 + a0 + v0);\n        if ((int)areThereMatches(a0, *((long long *)&v0))) {\n          primitSwapTiles(v0 + 3 * (v1 + 1) * 2 + a0, 3 * v1 * 2 + a0 + v0);\n          return 1;\n        }\n        primitSwapTiles(v0 + 3 * (v1 + 1) * 2 + a0, 3 * v1 * 2 + a0 + v0);\n      }\n      if ((int)isValid(*((long long *)&v0), 97)) {\n        primitSwapTiles(v0 + 3 * v1 * 2 + a0, 3 * v1 * 2 + a0 + v0 - 1);\n        if ((int)areThereMatches(a0, *((long long *)&v0))) {\n          primitSwapTiles(v0 - 1 + 3 * v1 * 2 + a0, 3 * v1 * 2 + a0 + v0);\n          return 1;\n        }\n        primitSwapTiles(v0 - 1 + 3 * v1 * 2 + a0, 3 * v1 * 2 + a0 + v0);\n      }\n      if ((int)isValid(*((long long *)&v0), 100)) {\n        primitSwapTiles(v0 + 3 * v1 * 2 + a0, 3 * v1 * 2 + a0 + v0 + 1);\n        if ((int)areThereMatches(a0, *((long long *)&v0))) {\n          primitSwapTiles(v0 + 1 + 3 * v1 * 2 + a0, 3 * v1 * 2 + a0 + v0);\n          return 1;\n        }\n        primitSwapTiles(v0 + 1 + 3 * v1 * 2 + a0, 3 * v1 * 2 + a0 + v0);\n      }\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int areThereMatches(char grid[6][6], gridcoord tile) {\n    gridcoord dummy[36];\n    int dummyinsertat = 0;\n    if (checkmatches_lengthwise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    if (checkmatches_crosswise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkmatches_lengthwise)(long long, long long, long long, long long);\nlong long(checkmatches_crosswise)(long long, long long, long long, long long);\n\nlong long areThereMatches_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x12c]\n  char v1;         // [bp-0x128]\n\n  v0 = 0;\n  return ((int)checkmatches_lengthwise(a0, a1, &v1, &v0) <= 1\n              ? 1\n              : ((int)checkmatches_crosswise(a0, a1, &v1, &v0) <= 1 ? 1 : 0));\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":1,"function":"int params_finish(struct params *fsm) {\n    if (fsm->cs == params_error)\n        return -1;\n    if (fsm->cs >= params_first_final)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1032];\n  unsigned int field_408;\n} struct_0;\n\nlong long params_finish_name_conflict(struct_0 *a0) {\n  return (!a0->field_408 ? (a0->field_408 < 23 ? 1 : 0) : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/brson_ragel-dist/examples/params.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4202764];\n  unsigned int field_40210c;\n} struct_0;\n\nextern char g_40210c;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long count_nucleotides_name_conflict(unsigned long long a0[5], char *a1) {\n  int v0;                 // [bp-0x58], Other Possible Types: unsigned long\n  unsigned long v1;       // [bp-0x50]\n  int v2;                 // [bp-0x48], Other Possible Types: unsigned long\n  unsigned long v3;       // [bp-0x40]\n  void *v4;               // [bp-0x38], Other Possible Types: unsigned long\n  char *v5;               // [bp-0x28]\n  unsigned long v6;       // [bp-0x20]\n  unsigned long v7;       // [bp-0x10]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long v11;      // rbx\n  struct_0 *v12;          // rax\n  unsigned long long v14; // rbx\n\n  v10 = &v8;\n  v7 = v11;\n  v5 = strlen(a1);\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v2) = 0;\n  v4 = 0;\n  for (v6 = 0; v6 < v5; v6 += 1) {\n    v12 = a1[v6] - 65;\n    switch ((unsigned int)v12) {\n    case 0:\n    case 32:\n      v0 = (long long)v0 + 1;\n      break;\n    case 2:\n    case 34:\n      v1 = (long long)(&v0)[8] + 1;\n      break;\n    case 6:\n    case 38:\n      v2 = (long long)v2 + 1;\n      break;\n    case 19:\n    case 51:\n      v3 = (long long)(&v2)[8] + 1;\n      break;\n    case 20:\n    case 52:\n      v4 += 1;\n      break;\n    default:\n      fprintf(stderr @GLIBC_2.2.5,\n              \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\", a1[v6]);\n      v6 = v5;\n      break;\n    }\n  }\n  a0[0] = (long long)v0;\n  a0[1] = (long long)(&v0)[8];\n  a0[2] = (long long)v2;\n  a0[3] = (long long)(&v2)[8];\n  a0[4] = v4;\n  v14 = v7;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf6nriqwv/count_nucleotides_name_conflict.c:25:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 25 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpf6nriqwv/count_nucleotides_name_conflict.c:25:22: error: expected ';' after top level\ndeclarator 25 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpf6nriqwv/count_nucleotides_name_conflict.c:46:18: error: expected expression\n   46 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmpf6nriqwv/count_nucleotides_name_conflict.c:47:18: error: expected expression\n   47 |     *((int128_t *)&v2) = 0;\n      |                  ^\n/tmp/tmpf6nriqwv/count_nucleotides_name_conflict.c:70:27: error: expected ')'\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict(): Unexpected\ncharacter: '%c'\\n\", a1[v6]); |                           ^\n/tmp/tmpf6nriqwv/count_nucleotides_name_conflict.c:70:20: note: to match this '('\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict(): Unexpected\ncharacter: '%c'\\n\", a1[v6]); |                    ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long transcribe_dna_to_rna_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = strdup(a0);\n  v0 = strlen(v1);\n  for (v2 = 0; v2 < v0; v2 += 1) {\n    if (v1[v2] == 116 || v1[v2] == 84)\n      v1[v2] = v1[v2] + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[4202976];\n  unsigned int field_4021e0;\n} struct_0;\n\nextern char g_4021e0;\n\nlong long get_dna_complement_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  struct_0 *v6;          // rax\n\n  v5 = &v3;\n  v1 = strdup(a0);\n  v0 = strlen(v1);\n  for (v2 = 0; v2 < v0; v2 += 1) {\n    v6 = v1[v2] - 65;\n    switch ((unsigned int)v6) {\n    case 0:\n    case 32:\n      v1[v2] = 84;\n      break;\n    case 2:\n    case 34:\n      v1[v2] = 71;\n      break;\n    case 6:\n    case 38:\n      v1[v2] = 67;\n      break;\n    case 19:\n    case 51:\n      v1[v2] = 65;\n      break;\n    default:\n      free(v1);\n      return 0;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamming_distance_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned long v1;      // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  void *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v1 = strlen(a0);\n  v0 = strlen(a1);\n  if (v1 != v0)\n    return -1;\n  v3 = 0;\n  for (v2 = 0; v2 < v1; v2 += 1) {\n    if (a0[v2] != *((char *)(v2 + a1)))\n      v3 += 1;\n  }\n  return v3;\n}\n","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strstrip_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x18]\n  char v2[2];            // [bp-0x10], Other Possible Types: unsigned long\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v0 = a0;\n  v1 = strlen(v0);\n  if (!v1)\n    return v0;\n  for (*((char **)&v2) = &v0[1 + v1];\n       v2 >= v0 &&\n       (*((short *)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000);\n       v2 = &v2[1])\n    ;\n  for (*((char *)(v2 + 1)) = 0;\n       *((char *)v0) &&\n       (*((short *)((*((char *)v0) << 1) + *((long long *)&__ctype_b_loc()))) &\n        0x2000);\n       v0 += 1)\n    ;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb4a5qsts/strstrip_name_conflict.c:30:96: error: cannot take the address of an rvalue\nof type 'int' 30 |     for (*((char **)&v2) = &v0[1 + v1]; v2 >= v0 && (*((short\n*)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v2 = &v2[1]); |\n^~~~~~~~~~~~~~~~ /tmp/tmpb4a5qsts/strstrip_name_conflict.c:30:130: error: array type 'char[2]'\nis not assignable 30 |     for (*((char **)&v2) = &v0[1 + v1]; v2 >= v0 &&\n(*((short *)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v2 =\n&v2[1]); | ~~ ^ /tmp/tmpb4a5qsts/strstrip_name_conflict.c:31:103: error: cannot take the\naddress of an rvalue of type 'int' 31 |     for (*((char *)(v2 + 1)) = 0;\n*((char *)v0) && (*((short *)((*((char *)v0) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v0 += 1); | ^~~~~~~~~~~~~~~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strrev_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x28]\n  char *v1;              // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v2 = strlen(a0);\n  v1 = calloc(v2 + 1, 1);\n  if (!v1)\n    return 0;\n  for (v3 = 0; v3 < v2; v3 += 1) {\n    v0 = v2 - v3 - 1;\n    v1[v3] = a0[v0];\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4202636];\n  unsigned int field_40208c;\n} struct_0;\n\nextern char g_40208c;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long count_nucleotides_name_conflict(unsigned long long a0[5], char *a1) {\n  int v0;                 // [bp-0x58], Other Possible Types: unsigned long\n  unsigned long v1;       // [bp-0x50]\n  int v2;                 // [bp-0x48], Other Possible Types: unsigned long\n  unsigned long v3;       // [bp-0x40]\n  void *v4;               // [bp-0x38], Other Possible Types: unsigned long\n  char *v5;               // [bp-0x28]\n  unsigned long v6;       // [bp-0x20]\n  unsigned long v7;       // [bp-0x10]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long v11;      // rbx\n  struct_0 *v12;          // rax\n  unsigned long long v14; // rbx\n\n  v10 = &v8;\n  v7 = v11;\n  v5 = strlen(a1);\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v2) = 0;\n  v4 = 0;\n  for (v6 = 0; v6 < v5; v6 += 1) {\n    v12 = a1[v6] - 65;\n    switch ((unsigned int)v12) {\n    case 0:\n    case 32:\n      v0 = (long long)v0 + 1;\n      break;\n    case 2:\n    case 34:\n      v1 = (long long)(&v0)[8] + 1;\n      break;\n    case 6:\n    case 38:\n      v2 = (long long)v2 + 1;\n      break;\n    case 19:\n    case 51:\n      v3 = (long long)(&v2)[8] + 1;\n      break;\n    case 20:\n    case 52:\n      v4 += 1;\n      break;\n    default:\n      fprintf(stderr @GLIBC_2.2.5,\n              \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\", a1[v6]);\n      v6 = v5;\n      break;\n    }\n  }\n  a0[0] = (long long)v0;\n  a0[1] = (long long)(&v0)[8];\n  a0[2] = (long long)v2;\n  a0[3] = (long long)(&v2)[8];\n  a0[4] = v4;\n  v14 = v7;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx7cjf6n7/count_nucleotides_name_conflict.c:25:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 25 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpx7cjf6n7/count_nucleotides_name_conflict.c:25:22: error: expected ';' after top level\ndeclarator 25 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpx7cjf6n7/count_nucleotides_name_conflict.c:46:18: error: expected expression\n   46 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmpx7cjf6n7/count_nucleotides_name_conflict.c:47:18: error: expected expression\n   47 |     *((int128_t *)&v2) = 0;\n      |                  ^\n/tmp/tmpx7cjf6n7/count_nucleotides_name_conflict.c:70:27: error: expected ')'\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict(): Unexpected\ncharacter: '%c'\\n\", a1[v6]); |                           ^\n/tmp/tmpx7cjf6n7/count_nucleotides_name_conflict.c:70:20: note: to match this '('\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict(): Unexpected\ncharacter: '%c'\\n\", a1[v6]); |                    ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long transcribe_dna_to_rna_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = strdup(a0);\n  v0 = strlen(v1);\n  for (v2 = 0; v2 < v0; v2 += 1) {\n    if (v1[v2] == 116 || v1[v2] == 84)\n      v1[v2] = v1[v2] + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[4202848];\n  unsigned int field_402160;\n} struct_0;\n\nextern char g_402160;\n\nlong long get_dna_complement_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  struct_0 *v6;          // rax\n\n  v5 = &v3;\n  v1 = strdup(a0);\n  v0 = strlen(v1);\n  v2 = 0;\n  while (true) {\n    if (v2 < v0) {\n      v6 = v1[v2] - 65;\n      switch ((unsigned int)v6) {\n      case 0:\n      case 32:\n        v1[v2] = 84;\n        break;\n      case 2:\n      case 34:\n        v1[v2] = 71;\n        break;\n      case 6:\n      case 38:\n        v1[v2] = 67;\n        break;\n      case 19:\n      case 51:\n        v1[v2] = 65;\n        break;\n      default:\n        free(v1);\n        return 0;\n      }\n      v2 += 1;\n    } else {\n      return v1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamming_distance_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned long v1;      // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  void *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v1 = strlen(a0);\n  v0 = strlen(a1);\n  if (v1 != v0)\n    return -1;\n  v3 = 0;\n  for (v2 = 0; v2 < v1; v2 += 1) {\n    if (a0[v2] != *((char *)(v2 + a1)))\n      v3 += 1;\n  }\n  return v3;\n}\n","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strstrip_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x18]\n  char v2[2];            // [bp-0x10], Other Possible Types: unsigned long\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v0 = a0;\n  v1 = strlen(v0);\n  if (!v1)\n    return v0;\n  for (*((char **)&v2) = &v0[1 + v1];\n       v2 >= v0 &&\n       (*((short *)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000);\n       v2 = &v2[1])\n    ;\n  for (*((char *)(v2 + 1)) = 0;\n       *((char *)v0) &&\n       (*((short *)((*((char *)v0) << 1) + *((long long *)&__ctype_b_loc()))) &\n        0x2000);\n       v0 += 1)\n    ;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaenr0ev6/strstrip_name_conflict.c:30:96: error: cannot take the address of an rvalue\nof type 'int' 30 |     for (*((char **)&v2) = &v0[1 + v1]; v2 >= v0 && (*((short\n*)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v2 = &v2[1]); |\n^~~~~~~~~~~~~~~~ /tmp/tmpaenr0ev6/strstrip_name_conflict.c:30:130: error: array type 'char[2]'\nis not assignable 30 |     for (*((char **)&v2) = &v0[1 + v1]; v2 >= v0 &&\n(*((short *)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v2 =\n&v2[1]); | ~~ ^ /tmp/tmpaenr0ev6/strstrip_name_conflict.c:31:103: error: cannot take the\naddress of an rvalue of type 'int' 31 |     for (*((char *)(v2 + 1)) = 0;\n*((char *)v0) && (*((short *)((*((char *)v0) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v0 += 1); | ^~~~~~~~~~~~~~~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strrev_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x28]\n  char *v1;              // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v2 = strlen(a0);\n  v1 = calloc(v2 + 1, 1);\n  if (!v1)\n    return 0;\n  for (v3 = 0; v3 < v2; v3 += 1) {\n    v0 = v2 - v3 - 1;\n    v1[v3] = a0[v0];\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4202652];\n  unsigned int field_40209c;\n} struct_0;\n\nextern char g_40209c;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long count_nucleotides_name_conflict(unsigned long long a0[5], char *a1) {\n  int v0;                 // [bp-0x58], Other Possible Types: unsigned long\n  unsigned long v1;       // [bp-0x50]\n  int v2;                 // [bp-0x48], Other Possible Types: unsigned long\n  unsigned long v3;       // [bp-0x40]\n  void *v4;               // [bp-0x38], Other Possible Types: unsigned long\n  char *v5;               // [bp-0x28]\n  unsigned long v6;       // [bp-0x20]\n  unsigned long v7;       // [bp-0x10]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long v11;      // rbx\n  struct_0 *v12;          // rax\n  unsigned long long v14; // rbx\n\n  v10 = &v8;\n  v7 = v11;\n  v5 = strlen(a1);\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v2) = 0;\n  v4 = 0;\n  for (v6 = 0; v6 < v5; v6 += 1) {\n    v12 = a1[v6] - 65;\n    switch ((unsigned int)v12) {\n    case 0:\n    case 32:\n      v0 = (long long)v0 + 1;\n      break;\n    case 2:\n    case 34:\n      v1 = (long long)(&v0)[8] + 1;\n      break;\n    case 6:\n    case 38:\n      v2 = (long long)v2 + 1;\n      break;\n    case 19:\n    case 51:\n      v3 = (long long)(&v2)[8] + 1;\n      break;\n    case 20:\n    case 52:\n      v4 += 1;\n      break;\n    default:\n      fprintf(stderr @GLIBC_2.2.5,\n              \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\", a1[v6]);\n      v6 = v5;\n      break;\n    }\n  }\n  a0[0] = (long long)v0;\n  a0[1] = (long long)(&v0)[8];\n  a0[2] = (long long)v2;\n  a0[3] = (long long)(&v2)[8];\n  a0[4] = v4;\n  v14 = v7;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl0udqs68/count_nucleotides_name_conflict.c:25:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 25 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpl0udqs68/count_nucleotides_name_conflict.c:25:22: error: expected ';' after top level\ndeclarator 25 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpl0udqs68/count_nucleotides_name_conflict.c:46:18: error: expected expression\n   46 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmpl0udqs68/count_nucleotides_name_conflict.c:47:18: error: expected expression\n   47 |     *((int128_t *)&v2) = 0;\n      |                  ^\n/tmp/tmpl0udqs68/count_nucleotides_name_conflict.c:70:27: error: expected ')'\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict(): Unexpected\ncharacter: '%c'\\n\", a1[v6]); |                           ^\n/tmp/tmpl0udqs68/count_nucleotides_name_conflict.c:70:20: note: to match this '('\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict(): Unexpected\ncharacter: '%c'\\n\", a1[v6]); |                    ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long transcribe_dna_to_rna_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = strdup(a0);\n  v0 = strlen(v1);\n  for (v2 = 0; v2 < v0; v2 += 1) {\n    if (v1[v2] == 116 || v1[v2] == 84)\n      v1[v2] = v1[v2] + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[4202864];\n  unsigned int field_402170;\n} struct_0;\n\nextern char g_402170;\n\nlong long get_dna_complement_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  struct_0 *v6;          // rax\n\n  v5 = &v3;\n  v1 = strdup(a0);\n  v0 = strlen(v1);\n  for (v2 = 0; v2 < v0; v2 += 1) {\n    v6 = v1[v2] - 65;\n    switch ((unsigned int)v6) {\n    case 0:\n    case 32:\n      v1[v2] = 84;\n      break;\n    case 2:\n    case 34:\n      v1[v2] = 71;\n      break;\n    case 6:\n    case 38:\n      v1[v2] = 67;\n      break;\n    case 19:\n    case 51:\n      v1[v2] = 65;\n      break;\n    default:\n      free(v1);\n      return 0;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamming_distance_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned long v1;      // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  void *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v1 = strlen(a0);\n  v0 = strlen(a1);\n  if (v1 != v0)\n    return -1;\n  v3 = 0;\n  for (v2 = 0; v2 < v1; v2 += 1) {\n    if (a0[v2] != *((char *)(v2 + a1)))\n      v3 += 1;\n  }\n  return v3;\n}\n","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strstrip_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x18]\n  char v2[2];            // [bp-0x10], Other Possible Types: unsigned long\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v0 = a0;\n  v1 = strlen(v0);\n  if (!v1)\n    return v0;\n  for (*((char **)&v2) = &v0[1 + v1];\n       v2 >= v0 &&\n       (*((short *)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000);\n       v2 = &v2[1])\n    ;\n  for (*((char *)(v2 + 1)) = 0;\n       *((char *)v0) &&\n       (*((short *)((*((char *)v0) << 1) + *((long long *)&__ctype_b_loc()))) &\n        0x2000);\n       v0 += 1)\n    ;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw7n3ieo1/strstrip_name_conflict.c:30:96: error: cannot take the address of an rvalue\nof type 'int' 30 |     for (*((char **)&v2) = &v0[1 + v1]; v2 >= v0 && (*((short\n*)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v2 = &v2[1]); |\n^~~~~~~~~~~~~~~~ /tmp/tmpw7n3ieo1/strstrip_name_conflict.c:30:130: error: array type 'char[2]'\nis not assignable 30 |     for (*((char **)&v2) = &v0[1 + v1]; v2 >= v0 &&\n(*((short *)((v2[0] << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v2 =\n&v2[1]); | ~~ ^ /tmp/tmpw7n3ieo1/strstrip_name_conflict.c:31:103: error: cannot take the\naddress of an rvalue of type 'int' 31 |     for (*((char *)(v2 + 1)) = 0;\n*((char *)v0) && (*((short *)((*((char *)v0) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v0 += 1); | ^~~~~~~~~~~~~~~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strrev_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x28]\n  char *v1;              // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v2 = strlen(a0);\n  v1 = calloc(v2 + 1, 1);\n  if (!v1)\n    return 0;\n  for (v3 = 0; v3 < v2; v3 += 1) {\n    v0 = v2 - v3 - 1;\n    v1[v3] = a0[v0];\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char hashmap;\n\nlong long rot13_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x9]\n  unsigned int v3; // eax\n\n  v3 = *((short *)(*((long long *)&__ctype_b_loc()) + (char)a0 * 2)) & 0x400;\n  if (!v3)\n    return (char)a0;\n  v0 = (char)a0 - 65;\n  return *(&(&hashmap)[v0]);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvbqykqnz/rot13_name_conflict.c:24:37: error: cannot take the address of an rvalue of\ntype 'int' 24 |     v3 = *((short *)(*((long long *)&__ctype_b_loc()) + (char)a0\n* 2)) & 0x400; |                                     ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(rot13)(long long);\n\nlong long srot13_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  unsigned long v6;      // rbx\n  unsigned long long v7; // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = strlen(a0);\n  for (v1 = 0; v1 < v0; v1 += 1) {\n    a0[v1] = rot13(a0[v1]);\n  }\n  v7 = v2;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char hashmap;\n\nlong long rot13_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x9]\n  unsigned int v3; // eax\n\n  v3 = *((short *)(*((long long *)&__ctype_b_loc()) + (char)a0 * 2)) & 0x400;\n  if (!v3)\n    return (char)a0;\n  v0 = (char)a0 - 65;\n  return *(&(&hashmap)[v0]);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcpv4r7uv/rot13_name_conflict.c:24:37: error: cannot take the address of an rvalue of\ntype 'int' 24 |     v3 = *((short *)(*((long long *)&__ctype_b_loc()) + (char)a0\n* 2)) & 0x400; |                                     ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(rot13)(long long);\n\nlong long srot13_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  unsigned long v6;      // rbx\n  unsigned long long v7; // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = strlen(a0);\n  for (v1 = 0; v1 < v0; v1 += 1) {\n    a0[v1] = rot13(a0[v1]);\n  }\n  v7 = v2;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *s_tolower(char *s) {\n    char *cp;\n    if (s == ((void *)0))\n        return ((void *)0);\n    if (!*s)\n        return s;\n    for (cp = s; (*cp = tolower(*cp)); cp++)\n        ;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tolower)(int);\n\nlong long s_tolower_name_conflict(char *a0) {\n  char *v0;              // [bp-0x10], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (!a0) {\n    return 0;\n  } else if (!*(a0)) {\n    return a0;\n  } else {\n    v0 = a0;\n    while (true) {\n      *(v0) = tolower(*(v0));\n      if (!*(v0))\n        break;\n      v0 += 1;\n    }\n    return a0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":0,"function":"int s_tokenize(char *s, char *tokens[], int ntoks, const char *delims) {\n    register int i;\n    if (s == ((void *)0) || tokens == ((void *)0) || delims == ((void *)0) || !*s || !*delims || ntoks < 1)\n        return 0;\n    tokens[0] = strtok(s, delims);\n    if (tokens[0] == ((void *)0))\n        return 0;\n    for (i = 1; i < ntoks && (tokens[i] = strtok(((void *)0), delims)) != ((void *)0); i++)\n        ;\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok)(char *, char *);\n\nlong long s_tokenize(char *a0, unsigned long long *a1, unsigned long a2,\n                     char *a3) {\n  unsigned long v2;       // rbx, Other Possible Types: unsigned long long\n  unsigned long long *v3; // r12\n\n  if (a0 && a1 && a3 && *(a0) && *(a3) && (unsigned int)a2 > 0) {\n    *(a1) = strtok(a0, a3);\n    if (!*(a1))\n      return 0;\n    for (v2 = 1; (unsigned int)v2 < (unsigned int)a2 &&\n                 (v3 = v2 * 8 + a1,\n                 *(v3) = (unsigned long long)strtok(NULL, a3), *(v3));\n         v2 = (unsigned int)v2 + 1)\n      ;\n    return v2;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":0,"function":"static inline size_t SCREEN(size_t x, size_t y) {\n    y = min(y, (terminal.rows - 1));\n    if (between(y, terminal.page.top, terminal.page.bottom)) {\n        return PAGE(x, y - terminal.page.top);\n    } else {\n        return y * terminal.cols + min(x, (terminal.cols - 1));\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(min)(long long, long long);\nlong long(between)(long long, long long, long long);\nlong long(PAGE)(long long, long long);\n\nextern unsigned long long g_413648;\nextern unsigned long long g_413670;\nextern unsigned long long g_413678;\nextern unsigned long long terminal;\n\nlong long SCREEN_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long long v0; // [bp-0x28]\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v0 = a1;\n  v0 = ::0x405975 ::min(v0, (unsigned int)g_413648 - 1);\n  if ((char)::0x4059a3 ::between(v0, g_413670, g_413678)) {\n    v2 = PAGE(a0, v0 - g_413670);\n    return v2;\n  }\n  v2 = ::0x405975 ::min(a0, (unsigned int)terminal - 1) + v0 * terminal;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprk437b9k/SCREEN_name_conflict.c:31:10: error: expected expression\n   31 |     v0 = ::0x405975::min(v0, (unsigned int)g_413648 - 1);\n      |          ^\n/tmp/tmprk437b9k/SCREEN_name_conflict.c:32:15: error: expected expression\n   32 |     if ((char)::0x4059a3::between(v0, g_413670, g_413678))\n      |               ^\n/tmp/tmprk437b9k/SCREEN_name_conflict.c:37:10: error: expected expression\n   37 |     v2 = ::0x405975::min(a0, (unsigned int)terminal - 1) + v0 *\nterminal; |          ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool term_flushlines() {\n    size_t row;\n    size_t col_start, col_stop, col_this;\n    struct glyph_t *start, *this;\n    bool retval = 0;\n    wchar_t *buffer = emalloc(terminal.cols * sizeof (*buffer));\n    for (row = 0; row < terminal.rows; row++) {\n        col_start = terminal.dirty[row].left;\n        col_stop = terminal.dirty[row].right;\n        start = terminal.text + SCREEN(col_start, row);\n        for (col_this = col_start , this = start; col_this < col_stop; col_this++ , this++) {\n            buffer[col_this] = this->c;\n            if ((start->c != '\\x00') != (this->c != '\\x00') || start->background != this->background || start->foreground != this->foreground || start->attr != this->attr) {\n                term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n                col_start = col_this;\n                start = this;\n                retval = 1;\n            }\n        }\n        if (col_stop > col_start) {\n            term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n            retval = 1;\n        }\n        terminal.dirty[row].left = terminal.dirty[row].right = 0;\n    }\n    free(buffer);\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(emalloc)(long long);\nlong long(SCREEN)(long long, long long);\nlong long(term_flush_section)(long long, long long, long long, long long,\n                              long long, long long, int);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n  char field_c;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[8];\n  unsigned long long field_8;\n} struct_1;\n\nextern unsigned long long g_413648;\nextern unsigned long long g_413650;\nextern unsigned long long g_4136a0;\nextern unsigned long long terminal;\n\nlong long term_flushlines_name_conflict() {\n  unsigned long v0;       // [bp-0x58]\n  void *v1;               // [bp-0x50]\n  char v2;                // [bp-0x41]\n  struct_0 *v3;           // [bp-0x40], Other Possible Types: unsigned long\n  struct_0 *v4;           // [bp-0x38], Other Possible Types: unsigned long\n  unsigned long v5;       // [bp-0x30]\n  unsigned long v6;       // [bp-0x28], Other Possible Types: unsigned long long\n  unsigned long long *v7; // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v8;       // [bp-0x10]\n  char v9;                // [bp-0x8]\n  unsigned long long v11; // rbp\n  unsigned long v12;      // rbx\n  unsigned int *v13;      // rdx\n  unsigned int v14;       // eax\n  struct_1 *v15;          // rax\n  unsigned long long v16; // rbx\n\n  v11 = &v9;\n  v8 = v12;\n  v2 = 0;\n  v1 = emalloc(terminal * 4);\n  for (v7 = 0; v7 < g_413648; v7 = (char *)v7 + 1) {\n    v6 = *((long long *)(g_4136a0 + v7 * 16));\n    v0 = *((long long *)(g_4136a0 + v7 * 16 + 8));\n    v4 = SCREEN(v6, v7) * 16 + g_413650;\n    v5 = v6;\n    for (v3 = v4; v5 < v0; v3 = (char *)&v3[1].field_0 + 3) {\n      v13 = v5 * 4 + v1;\n      *(v13) = v3->field_0;\n      *((char *)&v13) = *((int *)v4);\n      v14 = v3->field_0;\n      *((char *)&v14) = v14;\n      if ((char)(v14 ^ (unsigned int)v13) ||\n          *((int *)(v4 + 8)) != v3->field_8 ||\n          *((int *)(v4 + 4)) != v3->field_4 ||\n          *((char *)(v4 + 12)) != v3->field_c) {\n        term_flush_section(v6, v7, v6 * 4 + v1, v5 - v6, v4->field_4,\n                           v4->field_8, v4->field_c);\n        v6 = v5;\n        v4 = v3;\n        v2 = 1;\n      }\n      v5 += 1;\n    }\n    if (v6 < v0) {\n      term_flush_section(v6, v7, v6 * 4 + v1, v5 - v6, v4->field_4, v4->field_8,\n                         v4->field_c);\n      v2 = 1;\n    }\n    v15 = g_4136a0 + v7 * 16;\n    v15->field_8 = 0;\n    *((unsigned long long *)(g_4136a0 + v7 * 16)) = v15->field_8;\n  }\n  free(v1);\n  v16 = v8;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqo5smvjl/term_flushlines_name_conflict.c:62:44: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 62 |         v6 = *((long long\n*)(g_4136a0 + v7 * 16)); |                                         ~~ ^ ~~\n/tmp/tmpqo5smvjl/term_flushlines_name_conflict.c:63:44: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 63 |         v0 = *((long long\n*)(g_4136a0 + v7 * 16 + 8)); |                                         ~~ ^ ~~\n/tmp/tmpqo5smvjl/term_flushlines_name_conflict.c:87:29: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 87 |         v15 = g_4136a0 + v7 *\n16; |                          ~~ ^ ~~ /tmp/tmpqo5smvjl/term_flushlines_name_conflict.c:89:48:\nerror: invalid operands to binary expression ('unsigned long long *' and 'int')\n   89 |         *((unsigned long long *)(g_4136a0 + v7 * 16)) = v15->field_8;\n      |                                             ~~ ^ ~~\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"size_t term_write(char *utf8s) {\n    size_t n;\n    wchar_t ucs2char;\n    char *utf8s_orig = utf8s;\n    do {\n        if (*utf8s == '\\x00') {\n            break;\n        } else if (term_do_control_char(*utf8s)) {\n            n = 1;\n        } else if ((n = utf8towchar(utf8s, &ucs2char)) > 0) {\n            term_writechar(ucs2char);\n        }\n        utf8s += n;\n    } while (n);\n    return utf8s - utf8s_orig;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(term_do_control_char)(long long);\nlong long(utf8towchar)(long long, long long);\nlong long(term_write_name_conflictchar)(long long);\n\nlong long term_write_name_conflict(char *a0) {\n  char *v0;              // [bp-0x30], Other Possible Types: unsigned long\n  char v1;               // [bp-0x1c]\n  char *v2;              // [bp-0x18]\n  unsigned long v3;      // [bp-0x10], Other Possible Types: unsigned long long\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v0 = a0;\n  v2 = v0;\n  while (*((char *)v0)) {\n    if ((char)term_do_control_char(*((char *)v0))) {\n      v3 = 1;\n    } else {\n      v3 = utf8towchar(v0, &v1);\n      if (v3)\n        term_write_name_conflictchar(*((int *)&v1));\n    }\n    v0 += v3;\n    if (!v3)\n      return v0 - v2;\n  }\n  return v0 - v2;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"bool term_handle_keypress(KeySym key, uint32_t mod) {\n    size_t i;\n    if (mod & (1 << 3)) {\n        term_cb->write_host(\"\\033\", 1);\n    }\n    if (key == 65293) {\n        if (terminal.crlf) {\n            term_cb->write_host(\"\\r\\n\", 2);\n        } else {\n            term_cb->write_host(\"\\r\", 1);\n        }\n        return 1;\n    }\n    for (i = 0; i < (sizeof (keymap) / sizeof (keymap[0])); i++) {\n        if (keymap[i].key == key && keymap[i].mod == (mod & ~(1 << 3))) {\n            term_cb->write_host(keymap[i].out, strlen(keymap[i].out));\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint term_cb; // add global variable by heuristics\nint term_cb; // add global variable by heuristics\nint term_cb; // add global variable by heuristics\nint term_cb; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_3 {\n  char padding_0[4270480];\n  char *field_412990;\n} struct_3;\n\ntypedef struct struct_2 {\n  char padding_0[4270480];\n  unsigned long long field_412990;\n} struct_2;\n\nextern unsigned long long g_40f938;\nextern unsigned int g_412988[4];\nextern char g_412990;\nextern char g_4136b0;\nextern unsigned long long keymap[4];\n\nlong long term_handle_keypress_name_conflict(unsigned long a0, unsigned long a1) {\n  struct_3 *v0;          // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x10]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rbx\n  unsigned long long v6; // rax\n  struct_2 *v8;          // rcx\n\n  v4 = &v2;\n  v1 = v5;\n  if (((char)a1 & 8))\n    term_cb->field_0(&g_40f938, 1, &g_40f938);\n  if (a0 == 65293) {\n    if (!g_4136b0)\n      term_cb->field_0(\"\\r\", 1, \"\\r\");\n    else\n      term_cb->field_0(\"\\r\\n\", 2, \"\\r\\n\");\n    return 1;\n  } else {\n    for (v0 = 0; v0 <= 89; v0 = &v0->padding_0[1]) {\n      if (a0 == *((long long *)(0x20 * v0 + (char *)&keymap[0])) &&\n          *((int *)(0x20 * v0 + (char *)&g_412988[0])) ==\n              ((unsigned int)a1 & -9)) {\n        v6 = strlen(*((long long *)&(&g_412990)[32 * v0]));\n        v8 = v0 * 32;\n        term_cb->field_0(*((long long *)(v8 + &g_412990)), v6, v6, v8);\n        return 1;\n      }\n    }\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:50:18: error: member reference type\n'int' is not a pointer 50 |         term_cb->field_0(&g_40f938, 1, &g_40f938);\n      |         ~~~~~~~  ^\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:54:22: error: member reference type\n'int' is not a pointer 54 |             term_cb->field_0(\"\\r\", 1, \"\\r\"); |\n~~~~~~~  ^ /tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:56:22: error: member\nreference type 'int' is not a pointer 56 |             term_cb->field_0(\"\\r\\n\",\n2, \"\\r\\n\"); |             ~~~~~~~  ^\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:63:44: error: invalid operands to binary\nexpression ('int' and 'struct_3 *' (aka 'struct struct_3 *')) 63 | if (a0 ==\n*((long long *)(0x20 * v0 + (char *)&keymap[0])) && *((int *)(0x20 * v0 + (char\n*)&g_412988[0])) == ((unsigned int)a1 & -9)) | ~~~~ ^ ~~\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:63:90: error: invalid operands to binary\nexpression ('int' and 'struct_3 *' (aka 'struct struct_3 *')) 63 | if (a0 ==\n*((long long *)(0x20 * v0 + (char *)&keymap[0])) && *((int *)(0x20 * v0 + (char\n*)&g_412988[0])) == ((unsigned int)a1 & -9)) | ~~~~ ^ ~~\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:65:60: error: invalid operands to binary\nexpression ('int' and 'struct_3 *' (aka 'struct struct_3 *')) 65 | v6 =\nstrlen(*((long long *)&(&g_412990)[32 * v0])); | ~~ ^ ~~\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:66:25: error: invalid operands to binary\nexpression ('struct_3 *' (aka 'struct struct_3 *') and 'int') 66 | v8 = v0 * 32;\n      |                      ~~ ^ ~~\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:67:26: error: member reference type\n'int' is not a pointer 67 |                 term_cb->field_0(*((long long *)(v8\n+ &g_412990)), v6, v6, v8); |                 ~~~~~~~  ^\n/tmp/tmpp_0f_8ql/term_handle_keypress_name_conflict.c:67:53: error: invalid operands to binary\nexpression ('struct_2 *' (aka 'struct struct_2 *') and 'char *') 67 |\nterm_cb->field_0(*((long long *)(v8 + &g_412990)), v6, v6, v8); | ~~ ^ ~~~~~~~~~\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(between)(long long, long long, long long);\nlong long(esc_csi_dispatch)(long long);\nlong long(esc_clear)();\nlong long(esc_collect)(long long);\n\nlong long esc_state_csi_name_conflict(unsigned long a0) {\n  if ((char)::0x40a147 ::between((char)a0, 64, 126)) {\n    esc_csi_dispatch((char)a0);\n    esc_clear();\n    return 1;\n  } else if ((char)a0 == 127) {\n    return 1;\n  } else if ((char)a0 > 31) {\n    esc_collect((char)a0);\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxvj5hubh/esc_state_csi_name_conflict.c:23:15: error: expected expression\n   23 |     if ((char)::0x40a147::between((char)a0, 64, 126))\n      |               ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\nlong long(between)(long long, long long, long long);\nlong long(esc_collect)(long long);\n\nlong long esc_state_osc_name_conflict(unsigned long a0) {\n  if ((char)a0 == 7) {\n    esc_clear();\n    return 1;\n  } else if (!(char)::0x40a147 ::between((char)a0, 0, 31)) {\n    esc_collect((char)a0);\n    return 1;\n  } else {\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpws1_uiwn/esc_state_osc_name_conflict.c:27:21: error: expected expression\n   27 |     else if (!(char)::0x40a147::between((char)a0, 0, 31))\n      |                     ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long esc_state_wait_for_ST_name_conflict(unsigned long a0) {\n  char v0; // [bp-0xc]\n\n  v0 = a0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint esc_seq;          // add global variable by heuristics\nint esc_seq;          // add global variable by heuristics\nint esc_state_escape; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\n\nextern struct_0 *esc_seq;\n\nlong long esc_handle_name_conflict(unsigned long a0) {\n  if ((char)a0 != 27 && (char)a0 != 26 && (char)a0 != 24) {\n    if (!esc_seq)\n      return 0;\n    return esc_seq((char)a0);\n  }\n  esc_clear();\n  if ((char)a0 == 27)\n    esc_seq = &esc_state_escape;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmgdifa9m/esc_handle_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *esc_seq; |        ^~~~~~~~ |        struct\n/tmp/tmpmgdifa9m/esc_handle_name_conflict.c:21:8: error: declaration of anonymous struct must\nbe a definition /tmp/tmpmgdifa9m/esc_handle_name_conflict.c:29:23: error: called object type\n'int' is not a function or function pointer 29 |         return\nesc_seq((char)a0); |                ~~~~~~~^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static inline wchar_t O(size_t col, size_t row) {\n    oflush();\n    return output.text[oindex(col, row)];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BO_name_conflictT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BO_name_conflictT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(oflush)();\nlong long(oindex)(long long, long long);\n\nextern unsigned long long output;\n\nlong long O_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned long long v4; // rbx\n\n  v0 = v2;\n  oflush();\n  v4 = v0;\n  return *((int *)(oindex(a0, a1) * 4 + output));\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t F(size_t col, size_t row) {\n    oflush();\n    return output.fgs[oindex(col, row)];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(oflush)();\nlong long(oindex)(long long, long long);\n\nextern unsigned long long g_413508;\n\nlong long F_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned long long v4; // rbx\n\n  v0 = v2;\n  oflush();\n  v4 = v0;\n  return *((int *)(oindex(a0, a1) * 4 + g_413508));\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t B(size_t col, size_t row) {\n    oflush();\n    return output.bgs[oindex(col, row)];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int B_name_conflictOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int B_name_conflictOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(oflush)();\nlong long(oindex)(long long, long long);\n\nextern unsigned long long g_413510;\n\nlong long B_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned long long v4; // rbx\n\n  v0 = v2;\n  oflush();\n  v4 = v0;\n  return *((int *)(oindex(a0, a1) * 4 + g_413510));\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline uint32_t A(size_t col, size_t row) {\n    oflush();\n    return output.attrs[oindex(col, row)];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(oflush)();\nlong long(oindex)(long long, long long);\n\nextern unsigned long long g_413518;\n\nlong long A_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned long long v4; // rbx\n\n  v0 = v2;\n  oflush();\n  v4 = v0;\n  return *((int *)(oindex(a0, a1) * 4 + g_413518));\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"bool oisempty() {\n    size_t x, y;\n    for (y = 0; y < output.rows; y++) {\n        for (x = 0; x < output.cols; x++) {\n            if (O(x, y) != L'\\x00') {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(O)(long long, long long);\n\nextern unsigned long long g_413520;\nextern unsigned long long g_413528;\n\nlong long oisempty_name_conflict() {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  void *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  for (v0 = 0; v0 < g_413528; v0 += 1) {\n    for (v1 = 0; v1 < g_413520; v1 += 1) {\n      if ((int)O(v1, v0))\n        return 0;\n    }\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_reset\");\n        char *message = test_reset();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_movement\");\n        char *message = test_movement();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_crlf\");\n        char *message = test_crlf();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_line\");\n        char *message = test_erase_line();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_display\");\n        char *message = test_erase_display();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_newline\");\n        char *message = test_newline();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_control_characters\");\n        char *message = test_control_characters();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_ignored_controls\");\n        char *message = test_ignored_controls();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_statusreport\");\n        char *message = test_statusreport();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_DECALN\");\n        char *message = test_DECALN();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_scrollregion\");\n        char *message = test_scrollregion();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_wraparound\");\n        char *message = test_wraparound();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_editing\");\n        char *message = test_editing();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_repeat\");\n        char *message = test_repeat();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_col_modes\");\n        char *message = test_col_modes();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_style\");\n        char *message = test_style();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_tabstops\");\n        char *message = test_tabstops();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_cursor\");\n        char *message = test_cursor();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_reset)();\nlong long(test_movement)();\nlong long(test_crlf)();\nlong long(test_erase_line)();\nlong long(test_erase_display)();\nlong long(test_newline)();\nlong long(test_control_characters)();\nlong long(test_ignored_controls)();\nlong long(test_statusreport)();\nlong long(test_DECALN)();\nlong long(test_scrollregion)();\nlong long(test_wraparound)();\nlong long(test_editing)();\nlong long(test_repeat)();\nlong long(test_col_modes)();\nlong long(test_style)();\nlong long(test_tabstops)();\nlong long(test_cursor)();\n\nextern char g_40ed42;\nextern char g_40ed55;\nextern char g_40ed63;\nextern char g_40ed6d;\nextern char g_40ed7d;\nextern char g_40ed90;\nextern char g_40ed9d;\nextern char g_40edb5;\nextern char g_40edcb;\nextern char g_40eddd;\nextern char g_40ede9;\nextern char g_40edfb;\nextern char g_40ee0b;\nextern char g_40ee18;\nextern char g_40ee24;\nextern char g_40ee33;\nextern char g_40ee3e;\nextern char g_40ee4c;\nextern unsigned int tests_run;\n\nlong long run_tests_name_conflict() {\n  unsigned long v0;  // [bp-0x98]\n  unsigned long v1;  // [bp-0x90]\n  unsigned long v2;  // [bp-0x88]\n  unsigned long v3;  // [bp-0x80]\n  unsigned long v4;  // [bp-0x78]\n  unsigned long v5;  // [bp-0x70]\n  unsigned long v6;  // [bp-0x68]\n  unsigned long v7;  // [bp-0x60]\n  unsigned long v8;  // [bp-0x58]\n  unsigned long v9;  // [bp-0x50]\n  unsigned long v10; // [bp-0x48]\n  unsigned long v11; // [bp-0x40]\n  unsigned long v12; // [bp-0x38]\n  unsigned long v13; // [bp-0x30]\n  unsigned long v14; // [bp-0x28]\n  unsigned long v15; // [bp-0x20]\n  unsigned long v16; // [bp-0x18]\n  unsigned long v17; // [bp-0x10]\n\n  printf(\"--> %s\\n\", &g_40ed42);\n  v17 = test_reset();\n  tests_run = tests_run + 1;\n  if (v17)\n    return v17;\n  printf(\"--> %s\\n\", &g_40ed55);\n  v16 = test_movement();\n  tests_run = tests_run + 1;\n  if (v16)\n    return v16;\n  printf(\"--> %s\\n\", &g_40ed63);\n  v15 = test_crlf();\n  tests_run = tests_run + 1;\n  if (v15)\n    return v15;\n  printf(\"--> %s\\n\", &g_40ed6d);\n  v14 = test_erase_line();\n  tests_run = tests_run + 1;\n  if (v14)\n    return v14;\n  printf(\"--> %s\\n\", &g_40ed7d);\n  v13 = test_erase_display();\n  tests_run = tests_run + 1;\n  if (v13)\n    return v13;\n  printf(\"--> %s\\n\", &g_40ed90);\n  v12 = test_newline();\n  tests_run = tests_run + 1;\n  if (v12)\n    return v12;\n  printf(\"--> %s\\n\", &g_40ed9d);\n  v11 = test_control_characters();\n  tests_run = tests_run + 1;\n  if (v11)\n    return v11;\n  printf(\"--> %s\\n\", &g_40edb5);\n  v10 = test_ignored_controls();\n  tests_run = tests_run + 1;\n  if (v10)\n    return v10;\n  printf(\"--> %s\\n\", &g_40edcb);\n  v9 = test_statusreport();\n  tests_run = tests_run + 1;\n  if (v9)\n    return v9;\n  printf(\"--> %s\\n\", &g_40eddd);\n  v8 = test_DECALN();\n  tests_run = tests_run + 1;\n  if (v8)\n    return v8;\n  printf(\"--> %s\\n\", &g_40ede9);\n  v7 = test_scrollregion();\n  tests_run = tests_run + 1;\n  if (v7)\n    return v7;\n  printf(\"--> %s\\n\", &g_40edfb);\n  v6 = test_wraparound();\n  tests_run = tests_run + 1;\n  if (v6)\n    return v6;\n  printf(\"--> %s\\n\", &g_40ee0b);\n  v5 = test_editing();\n  tests_run = tests_run + 1;\n  if (v5)\n    return v5;\n  printf(\"--> %s\\n\", &g_40ee18);\n  v4 = test_repeat();\n  tests_run = tests_run + 1;\n  if (v4)\n    return v4;\n  printf(\"--> %s\\n\", &g_40ee24);\n  v3 = test_col_modes();\n  tests_run = tests_run + 1;\n  if (v3)\n    return v3;\n  printf(\"--> %s\\n\", &g_40ee33);\n  v2 = test_style();\n  tests_run = tests_run + 1;\n  if (v2)\n    return v2;\n  printf(\"--> %s\\n\", &g_40ee3e);\n  v1 = test_tabstops();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40ee4c);\n  v0 = test_cursor();\n  tests_run = tests_run + 1;\n  return (!v0 ? v0 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(between)(long long, long long, long long);\nlong long(esc_csi_dispatch)(long long);\nlong long(esc_clear)();\nlong long(esc_collect)(long long);\n\nlong long esc_state_csi_name_conflict(unsigned long a0) {\n  if ((char)between((char)a0, 64, 126)) {\n    esc_csi_dispatch((char)a0);\n    esc_clear();\n    return 1;\n  } else if ((char)a0 == 127) {\n    return 1;\n  } else if ((char)a0 > 31) {\n    esc_collect((char)a0);\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\nlong long(between)(long long, long long, long long);\nlong long(esc_collect)(long long);\n\nlong long esc_state_osc_name_conflict(unsigned long a0) {\n  if ((char)a0 == 7) {\n    esc_clear();\n    return 1;\n  } else if (!(char)between((char)a0, 0, 31)) {\n    esc_collect((char)a0);\n    return 1;\n  } else {\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long esc_state_wait_for_ST_name_conflict(unsigned long a0) {\n  char v0; // [bp-0xc]\n\n  v0 = a0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint esc_seq;          // add global variable by heuristics\nint esc_seq;          // add global variable by heuristics\nint esc_state_escape; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\n\nextern struct_0 *esc_seq;\n\nlong long esc_handle_name_conflict(unsigned long a0) {\n  if ((char)a0 != 27 && (char)a0 != 26 && (char)a0 != 24) {\n    if (!esc_seq)\n      return 0;\n    return esc_seq((char)a0);\n  }\n  esc_clear();\n  if ((char)a0 == 27)\n    esc_seq = &esc_state_escape;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4lc7fhzo/esc_handle_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *esc_seq; |        ^~~~~~~~ |        struct\n/tmp/tmp4lc7fhzo/esc_handle_name_conflict.c:21:8: error: declaration of anonymous struct must\nbe a definition /tmp/tmp4lc7fhzo/esc_handle_name_conflict.c:29:23: error: called object type\n'int' is not a function or function pointer 29 |         return\nesc_seq((char)a0); |                ~~~~~~~^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"char *test_dcs() {\n    escbatch(\"\\033P123456789\\033\\\\\");\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(escbatch)(long long);\n\nextern unsigned long long g_40307d;\n\nlong long test_dcs_name_conflict() {\n  escbatch(&g_40307d);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_anywhere\");\n        char *message = test_anywhere();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi\");\n        char *message = test_csi();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_bad\");\n        char *message = test_csi_bad();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_many_params\");\n        char *message = test_csi_too_many_params();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_long_param\");\n        char *message = test_csi_too_long_param();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_C0\");\n        char *message = test_csi_C0();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_osc\");\n        char *message = test_osc();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_dcs\");\n        char *message = test_dcs();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_anywhere)();\nlong long(test_csi)();\nlong long(test_csi_bad)();\nlong long(test_csi_too_many_params)();\nlong long(test_csi_too_long_param)();\nlong long(test_csi_C0)();\nlong long(test_osc)();\nlong long(test_dcs)();\n\nextern char g_403f61;\nextern char g_403f77;\nextern char g_403f80;\nextern char g_403f8d;\nextern char g_403fa6;\nextern char g_403fbe;\nextern char g_403fca;\nextern char g_403fd3;\nextern unsigned int tests_run;\n\nlong long run_tests_name_conflict() {\n  unsigned long v0; // [bp-0x48]\n  unsigned long v1; // [bp-0x40]\n  unsigned long v2; // [bp-0x38]\n  unsigned long v3; // [bp-0x30]\n  unsigned long v4; // [bp-0x28]\n  unsigned long v5; // [bp-0x20]\n  unsigned long v6; // [bp-0x18]\n  unsigned long v7; // [bp-0x10]\n\n  printf(\"--> %s\\n\", &g_403f61);\n  v7 = test_anywhere();\n  tests_run = tests_run + 1;\n  if (v7)\n    return v7;\n  printf(\"--> %s\\n\", &g_403f77);\n  v6 = test_csi();\n  tests_run = tests_run + 1;\n  if (v6)\n    return v6;\n  printf(\"--> %s\\n\", &g_403f80);\n  v5 = test_csi_bad();\n  tests_run = tests_run + 1;\n  if (v5)\n    return v5;\n  printf(\"--> %s\\n\", &g_403f8d);\n  v4 = test_csi_too_many_params();\n  tests_run = tests_run + 1;\n  if (v4)\n    return v4;\n  printf(\"--> %s\\n\", &g_403fa6);\n  v3 = test_csi_too_long_param();\n  tests_run = tests_run + 1;\n  if (v3)\n    return v3;\n  printf(\"--> %s\\n\", &g_403fbe);\n  v2 = test_csi_C0();\n  tests_run = tests_run + 1;\n  if (v2)\n    return v2;\n  printf(\"--> %s\\n\", &g_403fca);\n  v1 = test_osc();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_403fd3);\n  v0 = test_dcs();\n  tests_run = tests_run + 1;\n  return (!v0 ? v0 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_utf8toucs2\");\n        char *message = test_utf8toucs2();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_helpers\");\n        char *message = test_helpers();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_utf8toucs2)();\nlong long(test_helpers)();\n\nextern char g_4024ad;\nextern char g_4024c5;\nextern unsigned int tests_run;\n\nlong long run_tests_name_conflict() {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  printf(\"--> %s\\n\", &g_4024ad);\n  v1 = test_utf8toucs2();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_4024c5);\n  v0 = test_helpers();\n  tests_run = tests_run + 1;\n  return (!v0 ? v0 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_util.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ASTEmpty_create_name_conflict() {\n  unsigned int v0[2]; // [bp-0x10]\n\n  *((void **)&v0[0]) = calloc(1, 8);\n  v0[0] = 0;\n  v0[1] = 3;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char field_8;\n} struct_0;\n\nlong long ASTLiteral_create_name_conflict(unsigned long a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = calloc(1, 12);\n  v0->field_0 = 1;\n  v0->field_4 = 3;\n  v0->field_8 = a0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ASTEmpty_create_name_conflict() {\n  unsigned int v0[2]; // [bp-0x10]\n\n  *((void **)&v0[0]) = calloc(1, 8);\n  v0[0] = 0;\n  v0[1] = 3;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char field_8;\n} struct_0;\n\nlong long ASTLiteral_create_name_conflict(unsigned long a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = calloc(1, 12);\n  v0->field_0 = 1;\n  v0->field_4 = 3;\n  v0->field_8 = a0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ASTEmpty_create)();\nlong long(yyparse_name_conflict)(long long);\nlong long(yyrelease)(long long);\n\nlong long parse_name_conflict(char *a0) {\n  char v0;               // [bp-0x88]\n  char *v1;              // [bp-0x28]\n  char v2;               // [bp-0x20]\n  unsigned long long v3; // [bp-0x10]\n\n  if (!*(a0))\n    return ASTEmpty_create();\n  memset(&v0, 0, 112);\n  v1 = a0;\n  do {\n  } while ((int)yyparse_name_conflict(&v0));\n  v3 = *((long long *)&v2);\n  yyrelease(&v0);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ASTEmpty_create_name_conflict() {\n  unsigned int v0[2]; // [bp-0x10]\n\n  *((void **)&v0[0]) = calloc(1, 8);\n  v0[0] = 0;\n  v0[1] = 3;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char field_8;\n} struct_0;\n\nlong long ASTLiteral_create_name_conflict(unsigned long a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = calloc(1, 12);\n  v0->field_0 = 1;\n  v0->field_4 = 3;\n  v0->field_8 = a0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ASTEmpty_create)();\nlong long(yyparse_name_conflict)(long long);\nlong long(yyrelease)(long long);\n\nlong long parse_name_conflict(char *a0) {\n  char v0;               // [bp-0x88]\n  char *v1;              // [bp-0x28]\n  char v2;               // [bp-0x20]\n  unsigned long long v3; // [bp-0x10]\n\n  if (!*(a0))\n    return ASTEmpty_create();\n  memset(&v0, 0, 112);\n  v1 = a0;\n  do {\n  } while ((int)yyparse_name_conflict(&v0));\n  v3 = *((long long *)&v2);\n  yyrelease(&v0);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long dump978_reader_new_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x18]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2[1134]; // [bp-0x10]\n\n  *((void **)&v2[0]) = calloc(1, 4536);\n  if (!v2)\n    return 0;\n  if ((unsigned int)a1) {\n    v1 = fcntl(a0, 3);\n    if (!(v1 >= 0) || !(fcntl(a0, 4) >= 0)) {\n      v0 = *(__errno_location());\n      free(v2);\n      *(__errno_location()) = v0;\n      return 0;\n    }\n  }\n  v2[0] = a0;\n  v2[1133] = 0;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp0yg3yon/dump978_reader_new_name_conflict.c:32:18: error: indirection requires pointer\noperand ('int' invalid) 32 |             v0 = *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpp0yg3yon/dump978_reader_new_name_conflict.c:34:13: error:\nindirection requires pointer operand ('int' invalid) 34 | *(__errno_location())\n= v0; |             ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":1,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hexbyte_name_conflict(char a0[2]) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0[0];\n  if (!(v0 <= 47 || v0 > 57)) {\n    v1 = v0 - 48;\n  } else if (v0 <= 96 || v0 > 102) {\n    if (!(v0 > 64) || !(v0 <= 70))\n      return 4294967295;\n    v1 = v0 - 55;\n  } else {\n    v1 = v0 - 87;\n  }\n  v1 *= 16;\n  v0 = a0[1];\n  if (v0 > 47 && v0 <= 57)\n    return v0 - 48 | v1;\n  if (v0 > 96 && v0 <= 102)\n    return v0 - 87 | v1;\n  if (v0 > 64 && v0 <= 70)\n    return v0 - 55 | v1;\n  return 4294967295;\n}\n","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4225064];\n  unsigned int field_407828;\n} struct_0;\n\nextern char g_407828;\n\nlong long get_fisb_product_format_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 2005)\n    return \"Developmental\";\n  if ((unsigned int)a0 > 2005) {\n  LABEL_404fa7:\n    return \"unknown\";\n  } else if ((unsigned int)a0 == 2004) {\n    return \"Proprietary\";\n  } else if ((unsigned int)a0 > 2004) {\n  LABEL_404fa7:\n    return \"unknown\";\n  } else if ((unsigned int)a0 > 2003) {\n  LABEL_404fa7:\n    return \"unknown\";\n  } else if ((unsigned int)a0 < 2000) {\n    if ((unsigned int)a0 == 600)\n      return \"Proprietary\";\n    if ((unsigned int)a0 > 600) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 > 413) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 >= 351) {\n      switch ((unsigned int)a0) {\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n      LABEL_404f68:\n        return \"Text\";\n      case 401:\n      case 403:\n      case 404:\n      LABEL_404f83:\n        return \"Graphic\";\n      case 411:\n      case 413:\n      LABEL_404f7a:\n        return \"Text (DLAC)\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      default:\n      LABEL_404fa7:\n        return \"unknown\";\n      }\n    }\n    if ((unsigned int)a0 == 254)\n      goto LABEL_404f83;\n    if ((unsigned int)a0 > 254) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 > 202) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 201 && (unsigned int)a0 != 151))\n      goto LABEL_404f83;\n    if ((unsigned int)a0 > 151) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 > 102) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 101))\n      goto LABEL_404f83;\n    if ((unsigned int)a0 > 83) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 81))\n      goto LABEL_404f83;\n    if ((unsigned int)a0 > 64) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 51))\n      goto LABEL_404f83;\n    if ((unsigned int)a0 > 27) {\n    LABEL_404fa7:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 20))\n      goto LABEL_404f7a;\n    if ((unsigned int)a0 > 7) {\n      if ((unsigned int)a0 - 8 > 5) {\n      LABEL_404fa7:\n        return \"unknown\";\n      }\n      return \"Text/Graphic\";\n    }\n    if ((unsigned int)a0 < 0)\n      goto LABEL_404fa7;\n    else\n      goto LABEL_404f68;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:39:1: error: redefinition of label\n'LABEL_404fa7' 39 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:44:1:\nerror: redefinition of label 'LABEL_404fa7' 44 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:53:1:\nerror: redefinition of label 'LABEL_404fa7' 53 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:58:1:\nerror: redefinition of label 'LABEL_404fa7' 58 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:77:1:\nerror: redefinition of label 'LABEL_404fa7' 77 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:85:1:\nerror: redefinition of label 'LABEL_404fa7' 85 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:90:1:\nerror: redefinition of label 'LABEL_404fa7' 90 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:97:1:\nerror: redefinition of label 'LABEL_404fa7' 97 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:102:1:\nerror: redefinition of label 'LABEL_404fa7' 102 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:109:1:\nerror: redefinition of label 'LABEL_404fa7' 109 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:116:1:\nerror: redefinition of label 'LABEL_404fa7' 116 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:123:1:\nerror: redefinition of label 'LABEL_404fa7' 123 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ /tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:132:1:\nerror: redefinition of label 'LABEL_404fa7' 132 | LABEL_404fa7: | ^\n/tmp/tmp479kmnkn/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_404fa7: | ^ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":1,"function":"static int encode_altitude(int ft) {\n    int i;\n    i = (ft + 1000) / 25;\n    if (i < 0)\n        i = 0;\n    if (i > 2047)\n        i = 2047;\n    return (i & 15) | 16 | ((i & 2032) << 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long encode_altitude_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = (unsigned int)(((unsigned int)a0 + 1000) * 1374389535 >> 35) -\n       ((unsigned int)a0 + 1000 >> 31);\n  if (v0 < 0)\n    v0 = 0;\n  if (v0 > 2047)\n    v0 = 2047;\n  return v0 * 2 & 4064 | v0 & 15 | 16;\n}\n","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static int encode_ground_speed(int kt) {\n    if (kt > 175)\n        return 124;\n    if (kt > 100)\n        return (kt - 100) / 5 + 108;\n    if (kt > 70)\n        return (kt - 70) / 2 + 93;\n    if (kt > 15)\n        return (kt - 15) + 38;\n    if (kt > 2)\n        return (kt - 2) * 2 + 11;\n    if (kt == 2)\n        return 12;\n    if (kt == 1)\n        return 8;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long encode_ground_speed_name_conflict(unsigned long a0) {\n  return (\n      (unsigned int)a0 <= 175\n          ? 124\n          : ((unsigned int)a0 <= 100\n                 ? ((unsigned int)a0 - 100) / 5 + 108\n                 : ((unsigned int)a0 <= 70\n                        ? (unsigned int)((unsigned int)a0 - 70 +\n                                             ((unsigned int)a0 - 70 >> 31) >>\n                                         1) +\n                              93\n                        : ((unsigned int)a0 <= 15\n                               ? (unsigned int)a0 + 23\n                               : ((unsigned int)a0 <= 2\n                                      ? ((unsigned int)a0 - 2) * 2 + 11\n                                      : ((unsigned int)a0 == 2\n                                             ? ((unsigned int)a0 == 1 ? 1 : 8)\n                                             : 12))))));\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static int encode_air_speed(int kt, int supersonic) {\n    int sign;\n    if (kt < 0) {\n        sign = 1024;\n        kt = -kt;\n    } else {\n        sign = 0;\n    }\n    if (supersonic)\n        kt = kt / 4;\n    ++kt;\n    if (kt > 1023)\n        kt = 1023;\n    return kt | sign;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long encode_air_speed_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x1c], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n  unsigned int v3; // eax\n\n  v0 = a0;\n  if (v0 >= 0) {\n    v1 = 0;\n  } else {\n    v1 = 0x400;\n    v0 = -(v0);\n  }\n  if ((unsigned int)a1) {\n    v3 = v0;\n    v0 = (v3 < 0 ? v3 + 3 : v3) >> 2;\n  }\n  v0 = (int)v0 + 1;\n  if (v0 > 1023)\n    v0 = 1023;\n  return v0 | v1;\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static int encode_vert_rate(int rate) {\n    int sign;\n    if (rate < 0) {\n        sign = 512;\n        rate = -rate;\n    } else {\n        sign = 0;\n    }\n    rate = (rate / 64) + 1;\n    if (rate > 511)\n        rate = 511;\n    return rate | sign;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long encode_vert_rate_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n  unsigned int v3; // eax\n\n  v0 = a0;\n  if (v0 >= 0) {\n    v1 = 0;\n  } else {\n    v1 = 0x200;\n    v0 = -(v0);\n  }\n  v3 = v0;\n  v0 = (unsigned int)((v3 < 0 ? v3 + 63 : v3) >> 6) + 1;\n  if (v0 > 511)\n    v0 = 511;\n  return v0 | v1;\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint8_t char_to_ais(int ch) {\n    char *match;\n    if (!ch)\n        return 32;\n    match = strchr(ais_charset, ch);\n    if (match)\n        return (uint8_t)(match - ais_charset);\n    else\n        return 32;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char *ais_charset;\n\nlong long char_to_ais_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10]\n\n  if (!(unsigned int)a0)\n    return 32;\n  v0 = strchr(ais_charset, a0);\n  return (!v0 ? v0 - ais_charset : 32);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg6bkj8n3/char_to_ais_name_conflict.c:26:22: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 26 |     return (!v0 ? v0 -\nais_charset : 32); |                   ~~ ^ ~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static unsigned int encodeSquawk(char *squawkStr) {\n    unsigned int squawk = strtoul(squawkStr, ((void *)0), 16);\n    unsigned int encoded = 0;\n    if (squawk & 4096)\n        encoded |= 2048;\n    if (squawk & 8192)\n        encoded |= 512;\n    if (squawk & 16384)\n        encoded |= 128;\n    if (squawk & 256)\n        encoded |= 32;\n    if (squawk & 512)\n        encoded |= 8;\n    if (squawk & 1024)\n        encoded |= 2;\n    if (squawk & 16)\n        encoded |= 4096;\n    if (squawk & 32)\n        encoded |= 1024;\n    if (squawk & 64)\n        encoded |= 256;\n    if (squawk & 1)\n        encoded |= 16;\n    if (squawk & 2)\n        encoded |= 4;\n    if (squawk & 4)\n        encoded |= 1;\n    return encoded;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtoul)(char *, char *, char *);\n\nlong long encodeSquawk_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = (unsigned int)strtoul(a0, NULL, 0x10);\n  v1 = 0;\n  if (((unsigned short)v0 & 0x1000))\n    v1 |= 0x800;\n  if (((unsigned short)v0 & 0x2000))\n    v1 |= 0x200;\n  if (((unsigned short)v0 & 0x4000))\n    v1 |= 128;\n  if (((unsigned short)v0 & 0x100))\n    v1 |= 32;\n  if (((unsigned short)v0 & 0x200))\n    v1 |= 8;\n  if (((unsigned short)v0 & 0x400))\n    v1 |= 2;\n  if (((char)v0 & 16))\n    v1 |= 0x1000;\n  if (((char)v0 & 32))\n    v1 |= 0x400;\n  if (((char)v0 & 64))\n    v1 |= 0x100;\n  if (((char)v0 & 1))\n    v1 |= 16;\n  if (((char)v0 & 2))\n    v1 |= 4;\n  if (((char)v0 & 4))\n    v1 |= 1;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint32_t checksum(uint8_t *message, int n) {\n    uint32_t rem = 0;\n    int i;\n    for (i = 0; i < n; ++i) {\n        rem = (rem << 8) ^ crc_table[message[i] ^ ((rem & 16711680) >> 16)];\n        rem = rem & 16777215;\n    }\n    return rem;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char crc_table;\n\nlong long checksum_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    v1 = *((int *)&(&crc_table)[4 * ((unsigned int)(v1 >> 16) ^ a0[v0])]) ^\n         v1 * 0x100;\n    v1 &= 16777215;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long dump978_reader_new_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x18]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2[1134]; // [bp-0x10]\n\n  *((void **)&v2[0]) = calloc(1, 4536);\n  if (!v2)\n    return 0;\n  if ((unsigned int)a1) {\n    v1 = fcntl(a0, 3);\n    if (!(v1 >= 0) || !(fcntl(a0, 4) >= 0)) {\n      v0 = *(__errno_location());\n      free(v2);\n      *(__errno_location()) = v0;\n      return 0;\n    }\n  }\n  v2[0] = a0;\n  v2[1133] = 0;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv845qapi/dump978_reader_new_name_conflict.c:32:18: error: indirection requires pointer\noperand ('int' invalid) 32 |             v0 = *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpv845qapi/dump978_reader_new_name_conflict.c:34:13: error:\nindirection requires pointer operand ('int' invalid) 34 | *(__errno_location())\n= v0; |             ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":1,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hexbyte_name_conflict(char a0[2]) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0[0];\n  if (!(v0 <= 47 || v0 > 57)) {\n    v1 = v0 - 48;\n  } else if (v0 <= 96 || v0 > 102) {\n    if (!(v0 > 64) || !(v0 <= 70))\n      return 4294967295;\n    v1 = v0 - 55;\n  } else {\n    v1 = v0 - 87;\n  }\n  v1 *= 16;\n  v0 = a0[1];\n  if (v0 > 47 && v0 <= 57)\n    return v0 - 48 | v1;\n  if (v0 > 96 && v0 <= 102)\n    return v0 - 87 | v1;\n  if (v0 > 64 && v0 <= 70)\n    return v0 - 55 | v1;\n  return 4294967295;\n}\n","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4233848];\n  unsigned int field_409a78;\n} struct_0;\n\nextern char g_409a78;\n\nlong long get_fisb_product_format_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 2005)\n    return \"Developmental\";\n  if ((unsigned int)a0 > 2005) {\n  LABEL_407143:\n    return \"unknown\";\n  } else if ((unsigned int)a0 == 2004) {\n    return \"Proprietary\";\n  } else if ((unsigned int)a0 > 2004) {\n  LABEL_407143:\n    return \"unknown\";\n  } else if ((unsigned int)a0 > 2003) {\n  LABEL_407143:\n    return \"unknown\";\n  } else if ((unsigned int)a0 < 2000) {\n    if ((unsigned int)a0 == 600)\n      return \"Proprietary\";\n    if ((unsigned int)a0 > 600) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 > 413) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 >= 351) {\n      switch ((unsigned int)a0) {\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n      LABEL_407104:\n        return \"Text\";\n      case 401:\n      case 403:\n      case 404:\n      LABEL_40711f:\n        return \"Graphic\";\n      case 411:\n      case 413:\n      LABEL_407116:\n        return \"Text (DLAC)\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      default:\n      LABEL_407143:\n        return \"unknown\";\n      }\n    }\n    if ((unsigned int)a0 == 254)\n      goto LABEL_40711f;\n    if ((unsigned int)a0 > 254) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 > 202) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 201 && (unsigned int)a0 != 151))\n      goto LABEL_40711f;\n    if ((unsigned int)a0 > 151) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if ((unsigned int)a0 > 102) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 101))\n      goto LABEL_40711f;\n    if ((unsigned int)a0 > 83) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 81))\n      goto LABEL_40711f;\n    if ((unsigned int)a0 > 64) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 51))\n      goto LABEL_40711f;\n    if ((unsigned int)a0 > 27) {\n    LABEL_407143:\n      return \"unknown\";\n    }\n    if (!((unsigned int)a0 < 20))\n      goto LABEL_407116;\n    if ((unsigned int)a0 > 7) {\n      if ((unsigned int)a0 - 8 > 5) {\n      LABEL_407143:\n        return \"unknown\";\n      }\n      return \"Text/Graphic\";\n    }\n    if ((unsigned int)a0 < 0)\n      goto LABEL_407143;\n    else\n      goto LABEL_407104;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:39:1: error: redefinition of label\n'LABEL_407143' 39 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:44:1:\nerror: redefinition of label 'LABEL_407143' 44 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:53:1:\nerror: redefinition of label 'LABEL_407143' 53 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:58:1:\nerror: redefinition of label 'LABEL_407143' 58 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:77:1:\nerror: redefinition of label 'LABEL_407143' 77 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:85:1:\nerror: redefinition of label 'LABEL_407143' 85 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:90:1:\nerror: redefinition of label 'LABEL_407143' 90 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:97:1:\nerror: redefinition of label 'LABEL_407143' 97 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:102:1:\nerror: redefinition of label 'LABEL_407143' 102 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:109:1:\nerror: redefinition of label 'LABEL_407143' 109 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:116:1:\nerror: redefinition of label 'LABEL_407143' 116 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:123:1:\nerror: redefinition of label 'LABEL_407143' 123 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ /tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:132:1:\nerror: redefinition of label 'LABEL_407143' 132 | LABEL_407143: | ^\n/tmp/tmps1nza4yq/get_fisb_product_format_name_conflict.c:30:1: note: previous definition is\nhere 30 | LABEL_407143: | ^ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x18], Other Possible Types: unsigned long long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 1;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = *((char *)(v1 + a0)) + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 0x1dcd6500 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsjofqd7q/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |             ^\n/tmp/tmpsjofqd7q/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |          ^\n/tmp/tmpsjofqd7q/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |                          ^\n      |                          ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) == -1) {\n      return 4294967295;\n    } else if (strcmp(a0, *((long long *)(vocab +\n                                          (*((int *)(vocab_hash + (v0 << 2)))\n                                           << 4) +\n                                          8)))) {\n      v0 = (0 CONCAT v0 + 1) / m 0x1dcd6500 >> 32;\n    } else {\n      return *((int *)(vocab_hash + v0 * 4));\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcj8ms431/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                     ^\n/tmp/tmpcj8ms431/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                  ^\n/tmp/tmpcj8ms431/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 60)\n    v0 = 60;\n  *((void **)(8 + (char *)vocab + 16 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(8 + (char *)vocab + 16 * vocab_size)), a0);\n  *((long long *)((char *)vocab + 16 * vocab_size)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 0x1dcd6500 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwukgwvje/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpwukgwvje/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpwukgwvje/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpwukgwvje/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = *((char *)(v1 + a0)) + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 30000000 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_j2zfbt1/GetWordHash_name_conflict.c:29:41: error: invalid operands to binary\nexpression ('int' and 'void *') 29 |         v0 = *((char *)(v1 + a0)) + 257 *\nv0; |                                     ~~~ ^ ~~\n/tmp/tmp_j2zfbt1/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |             ^\n/tmp/tmp_j2zfbt1/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |          ^\n/tmp/tmp_j2zfbt1/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |                          ^\n      |                          ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) != -1) {\n      v2 = *((int *)(vocab_hash + v0 * 4));\n      if (!strcmp(a0, *((long long *)(((v2 << 2) + v2 << 3) + vocab + 16))))\n        return *((int *)(vocab_hash + v0 * 4));\n      v0 = (0 CONCAT v0 + 1) / m 30000000 >> 32;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgv9h76to/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                     ^\n/tmp/tmpgv9h76to/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                  ^\n/tmp/tmpgv9h76to/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 100)\n    v0 = 100;\n  *((void **)(16 + (char *)vocab + 40 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(16 + 40 * vocab_size + (char *)vocab)), a0);\n  *((long long *)(40 * vocab_size + (char *)vocab)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 30000000 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpahlu0wnl/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpahlu0wnl/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpahlu0wnl/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpahlu0wnl/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int setup() {\n    int i;\n    FILE *test_input = fopen(\"test_input.log\", \"w\");\n    if (!test_input)\n        return 1;\n    for (i = 1; i <= 10; i++)\n        fprintf(test_input, \"this is line %d\\n\", i);\n    fclose(test_input);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long setup_name_conflict() {\n  FILE_t *v0;      // [bp-0x18]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = &fopen(\"test_input.log\", \"w\")->_flags;\n  if (!v0)\n    return 1;\n  for (v1 = 1; v1 <= 10; v1 += 1) {\n    fprintf(v0, \"this is line %d\\n\", v1);\n  }\n  fclose(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptlg_5vkx/setup_name_conflict.c:85:3: error: typedef redefinition with different types\n('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 85 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/test/dbfr_test.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fields_in_line_name_conflict(unsigned long a0, char *a1) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18], Other Possible Types: unsigned long long\n  char *v2;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = a0;\n  v1 = 1;\n  if (a0 && a1) {\n    v0 = strlen(a1);\n    while (true) {\n      v2 = strstr(v2, a1);\n      if (!v2)\n        break;\n      v1 += 1;\n      v2 += v0;\n    }\n    return v1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_field(unsigned long a0, char *a1, char *a2, unsigned long a3,\n                         char *a4) {\n  char *v0;              // [bp-0x40]\n  unsigned int v1;       // [bp-0x1c]\n  char *v2;              // [bp-0x18]\n  char *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long v6; // rdx\n  unsigned long v7;      // rax, Other Possible Types: unsigned int\n\n  v0 = a2;\n  if (a4 && *(a4)) {\n    v2 = field_start(a1, (unsigned int)a3 + 1, a4);\n    if (!v2) {\n      *((char *)a0) = 0;\n      return 4294967295;\n    }\n    v3 = strstr(v2, a4);\n    if (!v3) {\n      for (v3 = &a1[1 + strlen(a1)]; *(v3) == 10 || *(v3) == 13; v3 += 1)\n        ;\n      v3 += 1;\n    }\n    v6 = v3 - v2;\n    v7 = v0 + 1;\n    if (v6 <= v7)\n      v7 = v6;\n    v1 = v7;\n    strncpy(a0, v2, v1);\n    *((char *)(a0 + v1)) = 0;\n    return v1;\n  }\n  strncpy(a0, a1, v0);\n  v0[a0] = 0;\n  return strlen(a0);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long copy_field(unsigned long long a0, char **a1, unsigned long long *a2,\n                     unsigned long a3, char *a4) {\n  unsigned int v0; // [bp-0x1c]\n  char *v1;        // [bp-0x18]\n  struct_0 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = field_start(a0, a3 + 1, a4);\n  if (!v1)\n    return 4294967295;\n  v2 = strstr(v1, a4);\n  if (!v2) {\n    for (v2 = &v1[strlen(v1)];\n         *((char *)(v2 - 1)) == 10 || *((char *)(v2 - 1)) == 13; v2 -= 1)\n      ;\n  }\n  v0 = (unsigned int)(v2 - v1);\n  if (!*(a1) || !a2) {\n    *(a1) = xmalloc(v0 + 1);\n    *(a2) = v0 + 1;\n  } else if (*(a2) < v0 + 1) {\n    *(a1) = xrealloc(*(a1), v0 + 1);\n    *(a2) = v0 + 1;\n  }\n  (*(a1))[v0] = 0;\n  strncpy(*(a1), v1, v0);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptjm34q5i/copy_field.c:21:16: error: expected ';' at end of declaration\nlist 21 |     char field_-1; |                ^ |                ;\n/tmp/tmptjm34q5i/copy_field.c:38:28: error: 'struct_0 *' (aka 'struct struct_0\n*') and 'char *' are not pointers to compatible types 38 |     v0 = (unsigned\nint)(v2 - v1); |                         ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long field_start_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  unsigned long v0; // [bp-0x20]\n  char *v1;         // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v2;  // [bp-0xc]\n\n  v1 = a0;\n  v0 = strlen(a2);\n  v2 = 1;\n  while (true) {\n    if (v2 < a1) {\n      v1 = strstr(v1, a2);\n      if (!v1)\n        return 0;\n      v1 += v0;\n      v2 += 1;\n    } else {\n      return v1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mdyhms_datecmp_name_conflict(char a0[10], char a1[10]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0[6] == a1[6] && a0[7] == a1[7] && a0[8] == a1[8] && a0[9] == a1[9]) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  (unsigned int)v1 = strncmp(&a0[6], &a1[6], 4);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1jywtuh2/mdyhms_datecmp_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp1jywtuh2/mdyhms_datecmp_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v1 = strncmp(&a0[6],\n&a1[6], 4); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long dmyhms_datecmp_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = strncmp(a0 + 6, a1 + 6, 4);\n  if (v0)\n    return v0;\n  v0 = strncmp(a0 + 3, a1 + 3, 2);\n  if (!v0)\n    return strcmp(a0, a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strtok)(char *, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\nlong long(arr_resize)(long long, long long, long long, long long);\n\nlong long expand_nums(char *a0, unsigned long long *a1,\n                      unsigned long long *a2) {\n  char v0;               // [bp-0x24]\n  char v1;               // [bp-0x20]\n  unsigned int v2;       // [bp-0x1c]\n  char *v3;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned int v10;      // eax\n  unsigned int *v11;     // rax\n\n  v7 = &v5;\n  if (!(a0 && *(a0)))\n    return 0;\n  for (v4 = 0; a0[v4]; v4 += 1) {\n    v10 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v4] * 2)) & 0x800;\n    if (!v10 && a0[v4] != 44 && a0[v4] != 45)\n      return -2;\n  }\n  v4 = 0;\n  if (!*(a1) && !*(a2)) {\n    *(a1) = xmalloc(64);\n    *(a2) = 16;\n  }\n  if (!strchr(a0, 44) && !strchr(a0, 45)) {\n    __isoc99_sscanf(a0, \"%u\", (unsigned int)*(a1));\n    return 1;\n  }\n  v3 = strtok(a0, \",\");\n  while (true) {\n    if (v3) {\n      if (v4 >= *(a2)) {\n        *(a2) = arr_resize(a1, 4, *(a2), 16);\n        if (!*(a2))\n          return -1;\n      }\n      if (!strchr(v3, 45)) {\n        __isoc99_sscanf(v3, \"%u\", (unsigned int)(v4 * 4 + *(a1)));\n        v4 += 1;\n      } else {\n        __isoc99_sscanf(v3, \"%u-%u\", (unsigned int)&v1, (unsigned int)&v0);\n        if (*(a2) < v4 + *((int *)&v0) - *((int *)&v1)) {\n          *(a2) = arr_resize(a1, 4, *(a2), *((int *)&v0) - *((int *)&v1));\n          if (!*(a2))\n            return -1;\n        }\n        for (v2 = *((int *)&v1); *((int *)&v0) >= v2; v2 += 1) {\n          v11 = v4;\n          v4 = (unsigned int)v11 + 1;\n          *((unsigned int *)(*(a1) + v11 * 4)) = v2;\n        }\n      }\n      v3 = strtok(NULL, \",\");\n    } else {\n      return v4;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpap30fuu4/expand_nums.c:38:42: error: cannot take the address of an\nrvalue of type 'int' 38 |         v10 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v4] * 2)) & 0x800; | ^~~~~~~~~~~~~~~~\n/tmp/tmpap30fuu4/expand_nums.c:82:52: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 82 |                     *((unsigned int\n*)(*(a1) + v11 * 4)) = v2; |                                                ~~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(arr_resize)(long long, long long, long long, long long);\nlong long(field_str)(long long, long long, long long);\n\nlong long expand_label_list(char *a0, unsigned long long a1,\n                            unsigned long long a2, unsigned long long *a3,\n                            unsigned long long *a4) {\n  unsigned long v0;  // [bp-0x40]\n  char *v1;          // [bp-0x38]\n  unsigned long v2;  // [bp-0x30]\n  unsigned int v3;   // [bp-0x24]\n  char *v4;          // [bp-0x20], Other Possible Types: unsigned long\n  void *v5;          // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v6;   // [bp-0x10]\n  unsigned int v7;   // [bp-0xc]\n  unsigned long v9;  // rax\n  unsigned int *v11; // rax\n\n  v7 = 0;\n  v6 = 0;\n  v2 = strlen(a0);\n  v1 = xmalloc(v2 + 1);\n  for (v5 = 0; v7 < v2 + 1; v6 += 1) {\n    if (!(!(!a0[v7]) && !(a0[v7] == 10) && !(a0[v7] == 13))) {\n      v1[v6] = 0;\n      v5 += 1;\n      break;\n    } else if (a0[v7] == 92) {\n      if (a0[1 + v7] == 92) {\n        v1[v6] = 92;\n      } else {\n        if (a0[1 + v7] != 44) {\n          v9 = v6;\n          v6 = (unsigned int)v9 + 1;\n          v1[v9] = a0[v7];\n          v1[v6] = a0[1 + v7];\n        } else {\n          v1[v6] = 44;\n        }\n      }\n      v7 += 2;\n    } else if (a0[v7] != 44) {\n      v1[v6] = a0[v7];\n      v7 += 1;\n    } else {\n      v1[v6] = 0;\n      v5 += 1;\n      v7 += 1;\n    }\n  }\n  v0 = &v1[v6];\n  if (!*(a3)) {\n    *(a3) = xmalloc(v5 * 4);\n    *(a4) = v5;\n  } else if (*(a4) < v5) {\n    *(a4) = arr_resize(a3, 4, *(a4), v5 - *(a4));\n    if (!*(a4))\n      return -2;\n  }\n  v3 = 0;\n  v6 = 0;\n  for (v4 = v1; v4 != v0 + 1; v4 = &v4[1 + strlen(v4)]) {\n    v7 = field_str(v4, a1, a2);\n    if (v7 < 0) {\n      warnx(\"Failed to find field label: %s\");\n      v3 += 1;\n    }\n    v11 = v6;\n    v6 = (unsigned int)v11 + 1;\n    *((unsigned int *)(v11 * 4 + *(a3))) = v7 + 1;\n  }\n  if (v3)\n    return -1;\n  free(v1);\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpowdq8ofg/expand_label_list.c:82:28: error: invalid operands to binary\nexpression ('void *' and 'int') 82 |         *(a3) = xmalloc(v5 * 4); | ~~ ^ ~\n/tmp/tmpowdq8ofg/expand_label_list.c:103:32: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 103 |         *((unsigned int *)(v11 * 4\n+ *(a3))) = v7 + 1; |                            ~~~ ^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_pos(char *a0, unsigned long a1, char *a2, unsigned int *a3,\n                       unsigned int *a4) {\n  unsigned int *v0; // [bp-0x40]\n  unsigned long v1; // [bp-0x18]\n  char *v2;         // [bp-0x10]\n\n  v0 = a4;\n  v2 = field_start(a0, (unsigned int)a1 + 1, a2);\n  if (!v2) {\n    *(a3) = -1;\n    *(a4) = -1;\n    return 4294967295;\n  }\n  *(a3) = v2 - a0;\n  v1 = strstr(v2, a2);\n  if (!v1) {\n    for (*(a4) = (unsigned int)strlen(a0) - 1;\n         a0[*(a4)] == 10 || a0[*(a4)] == 13; *(a4) = *(a4)-1)\n      ;\n    if (*(a4) < *(a3))\n      *(a4) = *(a3);\n  } else if (v1 == v2) {\n    *(a4) = (unsigned int)(v1 - a0);\n  } else {\n    *(a4) = (unsigned int)(v1 - a0) - 1;\n  }\n  if (*(a3) != *(a4))\n    return *(a4) - *(a3) + 1;\n  if (!(a0[*(a3)] && a0[*(a3)] != 10 && a0[*(a3)] != 13 &&\n        strncmp(&a0[*(a3)], a2, strlen(a2))))\n    return 0;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp64n6aklf/get_line_pos.c:42:35: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 42 |         *(a4) = (unsigned int)(v1\n- a0); |                                ~~ ^ ~~\n/tmp/tmp64n6aklf/get_line_pos.c:46:35: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 46 |         *(a4) = (unsigned int)(v1\n- a0) - 1; |                                ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(get_line_field)(long long, long long, long long, long long,\n                          long long);\n\nlong long field_str_name_conflict(char *a0, char *a1, char *a2) {\n  unsigned int v0;       // [bp-0x24]\n  void *v1;              // [bp-0x20]\n  unsigned int v2;       // [bp-0x14]\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned long v8;      // rax\n\n  v7 = &v5;\n  if (!a0)\n    return -2;\n  if (!(a1 && *(a1)))\n    return -1;\n  if (a2 && *(a2)) {\n    v2 = (unsigned int)strlen(a0) + 3;\n    v1 = xmalloc(v2 + 1);\n    v4 = 0;\n    v0 = 0;\n    v3 = 0;\n    while (true) {\n      v0 = get_line_field(v1, a1, v2, v4, a2);\n      if (v0 < 0)\n        break;\n      if (strcmp(v1, a0)) {\n        v4 += 1;\n      } else {\n        v3 = 1;\n        break;\n      }\n    }\n    free(v1);\n    v8 = (!v3 ? v4 : -1);\n    return v8;\n  }\n  v8 = (!strcmp(a0, a1) ? -1 : 0);\n  return v8;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fields_in_line_name_conflict(unsigned long a0, char *a1) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18], Other Possible Types: unsigned long long\n  char *v2;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = a0;\n  v1 = 1;\n  if (a0 && a1) {\n    v0 = strlen(a1);\n    while (true) {\n      v2 = strstr(v2, a1);\n      if (!v2)\n        break;\n      v1 += 1;\n      v2 += v0;\n    }\n    return v1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_field(unsigned long a0, char *a1, char *a2, unsigned long a3,\n                         char *a4) {\n  char *v0;              // [bp-0x40]\n  unsigned int v1;       // [bp-0x1c]\n  char *v2;              // [bp-0x18]\n  char *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long v6; // rdx\n  unsigned long v7;      // rax, Other Possible Types: unsigned int\n\n  v0 = a2;\n  if (a4 && *(a4)) {\n    v2 = field_start(a1, (unsigned int)a3 + 1, a4);\n    if (!v2) {\n      *((char *)a0) = 0;\n      return 4294967295;\n    }\n    v3 = strstr(v2, a4);\n    if (!v3) {\n      for (v3 = &a1[1 + strlen(a1)]; *(v3) == 10 || *(v3) == 13; v3 += 1)\n        ;\n      v3 += 1;\n    }\n    v6 = v3 - v2;\n    v7 = v0 + 1;\n    if (v6 <= v7)\n      v7 = v6;\n    v1 = v7;\n    strncpy(a0, v2, v1);\n    *((char *)(a0 + v1)) = 0;\n    return v1;\n  }\n  strncpy(a0, a1, v0);\n  v0[a0] = 0;\n  return strlen(a0);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long copy_field(unsigned long long a0, char **a1, unsigned long long *a2,\n                     unsigned long a3, char *a4) {\n  unsigned int v0; // [bp-0x1c]\n  char *v1;        // [bp-0x18]\n  struct_0 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = field_start(a0, a3 + 1, a4);\n  if (!v1)\n    return 4294967295;\n  v2 = strstr(v1, a4);\n  if (!v2) {\n    for (v2 = &v1[strlen(v1)];\n         *((char *)(v2 - 1)) == 10 || *((char *)(v2 - 1)) == 13; v2 -= 1)\n      ;\n  }\n  v0 = (unsigned int)(v2 - v1);\n  if (!*(a1) || !a2) {\n    *(a1) = xmalloc(v0 + 1);\n    *(a2) = v0 + 1;\n  } else if (*(a2) < v0 + 1) {\n    *(a1) = xrealloc(*(a1), v0 + 1);\n    *(a2) = v0 + 1;\n  }\n  (*(a1))[v0] = 0;\n  strncpy(*(a1), v1, v0);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpui7qhls6/copy_field.c:21:16: error: expected ';' at end of declaration\nlist 21 |     char field_-1; |                ^ |                ;\n/tmp/tmpui7qhls6/copy_field.c:38:28: error: 'struct_0 *' (aka 'struct struct_0\n*') and 'char *' are not pointers to compatible types 38 |     v0 = (unsigned\nint)(v2 - v1); |                         ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long field_start_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  unsigned long v0; // [bp-0x20]\n  char *v1;         // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v2;  // [bp-0xc]\n\n  v1 = a0;\n  v0 = strlen(a2);\n  for (v2 = 1; v2 < a1; v2 += 1) {\n    v1 = strstr(v1, a2);\n    if (!v1)\n      return 0;\n    v1 += v0;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mdyhms_datecmp_name_conflict(char a0[10], char a1[10]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0[6] == a1[6] && a0[7] == a1[7] && a0[8] == a1[8] && a0[9] == a1[9]) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  (unsigned int)v1 = strncmp(&a0[6], &a1[6], 4);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvu0kw3w0/mdyhms_datecmp_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpvu0kw3w0/mdyhms_datecmp_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v1 = strncmp(&a0[6],\n&a1[6], 4); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long dmyhms_datecmp_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = strncmp(a0 + 6, a1 + 6, 4);\n  if (v0)\n    return v0;\n  v0 = strncmp(a0 + 3, a1 + 3, 2);\n  if (!v0)\n    return strcmp(a0, a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strtok)(char *, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\nlong long(arr_resize)(long long, long long, long long, long long);\n\nlong long expand_nums(char *a0, unsigned long long *a1,\n                      unsigned long long *a2) {\n  char v0;               // [bp-0x24]\n  char v1;               // [bp-0x20]\n  unsigned int v2;       // [bp-0x1c]\n  char *v3;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned int v10;      // eax\n  unsigned int *v11;     // rax\n\n  v7 = &v5;\n  if (!(a0 && *(a0)))\n    return 0;\n  for (v4 = 0; a0[v4]; v4 += 1) {\n    v10 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v4] * 2)) & 0x800;\n    if (!v10 && a0[v4] != 44 && a0[v4] != 45)\n      return -2;\n  }\n  v4 = 0;\n  if (!*(a1) && !*(a2)) {\n    *(a1) = xmalloc(64);\n    *(a2) = 16;\n  }\n  if (!strchr(a0, 44) && !strchr(a0, 45)) {\n    __isoc99_sscanf(a0, \"%u\", (unsigned int)*(a1));\n    return 1;\n  }\n  v3 = strtok(a0, \",\");\n  while (true) {\n    if (v3) {\n      if (v4 >= *(a2)) {\n        *(a2) = arr_resize(a1, 4, *(a2), 16);\n        if (!*(a2))\n          return -1;\n      }\n      if (!strchr(v3, 45)) {\n        __isoc99_sscanf(v3, \"%u\", (unsigned int)(v4 * 4 + *(a1)));\n        v4 += 1;\n      } else {\n        __isoc99_sscanf(v3, \"%u-%u\", (unsigned int)&v1, (unsigned int)&v0);\n        if (*(a2) < v4 + *((int *)&v0) - *((int *)&v1)) {\n          *(a2) = arr_resize(a1, 4, *(a2), *((int *)&v0) - *((int *)&v1));\n          if (!*(a2))\n            return -1;\n        }\n        for (v2 = *((int *)&v1); *((int *)&v0) >= v2; v2 += 1) {\n          v11 = v4;\n          v4 = (unsigned int)v11 + 1;\n          *((unsigned int *)(*(a1) + v11 * 4)) = v2;\n        }\n      }\n      v3 = strtok(NULL, \",\");\n    } else {\n      return v4;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdlkvhvmw/expand_nums.c:38:42: error: cannot take the address of an\nrvalue of type 'int' 38 |         v10 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v4] * 2)) & 0x800; | ^~~~~~~~~~~~~~~~\n/tmp/tmpdlkvhvmw/expand_nums.c:82:52: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 82 |                     *((unsigned int\n*)(*(a1) + v11 * 4)) = v2; |                                                ~~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(arr_resize)(long long, long long, long long, long long);\nlong long(field_str)(long long, long long, long long);\n\nlong long expand_label_list(char *a0, unsigned long long a1,\n                            unsigned long long a2, unsigned long long *a3,\n                            unsigned long long *a4) {\n  unsigned long v0;  // [bp-0x40]\n  char *v1;          // [bp-0x38]\n  unsigned long v2;  // [bp-0x30]\n  unsigned int v3;   // [bp-0x24]\n  char *v4;          // [bp-0x20], Other Possible Types: unsigned long\n  void *v5;          // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v6;   // [bp-0x10]\n  unsigned int v7;   // [bp-0xc]\n  unsigned long v9;  // rax\n  unsigned int *v11; // rax\n\n  v7 = 0;\n  v6 = 0;\n  v2 = strlen(a0);\n  v1 = xmalloc(v2 + 1);\n  for (v5 = 0; v7 < v2 + 1; v6 += 1) {\n    if (!(!(!a0[v7]) && !(a0[v7] == 10) && !(a0[v7] == 13))) {\n      v1[v6] = 0;\n      v5 += 1;\n      break;\n    } else if (a0[v7] == 92) {\n      if (a0[1 + v7] == 92) {\n        v1[v6] = 92;\n      } else {\n        if (a0[1 + v7] == 44) {\n          v1[v6] = 44;\n        } else {\n          v9 = v6;\n          v6 = (unsigned int)v9 + 1;\n          v1[v9] = a0[v7];\n          v1[v6] = a0[1 + v7];\n        }\n      }\n      v7 += 2;\n    } else if (a0[v7] == 44) {\n      v1[v6] = 0;\n      v5 += 1;\n      v7 += 1;\n    } else {\n      v1[v6] = a0[v7];\n      v7 += 1;\n    }\n  }\n  v0 = &v1[v6];\n  if (!*(a3)) {\n    *(a3) = xmalloc(v5 * 4);\n    *(a4) = v5;\n  } else if (*(a4) < v5) {\n    *(a4) = arr_resize(a3, 4, *(a4), v5 - *(a4));\n    if (!*(a4))\n      return -2;\n  }\n  v3 = 0;\n  v6 = 0;\n  for (v4 = v1; v4 != v0 + 1; v4 = &v4[1 + strlen(v4)]) {\n    v7 = field_str(v4, a1, a2);\n    if (v7 < 0) {\n      warnx(\"Failed to find field label: %s\");\n      v3 += 1;\n    }\n    v11 = v6;\n    v6 = (unsigned int)v11 + 1;\n    *((unsigned int *)(v11 * 4 + *(a3))) = v7 + 1;\n  }\n  if (v3)\n    return -1;\n  free(v1);\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqfpegt8l/expand_label_list.c:82:28: error: invalid operands to binary\nexpression ('void *' and 'int') 82 |         *(a3) = xmalloc(v5 * 4); | ~~ ^ ~\n/tmp/tmpqfpegt8l/expand_label_list.c:103:32: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 103 |         *((unsigned int *)(v11 * 4\n+ *(a3))) = v7 + 1; |                            ~~~ ^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_pos(char *a0, unsigned long a1, char *a2, unsigned int *a3,\n                       unsigned int *a4) {\n  unsigned long v0; // [bp-0x18]\n  char *v1;         // [bp-0x10]\n\n  v1 = field_start(a0, (unsigned int)a1 + 1, a2);\n  if (!v1) {\n    *(a3) = -1;\n    *(a4) = -1;\n    return 4294967295;\n  }\n  *(a3) = v1 - a0;\n  v0 = strstr(v1, a2);\n  if (!v0) {\n    for (*(a4) = (unsigned int)strlen(a0) - 1;\n         a0[*(a4)] == 10 || a0[*(a4)] == 13; *(a4) = *(a4)-1)\n      ;\n    if (*(a4) < *(a3))\n      *(a4) = *(a3);\n  } else if (v0 == v1) {\n    *(a4) = (unsigned int)(v0 - a0);\n  } else {\n    *(a4) = (unsigned int)(v0 - a0) - 1;\n  }\n  if (*(a3) != *(a4))\n    return *(a4) - *(a3) + 1;\n  if (!(a0[*(a3)] && a0[*(a3)] != 10 && a0[*(a3)] != 13 &&\n        strncmp(&a0[*(a3)], a2, strlen(a2))))\n    return 0;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpot9o2jsx/get_line_pos.c:40:35: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 40 |         *(a4) = (unsigned int)(v0\n- a0); |                                ~~ ^ ~~\n/tmp/tmpot9o2jsx/get_line_pos.c:44:35: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 44 |         *(a4) = (unsigned int)(v0\n- a0) - 1; |                                ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(get_line_field)(long long, long long, long long, long long,\n                          long long);\n\nlong long field_str_name_conflict(char *a0, char *a1, char *a2) {\n  unsigned int v0;       // [bp-0x24]\n  char *v1;              // [bp-0x20]\n  unsigned int v2;       // [bp-0x14]\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned long v8;      // rax\n\n  v7 = &v5;\n  if (!a0)\n    return -2;\n  if (!(a1 && *(a1)))\n    return -1;\n  if (a2 && *(a2)) {\n    v2 = (unsigned int)strlen(a0) + 3;\n    v1 = xmalloc(v2 + 1);\n    v4 = 0;\n    v0 = 0;\n    v3 = 0;\n    while (true) {\n      v0 = get_line_field(v1, a1, v2, v4, a2);\n      if (v0 < 0)\n        break;\n      if (strcmp(v1, a0)) {\n        v4 += 1;\n      } else {\n        v3 = 1;\n        break;\n      }\n    }\n    free(v1);\n    v8 = (!v3 ? v4 : -1);\n    return v8;\n  }\n  v8 = (!strcmp(a0, a1) ? -1 : 0);\n  return v8;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fields_in_line_name_conflict(unsigned long a0, char *a1) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18], Other Possible Types: unsigned long long\n  char *v2;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = a0;\n  v1 = 1;\n  if (a0 && a1) {\n    v0 = strlen(a1);\n    while (true) {\n      v2 = strstr(v2, a1);\n      if (!v2)\n        break;\n      v1 += 1;\n      v2 += v0;\n    }\n    return v1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_field(unsigned long a0, char *a1, char *a2, unsigned long a3,\n                         char *a4) {\n  char *v0;              // [bp-0x40]\n  unsigned int v1;       // [bp-0x1c]\n  char *v2;              // [bp-0x18]\n  char *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long v6; // rdx\n  unsigned long v7;      // rax, Other Possible Types: unsigned int\n\n  v0 = a2;\n  if (a4 && *(a4)) {\n    v2 = field_start(a1, (unsigned int)a3 + 1, a4);\n    if (!v2) {\n      *((char *)a0) = 0;\n      return 4294967295;\n    }\n    v3 = strstr(v2, a4);\n    if (!v3) {\n      for (v3 = &a1[1 + strlen(a1)]; *(v3) == 10 || *(v3) == 13; v3 += 1)\n        ;\n      v3 += 1;\n    }\n    v6 = v3 - v2;\n    v7 = v0 + 1;\n    if (v6 <= v7)\n      v7 = v6;\n    v1 = v7;\n    strncpy(a0, v2, v1);\n    *((char *)(a0 + v1)) = 0;\n    return v1;\n  }\n  strncpy(a0, a1, v0);\n  v0[a0] = 0;\n  return strlen(a0);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long copy_field(unsigned long long a0, char **a1, unsigned long long *a2,\n                     unsigned long a3, char *a4) {\n  unsigned int v0; // [bp-0x1c]\n  char *v1;        // [bp-0x18]\n  struct_0 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = field_start(a0, a3 + 1, a4);\n  if (!v1)\n    return 4294967295;\n  v2 = strstr(v1, a4);\n  if (!v2) {\n    for (v2 = &v1[strlen(v1)];\n         *((char *)(v2 - 1)) == 10 || *((char *)(v2 - 1)) == 13; v2 -= 1)\n      ;\n  }\n  v0 = (unsigned int)(v2 - v1);\n  if (!*(a1) || !a2) {\n    *(a1) = xmalloc(v0 + 1);\n    *(a2) = v0 + 1;\n  } else if (*(a2) < v0 + 1) {\n    *(a1) = xrealloc(*(a1), v0 + 1);\n    *(a2) = v0 + 1;\n  }\n  (*(a1))[v0] = 0;\n  strncpy(*(a1), v1, v0);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3l8roor9/copy_field.c:21:16: error: expected ';' at end of declaration\nlist 21 |     char field_-1; |                ^ |                ;\n/tmp/tmp3l8roor9/copy_field.c:38:28: error: 'struct_0 *' (aka 'struct struct_0\n*') and 'char *' are not pointers to compatible types 38 |     v0 = (unsigned\nint)(v2 - v1); |                         ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long field_start_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  unsigned long v0; // [bp-0x20]\n  char *v1;         // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v2;  // [bp-0xc]\n\n  v1 = a0;\n  v0 = strlen(a2);\n  v2 = 1;\n  while (true) {\n    if (v2 < a1) {\n      v1 = strstr(v1, a2);\n      if (!v1)\n        return 0;\n      v1 += v0;\n      v2 += 1;\n    } else {\n      return v1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mdyhms_datecmp_name_conflict(char a0[10], char a1[10]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0[6] == a1[6] && a0[7] == a1[7] && a0[8] == a1[8] && a0[9] == a1[9]) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  (unsigned int)v1 = strncmp(&a0[6], &a1[6], 4);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn5o2n2vb/mdyhms_datecmp_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpn5o2n2vb/mdyhms_datecmp_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v1 = strncmp(&a0[6],\n&a1[6], 4); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long dmyhms_datecmp_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = strncmp(a0 + 6, a1 + 6, 4);\n  if (v0)\n    return v0;\n  v0 = strncmp(a0 + 3, a1 + 3, 2);\n  if (!v0)\n    return strcmp(a0, a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strtok)(char *, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\nlong long(arr_resize)(long long, long long, long long, long long);\n\nlong long expand_nums(char *a0, unsigned long long *a1,\n                      unsigned long long *a2) {\n  char v0;               // [bp-0x24]\n  char v1;               // [bp-0x20]\n  unsigned int v2;       // [bp-0x1c]\n  char *v3;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned int v10;      // eax\n  unsigned int *v11;     // rax\n\n  v7 = &v5;\n  if (!(a0 && *(a0)))\n    return 0;\n  for (v4 = 0; a0[v4]; v4 += 1) {\n    v10 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v4] * 2)) & 0x800;\n    if (!v10 && a0[v4] != 44 && a0[v4] != 45)\n      return -2;\n  }\n  v4 = 0;\n  if (!*(a1) && !*(a2)) {\n    *(a1) = xmalloc(64);\n    *(a2) = 16;\n  }\n  if (!strchr(a0, 44) && !strchr(a0, 45)) {\n    __isoc99_sscanf(a0, \"%u\", (unsigned int)*(a1));\n    return 1;\n  }\n  for (v3 = strtok(a0, \",\"); v3; v3 = strtok(NULL, \",\")) {\n    if (v4 >= *(a2)) {\n      *(a2) = arr_resize(a1, 4, *(a2), 16);\n      if (!*(a2))\n        return -1;\n    }\n    if (!strchr(v3, 45)) {\n      __isoc99_sscanf(v3, \"%u\", (unsigned int)(v4 * 4 + *(a1)));\n      v4 += 1;\n    } else {\n      __isoc99_sscanf(v3, \"%u-%u\", (unsigned int)&v1, (unsigned int)&v0);\n      if (*(a2) < v4 + *((int *)&v0) - *((int *)&v1)) {\n        *(a2) = arr_resize(a1, 4, *(a2), *((int *)&v0) - *((int *)&v1));\n        if (!*(a2))\n          return -1;\n      }\n      for (v2 = *((int *)&v1); *((int *)&v0) >= v2; v2 += 1) {\n        v11 = v4;\n        v4 = (unsigned int)v11 + 1;\n        *((unsigned int *)(*(a1) + v11 * 4)) = v2;\n      }\n    }\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0jmb53ad/expand_nums.c:38:42: error: cannot take the address of an\nrvalue of type 'int' 38 |         v10 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0[v4] * 2)) & 0x800; | ^~~~~~~~~~~~~~~~\n/tmp/tmp0jmb53ad/expand_nums.c:79:48: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 79 |                 *((unsigned int\n*)(*(a1) + v11 * 4)) = v2; |                                            ~~~ ^ ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(arr_resize)(long long, long long, long long, long long);\nlong long(field_str)(long long, long long, long long);\n\nlong long expand_label_list(char *a0, unsigned long long a1,\n                            unsigned long long a2, unsigned long long *a3,\n                            unsigned long long *a4) {\n  unsigned long v0;  // [bp-0x40]\n  char *v1;          // [bp-0x38]\n  unsigned long v2;  // [bp-0x30]\n  unsigned int v3;   // [bp-0x24]\n  char *v4;          // [bp-0x20], Other Possible Types: unsigned long\n  void *v5;          // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v6;   // [bp-0x10]\n  unsigned int v7;   // [bp-0xc]\n  unsigned long v9;  // rax\n  unsigned int *v11; // rax\n\n  v7 = 0;\n  v6 = 0;\n  v2 = strlen(a0);\n  v1 = xmalloc(v2 + 1);\n  for (v5 = 0; v7 < v2 + 1; v6 += 1) {\n    if (!(!(!a0[v7]) && !(a0[v7] == 10) && !(a0[v7] == 13))) {\n      v1[v6] = 0;\n      v5 += 1;\n      break;\n    } else if (a0[v7] == 92) {\n      if (a0[1 + v7] == 92) {\n        v1[v6] = 92;\n      } else {\n        if (a0[1 + v7] != 44) {\n          v9 = v6;\n          v6 = (unsigned int)v9 + 1;\n          v1[v9] = a0[v7];\n          v1[v6] = a0[1 + v7];\n        } else {\n          v1[v6] = 44;\n        }\n      }\n      v7 += 2;\n    } else if (a0[v7] != 44) {\n      v1[v6] = a0[v7];\n      v7 += 1;\n    } else {\n      v1[v6] = 0;\n      v5 += 1;\n      v7 += 1;\n    }\n  }\n  v0 = &v1[v6];\n  if (!*(a3)) {\n    *(a3) = xmalloc(v5 * 4);\n    *(a4) = v5;\n  } else if (*(a4) < v5) {\n    *(a4) = arr_resize(a3, 4, *(a4), v5 - *(a4));\n    if (!*(a4))\n      return -2;\n  }\n  v3 = 0;\n  v6 = 0;\n  for (v4 = v1; v4 != v0 + 1; v4 = &v4[1 + strlen(v4)]) {\n    v7 = field_str(v4, a1, a2);\n    if (v7 < 0) {\n      warnx(\"Failed to find field label: %s\");\n      v3 += 1;\n    }\n    v11 = v6;\n    v6 = (unsigned int)v11 + 1;\n    *((unsigned int *)(v11 * 4 + *(a3))) = v7 + 1;\n  }\n  if (v3)\n    return -1;\n  free(v1);\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpapyfo8bq/expand_label_list.c:82:28: error: invalid operands to binary\nexpression ('void *' and 'int') 82 |         *(a3) = xmalloc(v5 * 4); | ~~ ^ ~\n/tmp/tmpapyfo8bq/expand_label_list.c:103:32: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 103 |         *((unsigned int *)(v11 * 4\n+ *(a3))) = v7 + 1; |                            ~~~ ^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_pos(char *a0, unsigned long a1, char *a2, unsigned int *a3,\n                       unsigned int *a4) {\n  unsigned long v0; // [bp-0x18]\n  char *v1;         // [bp-0x10]\n\n  v1 = field_start(a0, (unsigned int)a1 + 1, a2);\n  if (!v1) {\n    *(a3) = -1;\n    *(a4) = -1;\n    return 4294967295;\n  }\n  *(a3) = v1 - a0;\n  v0 = strstr(v1, a2);\n  if (!v0) {\n    for (*(a4) = (unsigned int)strlen(a0) - 1;\n         a0[*(a4)] == 10 || a0[*(a4)] == 13; *(a4) = *(a4)-1)\n      ;\n    if (*(a4) < *(a3))\n      *(a4) = *(a3);\n  } else if (v0 == v1) {\n    *(a4) = (unsigned int)(v0 - a0);\n  } else {\n    *(a4) = (unsigned int)(v0 - a0) - 1;\n  }\n  if (*(a3) != *(a4))\n    return *(a4) - *(a3) + 1;\n  if (!(a0[*(a3)] && a0[*(a3)] != 10 && a0[*(a3)] != 13 &&\n        strncmp(&a0[*(a3)], a2, strlen(a2))))\n    return 0;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfr1ugqb8/get_line_pos.c:40:35: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 40 |         *(a4) = (unsigned int)(v0\n- a0); |                                ~~ ^ ~~\n/tmp/tmpfr1ugqb8/get_line_pos.c:44:35: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 44 |         *(a4) = (unsigned int)(v0\n- a0) - 1; |                                ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(get_line_field)(long long, long long, long long, long long,\n                          long long);\n\nlong long field_str_name_conflict(char *a0, char *a1, char *a2) {\n  unsigned int v0;       // [bp-0x24]\n  char *v1;              // [bp-0x20]\n  unsigned int v2;       // [bp-0x14]\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned long v8;      // rax\n\n  v7 = &v5;\n  if (!a0)\n    return -2;\n  if (!(a1 && *(a1)))\n    return -1;\n  if (a2 && *(a2)) {\n    v2 = (unsigned int)strlen(a0) + 3;\n    v1 = xmalloc(v2 + 1);\n    v4 = 0;\n    v0 = 0;\n    v3 = 0;\n    while (true) {\n      v0 = get_line_field(v1, a1, v2, v4, a2);\n      if (v0 < 0)\n        break;\n      if (strcmp(v1, a0)) {\n        v4 += 1;\n      } else {\n        v3 = 1;\n        break;\n      }\n    }\n    free(v1);\n    v8 = (!v3 ? v4 : -1);\n    return v8;\n  }\n  v8 = (!strcmp(a0, a1) ? -1 : 0);\n  return v8;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"int qsort_strcmp(const char **a, const char **b) {\n    return strcmp(*a, *b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long qsort_strcmp_name_conflict(char **a0, char **a1) { return strcmp(*(a0), *(a1)); }\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_intcmp(const int *a, const int *b) {\n    return *a - *b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long qsort_intcmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a0) - *(a1);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_uintcmp(const unsigned int *a, const unsigned int *b) {\n    return *a - *b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long qsort_uintcmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a0) - *(a1);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"static char *striplower(char *s) {\n    char *p = ((void *)0);\n    for (p = s; p && *p; p++) {\n        if (*p == '/')\n            *p = ',';\n        *p = tolower(*p);\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tolower)(int);\n\nlong long striplower_name_conflict(char *a0) {\n  char *v0;              // [bp-0x10], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 0;\n  for (v0 = a0; v0; v0 += 1) {\n    if (!*((char *)v0))\n      return a0;\n    if (*((char *)v0) == 47)\n      *((char *)v0) = 44;\n    *((char *)v0) = tolower(*((char *)v0));\n  }\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int get_filepath(char *filepath, size_t len, char *channel, char *file) {\n    if (channel) {\n        if (!snprintf(filepath, len, \"%s/%s\", path, channel))\n            return 0;\n        create_dirtree(filepath);\n        return snprintf(filepath, len, \"%s/%s/%s\", path, channel, file);\n    }\n    return snprintf(filepath, len, \"%s/%s\", path, file);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(create_dirtree)(long long);\n\nextern char path;\n\nlong long get_filepath(char *a0, unsigned int a1, unsigned long a2,\n                       unsigned long a3) {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  if (!a2) {\n    (unsigned int)v1 = snprintf(a0, a1, \"%s/%s\", &path, (unsigned int)a3);\n    return v1;\n  } else if (snprintf(a0, a1, \"%s/%s\", &path, (unsigned int)a2)) {\n    create_dirtree(a0);\n    (unsigned int)v1 =\n        snprintf(a0, a1, \"%s/%s/%s\", &path, (unsigned int)a2, (unsigned int)a3);\n    return v1;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw8tqvtai/get_filepath.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpw8tqvtai/get_filepath.c:27:9: error: assignment to cast is illegal,\nlvalue casts are not supported 27 |         (unsigned int)v1 = snprintf(a0, a1,\n\"%s/%s\", &path, (unsigned int)a3); |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpw8tqvtai/get_filepath.c:33:9: error: assignment to cast is illegal,\nlvalue casts are not supported 33 |         (unsigned int)v1 = snprintf(a0, a1,\n\"%s/%s/%s\", &path, (unsigned int)a2, (unsigned int)a3); | ^~~~~~~~~~~~~~~~ ~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int open_channel(char *name) {\n    static char infile[256];\n    create_filepath(infile, sizeof (infile), name, \"in\");\n    if (access(infile, 0) == -1)\n        mkfifo(infile, (256 | 128 | 64));\n    return open(infile, 0 | 2048, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(create_filepath)(long long, long long, long long, long long);\nint(access)(char *, int);\nint(mkfifo)(char *, unsigned short);\nint(open)(char *, int, unsigned short);\n\nextern char infile.4;\n\nlong long open_channel_name_conflict(unsigned long long a0) {\n  create_filepath(&infile.4, 0x100, a0, \"in\");\n  if (access(&infile.4, 0) == -1) {\n    mkfifo(&infile.4, 448);\n    return open(&infile.4, 0x800, 0);\n  }\n  return open(&infile.4, 0x800, 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:21:19: error: expected ';' after top level\ndeclarator 21 | extern char infile.4; |                   ^ | ;\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:25:28: error: expected ')'\n   25 |     create_filepath(&infile.4, 0x100, a0, \"in\");\n      |                            ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:25:20: note: to match this '('\n   25 |     create_filepath(&infile.4, 0x100, a0, \"in\");\n      |                    ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:26:23: error: expected ')'\n   26 |     if (access(&infile.4, 0) == -1)\n      |                       ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:26:15: note: to match this '('\n   26 |     if (access(&infile.4, 0) == -1)\n      |               ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:28:23: error: expected ')'\n   28 |         mkfifo(&infile.4, 448);\n      |                       ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:28:15: note: to match this '('\n   28 |         mkfifo(&infile.4, 448);\n      |               ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:29:28: error: expected ')'\n   29 |         return open(&infile.4, 0x800, 0);\n      |                            ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:29:20: note: to match this '('\n   29 |         return open(&infile.4, 0x800, 0);\n      |                    ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:31:24: error: expected ')'\n   31 |     return open(&infile.4, 0x800, 0);\n      |                        ^\n/tmp/tmp5reos2ha/open_channel_name_conflict.c:31:16: note: to match this '('\n   31 |     return open(&infile.4, 0x800, 0);\n      |                ^\n6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int tcpopen(unsigned short port) {\n    int fd;\n    struct sockaddr_in sin;\n    memset(&sin, 0, sizeof(struct sockaddr_in));\n    struct hostent *hp = gethostbyname(host);\n    if (!hp) {\n        perror(\"plom-ii: cannot retrieve host information\");\n        exit(1);\n    }\n    memcpy(&sin.sin_addr, hp->h_addr_list[0], hp->h_length);\n    sin.sin_family = 2;\n    sin.sin_port = htons(port);\n    if ((fd = socket(2, SOCK_STREAM, 0)) < 0) {\n        perror(\"plom-ii: cannot create socket\");\n        exit(1);\n    }\n    if (connect(fd, (const struct sockaddr *)&sin, sizeof (sin)) < 0) {\n        perror(\"plom-ii: cannot connect to host\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct hostent *(gethostbyname)(char *);\nvoid(perror)(char *);\nunsigned short(htons)(unsigned short);\nint(socket)(int, int, int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\n\ntypedef struct struct_0 {\n  char padding_0[20];\n  unsigned int field_14;\n  struct struct_1 *field_18;\n} struct_0;\n\ntypedef struct struct_1 {\n  void *field_0;\n} struct_1;\n\nextern char *host;\n\nlong long tcpopen_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0x28], Other Possible Types: char\n  unsigned short v1; // [bp-0x26]\n  char v2;           // [bp-0x24]\n  unsigned int v3;   // [bp-0x14]\n  struct_0 *v4;      // [bp-0x10]\n\n  memset(&v0, 0, 16);\n  v4 = &gethostbyname(host)->h_name;\n  if (!v4) {\n    perror(\"plom-ii: cannot retrieve host information\");\n    exit(1); /* do not return */\n  }\n  memcpy(&v2, v4->field_18->field_0, v4->field_14);\n  v0 = 2;\n  v1 = htons(a0);\n  v3 = socket(2, 1, 0);\n  if (v3 < 0) {\n    perror(\"plom-ii: cannot create socket\");\n    exit(1); /* do not return */\n  } else if (connect(v3, &v0, 16) >= 0) {\n    return v3;\n  } else {\n    perror(\"plom-ii: cannot connect to host\");\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe7u9y0ey/tcpopen_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpe7u9y0ey/tcpopen_name_conflict.c:46:30: error: incomplete definition of type 'struct\nhostent' 46 |     v4 = &gethostbyname(host)->h_name; | ~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpe7u9y0ey/tcpopen_name_conflict.c:16:8: note: forward declaration of 'struct hostent'\n   16 | struct hostent *(gethostbyname)(char *);\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static size_t tokenize(char **result, size_t reslen, char *str, char delim) {\n    char *p = ((void *)0), *n = ((void *)0);\n    size_t i;\n    if (!str)\n        return 0;\n    for (n = str; *n == ' '; n++)\n        ;\n    p = n;\n    for (i = 0; *n != 0;) {\n        if (i == reslen)\n            return 0;\n        if (*n == delim) {\n            *n = 0;\n            result[i++] = p;\n            p = ++n;\n        } else\n            n++;\n    }\n    if (i < reslen && p < n && strlen(p))\n        result[i++] = p;\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long tokenize(unsigned long a0, unsigned long a1, char *a2,\n                   unsigned long a3) {\n  unsigned long long *v0; // [bp-0x20], Other Possible Types: unsigned long\n  char *v1;               // [bp-0x18], Other Possible Types: unsigned long\n  char *v2;               // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long *v5; // rax\n  unsigned long v6;       // rax\n\n  v2 = 0;\n  v1 = 0;\n  if (!a2)\n    return 0;\n  for (v1 = a2; *(v1) == 32; v1 += 1)\n    ;\n  v2 = v1;\n  v0 = 0;\n  while (*((char *)v1)) {\n    if (v0 == a1) {\n      return 0;\n    } else if ((char)a3 == *((char *)v1)) {\n      *((char *)v1) = 0;\n      v5 = v0;\n      v0 = (char *)v5 + 1;\n      *((char **)(v5 * 8 + a0)) = v2;\n      v1 += 1;\n      v2 = v1;\n    } else {\n      v1 += 1;\n    }\n  }\n  if (!(v0 < a1 && v2 < v1 && *((char *)v2)))\n    return v0;\n  v6 = v0;\n  v0 = v6 + 1;\n  *((unsigned long *)(v6 * 8 + a0)) = v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp31ulpzqn/tokenize.c:43:28: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 43 |             *((char **)(v5 * 8 + a0)) =\nv2; |                         ~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int read_line(int fd, size_t res_len, char *buf) {\n    size_t i = 0;\n    char c = 0;\n    do {\n        if (read(fd, &c, sizeof(char)) != sizeof(char))\n            return -1;\n        buf[i++] = c;\n    } while (c != '\\n' && i < res_len);\n    buf[i - 1] = 0;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long read_line_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;  // [bp-0x11]\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n  char *v3; // rax\n\n  v1 = 0;\n  v0 = 0;\n  do {\n    if (read(a0, &v0, 1) != 1)\n      return 4294967295;\n  } while ((v3 = v1, v1 = (unsigned long)(v3 + 1), v3[a2] = v0,\n            v0 != 10 && v1 < a1));\n  *((char *)(a2 + v1 - 1)) = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"int Needs_Quote(char *str) {\n    while (*str)\n        {\n            if (!((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) && strchr(\"-_./\", *str) == ((void *)0))\n                return 1;\n            str++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Needs_Quote_name_conflict(char *a0) {\n  char *v0;              // [bp-0x10], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  for (v0 = a0; *(v0); v0 += 1) {\n    if (!((char)*((short *)((*(v0) << 1) + *((long long *)&__ctype_b_loc()))) &\n          8) &&\n        !strchr(\"-_./\", *(v0)))\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwxtxv_hj/Needs_Quote_name_conflict.c:26:63: error: cannot take the address of an\nrvalue of type 'int' 26 |         if (!((char)*((short *)((*(v0) << 1) + *((long\nlong *)&__ctype_b_loc()))) & 8) && !strchr(\"-_./\", *(v0))) | ^~~~~~~~~~~~~~~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"char *Get_Label(char *str) {\n    if (((*__ctype_b_loc())[(int)((*buff))] & (unsigned short)_ISspace))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) || strchr(\".$_\", *str))\n        str++;\n    if (*str != ':' || str[1] != '\\x00')\n        return ((void *)0);\n    *str = '\\x00';\n    return buff;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char buff;\n\nlong long Get_Label_name_conflict(char a0[2]) {\n  char v0[2];            // [bp-0x10], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n  unsigned int v5;       // eax\n\n  v3 = &v1;\n  *(&v0) = a0;\n  if (v5)\n    return 0;\n  for (v5 = *((short *)(*((long long *)&__ctype_b_loc()) + buff * 2)) & 0x2000;\n       ((char)*((short *)((v0[0] << 1) + *((long long *)&__ctype_b_loc()))) &\n        8) ||\n       strchr(\".$_\", v0[0]);\n       v0 += 1)\n    ;\n  if (!(*((char *)v0) == 58 && !*((char *)(v0 + 1))))\n    return 0;\n  *((char *)v0) = 0;\n  return &buff;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5wzxwg0d/Get_Label_name_conflict.c:27:12: error: array type 'char[2]' is not\nassignable 27 |     *(&v0) = a0; |     ~~~~~~ ^\n/tmp/tmp5wzxwg0d/Get_Label_name_conflict.c:30:42: error: cannot take the address of an rvalue\nof type 'int' 30 |     for (v5 = *((short *)(*((long long *)&__ctype_b_loc()) +\nbuff * 2)) & 0x2000; ((char)*((short *)((v0[0] << 1) + *((long long\n*)&__ctype_b_loc()))) & 8) || strchr(\".$_\", v0[0]); v0 += 1); | ^~~~~~~~~~~~~~~~\n/tmp/tmp5wzxwg0d/Get_Label_name_conflict.c:30:132: error: cannot take the address of an rvalue\nof type 'int' 30 |     for (v5 = *((short *)(*((long long *)&__ctype_b_loc()) +\nbuff * 2)) & 0x2000; ((char)*((short *)((v0[0] << 1) + *((long long\n*)&__ctype_b_loc()))) & 8) || strchr(\".$_\", v0[0]); v0 += 1); | ^~~~~~~~~~~~~~~~\n/tmp/tmp5wzxwg0d/Get_Label_name_conflict.c:30:185: error: invalid operands to binary\nexpression ('char[2]' and 'int') 30 |     for (v5 = *((short *)(*((long long\n*)&__ctype_b_loc()) + buff * 2)) & 0x2000; ((char)*((short *)((v0[0] << 1) +\n*((long long *)&__ctype_b_loc()))) & 8) || strchr(\".$_\", v0[0]); v0 += 1); | ~~\n^  ~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"int Detect_End_Of_Fct(char *buff) {\n    if (strncmp(buff, \"END\", 3) == 0)\n        return 1;\n    {\n        static int i = 0;\n        if (i == 0) {\n            fprintf(stderr, \"warning, Detect_End_Of_Fct() not customizedfor this architecture\\n)\");\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_4034e7;\nextern unsigned int i.0;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long Detect_End_Of_Fct_name_conflict(char *a0) {\n  if (!strncmp(a0, &g_4034e7, 3))\n    return 1;\n  if (i.0)\n    return 0;\n  fwrite(\"warning, Detect_End_Of_Fct_name_conflict() not customizedfor this architecture\\n)\",\n         1, 66, stderr @GLIBC_2.2.5);\n  i.0 = i.0 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern unsigned int i.0; |                      ^ | ;\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:19:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:25:10: error: expected ')'\n   25 |     if (i.0)\n      |          ^\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:25:8: note: to match this '('\n   25 |     if (i.0)\n      |        ^\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:27:96: error: expected ')'\n   27 |     fwrite(\"warning, Detect_End_Of_Fct_name_conflict() not customizedfor this\narchitecture\\n)\", 1, 66, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:27:11: note: to match this '('\n   27 |     fwrite(\"warning, Detect_End_Of_Fct_name_conflict() not customizedfor this\narchitecture\\n)\", 1, 66, stderr@GLIBC_2.2.5); |           ^\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:28:6: error: expected ';' after expression\n   28 |     i.0 = i.0 + 1;\n      |      ^\n      |      ;\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:28:9: error: expression is not assignable\n   28 |     i.0 = i.0 + 1;\n      |      ~~ ^\n/tmp/tmpv6xgv38c/Detect_End_Of_Fct_name_conflict.c:28:12: error: expected ';' after expression\n   28 |     i.0 = i.0 + 1;\n      |            ^\n      |            ;\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"static int Common_Prefix_Length(char *str1, int l1, char *str2, int l2) {\n    if (l1 < l2)\n        l2 = l1;\n    l1 = 0;\n    while (l1 < l2 && *str1 == *str2)\n        {\n            str1++;\n            str2++;\n            l1++;\n        }\n    return l1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Common_Prefix_Length(char *a0, unsigned long a1, char *a2,\n                               unsigned long a3) {\n  char *v0;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0x18]\n  unsigned int v2; // [bp-0x14]\n  char *v3;        // [bp-0x10], Other Possible Types: unsigned long\n\n  v3 = a0;\n  v2 = a1;\n  v0 = a2;\n  v1 = a3;\n  if (v2 < v1)\n    v1 = v2;\n  for (v2 = 0; v2 < v1; v2 += 1) {\n    if (*(v3) != *(v0))\n      return v2;\n    v3 += 1;\n    v0 += 1;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":0,"function":"int Display_Completion(char *str, int length, int no) {\n    printf(\"match %6d  :<%s> len=%d\\n\", no, str, length);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Display_Completion(unsigned long a0, unsigned long a1,\n                             unsigned long a2) {\n  printf(\"match %6d  :<%s> len=%d\\n\", (unsigned int)a2, (unsigned int)a0,\n         (unsigned int)a1);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":0,"function":"static int init_mparams(void) {\n    ;\n    if (mparams.magic == 0) {\n        size_t magic;\n        size_t psize;\n        size_t gsize;\n        psize = sysconf(_SC_PAGESIZE);\n        gsize = (((0) != 0) ? (0) : psize);\n        if ((sizeof(size_t) != sizeof(char *)) || ((~(size_t)0) < (((sizeof(mchunk)) + (((size_t)8U) - ((size_t)1))) & ~(((size_t)8U) - ((size_t)1)))) || (sizeof(int) < 4) || (((size_t)8U) < (size_t)8U) || ((((size_t)8U) & (((size_t)8U) - ((size_t)1))) != 0) || (((sizeof(mchunk)) & ((sizeof(mchunk)) - ((size_t)1))) != 0) || ((gsize & (gsize - ((size_t)1))) != 0) || ((psize & (psize - ((size_t)1))) != 0))\n            abort();\n        mparams.granularity = gsize;\n        mparams.page_size = psize;\n        mparams.mmap_threshold = ((size_t)256U * (size_t)1024U);\n        mparams.trim_threshold = ((size_t)2U * (size_t)1024U * (size_t)1024U);\n        mparams.default_mflags = (0U) | (((size_t)1));\n        (&_gm_)->mflags = mparams.default_mflags;\n        (void)(0);\n        {\n            magic = (size_t)(time(0) ^ (size_t)1431655765U);\n            magic |= (size_t)8U;\n            magic &= ~(size_t)7U;\n            (*(volatile size_t *)(&(mparams.magic))) = magic;\n        }\n    }\n    ;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sysconf)(int);\nlong(time)(long *);\n\nextern unsigned long long g_40e1c8;\nextern unsigned long long g_40e1d0;\nextern unsigned long long g_40e1d8;\nextern unsigned long long g_40e1e0;\nextern unsigned int g_40e1e8;\nextern unsigned int g_40e570;\nextern unsigned long long mparams;\n\nlong long init_mparams_name_conflict() {\n  unsigned long v0;      // [bp-0x20]\n  unsigned long v1;      // [bp-0x18]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  if (mparams)\n    return 1;\n  v2 = sysconf(30);\n  v1 = v2;\n  if (!(!(v1 - 1 & v1) && !(v2 - 1 & v2)))\n    abort(); /* do not return */\n  g_40e1d0 = v1;\n  g_40e1c8 = v2;\n  g_40e1d8 = 0x40000;\n  g_40e1e0 = 0x200000;\n  g_40e1e8 = 1;\n  g_40e570 = g_40e1e8;\n  v0 = time(NULL) ^ 1431655765;\n  v0 |= 8;\n  v0 &= -8;\n  mparams = v0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"static int change_mparam(int param_number, int value) {\n    size_t val;\n    (void)(mparams.magic != 0 || init_mparams());\n    val = (value == -1) ? (~(size_t)0) : (size_t)value;\n    switch (param_number) {\n      case (-1):\n        mparams.trim_threshold = val;\n        return 1;\n      case (-2):\n        if (val >= mparams.page_size && ((val & (val - 1)) == 0)) {\n            mparams.granularity = val;\n            return 1;\n        } else\n            return 0;\n      case (-3):\n        mparams.mmap_threshold = val;\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_mparams)();\n\nextern unsigned long long g_40e1c8;\nextern unsigned long long g_40e1d0;\nextern unsigned long long g_40e1d8;\nextern unsigned long long g_40e1e0;\nextern unsigned long long mparams;\n\nlong long change_mparam_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n\n  if (!mparams)\n    init_mparams();\n  *((int *)&v0) = ((unsigned int)a1 == -1 ? (unsigned int)a1 : -1);\n  if ((unsigned int)a0 == -1) {\n    g_40e1e0 = v0;\n    return 1;\n  }\n  if ((unsigned int)a0 >= 0)\n    return 0;\n  if ((unsigned int)a0 == -3) {\n    g_40e1d8 = v0;\n    return 1;\n  } else if ((unsigned int)a0 == -2) {\n    if (!(v0 >= g_40e1c8 && !(v0 - 1 & v0)))\n      return 0;\n    g_40e1d0 = v0;\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int malloc_trim(size_t pad) {\n    int result = 0;\n    (void)(mparams.magic != 0 || init_mparams());\n    if (!(0)) {\n        result = sys_trim((&_gm_), pad);\n        ;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_mparams)();\nlong long(sys_trim)(long long, long long);\n\nextern unsigned long long _gm_;\nextern unsigned long long mparams;\n\nlong long malloc_trim_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  if (!mparams)\n    init_mparams();\n  v0 = sys_trim(&_gm_, a0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint(void) {\n    return (&_gm_)->footprint;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_40e558;\n\nlong long malloc_footprint_name_conflict() { return g_40e558; }\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_max_footprint(void) {\n    return (&_gm_)->max_footprint;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_40e560;\n\nlong long malloc_max_footprint_name_conflict() { return g_40e560; }\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint_limit(void) {\n    size_t maf = (&_gm_)->footprint_limit;\n    return maf == 0 ? (~(size_t)0) : maf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_40e568;\n\nlong long malloc_footprint_limit_name_conflict() {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = g_40e568;\n  return (!v0 ? v0 : -1);\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_set_footprint_limit(size_t bytes) {\n    size_t result;\n    if (bytes == 0)\n        result = (((1) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    if (bytes == (~(size_t)0))\n        result = 0;\n    else\n        result = (((bytes) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    return (&_gm_)->footprint_limit = result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_40e1d0;\nextern unsigned long long g_40e568;\n\nlong long malloc_set_footprint_limit_name_conflict(unsigned long a0) {\n  void *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  if (!a0)\n    v0 = -(g_40e1d0)&g_40e1d0;\n  if (a0 == -1)\n    v0 = 0;\n  else\n    v0 = -(g_40e1d0)&a0 + g_40e1d0 - 1;\n  g_40e568 = v0;\n  return g_40e568;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"struct mallinfo mallinfo(void) {\n    return internal_mallinfo((&_gm_));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(internal_mallinfo_name_conflict)(long long, long long);\n\nextern unsigned long long _gm_;\n\nlong long mallinfo_name_conflict(unsigned long long a0) {\n  internal_mallinfo_name_conflict(a0, &_gm_);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int mallopt(int param_number, int value) {\n    return change_mparam(param_number, value);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(change_mparam)(long long, long long);\n\nlong long mallopt_name_conflict(unsigned long a0, unsigned long a1) {\n  return change_mparam((unsigned int)a0, (unsigned int)a1);\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(localtime)(long *);\n\nlong long format_date_r_name_conflict(char *a0) {\n  unsigned int v0;    // [bp-0x18]\n  unsigned int v1[6]; // [bp-0x10]\n\n  *((long *)&v0) = time(NULL);\n  *((struct tm **)&v1[0]) = localtime(&v0);\n  sprintf(a0, \"%02d/%02d/%04d %02d:%02d:%02d\", v1[4] + 1, v1[3], v1[5] + 1900,\n          v1[2], v1[1], v1[0]);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(localtime)(long *);\n\nlong long format_date_r_name_conflict(char *a0) {\n  unsigned int v0;    // [bp-0x18]\n  unsigned int v1[6]; // [bp-0x10]\n\n  *((long *)&v0) = time(NULL);\n  *((struct tm **)&v1[0]) = localtime(&v0);\n  sprintf(a0, \"%02d/%02d/%04d %02d:%02d:%02d\", v1[4] + 1, v1[3], v1[5] + 1900,\n          v1[2], v1[1], v1[0]);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *strtok_r(char *s1, const char *s2, char **lasts) {\n    char *ret;\n    if (s1 == ((void *)0))\n        s1 = *lasts;\n    while (*s1 && strchr(s2, *s1))\n        ++s1;\n    if (*s1 == '\\x00')\n        return ((void *)0);\n    ret = s1;\n    while (*s1 && !strchr(s2, *s1))\n        ++s1;\n    if (*s1)\n        *s1++ = '\\x00';\n    *lasts = s1;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strtok_r_name_conflict(char *a0, char *a1, struct struct_0 **a2) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  char *v6;              // rax\n\n  v4 = &v2;\n  v0 = a0;\n  if (!v0)\n    v0 = *(a2);\n  for (; *((char *)v0) && strchr(a1, *((char *)v0)); v0 += 1)\n    ;\n  if (!*((char *)v0))\n    return 0;\n  for (v1 = v0; *((char *)v0) && !strchr(a1, *((char *)v0)); v0 += 1)\n    ;\n  if (*((char *)v0)) {\n    v6 = v0;\n    v0 = v6 + 1;\n    *(v6) = 0;\n  }\n  *(a2) = v0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strsep(char **stringp, const char *delim) {\n    char *ret = *stringp;\n    if (ret == ((void *)0))\n        return (((void *)0));\n    if ((*stringp = strpbrk(*stringp, delim)) != ((void *)0))\n        *((*stringp)++) = '\\x00';\n    return (ret);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strsep_name_conflict(struct struct_0 **a0, char *a1) {\n  char *v0; // [bp-0x10]\n  char *v3; // rax\n\n  v0 = &*(a0)->field_0;\n  if (!v0)\n    return 0;\n  *(a0) = strpbrk(*(a0), a1);\n  if (!*(a0))\n    return v0;\n  v3 = *(a0);\n  *(a0) = &v3[1];\n  *(v3) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph2ucxwep/strsep_name_conflict.c:22:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 22 |     v0 = &*(a0)->field_0; | ~~~~^\n~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *ltrim(char *str) {\n    char *p;\n    if (!str || !str[0])\n        return str;\n    for (p = str; ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); ++p) {\n    }\n    if (p > str)\n        strcpy(str, p);\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ltrim_name_conflict(char *a0) {\n  char *v0;              // [bp-0x10], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (a0 && *(a0)) {\n    for (v0 = a0;\n         (*((short *)((*(v0) << 1) + *((long long *)&__ctype_b_loc()))) &\n          0x2000);\n         v0 += 1)\n      ;\n    if (a0 >= v0)\n      return a0;\n    strcpy(a0, v0);\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6wq6kaak/ltrim_name_conflict.c:26:66: error: cannot take the address of an rvalue of\ntype 'int' 26 |         for (v0 = a0; (*((short *)((*(v0) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v0 += 1); | ^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *rtrim(char *str) {\n    size_t offset;\n    char *p;\n    if (!str || !str[0])\n        return str;\n    offset = strlen(str);\n    p = str + offset - 1;\n    for (; p >= str && ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); --p) {\n        *p = 0;\n    }\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rtrim_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x18]\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  if (a0 && *(a0)) {\n    v0 = strlen(a0);\n    for (v1 = &a0[1 + v0];\n         v1 >= a0 && (*((short *)((*((char *)v1) << 1) +\n                                  *((long long *)&__ctype_b_loc()))) &\n                      0x2000);\n         v1 -= 1) {\n      *((char *)v1) = 0;\n    }\n    return a0;\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwfdl3wyt/rtrim_name_conflict.c:28:95: error: cannot take the address of an rvalue of\ntype 'int' 28 |         for (v1 = &a0[1 + v0]; v1 >= a0 && (*((short *)((*((char\n*)v1) << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v1 -= 1) |\n^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcat(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    size_t dlen;\n    while (n-- != 0 && *d != '\\x00')\n        d++;\n    dlen = d - dst;\n    n = siz - dlen;\n    if (n == 0)\n        return (dlen + strlen(s));\n    while (*s != '\\x00')\n        {\n            if (n != 1) {\n                *d++ = *s;\n                n--;\n            }\n            s++;\n        }\n    *d = '\\x00';\n    return (dlen + (s - src));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlcat_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v0;      // [bp-0x30]\n  char *v2;              // rbx, Other Possible Types: unsigned long\n  char *v3;              // r13, Other Possible Types: unsigned long\n  unsigned long v4;      // r12, Other Possible Types: unsigned long long\n  unsigned long long v5; // rax\n  char *v6;              // rax\n  unsigned long long v7; // r12, Other Possible Types: unsigned long\n\n  v2 = a0;\n  v3 = a1;\n  v4 = a2;\n  while (true) {\n    v5 = v4;\n    v4 -= 1;\n    if (!(v5) || !(*((char *)v2)))\n      break;\n    v2 += 1;\n  }\n  v0 = v2 - a0;\n  if (!v7)\n    return strlen(a1) + v0;\n  for (v7 = a2 - v0; *((char *)v3); v3 += 1) {\n    if (v7 != 1) {\n      v6 = v2;\n      v2 += 1;\n      *(v6) = *((char *)v3);\n      v7 -= 1;\n    }\n  }\n  *((char *)v2) = 0;\n  return v0 + v3 - a1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcpy(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    if (n != 0 && --n != 0) {\n        do {\n            if ((*d++ = *s++) == 0)\n                break;\n        } while (--n != 0);\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlcpy_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x38]\n  char *v2;         // r13, Other Possible Types: unsigned long\n  char *v3;         // r12, Other Possible Types: unsigned long\n  char *v4;         // rdx\n  char *v5;         // rax\n  unsigned long v6; // rbx, Other Possible Types: unsigned long long\n  char *v7;         // rax\n\n  v0 = a2;\n  v2 = a0;\n  v3 = a1;\n  v6 = v0;\n  if (v6) {\n    v6 -= 1;\n    if (v6) {\n      do {\n        v4 = v3;\n        v3 += 1;\n        v5 = v2;\n        v2 += 1;\n        *(v5) = *(v4);\n      } while (*(v5) && (v6 -= 1, v6));\n    }\n  }\n  if (v6)\n    return -1 + v3 - a1;\n  if (v0)\n    *((char *)v2) = 0;\n  do {\n    v7 = v3;\n    v3 += 1;\n  } while (*(v7));\n  return -1 + v3 - a1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"const char *_ds_userdir_path(char *path, const char *home, const char *filename, const char *extension) {\n    char username[4096];\n    char userpath[4096];\n    if (filename == ((void *)0) || filename[0] == 0) {\n        path[0] = 0;\n        return path;\n    }\n    strlcpy(username, filename, 4096);\n    strcpy(userpath, username);\n    if (extension != ((void *)0) && (!strcmp(extension, \"nodspam\") || !strcmp(extension, \"dspam\"))) {\n        snprintf(path, 4096, \"%s/opt-%s/%s.%s\", home, (!strcmp(extension, \"nodspam\")) ? \"out\" : \"in\", userpath, extension);\n        return path;\n    }\n    if (extension == ((void *)0)) {\n        snprintf(path, 4096, \"%s/data/%s\", home, userpath);\n    } else {\n        snprintf(path, 4096, \"%s/data/%s/%s.%s\", home, userpath, username, extension);\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strlcpy)(long long, long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\n\nextern char g_40304e;\nextern char g_403052;\n\nlong long _ds_userdir_path_name_conflict(char *a0, unsigned long a1, char *a2, char *a3) {\n  char v0;         // [bp-0x2008]\n  char v1;         // [bp-0x1008]\n  unsigned int v4; // eax\n\n  if (a2 && *(a2)) {\n    strlcpy(&v1, a2, 0x1000);\n    strcpy(&v0, &v1);\n    if (a3 && (!(strcmp(a3, \"nodspam\")) || !(strcmp(a3, \"dspam\")))) {\n      if (strcmp(a3, \"nodspam\"))\n        v4 = &g_403052;\n      else\n        v4 = &g_40304e;\n      snprintf(a0, 0x1000, \"%s/opt-%s/%s.%s\", (unsigned int)a1, v4,\n               (unsigned int)&v0, (unsigned int)a3);\n      return a0;\n    }\n    if (!a3)\n      snprintf(a0, 0x1000, \"%s/data/%s\", (unsigned int)a1, (unsigned int)&v0);\n    else\n      snprintf(a0, 0x1000, \"%s/data/%s/%s.%s\", (unsigned int)a1,\n               (unsigned int)&v0, (unsigned int)&v1, (unsigned int)a3);\n    return a0;\n  }\n  *(a0) = 0;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd8uuzj35/_ds_userdir_path_name_conflict.c:17:6: error: conflicting types for\n'snprintf' 17 | int (snprintf)(char *, unsigned long, char *, ...); |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_prepare_path_for(const char *filename) {\n    char path[4096];\n    char *dir, *file;\n    char *file_buffer_start;\n    struct stat s;\n    if (!filename)\n        return 22;\n    file = strdup(filename);\n    if (!file) {\n        LOG(3, \"Memory allocation failed\");\n        return -5;\n    }\n    file_buffer_start = file;\n    path[0] = 0;\n    dir = strsep(&file, \"/\");\n    while (dir != ((void *)0))\n        {\n            strlcat(path, dir, sizeof (path));\n            dir = strsep(&file, \"/\");\n            {\n                if (dir != ((void *)0) && stat(path, &s) && path[0] != 0) {\n                    int x;\n                    ;\n                    ;\n                    x = mkdir(path, 504);\n                    if (x) {\n                        LOG(3, \"Unable to create directory: %s: %s\", path, strerror((*__errno_location())));\n                        free(file_buffer_start);\n                        return -3;\n                    }\n                }\n            }\n            strlcat(path, \"/\", sizeof (path));\n        }\n    free(file_buffer_start);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nchar(LOG)(long long, long long, long long, long long, long long, long long);\nlong long(strsep)(long long, long long);\nlong long(strlcat)(long long, long long, long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nchar *(strerror)(int);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long _ds_prepare_path_for(char *a0, unsigned long a1,\n                               unsigned long long a2, unsigned long long a3,\n                               unsigned long long a4, unsigned long long a5) {\n  stat v0;               // [bp-0x10c8]\n  unsigned long v1;      // [bp-0x1030]\n  char v2;               // [bp-0x1028]\n  unsigned int v3;       // [bp-0x1c]\n  void *v4;              // [bp-0x18]\n  unsigned long v5;      // [bp-0x10], Other Possible Types: unsigned long long\n  unsigned long long v9; // rax\n\n  if (!a0)\n    return 22;\n  v1 = strdup(a0);\n  if (!v1) {\n    LOG(3, \"Memory allocation failed\", a2, a3, a4, a5);\n    return 4294967291;\n  }\n  v4 = v1;\n  v2 = 0;\n  v5 = strsep(&v1, \"/\");\n  while (true) {\n    if (v5) {\n      strlcat(&v2, v5, 0x1000);\n      v5 = strsep(&v1, \"/\");\n      if (v5 && stat(&v2, &v0) && v2) {\n        v3 = mkdir(&v2, 504);\n        if (v3) {\n          v9 = strerror(*(__errno_location()));\n          LOG(3, \"Unable to create directory: %s: %s\", &v2, v9, a4, a5);\n          free(v4);\n          return 4294967293;\n        }\n      }\n      strlcat(&v2, \"/\", 0x1000);\n    } else {\n      free(v4);\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_bjkyk7c/_ds_prepare_path_for.c:52:3: error: redefinition of 'stat' as\ndifferent kind of symbol 52 | } stat; |   ^\n/tmp/tmp_bjkyk7c/_ds_prepare_path_for.c:20:6: note: previous definition is here\n   20 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmp_bjkyk7c/_ds_prepare_path_for.c:56:5: error: must use 'struct' tag to\nrefer to type 'stat' 56 |     stat v0;  // [bp-0x10c8] |     ^ |     struct\n/tmp/tmp_bjkyk7c/_ds_prepare_path_for.c:20:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 20 | int (stat)(char *, struct stat { | ^\n/tmp/tmp_bjkyk7c/_ds_prepare_path_for.c:86:35: error: indirection requires\npointer operand ('int' invalid) 86 |                     v9 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int lc(char *buff, const char *string) {\n    char *buffer;\n    int i, j = 0;\n    int len = strlen(string);\n    buffer = malloc(len + 1);\n    if (len == 0) {\n        buff[0] = 0;\n        free(buffer);\n        return 0;\n    }\n    for (i = 0; i < len; i++) {\n        if (((*__ctype_b_loc())[(int)(((int)string[i]))] & (unsigned short)_ISupper)) {\n            buffer[i] = tolower(string[i]);\n            j++;\n        } else {\n            buffer[i] = string[i];\n        }\n    }\n    buffer[len] = 0;\n    strcpy(buff, buffer);\n    free(buffer);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tolower)(int);\n\nlong long lc_name_conflict(char *a0, char *a1) {\n  char *v0;        // [bp-0x20]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v7; // eax\n\n  v2 = 0;\n  v1 = strlen(a1);\n  v0 = malloc(v1 + 1);\n  if (!v1) {\n    *(a0) = 0;\n    free(v0);\n    return 0;\n  }\n  for (v3 = 0; v3 < v1; v3 += 1) {\n    v7 = *((short *)(*((long long *)&__ctype_b_loc()) + a1[v3] * 2)) & 0x100;\n    if (v7) {\n      v0[v3] = tolower(a1[v3]);\n      v2 += 1;\n    } else {\n      v0[v3] = a1[v3];\n    }\n  }\n  v0[v1] = 0;\n  strcpy(a0, v0);\n  free(v0);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7xe86jmv/lc_name_conflict.c:37:41: error: cannot take the address of an rvalue of type\n'int' 37 |         v7 = *((short *)(*((long long *)&__ctype_b_loc()) + a1[v3] *\n2)) & 0x100; |                                         ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long long _ds_getcrc64(const char *s) {\n    static unsigned long long CRCTable[256];\n    unsigned long long crc = 0;\n    static int init = 0;\n    if (!init) {\n        int i;\n        init = 1;\n        for (i = 0; i <= 255; i++) {\n            int j;\n            unsigned long long part = i;\n            for (j = 0; j < 8; j++) {\n                if (part & 1)\n                    part = (part >> 1) ^ 15564440312192434176ULL;\n                else\n                    part >>= 1;\n            }\n            CRCTable[i] = part;\n        }\n    }\n    for (; *s; s++) {\n        unsigned long long temp1 = crc >> 8;\n        unsigned long long temp2 = CRCTable[(crc ^ (unsigned long long)*s) & 255];\n        crc = temp1 ^ temp2;\n    }\n    return crc;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4215104];\n  unsigned long long field_405140;\n} struct_0;\n\nextern char CRCTable.0;\nextern unsigned int init.1;\n\nlong long _ds_getcrc64_name_conflict(char *a0) {\n  char *v0;              // [bp-0x40], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x30]\n  unsigned long long v2; // [bp-0x28]\n  struct_0 *v3;          // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v4;       // [bp-0x18]\n  unsigned int v5;       // [bp-0x14]\n  void *v6;              // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v6 = 0;\n  if (!init.1) {\n    init.1 = 1;\n    for (v5 = 0; v5 <= 255; v5 += 1) {\n      v3 = v5;\n      for (v4 = 0; v4 <= 7; v4 += 1) {\n        if (!((char)v3 & 1))\n          v3 >>= 1;\n        else\n          v3 = 0xd800000000000000 ^ v3 >> 1;\n      }\n      *((unsigned long *)&(&CRCTable.0)[8 * v5]) = v3;\n    }\n  }\n  for (; *((char *)v0); v0 += 1) {\n    v2 = v6 >> 8;\n    v1 = *((long long *)&(&CRCTable.0)[8 * (*((char *)v0) ^ v6)]);\n    v6 = v2 ^ v1;\n  }\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:22:21: error: expected ';' after top level\ndeclarator 22 | extern char CRCTable.0; |                     ^ | ;\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:23:25: error: expected ';' after top level\ndeclarator 23 | extern unsigned int init.1; |                         ^ | ;\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:37:14: error: expected ')'\n   37 |     if (!init.1)\n      |              ^\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:37:8: note: to match this '('\n   37 |     if (!init.1)\n      |        ^\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:39:13: error: expected ';' after expression\n   39 |         init.1 = 1;\n      |             ^\n      |             ;\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:39:16: error: expression is not assignable\n   39 |         init.1 = 1;\n      |             ~~ ^\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:46:24: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'int') 46 | v3 >>= 1; |\n~~ ^   ~ /tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:48:50: error: invalid operands to\nbinary expression ('struct_0 *' (aka 'struct struct_0 *') and 'int') 48 | v3 =\n0xd800000000000000 ^ v3 >> 1; |                                               ~~\n^  ~ /tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:50:43: error: expected ')' 50 | *((unsigned\nlong *)&(&CRCTable.0)[8 * v5]) = v3; | ^ /tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:50:33:\nnote: to match this '(' 50 |             *((unsigned long *)&(&CRCTable.0)[8 *\nv5]) = v3; |                                 ^\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:55:17: error: invalid operands to binary\nexpression ('void *' and 'int') 55 |         v2 = v6 >> 8; |              ~~ ^ ~\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:56:40: error: expected ')'\n   56 |         v1 = *((long long *)&(&CRCTable.0)[8 * (*((char *)v0) ^ v6)]);\n      |                                        ^\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:56:30: note: to match this '('\n   56 |         v1 = *((long long *)&(&CRCTable.0)[8 * (*((char *)v0) ^ v6)]);\n      |                              ^\n/tmp/tmpws2sowud/_ds_getcrc64_name_conflict.c:56:63: error: invalid operands to binary\nexpression ('char' and 'void *') 56 |         v1 = *((long long\n*)&(&CRCTable.0)[8 * (*((char *)v0) ^ v6)]); | ~~~~~~~~~~~~~ ^ ~~ 11 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_weight(const char *token) {\n    int complexity = _ds_compute_complexity(token);\n    int sparse = _ds_compute_sparse(token);\n    if (complexity == 5) {\n        if (sparse == 1)\n            return 64;\n        if (sparse == 2)\n            return 16;\n        if (sparse == 3)\n            return 4;\n        if (sparse == 0)\n            return 256;\n    }\n    if (complexity == 4) {\n        if (sparse == 1)\n            return 16;\n        if (sparse == 2)\n            return 4;\n        if (sparse == 0)\n            return 64;\n    }\n    if (complexity == 3) {\n        if (sparse == 1)\n            return 4;\n        if (sparse == 0)\n            return 16;\n    }\n    if (complexity == 2) {\n        if (sparse == 0)\n            return 4;\n    }\n    if (complexity == 1) {\n        if (sparse == 0)\n            return 1;\n    }\n    LOG(4, \"_ds_compute_weight: no rule to compute markovian weight for '%s'; complexity: %d; sparse: %d\", token, complexity, sparse);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_ds_compute_complexity)(long long);\nlong long(_ds_compute_sparse)(long long);\nchar(LOG)(long long, long long, long long, long long, long long, long long);\n\nlong long _ds_compute_weight(unsigned long long a0, unsigned long a1,\n                             unsigned long a2, unsigned long a3,\n                             unsigned long a4, unsigned long long a5) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = _ds_compute_complexity(a0);\n  v0 = _ds_compute_sparse(a0);\n  if (v1 == 5) {\n    if (v0 == 1) {\n      return 64;\n    } else if (v0 == 2) {\n      return 16;\n    } else if (v0 == 3) {\n      return 4;\n    } else if (!v0) {\n      return 0x100;\n    }\n  }\n  if (v1 == 4) {\n    if (v0 == 1) {\n      return 16;\n    } else if (v0 == 2) {\n      return 4;\n    } else if (!v0) {\n      return 64;\n    }\n  }\n  if (v1 == 3) {\n    if (v0 == 1) {\n      return 4;\n    } else if (!v0) {\n      return 16;\n    }\n  }\n  if (v1 == 2 && !v0)\n    return 4;\n  if (v1 == 1 && !v0)\n    return 1;\n  LOG(4,\n      \"_ds_compute_weight: no rule to compute markovian weight for '%s'; \"\n      \"complexity: %d; sparse: %d\",\n      a0, v1, v0, a5);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_sparse(const char *token) {\n    int sparse = 0, i;\n    if (!strncmp(token, \"#+\", 2))\n        sparse++;\n    if (strlen(token) >= 2 && !strncmp((token + strlen(token)) - 2, \"+#\", 2))\n        sparse++;\n    for (i = 0; token[i]; i++) {\n        if (!strncmp(token + i, \"+#+\", 3)) {\n            sparse++;\n            i++;\n        }\n    }\n    return sparse;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _ds_compute_sparse_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  if (!strncmp(a0, \"#+\", 2))\n    v1 += 1;\n  if (strlen(a0) > 1 && !strncmp(&a0[2 + strlen(a0)], \"+#\", 2))\n    v1 += 1;\n  for (v0 = 0; a0[v0]; v0 += 1) {\n    if (!strncmp(&a0[v0], \"+#+\", 3)) {\n      v1 += 1;\n      v0 += 1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_complexity(const char *token) {\n    int i, complexity = 1;\n    if (token == ((void *)0))\n        return 1;\n    for (i = 0; token[i]; i++) {\n        if (token[i] == '+') {\n            complexity++;\n            i++;\n        }\n    }\n    return complexity;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _ds_compute_complexity_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 1;\n  if (!a0)\n    return 1;\n  for (v1 = 0; a0[v1]; v1 += 1) {\n    if (a0[v1] == 43) {\n      v0 += 1;\n      v1 += 1;\n    }\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_extract_address(char *buf, const char *address, size_t len) {\n    char *str = strdup(address);\n    char *x, *y;\n    if (str == ((void *)0))\n        return -2;\n    x = strchr(str, '<');\n    if (!x) {\n        free(str);\n        return -5;\n    }\n    y = strchr(x, '>');\n    if (y)\n        y[0] = 0;\n    strlcpy(buf, x + 1, len);\n    free(str);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(strlcpy)(long long, long long, long long);\n\nlong long _ds_extract_address(unsigned long long a0, char *a1,\n                              unsigned long long a2) {\n  char *v0; // [bp-0x20]\n  char *v1; // [bp-0x18]\n  void *v2; // [bp-0x10]\n\n  v2 = strdup(a1);\n  if (!v2)\n    return 4294967294;\n  v1 = strchr(v2, 60);\n  if (!v1) {\n    free(v2);\n    return 4294967291;\n  }\n  v0 = strchr(v1, 62);\n  if (v0)\n    *(v0) = 0;\n  strlcpy(a0, v1 + 1, a2);\n  free(v2);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_get_fcntl_lock(int fd) {\n    struct flock f;\n    int r;\n    f.l_type = 1;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    signal(14, timeout);\n    alarm(300);\n    r = fcntl(fd, 7, &f);\n    alarm(0);\n    signal(14, ((__sighandler_t)0));\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint timeout; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(alarm)(unsigned int);\nint(fcntl)(int, int, ...);\n\nlong long _ds_get_fcntl_lock_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0x38]\n  unsigned short v1; // [bp-0x36]\n  void *v2;          // [bp-0x30]\n  void *v3;          // [bp-0x28]\n  unsigned int v4;   // [bp-0xc]\n\n  v0 = 1;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  signal(14, timeout);\n  alarm(300);\n  v4 = fcntl(a0, 7);\n  alarm(0);\n  signal(14, 0);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_free_fcntl_lock(int fd) {\n    struct flock f;\n    f.l_type = 2;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    return fcntl(fd, 7, &f);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long _ds_free_fcntl_lock_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0x28]\n  unsigned short v1; // [bp-0x26]\n  void *v2;          // [bp-0x20]\n  void *v3;          // [bp-0x18]\n\n  v0 = 2;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  return fcntl(a0, 7);\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow(int base, unsigned int exp) {\n    int result = 1;\n    while (exp > 0)\n        {\n            if (exp & 1)\n                result *= base;\n            base *= base;\n            exp /= 2;\n        }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _ds_pow_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x20]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0xc]\n\n  v1 = a0;\n  v0 = a1;\n  for (v2 = 1; v0; v0 >>= 1) {\n    if (((char)v0 & 1))\n      v2 = v1 * v2;\n    v1 *= v1;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow2(int exp) {\n    return _ds_pow(2, exp);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_ds_pow)(long long, long long);\n\nlong long _ds_pow2_name_conflict(unsigned long a0) { return _ds_pow(2, (unsigned int)a0); }\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strcasestr(s, find)\n    const char *s;\n    const char *find;\n {\n    char c, sc;\n    size_t len;\n    if ((c = *find++) != 0) {\n        c = tolower((unsigned char)c);\n        len = strlen(find);\n        do {\n            do {\n                if ((sc = *s++) == 0)\n                    return (((void *)0));\n            } while ((char)tolower((unsigned char)sc) != c);\n        } while (strncasecmp(s, find, len) != 0);\n        s--;\n    }\n    return ((char *)s);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tolower)(int);\n\nlong long strcasestr_name_conflict(char *a0, char *a1) {\n  char *v0;        // [bp-0x38]\n  char *v1;        // [bp-0x30], Other Possible Types: unsigned long\n  char v2;         // [bp-0x19]\n  unsigned int v3; // [bp-0x18]\n  char v4;         // [bp-0x9]\n  char *v6;        // rax\n  char *v7;        // rax\n\n  v1 = a0;\n  v0 = a1;\n  v6 = v0;\n  v0 = v6 + 1;\n  v4 = *(v6);\n  if (v4) {\n    v4 = tolower(v4);\n    *((unsigned long *)&v3) = strlen(v0);\n    do {\n      do {\n        v7 = v1;\n        v1 = v7 + 1;\n        v2 = *(v7);\n        if (!v2)\n          return 0;\n      } while (v4 != (char)tolower(v2));\n    } while (strncasecmp(v1, v0, *((long long *)&v3)));\n    v1 -= 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *inet_ntoa_r(struct in_addr in, char *buf, int len) {\n    char b[18];\n    register char *p;\n    p = (char *)&in;\n    snprintf(b, sizeof (b), \"%d.%d.%d.%d\", (((int)p[0]) & 255), (((int)p[1]) & 255), (((int)p[2]) & 255), (((int)p[3]) & 255));\n    if (len <= strlen(b)) {\n        (*__errno_location()) = 34;\n        return (((void *)0));\n    }\n    return strcpy(buf, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\n\nlong long inet_ntoa_r_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x3c]\n  char v1;         // [bp-0x38]\n\n  v0 = a0;\n  snprintf(&v1, 18, \"%d.%d.%d.%d\", (unsigned int)a0, (unsigned int)a0,\n           (unsigned int)a0, (unsigned int)a0);\n  if (strlen(&v1) < (unsigned int)a2)\n    return strcpy(a1, &v1);\n  *(__errno_location()) = 34;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8ngx_bzg/inet_ntoa_r_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp8ngx_bzg/inet_ntoa_r_name_conflict.c:27:5: error: indirection requires pointer operand\n('int' invalid) 27 |     *(__errno_location()) = 34; |     ^~~~~~~~~~~~~~~~~~~~~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(MD5Update)(long long, long long, long long);\n\nlong long hash_file_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;               // [bp-0x1018]\n  unsigned long long v1; // [bp-0x18]\n  void *v2;              // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = 0;\n  while (true) {\n    v1 = read(a1, &v0, 0x1000);\n    if (v1 <= 0)\n      break;\n    MD5Update(a0, &v0, v1);\n    v2 += v1;\n  }\n  v0 = 0;\n  MD5Update(a0, &v0, 1);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/x11r7/mcookie/mcookie.c"}
{"compilable":1,"function":"bool check(const char *word) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long check_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool load(const char *dictionary) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long load_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"unsigned int size(void) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long size_name_conflict() { return 0; }\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool unload(void) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long unload_name_conflict() { return 0; }\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":0,"function":"int open_serial(int k) {\n    if (k == 0) {\n        fd = open(\"/dev/ttyUSB0\", 2 | 256);\n        perror(\"open /dev/ttyUSB0\");\n    } else {\n        fd = open(\"/dev/ttyUSB1\", 2 | 256);\n        perror(\"open /dev/ttyUSB1\");\n    }\n    if (fd == -1)\n        return -1;\n    else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nextern unsigned int fd;\n\nlong long open_serial_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  if (!(unsigned int)a0) {\n    fd = open(\"/dev/ttyUSB0\", 258, a2);\n    perror(\"open /dev/ttyUSB0\");\n  } else {\n    fd = open(\"/dev/ttyUSB1\", 258, a2);\n    perror(\"open /dev/ttyUSB1\");\n  }\n  return (fd == -1 ? 0 : 4294967295);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp5sytmba/open_serial_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":1,"function":"unsigned int calc_crc16(unsigned char *snd, unsigned char num) {\n    unsigned char i, j;\n    unsigned int c, crc = 65535;\n    for (i = 0; i < num; i++) {\n        c = snd[i] & 255;\n        crc ^= c;\n        for (j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc >>= 1;\n                crc ^= 40961;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return (crc);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long calc_crc16_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  char v2;         // [bp-0xa]\n  char v3;         // [bp-0x9]\n\n  v1 = 65535;\n  for (v3 = 0; v3 < (char)a1; v3 += 1) {\n    v0 = a0[v3];\n    v1 ^= v0;\n    for (v2 = 0; v2 <= 7; v2 += 1) {\n      if (((char)v1 & 1)) {\n        v1 >>= 1;\n        v1 ^= 40961;\n      } else {\n        v1 >>= 1;\n      }\n    }\n  }\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":0,"function":"int read(char *name, char *permission) {\n    int buf;\n    FILE *file;\n    file = fopen(name, permission);\n    fread(&buf, sizeof (buf), 1, file);\n    fclose(file);\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread_name_conflict)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_name_conflict_ptr;\n      char *_IO_read_name_conflict_end;\n      char *_IO_read_name_conflict_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_name_conflict_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_name_conflict_ptr;\n        short *_IO_read_name_conflict_end;\n        short *_IO_read_name_conflict_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_name_conflict_ptr;\n  char *_IO_read_name_conflict_end;\n  char *_IO_read_name_conflict_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_name_conflict_ptr;\n  unsigned short *_IO_read_name_conflict_end;\n  unsigned short *_IO_read_name_conflict_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_name_conflict(char *a0, char *a1) {\n  char v0;    // [bp-0x14]\n  FILE_t *v1; // [bp-0x10]\n\n  v1 = &fopen(a0, a1)->_flags;\n  fread_name_conflict(&v0, 4, 1, v1);\n  fclose(v1);\n  return *((int *)&v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwfxofcpv/read_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:16:16: error: conflicting types for 'fread_name_conflict'\n   16 | unsigned long (fread_name_conflict)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread_name_conflict (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:141:16: error: redefinition of '_IO_marker'\n  141 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:147:16: error: redefinition of '_IO_codecvt'\n  147 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:151:16: error: redefinition of '_IO_wide_data'\n  151 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpwfxofcpv/read_name_conflict.c:174:3: error: typedef redefinition with different types\n('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 174 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":0,"function":"int average(int *data, int size) {\n    if (data == ((void *)0) || size == 0) {\n        return 0;\n    }\n    printf(\"size=%d\\n\", sizeof data / sizeof(int));\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long average_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned int v6;       // eax\n\n  v4 = &v2;\n  if (a0 && (unsigned int)a1) {\n    printf(\"size=%d\\n\", 2);\n    v0 = 0;\n    for (v1 = 0; v1 < (unsigned int)a1; v1 += 1) {\n      v0 += a0[v1];\n    }\n    v6 = v0;\n    return (v6 >> 31 CONCAT v6) / m(unsigned int) a1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp576a9bmr/average_name_conflict.c:35:26: error: expected ')'\n   35 |         return (v6 >> 31 CONCAT v6) /m (unsigned int)a1;\n      |                          ^\n/tmp/tmp576a9bmr/average_name_conflict.c:35:16: note: to match this '('\n   35 |         return (v6 >> 31 CONCAT v6) /m (unsigned int)a1;\n      |                ^\n/tmp/tmp576a9bmr/average_name_conflict.c:35:41: error: expected expression\n   35 |         return (v6 >> 31 CONCAT v6) /m (unsigned int)a1;\n      |                                         ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":0,"function":"int average2(int data[], int size) {\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long average2_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n  unsigned int v3; // eax\n\n  v0 = 0;\n  for (v1 = 0; v1 < (unsigned int)a1; v1 += 1) {\n    v0 += a0[v1];\n  }\n  v3 = v0;\n  return (v3 >> 31 CONCAT v3) / m(unsigned int) a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwei40nj0/average2_name_conflict.c:29:22: error: expected ')'\n   29 |     return (v3 >> 31 CONCAT v3) /m (unsigned int)a1;\n      |                      ^\n/tmp/tmpwei40nj0/average2_name_conflict.c:29:12: note: to match this '('\n   29 |     return (v3 >> 31 CONCAT v3) /m (unsigned int)a1;\n      |            ^\n/tmp/tmpwei40nj0/average2_name_conflict.c:29:37: error: expected expression\n   29 |     return (v3 >> 31 CONCAT v3) /m (unsigned int)a1;\n      |                                     ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":0,"function":"char readchar() {\n    while (uartadr[8] & 1)\n        ;\n    return uartadr[4];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint uartadr; // add global variable by heuristics\nint uartadr; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *uartadr;\n\nlong long readchar_name_conflict() {\n  while ((uartadr->field_8 & 1))\n    ;\n  return uartadr->field_4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjlkkurmd/readchar_name_conflict.c:19:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 19 | extern struct_0 *uartadr; |        ^~~~~~~~ |        struct\n/tmp/tmpjlkkurmd/readchar_name_conflict.c:19:8: error: declaration of anonymous struct must be\na definition /tmp/tmpjlkkurmd/readchar_name_conflict.c:23:22: error: member reference type\n'int' is not a pointer 23 |     while ((uartadr->field_8 & 1)) | ~~~~~~~  ^\n/tmp/tmpjlkkurmd/readchar_name_conflict.c:25:21: error: member reference type 'int' is not a\npointer 25 |     return uartadr->field_4; |            ~~~~~~~  ^ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bonfireprocessor_bonfire-soc/riscv/software/cpptest/uart.c"}
{"compilable":0,"function":"_Bool show_cmd_help(int argc, char **argv) {\n    return (argc > 0 && (0 == strcmp(argv[0], \"-h\") || 0 == strcmp(argv[0], \"--help\")));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long show_cmd_help_name_conflict(unsigned long a0, char **a1) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 <= 0 || strcmp(*(a1), \"-h\") && strcmp(*(a1), \"--help\"))\n    v1 = 0;\n  else\n    v1 = 1;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/punch.c"}
{"compilable":0,"function":"int in_cmd(int argc, char **argv) {\n    if (0 == argc) {\n        char *cmd = \"in\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_in = with_open_log_file(argv[0], in_cmd_with_fh);\n    return (0 != did_punch_in);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint in_cmd_name_conflict_with_fh; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(help_cmd)(long long, long long);\nlong long(with_open_log_file)(long long, long long);\n\nlong long in_cmd_name_conflict(unsigned long a0, unsigned long long *a1) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  if (!(unsigned int)a0) {\n    v0 = \"in\";\n    help_cmd(1, &v0);\n    return 64;\n  }\n  v1 = with_open_log_file(*(a1), in_cmd_name_conflict_with_fh);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/in_cmd.c"}
{"compilable":0,"function":"bool ensure_data_dir_exists(void) {\n    char path[4096];\n    get_data_dir(path);\n    struct stat finfo;\n    int success = stat(path, &finfo);\n    if (-1 == success) {\n        if (2 == (*__errno_location())) {\n            success = mkdir(path, 16384 | (256 | 128 | 64) | (256 >> 3));\n            if (-1 == success) {\n                goto fail;\n            }\n        } else {\n            goto fail;\n        }\n    }\n    return 1;\n  fail:\n    fprintf(stderr, \"Error %d (%s) trying to create %s\\n\", (*__errno_location()), edesc((*__errno_location())), path);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_data_dir)(long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(edesc)(long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long ensure_data_dir_exists_name_conflict() {\n  stat v0;          // [bp-0x10b8]\n  char v1;          // [bp-0x1028]\n  unsigned int v2;  // [bp-0x1c]\n  unsigned long v3; // [bp-0x10]\n  unsigned long v5; // rbx\n  unsigned int v9;  // ebx\n\n  v3 = v5;\n  get_data_dir(&v1);\n  v2 = stat(&v1, &v0);\n  if (v2 == -1) {\n    if (*(__errno_location()) != 2) {\n      v9 = edesc(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"Error %d (%s) trying to create %s\\n\",\n              *(__errno_location()), v9, (unsigned int)&v1);\n      return 0;\n    }\n    v2 = mkdir(&v1, 16864);\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:49:3: error: redefinition of 'stat' as\ndifferent kind of symbol 49 | } stat; |   ^\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:17:6: note: previous definition is\nhere 17 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:51:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:51:22: error: expected ';' after top\nlevel declarator 51 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:55:5: error: must use 'struct' tag to\nrefer to type 'stat' 55 |     stat v0;  // [bp-0x10b8] |     ^ |     struct\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:17:6: note: struct 'stat' is hidden by\na non-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:67:13: error: indirection requires\npointer operand ('int' invalid) 67 |         if (*(__errno_location()) != 2) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:69:24: error:\nindirection requires pointer operand ('int' invalid) 69 |             v9 =\nedesc(*(__errno_location())); |                        ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:70:27: error: expected ')'\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"Error %d (%s) trying to create\n%s\\n\", *(__errno_location()), v9, (unsigned int)&v1); | ^\n/tmp/tmpx3c57jk8/ensure_data_dir_exists_name_conflict.c:70:20: note: to match this '('\n   70 |             fprintf(stderr@GLIBC_2.2.5, \"Error %d (%s) trying to create\n%s\\n\", *(__errno_location()), v9, (unsigned int)&v1); |                    ^ 7\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":1,"function":"char *edesc(int err) {\n    switch (err) {\n      case 2:\n        return \"file does not exist\";\n      case 20:\n        return \"is not a directory\";\n      case 13:\n        return \"access denied\";\n      case 9:\n        return \"bad file descriptor\";\n      case 17:\n        return \"the file exists\";\n      case 36:\n        return \"filename too long\";\n      case 30:\n        return \"write access requested on a read-only filesystem\";\n      case 22:\n        return \"flag is invalid\";\n      default:\n        return \"unknown error\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long edesc_name_conflict(unsigned long a0) {\n  switch ((unsigned int)a0) {\n  case 2:\n    return \"file does not exist\";\n  case 9:\n    return \"bad file descriptor\";\n  case 13:\n    return \"access denied\";\n  case 17:\n    return \"the file exists\";\n  case 20:\n    return \"is not a directory\";\n  case 22:\n    return \"flag is invalid\";\n  case 30:\n    return \"write access requested on a read-only filesystem\";\n  case 36:\n    return \"filename too long\";\n  default:\n    return \"unknown error\";\n  }\n}\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":0,"function":"int out_cmd(int argc) {\n    if (argc > 0) {\n        char *cmd = \"out\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_out = with_open_log_file(((void *)0), out_cmd_with_fh);\n    return (0 != did_punch_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint out_cmd_name_conflict_with_fh; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(with_open_log_file)(long long, long long);\nlong long(help_cmd)(long long, long long);\n\nlong long out_cmd_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  if ((unsigned int)a0 > 0) {\n    v0 = \"out\";\n    help_cmd(1, &v0);\n    return 64;\n  }\n  v1 = with_open_log_file(0, out_cmd_name_conflict_with_fh);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/out_cmd.c"}
{"compilable":0,"function":"size_t strfentry_time(char *buf, time_t *t) {\n    struct tm tt;\n    localtime_r(t, &tt);\n    size_t foo = strfiso8601(buf, 26, &tt);\n    return foo;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct tm *(localtime_r)(long *, struct tm {\n    int tm_sec;\n    int tm_min;\n    int tm_hour;\n    int tm_mday;\n    int tm_mon;\n    int tm_year;\n    int tm_wday;\n    int tm_yday;\n    int tm_isdst;\n    long tm_gmtoff;\n    char *tm_zone;\n} *);\nlong long(strfiso8601)(long long, long long, long long);\n\ntypedef struct tm {\n  unsigned int tm_sec;\n  unsigned int tm_min;\n  unsigned int tm_hour;\n  unsigned int tm_mday;\n  unsigned int tm_mon;\n  unsigned int tm_year;\n  unsigned int tm_wday;\n  unsigned int tm_yday;\n  unsigned int tm_isdst;\n  char padding_24[4];\n  unsigned int tm_gmtoff;\n  char padding_2c[4];\n  char *tm_zone;\n} tm;\n\nlong long strfentry_time(unsigned long long a0, unsigned int *a1) {\n  tm v0;            // [bp-0x48]\n  unsigned long v1; // [bp-0x10]\n\n  localtime_r(a1, &v0);\n  v1 = strfiso8601(a0, 26, &v0);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/entry.c"}
{"compilable":0,"function":"int summary_cmd(int argc, char **argv) {\n    t_formatter_fn formatter = print_summary_human;\n    if (argc > 0 && 0 == strncmp(\"--csv\", argv[0], 5)) {\n        formatter = print_summary_csv;\n    }\n    int exit_code = 0;\n    if (isatty(fileno(stdin))) {\n        exit_code = with_open_log_file((void *)formatter, summary_cmd_with_fh);\n    } else {\n        exit_code = summary_cmd_with_fh(stdin, (void *)formatter);\n    }\n    return exit_code;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint print_summary_human; // add global variable by heuristics\nint print_summary_csv;   // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(summary_cmd_name_conflict_with_fh)(long long, long long);\nlong long(with_open_log_file)(long long, long long);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long summary_cmd_name_conflict(unsigned long a0, char **a1) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned long v1; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v1 = print_summary_human;\n  if ((unsigned int)a0 > 0 && !strncmp(\"--csv\", *(a1), 5))\n    v1 = print_summary_csv;\n  v0 = 0;\n  if (!isatty(fileno(stdin @GLIBC_2.2.5))) {\n    v0 = summary_cmd_name_conflict_with_fh(stdin @GLIBC_2.2.5, v1);\n    return v0;\n  }\n  v0 = with_open_log_file(v1, summary_cmd_name_conflict_with_fh);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp27pr0lbr/summary_cmd_name_conflict.c:21:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 21 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp27pr0lbr/summary_cmd_name_conflict.c:21:21: error: expected ';' after top level\ndeclarator 21 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmp27pr0lbr/summary_cmd_name_conflict.c:32:29: error: expected ')'\n   32 |     if (!isatty(fileno(stdin@GLIBC_2.2.5)))\n      |                             ^\n/tmp/tmp27pr0lbr/summary_cmd_name_conflict.c:32:23: note: to match this '('\n   32 |     if (!isatty(fileno(stdin@GLIBC_2.2.5)))\n      |                       ^\n/tmp/tmp27pr0lbr/summary_cmd_name_conflict.c:34:39: error: expected ')'\n   34 |         v0 = summary_cmd_name_conflict_with_fh(stdin@GLIBC_2.2.5, v1);\n      |                                       ^\n/tmp/tmp27pr0lbr/summary_cmd_name_conflict.c:34:33: note: to match this '('\n   34 |         v0 = summary_cmd_name_conflict_with_fh(stdin@GLIBC_2.2.5, v1);\n      |                                 ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/summary_cmd.c"}
{"compilable":0,"function":"static int choose_pivot(int *p, int n) {\n    int *pl, *pm, *pn;\n    int s;\n    pm = p + (n >> 1);\n    if (n > 7) {\n        pl = p;\n        pn = p + n - 1;\n        if (n > 40) {\n            s = n >> 3;\n            pl = ((V[*(pl) + (h)]) < (V[*(pl + s) + (h)]) ? ((V[*(pl + s) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)) : ((V[*(pl + s) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)));\n            pm = ((V[*(pm - s) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) < (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)) : ((V[*(pm) + (h)]) > (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) > (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)));\n            pn = ((V[*(pn - s - s) + (h)]) < (V[*(pn - s) + (h)]) ? ((V[*(pn - s) + (h)]) < (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pn - s - s)) : ((V[*(pn - s) + (h)]) > (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pn - s - s)));\n        }\n        pm = ((V[*(pl) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pl)) : ((V[*(pm) + (h)]) > (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pl)));\n    }\n    return (V[*(pm) + (h)]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long V;\nextern unsigned int h;\n\nlong long choose_pivot_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0;  // [bp-0x24]\n  unsigned int *v1; // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int *v2; // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int *v3; // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = &a0[(unsigned int)a1 >> 1];\n  if ((unsigned int)a1 <= 7)\n    return *((int *)((h + *((int *)v2)) * 4 + V));\n  v3 = a0;\n  v1 = &a0[1 + (unsigned int)a1];\n  if ((unsigned int)a1 > 40) {\n    v0 = (unsigned int)a1 >> 3;\n    *((int *)&v3) =\n        (*((int *)((h + *(v3) << 2) + V)) < *((int *)(V + (h + v3[v0] << 2)))\n             ? (*((int *)(V + (h + v3[v0] << 2))) <=\n                        *((int *)(V + (h + v3[2 * v0] << 2)))\n                    ? &v3[v0]\n                    : (*((int *)((h + *(v3) << 2) + V)) <=\n                               *((int *)(V + (h + v3[2 * v0] << 2)))\n                           ? &v3[2 * v0]\n                           : v3))\n             : (*((int *)(V + (h + v3[v0] << 2))) <\n                        *((int *)(V + (h + v3[2 * v0] << 2)))\n                    ? (*((int *)((h + *(v3) << 2) + V)) <\n                               *((int *)(V + (h + v3[2 * v0] << 2)))\n                           ? v3\n                           : &v3[2 * v0])\n                    : &v3[v0]));\n    *((int *)&v2) =\n        (*((int *)(V + (h + *((int *)((char *)v2 + -(v0 << 2))) << 2))) <\n                 *((int *)((h + *((int *)v2) << 2) + V))\n             ? (*((int *)((h + *((int *)v2) << 2) + V)) <=\n                        *((int *)(V + (h + v2[v0] << 2)))\n                    ? v2\n                    : (*((int *)(V + (h + *((int *)((char *)v2 + -(v0 << 2)))\n                                      << 2))) <=\n                               *((int *)(V + (h + v2[v0] << 2)))\n                           ? &v2[v0]\n                           : (unsigned int *)((char *)v2 + -(v0 * 4))))\n             : (*((int *)((h + *((int *)v2) << 2) + V)) <\n                        *((int *)(V + (h + v2[v0] << 2)))\n                    ? (*((int *)(V + (h + *((int *)((char *)v2 + -(v0 << 2)))\n                                      << 2))) <\n                               *((int *)(V + (h + v2[v0] << 2)))\n                           ? (unsigned int *)((char *)v2 + -(v0 * 4))\n                           : &v2[v0])\n                    : v2));\n    *((int *)&v1) =\n        (*((int *)(V +\n                   (h + *((int *)((char *)v1 + -(v0 << 2) + -4 * v0)) << 2))) <\n                 *((int *)(V + (h + *((int *)((char *)v1 + -(v0 << 2))) << 2)))\n             ? (*((int *)(V + (h + *((int *)((char *)v1 + -(v0 << 2)))\n                               << 2))) <= *((int *)((h + *(v1) << 2) + V))\n                    ? (unsigned int *)((char *)v1 + -(v0 * 4))\n                    : (*((int *)(V + (h + *((int *)((char *)v1 + -(v0 << 2) +\n                                                    -4 * v0))\n                                      << 2))) <=\n                               *((int *)((h + *(v1) << 2) + V))\n                           ? v1\n                           : (unsigned int *)((char *)v1 + -(v0 * 4) +\n                                              -4 * v0)))\n             : (*((int *)(V + (h + *((int *)((char *)v1 + -(v0 << 2))) << 2))) <\n                        *((int *)((h + *(v1) << 2) + V))\n                    ? (*((int *)(V + (h + *((int *)((char *)v1 + -(v0 << 2) +\n                                                    -4 * v0))\n                                      << 2))) < *((int *)((h + *(v1) << 2) + V))\n                           ? (unsigned int *)((char *)v1 + -(v0 * 4) + -4 * v0)\n                           : v1)\n                    : (unsigned int *)((char *)v1 + -(v0 * 4))));\n  }\n  *((int *)&v2) = (*((int *)((h + *(v3) << 2) + V)) <\n                           *((int *)((h + *((int *)v2) << 2) + V))\n                       ? (*((int *)((h + *((int *)v2) << 2) + V)) <=\n                                  *((int *)((h + *(v1) << 2) + V))\n                              ? v2\n                              : (*((int *)((h + *(v3) << 2) + V)) <=\n                                         *((int *)((h + *(v1) << 2) + V))\n                                     ? v1\n                                     : v3))\n                       : (*((int *)((h + *((int *)v2) << 2) + V)) <\n                                  *((int *)((h + *(v1) << 2) + V))\n                              ? (*((int *)((h + *(v3) << 2) + V)) <\n                                         *((int *)((h + *(v1) << 2) + V))\n                                     ? v3\n                                     : v1)\n                              : v2));\n  return *((int *)((h + *((int *)v2)) * 4 + V));\n}\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":1,"function":"static int transform(int *x, int *p, int n, int k, int l, int q) {\n    int b, c, d, e, i, j, m, s;\n    int *pi, *pj;\n    for (s = 0 , i = k - l; i; i >>= 1)\n        ++s;\n    e = 2147483647 >> s;\n    for (b = d = r = 0; r < n && d <= e && (c = d << s | (k - l)) <= q; ++r) {\n        b = b << s | (x[r] - l + 1);\n        d = c;\n    }\n    m = (1 << (r - 1) * s) - 1;\n    x[n] = l - 1;\n    if (d <= n) {\n        for (pi = p; pi <= p + d; ++pi)\n            *pi = 0;\n        for (pi = x + r , c = b; pi <= x + n; ++pi) {\n            p[c] = 1;\n            c = (c & m) << s | (*pi - l + 1);\n        }\n        for (i = 1; i < r; ++i) {\n            p[c] = 1;\n            c = (c & m) << s;\n        }\n        for (pi = p , j = 1; pi <= p + d; ++pi)\n            if (*pi)\n                *pi = j++;\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = p[c];\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = p[c];\n                c = (c & m) << s;\n            }\n    } else {\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = c;\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = c;\n                c = (c & m) << s;\n            }\n        j = d + 1;\n    }\n    x[n] = 0;\n    return j;\n}\n","function_prediction":"int gcd_division(int a, int b) {\n  int r;\n  while (b != 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}","pass":1,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int vcblocksortCompress(int level, const unsigned char *data, size_t avail_in, unsigned char *odata, size_t *avail_out) {\n    double result;\n    struct BlockSortCompressionInstance *bsci;\n    bsci = calloc(sizeof (*bsci), 1);\n    resetStatistics(bsci);\n    result = bs_compress(bsci, (unsigned char *)data, avail_in);\n    freeBSCI(bsci);\n    *avail_out = (int)result;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(resetStatistics)(long long);\ndouble(bs_compress)(long long, long long, long long);\nlong long(freeBSCI)(long long);\n\nlong long vcblocksortCompress(unsigned long a0, unsigned long long a1,\n                              unsigned long long a2, unsigned long a3,\n                              unsigned long long *a4) {\n  unsigned long v0;      // [bp-0x38]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long long v2; // [bp-0x10]\n  unsigned long v4;      // xmm0lq\n\n  v1 = a0;\n  v0 = a3;\n  v2 = calloc(1064, 1);\n  resetStatistics(v2);\n  bs_compress(v2, a1, a2);\n  freeBSCI(v2);\n  *(a4) = v4;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int smaz_compress(const unsigned char *in, size_t inlen, unsigned char *out, size_t outlen) {\n    unsigned int h1, h2, h3 = 0;\n    int verblen = 0, _outlen = outlen;\n    unsigned char verb[256], *_out = out;\n    while (inlen)\n        {\n            int j = 7, needed;\n            unsigned char *flush = ((void *)0);\n            char *slot;\n            h1 = h2 = in[0] << 3;\n            if (inlen > 1)\n                h2 += in[1];\n            if (inlen > 2)\n                h3 = h2 ^ in[2];\n            if (j > inlen)\n                j = inlen;\n            for (; j > 0; j--) {\n                switch (j) {\n                  case 1:\n                    slot = Smaz_cb[h1 % 241];\n                    break;\n                  case 2:\n                    slot = Smaz_cb[h2 % 241];\n                    break;\n                  default:\n                    slot = Smaz_cb[h3 % 241];\n                    break;\n                }\n                while (slot[0])\n                    {\n                        if (slot[0] == j && memcmp(slot + 1, in, j) == 0) {\n                            if (verblen) {\n                                needed = (verblen == 1) ? 2 : 2 + verblen;\n                                flush = out;\n                                out += needed;\n                                outlen -= needed;\n                            }\n                            if (outlen <= 0)\n                                return _outlen + 1;\n                            out[0] = slot[slot[0] + 1];\n                            out++;\n                            outlen--;\n                            inlen -= j;\n                            in += j;\n                            goto out;\n                        } else {\n                            slot += slot[0] + 2;\n                        }\n                    }\n            }\n            verb[verblen] = in[0];\n            verblen++;\n            inlen--;\n            in++;\n          out:\n            if (!flush && (verblen == 256 || (verblen > 0 && inlen == 0))) {\n                needed = (verblen == 1) ? 2 : 2 + verblen;\n                flush = out;\n                out += needed;\n                outlen -= needed;\n                if (outlen < 0)\n                    return _outlen + 1;\n            }\n            if (flush) {\n                if (verblen == 1) {\n                    flush[0] = (signed char)254;\n                    flush[1] = verb[0];\n                } else {\n                    flush[0] = (signed char)255;\n                    flush[1] = (signed char)(verblen - 1);\n                    memcpy(flush + 2, verb, verblen);\n                }\n                flush = ((void *)0);\n                verblen = 0;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char Smaz_cb;\n\nlong long smaz_compress(char a0[3], unsigned long a1, char a2[2],\n                        unsigned long a3) {\n  unsigned long v0; // [bp-0x168]\n  char v1[2];       // [bp-0x160], Other Possible Types: unsigned long\n  unsigned long v2; // [bp-0x158]\n  char v3[3];       // [bp-0x150], Other Possible Types: unsigned long\n  char v4;          // [bp-0x148]\n  unsigned int v5;  // [bp-0x40]\n  unsigned int v6;  // [bp-0x3c]\n  char v7[2];       // [bp-0x38]\n  unsigned int v8;  // [bp-0x2c]\n  char *v9;         // [bp-0x28], Other Possible Types: unsigned long\n  char v10[2];      // [bp-0x20], Other Possible Types: unsigned long, void*\n  unsigned int v11; // [bp-0x18]\n  unsigned int v12; // [bp-0x14]\n  unsigned int v13; // [bp-0x10]\n  unsigned int v14; // [bp-0xc]\n\n  *(&v3) = a0;\n  v2 = a1;\n  *(&v1) = a2;\n  v0 = a3;\n  v13 = 0;\n  v12 = 0;\n  v8 = v0;\n  *(&v7) = v1;\n  while (true) {\n    do {\n      if (!v2)\n        return v1 - (char *)v7;\n      v11 = 7;\n      *((long long *)&v10) = 0;\n      v14 = *((char *)v3) * 8;\n      v6 = v14;\n      if (v2 > 1)\n        v14 += *((char *)(v3 + 1));\n      if (v2 > 2)\n        v13 = *((char *)(v3 + 2)) ^ v14;\n      if (v2 < v11)\n        v11 = v2;\n      while (true) {\n        if (v11 <= 0) {\n          (&v4)[v12] = v3[0];\n          v12 += 1;\n          v2 -= 1;\n          v3 += 1;\n          break;\n        } else {\n          if (v11 == 1) {\n            v9 = *((long long *)&(\n                &Smaz_cb)[8 * v6 + -1928 * (v6 * 285143057 >> 36)]);\n          } else if (v11 != 2) {\n            v9 = *((long long *)&(\n                &Smaz_cb)[8 * v13 + -1928 * (v13 * 285143057 >> 36)]);\n          } else {\n            v9 = *((long long *)&(\n                &Smaz_cb)[8 * v14 + -1928 * (v14 * 285143057 >> 36)]);\n          }\n          if (!*((char *)v9)) {\n            v11 -= 1;\n          } else if (!(v11 != *((char *)v9)) && !(memcmp(v9 + 1, v3, v11))) {\n            if (v12) {\n              v5 = (v12 == 1 ? v12 + 2 : 2);\n              *(&v10) = v1;\n              v1 = &v1[v5];\n              v0 -= v5;\n            }\n            if (!v0)\n              return v8 + 1;\n            *((char *)v1) = *((char *)(v9 + *((char *)v9) + 1));\n            v1 += 1;\n            v0 -= 1;\n            v2 -= v11;\n            v3 = &v3[v11];\n            break;\n          } else {\n            v9 += *((char *)v9) + 2;\n          }\n        }\n      }\n      if (!v10 && (v12 == 0x100 || v12 > 0 && !v2)) {\n        v5 = (v12 == 1 ? v12 + 2 : 2);\n        v10 = v1;\n        v1 = &v1[v5];\n        v0 -= v5;\n      }\n    } while (!v10);\n    if (v12 == 1) {\n      *((char *)v10) = 254;\n      *((char *)(v10 + 1)) = v4;\n    } else {\n      *((char *)v10) = 255;\n      *((char *)(v10 + 1)) = v12 - 1;\n      memcpy(v10 + 2, &v4, v12);\n    }\n    v10 = 0;\n    v12 = 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa6w4ju3g/smaz_compress.c:37:12: error: array type 'char[3]' is not\nassignable 37 |     *(&v3) = a0; |     ~~~~~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:39:12: error: array type 'char[2]' is not\nassignable 39 |     *(&v1) = a2; |     ~~~~~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:44:12: error: array type 'char[2]' is not\nassignable 44 |     *(&v7) = v1; |     ~~~~~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:68:24: error: invalid operands to binary\nexpression ('char[3]' and 'int') 68 |                     v3 += 1; | ~~ ^  ~\n/tmp/tmpa6w4ju3g/smaz_compress.c:94:37: error: array type 'char[2]' is not\nassignable 94 |                             *(&v10) = v1; | ~~~~~~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:95:32: error: array type 'char[2]' is not\nassignable 95 |                             v1 = &v1[v5]; | ~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:101:28: error: invalid operands to binary\nexpression ('char[2]' and 'int') 101 |                         v1 += 1; | ~~ ^ ~\n/tmp/tmpa6w4ju3g/smaz_compress.c:104:28: error: array type 'char[3]' is not\nassignable 104 |                         v3 = &v3[v11]; | ~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:116:21: error: array type 'char[2]' is not\nassignable 116 |                 v10 = v1; |                 ~~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:117:20: error: array type 'char[2]' is not\nassignable 117 |                 v1 = &v1[v5]; |                 ~~ ^\n/tmp/tmpa6w4ju3g/smaz_compress.c:132:13: error: array type 'char[2]' is not\nassignable 132 |         v10 = 0; |         ~~~ ^ 11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"int sCompress(int level, const unsigned char *in, size_t inlen, unsigned char *out, size_t *outlen) {\n    int res = smaz_compress(in, inlen, out, *outlen);\n    *outlen = res;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(smaz_compress)(long long, long long, long long, long long);\n\nlong long sCompress(unsigned long a0, unsigned long long a1,\n                    unsigned long long a2, unsigned long long a3,\n                    unsigned long long *a4) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0;\n  v1 = smaz_compress(a1, a2, a3, *(a4));\n  *(a4) = v1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"int smaz_decompress(char *in, int inlen, char *out, int outlen) {\n    unsigned char *c = (unsigned char *)in;\n    char *_out = out;\n    int _outlen = outlen;\n    while (inlen)\n        {\n            if (*c == 254) {\n                if (outlen < 1)\n                    return _outlen + 1;\n                *out = *(c + 1);\n                out++;\n                outlen--;\n                c += 2;\n                inlen -= 2;\n            } else if (*c == 255) {\n                int len = (*(c + 1)) + 1;\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, c + 2, len);\n                out += len;\n                outlen -= len;\n                c += 2 + len;\n                inlen -= 2 + len;\n            } else {\n                char *s = Smaz_rcb[*c];\n                int len = strlen(s);\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, s, len);\n                out += len;\n                outlen -= len;\n                c++;\n                inlen--;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char Smaz_rcb;\n\nlong long smaz_decompress(char a0[2], unsigned long a1, char *a2,\n                          unsigned long a3) {\n  char *v0;        // [bp-0x50], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0x48]\n  unsigned int v2; // [bp-0x44]\n  unsigned int v3; // [bp-0x30]\n  unsigned int v4; // [bp-0x2c]\n  void *v5;        // [bp-0x28]\n  unsigned int v6; // [bp-0x1c]\n  char *v7;        // [bp-0x18]\n  char v8[2];      // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = a1;\n  v0 = a2;\n  v1 = a3;\n  *(&v8) = a0;\n  v7 = v0;\n  v6 = v1;\n  while (true) {\n    if (!v2) {\n      return v0 - v7;\n    } else if (v8[0] != 254) {\n      if (v8[0] == 255) {\n        v3 = v8[1] + 1;\n        if (v1 < v3)\n          return v6 + 1;\n        memcpy(v0, v8 + 1, v3);\n        v0 += v3;\n        v1 -= v3;\n        v8 = &v8[1 + v3];\n        v2 -= v3 + 2;\n      } else {\n        v5 = *((long long *)&(&Smaz_rcb)[8 * v8[0]]);\n        v4 = strlen(v5);\n        if (v1 < v4)\n          return v6 + 1;\n        memcpy(v0, v5, v4);\n        v0 += v4;\n        v1 -= v4;\n        v8 = &v8[1];\n        v2 -= 1;\n      }\n    } else {\n      if (v1 > 0) {\n        *((char *)v0) = v8[1];\n        v0 += 1;\n        v1 -= 1;\n        v8 += 1;\n        v2 -= 2;\n      } else {\n        return v6 + 1;\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4cnqf117/smaz_decompress.c:34:12: error: array type 'char[2]' is not\nassignable 34 |     *(&v8) = a0; |     ~~~~~~ ^\n/tmp/tmp4cnqf117/smaz_decompress.c:53:20: error: array type 'char[2]' is not\nassignable 53 |                 v8 = &v8[1 + v3]; |                 ~~ ^\n/tmp/tmp4cnqf117/smaz_decompress.c:65:20: error: array type 'char[2]' is not\nassignable 65 |                 v8 = &v8[1]; |                 ~~ ^\n/tmp/tmp4cnqf117/smaz_decompress.c:76:20: error: invalid operands to binary\nexpression ('char[2]' and 'int') 76 |                 v8 += 1; | ~~ ^  ~ 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"long rand() {\n    _lastRand = _lastRand * 71762886081639153L;\n    return _lastRand;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long _lastRand;\n\nlong long rand_name_conflict() {\n  _lastRand = 71762886081639153 * _lastRand;\n  return _lastRand;\n}\n","pass":0,"source_file":"C_COMPILE/zma_cc0/src/toolchain/test/srad.c"}
{"compilable":0,"function":"long rand_long() {\n    int lower_32bit, upper_32bit;\n    long rand_long;\n    lower_32bit = rand();\n    upper_32bit = rand();\n    return (((long)upper_32bit << 32) + lower_32bit);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long rand_long_name_conflict() {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = rand();\n  v0 = rand();\n  return v1 + v0 * 0x100000000;\n}\n","pass":0,"source_file":"C_COMPILE/zma_cc0/apps/kmeans/input-generator/gen-input.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isAlphanum_name_conflict(unsigned long a0) {\n  if (((unsigned int)a0 <= 96 || (unsigned int)a0 > 122) &&\n      ((unsigned int)a0 <= 47 || (unsigned int)a0 > 57) &&\n      ((unsigned int)a0 <= 64 || (unsigned int)a0 > 90) &&\n      (unsigned int)a0 != 95 && (unsigned int)a0 != 36 &&\n      (unsigned int)a0 != 92 && (unsigned int)a0 <= 126)\n    return 0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\nextern unsigned int theLookahead;\n\nlong long get() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = theLookahead;\n  theLookahead = -1;\n  if (v0 == -1)\n    v0 = getc(stdin @GLIBC_2.2.5);\n  if (v0 <= 31 && v0 != 10 && v0 != -1)\n    return (v0 == 13 ? 32 : 10);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg5rt1zdz/get.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpg5rt1zdz/get.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpg5rt1zdz/get.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpg5rt1zdz/get.c:76:22: error: type name requires a specifier or qualifier\n   76 |             } __value;\n      |                      ^\n/tmp/tmpg5rt1zdz/get.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpg5rt1zdz/get.c:83:22: error: type name requires a specifier or qualifier\n   83 |             } __value;\n      |                      ^\n/tmp/tmpg5rt1zdz/get.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpg5rt1zdz/get.c:106:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpg5rt1zdz/get.c:106:21: error: expected ';' after top level declarator\n  106 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmpg5rt1zdz/get.c:116:24: error: expected ')'\n  116 |         v0 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpg5rt1zdz/get.c:116:18: note: to match this '('\n  116 |         v0 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get)();\n\nextern unsigned int theLookahead;\n\nlong long peek_name_conflict() {\n  theLookahead = get();\n  return theLookahead;\n}\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get)();\nlong long(peek)();\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long next_name_conflict() {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n  unsigned long long v4; // rax\n\n  v0 = get();\n  if (v0 != 47)\n    return v0;\n  (unsigned int)v2 = peek();\n  if ((unsigned int)v2 == 42) {\n    get();\n    while (true) {\n      do {\n        (unsigned int)v4 = get();\n        if ((unsigned int)v4 == -1) {\n          fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35,\n                 stderr @GLIBC_2.2.5);\n          exit(1); /* do not return */\n        }\n      } while ((unsigned int)v4 != 42);\n      if ((int)peek() == 47)\n        break;\n    }\n    get();\n    return 32;\n  } else if ((unsigned int)v2 == 47) {\n    do {\n      v0 = get();\n    } while (v0 > 10);\n    return v0;\n  } else {\n    return v0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaqw7y5r2/next_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpaqw7y5r2/next_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpaqw7y5r2/next_name_conflict.c:30:5: error: assignment to cast is illegal, lvalue casts\nare not supported 30 |     (unsigned int)v2 = peek(); |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpaqw7y5r2/next_name_conflict.c:38:17: error: assignment to cast is illegal, lvalue\ncasts are not supported 38 |                 (unsigned int)v4 = get(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpaqw7y5r2/next_name_conflict.c:41:81: error: expected ')' 41 |\nfwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpaqw7y5r2/next_name_conflict.c:41:27: note: to match this '('\n   41 |                     fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1,\n35, stderr@GLIBC_2.2.5); |                           ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"unsigned short CheckSum(unsigned short *ptr, int nbytes) {\n    register long sum;\n    unsigned short oddbyte;\n    register short answer;\n    sum = 0;\n    while (nbytes > 1)\n        {\n            sum += *ptr++;\n            nbytes -= 2;\n        }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n    sum = (sum >> 16) + (sum & 65535);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n    return (answer);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long CheckSum_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x2c]\n  char *v1;               // [bp-0x28], Other Possible Types: unsigned long\n  unsigned short v2;      // [bp-0x12], Other Possible Types: char\n  unsigned long v3;       // [bp-0x10]\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n  unsigned long v7;       // rbx\n  void *v8;               // rbx, Other Possible Types: unsigned long\n  char *v9;               // rax\n  unsigned long long v11; // rax\n\n  v6 = &v4;\n  v3 = v7;\n  v1 = a0;\n  v0 = a1;\n  for (v8 = 0; v0 > 1; v0 -= 2) {\n    v9 = v1;\n    v1 = v9 + 2;\n    v8 += *((short *)&v9);\n  }\n  if (v0 == 1) {\n    v2 = 0;\n    v2 = *((char *)v1);\n    v8 += v2;\n  }\n  v11 = ~((unsigned int)((v8 >> 16) + (unsigned short)v8 +\n                         ((v8 >> 16) + (unsigned short)v8 >> 16)));\n  return v11;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu900dayb/CheckSum_name_conflict.c:46:32: error: invalid operands to binary expression\n('void *' and 'int') 46 |     v11 = ~((unsigned int)((v8 >> 16) + (unsigned\nshort)v8 + ((v8 >> 16) + (unsigned short)v8 >> 16))); | ~~ ^  ~~\n/tmp/tmpu900dayb/CheckSum_name_conflict.c:46:67: error: invalid operands to binary expression\n('void *' and 'int') 46 |     v11 = ~((unsigned int)((v8 >> 16) + (unsigned\nshort)v8 + ((v8 >> 16) + (unsigned short)v8 >> 16))); | ~~ ^  ~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/2dango_Custom-UDP-packet/udp.c"}
{"compilable":1,"function":"size_t encode_string(char *dest, const char *src) {\n    char *start = dest, c;\n    while ((c = *(src++)))\n        {\n            switch (c) {\n              case '\\n':\n                *(dest++) = '\\\\';\n                *(dest++) = 'n';\n                break;\n              case '\\\\':\n                *(dest++) = '\\\\';\n                *(dest++) = '\\\\';\n                break;\n              case ':':\n                *(dest++) = '\\\\';\n              default:\n                *(dest++) = c;\n            }\n        }\n    *dest = '\\x00';\n    return dest - start;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long encode_string_name_conflict(char *a0, char *a1) {\n  char *v0;        // [bp-0x28], Other Possible Types: unsigned long\n  char *v1;        // [bp-0x20], Other Possible Types: unsigned long\n  char v2;         // [bp-0x11]\n  char *v3;        // [bp-0x10]\n  char *v5;        // rax\n  unsigned int v6; // eax\n  char *v7;        // rax\n  char *v8;        // rax\n  char *v9;        // rax\n  char *v10;       // rax\n  char *v11;       // rax\n  char *v12;       // rax\n\n  v1 = a0;\n  v0 = a1;\n  v3 = v1;\n  while (true) {\n    v5 = v0;\n    v0 = v5 + 1;\n    v2 = *(v5);\n    if (!v2)\n      break;\n    v6 = v2;\n    if (v6 == 92) {\n      v7 = v1;\n      v1 = v7 + 1;\n      *(v7) = 92;\n      v8 = v1;\n      v1 = v8 + 1;\n      *(v8) = 92;\n    } else {\n      if (v6 <= 92) {\n        if (v6 == 10) {\n          v9 = v1;\n          v1 = v9 + 1;\n          *(v9) = 92;\n          v10 = v1;\n          v1 = v10 + 1;\n          *(v10) = 110;\n          continue;\n        } else if (v6 == 58) {\n          v11 = v1;\n          v1 = v11 + 1;\n          *(v11) = 92;\n        }\n      }\n      v12 = v1;\n      v1 = v12 + 1;\n      *(v12) = v2;\n    }\n  }\n  *((char *)v1) = 0;\n  return v1 - v3;\n}\n","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/DSV.c"}
{"compilable":1,"function":"static inline unsigned int digits(unsigned int n) {\n    return n ? 1 + digits(n / 10) : n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(digits_name_conflict)(unsigned long);\n\nlong long digits_name_conflict(unsigned long a0) {\n  return (!(unsigned int)a0\n              ? (int)digits_name_conflict((unsigned int)a0 * 3435973837 >> 35) + 1\n              : (unsigned int)a0);\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/redo.c"}
{"compilable":0,"function":"static char **parse_shebang(char *target, char *doscript, char *temp_output) {\n    FILE *fp = fopen(doscript, \"rb\");\n    if (!fp)\n        die_(\"(build.c:137): redo: failed to open %s: %s\\n\", doscript, strerror((*__errno_location())));\n    char *buf = xmalloc(1024);\n    buf[fread(buf, 1, 1023, fp)] = '\\x00';\n    if (ferror(fp))\n        die_(\"(build.c:141): redo: failed to read from %s: %s\\n\", doscript, strerror((*__errno_location())));\n    fclose(fp);\n    char **argv;\n    size_t i = 0;\n    if (buf[0] == '#' && buf[1] == '!') {\n        argv = parsecmd(&buf[2], &i, 5);\n    } else {\n        argv = xmalloc(7 * sizeof(char *));\n        argv[i++] = \"/bin/sh\";\n        argv[i++] = \"-e\";\n    }\n    argv[i++] = doscript;\n    argv[i++] = target;\n    char *__xpg_basename = remove_ext(target);\n    argv[i++] = __xpg_basename;\n    argv[i++] = temp_output;\n    argv[i] = ((void *)0);\n    return argv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strerror)(int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(die_)(...);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(parsecmd)(long long, long long, long long);\nlong long(remove_ext)(long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long parse_shebang(unsigned long long a0, char *a1, unsigned long a2) {\n  unsigned long long *v0; // [bp-0x30], Other Possible Types: unsigned long\n  unsigned long v1;       // [bp-0x28]\n  char v2[2];             // [bp-0x20]\n  FILE_t *v3;             // [bp-0x18]\n  unsigned long long *v4; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long v8;       // rax\n  unsigned long v9;       // rax\n  unsigned long v10;      // rax\n  unsigned long v11;      // rax\n  unsigned long v12;      // rax\n  unsigned long v13;      // rax\n\n  v3 = &fopen(a1, \"rb\")->_flags;\n  if (!v3) {\n    strerror(*(__errno_location()));\n    die_(); /* do not return */\n  }\n  *((long long *)&v2) = xmalloc(0x400);\n  v2[fread(v2, 1, 1023, v3)] = 0;\n  if (ferror(v3)) {\n    strerror(*(__errno_location()));\n    die_(); /* do not return */\n  }\n  fclose(v3);\n  v0 = 0;\n  if (v2[0] != 35 || v2[1] != 33) {\n    v4 = xmalloc(56);\n    v8 = v0;\n    v0 = v8 + 1;\n    *((char **)(v4 + v8 * 8)) = \"/bin/sh\";\n    v9 = v0;\n    v0 = v9 + 1;\n    *((char **)(v4 + v9 * 8)) = \"-e\";\n  } else {\n    v4 = parsecmd(v2 + 1, &v0, 5);\n  }\n  v10 = v0;\n  v0 = v10 + 1;\n  *((char **)(v10 * 8 + v4)) = a1;\n  v11 = v0;\n  v0 = v11 + 1;\n  *((unsigned long long *)(v11 * 8 + v4)) = a0;\n  v1 = remove_ext(a0);\n  v12 = v0;\n  v0 = v12 + 1;\n  *((unsigned long *)(v12 * 8 + v4)) = v1;\n  v13 = v0;\n  v0 = v13 + 1;\n  *((unsigned long *)(v13 * 8 + v4)) = a2;\n  *((long long *)(v4 + v0 * 8)) = 0;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgu6zvivc/parse_shebang.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpgu6zvivc/parse_shebang.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpgu6zvivc/parse_shebang.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpgu6zvivc/parse_shebang.c:78:22: error: type name requires a specifier or\nqualifier 78 |             } __value; |                      ^\n/tmp/tmpgu6zvivc/parse_shebang.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpgu6zvivc/parse_shebang.c:85:22: error: type name requires a specifier or\nqualifier 85 |             } __value; |                      ^\n/tmp/tmpgu6zvivc/parse_shebang.c:18:16: error: conflicting types for 'fread'\n   18 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpgu6zvivc/parse_shebang.c:107:18: error: ISO C requires a named parameter\nbefore '...' 107 | long long (die_)(...); |                  ^\n/tmp/tmpgu6zvivc/parse_shebang.c:165:13: error: declaration of anonymous union\nmust be a definition 165 |             union <anon> { |             ^\n/tmp/tmpgu6zvivc/parse_shebang.c:168:22: error: type name requires a specifier\nor qualifier 168 |             } __value; |                      ^\n/tmp/tmpgu6zvivc/parse_shebang.c:172:13: error: declaration of anonymous union\nmust be a definition 172 |             union <anon> { |             ^\n/tmp/tmpgu6zvivc/parse_shebang.c:175:22: error: type name requires a specifier\nor qualifier 175 |             } __value; |                      ^\n/tmp/tmpgu6zvivc/parse_shebang.c:108:6: error: conflicting types for 'ferror'\n  108 | int (ferror)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:790:12: note: previous declaration is here\n  790 | extern int ferror (FILE *__stream) __THROW __wur;\n      |            ^\n/tmp/tmpgu6zvivc/parse_shebang.c:235:16: error: redefinition of '_IO_marker'\n  235 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpgu6zvivc/parse_shebang.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpgu6zvivc/parse_shebang.c:241:16: error: redefinition of '_IO_codecvt'\n  241 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpgu6zvivc/parse_shebang.c:53:12: note: previous definition is here\n   53 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpgu6zvivc/parse_shebang.c:245:16: error: redefinition of '_IO_wide_data'\n  245 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpgu6zvivc/parse_shebang.c:61:12: note: previous definition is here\n   61 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpgu6zvivc/parse_shebang.c:268:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 268 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpgu6zvivc/parse_shebang.c:287:18: error: indirection requires pointer\noperand ('int' invalid) 287 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpgu6zvivc/parse_shebang.c:294:18: error:\nindirection requires pointer operand ('int' invalid) 294 |\nstrerror(*(__errno_location())); |                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgu6zvivc/parse_shebang.c:326:29: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 326 |     *((long long *)(v4 + v0\n* 8)) = 0; |                          ~~ ^ ~ 19 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char **parsecmd(char *cmd, size_t *i, size_t keep_free) {\n    size_t argv_len = 16;\n    char **argv = xmalloc(argv_len * sizeof(char *));\n    size_t j = 0;\n    bool prev_space = 1;\n    for (;; ++j) {\n        switch (cmd[j]) {\n          case ' ':\n            cmd[j] = '\\x00';\n            prev_space = 1;\n            break;\n          case '\\n':\n          case '\\r':\n            cmd[j] = '\\x00';\n          case '\\x00':\n            return argv;\n          default:\n            if (!prev_space)\n                break;\n            while (*i + keep_free >= argv_len)\n                {\n                    argv_len *= 2;\n                    argv = xrealloc(argv, argv_len * sizeof(char *));\n                }\n            prev_space = 0;\n            argv[*i] = &cmd[j];\n            ++*i;\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\n\nlong long parsecmd_name_conflict(unsigned long a0, unsigned long long *a1, unsigned long a2) {\n  unsigned long long *v0; // [bp-0x38]\n  char v1;                // [bp-0x21]\n  char *v2;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long *v3; // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long v4;       // [bp-0x10], Other Possible Types: unsigned long long\n  unsigned int v6;        // eax\n\n  v0 = a1;\n  v4 = 16;\n  v3 = xmalloc(v4 * 8);\n  v2 = 0;\n  v1 = 1;\n  while (true) {\n    v6 = v2[a0];\n    if (v6 == 32) {\n      v2[a0] = 0;\n      v1 = 1;\n    } else {\n      if (v6 <= 32) {\n        if (v6 == 13)\n          break;\n        if (v6 <= 13) {\n          if (!v6)\n            return v3;\n          if (v6 == 10)\n            break;\n        }\n      }\n      if (!(char)(v1 ^ 1)) {\n        for (; a2 + *(a1) >= v4; v3 = xrealloc(v3, v4 * 8)) {\n          v4 *= 2;\n        }\n        v1 = 0;\n        *((char **)(v3 + *(a1) * 8)) = &v2[a0];\n        *(a1) = *(a1) + 1;\n      }\n    }\n    v2 += 1;\n  }\n  v2[a0] = 0;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *xrealpath(const char *path) {\n    char *dirc = xstrdup(path);\n    char *dname = dirname(dirc);\n    char *absdir = realpath(dname, ((void *)0));\n    char *abstarget = ((void *)0);\n    if (absdir)\n        abstarget = concat(3, absdir, \"/\", xbasename(path));\n    free(dirc);\n    free(absdir);\n    return abstarget;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\nchar *(dirname)(char *);\nchar *(realpath)(char *, char *);\nlong long(xbasename)(long long);\nlong long(concat)(...);\n\nlong long xrealpath_name_conflict(unsigned long long a0) {\n  void *v0; // [bp-0x28]\n  char *v1; // [bp-0x20]\n  void *v2; // [bp-0x18]\n  void *v3; // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = xstrdup(a0);\n  v1 = dirname(v2);\n  v0 = realpath(v1, NULL);\n  v3 = 0;\n  if (v0) {\n    xbasename(a0);\n    v3 = concat();\n  }\n  free(v2);\n  free(v0);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpylcbmfm1/xrealpath_name_conflict.c:20:20: error: ISO C requires a named parameter\nbefore '...' 20 | long long (concat)(...); |                    ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *get_relpath(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *abstarget = xrealpath(target);\n    if (!abstarget)\n        return ((void *)0);\n    char *path = xstrdup(relpath(abstarget, root));\n    free(abstarget);\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nlong long(xrealpath)(long long);\nlong long(relpath)(long long, long long);\nlong long(xstrdup)(long long);\n\nlong long get_relpath_name_conflict(unsigned long long a0) {\n  unsigned long v0;      // [bp-0x20]\n  void *v1;              // [bp-0x18]\n  unsigned long long v2; // [bp-0x10]\n\n  v2 = getenv(\"REDO_ROOT\");\n  v1 = xrealpath(a0);\n  if (!v1)\n    return 0;\n  v0 = xstrdup(relpath(v1, v2));\n  free(v1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *get_dep_path(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *dep_path;\n    char *reltarget = get_relpath(target);\n    if (!reltarget)\n        return ((void *)0);\n    char *redodir = is_absolute(reltarget) ? \"/.redo/abs/\" : \"/.redo/rel/\";\n    dep_path = concat(3, root, redodir, reltarget);\n    mkpath(dep_path, 493);\n    free(reltarget);\n    return dep_path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nlong long(get_relpath)(long long);\nlong long(is_absolute)(long long);\nlong long(concat)(...);\nlong long(mkpath)(long long, long long);\n\nlong long get_dep_path_name_conflict(unsigned long long a0) {\n  unsigned long long v0; // [bp-0x28]\n  unsigned long v1;      // [bp-0x20]\n  void *v2;              // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n\n  v3 = getenv(\"REDO_ROOT\");\n  v2 = get_relpath(a0);\n  if (!v2)\n    return 0;\n  *((int *)&v1) = (!(char)is_absolute(v2) ? \"/.redo/abs/\" : \"/.redo/rel/\");\n  v0 = concat();\n  mkpath(v0, 493);\n  free(v2);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpen362ji9/get_dep_path_name_conflict.c:19:20: error: ISO C requires a named parameter\nbefore '...' 19 | long long (concat)(...); |                    ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"int update_target(const char *target, int ident) {\n    dep_info dep = {.target = target, .path = get_dep_path(target)};\n    if (!dep.path)\n        return 1;\n    int retval = handle_ident(&dep, ident);\n    free(dep.path);\n    free(dep.hash);\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_dep_path)(long long);\nlong long(handle_ident)(long long, long long);\n\nlong long update_target_name_conflict(unsigned long long a0, unsigned long a1) {\n  int v0;          // [bp-0x48], Other Possible Types: unsigned long\n  void *v1;        // [bp-0x40]\n  int v2;          // [bp-0x38]\n  int v3;          // [bp-0x28]\n  unsigned int v4; // [bp-0xc]\n\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v2) = 0;\n  *((int128_t *)&v3) = 0;\n  v0 = a0;\n  v1 = get_dep_path(a0);\n  if (!v1)\n    return 1;\n  v4 = handle_ident(&v0, (unsigned int)a1);\n  free(v1);\n  free((long long)v2);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptkykz1b0/update_target_name_conflict.c:30:18: error: expected expression\n   30 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmptkykz1b0/update_target_name_conflict.c:31:18: error: expected expression\n   31 |     *((int128_t *)&v2) = 0;\n      |                  ^\n/tmp/tmptkykz1b0/update_target_name_conflict.c:32:18: error: expected expression\n   32 |     *((int128_t *)&v3) = 0;\n      |                  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"bool is_absolute(const char *path) {\n    return path[0] == '/';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_absolute_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = *(a0);\n  *((char *)&v1) = (char)v1 == 47;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"char *relpath(char *path, char *start) {\n    int i;\n    for (i = 0; path[i] && start[i]; ++i) {\n        if (path[i] != start[i])\n            return path;\n    }\n    if (!path[i] && start[i])\n        return start;\n    if (!path[i] && !start[i])\n        return \".\";\n    if (path[i] == '/')\n        ++i;\n    return &path[i];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long relpath_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; a0[v0] && a1[v0]; v0 += 1) {\n    if (a0[v0] != a1[v0])\n      return a0;\n  }\n  if (!a0[v0] && a1[v0])\n    return a1;\n  if (!a0[v0] && !a1[v0])\n    return \".\";\n  if (a0[v0] == 47)\n    v0 += 1;\n  return &a0[v0];\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"off_t fsize(const char *fn) {\n    struct stat st;\n    if (stat(fn, &st)) {\n        if ((*__errno_location()) != 2)\n            die_(\"(build.c:66): redo: failed to aquire stat() information about %s: %s\\n\", fn, strerror((*__errno_location())));\n        return -1;\n    }\n    return st.st_size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nchar *(strerror)(int);\nlong long(die_)(...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long fsize_name_conflict(char *a0) {\n  stat v0; // [bp-0x98]\n  char v1; // [bp-0x68]\n\n  if (!stat(a0, &v0)) {\n    return *((long long *)&v1);\n  } else if (*(__errno_location()) != 2) {\n    strerror(*(__errno_location()));\n    die_(); /* do not return */\n  } else {\n    return -1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp81m1cuts/fsize_name_conflict.c:29:18: error: ISO C requires a named parameter before\n'...' 29 | long long (die_)(...); |                  ^\n/tmp/tmp81m1cuts/fsize_name_conflict.c:49:3: error: redefinition of 'stat' as different kind\nof symbol 49 | } stat; |   ^ /tmp/tmp81m1cuts/fsize_name_conflict.c:16:6: note: previous\ndefinition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmp81m1cuts/fsize_name_conflict.c:53:5: error: must use 'struct' tag to refer to type\n'stat' 53 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmp81m1cuts/fsize_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmp81m1cuts/fsize_name_conflict.c:60:14: error: indirection requires pointer operand\n('int' invalid) 60 |     else if (*(__errno_location()) != 2) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp81m1cuts/fsize_name_conflict.c:62:18: error: indirection\nrequires pointer operand ('int' invalid) 62 | strerror(*(__errno_location()));\n      |                  ^~~~~~~~~~~~~~~~~~~~~\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"char *make_abs(char *root, char *path) {\n    if (!is_absolute(path))\n        return concat(3, root, \"/\", path);\n    else\n        return xstrdup(path);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(is_absolute)(long long);\nlong long(xstrdup)(long long);\nlong long(concat)(...);\n\nlong long make_abs_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v0 = a0;\n  if (!(char)((int)is_absolute(a1) ^ 1)) {\n    v3 = xstrdup(a1);\n    return v3;\n  }\n  v3 = concat();\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd1g2qle7/make_abs_name_conflict.c:18:20: error: ISO C requires a named parameter\nbefore '...' 18 | long long (concat)(...); |                    ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(MD5Update)(long long, long long, long long);\n\nlong long hash_file_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;               // [bp-0x1018]\n  unsigned long long v1; // [bp-0x18]\n  void *v2;              // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = 0;\n  while (true) {\n    v1 = read(a1, &v0, 0x1000);\n    if (v1 <= 0)\n      break;\n    MD5Update(a0, &v0, v1);\n    v2 += v1;\n  }\n  v0 = 0;\n  MD5Update(a0, &v0, 1);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  unsigned int v4;       // esi\n\n  v0 = a1;\n  v3 = v0;\n  v4 = v3;\n  v1 = open(a0, v3, v3);\n  if (v1 >= 0)\n    return v1;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbk81q84f/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = write(a0, a1, (unsigned int)a2);\n  if (v0 >= 0)\n    return v0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpghitux0z/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return (!access(a0, 0) ? 0 : 1); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgga9xwgv/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\nint(atoi)(char *);\n\nlong long file_read_int_fd_name_conflict(unsigned long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read((unsigned int)a0, &v0, 20) < 0)\n    return 1;\n  *(a1) = atoi(&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 0x101000);\n  if (v1 < 0)\n    return 1;\n  v0 = file_read_int_fd(v1, a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x28]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return ((int)file_write((unsigned int)a0, &v0, 20) < 0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 1052673);\n  if (v1 < 0)\n    return 1;\n  v0 = file_write_int_fd(v1, (unsigned int)a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 0x101000);\n  return (v0 < 0 ? ((int)file_read(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 1052673);\n  return (v0 < 0 ? ((int)file_write(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents_name_conflict(char *a0) {\n  stat v0;         // [bp-0xa8]\n  char v1;         // [bp-0x78]\n  void *v2;        // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0);\n  if (v3 < 0)\n    return 0;\n  v2 = malloc(*((long long *)&v1));\n  if (!(v2 && file_read(v3, v2, *((long long *)&v1)) != *((long long *)&v1)))\n    return v2;\n  free(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphdgdbroc/file_read_contents_name_conflict.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmphdgdbroc/file_read_contents_name_conflict.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmphdgdbroc/file_read_contents_name_conflict.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmphdgdbroc/file_read_contents_name_conflict.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmphdgdbroc/file_read_contents_name_conflict.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"spi *libsoc_spi_init(uint8_t spidev_device, uint8_t chip_select) {\n    spi *spi_dev;\n    libsoc_spi_debug(__func__, ((void *)0), \"initialising spidev device %d.%d\", spidev_device, chip_select);\n    spi_dev = malloc(sizeof(spi));\n    if (spi_dev == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"failed to allocate memory\");\n        return ((void *)0);\n    }\n    char path[40];\n    spi_dev->spi_dev = spidev_device;\n    spi_dev->chip_select = chip_select;\n    sprintf(path, \"/dev/spidev%d.%d\", spi_dev->spi_dev, spi_dev->chip_select);\n    if (!file_valid(path)) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s not a vaild device\", path);\n        goto error;\n    }\n    spi_dev->fd = file_open(path, 1052672 | 2);\n    if (spi_dev->fd < 0) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s could not be opened\", path);\n        goto error;\n    }\n    return spi_dev;\n  error:\n    free(spi_dev);\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\nlong long(file_valid)(long long);\nlong long(file_open)(long long, long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n  char field_5;\n} struct_0;\n\nlong long libsoc_spi_init_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;      // [bp-0x38]\n  struct_0 *v1; // [bp-0x10]\n\n  libsoc_spi_debug();\n  v1 = malloc(8);\n  if (!v1) {\n    libsoc_spi_debug();\n    return 0;\n  }\n  v1->field_4 = a0;\n  v1->field_5 = a1;\n  sprintf(&v0, \"/dev/spidev%d.%d\", v1->field_4, v1->field_5);\n  if (!(int)file_valid(&v0)) {\n    libsoc_spi_debug();\n  } else {\n    v1->field_0 = file_open(&v0, 1052674);\n    if (v1->field_0 >= 0)\n      return v1;\n    libsoc_spi_debug();\n  }\n  free(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzgjuosdr/libsoc_spi_init_name_conflict.c:16:25: error: ISO C requires a named\nparameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_bits_per_word(spi *spi, spi_bpw bpw) {\n    if (bpw != BITS_8 && bpw != BITS_16) {\n        libsoc_spi_debug(__func__, spi, \"bits per word was not BITS_8 or BITS_16\", bpw);\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting bits per word to %d\", bpw);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting bits per word\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_set_bits_per_word_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  if ((unsigned int)a1 != 8 && (unsigned int)a1 != 16) {\n    libsoc_spi_debug();\n    return 1;\n  }\n  libsoc_spi_debug();\n  v0 = ioctl(*(a0), 1073834755);\n  if (v0 != -1)\n    return 0;\n  libsoc_spi_debug();\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuixjzqrc/libsoc_spi_set_bits_per_word_name_conflict.c:16:25: error: ISO C requires a\nnamed parameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_bpw libsoc_spi_get_bits_per_word(spi *spi) {\n    uint8_t bpw;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading bits per word\");\n        return BPW_ERROR;\n    }\n    switch (bpw) {\n      case 8:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 8\");\n        return BITS_8;\n      case 16:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 16\");\n        return BITS_16;\n      default:\n        libsoc_spi_debug(__func__, spi, \"bits per word not recognised\");\n        return BPW_ERROR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_get_bits_per_word_name_conflict(unsigned int *a0) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n  unsigned int v3; // eax\n\n  v1 = ioctl(*(a0), 2147576579);\n  if (v1 == -1) {\n    libsoc_spi_debug();\n    return 17;\n  }\n  v3 = v0;\n  if (v3 == 8) {\n    libsoc_spi_debug();\n    return 8;\n  } else if (v3 != 16) {\n    libsoc_spi_debug();\n    return 17;\n  } else {\n    libsoc_spi_debug();\n    return 16;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjfaz6v60/libsoc_spi_get_bits_per_word_name_conflict.c:16:25: error: ISO C requires a\nnamed parameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_speed(spi *spi, uint32_t speed) {\n    libsoc_spi_debug(__func__, spi, \"setting speed to %dHz\", speed);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting speed\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_set_speed_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x24]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a1;\n  libsoc_spi_debug();\n  v1 = ioctl(*(a0), 1074031364);\n  if (v1 != -1)\n    return 0;\n  libsoc_spi_debug();\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpeyuqtqwv/libsoc_spi_set_speed_name_conflict.c:16:25: error: ISO C requires a named\nparameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"uint32_t libsoc_spi_get_speed(spi *spi) {\n    uint32_t speed;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading speed\");\n        return -1;\n    }\n    libsoc_spi_debug(__func__, spi, \"read speed as %dHz\", speed);\n    return speed;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_get_speed_name_conflict(unsigned int *a0) {\n  char v0;         // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = ioctl(*(a0), 2147773188);\n  if (v1 == -1) {\n    libsoc_spi_debug();\n    return 4294967295;\n  }\n  libsoc_spi_debug();\n  return *((int *)&v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5w0os_cm/libsoc_spi_get_speed_name_conflict.c:16:25: error: ISO C requires a named\nparameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_mode(spi *spi, spi_mode mode) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting mode to %d\", mode);\n    uint8_t new_mode;\n    switch (mode) {\n      case MODE_0:\n        new_mode = (0 | 0);\n        break;\n      case MODE_1:\n        new_mode = (0 | (((1UL)) << (0)));\n        break;\n      case MODE_2:\n        new_mode = ((((1UL)) << (1)) | 0);\n        break;\n      case MODE_3:\n        new_mode = ((((1UL)) << (1)) | (((1UL)) << (0)));\n        break;\n      default:\n        return 1;\n    }\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &new_mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting mode\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_set_mode_name_conflict(unsigned int *a0, unsigned long a1) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n\n  if (!a0) {\n    libsoc_spi_debug();\n    return 1;\n  }\n  libsoc_spi_debug();\n  if ((unsigned int)a1 != 3) {\n    if ((unsigned int)a1 > 3)\n      return 1;\n    if ((unsigned int)a1 == 2) {\n      v0 = 2;\n    } else if ((unsigned int)a1 <= 2) {\n      if (!(unsigned int)a1) {\n        v0 = 0;\n      } else if ((unsigned int)a1 == 1) {\n        v0 = 1;\n      }\n    }\n  } else {\n    v0 = 3;\n    v1 = ioctl(*(a0), 1073834753);\n    if (v1 != -1)\n      return 0;\n    libsoc_spi_debug();\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvgqcy3hb/libsoc_spi_set_mode_name_conflict.c:16:25: error: ISO C requires a named\nparameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_mode libsoc_spi_get_mode(spi *spi) {\n    uint8_t mode;\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return MODE_ERROR;\n    }\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading mode\");\n        return MODE_ERROR;\n    }\n    switch (mode) {\n      case (0 | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 0\");\n        return MODE_0;\n      case (0 | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 1\");\n        return MODE_1;\n      case ((((1UL)) << (1)) | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 2\");\n        return MODE_2;\n      case ((((1UL)) << (1)) | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 3\");\n        return MODE_3;\n      default:\n        libsoc_spi_debug(__func__, spi, \"mode not recognised\");\n        return MODE_ERROR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_get_mode_name_conflict(unsigned int *a0) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n  unsigned int v4; // eax\n\n  if (!a0) {\n    libsoc_spi_debug();\n    return 4;\n  }\n  v1 = ioctl(*(a0), 2147576577);\n  if (v1 == -1) {\n    libsoc_spi_debug();\n    return 4;\n  }\n  v4 = v0;\n  if (v4 == 3) {\n    libsoc_spi_debug();\n    return 3;\n  }\n  if (v4 <= 3) {\n    if (v4 == 2) {\n      libsoc_spi_debug();\n      return 2;\n    } else if (v4 <= 2) {\n      if (!v4) {\n        libsoc_spi_debug();\n        return 0;\n      } else if (v4 == 1) {\n        libsoc_spi_debug();\n        return 1;\n      }\n    }\n  }\n  libsoc_spi_debug();\n  return 4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz2nzzsjo/libsoc_spi_get_mode_name_conflict.c:16:25: error: ISO C requires a named\nparameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_write(spi *spi, uint8_t *tx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing write transfer of %d bytes\", len);\n    if (spi == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed sending message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_write(unsigned int *a0, unsigned long a1,\n                           unsigned long a2) {\n  int v0;          // [bp-0x38], Other Possible Types: unsigned long\n  int v1;          // [bp-0x28], Other Possible Types: unsigned int\n  unsigned int v2; // [bp-0xc]\n\n  libsoc_spi_debug();\n  if (a0 && a1) {\n    if ((unsigned int)a2) {\n      *((int128_t *)&v0) = 0;\n      *((int128_t *)&v1) = 0;\n      v0 = a1;\n      v1 = a2;\n      v2 = ioctl(*(a0), 0x40206b00);\n      if (v2 > 0)\n        return 0;\n      libsoc_spi_debug();\n      return 1;\n    } else {\n      libsoc_spi_debug();\n      return 1;\n    }\n  }\n  libsoc_spi_debug();\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjeyynx2a/libsoc_spi_write.c:18:25: error: ISO C requires a named\nparameter before '...' 18 | char (libsoc_spi_debug)(...); | ^\n/tmp/tmpjeyynx2a/libsoc_spi_write.c:31:26: error: expected expression\n   31 |             *((int128_t *)&v0) = 0;\n      |                          ^\n/tmp/tmpjeyynx2a/libsoc_spi_write.c:32:26: error: expected expression\n   32 |             *((int128_t *)&v1) = 0;\n      |                          ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_read(spi *spi, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing read transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or rx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed recieving message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_read(unsigned int *a0, unsigned long a1,\n                          unsigned long a2) {\n  int v0;           // [bp-0x38]\n  unsigned long v1; // [bp-0x30]\n  int v2;           // [bp-0x28], Other Possible Types: unsigned int\n  unsigned int v3;  // [bp-0xc]\n\n  libsoc_spi_debug();\n  if (a0 && a1) {\n    if ((unsigned int)a2) {\n      *((int128_t *)&v0) = 0;\n      *((int128_t *)&v2) = 0;\n      v1 = a1;\n      v2 = a2;\n      v3 = ioctl(*(a0), 0x40206b00);\n      if (v3 > 0)\n        return 0;\n      libsoc_spi_debug();\n      return 1;\n    } else {\n      libsoc_spi_debug();\n      return 1;\n    }\n  }\n  libsoc_spi_debug();\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfxtj9yw4/libsoc_spi_read.c:18:25: error: ISO C requires a named\nparameter before '...' 18 | char (libsoc_spi_debug)(...); | ^\n/tmp/tmpfxtj9yw4/libsoc_spi_read.c:32:26: error: expected expression\n   32 |             *((int128_t *)&v0) = 0;\n      |                          ^\n/tmp/tmpfxtj9yw4/libsoc_spi_read.c:33:26: error: expected expression\n   33 |             *((int128_t *)&v2) = 0;\n      |                          ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_rw(spi *spi, uint8_t *tx, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing duplex rw transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi | rx | tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed duplex transfer\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\n\nlong long libsoc_spi_rw(unsigned int *a0, unsigned long a1, unsigned long a2,\n                        unsigned long a3) {\n  int v0;           // [bp-0x38], Other Possible Types: unsigned long\n  unsigned long v1; // [bp-0x30]\n  int v2;           // [bp-0x28], Other Possible Types: unsigned int\n  unsigned int v3;  // [bp-0xc]\n\n  libsoc_spi_debug();\n  if (a0 && a2 && a1) {\n    if ((unsigned int)a3) {\n      *((int128_t *)&v0) = 0;\n      *((int128_t *)&v2) = 0;\n      v0 = a1;\n      v1 = a2;\n      v2 = a3;\n      v3 = ioctl(*(a0), 0x40206b00);\n      if (v3 > 0)\n        return 0;\n      libsoc_spi_debug();\n      return 1;\n    } else {\n      libsoc_spi_debug();\n      return 1;\n    }\n  }\n  libsoc_spi_debug();\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0n_bjhls/libsoc_spi_rw.c:18:25: error: ISO C requires a named parameter\nbefore '...' 18 | char (libsoc_spi_debug)(...); |                         ^\n/tmp/tmp0n_bjhls/libsoc_spi_rw.c:32:26: error: expected expression\n   32 |             *((int128_t *)&v0) = 0;\n      |                          ^\n/tmp/tmp0n_bjhls/libsoc_spi_rw.c:33:26: error: expected expression\n   33 |             *((int128_t *)&v2) = 0;\n      |                          ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_free(spi *spi) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"freeing spi device\");\n    if (file_close(spi->fd) < 0)\n        return 1;\n    free(spi);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_spi_debug)(...);\nlong long(file_close)(long long);\n\nlong long libsoc_spi_free_name_conflict(unsigned int *a0) {\n  if (!a0) {\n    libsoc_spi_debug();\n    return 1;\n  }\n  libsoc_spi_debug();\n  if ((int)file_close(*(a0)) < 0)\n    return 1;\n  free(a0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpti6nhatg/libsoc_spi_free_name_conflict.c:16:25: error: ISO C requires a named\nparameter before '...' 16 | char (libsoc_spi_debug)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"uint8_t read_status_register(spi *spi_dev) {\n    printf(\"Reading STATUS register\\n\");\n    tx[0] = 5;\n    tx[1] = 0;\n    rx[0] = 0;\n    rx[1] = 0;\n    libsoc_spi_rw(spi_dev, tx, rx, 2);\n    printf(\"STATUS is 0x%02x\\n\", rx[1]);\n    return rx[1];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_rw)(long long, long long, long long, long long);\n\nextern char g_4050e1;\nextern char g_405121;\nextern char rx;\nextern char tx;\n\nlong long read_status_register_name_conflict(unsigned long long a0) {\n  puts(\"Reading STATUS register\");\n  tx = 5;\n  g_4050e1 = 0;\n  rx = 0;\n  g_405121 = 0;\n  libsoc_spi_rw(a0, &tx, &rx, 2);\n  printf(\"STATUS is 0x%02x\\n\", g_405121);\n  return g_405121;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int write_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Writing to page %d\\n\", page_address);\n    page_address = page_address * 32;\n    tx[0] = 2;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    if (len > 32) {\n        printf(\"Page size is 32 bytes\\n\");\n        return 1;\n    }\n    int i;\n    for (i = 0; i < len; i++) {\n        tx[(i + 3)] = data[i];\n    }\n    libsoc_spi_write(spi_dev, tx, (len + 3));\n    int status;\n    do {\n        status = read_status_register(spi_dev);\n        if (status & 1) {\n            printf(\"Write in progress...\\n\");\n        } else {\n            printf(\"Write finished...\\n\");\n        }\n    } while (status & 1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_write)(long long, long long, long long);\nlong long(read_status_register)(long long);\n\nextern char g_4050e1;\nextern char g_4050e2;\nextern char g_4050e3;\nextern char tx;\n\nlong long write_page(unsigned long long a0, unsigned long a1, char *a2,\n                     unsigned long a3) {\n  unsigned short v0; // [bp-0x24]\n  unsigned int v1;   // [bp-0x10]\n  unsigned int v2;   // [bp-0xc]\n\n  v0 = a1;\n  printf(\"Writing to page %d\\n\", v0);\n  v0 *= 32;\n  tx = 2;\n  g_4050e1 = v0 >> 8;\n  g_4050e2 = v0;\n  if ((unsigned int)a3 > 32) {\n    puts(\"Page size is 32 bytes\");\n    return 1;\n  }\n  for (v2 = 0; v2 < (unsigned int)a3; v2 += 1) {\n    *(&(&g_4050e3)[v2]) = a2[v2];\n  }\n  libsoc_spi_write(a0, &tx, (unsigned int)a3 + 3);\n  do {\n    v1 = read_status_register(a0);\n    if (!((char)v1 & 1))\n      puts(\"Write finished...\");\n    else\n      puts(\"Write in progress...\");\n  } while (((char)v1 & 1));\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int read_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Reading page address %d\\n\", page_address);\n    tx[0] = 3;\n    page_address = page_address * 32;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    libsoc_spi_rw(spi_dev, tx, rx, (len + 3));\n    int i;\n    for (i = 0; i < len; i++) {\n        data[i] = rx[(i + 3)];\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_rw)(long long, long long, long long, long long);\n\nextern char g_4050e1;\nextern char g_4050e2;\nextern char g_405123;\nextern unsigned long long rx;\nextern char tx;\n\nlong long read_page(unsigned long long a0, unsigned long a1, char *a2,\n                    unsigned long a3) {\n  unsigned short v0; // [bp-0x24]\n  unsigned int v1;   // [bp-0xc]\n\n  v0 = a1;\n  printf(\"Reading page address %d\\n\", v0);\n  tx = 3;\n  v0 *= 32;\n  g_4050e1 = v0 >> 8;\n  g_4050e2 = v0;\n  libsoc_spi_rw(a0, &tx, &rx, (unsigned int)a3 + 3);\n  for (v1 = 0; v1 < (unsigned int)a3; v1 += 1) {\n    a2[v1] = *(&(&g_405123)[v1]);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int set_write_enable(spi *spi_dev) {\n    tx[0] = 6;\n    printf(\"Setting write enable bit\\n\");\n    libsoc_spi_write(spi_dev, tx, 1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_write)(long long, long long, long long);\n\nextern char tx;\n\nlong long set_write_enable_name_conflict(unsigned long long a0) {\n  tx = 6;\n  puts(\"Setting write enable bit\");\n  libsoc_spi_write(a0, &tx, 1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  unsigned int v4;       // esi\n\n  v0 = a1;\n  v3 = v0;\n  v4 = v3;\n  v1 = open(a0, v3, v3);\n  if (v1 >= 0)\n    return v1;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkrk26rgt/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = write(a0, a1, (unsigned int)a2);\n  if (v0 >= 0)\n    return v0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsbhbjvxe/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return (!access(a0, 0) ? 0 : 1); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj7_78bln/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\nint(atoi)(char *);\n\nlong long file_read_int_fd_name_conflict(unsigned long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read((unsigned int)a0, &v0, 20) < 0)\n    return 1;\n  *(a1) = atoi(&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 0x101000);\n  if (v1 < 0)\n    return 1;\n  v0 = file_read_int_fd(v1, a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x28]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return ((int)file_write((unsigned int)a0, &v0, 20) < 0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 1052673);\n  if (v1 < 0)\n    return 1;\n  v0 = file_write_int_fd(v1, (unsigned int)a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 0x101000);\n  return (v0 < 0 ? ((int)file_read(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 1052673);\n  return (v0 < 0 ? ((int)file_write(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents_name_conflict(char *a0) {\n  stat v0;         // [bp-0xa8]\n  char v1;         // [bp-0x78]\n  void *v2;        // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0);\n  if (v3 < 0)\n    return 0;\n  v2 = malloc(*((long long *)&v1));\n  if (!(v2 && file_read(v3, v2, *((long long *)&v1)) != *((long long *)&v1)))\n    return v2;\n  free(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgweffskz/file_read_contents_name_conflict.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpgweffskz/file_read_contents_name_conflict.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpgweffskz/file_read_contents_name_conflict.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpgweffskz/file_read_contents_name_conflict.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpgweffskz/file_read_contents_name_conflict.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  unsigned int v4;       // esi\n\n  v0 = a1;\n  v3 = v0;\n  v4 = v3;\n  v1 = open(a0, v3, v3);\n  if (v1 >= 0)\n    return v1;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppb81819q/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = write(a0, a1, (unsigned int)a2);\n  if (v0 >= 0)\n    return v0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6iw9g946/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return (!access(a0, 0) ? 0 : 1); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptunanf4x/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\nint(atoi)(char *);\n\nlong long file_read_int_fd_name_conflict(unsigned long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read((unsigned int)a0, &v0, 20) < 0)\n    return 1;\n  *(a1) = atoi(&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 0x101000);\n  if (v1 < 0)\n    return 1;\n  v0 = file_read_int_fd(v1, a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x28]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return ((int)file_write((unsigned int)a0, &v0, 20) < 0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 1052673);\n  if (v1 < 0)\n    return 1;\n  v0 = file_write_int_fd(v1, (unsigned int)a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 0x101000);\n  return (v0 < 0 ? ((int)file_read(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 1052673);\n  return (v0 < 0 ? ((int)file_write(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents_name_conflict(char *a0) {\n  stat v0;         // [bp-0xa8]\n  char v1;         // [bp-0x78]\n  void *v2;        // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0);\n  if (v3 < 0)\n    return 0;\n  v2 = malloc(*((long long *)&v1));\n  if (!(v2 && file_read(v3, v2, *((long long *)&v1)) != *((long long *)&v1)))\n    return v2;\n  free(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbx4m9pp2/file_read_contents_name_conflict.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpbx4m9pp2/file_read_contents_name_conflict.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpbx4m9pp2/file_read_contents_name_conflict.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpbx4m9pp2/file_read_contents_name_conflict.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpbx4m9pp2/file_read_contents_name_conflict.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  unsigned int v4;       // esi\n\n  v0 = a1;\n  v3 = v0;\n  v4 = v3;\n  v1 = open(a0, v3, v3);\n  if (v1 >= 0)\n    return v1;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptvjv9wgs/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = write(a0, a1, (unsigned int)a2);\n  if (v0 >= 0)\n    return v0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsz0as5ri/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return (!access(a0, 0) ? 0 : 1); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0tjkwxvd/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\nint(atoi)(char *);\n\nlong long file_read_int_fd_name_conflict(unsigned long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read((unsigned int)a0, &v0, 20) < 0)\n    return 1;\n  *(a1) = atoi(&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 0x101000);\n  if (v1 < 0)\n    return 1;\n  v0 = file_read_int_fd(v1, a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x28]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return ((int)file_write((unsigned int)a0, &v0, 20) < 0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 1052673);\n  if (v1 < 0)\n    return 1;\n  v0 = file_write_int_fd(v1, (unsigned int)a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 0x101000);\n  return (v0 < 0 ? ((int)file_read(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 1052673);\n  return (v0 < 0 ? ((int)file_write(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents_name_conflict(char *a0) {\n  stat v0;         // [bp-0xa8]\n  char v1;         // [bp-0x78]\n  void *v2;        // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0);\n  if (v3 < 0)\n    return 0;\n  v2 = malloc(*((long long *)&v1));\n  if (!(v2 && file_read(v3, v2, *((long long *)&v1)) != *((long long *)&v1)))\n    return v2;\n  free(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb01p50xa/file_read_contents_name_conflict.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpb01p50xa/file_read_contents_name_conflict.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpb01p50xa/file_read_contents_name_conflict.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpb01p50xa/file_read_contents_name_conflict.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpb01p50xa/file_read_contents_name_conflict.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"pwm *libsoc_pwm_request(unsigned int chip, unsigned int pwm_num, shared_mode mode) {\n    pwm *new_pwm;\n    char tmp_str[256];\n    int shared = 0;\n    if (mode != LS_PWM_SHARED && mode != LS_PWM_GREEDY && mode != LS_PWM_WEAK) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"mode was not set, or invalid, setting mode to LS_PWM_SHARED\");\n        mode = LS_PWM_SHARED;\n    }\n    libsoc_pwm_debug(__func__, chip, pwm_num, \"requested PWM\");\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    if (file_valid(tmp_str)) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"PWM already exported\");\n        switch (mode) {\n          case LS_PWM_WEAK:\n            {\n                return ((void *)0);\n            }\n          case LS_PWM_SHARED:\n            {\n                shared = 1;\n                break;\n            }\n          default:\n            {\n                break;\n            }\n        }\n    } else {\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/export\", chip);\n        if (file_write_int_path(tmp_str, pwm_num) == 1) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"write failed\");\n            return ((void *)0);\n        }\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n        if (!file_valid(tmp_str)) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"failed to export PWM\");\n            perror(\"libsoc-pwm-debug\");\n            return ((void *)0);\n        }\n    }\n    new_pwm = malloc(sizeof(pwm));\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    new_pwm->enable_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", chip, pwm_num);\n    new_pwm->period_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/duty_cycle\", chip, pwm_num);\n    new_pwm->duty_fd = file_open(tmp_str, 1052672 | 2);\n    if (new_pwm->enable_fd < 0 || new_pwm->period_fd < 0 || new_pwm->duty_fd < 0) {\n        free(new_pwm);\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"Failed to open pwm sysfs file: %d\", new_pwm->enable_fd);\n        return ((void *)0);\n    }\n    new_pwm->chip = chip;\n    new_pwm->pwm = pwm_num;\n    new_pwm->shared = shared;\n    return new_pwm;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_valid)(long long);\nlong long(file_write_int_path)(long long, long long);\nlong long(file_open)(long long, long long);\nvoid(perror)(char *);\n\nlong long libsoc_pwm_request(unsigned long a0, unsigned long a1,\n                             unsigned long a2, unsigned long a3,\n                             unsigned long long a4, unsigned long long a5) {\n  unsigned int v0;    // [bp-0x124], Other Possible Types: unsigned long\n  char v1;            // [bp-0x118]\n  unsigned int v2[6]; // [bp-0x18]\n  unsigned int v3;    // [bp-0xc]\n\n  v0 = a2;\n  v3 = 0;\n  if (v0 && v0 != 1 && v0 != 2) {\n    libsoc_pwm_debug(\n        \"libsoc_pwm_request\", (unsigned int)a0, (unsigned int)a1,\n        \"mode was not set, or invalid, setting mode to LS_PWM_SHARED\", a4, a5);\n    v0 = 0;\n  }\n  libsoc_pwm_debug(\"libsoc_pwm_request\", (unsigned int)a0, (unsigned int)a1,\n                   \"requested PWM\", a4, a5);\n  sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n          (unsigned int)a1);\n  if (!(int)file_valid(&v1)) {\n    sprintf(&v1, \"/sys/class/pwm/pwmchip%d/export\", (unsigned int)a0);\n    if ((int)file_write_int_path(&v1, (unsigned int)a1) == 1) {\n      libsoc_pwm_debug(\"libsoc_pwm_request\", (unsigned int)a0, (unsigned int)a1,\n                       \"write failed\", a4, a5);\n      return 0;\n    }\n    sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n            (unsigned int)a1);\n    if (!(int)file_valid(&v1)) {\n      libsoc_pwm_debug(\"libsoc_pwm_request\", (unsigned int)a0, (unsigned int)a1,\n                       \"failed to export PWM\", a4, a5);\n      perror(\"libsoc-pwm-debug\");\n      return 0;\n    }\n  } else {\n    libsoc_pwm_debug(\"libsoc_pwm_request\", (unsigned int)a0, (unsigned int)a1,\n                     \"PWM already exported\", a4, a5);\n    if (!(int)v0) {\n      v3 = 1;\n    } else if ((int)v0 == 2) {\n      return 0;\n    }\n  }\n  *((void **)&v2[0]) = malloc(24);\n  sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n          (unsigned int)a1);\n  v2[2] = file_open(&v1, 1052674);\n  sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", (unsigned int)a0,\n          (unsigned int)a1);\n  v2[4] = file_open(&v1, 1052674);\n  sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/duty_cycle\", (unsigned int)a0,\n          (unsigned int)a1);\n  v2[3] = file_open(&v1, 1052674);\n  if (v2[2] >= 0 && v2[4] >= 0 && v2[3] >= 0) {\n    v2[0] = a0;\n    v2[1] = a1;\n    v2[5] = v3;\n    return v2;\n  }\n  free(v2);\n  libsoc_pwm_debug(\"libsoc_pwm_request\", (unsigned int)a0, (unsigned int)a1,\n                   \"Failed to open pwm sysfs file: %d\", v2[2], a5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp417g32z/libsoc_pwm_request.c:20:7: error: conflicting types for\n'perror' 20 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_free(pwm *pwm) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing pwm\");\n    if (file_close(pwm->enable_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->period_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->duty_fd) < 0) {\n        return 1;\n    }\n    if (pwm->shared == 1) {\n        free(pwm);\n        return 0;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/unexport\", pwm->chip);\n    file_write_int_path(path, pwm->pwm);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d\", pwm->chip, pwm->pwm);\n    if (file_valid(path)) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing failed\");\n        return 1;\n    }\n    free(pwm);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_close)(long long);\nlong long(file_write_int_path)(long long, long long);\nlong long(file_valid)(long long);\n\nlong long libsoc_pwm_free(unsigned int a0[6], unsigned long a1,\n                          unsigned long a2, unsigned long a3,\n                          unsigned long long a4, unsigned long long a5) {\n  char v0; // [bp-0x108]\n\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_free\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 1;\n  }\n  libsoc_pwm_debug(\"libsoc_pwm_free\", a0[0], a0[1], \"freeing pwm\", a4, a5);\n  if ((int)file_close(a0[2]) < 0) {\n    return 1;\n  } else if ((int)file_close(a0[4]) < 0) {\n    return 1;\n  } else if ((int)file_close(a0[3]) < 0) {\n    return 1;\n  } else if (a0[5] != 1) {\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/unexport\", a0[0]);\n    file_write_int_path(&v0, a0[1]);\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d\", a0[0], a0[1]);\n    if (!(int)file_valid(&v0)) {\n      free(a0);\n      return 0;\n    }\n    libsoc_pwm_debug(\"libsoc_pwm_free\", a0[0], a0[1], \"freeing failed\", a4, a5);\n    return 1;\n  } else {\n    free(a0);\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_enabled(pwm *pwm, pwm_enabled enabled) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (enabled != ENABLED && enabled != DISABLED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting enabled to %s\", pwm_enabled_strings[enabled]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_enabled_strings[enabled], 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_write_str)(long long, long long, long long);\n\nextern char pwm_enabled_strings;\n\nlong long libsoc_pwm_set_enabled(unsigned int a0[2], unsigned long a1,\n                                 unsigned long a2, unsigned long a3,\n                                 unsigned long long a4, unsigned long long a5) {\n  char v0; // [bp-0x108]\n\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_enabled\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 1;\n  }\n  if ((unsigned int)a1 != 1 && (unsigned int)a1)\n    return 1;\n  libsoc_pwm_debug(\"libsoc_pwm_set_enabled\", a0[0], a0[1],\n                   \"setting enabled to %s\",\n                   (char *)(4215456 + 0x100 * (unsigned int)a1), a5);\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", a0[0], a0[1]);\n  return file_write_str(&v0, (char *)(4215456 + 0x100 * (unsigned int)a1), 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"pwm_enabled libsoc_pwm_get_enabled(pwm *pwm) {\n    int val;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return ENABLED_ERROR;\n    }\n    if (file_read_int_fd(pwm->enable_fd, &val) == 1) {\n        return ENABLED_ERROR;\n    }\n    if (val == 1) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as enabled\");\n        return ENABLED;\n    } else if (val == 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as disabled\");\n        return DISABLED;\n    } else {\n        return ENABLED_ERROR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_read_int_fd)(long long, long long);\n\nlong long libsoc_pwm_get_enabled(unsigned int a0[3], unsigned long a1,\n                                 unsigned long a2, unsigned long a3,\n                                 unsigned long long a4, unsigned long long a5) {\n  char v0; // [bp-0xc]\n\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_enabled\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 4294967295;\n  } else if ((int)file_read_int_fd(a0[2], &v0) == 1) {\n    return 4294967295;\n  } else if (*((int *)&v0) == 1) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_enabled\", a0[0], a0[1], \"read as enabled\",\n                     a4, a5);\n    return 1;\n  } else if (!*((int *)&v0)) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_enabled\", a0[0], a0[1], \"read as disabled\",\n                     a4, a5);\n    return 0;\n  } else {\n    return 4294967295;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_period(pwm *pwm, unsigned int period) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting period to %d\", period);\n    return file_write_int_fd(pwm->period_fd, period);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_write_int_fd)(long long, long long);\n\nlong long libsoc_pwm_set_period(unsigned int a0[5], unsigned long a1,\n                                unsigned long a2, unsigned long a3,\n                                unsigned long long a4, unsigned long long a5) {\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_period\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 1;\n  }\n  libsoc_pwm_debug(\"libsoc_pwm_set_period\", a0[0], a0[1],\n                   \"setting period to %d\", (unsigned int)a1, a5);\n  return file_write_int_fd(a0[4], (unsigned int)a1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_duty_cycle(pwm *pwm, unsigned int duty) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting duty to %d\", duty);\n    return file_write_int_fd(pwm->duty_fd, duty);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_write_int_fd)(long long, long long);\n\nlong long libsoc_pwm_set_duty_cycle(unsigned int a0[4], unsigned long a1,\n                                    unsigned long a2, unsigned long a3,\n                                    unsigned long long a4,\n                                    unsigned long long a5) {\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_duty_cycle\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 1;\n  }\n  libsoc_pwm_debug(\"libsoc_pwm_set_duty_cycle\", a0[0], a0[1],\n                   \"setting duty to %d\", (unsigned int)a1, a5);\n  return file_write_int_fd(a0[3], (unsigned int)a1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_period(pwm *pwm) {\n    int period = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->period_fd, &period);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got period as %d\", period);\n    return period;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_read_int_fd)(long long, long long);\n\nlong long libsoc_pwm_get_period(unsigned int a0[5], unsigned long a1,\n                                unsigned long a2, unsigned long a3,\n                                unsigned long long a4, unsigned long long a5) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = -1;\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_period\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 4294967295;\n  }\n  file_read_int_fd(a0[4], &v0);\n  libsoc_pwm_debug(\"libsoc_pwm_get_period\", a0[0], a0[1], \"got period as %d\",\n                   v0, a5);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_duty_cycle(pwm *pwm) {\n    int duty = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->duty_fd, &duty);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got duty as %d\", duty);\n    return duty;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_read_int_fd)(long long, long long);\n\nlong long libsoc_pwm_get_duty_cycle(unsigned int a0[4], unsigned long a1,\n                                    unsigned long a2, unsigned long a3,\n                                    unsigned long long a4,\n                                    unsigned long long a5) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = -1;\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_duty_cycle\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 4294967295;\n  }\n  file_read_int_fd(a0[3], &v0);\n  libsoc_pwm_debug(\"libsoc_pwm_get_duty_cycle\", a0[0], a0[1], \"got duty as %d\",\n                   v0, a5);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_polarity(pwm *pwm, pwm_polarity polarity) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (polarity != NORMAL && polarity != INVERSED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting polarity to %s\", pwm_polarity_strings[polarity]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_polarity_strings[polarity], 256);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_write_str)(long long, long long, long long);\n\nextern char pwm_polarity_strings;\n\nlong long libsoc_pwm_set_polarity(unsigned int a0[2], unsigned long a1,\n                                  unsigned long a2, unsigned long a3,\n                                  unsigned long long a4,\n                                  unsigned long long a5) {\n  char v0; // [bp-0x108]\n\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_polarity\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 1;\n  }\n  if ((unsigned int)a1 && (unsigned int)a1 != 1)\n    return 1;\n  libsoc_pwm_debug(\"libsoc_pwm_set_polarity\", a0[0], a0[1],\n                   \"setting polarity to %s\",\n                   (char *)(4214944 + 0x100 * (unsigned int)a1), a5);\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", a0[0], a0[1]);\n  return file_write_str(&v0, (char *)(4214944 + 0x100 * (unsigned int)a1),\n                        0x100);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_polarity(pwm *pwm) {\n    int polarity;\n    char path[256];\n    char tmp_str[1];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    if (file_read_str(path, tmp_str, 1) == 1) {\n        return POLARITY_ERROR;\n    }\n    if (strncmp(tmp_str, \"i\", 1) == 0) {\n        polarity = INVERSED;\n    } else if (strncmp(tmp_str, \"n\", 1) == 0) {\n        polarity = NORMAL;\n    } else {\n        polarity = POLARITY_ERROR;\n    }\n    if (polarity > 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got polarity as %s\", pwm_polarity_strings[polarity]);\n    } else {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"getting polarity failed\");\n    }\n    return polarity;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar(libsoc_pwm_debug)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(file_read_str)(long long, long long, long long);\n\nextern char pwm_polarity_strings;\n\nlong long libsoc_pwm_get_polarity(unsigned int a0[2], unsigned long a1,\n                                  unsigned long a2, unsigned long a3,\n                                  unsigned long long a4,\n                                  unsigned long long a5) {\n  char v0;         // [bp-0x119]\n  char v1;         // [bp-0x118]\n  unsigned int v2; // [bp-0xc]\n\n  if (!a0) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_polarity\", 4294967295, 4294967295,\n                     \"invalid pwm pointer\", a4, a5);\n    return 1;\n  }\n  sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", a0[0], a0[1]);\n  if ((int)file_read_str(&v1, &v0, 1) == 1)\n    return 4294967295;\n  if (v0 == 105) {\n    v2 = 1;\n  } else if (v0 != 110) {\n    v2 = -1;\n  } else {\n    v2 = 0;\n  }\n  if (v2 <= 0)\n    libsoc_pwm_debug(\"libsoc_pwm_get_polarity\", a0[0], a0[1],\n                     \"getting polarity failed\", a4, a5);\n  else\n    libsoc_pwm_debug(\"libsoc_pwm_get_polarity\", a0[0], a0[1],\n                     \"got polarity as %s\", (char *)(4214944 + 0x100 * v2), a5);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  unsigned int v4;       // esi\n\n  v0 = a1;\n  v3 = v0;\n  v4 = v3;\n  v1 = open(a0, v3, v3);\n  if (v1 >= 0)\n    return v1;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvf50pbvp/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = write(a0, a1, (unsigned int)a2);\n  if (v0 >= 0)\n    return v0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgroyalus/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return (!access(a0, 0) ? 0 : 1); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6ty8rkwf/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\nint(atoi)(char *);\n\nlong long file_read_int_fd_name_conflict(unsigned long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read((unsigned int)a0, &v0, 20) < 0)\n    return 1;\n  *(a1) = atoi(&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 0x101000);\n  if (v1 < 0)\n    return 1;\n  v0 = file_read_int_fd(v1, a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x28]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return ((int)file_write((unsigned int)a0, &v0, 20) < 0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = file_open(a0, 1052673);\n  if (v1 < 0)\n    return 1;\n  v0 = file_write_int_fd(v1, (unsigned int)a1);\n  if (!((int)file_close(v1) >= 0 && v0 != 1))\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 0x101000);\n  return (v0 < 0 ? ((int)file_read(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = file_open(a0, 1052673);\n  return (v0 < 0 ? ((int)file_write(v0, a1, (unsigned int)a2) < 0\n                        ? ((int)file_close(v0) < 0 ? 0 : 1)\n                        : 1)\n                 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents_name_conflict(char *a0) {\n  stat v0;         // [bp-0xa8]\n  char v1;         // [bp-0x78]\n  void *v2;        // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0);\n  if (v3 < 0)\n    return 0;\n  v2 = malloc(*((long long *)&v1));\n  if (!(v2 && file_read(v3, v2, *((long long *)&v1)) != *((long long *)&v1)))\n    return v2;\n  free(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbia6okzi/file_read_contents_name_conflict.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpbia6okzi/file_read_contents_name_conflict.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpbia6okzi/file_read_contents_name_conflict.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpbia6okzi/file_read_contents_name_conflict.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpbia6okzi/file_read_contents_name_conflict.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"static int wait_for_process(pid_t pid) {\n    int rv = 70;\n    int stats = 0;\n    int i = 0;\n    struct sigaction sig_handler;\n    sig_handler.__sigaction_handler.sa_handler = caught_signal;\n    sig_handler.sa_flags = 0;\n    sigaction(14, &sig_handler, ((void *)0));\n    sigaction(1, &sig_handler, ((void *)0));\n    sigaction(2, &sig_handler, ((void *)0));\n    sigaction(15, &sig_handler, ((void *)0));\n    sigaction(13, &sig_handler, ((void *)0));\n    for (i = 0; ; i++) {\n        pid_t p = waitpid(pid, &stats, 0);\n        if (p == pid) {\n            rv = (((stats) & 127) == 0) ? (((stats) & 65280) >> 8) : (128 | ((stats) & 127));\n            break;\n        } else {\n            int sig = 0;\n            switch (i) {\n              case 0:\n                sig = caught > 0 ? caught : 15;\n                if (caught == 14) {\n                    fprintf(stderr, \"Timeout.. killing the process\\n\");\n                }\n                break;\n              case 1:\n                sig = 15;\n                break;\n              default:\n                sig = 9;\n                break;\n            }\n            if (kill(pid, sig) < 0) {\n                perror(\"lost child when trying to kill\");\n            }\n            alarm(5);\n        }\n    }\n    return rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint caught_signal; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(waitpid)(int, int *, int);\nvoid(perror)(char *);\nunsigned int(alarm)(unsigned int);\n\nextern unsigned int caught;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long wait_for_process_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0xb8]\n  unsigned int v1; // [bp-0x30]\n  unsigned int v2; // [bp-0x1c]\n  unsigned int v3; // [bp-0x18]\n  unsigned int v4; // [bp-0x14]\n  unsigned int v5; // [bp-0x10]\n  unsigned int v6; // [bp-0xc]\n  unsigned long long\n      v9; // eax, Other Possible Types: unsigned long, unsigned int\n\n  v4 = 70;\n  v2 = 0;\n  v6 = 0;\n  *((void **)&v0) = caught_signal;\n  v1 = 0;\n  sigaction(0xe, &v0, NULL);\n  sigaction(0x1, &v0, NULL);\n  sigaction(0x2, &v0, NULL);\n  sigaction(0xf, &v0, NULL);\n  sigaction(0xd, &v0, NULL);\n  v6 = 0;\n  while (true) {\n    v3 = waitpid(a0, &v2, 0);\n    if (v3 == (unsigned int)a0)\n      break;\n    v5 = 0;\n    if (!v6) {\n      v5 = (caught <= 0 ? caught : 15);\n      if (caught == 14)\n        fwrite(\"Timeout.. killing the process\\n\", 1, 30, stderr @GLIBC_2.2.5);\n    } else if (v6 != 1) {\n      v5 = 9;\n    } else {\n      v5 = 15;\n    }\n    if (kill(a0, v5) < 0)\n      perror(\"lost child when trying to kill\");\n    alarm(5);\n    v6 += 1;\n  }\n  if (((char)v2 & 127)) {\n    v9 = v2;\n    *((char *)&v9) = (char)v9 | 128;\n  } else {\n    v9 = v2 >> 8;\n  }\n  v4 = v9;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnupl9rgf/wait_for_process_name_conflict.c:19:7: error: conflicting types for 'perror'\n   19 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpnupl9rgf/wait_for_process_name_conflict.c:23:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 23 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpnupl9rgf/wait_for_process_name_conflict.c:23:22: error: expected ';' after top level\ndeclarator 23 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpnupl9rgf/wait_for_process_name_conflict.c:57:72: error: expected ')'\n   57 |                 fwrite(\"Timeout.. killing the process\\n\", 1, 30,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpnupl9rgf/wait_for_process_name_conflict.c:57:23: note: to\nmatch this '(' 57 |                 fwrite(\"Timeout.. killing the process\\n\", 1,\n30, stderr@GLIBC_2.2.5); |                       ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shelsonjava_memcached/timedrun.c"}
{"compilable":1,"function":"unsigned int hamdist(unsigned int x, unsigned int y) {\n    unsigned int dist = 0, val = x ^ y;\n    while (val)\n        {\n            ++dist;\n            val &= val - 1;\n        }\n    return dist;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamdist_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  for (v0 = (unsigned int)a0 ^ (unsigned int)a1; v0; v0 &= v0 - 1) {\n    v1 += 1;\n  }\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Hamming_Distance/C/Arpan-Patel/HammingDistance.c"}
{"compilable":1,"function":"int partition(int a[], int lo, int hi) {\n    int i = lo, j = hi + 1, temp;\n    while (1)\n        {\n            while (a[++i] < a[lo])\n                {\n                    if (i == hi)\n                        break;\n                }\n            ;\n            while (a[lo] < a[--j])\n                {\n                    if (j == lo)\n                        break;\n                }\n            if (i >= j)\n                break;\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    temp = a[lo];\n    a[lo] = a[j];\n    a[j] = temp;\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long partition_name_conflict(unsigned int *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc], Other Possible Types: unsigned long\n\n  v2 = a1;\n  v1 = (unsigned int)a2 + 1;\n  while (true) {\n    v2 = (int)v2 + 1;\n    if (a0[v2] < a0[(unsigned int)a1] && !(v2 == (unsigned int)a2))\n      continue;\n    do {\n      v1 -= 1;\n    } while (a0[(unsigned int)a1] < a0[v1] && v1 != (unsigned int)a1);\n    if (v2 >= v1) {\n      v0 = a0[(unsigned int)a1];\n      a0[(unsigned int)a1] = a0[v1];\n      a0[v1] = v0;\n      return v1;\n    }\n    v0 = a0[v2];\n    a0[v2] = a0[v1];\n    a0[v1] = v0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Quick_Sort/C/jonathanlebron/quick_sort.c"}
{"compilable":0,"function":"int parent(int i) {\n    return (int)((i + 1) / 2) - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parent_name_conflict(unsigned long a0) {\n  return (unsigned int)((unsigned int)a0 + 1 + ((unsigned int)a0 + 1 >> 31) >>\n                        1) -\n         1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int left(int i) {\n    return i * 2 + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long left_name_conflict(unsigned long a0) { return (unsigned int)a0 * 2 + 1; }\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int right(int i) {\n    return 2 * i + 2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long right_name_conflict(unsigned long a0) { return ((unsigned int)a0 + 1) * 2; }\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int test_sorted_array(int *array, int size) {\n    int i;\n    for (i = 0; i < size - 2; i++) {\n        if (array[i] > array[i + 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test_sorted_array_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (true) {\n    if (v0 >= (unsigned int)a1 - 2) {\n      return 1;\n    } else if (a0[v0] <= a0[1 + v0]) {\n      v0 += 1;\n    } else {\n      return 0;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int BinarySearch(TypeArray a[], TypeArray key, int first, int last) {\n    if (first > last)\n        return -1;\n    ;\n    int length = last - first + 1;\n    int midIndex = (first + last) / 2;\n    TypeArray midValue = a[midIndex];\n    if (key > midValue) {\n        return BinarySearch(a, key, midIndex + 1, last);\n    } else if (key < midValue) {\n        return BinarySearch(a, key, first, midIndex - 1);\n    } else\n        return midIndex;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(BinarySearch)(unsigned int *, unsigned long, unsigned long,\n                        unsigned long);\n\nlong long BinarySearch(unsigned int *a0, unsigned long a1, unsigned long a2,\n                       unsigned long a3) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned int v1;  // [bp-0x10]\n  unsigned int v2;  // [bp-0xc]\n  unsigned long v4; // rax\n\n  if ((unsigned int)a2 > (unsigned int)a3)\n    return 4294967295;\n  v2 = (unsigned int)a3 - (unsigned int)a2 + 1;\n  v1 = (unsigned int)a3 + (unsigned int)a2 +\n           ((unsigned int)a3 + (unsigned int)a2 >> 31) >>\n       1;\n  v0 = a0[v1];\n  if ((unsigned int)a1 > v0) {\n    v4 = BinarySearch(a0, (unsigned int)a1, v1 + 1, (unsigned int)a3);\n    return v4;\n  } else if ((unsigned int)a1 < v0) {\n    v4 = BinarySearch(a0, (unsigned int)a1, (unsigned int)a2, v1 - 1);\n    return v4;\n  } else {\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Binary_Search/C/mariolamacchia/binarysearch.c"}
{"compilable":0,"function":"int gcd_division(int a, int b) {\n    while (b != 0)\n        {\n            int tmp = a;\n            a = b;\n            b = tmp % b;\n        }\n    return a;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long gcd_division_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x20]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0xc]\n  unsigned int v4; // eax\n\n  v1 = a0;\n  for (v0 = a1; v0; v0 = (v4 >> 31 CONCAT v4) / m v0 / 0x100000000) {\n    v2 = v1;\n    v1 = v0;\n    v4 = v2;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvcn991ag/gcd_division_name_conflict.c:26:38: error: expected ')'\n   26 |     for (v0 = a1; v0; v0 = (v4 >> 31 CONCAT v4) /m v0 / 0x100000000)\n      |                                      ^\n/tmp/tmpvcn991ag/gcd_division_name_conflict.c:26:28: note: to match this '('\n   26 |     for (v0 = a1; v0; v0 = (v4 >> 31 CONCAT v4) /m v0 / 0x100000000)\n      |                            ^\n/tmp/tmpvcn991ag/gcd_division_name_conflict.c:26:52: error: expected ')'\n   26 |     for (v0 = a1; v0; v0 = (v4 >> 31 CONCAT v4) /m v0 / 0x100000000)\n      |                                                    ^\n/tmp/tmpvcn991ag/gcd_division_name_conflict.c:26:9: note: to match this '('\n   26 |     for (v0 = a1; v0; v0 = (v4 >> 31 CONCAT v4) /m v0 / 0x100000000)\n      |         ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"int gcd_substraction(int a, int b) {\n    while (a != b)\n        {\n            if (a > b) {\n                a = a - b;\n            } else {\n                b = b - a;\n            }\n        }\n    return a;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long gcd_substraction_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc], Other Possible Types: unsigned long\n\n  v1 = a0;\n  v0 = a1;\n  while (v1 != v0) {\n    if (v1 > v0)\n      v1 -= v0;\n    else\n      v0 -= v1;\n  }\n  return (unsigned int)v1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":0,"function":"int gcd_recursive(int a, int b) {\n    return (b == 0) ? a : gcd_recursive(b, a % b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(gcd_recursive_name_conflict)(unsigned long, unsigned long);\n\nlong long gcd_recursive_name_conflict(unsigned long a0, unsigned long a1) {\n  if (!(unsigned int)a1)\n    return (unsigned int)a0;\n  return gcd_recursive_name_conflict((unsigned int)a1,\n                       ((unsigned int)a0 >> 31 CONCAT(unsigned int) a0) /\n                               m(unsigned int) a1 >>\n                           32);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqgn7afx0/gcd_recursive_name_conflict.c:22:68: error: expected ')'\n   22 |     return gcd_recursive_name_conflict((unsigned int)a1, ((unsigned int)a0 >> 31\nCONCAT (unsigned int)a0) /m (unsigned int)a1 >> 32); | ^\n/tmp/tmpqgn7afx0/gcd_recursive_name_conflict.c:22:44: note: to match this '('\n   22 |     return gcd_recursive_name_conflict((unsigned int)a1, ((unsigned int)a0 >> 31\nCONCAT (unsigned int)a0) /m (unsigned int)a1 >> 32); | ^\n/tmp/tmpqgn7afx0/gcd_recursive_name_conflict.c:22:97: error: expected expression\n   22 |     return gcd_recursive_name_conflict((unsigned int)a1, ((unsigned int)a0 >> 31\nCONCAT (unsigned int)a0) /m (unsigned int)a1 >> 32); | ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":0,"function":"bool test_doors(int doors[]) {\n    for (int i = 0; i <= 99; ++i) {\n        if (doors[i] && (int)sqrt(doors[i]) % 1 != 0)\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble(sqrt)(double);\n\nlong long test_doors_name_conflict(unsigned int *a0) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  for (v0 = 0; v0 <= 99; v0 += 1) {\n    if (a0[v0])\n      sqrt(a0[v0]);\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/100_Doors_Problem/C/kennyledet/100-Doors.c"}
{"compilable":1,"function":"int length(char *string) {\n    int count = 0;\n    while (string[count++] != '\\x00')\n        ;\n    return --count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long length_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n  char *v2;        // rax\n\n  v0 = 0;\n  do {\n    v2 = v0;\n    v0 = (unsigned int)v2 + 1;\n  } while (v2[a0]);\n  v0 -= 1;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int exponentiation(int base, int exp) {\n    if (!exp) {\n        return 1;\n    }\n    int total = base;\n    int i = 1;\n    while (i++ < exp)\n        {\n            total *= base;\n        }\n    return total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long exponentiation_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n  unsigned int v4; // eax\n\n  if (!(unsigned int)a1)\n    return 1;\n  v1 = a0;\n  v0 = 1;\n  while (true) {\n    v4 = v0;\n    v0 = v4 + 1;\n    if ((unsigned int)a1 <= v4)\n      break;\n    v1 = (unsigned int)a0 * v1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":0,"function":"int parse(char *number) {\n    int size = length(number);\n    int exp = size - 1;\n    int total = 0;\n    int i;\n    for (i = 0; i < size; i++) {\n        if (number[i] >= '0' && number[i] <= '9') {\n            total += (number[i] - 48) * exponentiation(10, exp--);\n        }\n    }\n    return total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(length)(long long);\nlong long(exponentiation)(long long, long long);\n\nlong long parse_name_conflict(char *a0) {\n  unsigned int v0;        // [bp-0x20]\n  unsigned int v1;        // [bp-0x1c]\n  unsigned int v2;        // [bp-0x18]\n  unsigned int v3;        // [bp-0x14]\n  unsigned long v4;       // [bp-0x10]\n  char v5;                // [bp-0x8]\n  unsigned long long v7;  // rbp\n  unsigned long v8;       // rbx\n  unsigned long long v9;  // rax\n  unsigned long long v11; // rbx\n\n  v7 = &v5;\n  v4 = v8;\n  v0 = length(a0);\n  v3 = v0 - 1;\n  v2 = 0;\n  for (v1 = 0; v1 < v0; v1 += 1) {\n    if (a0[v1] > 47 && a0[v1] <= 57) {\n      v9 = v3;\n      v3 = (unsigned int)v9 - 1;\n      v2 += (a0[v1] - 48) * (int)exponentiation(10, v9);\n    }\n  }\n  v11 = v4;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int linear_search(int arr[], int size, int element) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long linear_search_name_conflict(unsigned int *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    if ((unsigned int)a2 == a0[v0])\n      return v0;\n  }\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Linear_Search/C/jay754/linear_search.c"}
{"compilable":1,"function":"unsigned long long factorial(int number) {\n    if (0 == number)\n        return 1;\n    else\n        return number * factorial(number - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(factorial_name_conflict)(unsigned long);\n\nlong long factorial_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned long long v4; // rbx\n\n  v0 = v2;\n  v4 = v0;\n  return (!(unsigned int)a0 ? (unsigned int)a0 * factorial_name_conflict((unsigned int)a0 - 1)\n                            : 1);\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Factorial/C/harshasrisri/factorial.c"}
{"compilable":0,"function":"int fibo_r() {\n    static int a = 0, b = 1, count = 0;\n    if (0 == count) {\n        count++;\n        return a;\n    }\n    if (1 == count) {\n        count++;\n        return b;\n    }\n    return (b > a) ? (a += b) : (b += a);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int __TMC_END__;\nextern unsigned int a.1;\nextern unsigned int b.0;\n\nlong long fibo_r_name_conflict() {\n  if (!__TMC_END__) {\n    __TMC_END__ = __TMC_END__ + 1;\n    return a.1;\n  } else if (__TMC_END__ == 1) {\n    __TMC_END__ = __TMC_END__ + 1;\n    return b.0;\n  } else if (b.0 <= a.1) {\n    b.0 = a.1 + b.0;\n    return b.0;\n  } else {\n    a.1 = b.0 + a.1;\n    return a.1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:18:22: error: expected ';' after top level declarator\n   18 | extern unsigned int a.1;\n      |                      ^\n      |                      ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern unsigned int b.0;\n      |                      ^\n      |                      ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:26:17: error: expected ';' after return statement\n   26 |         return a.1;\n      |                 ^\n      |                 ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:31:17: error: expected ';' after return statement\n   31 |         return b.0;\n      |                 ^\n      |                 ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:33:15: error: expected ')'\n   33 |     else if (b.0 <= a.1)\n      |               ^\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:33:13: note: to match this '('\n   33 |     else if (b.0 <= a.1)\n      |             ^\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:35:10: error: expected ';' after expression\n   35 |         b.0 = a.1 + b.0;\n      |          ^\n      |          ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:35:13: error: expression is not assignable\n   35 |         b.0 = a.1 + b.0;\n      |          ~~ ^\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:35:16: error: expected ';' after expression\n   35 |         b.0 = a.1 + b.0;\n      |                ^\n      |                ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:35:22: error: expected ';' after expression\n   35 |         b.0 = a.1 + b.0;\n      |                      ^\n      |                      ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:36:17: error: expected ';' after return statement\n   36 |         return b.0;\n      |                 ^\n      |                 ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:40:10: error: expected ';' after expression\n   40 |         a.1 = b.0 + a.1;\n      |          ^\n      |          ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:40:13: error: expression is not assignable\n   40 |         a.1 = b.0 + a.1;\n      |          ~~ ^\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:40:16: error: expected ';' after expression\n   40 |         a.1 = b.0 + a.1;\n      |                ^\n      |                ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:40:22: error: expected ';' after expression\n   40 |         a.1 = b.0 + a.1;\n      |                      ^\n      |                      ;\n/tmp/tmp8lq3d6jz/fibo_r_name_conflict.c:41:17: error: expected ';' after return statement\n   41 |         return a.1;\n      |                 ^\n      |                 ;\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Fibonacci_series/C/harshasrisri/fibo_r.c"}
{"compilable":1,"function":"bool isSorted(int a[], int size) {\n    for (int i = 1; i < size; i++) {\n        if (a[i] < a[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isSorted_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a1; v0 += 1) {\n    if (a0[v0] < a0[1 + v0])\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Bogosort/C/jonathanlebron/bogo_sort.c"}
{"compilable":0,"function":"bool test_insertion_sort(int *sequence, int sequence_length) {\n    for (int i = 1; i < sequence_length; i++) {\n        if (sequence[i] < sequence[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test_insertion_sort_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a1; v0 += 1) {\n    if (a0[v0] < a0[1 + v0])\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Insertion_Sort/C/kennyledet/insertion_sort.c"}
{"compilable":0,"function":"in_port_t get_port(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return ntohs(((struct sockaddr_in *)sa)->sin_port);\n      case 10:\n        return ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(ntohs)(unsigned short);\n\nlong long get_port_name_conflict(unsigned short a0[2]) {\n  unsigned int v1; // eax\n  void *v2;        // rax, Other Possible Types: unsigned long\n\n  v1 = a0[0];\n  if (v1 == 2) {\n    (unsigned short)v2 = ntohs(a0[1]);\n    return v2;\n  } else if (v1 == 10) {\n    (unsigned short)v2 = ntohs(a0[1]);\n    return v2;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7e98t49k/get_port_name_conflict.c:26:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 26 |         (unsigned short)v2 = ntohs(a0[1]); |\n^~~~~~~~~~~~~~~~~~ ~ /tmp/tmp7e98t49k/get_port_name_conflict.c:31:9: error: assignment to cast\nis illegal, lvalue casts are not supported 31 |         (unsigned short)v2 =\nntohs(a0[1]); |         ^~~~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int is_addr_any(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return (((struct sockaddr_in *)sa)->sin_addr.s_addr == htonl(((in_addr_t)0)));\n      case 10:\n        return !memcmp(&((struct sockaddr_in6 *)sa)->sin6_addr, &in6addr_any, sizeof (in6addr_any));\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(htonl)(unsigned int);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_0;\n\nextern void in6addr_any @GLIBC_2.2.5;\n\nlong long is_addr_any_name_conflict(struct_0 *a0) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned int v3;       // eax\n  unsigned long long v5; // rbx\n\n  v0 = v2;\n  v3 = a0->field_0;\n  v5 = v0;\n  return (v3 == 2\n              ? (v3 == 10 ? 0 : !memcmp(a0 + 1, &in6addr_any @GLIBC_2.2.5, 16))\n              : a0->field_4 == htonl(0));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpovu8015e/is_addr_any_name_conflict.c:24:24: error: expected ';' after top level\ndeclarator 24 | extern void in6addr_any@GLIBC_2.2.5; |                        ^\n      |                        ;\n/tmp/tmpovu8015e/is_addr_any_name_conflict.c:36:67: error: expected ')'\n   36 |     return (v3 == 2 ? (v3 == 10 ? 0 : !memcmp(a0 + 1,\n&in6addr_any@GLIBC_2.2.5, 16)) : a0->field_4 == htonl(0)); | ^\n/tmp/tmpovu8015e/is_addr_any_name_conflict.c:36:46: note: to match this '('\n   36 |     return (v3 == 2 ? (v3 == 10 ? 0 : !memcmp(a0 + 1,\n&in6addr_any@GLIBC_2.2.5, 16)) : a0->field_4 == htonl(0)); | ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int sed_the_buffer(int size, int *live) {\n    int i;\n    memmove(b2, buf, size);\n    for (i = 0; i < rules;) {\n        if (rule_live[i] == 0) {\n            i++;\n            break;\n        }\n        if (replace(b2, size, &rule[i].expression, rule[i].torig)) {\n            printf(\"\\033[32m[+] Replacing %s with %s\\n\\033[0m\", rule[i].forig, rule[i].torig);\n            rule_live[i]--;\n        }\n        i++;\n    }\n    return size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(replace)(long long, long long, long long, long long);\n\nextern void b2;\nextern void buf;\nextern char g_405628;\nextern unsigned long long rule;\nextern unsigned long long rule_live;\nextern unsigned int rules;\n\nlong long sed_the_buffer_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v4; // rcx\n  unsigned int *v5;      // rax\n  unsigned int v7;       // ecx\n\n  v0 = a1;\n  memcpy(&b2, &buf, (unsigned int)a0);\n  for (v1 = 0; v1 < rules; v1 += 1) {\n    if (*((int *)(rule_live + (v1 << 2)))) {\n      v4 = *((long long *)((3 * v1 * 4 + v1) * 8 + rule + 24));\n      v5 = v1;\n      if ((int)replace(&b2, (unsigned int)a0,\n                       (0x8 * v5 + 0x4 * v5 + (char *)v5 << 3) + rule + 40,\n                       v4)) {\n        v7 = *((long long *)((3 * v1 * 4 + v1) * 8 + rule + 24));\n        printf(&g_405628,\n               (int)*((long long *)((3 * v1 * 4 + v1) * 8 + rule + 16)), v7);\n        *((int *)(rule_live + v1 * 4)) = *((int *)(rule_live + v1 * 4)) - 1;\n      }\n    } else {\n      v1 += 1;\n      return (unsigned int)a0;\n    }\n  }\n  return (unsigned int)a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvioymkw4/sed_the_buffer_name_conflict.c:41:58: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 41 |             if ((int)replace(&b2,\n(unsigned int)a0, (0x8 * v5 + 0x4 * v5 + (char *)v5 << 3) + rule + 40, v4)) |\n~~~ ^ ~~ /tmp/tmpvioymkw4/sed_the_buffer_name_conflict.c:41:69: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 41 |             if\n((int)replace(&b2, (unsigned int)a0, (0x8 * v5 + 0x4 * v5 + (char *)v5 << 3) +\nrule + 40, v4)) | ~~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(open)(char *, int, unsigned short);\nint(fcntl)(int, int, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern unsigned int xpmem_fd;\n\nlong long xpmem_init_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  stat v0; // [bp-0x98]\n  char v1; // [bp-0x80]\n\n  if (!stat(\"/dev/xpmem\", &v0) && ((short)*((int *)&v1) & 0xf000) == 0x2000) {\n    xpmem_fd = open(\"/dev/xpmem\", 2, a2);\n    if (xpmem_fd != -1 && fcntl(xpmem_fd, 2) != -1)\n      return 0;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpexdfwgr3/xpmem_init_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpexdfwgr3/xpmem_init_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpexdfwgr3/xpmem_init_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpexdfwgr3/xpmem_init_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_remove(unsigned long a0, unsigned long a1,\n                       unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return ((int)xpmem_ioctl(30722, &v0, a2) == -1 ? 0 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_release(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return ((int)xpmem_ioctl(30724, &v0, a2) == -1 ? 0 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_version(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  return xpmem_ioctl(0x7800, 0, a2);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(open)(char *, int, unsigned short);\nint(fcntl)(int, int, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern unsigned int xpmem_fd;\n\nlong long xpmem_init_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  stat v0; // [bp-0x98]\n  char v1; // [bp-0x80]\n\n  if (!stat(\"/dev/xpmem\", &v0) && ((short)*((int *)&v1) & 0xf000) == 0x2000) {\n    xpmem_fd = open(\"/dev/xpmem\", 2, a2);\n    if (xpmem_fd != -1 && fcntl(xpmem_fd, 2) != -1)\n      return 0;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo0jdh7f2/xpmem_init_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpo0jdh7f2/xpmem_init_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpo0jdh7f2/xpmem_init_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpo0jdh7f2/xpmem_init_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_remove(unsigned long a0, unsigned long a1,\n                       unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return ((int)xpmem_ioctl(30722, &v0, a2) == -1 ? 0 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_release(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return ((int)xpmem_ioctl(30724, &v0, a2) == -1 ? 0 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_version(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  return xpmem_ioctl(0x7800, 0, a2);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(open)(char *, int, unsigned short);\nint(fcntl)(int, int, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern unsigned int xpmem_fd;\n\nlong long xpmem_init_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  stat v0; // [bp-0x98]\n  char v1; // [bp-0x80]\n\n  if (!stat(\"/dev/xpmem\", &v0) && ((short)*((int *)&v1) & 0xf000) == 0x2000) {\n    xpmem_fd = open(\"/dev/xpmem\", 2, a2);\n    if (xpmem_fd != -1 && fcntl(xpmem_fd, 2) != -1)\n      return 0;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3n7tlxpl/xpmem_init_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmp3n7tlxpl/xpmem_init_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmp3n7tlxpl/xpmem_init_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmp3n7tlxpl/xpmem_init_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_remove(unsigned long a0, unsigned long a1,\n                       unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return ((int)xpmem_ioctl(30722, &v0, a2) == -1 ? 0 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_release(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return ((int)xpmem_ioctl(30724, &v0, a2) == -1 ? 0 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_version(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  return xpmem_ioctl(0x7800, 0, a2);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int RateStatement(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Agree\\n2. Nuetral\\n3. Disagree\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += agree;\n        return 1;\n      case 2:\n        *score += neutral;\n        return 1;\n      case 3:\n        *score += disagree;\n      default:\n        return 0;\n    }\n    printf(\"\\n\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long RateStatement_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n  unsigned int v2; // eax\n\n  v0 = 0;\n  puts(\"1. Agree\\n2. Nuetral\\n3. Disagree\");\n  printf(\"%s: \", (unsigned int)a0);\n  __isoc99_scanf(\"%d\", (unsigned int)&v0);\n  v2 = v0;\n  if (v2 == 3) {\n    *(a1) = -5 + *(a1);\n  } else if (v2 <= 3) {\n    if (v2 == 1) {\n      *(a1) = 10 + *(a1);\n      return 1;\n    } else if (v2 == 2) {\n      *(a1) = 5 + *(a1);\n      return 1;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":0,"function":"int AskQuestion(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Yes\\n2. No\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += yes;\n        printf(\"\\n\\n\");\n        return 1;\n      case 2:\n        *score += no;\n        printf(\"\\n\\n\");\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long AskQuestion_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n  unsigned int v2; // eax\n\n  v0 = 0;\n  puts(\"1. Yes\\n2. No\");\n  printf(\"%s: \", (unsigned int)a0);\n  __isoc99_scanf(\"%d\", (unsigned int)&v0);\n  v2 = v0;\n  if (v2 == 1) {\n    *(a1) = 15 + *(a1);\n    puts(\"\\n\");\n    return 1;\n  }\n  if (v2 != 2)\n    return 0;\n  *(a1) = -5 + *(a1);\n  puts(\"\\n\");\n}\n","pass":0,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\nlong long(cleanup)();\n\nextern unsigned long long done;\nextern unsigned int max;\nextern unsigned int root;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long beenhere(unsigned long a0, unsigned long a1, unsigned long a2,\n                   unsigned long a3, unsigned long a4) {\n  unsigned int v0;        // [bp-0x48]\n  unsigned int v1;        // [bp-0x2c]\n  char *v2;               // [bp-0x28]\n  unsigned long long *v3; // [bp-0x20]\n  unsigned long v4;       // [bp-0x18]\n  unsigned long v5;       // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = a3;\n  v3 = (unsigned int)a1 +\n       (max - 1) *\n           (((unsigned int)a2 >> 1) +\n            ((unsigned int)a0 - 2 >> 1) * ((unsigned int)a0 - 1 >> 1) - 1) -\n       1;\n  v0 -= (int)(1 << ((char)root & 31));\n  v2 = (unsigned int)a4 + (v0 >> 3);\n  v2 = (unsigned int)a4 + (v2 * (v2 + 1) >> 1);\n  v1 = 1 << ((char)(v0 & 7) & 31);\n  v5 = *((long long *)(done + v3 * 16));\n  if (v2 < v5 && (v2[*((long long *)(done + (v3 << 4) + 8))] & v1))\n    return 1;\n  if (v2 >= v5) {\n    if (v5) {\n      do {\n        v5 *= 2;\n      } while (v2 >= v5);\n      v4 = realloc(*((long long *)(done + v3 * 16 + 8)), v5);\n      if (v4)\n        memset(v4 + *((long long *)(done + v3 * 16)), 0,\n               v5 - *((long long *)(done + v3 * 16)));\n    } else {\n      for (v5 = 1 << ((char)((unsigned int)a1 - root) & 31); v2 >= v5; v5 *= 2)\n        ;\n      v4 = calloc(v5, 1);\n    }\n    if (!v4) {\n      fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40,\n             stderr @GLIBC_2.2.5);\n      cleanup();\n      exit(1); /* do not return */\n    }\n    *((unsigned long *)(v3 * 16 + done)) = v5;\n    *((unsigned long *)(v3 * 16 + done + 8)) = v4;\n  }\n  v2[*((long long *)(done + v3 * 16 + 8))] =\n      v2[*((long long *)(done + v3 * 16 + 8))] | v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppdjp1ouh/beenhere.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmppdjp1ouh/beenhere.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmppdjp1ouh/beenhere.c:37:33: error: invalid operands to binary expression\n('char *' and 'char *') 37 |     v2 = (unsigned int)a4 + (v2 * (v2 + 1) >> 1);\n      |                              ~~ ^ ~~~~~~~~\n/tmp/tmppdjp1ouh/beenhere.c:39:36: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 39 |     v5 = *((long long *)(done + v3 *\n16)); |                                 ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:40:51: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 40 |     if (v2 < v5 && (v2[*((long long\n*)(done + (v3 << 4) + 8))] & v1)) | ~~ ^  ~ /tmp/tmppdjp1ouh/beenhere.c:50:52:\nerror: invalid operands to binary expression ('unsigned long long *' and 'int')\n   50 |             v4 = realloc(*((long long *)(done + v3 * 16 + 8)), v5);\n      |                                                 ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:52:55: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 52 |                 memset(v4 + *((long long\n*)(done + v3 * 16)), 0, v5 - *((long long *)(done + v3 * 16))); | ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:52:97: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 52 |                 memset(v4 + *((long long\n*)(done + v3 * 16)), 0, v5 - *((long long *)(done + v3 * 16))); | ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:61:78: error: expected ')'\n   61 |             fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmppdjp1ouh/beenhere.c:61:19: note: to match this\n'(' 61 |             fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmppdjp1ouh/beenhere.c:65:32:\nerror: invalid operands to binary expression ('unsigned long long *' and 'int')\n   65 |         *((unsigned long *)(v3 * 16 + done)) = v5;\n      |                             ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:66:32: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 66 |         *((unsigned long *)(v3 * 16 +\ndone + 8)) = v4; |                             ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:68:34: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 68 |     v2[*((long long *)(done + v3 * 16 +\n8))] = v2[*((long long *)(done + v3 * 16 + 8))] | v1; | ~~ ^ ~~\n/tmp/tmppdjp1ouh/beenhere.c:68:77: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 68 |     v2[*((long long *)(done + v3 * 16 +\n8))] = v2[*((long long *)(done + v3 * 16 + 8))] | v1; | ~~ ^ ~~ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Sigil-Ebook_Sigil/3rdparty/zlib/examples/enough.c"}
{"compilable":0,"function":"int generateRandom(int min, int max) {\n    return rand() % (max - min + 1) + min;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long generateRandom_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = a0;\n  (unsigned int)v2 = rand();\n  return (unsigned int)a0 + (((unsigned int)v2 >> 31 CONCAT(unsigned int) v2) /\n                                 m((unsigned int)a1 - v0 + 1) >>\n                             32);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_23zii1m/generateRandom_name_conflict.c:24:5: error: assignment to cast is illegal,\nlvalue casts are not supported 24 |     (unsigned int)v2 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmp_23zii1m/generateRandom_name_conflict.c:25:56: error: expected ')'\n   25 |     return (unsigned int)a0 + (((unsigned int)v2 >> 31 CONCAT (unsigned\nint)v2) /m ((unsigned int)a1 - v0 + 1) >> 32); | ^\n/tmp/tmp_23zii1m/generateRandom_name_conflict.c:25:32: note: to match this '('\n   25 |     return (unsigned int)a0 + (((unsigned int)v2 >> 31 CONCAT (unsigned\nint)v2) /m ((unsigned int)a1 - v0 + 1) >> 32); | ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int getEmptyCells(struct Pos empty[], struct Square m[][4]) {\n    int i, j;\n    int n = 0;\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            if (!m[i][j].value) {\n                struct Pos temp;\n                temp.x = i;\n                temp.y = j;\n                empty[n++] = temp;\n            }\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long getEmptyCells_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x1c]\n  unsigned int v1;        // [bp-0x18]\n  unsigned int v2;        // [bp-0x14]\n  unsigned int v3;        // [bp-0x10]\n  unsigned int v4;        // [bp-0xc]\n  unsigned long long *v6; // rax\n\n  v2 = 0;\n  for (v4 = 0; v4 <= 3; v4 += 1) {\n    for (v3 = 0; v3 <= 3; v3 += 1) {\n      if (!*((int *)((v4 << 5) + a1 + (v3 << 3)))) {\n        v0 = v4;\n        v1 = v3;\n        v6 = v2;\n        v2 = (unsigned int)v6 + 1;\n        *((long long *)(v6 * 8 + a0)) = *((long long *)&v0);\n      }\n    }\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb1hjnrj1/getEmptyCells_name_conflict.c:37:36: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 37 |                 *((long long\n*)(v6 * 8 + a0)) = *((long long *)&v0); |                                 ~~ ^ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int playerWon(struct Square m[][4]) {\n    int i, j;\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            if (m[i][j].value == 2048)\n                return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long playerWon_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  for (v1 = 0; v1 <= 3; v1 += 1) {\n    for (v0 = 0; v0 <= 3; v0 += 1) {\n      if (*((int *)((v1 << 5) + a0 + (v0 << 3))) == 0x800)\n        return 1;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int readMove() {\n    int move, validMove = 0;\n    while (!validMove)\n        {\n            printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", RIGHT, DOWN, LEFT, UP);\n            scanf(\"%d\", &move);\n            if (move >= 0 && move < 3)\n                validMove = 1;\n        }\n    return move;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long readMove_name_conflict() {\n  char v0;         // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  while (true) {\n    do {\n      do {\n        if (v1)\n          return *((int *)&v0);\n        printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", 0, 1,\n               2, 3);\n        __isoc99_scanf(\"%d\", (unsigned int)&v0);\n      } while (*((int *)&v0) < 0);\n    } while (*((int *)&v0) > 2);\n    v1 = 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int gpio_export(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/export\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_export_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x58]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = open(\"/sys/class/gpio/export\", 1, a2);\n  if (v2 < 0) {\n    perror(\"gpio/export\");\n    return v2;\n  }\n  v1 = snprintf(&v0, 64, \"%d\", (unsigned int)a0);\n  write(v2, &v0, v1);\n  close(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpko3l9ers/gpio_export_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpko3l9ers/gpio_export_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_unexport(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/unexport\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_unexport_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x58]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = open(\"/sys/class/gpio/unexport\", 1, a2);\n  if (v2 < 0) {\n    perror(\"gpio/export\");\n    return v2;\n  }\n  v1 = snprintf(&v0, 64, \"%d\", (unsigned int)a0);\n  write(v2, &v0, v1);\n  close(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpphec4f5e/gpio_unexport_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpphec4f5e/gpio_unexport_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_set_dir(unsigned int gpio, char *ident, unsigned int out_flag) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/direction\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/direction\");\n        return fd;\n    }\n    if (out_flag)\n        write(fd, \"out\", 4);\n    else\n        write(fd, \"in\", 3);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_set_dir_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x58]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/direction\",\n                (unsigned int)a0, (unsigned int)a1);\n  v1 = open(&v0, 1, 8264);\n  if (v1 < 0) {\n    perror(\"gpio/direction\");\n    return v1;\n  }\n  if (!(unsigned int)a2)\n    write(v1, \"in\", 3);\n  else\n    write(v1, \"out\", 4);\n  close(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyweskjtd/gpio_set_dir_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpyweskjtd/gpio_set_dir_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_set_value(unsigned int gpio, char *ident, unsigned int value) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-value\");\n        return fd;\n    }\n    if (value)\n        write(fd, \"1\", 2);\n    else\n        write(fd, \"0\", 2);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_set_value_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x58]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/value\", (unsigned int)a0,\n                (unsigned int)a1);\n  v1 = open(&v0, 1, 8328);\n  if (v1 < 0) {\n    perror(\"gpio/set-value\");\n    return v1;\n  }\n  if (!(unsigned int)a2)\n    write(v1, \"0\", 2);\n  else\n    write(v1, \"1\", 2);\n  close(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwcpy29r5/gpio_set_value_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpwcpy29r5/gpio_set_value_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_get_value(unsigned int gpio, char *ident, unsigned int *value) {\n    int fd, len;\n    char buf[64];\n    char ch;\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0);\n    if (fd < 0) {\n        perror(\"gpio/get-value\");\n        return fd;\n    }\n    read(fd, &ch, 1);\n    if (ch != '0') {\n        *value = 1;\n    } else {\n        *value = 0;\n    }\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(read)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_get_value_name_conflict(unsigned long a0, unsigned long a1, unsigned int *a2) {\n  char v0;         // [bp-0x59]\n  char v1;         // [bp-0x58]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = snprintf(&v1, 64, \"/sys/class/gpio/gpio%d_%s/value\", (unsigned int)a0,\n                (unsigned int)a1);\n  v2 = open(&v1, 0, 8328);\n  if (v2 < 0) {\n    perror(\"gpio/get-value\");\n    return v2;\n  }\n  read(v2, &v0, 1);\n  if (v0 != 48)\n    *(a2) = 1;\n  else\n    *(a2) = 0;\n  close(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpiiu_basy/gpio_get_value_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpiiu_basy/gpio_get_value_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_set_edge(unsigned int gpio, char *ident, char *edge) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/edge\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-edge\");\n        return fd;\n    }\n    write(fd, edge, strlen(edge) + 1);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_set_edge_name_conflict(unsigned long a0, unsigned long a1, void *a2) {\n  char v0;         // [bp-0x58]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/edge\", (unsigned int)a0,\n                (unsigned int)a1);\n  v1 = open(&v0, 1, 8400);\n  if (v1 < 0) {\n    perror(\"gpio/set-edge\");\n    return v1;\n  }\n  write(v1, a2, strlen(a2) + 1);\n  close(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp19ipql3i/gpio_set_edge_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp19ipql3i/gpio_set_edge_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_fd_open(unsigned int gpio, char *ident) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0 | 2048);\n    if (fd < 0) {\n        perror(\"gpio/fd_open\");\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long gpio_fd_open_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;         // [bp-0x58]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/value\", (unsigned int)a0,\n                (unsigned int)a1);\n  v1 = open(&v0, 0x800, 8328);\n  if (v1 < 0) {\n    perror(\"gpio/fd_open\");\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi3uiuwzp/gpio_fd_open_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpi3uiuwzp/gpio_fd_open_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_fd_close(int fd) {\n    return close(fd);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long gpio_fd_close_name_conflict(unsigned long a0) { return close(a0); }\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int hello(void) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hello_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/src/hello.c"}
{"compilable":0,"function":"int UnityEnd(void) {\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrint(UnityStrBreaker);\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrintNumber((_U_SINT)(Unity.NumberOfTests));\n    UnityPrint(UnityStrResultsTests);\n    UnityPrintNumber((_U_SINT)(Unity.TestFailures));\n    UnityPrint(UnityStrResultsFailures);\n    UnityPrintNumber((_U_SINT)(Unity.TestIgnores));\n    UnityPrint(UnityStrResultsIgnored);\n    {\n        putchar('\\n');\n    }\n    ;\n    if (Unity.TestFailures == 0U) {\n        UnityPrintOk();\n    } else {\n        UnityPrintFail();\n    }\n    {\n        putchar('\\n');\n    }\n    ;\n    ;\n    return (int)(Unity.TestFailures);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(putchar)(int);\nlong long(UnityPrint)(long long);\nlong long(UnityPrintNumber)(long long);\nlong long(UnityPrintOk)();\nlong long(UnityPrintFail)();\n\nextern unsigned long long g_4075b8;\nextern unsigned long long g_4075c0;\nextern unsigned long long g_4075c8;\n\nlong long UnityEnd_name_conflict() {\n  putchar(10);\n  UnityPrint(\"-----------------------\");\n  putchar(10);\n  UnityPrintNumber(g_4075b8);\n  UnityPrint(\" Tests \");\n  UnityPrintNumber(g_4075c0);\n  UnityPrint(\" Failures \");\n  UnityPrintNumber(g_4075c8);\n  UnityPrint(\" Ignored \");\n  putchar(10);\n  if (g_4075c0)\n    UnityPrintFail();\n  else\n    UnityPrintOk();\n  putchar(10);\n  return g_4075c0;\n}\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity.c"}
{"compilable":0,"function":"static int selected(const char *filter, const char *name) {\n    if (filter == 0)\n        return 1;\n    return strstr(name, filter) ? 1 : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long selected_name_conflict(char *a0, char *a1) { return (!a0 ? strstr(a1, a0) : 1); }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int testSelected(const char *test) {\n    return selected(UnityFixture.NameFilter, test);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(selected)(long long, long long);\n\nextern unsigned long long g_4070c8;\n\nlong long testSelected_name_conflict(unsigned long long a0) { return selected(g_4070c8, a0); }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int groupSelected(const char *group) {\n    return selected(UnityFixture.GroupFilter, group);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(selected)(long long, long long);\n\nextern unsigned long long g_4070d0;\n\nlong long groupSelected_name_conflict(unsigned long long a0) {\n  return selected(g_4070d0, a0);\n}\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityFailureCount(void) {\n    return Unity.TestFailures;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_4075c0;\n\nlong long UnityFailureCount_name_conflict() { return g_4075c0; }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityGetCommandLineOptions(int argc, const char *argv[]) {\n    int i;\n    UnityFixture.Verbose = 0;\n    UnityFixture.GroupFilter = 0;\n    UnityFixture.NameFilter = 0;\n    UnityFixture.RepeatCount = 1;\n    if (argc == 1)\n        return 0;\n    for (i = 1; i < argc;) {\n        if (strcmp(argv[i], \"-v\") == 0) {\n            UnityFixture.Verbose = 1;\n            i++;\n        } else if (strcmp(argv[i], \"-g\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.GroupFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-n\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.NameFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-r\") == 0) {\n            UnityFixture.RepeatCount = 2;\n            i++;\n            if (i < argc) {\n                if (*(argv[i]) >= '0' && *(argv[i]) <= '9') {\n                    UnityFixture.RepeatCount = atoi(argv[i]);\n                    i++;\n                }\n            }\n        } else {\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4070d0; // add global variable by heuristics\nint g_4070c8; // add global variable by heuristics\nint g_4070d0; // add global variable by heuristics\nint g_4070c8; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(atoi)(char *);\n\nextern unsigned int UnityFixture;\nextern unsigned int g_4070c4;\nextern struct_0 *g_4070c8;\nextern struct_0 *g_4070d0;\n\nlong long UnityGetCommandLineOptions_name_conflict(unsigned long a0, struct struct_0 **a1) {\n  unsigned int v0; // [bp-0xc]\n\n  UnityFixture = 0;\n  g_4070d0 = 0;\n  g_4070c8 = 0;\n  g_4070c4 = 1;\n  if ((unsigned int)a0 == 1)\n    return 0;\n  v0 = 1;\n  while (true) {\n    do {\n      do {\n        while (true) {\n          while (true) {\n            while (true) {\n              while (true) {\n                if (v0 >= (unsigned int)a0)\n                  return 0;\n                if (strcmp(a1[v0], \"-v\"))\n                  break;\n                UnityFixture = 1;\n                v0 += 1;\n              }\n              if (strcmp(a1[v0], \"-g\"))\n                break;\n              v0 += 1;\n              if (v0 >= (unsigned int)a0)\n                return 1;\n              g_4070d0 = a1[v0];\n              v0 += 1;\n            }\n            if (strcmp(a1[v0], \"-n\"))\n              break;\n            v0 += 1;\n            if (v0 >= (unsigned int)a0)\n              return 1;\n            g_4070c8 = a1[v0];\n            v0 += 1;\n          }\n          if (strcmp(a1[v0], \"-r\")) {\n            v0 += 1;\n          } else {\n            g_4070c4 = 2;\n            v0 += 1;\n            if (v0 < (unsigned int)a0)\n              break;\n          }\n        }\n      } while (a1[v0]->field_0 <= 47);\n    } while (a1[v0]->field_0 > 57);\n    g_4070c4 = atoi(a1[v0]);\n    v0 += 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:24:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 24 | extern struct_0 *g_4070c8; | ^~~~~~~~ |\nstruct /tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:24:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:25:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 25 | extern struct_0 *g_4070d0; | ^~~~~~~~ |\nstruct /tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:25:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:87:28: error: incomplete\ndefinition of type 'struct struct_0' 87 |             } while (a1[v0]->field_0\n<= 47); |                      ~~~~~~^\n/tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:27:63: note: forward declaration\nof 'struct struct_0' 27 | long long UnityGetCommandLineOptions_name_conflict(unsigned long a0,\nstruct struct_0 **a1) | ^ /tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:88:24:\nerror: incomplete definition of type 'struct struct_0' 88 |         } while\n(a1[v0]->field_0 > 57); |                  ~~~~~~^\n/tmp/tmp3kgtpc7s/UnityGetCommandLineOptions_name_conflict.c:27:63: note: forward declaration\nof 'struct struct_0' 27 | long long UnityGetCommandLineOptions_name_conflict(unsigned long a0,\nstruct struct_0 **a1) | ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int print_jpeg_metadata(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 1;\n    int offset = 0;\n    long metadata_size = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            buf[offset++] = c;\n            if (offset >= bufsize)\n                buf_resize(0);\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        metadata_size = offset - 2;\n                        if (metadata_size != ftell(f) - 2 || metadata_size < 0) {\n                            fprintf(stderr, \"unexpected error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        err = 0;\n                        fprintf(stderr, \"%li %s\\n\", metadata_size, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        exit(1);\n                    }\n                    length -= 2;\n                    if (offset + length > bufsize) {\n                        buf_resize(length);\n                    }\n                    uint16_t segment = *((uint16_t *)(buf + offset - 4));\n                    fprintf(stderr, \"segment: %02X%02X, length: %d\\n\", segment & 255, segment >> 8, length);\n                    if (length) {\n                        if (fread(buf + offset, 1, length, f) != length) {\n                            fprintf(stderr, \"error: read error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        offset += length;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    long file_offset = ftell(output_file);\n    if (file_offset < 0) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    uint32_t file_offset32 = (uint32_t)file_offset;\n    if (fwrite(&file_offset32, 1, sizeof (file_offset32), index_file) != sizeof (file_offset32)) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    if (metadata_size) {\n        if (fwrite(buf, 1, metadata_size, output_file) != metadata_size) {\n            fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n            exit(1);\n        }\n    }\n    fflush(output_file);\n    return err;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(buf_resize)(long long);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern void *buf;\nextern unsigned long long bufsize;\nextern FILE_t *index_file;\nextern FILE_t *output_file;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long print_jpeg_metadata(char *a0) {\n  unsigned int v0;   // [bp-0x4c]\n  unsigned long v1;  // [bp-0x48]\n  unsigned short v2; // [bp-0x3a]\n  unsigned int v3;   // [bp-0x38]\n  unsigned int v4;   // [bp-0x34]\n  unsigned int v5;   // [bp-0x30]\n  unsigned int v6;   // [bp-0x2c]\n  FILE_t *v7;        // [bp-0x28]\n  void *v8;          // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v9;   // [bp-0x14]\n  unsigned int v10;  // [bp-0x10]\n  unsigned int v11;  // [bp-0xc]\n  char *v13;         // rax\n  char *v14;         // rax\n  char *v15;         // rax\n\n  v7 = &fopen(a0, \"r\")->_flags;\n  if (!v7) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: cannot open file %s\\n\",\n            (unsigned int)a0);\n    return *(__errno_location());\n  }\n  v11 = 0;\n  v10 = 1;\n  v9 = 0;\n  v8 = 0;\n  while (true) {\n    v6 = fgetc(v7);\n    if (v6 == -1)\n      break;\n    v13 = v9;\n    v9 = (unsigned int)v13 + 1;\n    *((char *)(v13 + buf)) = v6;\n    if (v9 >= bufsize)\n      buf_resize(0);\n    if (v11) {\n      v5 = (int)ftell(v7) - 2;\n      if (v6 != 216) {\n        if (((char)v6 & 240) != 224) {\n          v8 = v9 - 2;\n          if (!(v8 == ftell(v7) - 2) || !(!((char)(v8 - 0 >> 63)))) {\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"unexpected error while processing %s\\n\", (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          v10 = 0;\n          fprintf(stderr @GLIBC_2.2.5, \"%li %s\\n\", (unsigned int)v8,\n                  (unsigned int)a0);\n          break;\n        } else {\n          v4 = 0;\n          v3 = fgetc(v7);\n          if (v3 == -1) {\n            fprintf(stderr @GLIBC_2.2.5, \"error: unexpected end of file %s\\n\",\n                    (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          v14 = v9;\n          v9 = (unsigned int)v14 + 1;\n          *((char *)(v14 + buf)) = v3;\n          if (v9 >= bufsize)\n            buf_resize(0);\n          v4 += v3 * 0x100;\n          v3 = fgetc(v7);\n          if (v3 == -1) {\n            fprintf(stderr @GLIBC_2.2.5, \"error: unexpected end of file %s\\n\",\n                    (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          v15 = v9;\n          v9 = (unsigned int)v15 + 1;\n          *((char *)(v15 + buf)) = v3;\n          if (v9 >= bufsize)\n            buf_resize(0);\n          v4 += v3;\n          if (v4 <= 1) {\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"error: invalid segment length in %s\\n\", (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          v4 -= 2;\n          if (bufsize < v4 + v9)\n            buf_resize(v4);\n          v2 = *((short *)(-4 + (char *)buf + v9));\n          fprintf(stderr @GLIBC_2.2.5, \"segment: %02X%02X, length: %d\\n\", v2,\n                  (unsigned int)(v2 >> 8), v4);\n          if (v4) {\n            if (fread(buf + v9, 1, v4, v7) == v4) {\n              v9 += v4;\n            } else {\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"error: read error while processing %s\\n\",\n                      (unsigned int)a0);\n              exit(1); /* do not return */\n            }\n          }\n        }\n      }\n      v11 = 0;\n    } else if (v6 == 255) {\n      v11 = 1;\n    }\n  }\n  fclose(v7);\n  v1 = ftell(output_file);\n  if ((char)(v1 - 0 >> 63)) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: write error while processing %s\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  v0 = v1;\n  if (fwrite(&v0, 1, 4, index_file) != 4) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: write error while processing %s\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  if (v8 && fwrite(buf, 1, v8, output_file) != v8) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: write error while processing %s\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  fflush(output_file);\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:16:6: error: conflicting types for\n'fgetc' 16 | int (fgetc)(struct FILE_t { |      ^ /usr/include/stdio.h:513:12:\nnote: previous declaration is here 513 | extern int fgetc (FILE *__stream); | ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:105:7: error: conflicting types for\n'ftell' 105 | long (ftell)(struct FILE_t { |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:252:13: error: declaration of anonymous\nunion must be a definition 252 |             union <anon> { |             ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:255:22: error: type name requires a\nspecifier or qualifier 255 |             } __value; |                      ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:259:13: error: declaration of anonymous\nunion must be a definition 259 |             union <anon> { |             ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:262:22: error: type name requires a\nspecifier or qualifier 262 |             } __value; |                      ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:195:16: error: conflicting types for\n'fread' 195 | unsigned long (fread)(void*, unsigned long, unsigned long, struct\nFILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmprqkr98d2/print_jpeg_metadata.c:320:16: error:\nredefinition of '_IO_marker' 320 | typedef struct _IO_marker { | ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:326:16: error: redefinition of\n'_IO_codecvt' 326 | typedef struct _IO_codecvt { |                ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:330:16: error: redefinition of\n'_IO_wide_data' 330 | typedef struct _IO_wide_data { |                ^\n/tmp/tmprqkr98d2/print_jpeg_metadata.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata.c"}
{"compilable":0,"function":"int print_jpeg_metadata_size(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        printf(\"%d %s\\n\", ftell(f) - 2, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        err = 1;\n                        break;\n                    }\n                    if (length && fseek(f, length - 2, 1) < 0) {\n                        fprintf(stderr, \"error: i/o error with %s\\n\", filename);\n                        err = (*__errno_location());\n                        break;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    return err;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long print_jpeg_metadata_size(char *a0) {\n  unsigned int v0; // [bp-0x28]\n  unsigned int v1; // [bp-0x24]\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x1c]\n  FILE_t *v4;      // [bp-0x18]\n  unsigned int v5; // [bp-0x10]\n  unsigned int v6; // [bp-0xc]\n\n  v4 = &fopen(a0, \"r\")->_flags;\n  if (!v4) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: cannot open file %s\\n\",\n            (unsigned int)a0);\n    return *(__errno_location());\n  }\n  v6 = 0;\n  v5 = 0;\n  while (true) {\n    v3 = fgetc(v4);\n    if (v3 == -1)\n      break;\n    if (v6) {\n      v2 = (int)ftell(v4) - 2;\n      if (v3 != 216) {\n        if (((char)v3 & 240) != 224) {\n          printf(\"%d %s\\n\", (int)ftell(v4) - 2, (unsigned int)a0);\n          break;\n        } else {\n          v1 = 0;\n          v0 = fgetc(v4);\n          if (v0 == -1) {\n            break;\n          } else {\n            v1 += v0 * 0x100;\n            v0 = fgetc(v4);\n            if (v0 == -1)\n              break;\n            v1 += v0;\n            if (v1 <= 1) {\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"error: invalid segment length in %s\\n\",\n                      (unsigned int)a0);\n              v5 = 1;\n              break;\n            } else {\n              if (v1 && fseek(v4, v1 - 2, 1) < 0) {\n                fprintf(stderr @GLIBC_2.2.5, \"error: i/o error with %s\\n\",\n                        (unsigned int)a0);\n                v5 = *(__errno_location());\n                break;\n              }\n            }\n          }\n        }\n      }\n      v6 = 0;\n    } else if (v3 == 255) {\n      v6 = 1;\n    }\n  }\n  fclose(v4);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:16:6: error: conflicting types for\n'fgetc' 16 | int (fgetc)(struct FILE_t { |      ^ /usr/include/stdio.h:513:12:\nnote: previous declaration is here 513 | extern int fgetc (FILE *__stream); | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:162:13: error: declaration of\nanonymous union must be a definition 162 |             union <anon> { | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:169:13: error: declaration of\nanonymous union must be a definition 169 |             union <anon> { | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:105:7: error: conflicting types for\n'ftell' 105 | long (ftell)(struct FILE_t { |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:251:13: error: declaration of\nanonymous union must be a definition 251 |             union <anon> { | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:254:22: error: type name requires a\nspecifier or qualifier 254 |             } __value; |                      ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:258:13: error: declaration of\nanonymous union must be a definition 258 |             union <anon> { | ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:261:22: error: type name requires a\nspecifier or qualifier 261 |             } __value; |                      ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:194:6: error: conflicting types for\n'fseek' 194 | int (fseek)(struct FILE_t { |      ^ /usr/include/stdio.h:713:12:\nnote: previous declaration is here 713 | extern int fseek (FILE *__stream, long\nint __off, int __whence); |            ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:319:16: error: redefinition of\n'_IO_marker' 319 | typedef struct _IO_marker { |                ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:325:16: error: redefinition of\n'_IO_codecvt' 325 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:329:16: error: redefinition of\n'_IO_wide_data' 329 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpyidrb_zu/print_jpeg_metadata_size.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^ fatal error: too many errors\nemitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata_size.c"}
{"compilable":0,"function":"int mread(int s, char *bufp, unsigned int n) {\n    register unsigned int count = 0;\n    register int nread;\n    do {\n        nread = read(s, bufp, n - count);\n        numCalls++;\n        if (nread < 0) {\n            perror(\"ttcp_mread\");\n            return (-1);\n        }\n        if (nread == 0)\n            return ((int)count);\n        count += (unsigned int)nread;\n        bufp += nread;\n    } while (count < n);\n    return ((int)count);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nextern unsigned long long numCalls;\n\nlong long mread_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  void *v0;              // [bp-0x28], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n  void *v4;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v5; // rax\n\n  v3 = &v1;\n  v0 = a1;\n  v4 = 0;\n  while ((unsigned int)v5 >= 0) {\n    v5 = read(a0, v0, (unsigned int)a2 - v4);\n    numCalls = numCalls + 1;\n    if (!(unsigned int)v5)\n      return v4;\n    v4 += v5;\n    v0 += v5;\n    if ((unsigned int)v4 >= (unsigned int)a2)\n      return v4;\n  }\n  perror(\"ttcp_mread_name_conflict\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoltfmag8/mread_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpoltfmag8/mread_name_conflict.c:34:44: error: invalid operands to binary expression\n('unsigned int' and 'void *') 34 |         v5 = read(a0, v0, (unsigned int)a2 -\nv4); |                           ~~~~~~~~~~~~~~~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hynnet_openwrt-mt7620/feeds/packages/net/ttcp/ttcp.c"}
{"compilable":0,"function":"int testfunction(int arg1, int *arg2) {\n    return arg2[arg1];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long testfunction_name_conflict(unsigned long a0, unsigned long a1) {\n  return *((int *)(a1 + (unsigned int)a0 * 4));\n}\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test2function(void) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test2function_name_conflict() { return 0; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test4function(const int arg1) {\n    return carray[arg1];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char carray;\n\nlong long test4function_name_conflict(unsigned long a0) {\n  return *((int *)&(&carray)[4 * (unsigned int)a0]);\n}\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_duplicate_function() {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long possibly_duplicate_function_name_conflict() { return 0; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_dupli_function() {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long possibly_dupli_function_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_char_signed(int arg) {\n    if (arg == 189) {\n        return 0;\n    } else if (arg != -67) {\n        printf(\"Hmm, it seems 'char' is not eight bits wide on your machine.\\n\");\n        printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_char_signed_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 189)\n    return 0;\n  if ((unsigned int)a0 == -67)\n    return 1;\n  puts(\"Hmm, it seems 'char' is not eight bits wide on your machine.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n}\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_shifting_signed(long arg) {\n    long res = arg >> 4;\n    if (res == -133687308L) {\n        return 1;\n    }\n    res |= (~0L) << (32 - 4);\n    if (res == -133687308L) {\n        return 0;\n    }\n    printf(\"Right shift isn't acting as I expect it to.\\n\");\n    printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_shifting_signed_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0 >> 4;\n  if (v0 == -133687308)\n    return 1;\n  v0 |= -0x10000000;\n  if (v0 == -133687308)\n    return 0;\n  puts(\"Right shift isn't acting as I expect it to.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcpy_name_conflict(char *a0, char *a1) {\n  char *v0; // [bp-0x28], Other Possible Types: unsigned long\n  char *v1; // [bp-0x20], Other Possible Types: unsigned long\n  char *v2; // [bp-0x10]\n  char *v4; // rdx\n  char *v5; // rax\n\n  v1 = a0;\n  v0 = a1;\n  v2 = v1;\n  do {\n    v4 = v0;\n    v0 = v4 + 1;\n    v5 = v1;\n    v1 = v5 + 1;\n    *(v5) = *(v4);\n  } while (*(v5));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcmp_name_conflict(char *a0, char *a1) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = a0;\n  for (v0 = a1; *(v1); v0 += 1) {\n    if (*(v1) == *(v0))\n      v1 += 1;\n    else\n      return *((char *)v1) - *((char *)v0);\n  }\n  return *((char *)v1) - *((char *)v0);\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlen_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; a0[v0]; v0 += 1)\n    ;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strchr_name_conflict(char *a0, unsigned long a1) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  for (v0 = a0; *(v0); v0 += 1) {\n    if ((char)a1 == *(v0))\n      return v0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long gets_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;         // [bp-0x11]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  while ((unsigned int)a1 > v2 + 1) {\n    v1 = read(0, &v0, 1);\n    if (!(v1 > 0) || !(v0 != 10) || !(v0 != 13))\n      break;\n    if (v0 == 13)\n      break;\n  }\n  *((char *)(a0 + v2)) = 0;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nint(fstat_name_conflict)(\n    int, struct stat_name_conflict {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(close)(int);\n\ntypedef struct stat_name_conflict {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat_name_conflict;\n\nlong long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = open(a0, 0, a2);\n  if (v1 < 0)\n    return 4294967295;\n  v0 = fstat_name_conflict(v1, a1);\n  close(v1);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9nqfiqt1/stat_name_conflict.c:51:11: error: redefinition of 'stat_name_conflict' as different kind\nof symbol 51 | long long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) | ^\n/tmp/tmp9nqfiqt1/stat_name_conflict.c:49:3: note: previous definition is here\n   49 | } stat_name_conflict;\n      |   ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long atoi_name_conflict(char *a0) {\n  char *v0;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n  char *v4;        // rax\n\n  v0 = a0;\n  for (v1 = 0; *((char *)v0) > 47; v1 = *(v4) + 5 * v1 * 2 - 48) {\n    if (*((char *)v0) > 57)\n      return v1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcpy_name_conflict(char *a0, char *a1) {\n  char *v0; // [bp-0x28], Other Possible Types: unsigned long\n  char *v1; // [bp-0x20], Other Possible Types: unsigned long\n  char *v2; // [bp-0x10]\n  char *v4; // rdx\n  char *v5; // rax\n\n  v1 = a0;\n  v0 = a1;\n  v2 = v1;\n  do {\n    v4 = v0;\n    v0 = v4 + 1;\n    v5 = v1;\n    v1 = v5 + 1;\n    *(v5) = *(v4);\n  } while (*(v5));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcmp_name_conflict(char *a0, char *a1) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = a0;\n  for (v0 = a1; *(v1); v0 += 1) {\n    if (*(v1) == *(v0))\n      v1 += 1;\n    else\n      return *((char *)v1) - *((char *)v0);\n  }\n  return *((char *)v1) - *((char *)v0);\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlen_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; a0[v0]; v0 += 1)\n    ;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strchr_name_conflict(char *a0, unsigned long a1) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  for (v0 = a0; *(v0); v0 += 1) {\n    if ((char)a1 == *(v0))\n      return v0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long gets_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;         // [bp-0x11]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  while ((unsigned int)a1 > v2 + 1) {\n    v1 = read(0, &v0, 1);\n    if (!(v1 > 0) || !(v0 != 10) || !(v0 != 13))\n      break;\n    if (v0 == 13)\n      break;\n  }\n  *((char *)(a0 + v2)) = 0;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nint(fstat_name_conflict)(\n    int, struct stat_name_conflict {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(close)(int);\n\ntypedef struct stat_name_conflict {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat_name_conflict;\n\nlong long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = open(a0, 0, a2);\n  if (v1 < 0)\n    return 4294967295;\n  v0 = fstat_name_conflict(v1, a1);\n  close(v1);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbhiv5auz/stat_name_conflict.c:51:11: error: redefinition of 'stat_name_conflict' as different kind\nof symbol 51 | long long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) | ^\n/tmp/tmpbhiv5auz/stat_name_conflict.c:49:3: note: previous definition is here\n   49 | } stat_name_conflict;\n      |   ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":0,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long atoi_name_conflict(char *a0) {\n  char *v0;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n  char *v4;        // rax\n\n  v0 = a0;\n  for (v1 = 0; *((char *)v0) > 47; v1 = *(v4) + 5 * v1 * 2 - 48) {\n    if (*((char *)v0) <= 57) {\n      v4 = v0;\n      v0 = v4 + 1;\n    } else {\n      return v1;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/maxymania_open-xv6/ulib/ulib.c"}
{"compilable":1,"function":"static int pmu_can_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((5)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &arg) < 0 || arg != 1)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pmu_can_sleep_name_conflict(unsigned long a0) {\n  void *v0; // [bp-0x10]\n\n  v0 = 0;\n  if (ioctl(a0, 2148024837) >= 0 && v0 == 1)\n    return 0;\n  return 1;\n}\n","pass":1,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":1,"function":"static int pmu_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((0U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), arg) < 0)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pmu_sleep_name_conflict(unsigned long a0) {\n  void *v0; // [bp-0x10]\n\n  v0 = 0;\n  return (ioctl(a0, 0x4200) < 0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":0,"function":"off_t get_sig_offset(int orig) {\n    int pagesize = sysconf(_SC_PAGESIZE);\n    return (off_t)((sizeof(char) * pagesize) - (orig ? 20 : 10));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sysconf)(int);\n\nlong long get_sig_offset_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = sysconf(30);\n  return v0 - (!(unsigned int)a0 ? 20 : 10);\n}\n","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-reset-swap.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x18], Other Possible Types: unsigned long long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 1;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 0x1dcd6500 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzde2pi2z/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |             ^\n/tmp/tmpzde2pi2z/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |          ^\n/tmp/tmpzde2pi2z/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |                          ^\n      |                          ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) == -1) {\n      return 4294967295;\n    } else if (strcmp(a0, *((long long *)(vocab +\n                                          (*((int *)(vocab_hash + (v0 << 2)))\n                                           << 4) +\n                                          8)))) {\n      v0 = (0 CONCAT v0 + 1) / m 0x1dcd6500 >> 32;\n    } else {\n      return *((int *)(vocab_hash + v0 * 4));\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvuu7k4fb/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                     ^\n/tmp/tmpvuu7k4fb/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                  ^\n/tmp/tmpvuu7k4fb/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 60)\n    v0 = 60;\n  *((void **)(8 + (char *)vocab + 16 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(8 + (char *)vocab + 16 * vocab_size)), a0);\n  *((long long *)((char *)vocab + 16 * vocab_size)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 0x1dcd6500 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpijxppiso/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpijxppiso/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpijxppiso/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpijxppiso/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 30000000 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5j8y11gn/GetWordHash_name_conflict.c:29:27: error: invalid operands to binary\nexpression ('int' and 'void *') 29 |         v0 = v1[a0] + 257 * v0; | ~~~ ^ ~~\n/tmp/tmp5j8y11gn/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |             ^\n/tmp/tmp5j8y11gn/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |          ^\n/tmp/tmp5j8y11gn/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |                          ^\n      |                          ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) != -1) {\n      v2 = *((int *)(vocab_hash + v0 * 4));\n      if (!strcmp(a0, *((long long *)(((v2 << 2) + v2 << 3) + vocab + 16))))\n        return *((int *)(vocab_hash + v0 * 4));\n      v0 = (0 CONCAT v0 + 1) / m 30000000 >> 32;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwlqyikrx/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                     ^\n/tmp/tmpwlqyikrx/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                  ^\n/tmp/tmpwlqyikrx/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 100)\n    v0 = 100;\n  *((void **)(16 + (char *)vocab + 40 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(16 + 40 * vocab_size + (char *)vocab)), a0);\n  *((long long *)(40 * vocab_size + (char *)vocab)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 30000000 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz4rge660/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpz4rge660/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpz4rge660/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpz4rge660/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_ArvoreB(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    return offset;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Busca_Recursiva_ArvoreB)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Buscar_Registro_ArvoreB_name_conflict(char *a0, unsigned long a1) {\n  char v0;    // [bp-0x14]\n  char v1;    // [bp-0x12]\n  FILE_t *v2; // [bp-0x10]\n\n  v2 = &fopen(a0, \"r+\")->_flags;\n  fseek(v2, 2, 0);\n  fread(&v1, 2, 1, v2);\n  if (!*((short *)&v1))\n    return 0;\n  Busca_Recursiva_ArvoreB(v2, *((short *)&v1), (unsigned int)a1, &v0);\n  return *((short *)&v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:16:6: error: conflicting types for\n'fseek' 16 | int (fseek)(struct FILE_t { |      ^ /usr/include/stdio.h:713:12:\nnote: previous declaration is here 713 | extern int fseek (FILE *__stream, long\nint __off, int __whence); |            ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:162:13: error: declaration of\nanonymous union must be a definition 162 |             union <anon> { | ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:169:13: error: declaration of\nanonymous union must be a definition 169 |             union <anon> { | ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:105:16: error: conflicting types for\n'fread' 105 | unsigned long (fread)(void*, unsigned long, unsigned long, struct\nFILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:231:16:\nerror: redefinition of '_IO_marker' 231 | typedef struct _IO_marker { | ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:237:16: error: redefinition of\n'_IO_codecvt' 237 | typedef struct _IO_codecvt { |                ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:241:16: error: redefinition of\n'_IO_wide_data' 241 | typedef struct _IO_wide_data { |                ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^\n/tmp/tmptxjtuwrn/Buscar_Registro_ArvoreB_name_conflict.c:264:3: error: typedef redefinition\nwith different types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 264 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Inserir_No_ArvoreB(char *arquivo, uint32_t id, uint16_t offset) {\n    uint16_t raiz;\n    uint16_t raiz_pos;\n    uint16_t nova_rrn;\n    uint16_t promo_r_child;\n    uint32_t promo_key_id;\n    uint16_t promo_key_offset;\n    uint8_t flag;\n    FILE *arq_arv;\n    no_arvore_b_t nova;\n    no_arvore_b_t raiz_a;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0) {\n        nova.n = 1;\n        nova.id[0] = id;\n        nova.offset[0] = offset;\n        nova.filhas[0] = 0;\n        nova.filhas[1] = 0;\n        nova_rrn = (Criar_Pagina(arq_arv, nova));\n        fseek(arq_arv, 2, 0);\n        fwrite(&nova_rrn, sizeof(uint16_t), 1, arq_arv);\n    } else {\n        flag = Recursive_Insertion(arq_arv, raiz, id, offset, &promo_r_child, &promo_key_id, &promo_key_offset);\n        switch (flag) {\n          case 2:\n            raiz_a.filhas[0] = raiz;\n            raiz_a.id[0] = promo_key_id;\n            raiz_a.offset[0] = promo_key_offset;\n            raiz_a.filhas[1] = promo_r_child;\n            raiz_a.n = 1;\n            raiz = Criar_Pagina(arq_arv, raiz_a);\n            fseek(arq_arv, 2, 0);\n            fwrite(&raiz, sizeof(uint16_t), 1, arq_arv);\n            break;\n          case 1:\n            break;\n          case 0:\n            break;\n        }\n    }\n    fclose(arq_arv);\n    return nova_rrn;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Criar_Pagina)(long long, long long, long long, long long, long long,\n                        long long, long long, long long, long long, long long,\n                        long long);\nlong long(Recursive_Insertion)(long long, long long, long long, long long,\n                               long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Inserir_No_ArvoreB(char *a0, unsigned long long a1, unsigned long a2,\n                             unsigned long a3, unsigned long long a4,\n                             unsigned long long a5) {\n  int tmp_54;             // tmp #54\n  unsigned long long v0;  // [bp-0xc8]\n  unsigned short v1;      // [bp-0x98]\n  char v2;                // [bp-0x88]\n  unsigned int v3;        // [bp-0x84]\n  char v4;                // [bp-0x80]\n  char v5;                // [bp-0x78]\n  unsigned short v6;      // [bp-0x74]\n  char v7;                // [bp-0x70]\n  unsigned short v8;      // [bp-0x6c]\n  unsigned short v9;      // [bp-0x6a]\n  char v10;               // [bp-0x68]\n  char v11;               // [bp-0x58]\n  unsigned int v12;       // [bp-0x54]\n  char v13;               // [bp-0x50]\n  char v14;               // [bp-0x48]\n  unsigned short v15;     // [bp-0x44]\n  char v16;               // [bp-0x40]\n  unsigned short v17;     // [bp-0x3c]\n  unsigned short v18;     // [bp-0x3a]\n  char v19;               // [bp-0x38]\n  char v20;               // [bp-0x2e]\n  char v21;               // [bp-0x2c]\n  char v22;               // [bp-0x28]\n  unsigned short v23;     // [bp-0x26]\n  char v24;               // [bp-0x24], Other Possible Types: unsigned short\n  char v25;               // [bp-0x21]\n  FILE_t *v26;            // [bp-0x20]\n  unsigned long long v28; // rdx\n  unsigned long long v30; // rcx\n  unsigned long long v32; // rdx\n  unsigned long long v33; // rcx\n\n  v1 = a2;\n  v26 = &fopen(a0, \"r+\")->_flags;\n  fseek(v26, 2, 0);\n  fread(&v24, 2, 1, v26);\n  if (!*((short *)&v24)) {\n    v11 = 1;\n    v12 = a1;\n    v15 = v1;\n    v17 = 0;\n    v18 = 0;\n    v28 = v26;\n    tmp_54 = *((long long *)&v11);\n    v0 = tmp_54;\n    v30 = *((long long *)&v19);\n    v23 = Criar_Pagina(v28, 2, v28, v30, a4, a5, v0, *((long long *)&v13),\n                       *((long long *)&v14), *((long long *)&v16), v30);\n    fseek(v26, 2, 0);\n    fwrite(&v23, 2, 1, v26);\n  } else {\n    v25 = Recursive_Insertion(v26, *((short *)&v24), (unsigned int)a1, v1, &v22,\n                              &v21, &v20);\n    if (v25 == 2) {\n      v8 = *((short *)&v24);\n      v3 = *((int *)&v21);\n      v6 = *((short *)&v20);\n      v9 = *((short *)&v22);\n      v2 = 1;\n      v32 = v26;\n      v33 = *((long long *)&v10);\n      v24 = Criar_Pagina(v32, a1, v32, v33, a4, a5, *((long long *)&v2),\n                         *((long long *)&v4), *((long long *)&v5),\n                         *((long long *)&v7), v33);\n      fseek(v26, 2, 0);\n      fwrite(&v24, 2, 1, v26);\n    }\n  }\n  fclose(v26);\n  return v23;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:105:16: error: conflicting types for\n'fread' 105 | unsigned long (fread)(void*, unsigned long, unsigned long, struct\nFILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:232:16: error:\nredefinition of '_IO_marker' 232 | typedef struct _IO_marker { | ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:238:16: error: redefinition of\n'_IO_codecvt' 238 | typedef struct _IO_codecvt { |                ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:242:16: error: redefinition of\n'_IO_wide_data' 242 | typedef struct _IO_wide_data { |                ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmplnm6k3fr/Inserir_No_ArvoreB.c:265:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 265 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint8_t Inicializar_ArvoreB(char *arquivo) {\n    FILE *nova;\n    uint16_t ped = 0;\n    uint16_t raiz = 0;\n    nova = fopen(arquivo, \"r\");\n    if (nova == ((void *)0)) {\n        nova = fopen(arquivo, \"w\");\n        if (nova == ((void *)0))\n            return 0;\n        fwrite(&ped, sizeof(uint16_t), 1, nova);\n        fwrite(&raiz, sizeof(uint16_t), 1, nova);\n        fclose(nova);\n        return 2;\n    }\n    fclose(nova);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Inicializar_ArvoreB_name_conflict(char *a0) {\n  unsigned short v0; // [bp-0x14]\n  unsigned short v1; // [bp-0x12]\n  FILE_t *v2;        // [bp-0x10]\n\n  v1 = 0;\n  v0 = 0;\n  v2 = &fopen(a0, \"r\")->_flags;\n  if (v2) {\n    fclose(v2);\n    return 1;\n  }\n  v2 = &fopen(a0, \"w\")->_flags;\n  if (!v2)\n    return 0;\n  fwrite(&v1, 2, 1, v2);\n  fwrite(&v0, 2, 1, v2);\n  fclose(v2);\n  return 2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9yx9dpzf/Inicializar_ArvoreB_name_conflict.c:85:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 85 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t POS_to_RRN(uint16_t POS) {\n    POS -= 4;\n    POS /= sizeof(no_arvore_b_t);\n    POS += 1;\n    return POS;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long POS_to_RRN_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 -= 4;\n  v0 = v0 * 52429 >> 21;\n  v0 += 1;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t RRN_to_POS(uint16_t RRN) {\n    --RRN;\n    RRN *= sizeof(no_arvore_b_t);\n    RRN += 4;\n    return RRN;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long RRN_to_POS_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 -= 1;\n  v0 = 5 * v0 * 8;\n  v0 += 4;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Remocao_Arvore_B(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    uint16_t rrn;\n    no_arvore_b_t pagina;\n    int i;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    rrn = Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    if (rrn == 0)\n        return 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Carregar_Pagina(arq_arv, &pagina);\n    i = 0;\n    while (pagina.id[i] != id)\n        ++i;\n    pagina.offset[i] = 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Escrever_Pagina(arq_arv, pagina);\n    fclose(arq_arv);\n    return rrn;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Busca_Recursiva_ArvoreB)(long long, long long, long long, long long);\nlong long(RRN_to_POS)(long long);\nlong long(Carregar_Pagina)(long long, long long);\nlong long(Escrever_Pagina)(long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Remocao_Arvore_B_name_conflict(char *a0, unsigned long a1) {\n  unsigned long long v0; // [bp-0x98]\n  unsigned long long v1; // [bp-0x90]\n  unsigned long long v2; // [bp-0x88]\n  unsigned long long v3; // [bp-0x80]\n  unsigned long long v4; // [bp-0x78]\n  char v5;               // [bp-0x58]\n  char v6;               // [bp-0x54]\n  char v7;               // [bp-0x50]\n  char v8;               // [bp-0x48]\n  char v9;               // [bp-0x40]\n  char v10;              // [bp-0x38]\n  char v11;              // [bp-0x2e]\n  char v12;              // [bp-0x2c]\n  unsigned short v13;    // [bp-0x2a]\n  FILE_t *v14;           // [bp-0x28]\n  unsigned int v15;      // [bp-0x1c]\n\n  v14 = &fopen(a0, \"r+\")->_flags;\n  fseek(v14, 2, 0);\n  fread(&v12, 2, 1, v14);\n  if (!*((short *)&v12))\n    return 0;\n  v13 = Busca_Recursiva_ArvoreB(v14, *((short *)&v12), (unsigned int)a1, &v11);\n  if (!v13)\n    return 0;\n  fseek(v14, RRN_to_POS(v13), 0);\n  Carregar_Pagina(v14, &v5);\n  for (v15 = 0; (unsigned int)a1 != *((int *)&(&v6)[4 * v15]); v15 += 1)\n    ;\n  *((short *)&(&v6)[16 + 2 * v15]) = 0;\n  fseek(v14, RRN_to_POS(v13), 0);\n  v0 = *((long long *)&v5);\n  v1 = *((long long *)&v7);\n  v2 = *((long long *)&v8);\n  v3 = *((long long *)&v9);\n  v4 = *((long long *)&v10);\n  Escrever_Pagina(v14);\n  fclose(v14);\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:76:22: error: type name requires a specifier\nor qualifier 76 |             } __value; |                      ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:83:22: error: type name requires a specifier\nor qualifier 83 |             } __value; |                      ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:105:16: error: conflicting types for 'fread'\n  105 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:234:16: error: redefinition of '_IO_marker'\n  234 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:240:16: error: redefinition of '_IO_codecvt'\n  240 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:244:16: error: redefinition of\n'_IO_wide_data' 244 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpr072v8xo/Remocao_Arvore_B_name_conflict.c:267:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 267 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_Com_Indice(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    char caminho_indice[128];\n    uint16_t pos;\n    int i;\n    char c;\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    pos = Buscar_Registro_ArvoreB(caminho_indice, id);\n    if (pos != 0 && registro != ((void *)0)) {\n        arq_reg = fopen(caminho_registro, \"r\");\n        fseek(arq_reg, pos + 2, 0);\n        fread(&(registro->id), sizeof(uint32_t), 1, arq_reg);\n        fgetc(arq_reg);\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n        fclose(arq_reg);\n    }\n    return pos;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Get_Caminho_Indice)(long long, long long);\nlong long(Buscar_Registro_ArvoreB)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Buscar_Registro_Com_Indice(char *a0, unsigned long a1, void *a2) {\n  char v0;           // [bp-0xa8]\n  char v1;           // [bp-0x19]\n  FILE_t *v2;        // [bp-0x18]\n  unsigned short v3; // [bp-0xe]\n  unsigned int v4;   // [bp-0xc]\n\n  Get_Caminho_Indice(a0, &v0);\n  v3 = Buscar_Registro_ArvoreB(&v0, (unsigned int)a1);\n  if (!v3) {\n    return v3;\n  } else if (!a2) {\n    return v3;\n  } else {\n    v2 = &fopen(a0, \"r\")->_flags;\n    fseek(v2, v3 + 2, 0);\n    fread(a2, 4, 1, v2);\n    fgetc(v2);\n    v4 = 0;\n    while (true) {\n      v1 = fgetc(v2);\n      if (v1 == 124)\n        break;\n      *(4 + (char *)a2 + v4) = v1;\n      v4 += 1;\n    }\n    *(4 + (char *)a2 + v4) = 0;\n    v4 = 0;\n    while (true) {\n      v1 = fgetc(v2);\n      if (v1 == 124)\n        break;\n      *(132 + (char *)a2 + v4) = v1;\n      v4 += 1;\n    }\n    *(132 + (char *)a2 + v4) = 0;\n    v4 = 0;\n    while (true) {\n      v1 = fgetc(v2);\n      if (v1 == 124)\n        break;\n      *(388 + (char *)a2 + v4) = v1;\n      v4 += 1;\n    }\n    *(388 + (char *)a2 + v4) = 0;\n    v4 = 0;\n    while (true) {\n      v1 = fgetc(v2);\n      if (v1 == 124)\n        break;\n      *(452 + (char *)a2 + v4) = v1;\n      v4 += 1;\n    }\n    *(452 + (char *)a2 + v4) = 0;\n    fclose(v2);\n    return v3;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:32:16: error: nested redefinition\nof '_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:31:12: note: previous definition\nis here 31 |     struct _IO_marker { |            ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:75:13: error: declaration of\nanonymous union must be a definition 75 |             union <anon> { | ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:78:22: error: type name requires a\nspecifier or qualifier 78 |             } __value; |                      ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:82:13: error: declaration of\nanonymous union must be a definition 82 |             union <anon> { | ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:85:22: error: type name requires a\nspecifier or qualifier 85 |             } __value; |                      ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:18:6: error: conflicting types for\n'fseek' 18 | int (fseek)(struct FILE_t { |      ^ /usr/include/stdio.h:713:12:\nnote: previous declaration is here 713 | extern int fseek (FILE *__stream, long\nint __off, int __whence); |            ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:164:13: error: declaration of\nanonymous union must be a definition 164 |             union <anon> { | ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:167:22: error: type name requires\na specifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:171:13: error: declaration of\nanonymous union must be a definition 171 |             union <anon> { | ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:174:22: error: type name requires\na specifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:107:16: error: conflicting types\nfor 'fread' 107 | unsigned long (fread)(void*, unsigned long, unsigned long,\nstruct FILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:253:13:\nerror: declaration of anonymous union must be a definition 253 | union <anon> {\n      |             ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:256:22: error: type name requires\na specifier or qualifier 256 |             } __value; |                      ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:260:13: error: declaration of\nanonymous union must be a definition 260 |             union <anon> { | ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:263:22: error: type name requires\na specifier or qualifier 263 |             } __value; |                      ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:196:6: error: conflicting types\nfor 'fgetc' 196 | int (fgetc)(struct FILE_t { |      ^\n/usr/include/stdio.h:513:12: note: previous declaration is here\n  513 | extern int fgetc (FILE *__stream);\n      |            ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:321:16: error: redefinition of\n'_IO_marker' 321 | typedef struct _IO_marker { |                ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:31:12: note: previous definition\nis here 31 |     struct _IO_marker { |            ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:327:16: error: redefinition of\n'_IO_codecvt' 327 | typedef struct _IO_codecvt { |                ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:53:12: note: previous definition\nis here 53 |     struct _IO_codecvt { |            ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:331:16: error: redefinition of\n'_IO_wide_data' 331 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp9rammhtc/Buscar_Registro_Com_Indice.c:61:12: note: previous definition\nis here 61 |     struct _IO_wide_data { |            ^ fatal error: too many\nerrors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    uint32_t id_c;\n    uint16_t tamanho_c;\n    int tamanho_arq;\n    uint16_t retorno = 2;\n    char is_vazio;\n    int i;\n    char c;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r\");\n    fseek(arq_reg, 0, 2);\n    tamanho_arq = ftell(arq_reg);\n    fseek(arq_reg, 2, 0);\n    fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n    fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n    fseek(arq_reg, tamanho_c - 4, 1);\n    while (id_c != id && ftell(arq_reg) < tamanho_arq)\n        {\n            retorno = ftell(arq_reg);\n            fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n            is_vazio = fgetc(arq_reg);\n            if (is_vazio == '*') {\n                id_c = id + 1;\n                fseek(arq_reg, tamanho_c - 1, 1);\n            } else {\n                fseek(arq_reg, -1, 1);\n                fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n                fseek(arq_reg, tamanho_c - 4, 1);\n            }\n        }\n    if (id_c != id)\n        retorno = 0;\n    else if (registro != ((void *)0)) {\n        fseek(arq_reg, retorno + 7, 0);\n        registro->id = id_c;\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n    }\n    fclose(arq_reg);\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Abrir_arquivo)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Buscar_Registro(unsigned long long a0, unsigned long a1,\n                          unsigned int *a2) {\n  char v0;           // [bp-0x26]\n  unsigned int v1;   // [bp-0x24], Other Possible Types: char\n  char v2;           // [bp-0x1e]\n  char v3;           // [bp-0x1d]\n  unsigned int v4;   // [bp-0x1c]\n  FILE_t *v5;        // [bp-0x18]\n  unsigned int v6;   // [bp-0x10]\n  unsigned short v7; // [bp-0xa]\n\n  v7 = 2;\n  v5 = Abrir_arquivo(a0, \"r\");\n  fseek(v5, 0, 2);\n  v4 = ftell(v5);\n  fseek(v5, 2, 0);\n  fread(&v0, 2, 1, v5);\n  fread(&v1, 4, 1, v5);\n  fseek(v5, *((short *)&v0) - 4, 1);\n  while ((unsigned int)a1 != v1 && ftell(v5) < v4) {\n    v7 = ftell(v5);\n    fread(&v0, 2, 1, v5);\n    v3 = fgetc(v5);\n    if (v3 != 42) {\n      fseek(v5, -1, 1);\n      fread(&v1, 4, 1, v5);\n      fseek(v5, *((short *)&v0) - 4, 1);\n    } else {\n      v1 = (unsigned int)a1 + 1;\n      fseek(v5, *((short *)&v0) - 1, 1);\n    }\n  }\n  if ((unsigned int)a1 != v1) {\n    v7 = 0;\n  } else if (a2) {\n    fseek(v5, v7 + 7, 0);\n    *(a2) = v1;\n    v6 = 0;\n    while (true) {\n      v2 = fgetc(v5);\n      if (v2 == 124)\n        break;\n      *(4 + (char *)a2 + v6) = v2;\n      v6 += 1;\n    }\n    *(4 + (char *)a2 + v6) = 0;\n    v6 = 0;\n    while (true) {\n      v2 = fgetc(v5);\n      if (v2 == 124)\n        break;\n      *(132 + (char *)a2 + v6) = v2;\n      v6 += 1;\n    }\n    *(132 + (char *)a2 + v6) = 0;\n    v6 = 0;\n    while (true) {\n      v2 = fgetc(v5);\n      if (v2 == 124)\n        break;\n      *(388 + (char *)a2 + v6) = v2;\n      v6 += 1;\n    }\n    *(388 + (char *)a2 + v6) = 0;\n    v6 = 0;\n    while (true) {\n      v2 = fgetc(v5);\n      if (v2 == 124)\n        break;\n      *(452 + (char *)a2 + v6) = v2;\n      v6 += 1;\n    }\n    *(452 + (char *)a2 + v6) = 0;\n  }\n  fclose(v5);\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpre153tmd/Buscar_Registro.c:31:16: error: nested redefinition of\n'_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmpre153tmd/Buscar_Registro.c:30:12: note: previous definition is here\n   30 |     struct _IO_marker {\n      |            ^\n/tmp/tmpre153tmd/Buscar_Registro.c:74:13: error: declaration of anonymous union\nmust be a definition 74 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:77:22: error: type name requires a specifier\nor qualifier 77 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:81:13: error: declaration of anonymous union\nmust be a definition 81 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:84:22: error: type name requires a specifier\nor qualifier 84 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:17:6: error: conflicting types for 'fseek'\n   17 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpre153tmd/Buscar_Registro.c:163:13: error: declaration of anonymous union\nmust be a definition 163 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:166:22: error: type name requires a specifier\nor qualifier 166 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:170:13: error: declaration of anonymous union\nmust be a definition 170 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:173:22: error: type name requires a specifier\nor qualifier 173 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:106:7: error: conflicting types for 'ftell'\n  106 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmpre153tmd/Buscar_Registro.c:252:13: error: declaration of anonymous union\nmust be a definition 252 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:255:22: error: type name requires a specifier\nor qualifier 255 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:259:13: error: declaration of anonymous union\nmust be a definition 259 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:262:22: error: type name requires a specifier\nor qualifier 262 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:195:16: error: conflicting types for 'fread'\n  195 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpre153tmd/Buscar_Registro.c:341:13: error: declaration of anonymous union\nmust be a definition 341 |             union <anon> { |             ^\n/tmp/tmpre153tmd/Buscar_Registro.c:344:22: error: type name requires a specifier\nor qualifier 344 |             } __value; |                      ^\n/tmp/tmpre153tmd/Buscar_Registro.c:348:13: error: declaration of anonymous union\nmust be a definition 348 |             union <anon> { |             ^ fatal\nerror: too many errors emitted, stopping now [-ferror-limit=] 20 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Calcular_Tamanho(registro_t registro) {\n    uint16_t retorno = 0;\n    retorno += 5;\n    retorno += sizeof(uint32_t);\n    retorno += strlen(registro.autor);\n    retorno += strlen(registro.titulo);\n    retorno += strlen(registro.curso);\n    retorno += strlen(registro.tipo);\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Calcular_Tamanho_name_conflict() {\n  unsigned short v0; // [bp-0xa]\n  unsigned long v1;  // [bp+0x8]\n  char v2;           // [bp+0x8c]\n  char v3;           // [bp+0x18c]\n  char v4;           // [bp+0x1cc]\n\n  v0 = 0;\n  v0 += 5;\n  v0 += 4;\n  v0 += (unsigned short)strlen(&v1);\n  v0 += (unsigned short)strlen(&v2);\n  v0 += (unsigned short)strlen(&v3);\n  v0 += (unsigned short)strlen(&v4);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Inserir_Registro(char *caminho_registro, registro_t registro) {\n    FILE *arq_reg;\n    uint16_t first_led;\n    uint16_t nova_first_led;\n    uint16_t tamanho, tamanho_first_led, tamanho_novo_branco;\n    int retorno;\n    char caminho_indice[128];\n    tamanho = Calcular_Tamanho(registro);\n    tamanho_first_led = 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, 0, 0);\n    fread(&first_led, sizeof(uint16_t), 1, arq_reg);\n    if (first_led != 0) {\n        fseek(arq_reg, first_led, 0);\n        fread(&tamanho_first_led, sizeof(uint16_t), 1, arq_reg);\n    }\n    if (first_led == 0 || tamanho_first_led < tamanho)\n        retorno = Inserir_Registro_Final(arq_reg, registro);\n    else {\n        fgetc(arq_reg);\n        fread(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, 0, 0);\n        fwrite(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, first_led, 0);\n        tamanho_novo_branco = tamanho_first_led - tamanho - 2;\n        if (tamanho_novo_branco > 8) {\n            fwrite(&tamanho_novo_branco, sizeof(uint16_t), 1, arq_reg);\n            Inserir_ED(arq_reg, first_led);\n            fseek(arq_reg, first_led + 2 + tamanho_novo_branco, 0);\n        } else\n            tamanho = tamanho_first_led;\n        retorno = ftell(arq_reg);\n        fwrite(&tamanho, sizeof(uint16_t), 1, arq_reg);\n        fwrite(&(registro.id), sizeof(uint32_t), 1, arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.autor, sizeof(char), strlen(registro.autor), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.titulo, sizeof(char), strlen(registro.titulo), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.curso, sizeof(char), strlen(registro.curso), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.tipo, sizeof(char), strlen(registro.tipo), arq_reg);\n        fputc('|', arq_reg);\n    }\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Inserir_No_ArvoreB(caminho_indice, registro.id, (uint16_t)(retorno));\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Calcular_Tamanho)();\nlong long(Abrir_arquivo)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(Inserir_Registro_Final)(long long, long long, long long, long long,\n                                  long long, long long, char);\nlong long(Get_Caminho_Indice)(long long, long long);\nlong long(Inserir_No_ArvoreB)(long long, long long, long long, long long,\n                              long long, long long);\nlong long(Inserir_ED)(long long, long long);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Inserir_Registro(unsigned long a0, unsigned long a1, unsigned long a2,\n                           unsigned long a3, unsigned long a4,\n                           unsigned long long a5, char v10) {\n  char v0;                // [bp-0x2a8], Other Possible Types: unsigned long\n  unsigned long long v1;  // [bp-0xb0]\n  char v2;                // [bp-0xa8]\n  unsigned short v3;      // [bp-0x22]\n  unsigned short v4;      // [bp-0x20]\n  unsigned short v5;      // [bp-0x1e]\n  char v6;                // [bp-0x1c]\n  char v7;                // [bp-0x1a]\n  FILE_t *v8;             // [bp-0x18]\n  unsigned int v9;        // [bp-0xc]\n  char v11;               // [bp+0x8c]\n  char v12;               // [bp+0x18c]\n  char v13;               // [bp+0x1cc]\n  unsigned long v14;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v15;          // rdi, Other Possible Types: unsigned long\n  struct_0 *v16;          // rsi, Other Possible Types: unsigned long\n  unsigned long v17;      // d\n  unsigned long v18;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v19;          // rdi, Other Possible Types: unsigned long\n  struct_0 *v20;          // rsi, Other Possible Types: unsigned long\n  unsigned long long v21; // rcx\n  unsigned long long v22; // rcx\n\n  v1 = a0;\n  v14 = 60;\n  v15 = &v0;\n  for (v16 = &v10; v14; v16 += v17 * 8) {\n    v14 -= 1;\n    *((long long *)v15) = *((long long *)v16);\n    v15 += v17 * 8;\n  }\n  *((int *)v15) = *((int *)v16);\n  v5 = Calcular_Tamanho();\n  v4 = 0;\n  v8 = Abrir_arquivo(v1, \"r+\");\n  fseek(v8, 0, 0);\n  fread(&v7, 2, 1, v8);\n  if (*((short *)&v7)) {\n    fseek(v8, *((short *)&v7), 0);\n    fread(&v4, 2, 1, v8);\n  }\n  if (!*((short *)&v7) || (char)[D] amd64g_calculate_condition(\n                              0x2 < 64 >, 0x6 < 64 >,\n                              Conv(16->64, Load(addr = stack_base - 32,\n                                                size = 2, endness = Iend_LE)),\n                              Conv(16->64, Load(addr = stack_base - 30,\n                                                size = 2, endness = Iend_LE)),\n                              cc_ndep)) {\n    a4 = v8;\n    v18 = 60;\n    v19 = &v0;\n    for (v20 = &v10; v18; v20 += v17 * 8) {\n      v18 -= 1;\n      *((long long *)v19) = *((long long *)v20);\n      v19 += v17 * 8;\n    }\n    v21 = *((int *)v20);\n    *((unsigned int *)v19) = v21;\n    v9 = Inserir_Registro_Final(a4, v20, v19, v21, a4, a5, v0);\n  } else {\n    fgetc(v8);\n    fread(&v6, 2, 1, v8);\n    fseek(v8, 0, 0);\n    fwrite(&v6, 2, 1, v8);\n    fseek(v8, *((short *)&v7), 0);\n    v3 = v4 - v5 - 2;\n    if (v3 << 48 <= 0x8000000000000) {\n      v5 = v4;\n    } else {\n      fwrite(&v3, 2, 1, v8);\n      Inserir_ED(v8, *((short *)&v7));\n      fseek(v8, v3 + *((short *)&v7) + 2, 0);\n    }\n    v9 = ftell(v8);\n    fwrite(&v5, 2, 1, v8);\n    fwrite(&v10, 4, 1, v8);\n    fputc(124, v8);\n    fwrite(&v10, 1, strlen(&v10), v8);\n    fputc(124, v8);\n    fwrite(&v11, 1, strlen(&v11), v8);\n    fputc(124, v8);\n    fwrite(&v12, 1, strlen(&v12), v8);\n    fputc(124, v8);\n    fwrite(&v13, 1, strlen(&v13), v8);\n    fputc(124, v8);\n  }\n  fclose(v8);\n  Get_Caminho_Indice(v1, &v2);\n  v22 = (unsigned int)v10;\n  Inserir_No_ArvoreB(&v2, v22, v9, v22, a4, a5);\n  return v9;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyexki0c_/Inserir_Registro.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:18:6: error: conflicting types for 'fseek'\n   18 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:107:16: error: conflicting types for 'fread'\n  107 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:253:13: error: declaration of anonymous\nunion must be a definition 253 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:256:22: error: type name requires a\nspecifier or qualifier 256 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:260:13: error: declaration of anonymous\nunion must be a definition 260 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:263:22: error: type name requires a\nspecifier or qualifier 263 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:196:6: error: conflicting types for 'fgetc'\n  196 | int (fgetc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:513:12: note: previous declaration is here\n  513 | extern int fgetc (FILE *__stream);\n      |            ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:346:13: error: declaration of anonymous\nunion must be a definition 346 |             union <anon> { |             ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:349:22: error: type name requires a\nspecifier or qualifier 349 |             } __value; |                      ^\n/tmp/tmpyexki0c_/Inserir_Registro.c:353:13: error: declaration of anonymous\nunion must be a definition 353 |             union <anon> { |             ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Remover_Registro(char *caminho_registro, uint32_t id) {\n    FILE *arq_reg;\n    uint16_t posicao;\n    char asteristico = '*';\n    char caminho_indice[128];\n    posicao = Buscar_Registro_Com_Indice(caminho_registro, id, ((void *)0));\n    if (posicao == 0)\n        return 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, posicao + 2, 0);\n    fwrite(&asteristico, sizeof(char), 1, arq_reg);\n    Inserir_ED(arq_reg, posicao);\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Remocao_Arvore_B(caminho_indice, id);\n    return posicao;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Buscar_Registro_Com_Indice)(long long, long long, long long);\nlong long(Abrir_arquivo)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong long(Inserir_ED)(long long, long long);\nlong long(Get_Caminho_Indice)(long long, long long);\nlong long(Remocao_Arvore_B)(long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Remover_Registro_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;           // [bp-0xa8]\n  char v1;           // [bp-0x19]\n  FILE_t *v2;        // [bp-0x18]\n  unsigned short v3; // [bp-0xa]\n\n  v1 = 42;\n  v3 = Buscar_Registro_Com_Indice(a0, (unsigned int)a1, 0);\n  if (!v3)\n    return 0;\n  v2 = Abrir_arquivo(a0, \"r+\");\n  fseek(v2, v3 + 2, 0);\n  fwrite(&v1, 1, 1, v2);\n  Inserir_ED(v2, v3);\n  fclose(v2);\n  Get_Caminho_Indice(a0, &v0);\n  Remocao_Arvore_B(&v0, (unsigned int)a1);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:18:6: error: conflicting types for 'fseek'\n   18 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:146:16: error: redefinition of '_IO_marker'\n  146 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:152:16: error: redefinition of '_IO_codecvt'\n  152 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:53:12: note: previous definition is here\n   53 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:156:16: error: redefinition of\n'_IO_wide_data' 156 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:61:12: note: previous definition is here\n   61 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpdmafxp0g/Remover_Registro_name_conflict.c:179:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 179 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"registro_t String_to_reg(char *cadeia) {\n    registro_t retorno;\n    char *campo;\n    if (cadeia == ((void *)0)) {\n        printf(\"Erro ao converter arquivo de catalogo: linha vazia!\\n\");\n        retorno.id = 0;\n        return retorno;\n    }\n    campo = strtok(cadeia, \";\");\n    retorno.id = (uint32_t)(atoi(campo));\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.autor, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.titulo, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.curso, campo + 1);\n    campo = strtok(((void *)0), \"\\r\");\n    strcpy(retorno.tipo, campo + 1);\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok)(char *, char *);\nint(atoi)(char *);\n\nlong long String_to_reg_name_conflict(unsigned long long *a0, unsigned long a1) {\n  char *v0;                // [bp-0x208]\n  unsigned long long *v1;  // [bp-0x200]\n  unsigned int v2;         // [bp-0x1f8]\n  char v3;                 // [bp-0x1f4]\n  char v4;                 // [bp-0x174]\n  char v5;                 // [bp-0x74]\n  char v6;                 // [bp-0x34]\n  char *v7;                // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long *v9;  // rdx\n  unsigned long long *v10; // rdi, Other Possible Types: unsigned long\n  unsigned long long v11;  // rdx\n  unsigned long v12;       // rcx, Other Possible Types: unsigned long long\n  unsigned long v13;       // d\n  unsigned long long *v14; // rsi, Other Possible Types: unsigned long\n  unsigned long long *v15; // rdx\n  unsigned long long *v16; // rdi, Other Possible Types: unsigned long\n  unsigned long long v17;  // rdx\n  unsigned long v18;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v19; // rsi, Other Possible Types: unsigned long\n  unsigned long v20;       // d\n\n  v1 = a0;\n  v0 = a1;\n  if (v0) {\n    v7 = strtok(v0, \";\");\n    v2 = atoi(v7);\n    v7 = strtok(NULL, \";\");\n    strcpy(&v3, v7 + 1);\n    v7 = strtok(NULL, \";\");\n    strcpy(&v4, v7 + 1);\n    v7 = strtok(NULL, \";\");\n    strcpy(&v5, v7 + 1);\n    v7 = strtok(NULL, \"\\r\");\n    strcpy(&v6, v7 + 1);\n    v15 = v1;\n    *(v15) = *((long long *)&v2);\n    *((unsigned long long **)((char *)&v15[59] + 4)) = v1;\n    v16 = v15 + 1 & -8;\n    v17 = v15 - v16;\n    v18 = (484 + (unsigned int)v17 & -8) >> 3;\n    for (v19 = (char *)&v2 - v17; v18; v19 += v20 * 8) {\n      v18 -= 1;\n      *((long long *)v16) = *((long long *)v19);\n      v16 += v20 * 8;\n    }\n    return v1;\n  } else {\n    puts(\"Erro ao converter arquivo de catalogo: linha vazia!\");\n    v2 = 0;\n    v9 = v1;\n    *(v9) = *((long long *)&v2);\n    *((unsigned long long **)((char *)&v9[59] + 4)) = v1;\n    v10 = v9 + 1 & -8;\n    v11 = v9 - v10;\n    v12 = (484 + (unsigned int)v11 & -8) >> 3;\n    for (v14 = (char *)&v2 - v11; v12; v14 += v13 * 8) {\n      v12 -= 1;\n      *((long long *)v10) = *((long long *)v14);\n      v10 += v13 * 8;\n    }\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyrn4h025/String_to_reg_name_conflict.c:59:23: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 59 |         v16 = v15 + 1 & -8;\n      |               ~~~~~~~ ^ ~~\n/tmp/tmpyrn4h025/String_to_reg_name_conflict.c:77:22: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 77 |         v10 = v9 + 1 & -8; |\n~~~~~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Importar_arquivo_catalogo(char *caminho_catalogo, char *caminho_registro) {\n    char leitura[1024];\n    char c;\n    int i;\n    int n_reg = 0;\n    registro_t lido;\n    FILE *catalogo;\n    catalogo = Abrir_arquivo(caminho_catalogo, \"r\");\n    while (1)\n        {\n            i = 0;\n            while ((c = fgetc(catalogo)) != '\\n' && c != (-1))\n                {\n                    leitura[i] = c;\n                    ++i;\n                }\n            leitura[i] = '\\x00';\n            if (strlen(leitura) < 4)\n                break;\n            lido = String_to_reg(leitura);\n            i = Inserir_Registro(caminho_registro, lido);\n            printf(\"Inserido registro na posicao %d do arquivo.\\n\", i);\n            ++n_reg;\n        }\n    fclose(catalogo);\n    return n_reg;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Abrir_arquivo)(long long, long long);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(String_to_reg)(long long, long long);\nlong long(Inserir_Registro)(long long, long long, long long, long long,\n                            long long, long long, char);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Importar_arquivo_catalogo(unsigned long a0, unsigned long a1,\n                                    unsigned long a2, unsigned long a3,\n                                    unsigned long a4, unsigned long long a5) {\n  unsigned long v0;       // [bp-0x818], Other Possible Types: char\n  unsigned long v1;       // [bp-0x628]\n  unsigned long long v2;  // [bp-0x620]\n  char v3;                // [bp-0x618]\n  char v4;                // [bp-0x428]\n  char v5;                // [bp-0x19]\n  FILE_t *v6;             // [bp-0x18]\n  unsigned int v7;        // [bp-0x10]\n  unsigned int v8;        // [bp-0xc]\n  unsigned long long v10; // r8\n  unsigned long v11;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v12;          // rsi, Other Possible Types: unsigned long\n  unsigned long v13;      // d\n  struct_0 *v14;          // rdi, Other Possible Types: unsigned long\n  unsigned long long v15; // rcx\n\n  v2 = a0;\n  v1 = a1;\n  v7 = 0;\n  v6 = Abrir_arquivo(v2, \"r\");\n  while (true) {\n    v8 = 0;\n    while (true) {\n      v5 = fgetc(v6);\n      if (!(v5 != 10) || !(v5 != 255))\n        break;\n      (&v4)[v8] = v5;\n      v8 += 1;\n    }\n    (&v4)[v8] = 0;\n    if (strlen(&v4) <= 3)\n      break;\n    String_to_reg(&v3, &v4);\n    v10 = v1;\n    v11 = 60;\n    v14 = &v0;\n    for (v12 = &v3; v11; v12 += v13 * 8) {\n      v11 -= 1;\n      *((long long *)v14) = *((long long *)v12);\n      v14 += v13 * 8;\n    }\n    v15 = *((int *)v12);\n    *((unsigned int *)v14) = v15;\n    v8 = Inserir_Registro(v10, v12, v14, v15, v10, a5, v0);\n    printf(\"Inserido registro na posicao %d do arquivo.\\n\", v8);\n    v7 += 1;\n  }\n  fclose(v6);\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:31:16: error: nested redefinition\nof '_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:30:12: note: previous definition is\nhere 30 |     struct _IO_marker { |            ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:74:13: error: declaration of\nanonymous union must be a definition 74 |             union <anon> { | ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:77:22: error: type name requires a\nspecifier or qualifier 77 |             } __value; |                      ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:81:13: error: declaration of\nanonymous union must be a definition 81 |             union <anon> { | ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:84:22: error: type name requires a\nspecifier or qualifier 84 |             } __value; |                      ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:17:6: error: conflicting types for\n'fgetc' 17 | int (fgetc)(struct FILE_t { |      ^ /usr/include/stdio.h:513:12:\nnote: previous declaration is here 513 | extern int fgetc (FILE *__stream); | ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:148:16: error: redefinition of\n'_IO_marker' 148 | typedef struct _IO_marker { |                ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:30:12: note: previous definition is\nhere 30 |     struct _IO_marker { |            ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:154:16: error: redefinition of\n'_IO_codecvt' 154 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:52:12: note: previous definition is\nhere 52 |     struct _IO_codecvt { |            ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:158:16: error: redefinition of\n'_IO_wide_data' 158 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:60:12: note: previous definition is\nhere 60 |     struct _IO_wide_data { |            ^\n/tmp/tmpltamzomk/Importar_arquivo_catalogo.c:181:3: error: typedef redefinition\nwith different types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 181 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"static unsigned char *option_find1(unsigned char *p, unsigned char *end, int opt, int minsize) {\n    while (*p != 255)\n        {\n            if (p >= end)\n                return ((void *)0);\n            else if (*p == 0)\n                p++;\n            else {\n                int opt_len;\n                if (p >= end - 2)\n                    return ((void *)0);\n                opt_len = ((int)(((unsigned char *)(p))[1]));\n                if (p >= end - (2 + opt_len))\n                    return ((void *)0);\n                if (*p == opt && opt_len >= minsize)\n                    return p;\n                p += opt_len + 2;\n            }\n        }\n    return opt == 255 ? p : ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long option_find1(char a0[2], unsigned long a1, unsigned long a2,\n                       unsigned long a3) {\n  char v0[2];      // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n\n  *(&v0) = a0;\n  while (*((char *)v0) != 255) {\n    if (v0 >= a1) {\n      return 0;\n    } else if (!*((char *)v0)) {\n      v0 += 1;\n    } else {\n      if (v0 >= a1 - 2)\n        return 0;\n      v1 = *((char *)(v0 + 1));\n      if (v0 >= a1 + !(v1 + 2))\n        return 0;\n      if ((unsigned int)a2 == *((char *)v0) && v1 >= (unsigned int)a3)\n        return v0;\n      v0 += v1 + 2;\n    }\n  }\n  return ((unsigned int)a2 == 255 ? 0 : v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpytfml1jf/option_find1.c:22:12: error: array type 'char[2]' is not\nassignable 22 |     *(&v0) = a0; |     ~~~~~~ ^\n/tmp/tmpytfml1jf/option_find1.c:31:16: error: invalid operands to binary\nexpression ('char[2]' and 'int') 31 |             v0 += 1; |             ~~ ^  ~\n/tmp/tmpytfml1jf/option_find1.c:42:16: error: invalid operands to binary\nexpression ('char[2]' and 'unsigned int') 42 |             v0 += v1 + 2; | ~~ ^\n~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static unsigned char *option_find(struct dhcp_packet *mess, size_t size, int opt_type, int minsize) {\n    unsigned char *ret, *overload;\n    if ((ret = option_find1(&mess->options[0], ((unsigned char *)mess) + size, opt_type, minsize)))\n        return ret;\n    if (!(overload = option_find1(&mess->options[0], ((unsigned char *)mess) + size, 52, 1)))\n        return ((void *)0);\n    if ((overload[2] & 1) && (ret = option_find1(&mess->file[0], &mess->file[128], opt_type, minsize)))\n        return ret;\n    if ((overload[2] & 2) && (ret = option_find1(&mess->sname[0], &mess->sname[64], opt_type, minsize)))\n        return ret;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(option_find1)(long long, long long, long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[2];\n  char field_2;\n} struct_0;\n\nlong long option_find(unsigned long a0, unsigned long a1, unsigned long a2,\n                      unsigned long a3) {\n  struct_0 *v0;     // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  v1 = option_find1(a0 + 240, a0 + a1, (unsigned int)a2, (unsigned int)a3);\n  if (v1)\n    return v1;\n  v0 = option_find1(a0 + 240, a0 + a1, 52, 1);\n  if (!v0)\n    return 0;\n  if ((v0->field_2 & 1)) {\n    v1 = option_find1(a0 + 108, a0 + 236, (unsigned int)a2, (unsigned int)a3);\n    if (v1)\n      return v1;\n  }\n  if (!(v0->field_2 & 2))\n    return 0;\n  v1 = option_find1(a0 + 44, a0 + 108, (unsigned int)a2, (unsigned int)a3);\n  if (v1)\n    return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":1,"function":"static unsigned int option_uint(unsigned char *opt, int size) {\n    unsigned int ret = 0;\n    int i;\n    unsigned char *p = ((void *)&(((unsigned char *)(opt))[2]));\n    for (i = 0; i < size; i++)\n        ret = (ret << 8) | *p++;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long option_uint_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v0;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n  char *v4;        // rax\n\n  v2 = 0;\n  v0 = a0 + 2;\n  for (v1 = 0; v1 < (unsigned int)a1; v1 += 1) {\n    v4 = v0;\n    v0 = v4 + 1;\n    v2 = *(v4) | v2 * 0x100;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static ssize_t netlink_recv(int fd) {\n    struct msghdr msg;\n    ssize_t rc;\n    msg.msg_control = ((void *)0);\n    msg.msg_controllen = 0;\n    msg.msg_name = ((void *)0);\n    msg.msg_namelen = 0;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    while (1)\n        {\n            msg.msg_flags = 0;\n            while ((rc = recvmsg(fd, &msg, MSG_PEEK)) == -1 && (*__errno_location()) == 4)\n                ;\n            if (rc == -1 && (*__errno_location()) == 95) {\n                if (!expand_buf(&iov, 2000))\n                    return -1;\n                break;\n            }\n            if (rc == -1 || !(msg.msg_flags & MSG_TRUNC))\n                break;\n            if (!expand_buf(&iov, iov.iov_len + 100))\n                return -1;\n        }\n    while ((rc = recvmsg(fd, &msg, 0)) == -1 && (*__errno_location()) == 4)\n        ;\n    return rc;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(expand_buf)(long long, long long);\n\nextern unsigned long long g_4040d8;\nextern unsigned long long iov;\n\nlong long netlink_recv_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x48]\n  unsigned int v1;       // [bp-0x40]\n  unsigned long v2;      // [bp-0x38]\n  unsigned long long v3; // [bp-0x30]\n  void *v4;              // [bp-0x28]\n  void *v5;              // [bp-0x20]\n  unsigned int v6;       // [bp-0x18]\n  unsigned long v7;      // [bp-0x10]\n\n  v4 = 0;\n  v5 = 0;\n  v0 = 0;\n  v1 = 0;\n  v2 = &iov;\n  v3 = 1;\n  while (true) {\n    v6 = 0;\n    do {\n      v7 = recvmsg((unsigned int)a0, &v0, 2, &v0);\n    } while (v7 == -1 && *(__errno_location()) == 4);\n    if (v7 == -1 && *(__errno_location()) == 95) {\n      if (!(int)expand_buf(&iov, 2000))\n        return -1;\n      goto LABEL_4013e4;\n    } else if (!(v7 != -1) || !(((char)v6 & 32))) {\n    LABEL_4013e4:\n      do {\n        v7 = recvmsg((unsigned int)a0, &v0, 0, &v0);\n      } while (v7 == -1 && *(__errno_location()) == 4);\n    } else if (!(int)expand_buf(&iov, g_4040d8 + 100)) {\n      return -1;\n    }\n  }\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1h4skz98/netlink_recv_name_conflict.c:44:30: error: indirection requires pointer\noperand ('int' invalid) 44 |         } while (v7 == -1 && *(__errno_location())\n== 4); |                              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1h4skz98/netlink_recv_name_conflict.c:45:25: error: indirection requires pointer\noperand ('int' invalid) 45 |         if (v7 == -1 && *(__errno_location()) ==\n95) |                         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1h4skz98/netlink_recv_name_conflict.c:57:34: error: indirection requires pointer\noperand ('int' invalid) 57 |             } while (v7 == -1 &&\n*(__errno_location()) == 4); | ^~~~~~~~~~~~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static int parse_hex(char *in, unsigned char *out, int maxlen, int *mac_type) {\n    int i = 0;\n    char *r;\n    if (mac_type)\n        *mac_type = 0;\n    while (maxlen == -1 || i < maxlen)\n        {\n            for (r = in; *r != 0 && *r != ':' && *r != '-'; r++)\n                ;\n            if (*r == 0)\n                maxlen = i;\n            if (r != in) {\n                if (*r == '-' && i == 0 && mac_type) {\n                    *r = 0;\n                    *mac_type = strtol(in, ((void *)0), 16);\n                    mac_type = ((void *)0);\n                } else {\n                    *r = 0;\n                    out[i] = strtol(in, ((void *)0), 16);\n                    i++;\n                }\n            }\n            in = r + 1;\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_hex_name_conflict(char *a0, char *a1, unsigned long a2, unsigned int *a3) {\n  void *v0;        // [bp-0x38], Other Possible Types: unsigned int *\n  unsigned int v1; // [bp-0x2c]\n  char *v2;        // [bp-0x20], Other Possible Types: unsigned long\n  char *v3;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v4; // [bp-0xc]\n\n  v2 = a0;\n  v1 = a2;\n  v0 = a3;\n  v4 = 0;\n  if (v0)\n    *(v0) = 0;\n  for (; v1 == -1 || v4 < v1; v2 = v3 + 1) {\n    for (v3 = v2; *(v3) && *(v3) != 58 && *(v3) != 45; v3 += 1)\n      ;\n    if (!*((char *)v3))\n      v1 = v4;\n    if (v3 != v2) {\n      if (*(v3) != 45 || v4 || !v0) {\n        *((char *)v3) = 0;\n        a1[v4] = strtol(v2, NULL, 16);\n        v4 += 1;\n      } else {\n        *((char *)v3) = 0;\n        *(v0) = strtol(v2, NULL, 16);\n        v0 = 0;\n      }\n    }\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbp7xf9gd/parse_hex_name_conflict.c:30:15: error: incomplete type 'void' is not\nassignable 30 |         *(v0) = 0; |         ~~~~~ ^\n/tmp/tmpbp7xf9gd/parse_hex_name_conflict.c:47:23: error: incomplete type 'void' is not\nassignable 47 |                 *(v0) = strtol(v2, NULL, 16); | ~~~~~ ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask) {\n    return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_same_net_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  return !((unsigned int)a2 & ((unsigned int)a0 ^ (unsigned int)a1));\n}\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static struct in_addr find_interface(struct in_addr client, int fd, unsigned int index) {\n    struct sockaddr_nl addr;\n    struct nlmsghdr *h;\n    ssize_t len;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg g;\n    } req;\n    addr.nl_family = 16;\n    addr.nl_pad = 0;\n    addr.nl_groups = 0;\n    addr.nl_pid = 0;\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETADDR;\n    req.nlh.nlmsg_flags = 256 | 512 | 1 | 4;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = 1;\n    req.g.rtgen_family = 2;\n    if (sendto(fd, (void *)&req, sizeof (req), 0, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        perror(\"sendto failed\");\n        exit(1);\n    }\n    while (1)\n        {\n            if ((len = netlink_recv(fd)) == -1) {\n                perror(\"netlink\");\n                exit(1);\n            }\n            for (h = (struct nlmsghdr *)iov.iov_base; (((size_t)len) >= (int)sizeof(struct nlmsghdr) && (h)->nlmsg_len >= sizeof(struct nlmsghdr) && (h)->nlmsg_len <= ((size_t)len)); h = ((len) -= ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(h)) + ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)))))\n                if (h->nlmsg_type == 3)\n                    exit(0);\n                else if (h->nlmsg_type == RTM_NEWADDR) {\n                    struct ifaddrmsg *ifa = ((void *)(((char *)h) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    struct rtattr *rta;\n                    unsigned int len1 = h->nlmsg_len - ((sizeof (*ifa)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n                    if (ifa->ifa_index == index && ifa->ifa_family == 2) {\n                        struct in_addr netmask, addr;\n                        netmask.s_addr = htonl(4294967295U << (32 - ifa->ifa_prefixlen));\n                        addr.s_addr = 0;\n                        for (rta = ((struct rtattr *)(((char *)(ifa)) + (((sizeof(struct ifaddrmsg)) + 4U - 1) & ~(4U - 1)))); ((len1) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len1)); rta = ((len1) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n                            if (rta->rta_type == IFA_LOCAL)\n                                addr = *((struct in_addr *)(rta + 1));\n                        if (addr.s_addr && is_same_net(addr, client, netmask))\n                            return addr;\n                    }\n                }\n        }\n    exit(0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nvoid(perror)(char *);\nlong long(netlink_recv)(long long);\nunsigned int(htonl)(unsigned int);\nlong long(is_same_net)(long long, long long, long long);\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_1;\n\ntypedef struct struct_2 {\n  char field_0;\n  char field_1;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_2;\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nextern struct_1 *iov;\n\nlong long find_interface_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;            // [bp-0x70]\n  unsigned int v1;    // [bp-0x60]\n  unsigned int v2;    // [bp-0x5c]\n  unsigned int v3;    // [bp-0x58]\n  unsigned short v4;  // [bp-0x54]\n  unsigned short v5;  // [bp-0x52]\n  unsigned int v6;    // [bp-0x50]\n  unsigned int v7;    // [bp-0x4c]\n  char v8;            // [bp-0x48]\n  unsigned short v9;  // [bp-0x3c]\n  unsigned short v10; // [bp-0x3a]\n  unsigned int v11;   // [bp-0x38]\n  unsigned int v12;   // [bp-0x34]\n  struct_2 *v13;      // [bp-0x30]\n  unsigned int v14;   // [bp-0x24]\n  struct_0 *v15;      // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v16;  // [bp-0x18]\n  struct_1 *v17;      // [bp-0x10], Other Possible Types: unsigned long\n\n  v9 = 16;\n  v10 = 0;\n  v12 = 0;\n  v11 = 0;\n  v3 = 20;\n  v4 = 22;\n  v5 = 773;\n  v7 = 0;\n  v6 = 1;\n  v8 = 2;\n  if (sendto(a1, &v3, 20, 0, &v9, 12) == -1) {\n    perror(\"sendto failed\");\n    exit(1); /* do not return */\n  }\n  while (true) {\n    v16 = netlink_recv(*((int *)&v0));\n    if (v16 == -1)\n      break;\n    for (v17 = iov; v16 > 15 && v17->field_0 > 15 && v16 >= v17->field_0;\n         v17 = (char *)v17 + (v17->field_0 + 3 & -0x4)) {\n      if (v17->field_4 == 3)\n        exit(0); /* do not return */\n      if (v17->field_4 == 20) {\n        v13 = &v17[2].field_4;\n        v14 = v17->field_0 - 24;\n        if ((unsigned int)a2 == v13->field_4 && v13->field_0 == 2) {\n          v2 = htonl(4294967295 << ((char)(32 - v13->field_1) & 31));\n          v1 = 0;\n          for (v15 = &v13[1].field_0;\n               v14 > 3 && *((short *)v15) << 48 > 0x3000000000000 &&\n               v14 >= *((short *)v15);\n               v15 += *((short *)v15) + 3 & 0xfffffffc) {\n            if (*((short *)(v15 + 2)) == 2)\n              v1 = *((int *)(v15 + 4));\n            v14 -= *((short *)v15) + 3 & 0xfffffffc;\n          }\n          if (v1 && (int)is_same_net(v1, (unsigned int)a0, v2))\n            return v1;\n        }\n      }\n      v16 -= v17->field_0 + 3 & -0x4;\n    }\n  }\n  perror(\"netlink\");\n  exit(1); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6qdws4bo/find_interface_name_conflict.c:20:7: error: conflicting types for 'perror'\n   20 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"int output(char *filename) {\n    FILE *fp;\n    char str[64];\n    if ((fp = fopen(filename, \"r\")) == ((void *)0)) {\n        printf(\"Cannot open file %s.\\n\", filename);\n        return 1;\n    }\n    while (!feof(fp))\n        {\n            if (fgets(str, 128, fp)) {\n                printf(\"%s\", str);\n            }\n        }\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(feof)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long output(char *a0) {\n  char v0;    // [bp-0x58]\n  FILE_t *v1; // [bp-0x10]\n\n  v1 = &fopen(a0, \"r\")->_flags;\n  if (!v1) {\n    printf(\"Cannot open file %s.\\n\", (unsigned int)a0);\n    return 1;\n  }\n  while (true) {\n    if (feof(v1)) {\n      fclose(v1);\n      return 0;\n    } else if (fgets(&v0, 128, v1)) {\n      printf(\"%s\", (unsigned int)&v0);\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgwrtwlly/output.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpgwrtwlly/output.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpgwrtwlly/output.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpgwrtwlly/output.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpgwrtwlly/output.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpgwrtwlly/output.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpgwrtwlly/output.c:16:6: error: conflicting types for 'feof'\n   16 | int (feof)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:788:12: note: previous declaration is here\n  788 | extern int feof (FILE *__stream) __THROW __wur;\n      |            ^\n/tmp/tmpgwrtwlly/output.c:162:13: error: declaration of anonymous union must be\na definition 162 |             union <anon> { |             ^\n/tmp/tmpgwrtwlly/output.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmpgwrtwlly/output.c:169:13: error: declaration of anonymous union must be\na definition 169 |             union <anon> { |             ^\n/tmp/tmpgwrtwlly/output.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmpgwrtwlly/output.c:105:8: error: conflicting types for 'fgets'\n  105 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpgwrtwlly/output.c:230:16: error: redefinition\nof '_IO_marker' 230 | typedef struct _IO_marker { |                ^\n/tmp/tmpgwrtwlly/output.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpgwrtwlly/output.c:236:16: error: redefinition of '_IO_codecvt'\n  236 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpgwrtwlly/output.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpgwrtwlly/output.c:240:16: error: redefinition of '_IO_wide_data'\n  240 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpgwrtwlly/output.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpgwrtwlly/output.c:263:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 263 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lazyparser_honggfuzz/examples/targets/badcode1.c"}
{"compilable":0,"function":"int askCharQuestion(char *question) {\n    char answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %c\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askCharQuestion_name_conflict(unsigned long a0) {\n  char v0; // [bp-0x9]\n\n  v0 = 0;\n  printf(\"%s\\n> \", (unsigned int)a0);\n  __isoc99_scanf(\" %c\", (unsigned int)&v0);\n  fflush(stdin @GLIBC_2.2.5);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvfgwl9s6/askCharQuestion_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpvfgwl9s6/askCharQuestion_name_conflict.c:18:21: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpvfgwl9s6/askCharQuestion_name_conflict.c:27:17: error: expected ')'\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |                 ^\n/tmp/tmpvfgwl9s6/askCharQuestion_name_conflict.c:27:11: note: to match this '('\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int askIntQuestion(char *question) {\n    int answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %i\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askIntQuestion_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  printf(\"%s\\n> \", (unsigned int)a0);\n  __isoc99_scanf(\" %i\", (unsigned int)&v0);\n  fflush(stdin @GLIBC_2.2.5);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbbbdg08r/askIntQuestion_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpbbbdg08r/askIntQuestion_name_conflict.c:18:21: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpbbbdg08r/askIntQuestion_name_conflict.c:27:17: error: expected ')'\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |                 ^\n/tmp/tmpbbbdg08r/askIntQuestion_name_conflict.c:27:11: note: to match this '('\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"short askBoolQuestion(char *question) {\n    int response = -1;\n    do {\n        printf(\"%s\\n> \", question);\n        scanf(\" %i\", &response);\n        fflush(stdin);\n        if (response < 0 || response > 1) {\n            printf(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\\n\");\n        }\n    } while (response < 0 || response > 1);\n    return response;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askBoolQuestion_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = -1;\n  do {\n    do {\n      printf(\"%s\\n> \", (unsigned int)a0);\n      __isoc99_scanf(\" %i\", (unsigned int)&v0);\n      fflush(stdin @GLIBC_2.2.5);\n      if (v0 < 0 || v0 > 1)\n        puts(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\");\n    } while (v0 < 0);\n  } while (v0 > 1);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd9j0uukm/askBoolQuestion_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpd9j0uukm/askBoolQuestion_name_conflict.c:18:21: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpd9j0uukm/askBoolQuestion_name_conflict.c:31:25: error: expected ')'\n   31 |             fflush(stdin@GLIBC_2.2.5);\n      |                         ^\n/tmp/tmpd9j0uukm/askBoolQuestion_name_conflict.c:31:19: note: to match this '('\n   31 |             fflush(stdin@GLIBC_2.2.5);\n      |                   ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char *askStringQuestion(char *question, int maxLength) {\n    char *answer = calloc(maxLength + 1, sizeof(char));\n    printf(\"%s\\n> \", question);\n    fgets(answer, maxLength, stdin);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askStringQuestion(unsigned long a0, unsigned long a1) {\n  char *v0; // [bp-0x10]\n\n  v0 = calloc((unsigned int)a1 + 1, 1);\n  printf(\"%s\\n> \", (unsigned int)a0);\n  fgets(v0, a1, stdin @GLIBC_2.2.5);\n  fflush(stdin @GLIBC_2.2.5);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnaynp4ch/askStringQuestion.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:16:8: error: conflicting types for 'fgets'\n   16 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpnaynp4ch/askStringQuestion.c:106:8: error:\nunknown type name 'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t\n*stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:106:21: error: expected ';' after top level\ndeclarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpnaynp4ch/askStringQuestion.c:114:24: error: expected ')'\n  114 |     fgets(v0, a1, stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:114:10: note: to match this '('\n  114 |     fgets(v0, a1, stdin@GLIBC_2.2.5);\n      |          ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:115:17: error: expected ')'\n  115 |     fflush(stdin@GLIBC_2.2.5);\n      |                 ^\n/tmp/tmpnaynp4ch/askStringQuestion.c:115:11: note: to match this '('\n  115 |     fflush(stdin@GLIBC_2.2.5);\n      |           ^\n10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int multiprobabilisticRand(int probabilities[], int arraySize) {\n    int i, winner = -1, total = 0, choice = 0, currentTick = 0;\n    for (i = 0; i < arraySize; i++) {\n        total += probabilities[i];\n    }\n    choice = rand() % total;\n    for (i = 0; i < arraySize; i++) {\n        currentTick += probabilities[i];\n        if (choice < currentTick) {\n            winner = i;\n            break;\n        }\n    }\n    return winner;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long multiprobabilisticRand_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned int v1;       // [bp-0x18]\n  unsigned int v2;       // [bp-0x14]\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v6; // rax\n\n  v3 = -1;\n  v2 = 0;\n  v0 = 0;\n  v1 = 0;\n  for (v4 = 0; v4 < (unsigned int)a1; v4 += 1) {\n    v2 += a0[v4];\n  }\n  (unsigned int)v6 = rand();\n  v0 = ((unsigned int)v6 >> 31 CONCAT(unsigned int) v6) / m v2 >> 32;\n  for (v4 = 0; v4 < (unsigned int)a1; v4 += 1) {\n    v1 += a0[v4];\n    if (v0 < v1) {\n      v3 = v4;\n      return v3;\n    }\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgrf09xq_/multiprobabilisticRand_name_conflict.c:36:5: error: assignment to cast is\nillegal, lvalue casts are not supported 36 |     (unsigned int)v6 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpgrf09xq_/multiprobabilisticRand_name_conflict.c:37:34: error:\nexpected ')' 37 |     v0 = ((unsigned int)v6 >> 31 CONCAT (unsigned int)v6) /m\nv2 >> 32; |                                  ^\n/tmp/tmpgrf09xq_/multiprobabilisticRand_name_conflict.c:37:10: note: to match this '('\n   37 |     v0 = ((unsigned int)v6 >> 31 CONCAT (unsigned int)v6) /m v2 >> 32;\n      |          ^\n/tmp/tmpgrf09xq_/multiprobabilisticRand_name_conflict.c:37:61: error: expected ';' after\nexpression 37 |     v0 = ((unsigned int)v6 >> 31 CONCAT (unsigned int)v6) /m v2\n>> 32; |                                                             ^ | ; 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int randMinMax(int minimum, int maximum) {\n    return (rand() % (maximum - minimum)) + minimum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long randMinMax_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = a0;\n  (unsigned int)v2 = rand();\n  return v0 + (((unsigned int)v2 >> 31 CONCAT(unsigned int) v2) /\n                   m((unsigned int)a1 - (unsigned int)a0) >>\n               32);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo5c8knjs/randMinMax_name_conflict.c:24:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 24 |     (unsigned int)v2 = rand(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpo5c8knjs/randMinMax_name_conflict.c:25:42: error: expected ')'\n   25 |     return v0 + (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0) >> 32); | ^\n/tmp/tmpo5c8knjs/randMinMax_name_conflict.c:25:18: note: to match this '('\n   25 |     return v0 + (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0) >> 32); |                  ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char cycleChar(char original, int ticks) {\n    char alphabet[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int min = alphabet[0];\n    int max = alphabet[25];\n    if (isMutable(original))\n        return min + ((original + ticks - min) % 26);\n    return original;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(isMutable)(long long);\n\nlong long cycleChar_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;         // [bp-0x38]\n  char v1;         // [bp-0x2e]\n  char v2;         // [bp-0x1f]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  strncpy(&v0, \"ABCDEFGHIJKLMNOP\", 16);\n  strncpy(&v1, \"KLMNOPQRSTUVWXYZ\", 16);\n  v4 = v0;\n  v3 = v2;\n  return (!(char)isMutable(a0)\n              ? v4 + (unsigned int)(a1 + a0) - v4 -\n                    (unsigned int)(((unsigned int)(a1 + a0) - v4) / 26) * 26\n              : a0);\n}\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"bool isMutable(char c) {\n    int i;\n    char mutables[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (i = 0; i < 26; i++) {\n        if (mutables[i] == c)\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isMutable_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x28]\n  char v1;               // [bp-0x1e]\n  unsigned int v2;       // [bp-0xc]\n  unsigned long long v4; // rdx\n\n  strncpy(&v0, \"ABCDEFGHIJKLMNOP\", 16);\n  v4 = 6510331868474594387;\n  strncpy(&v1, \"KLMNOPQRSTUVWXYZ\", 16);\n  for (v2 = 0; v2 <= 25; v2 += 1) {\n    if ((char)a0 == (&v0)[v2])\n      return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"char *loadFileToDecode(char *fileName) {\n    int length = 0;\n    FILE *file = fopen(fileName, \"rb\");\n    char *buffer = ((void *)0);\n    if (file) {\n        fseek(file, 0, 2);\n        length = ftell(file);\n        fseek(file, 0, 0);\n        buffer = calloc(length + 1, sizeof(char));\n        fread(buffer, 1, length, file);\n        fclose(file);\n        return buffer;\n    } else {\n        error(\"Couldn't read input file\");\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long loadFileToDecode(char *a0) {\n  void *v0;        // [bp-0x20]\n  FILE_t *v1;      // [bp-0x18]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = &fopen(a0, \"rb\")->_flags;\n  v0 = 0;\n  if (!v1) {\n    error(\"Couldn't read input file\");\n    return 0;\n  }\n  fseek(v1, 0, 2);\n  v2 = ftell(v1);\n  fseek(v1, 0, 0);\n  v0 = calloc(v2 + 1, 1);\n  fread(v0, 1, v2, v1);\n  fclose(v1);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:76:22: error: type name requires a specifier\nor qualifier 76 |             } __value; |                      ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:83:22: error: type name requires a specifier\nor qualifier 83 |             } __value; |                      ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:251:13: error: declaration of anonymous\nunion must be a definition 251 |             union <anon> { |             ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:254:22: error: type name requires a\nspecifier or qualifier 254 |             } __value; |                      ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:258:13: error: declaration of anonymous\nunion must be a definition 258 |             union <anon> { |             ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:261:22: error: type name requires a\nspecifier or qualifier 261 |             } __value; |                      ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:194:16: error: conflicting types for 'fread'\n  194 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:319:16: error: redefinition of '_IO_marker'\n  319 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:325:16: error: redefinition of '_IO_codecvt'\n  325 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:329:16: error: redefinition of\n'_IO_wide_data' 329 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp4v7dp_8w/loadFileToDecode.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"long timediff(clock_t t1, clock_t t2) {\n    long elapsed;\n    elapsed = ((double)t2 - t1) / ((__clock_t)1000000) * 1000;\n    return elapsed;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble timediff_name_conflict(long long a0, long long a1) {\n  unsigned long v0; // [bp-0x28]\n  int tmp_51;       // tmp #51\n  int tmp_53;       // tmp #53\n  int tmp_52;       // tmp #52\n  unsigned long v1; // [bp-0x20]\n  unsigned long v2; // [bp-0x10]\n  int v4;           // xmm1\n\n  v1 = a0;\n  v0 = a1;\n  tmp_51 = DivV(tmp_53, tmp_52);\n  v4 = tmp_51;\n  v2 = (unsigned long long)((0 CONCAT 0x408f400000000000) * v4);\n  return (unsigned long long)((0 CONCAT 0x408f400000000000) * v4);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph2efu2u9/timediff_name_conflict.c:31:34: error: expected ')'\n   31 |     v2 = (unsigned long long)((0 CONCAT 0x408f400000000000) * v4);\n      |                                  ^\n/tmp/tmph2efu2u9/timediff_name_conflict.c:31:31: note: to match this '('\n   31 |     v2 = (unsigned long long)((0 CONCAT 0x408f400000000000) * v4);\n      |                               ^\n/tmp/tmph2efu2u9/timediff_name_conflict.c:32:36: error: expected ')'\n   32 |     return (unsigned long long)((0 CONCAT 0x408f400000000000) * v4);\n      |                                    ^\n/tmp/tmph2efu2u9/timediff_name_conflict.c:32:33: note: to match this '('\n   32 |     return (unsigned long long)((0 CONCAT 0x408f400000000000) * v4);\n      |                                 ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/main.c"}
{"compilable":0,"function":"inline Limit init_limit(unsigned int h, struct Limit lim) {\n    double WSd = (double)sizeof(WORD) * 8;\n    unsigned int WSi = (unsigned int)sizeof(WORD) * 8;\n    lim.h = h;\n    WORD yWord = (9223372036854775807L * 2UL + 1UL);\n    unsigned int shift_places = (WSi - (h % WSi)) % WSi;\n    yWord = yWord >> shift_places;\n    lim.yWord = yWord;\n    lim.words = (unsigned int)ceil((double)lim.h / WSd);\n    lim.yIndex = 0;\n    return lim;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_limit_name_conflict(unsigned long long a0[3], unsigned long a1) {\n  unsigned int v0;       // [bp-0x24]\n  int tmp_8;             // tmp #8\n  int tmp_9;             // tmp #9\n  int tmp_6;             // tmp #6\n  unsigned long v1;      // [bp-0x20], Other Possible Types: unsigned long long\n  unsigned int v2;       // [bp-0x14]\n  unsigned long long v3; // [bp-0x10]\n  unsigned int v4;       // [bp+0x8]\n  unsigned int v5;       // [bp+0xc]\n  unsigned int v6;       // [bp+0x10]\n  unsigned long v7;      // [bp+0x18]\n  int v8;                // xmm0\n\n  v3 = 0x4050000000000000;\n  v2 = 64;\n  v5 = a1;\n  v1 = -1;\n  v0 = (0 CONCAT v2 - ((0 CONCAT(unsigned int) a1) / m v2 >> 32)) / m v2 >> 32;\n  v1 >>= (char)v0 & 63;\n  v7 = v1;\n  tmp_8 = DivV(tmp_9, tmp_6);\n  v8 = tmp_8;\n  ceil((unsigned long long)v8);\n  v4 = (unsigned long long)v8;\n  v6 = 0;\n  a0[0] = *((long long *)&v4);\n  a0[1] = *((long long *)&v6);\n  a0[2] = v7;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpor3il0_m/init_limit_name_conflict.c:37:13: error: expected ')'\n   37 |     v0 = (0 CONCAT v2 - ((0 CONCAT (unsigned int)a1) /m v2 >> 32)) /m v2\n>> 32; |             ^ /tmp/tmpor3il0_m/init_limit_name_conflict.c:37:10: note: to match this\n'(' 37 |     v0 = (0 CONCAT v2 - ((0 CONCAT (unsigned int)a1) /m v2 >> 32)) /m\nv2 >> 32; |          ^ /tmp/tmpor3il0_m/init_limit_name_conflict.c:37:70: error: expected ';'\nafter expression 37 |     v0 = (0 CONCAT v2 - ((0 CONCAT (unsigned int)a1) /m v2\n>> 32)) /m v2 >> 32; | ^ | ; 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int popcount_words(WORD *words, int length) {\n    unsigned int count = 0;\n    unsigned int i;\n    for (i = 0; i < length; i++) {\n        count += __builtin_popcountl(words[i]);\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(__popcountdi2)(long long);\n\nlong long popcount_words_name_conflict(unsigned long long *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = 0;\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    v1 += (int)__popcountdi2(a0[v0]);\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shift_words(WORD *words, int length) {\n    WORD mask = (WORD)1 << ((int)sizeof(WORD) * 8 - 1);\n    WORD carried_bit = 0;\n    WORD temp;\n    int i;\n    for (i = length - 1; i > -1; i--) {\n        temp = words[i];\n        words[i] = (WORD)((words[i] << 1) | carried_bit);\n        carried_bit = (WORD)((temp & mask) != 0);\n    }\n    return words;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shift_words_name_conflict(unsigned long long *a0, unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned long long v1; // [bp-0x20]\n  unsigned int v2;       // [bp-0x14]\n  void *v3;              // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = 0x8000000000000000;\n  v3 = 0;\n  for (v2 = (unsigned int)a1 - 1; v2 >= 0; v2 -= 1) {\n    v0 = a0[v2];\n    a0[v2] = a0[v2] * 2 | v3;\n    v3 = (v0 & v1);\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu6xo5__a/shift_words_name_conflict.c:29:29: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 29 |         a0[v2] = a0[v2] * 2\n| v3; |                  ~~~~~~~~~~ ^ ~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shiftc_words(WORD *words, struct Limit lim) {\n    words = shift_words(words, lim.words);\n    words[lim.yIndex] = words[lim.yIndex] & lim.yWord;\n    return words;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(shift_words)(long long, long long);\n\nlong long shiftc_words(unsigned long long *a0, unsigned long a1,\n                       unsigned long a2, unsigned long a3, unsigned long a4,\n                       unsigned long a5, unsigned int v1, unsigned int a6,\n                       unsigned long a7) {\n  unsigned long long *v0; // [bp-0x10]\n\n  v0 = a0;\n  v0 = shift_words(v0, v1);\n  v0[a6] = v0[a6] & a7;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD delta(char a, char b) {\n    return (WORD)(a != b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long delta_name_conflict(unsigned long a0, unsigned long a1) {\n  return (char)a0 != (char)a1;\n}\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD ***M;\n    if ((M = (WORD ***)calloc((m + 1), sizeof(WORD **))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (i = 0; i < m + 1; i++) {\n        if ((M[i] = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M2 could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if ((M[i][j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n                fprintf(stderr, \" Error: M3 could not be allocated!\\n\");\n                return (0);\n            }\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0) {\n                if (i <= lim.h) {\n                    ones = shift_words(ones, lim.words);\n                    ones[lim.words - 1] = ones[lim.words - 1] + 1;\n                }\n                memcpy(M[i][j], ones, lim.words * sizeof(WORD));\n            } else {\n                for (k = 0; k < lim.words; k++) {\n                    M[i][j][k] = M[i - 1][j - 1][k];\n                }\n                M[i][j] = shiftc_words(M[i][j], lim);\n                M[i][j][lim.words - 1] = M[i][j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n            }\n            if (j >= lim.h && i >= lim.h) {\n                err = popcount_words(M[i][j], lim.words);\n                if (err < min_err) {\n                    min_err = err;\n                    (*dd) = min_err;\n                    (*ii) = i - 1;\n                    (*jj) = j - 1;\n                }\n            }\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            free(M[i][j]);\n        }\n        free(M[i]);\n    }\n    free(M);\n    free(ones);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_limit)(long long, long long);\nlong long(shift_words)(long long, long long);\nlong long(shiftc_words)(long long, long long, long long, long long, long long,\n                        long long, int, int, long long);\nlong long(delta)(long long, long long);\nlong long(popcount_words)(long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long maxshiftm_hd(char *a0, unsigned long a1, char *a2, unsigned long a3,\n                       unsigned long long a4, unsigned int *a5,\n                       unsigned int *v14, unsigned int *a6) {\n  char v0;                 // [bp-0xa8]\n  char *v1;                // [bp-0x70]\n  unsigned int v2;         // [bp-0x64]\n  char v3;                 // [bp-0x58]\n  char v4;                 // [bp-0x54]\n  char v5;                 // [bp-0x50]\n  char v6;                 // [bp-0x48]\n  unsigned int v7;         // [bp-0x3c]\n  void **v8;               // [bp-0x38]\n  unsigned long long *v9;  // [bp-0x30], Other Possible Types: unsigned long\n  unsigned int v10;        // [bp-0x28]\n  unsigned int v11;        // [bp-0x24]\n  unsigned int v12;        // [bp-0x20]\n  unsigned int v13;        // [bp-0x1c]\n  unsigned long long *v16; // rbx\n  unsigned long long *v17; // rbx\n  unsigned long long v18;  // rsi\n  unsigned long long v19;  // rdx\n\n  v2 = a1;\n  v1 = a2;\n  v10 = -1;\n  init_limit(&v3, (unsigned int)a4);\n  v9 = calloc(*((int *)&v3), 8);\n  if (!v9) {\n    fwrite(\" Error: ow could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v8 = calloc(v2 + 1, 8);\n  if (!v8) {\n    fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  for (v13 = 0; v13 < v2 + 1; v13 += 1) {\n    v16 = &v8[v13];\n    *(v16) = calloc((unsigned int)a3 + 1, 8);\n    if (!*(v16)) {\n      fwrite(\" Error: M2 could not be allocated!\\n\", 1, 35,\n             stderr @GLIBC_2.2.5);\n      return 0;\n    }\n  }\n  for (v13 = 0; v13 < v2 + 1; v13 += 1) {\n    for (v12 = 0; v12 < (unsigned int)a3 + 1; v12 += 1) {\n      v17 = v8[v13] + v12 * 8;\n      *(v17) = calloc(*((int *)&v3), 8);\n      if (!*(v17)) {\n        fwrite(\" Error: M3 could not be allocated!\\n\", 1, 35,\n               stderr @GLIBC_2.2.5);\n        return 0;\n      }\n    }\n  }\n  for (v13 = 1; v13 < v2 + 1; v13 += 1) {\n    for (v12 = 0; v12 < (unsigned int)a3 + 1; v12 += 1) {\n      if (!v12) {\n        if (*((int *)&v4) >= v13) {\n          v9 = shift_words(v9, *((int *)&v3));\n          *((long long *)(v9 + (*((int *)&v3) - 1) * 8)) =\n              *((long long *)(v9 + (*((int *)&v3) - 1) * 8)) + 1;\n        }\n        memcpy(*((long long *)((char *)v8[v13] + 8 * v12)), v9,\n               *((int *)&v3) * 8);\n      } else {\n        for (v11 = 0; v11 < *((int *)&v3); v11 += 1) {\n          *((long long *)(*((long long *)((char *)v8[v13] + 8 * v12)) +\n                          v11 * 8)) =\n              *((long long *)(*((long long *)(-8 + (char *)v8[1 + v13] +\n                                              8 * v12)) +\n                              v11 * 8));\n        }\n        v18 = *((long long *)((char *)v8[v13] + 8 * v12));\n        v19 = *((long long *)&v5);\n        *((long long *)((char *)v8[v13] + 8 * v12)) =\n            shiftc_words(v18, v18, v19, &v0, a4, a5, *((long long *)&v3), v19,\n                         *((long long *)&v6));\n        *((long long *)(*((long long *)((char *)v8[v13] + 8 * v12)) +\n                        (*((int *)&v3) - 1) * 8)) =\n            delta(a0[1 + v13], v1[1 + v12]) |\n            *((long long *)(*((long long *)((char *)v8[v13] + 8 * v12)) +\n                            (*((int *)&v3) - 1) * 8));\n      }\n      if (v12 >= *((int *)&(&v3)[4]) && v13 >= *((int *)&(&v3)[4])) {\n        v7 = popcount_words(*((long long *)((char *)v8[v13] + 8 * v12)),\n                            *((int *)&v3));\n        if (v7 < v10) {\n          v10 = v7;\n          *(a6) = v10;\n          *(a5) = v13 - 1;\n          *(v14) = v12 - 1;\n        }\n      }\n    }\n  }\n  for (v13 = 0; v13 < v2 + 1; v13 += 1) {\n    for (v12 = 0; v12 < (unsigned int)a3 + 1; v12 += 1) {\n      free(*((long long *)((char *)v8[v13] + 8 * v12)));\n    }\n    free(v8[v13]);\n  }\n  free(v8);\n  free(v9);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbzcw0iyi/maxshiftm_hd.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpbzcw0iyi/maxshiftm_hd.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpbzcw0iyi/maxshiftm_hd.c:52:69: error: expected ')'\n   52 |         fwrite(\" Error: ow could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpbzcw0iyi/maxshiftm_hd.c:52:15: note: to match\nthis '(' 52 |         fwrite(\" Error: ow could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); |               ^ /tmp/tmpbzcw0iyi/maxshiftm_hd.c:58:69:\nerror: expected ')' 58 |         fwrite(\" Error: M1 could not be allocated!\\n\",\n1, 35, stderr@GLIBC_2.2.5); | ^ /tmp/tmpbzcw0iyi/maxshiftm_hd.c:58:15: note: to\nmatch this '(' 58 |         fwrite(\" Error: M1 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmpbzcw0iyi/maxshiftm_hd.c:67:73: error: expected ')'\n   67 |             fwrite(\" Error: M2 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpbzcw0iyi/maxshiftm_hd.c:67:19: note: to match\nthis '(' 67 |             fwrite(\" Error: M2 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); |                   ^\n/tmp/tmpbzcw0iyi/maxshiftm_hd.c:79:77: error: expected ')'\n   79 |                 fwrite(\" Error: M3 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpbzcw0iyi/maxshiftm_hd.c:79:23: note: to match\nthis '(' 79 |                 fwrite(\" Error: M3 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |                       ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd_ls(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD **M0;\n    WORD **M1;\n    if ((M0 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M0 could not be allocated!\\n\");\n        return (0);\n    }\n    if ((M1 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (j = 0; j < n + 1; j++) {\n        if ((M0[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M0J could not be allocated!\\n\");\n            return (0);\n        }\n        if ((M1[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M1J could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0 && i <= lim.h) {\n                ones = shift_words(ones, lim.words);\n                ones[lim.words - 1] = ones[lim.words - 1] + 1;\n            }\n            switch (i % 2) {\n              case 0:\n                if (j == 0) {\n                    memcpy(M1[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M1[j][k] = M0[j - 1][k];\n                    }\n                    M1[j] = shiftc_words(M1[j], lim);\n                    M1[j][lim.words - 1] = M1[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M1[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n              case 1:\n                if (j == 0) {\n                    memcpy(M0[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M0[j][k] = M1[j - 1][k];\n                    }\n                    M0[j] = shiftc_words(M0[j], lim);\n                    M0[j][lim.words - 1] = M0[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M0[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (j = 0; j < n + 1; j++) {\n        free(M0[j]);\n        free(M1[j]);\n    }\n    free(M0);\n    free(M1);\n    free(ones);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_limit)(long long, long long);\nlong long(shift_words)(long long, long long);\nlong long(shiftc_words)(long long, long long, long long, long long, long long,\n                        long long, int, int, long long);\nlong long(delta)(long long, long long);\nlong long(popcount_words)(long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long maxshiftm_hd_ls(char *a0, unsigned long a1, char *a2,\n                          unsigned long a3, unsigned long long a4,\n                          unsigned int *a5, unsigned int *v15,\n                          unsigned int *a6) {\n  char v0;                 // [bp-0xb8]\n  char *v1;                // [bp-0x80]\n  unsigned int v2;         // [bp-0x74]\n  char v3;                 // [bp-0x68]\n  char v4;                 // [bp-0x64]\n  char v5;                 // [bp-0x60]\n  char v6;                 // [bp-0x58]\n  unsigned int v7;         // [bp-0x44]\n  void **v8;               // [bp-0x40]\n  void **v9;               // [bp-0x38]\n  unsigned long long *v10; // [bp-0x30], Other Possible Types: unsigned long\n  unsigned int v11;        // [bp-0x28]\n  unsigned int v12;        // [bp-0x24]\n  unsigned int v13;        // [bp-0x20]\n  unsigned int v14;        // [bp-0x1c]\n  unsigned long long *v17; // rbx\n  unsigned long long *v18; // rbx\n  unsigned int v19;        // eax\n  unsigned long long v20;  // rsi\n  unsigned long long v21;  // rdx\n  unsigned long long v22;  // rsi\n  unsigned long long v23;  // rdx\n\n  v2 = a1;\n  v1 = a2;\n  v11 = -1;\n  init_limit(&v3, (unsigned int)a4);\n  v10 = calloc(*((int *)&v3), 8);\n  if (!v10) {\n    fwrite(\" Error: ow could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v9 = calloc((unsigned int)a3 + 1, 8);\n  if (!v9) {\n    fwrite(\" Error: M0 could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v8 = calloc((unsigned int)a3 + 1, 8);\n  if (!v8) {\n    fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v13 = 0;\n  while (true) {\n    if (v13 < (unsigned int)a3 + 1) {\n      v17 = &v9[v13];\n      *(v17) = calloc(*((int *)&v3), 8);\n      if (!*(v17)) {\n        fwrite(\" Error: M0J could not be allocated!\\n\", 1, 36,\n               stderr @GLIBC_2.2.5);\n        return 0;\n      }\n      v18 = &v8[v13];\n      *(v18) = calloc(*((int *)&v3), 8);\n      if (!*(v18)) {\n        fwrite(\" Error: M1J could not be allocated!\\n\", 1, 36,\n               stderr @GLIBC_2.2.5);\n        return 0;\n      }\n      v13 += 1;\n    } else {\n      for (v14 = 1; v14 < v2 + 1; v14 += 1) {\n        for (v13 = 0; v13 < (unsigned int)a3 + 1; v13 += 1) {\n          if (!v13 && *((int *)&v4) >= v14) {\n            v10 = shift_words(v10, *((int *)&v3));\n            *((long long *)(v10 + (*((int *)&v3) - 1) * 8)) =\n                *((long long *)(v10 + (*((int *)&v3) - 1) * 8)) + 1;\n          }\n          v19 = v14 & 1;\n          if (!v19) {\n            if (!v13) {\n              memcpy(v8[v13], v10, *((int *)&v3) * 8);\n            } else {\n              for (v12 = 0; v12 < *((int *)&v3); v12 += 1) {\n                *((long long *)((char *)v8[v13] + 8 * v12)) =\n                    *((long long *)((char *)v9[1 + v13] + 8 * v12));\n              }\n              v20 = v8[v13];\n              v21 = *((long long *)&v5);\n              v8[v13] =\n                  shiftc_words(v20, v20, v21, &v0, a4, a5, *((long long *)&v3),\n                               v21, *((long long *)&v6));\n              *((long long *)(-8 + (char *)v8[v13] + 8 * *((int *)&v3))) =\n                  delta(a0[1 + v14], v1[1 + v13]) |\n                  *((long long *)(-8 + (char *)v8[v13] + 8 * *((int *)&v3)));\n            }\n            if (v13 >= *((int *)&v4) && v14 >= *((int *)&v4)) {\n              v7 = popcount_words(v8[v13], *((int *)&v3));\n              if (v7 < v11) {\n                v11 = v7;\n                *(a6) = v11;\n                *(a5) = v14 - 1;\n                *(v15) = v13 - 1;\n              }\n            }\n          } else if (v19 == 1) {\n            if (!v13) {\n              memcpy(v9[v13], v10, *((int *)&v3) * 8);\n            } else {\n              for (v12 = 0; v12 < *((int *)&v3); v12 += 1) {\n                *((long long *)((char *)v9[v13] + 8 * v12)) =\n                    *((long long *)((char *)v8[1 + v13] + 8 * v12));\n              }\n              v22 = v9[v13];\n              v23 = *((long long *)&v5);\n              v9[v13] =\n                  shiftc_words(v22, v22, v23, &v0, a4, a5, *((long long *)&v3),\n                               v23, *((long long *)&v6));\n              *((long long *)(-8 + (char *)v9[v13] + 8 * *((int *)&v3))) =\n                  delta(a0[1 + v14], v1[1 + v13]) |\n                  *((long long *)(-8 + (char *)v9[v13] + 8 * *((int *)&v3)));\n            }\n            if (v13 >= *((int *)&v4) && v14 >= *((int *)&v4)) {\n              v7 = popcount_words(v9[v13], *((int *)&v3));\n              if (v7 < v11) {\n                v11 = v7;\n                *(a6) = v11;\n                *(a5) = v14 - 1;\n                *(v15) = v13 - 1;\n              }\n            }\n          }\n        }\n      }\n      for (v13 = 0; v13 < (unsigned int)a3 + 1; v13 += 1) {\n        free(v9[v13]);\n        free(v8[v13]);\n      }\n      free(v9);\n      free(v8);\n      free(v10);\n      return 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:22:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:56:69: error: expected ')'\n   56 |         fwrite(\" Error: ow could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5cv47_92/maxshiftm_hd_ls.c:56:15: note: to\nmatch this '(' 56 |         fwrite(\" Error: ow could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:62:69: error: expected ')'\n   62 |         fwrite(\" Error: M0 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5cv47_92/maxshiftm_hd_ls.c:62:15: note: to\nmatch this '(' 62 |         fwrite(\" Error: M0 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:68:69: error: expected ')'\n   68 |         fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5cv47_92/maxshiftm_hd_ls.c:68:15: note: to\nmatch this '(' 68 |         fwrite(\" Error: M1 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:80:78: error: expected ')'\n   80 |                 fwrite(\" Error: M0J could not be allocated!\\n\", 1, 36,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5cv47_92/maxshiftm_hd_ls.c:80:23: note: to\nmatch this '(' 80 |                 fwrite(\" Error: M0J could not be\nallocated!\\n\", 1, 36, stderr@GLIBC_2.2.5); |                       ^\n/tmp/tmp5cv47_92/maxshiftm_hd_ls.c:87:78: error: expected ')'\n   87 |                 fwrite(\" Error: M1J could not be allocated!\\n\", 1, 36,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5cv47_92/maxshiftm_hd_ls.c:87:23: note: to\nmatch this '(' 87 |                 fwrite(\" Error: M1J could not be\nallocated!\\n\", 1, 36, stderr@GLIBC_2.2.5); |                       ^ 7 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"static int buf_prepare(size_t require) {\n    if (buf->size >= require) {\n        return 0;\n    }\n    buf->size = require * 2;\n    if (buf->size < 4096) {\n        buf->size = 4096;\n    }\n    if (buf->data == ((void *)0)) {\n        buf->data = malloc(buf->size);\n    } else {\n        buf->data = realloc(buf->data, buf->size);\n    }\n    if (buf->data == ((void *)0)) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\n\nextern struct_0 *buf;\n\nlong long buf_prepare_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v2; // rbx\n\n  v0 = v2;\n  if (*((long long *)&buf->field_8) >= a0)\n    return 0;\n  *((unsigned long *)&buf->field_8) = a0 * 2;\n  if (*((long long *)&buf->field_8) <= 4095)\n    *((long long *)&buf->field_8) = 0x1000;\n  if (!buf->field_0)\n    buf->field_0 = malloc(*((long long *)&buf->field_8));\n  else\n    buf->field_0 = realloc(buf->field_0, *((long long *)&buf->field_8));\n  return (!buf->field_0 ? 0 : 4294967295);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:29:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 29 | extern struct_0 *buf; |        ^~~~~~~~ |        struct\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:29:8: error: declaration of anonymous struct must\nbe a definition /tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:37:30: error: member reference\ntype 'int' is not a pointer 37 |     if (*((long long *)&buf->field_8) >= a0) |\n~~~  ^ /tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:39:30: error: member reference type 'int'\nis not a pointer 39 |     *((unsigned long *)&buf->field_8) = a0 * 2; | ~~~  ^\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:40:30: error: member reference type 'int' is not\na pointer 40 |     if (*((long long *)&buf->field_8) <= 4095) | ~~~  ^\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:41:30: error: member reference type 'int' is not\na pointer 41 |         *((long long *)&buf->field_8) = 0x1000; | ~~~  ^\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:42:15: error: member reference type 'int' is not\na pointer 42 |     if (!buf->field_0) |          ~~~  ^\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:43:14: error: member reference type 'int' is not\na pointer 43 |         buf->field_0 = malloc(*((long long *)&buf->field_8)); |\n~~~  ^ /tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:43:52: error: member reference type 'int'\nis not a pointer 43 |         buf->field_0 = malloc(*((long long\n*)&buf->field_8)); |                                               ~~~  ^\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:45:14: error: member reference type 'int' is not\na pointer 45 |         buf->field_0 = realloc(buf->field_0, *((long long\n*)&buf->field_8)); |         ~~~  ^ /tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:45:37: error:\nmember reference type 'int' is not a pointer 45 |         buf->field_0 =\nrealloc(buf->field_0, *((long long *)&buf->field_8)); | ~~~  ^\n/tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:45:67: error: member reference type 'int' is not\na pointer 45 |         buf->field_0 = realloc(buf->field_0, *((long long\n*)&buf->field_8)); | ~~~  ^ /tmp/tmpdls0iqrj/buf_prepare_name_conflict.c:46:19: error: member\nreference type 'int' is not a pointer 46 |     return (!buf->field_0 ? 0 :\n4294967295); |              ~~~  ^ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_connect(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (connect(fd, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nchar *(strncpy)(char *, char *, unsigned long);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\n\nlong long pt_comm_connect_name_conflict(char *a0) {\n  unsigned short v0; // [bp-0x88], Other Possible Types: char\n  char v1;           // [bp-0x86]\n  unsigned int v2;   // [bp-0xc]\n\n  v2 = socket(1, 1, 0);\n  if (v2 == -1)\n    return 4294967295;\n  memset(&v0, 0, 110);\n  v0 = 1;\n  strncpy(&v1, a0, 107);\n  return (connect(v2, &v0, 110) == -1 ? v2 : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_listen(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (unlink(addr.sun_path) == -1 && (*__errno_location()) != 2) {\n        return -1;\n    }\n    if (bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {\n        return -1;\n    }\n    if (chmod(addr.sun_path, (2048 | 1024 | 512 | (256 | 128 | 64) | ((256 | 128 | 64) >> 3) | (((256 | 128 | 64) >> 3) >> 3))) == 0) {\n        (*__errno_location()) = 0;\n    }\n    if (listen(fd, 128) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nchar *(strncpy)(char *, char *, unsigned long);\nint(unlink)(char *);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(chmod)(char *, unsigned short);\nint(listen)(int, int);\n\nlong long pt_comm_listen_name_conflict(char *a0) {\n  unsigned short v0; // [bp-0x88], Other Possible Types: char\n  char v1;           // [bp-0x86]\n  unsigned int v2;   // [bp-0xc]\n\n  v2 = socket(1, 1, 0);\n  if (v2 == -1)\n    return 4294967295;\n  memset(&v0, 0, 110);\n  v0 = 1;\n  strncpy(&v1, a0, 107);\n  if (unlink(&v1) == -1 && *(__errno_location()) != 2)\n    return 4294967295;\n  if (bind(v2, &v0, 110) == -1)\n    return 4294967295;\n  if (chmod(&v1, 4095))\n    return (listen(v2, 128) == -1 ? v2 : 4294967295);\n  *(__errno_location()) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9uscm1yp/pt_comm_listen_name_conflict.c:38:30: error: indirection requires pointer\noperand ('int' invalid) 38 |     if (unlink(&v1) == -1 && *(__errno_location())\n!= 2) |                              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9uscm1yp/pt_comm_listen_name_conflict.c:44:5: error: indirection requires pointer\noperand ('int' invalid) 44 |     *(__errno_location()) = 0; |\n^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_accept(int fd) {\n    struct sockaddr_un addr;\n    socklen_t addrlen = sizeof (addr);\n    return accept(fd, (struct sockaddr *)&addr, &addrlen);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long pt_comm_accept_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x7c]\n  sockaddr v1;     // [bp-0x78]\n\n  v0 = 110;\n  return accept(a0, &v1, &v0);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_recv_msg(int fd, pt_comm_message_t **msg_ptr) {\n    int i;\n    ssize_t retval, recvlen;\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t)) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    retval = recv(fd, msg, sizeof(pt_comm_message_t), MSG_DONTWAIT);\n    if (retval == -1) {\n        if ((*__errno_location()) == 11 || (*__errno_location()) == 11) {\n            return PT_MSG_EMPTY;\n        } else {\n            return PT_MSG_ERR_SOCK;\n        }\n    } else if (retval == 0) {\n        return PT_MSG_PEERDOWN;\n    } else if (retval != sizeof(pt_comm_message_t)) {\n        return PT_MSG_INVALID;\n    } else if (msg->len > 1024 * 1024 || msg->len < 0) {\n        return PT_MSG_INVALID;\n    }\n    if (msg->len == 0) {\n        return msg->type;\n    }\n    if (buf_prepare(sizeof(pt_comm_message_t) + msg->len) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    for (i = 0 , recvlen = 0; i < 10; i++) {\n        retval = recv(fd, msg->data + recvlen, msg->len - recvlen, 0);\n        if (retval == -1) {\n            return PT_MSG_ERR_SOCK;\n        } else if (retval == 0) {\n            return PT_MSG_PEERDOWN;\n        }\n        recvlen += retval;\n        if (recvlen == msg->len) {\n            break;\n        }\n    }\n    if (recvlen != msg->len) {\n        return PT_MSG_INVALID;\n    }\n    return msg->type;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint buf; // add global variable by heuristics\nint buf; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(buf_prepare)(long long);\nlong(recv)(int, void *, unsigned long, int);\n\nextern struct_0 *buf;\n\nlong long pt_comm_recv_msg_name_conflict(unsigned long a0, struct struct_1 **a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned int v1[2];    // [bp-0x20]\n  void *v2;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  if ((int)buf_prepare(12) == -1)\n    return 3;\n  *(a1) = buf->field_0;\n  *((struct struct_1 **)&v1[0]) = *(a1);\n  v0 = recv(a0, v1, 12, 64);\n  if (v0 == -1) {\n    if (!(*(__errno_location()) != 11 && *(__errno_location()) != 11))\n      return 0;\n    return 2;\n  } else if (!v0) {\n    return 1;\n  } else if (v0 != 12) {\n    return 4;\n  } else {\n    if (!(v1[0] <= 0x100000 && v1[0] >= 0))\n      return 4;\n    if (!v1[0]) {\n      return v1[1];\n    } else if ((int)buf_prepare(v1[0] + 12) == -1) {\n      return 3;\n    } else {\n      *(a1) = buf->field_0;\n      *((struct struct_1 **)&v1[0]) = *(a1);\n      v3 = 0;\n      for (v2 = 0; v3 <= 9; v3 += 1) {\n        v0 = recv(a0, (char *)&v1[1 + 1] + v2, v1[0] - v2, 0);\n        if (v0 == -1)\n          return 2;\n        if (!v0)\n          return 1;\n        v2 += v0;\n        if (v2 == v1[0])\n          break;\n      }\n      return (v2 == v1[0] ? 4 : v1[1]);\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:21:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 21 | extern struct_0 *buf; |        ^~~~~~~~ | struct\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:21:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:35:18: error: member\nreference type 'int' is not a pointer 35 |     *(a1) = buf->field_0; | ~~~  ^\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:40:15: error: indirection requires pointer\noperand ('int' invalid) 40 |         if (!(*(__errno_location()) != 11 &&\n*(__errno_location()) != 11)) |               ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:40:46: error: indirection requires pointer\noperand ('int' invalid) 40 |         if (!(*(__errno_location()) != 11 &&\n*(__errno_location()) != 11)) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:66:26: error: member reference type 'int' is\nnot a pointer 66 |             *(a1) = buf->field_0; |                     ~~~ ^\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:71:50: error: invalid operands to binary\nexpression ('char *' and 'void *') 71 |                 v0 = recv(a0, (char\n*)&v1[1 + 1] + v2, v1[0] - v2, 0); | ~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpfsamz8fc/pt_comm_recv_msg_name_conflict.c:71:62: error: invalid operands to binary\nexpression ('unsigned int' and 'void *') 71 |                 v0 = recv(a0,\n(char *)&v1[1 + 1] + v2, v1[0] - v2, 0); | ~~~~~ ^ ~~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_build_msg(pt_comm_message_t **msg_ptr, size_t size, int type) {\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t) + size) == -1) {\n        return -1;\n    }\n    msg = *msg_ptr = buf->data;\n    msg->len = size;\n    msg->type = type;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint buf; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(buf_prepare)(long long);\n\nextern struct_0 *buf;\n\nlong long pt_comm_build_msg(struct struct_1 **a0, unsigned long a1,\n                            unsigned long a2) {\n  unsigned int v0[2]; // [bp-0x10]\n\n  if ((int)buf_prepare(a1 + 12) == -1)\n    return 4294967295;\n  *(a0) = buf->field_0;\n  *((struct struct_1 **)&v0[0]) = *(a0);\n  v0[0] = a1;\n  v0[1] = a2;\n  return 0;\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3_sgdf5t/pt_comm_build_msg.c:19:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 19 | extern struct_0 *buf; |        ^~~~~~~~ | struct\n/tmp/tmp3_sgdf5t/pt_comm_build_msg.c:19:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmp3_sgdf5t/pt_comm_build_msg.c:27:18: error:\nmember reference type 'int' is not a pointer 27 |     *(a0) = buf->field_0; |\n~~~  ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_type(int fd, int type) {\n    pt_comm_message_t *msg;\n    if (pt_comm_build_msg(&msg, 0, type) == -1) {\n        return -1;\n    }\n    return pt_comm_send_msg(fd, msg);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pt_comm_build_msg)(long long, long long, long long);\nlong long(pt_comm_send_msg)(long long, long long);\n\nlong long pt_comm_send_type_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0; // [bp-0x10]\n\n  if ((int)pt_comm_build_msg(&v0, 0, (unsigned int)a1) != -1)\n    return pt_comm_send_msg((unsigned int)a0, *((long long *)&v0));\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_msg(int fd, pt_comm_message_t *msg) {\n    ssize_t retval;\n    retval = send(fd, msg, sizeof(pt_comm_message_t), 0);\n    if (retval == -1) {\n        return -1;\n    }\n    if (msg->len == 0) {\n        return 0;\n    }\n    retval = send(fd, msg->data, msg->len, 0);\n    if (retval == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\n\nlong long pt_comm_send_msg_name_conflict(unsigned long a0, unsigned int *a1) {\n  char v0;          // [bp-0x1c]\n  unsigned long v1; // [bp-0x10]\n\n  v1 = send(a0, a1, 12, 0);\n  if (v1 == -1) {\n    return 4294967295;\n  } else if (*(a1)) {\n    v1 = send(*((int *)&v0), a1 + 3, *(a1), 0);\n    return (v1 == -1 ? 0 : 4294967295);\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_close(int fd, const char *addrstr) {\n    if (addrstr != ((void *)0)) {\n        unlink(addrstr);\n    }\n    return close(fd);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nint(unlink)(char *);\n\nlong long pt_comm_close_name_conflict(unsigned long a0, char *a1) {\n  if (a1)\n    unlink(a1);\n  return close(a0);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"static int has_color(void) {\n    if (output_is_tty == -1) {\n        output_is_tty = isatty(1);\n    }\n    return output_is_tty == 1 ? 1 : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int output_is_tty;\n\nlong long has_color_name_conflict() {\n  if (output_is_tty == -1) {\n    output_is_tty = isatty(1);\n    return output_is_tty == 1;\n  }\n  return output_is_tty == 1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_type.c"}
{"compilable":0,"function":"static int pt_send_msg(int fd) {\n    if (clictx.pft.type != (1 << 0)) {\n        pt_comm_message_t *msg;\n        if (pt_comm_build_msg(&msg, sizeof(pt_filter_t), PT_MSG_DO_FILTER) == -1) {\n            return -1;\n        }\n        pt_filter_pack_filter_msg(&clictx.pft, msg->data);\n        if (pt_comm_send_msg(fd, msg) == -1) {\n            return -1;\n        }\n    }\n    if (clictx.pft.type != (1 << 1)) {\n        return pt_comm_send_type(fd, PT_MSG_DO_TRACE);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pt_comm_build_msg)(long long, long long, long long);\nlong long(pt_comm_send_type)(long long, long long);\nlong long(pt_filter_pack_filter_msg)(long long, long long);\nlong long(pt_comm_send_msg)(long long, long long);\n\nextern char g_40c4a8;\n\nlong long pt_send_msg_name_conflict(unsigned long a0) {\n  char v0; // [bp-0x10]\n\n  if (g_40c4a8 != 1) {\n    if ((int)pt_comm_build_msg(&v0, 16, 2147483651) == -1)\n      return 4294967295;\n    pt_filter_pack_filter_msg(&g_40c4a8, *((long long *)&v0) + 12);\n    if ((int)pt_comm_send_msg((unsigned int)a0, *((long long *)&v0)) == -1)\n      return 4294967295;\n  }\n  if (g_40c4a8 == 2)\n    return 0;\n  return pt_comm_send_type((unsigned int)a0, 2147483649);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/trace.c"}
{"compilable":0,"function":"int pt_status_main(void) {\n    int ret, try_ptrace;\n    try_ptrace = 0;\n    if (!clictx.ptrace) {\n        ret = status_ext();\n        if (ret == -1) {\n            printf(\"Fetch status error\\n\");\n            try_ptrace = 1;\n        } else if (ret == -2) {\n            printf(\"Operation timed out, no response received, make sure PHP process is active and extension already installed.\\n\");\n            try_ptrace = 1;\n        }\n    }\n    try_ptrace = 0;\n    if (clictx.ptrace || try_ptrace) {\n        ret = status_ptrace();\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(status_ext)(long long, long long, long long, long long, long long,\n                      long long);\nlong long(status_ptrace)(long long, long long, long long, long long, long long,\n                         long long);\n\nextern unsigned int g_40c28c;\n\nlong long pt_status_main(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2, unsigned long long a3,\n                         unsigned long long a4, unsigned long long a5) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  if (!g_40c28c) {\n    v1 = status_ext(a0, a1, a2, a3, a4, a5);\n    if (v1 == -1) {\n      puts(\"Fetch status error\");\n      v0 = 1;\n    } else if (v1 == -2) {\n      puts(\"Operation timed out, no response received, make sure PHP process \"\n           \"is active and extension already installed.\");\n      v0 = 1;\n    }\n  }\n  v0 = 0;\n  if (!g_40c28c && !v0)\n    return v1;\n  v1 = status_ptrace(a0, a1, a2, a3, a4, a5);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/status.c"}
{"compilable":0,"function":"sds sdsempty(void) {\n    return sdsnewlen(\"\", 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\n\nextern unsigned long long g_409d78;\n\nlong long sdsempty_name_conflict() { return sdsnewlen(&g_409d78, 0); }\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsnew(const char *init) {\n    size_t initlen = (init == ((void *)0)) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnew_name_conflictlen)(long long, long long);\n\nlong long sdsnew_name_conflict(char *a0) {\n  unsigned long long v0; // [bp-0x10]\n  void *v2;              // rax, Other Possible Types: unsigned long\n\n  if (!a0)\n    v2 = 0;\n  else\n    v2 = strlen(a0);\n  v0 = v2;\n  return sdsnew_name_conflictlen(a0, v0);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdslen)(long long);\nlong long(sdsnewlen)(long long, long long);\n\nlong long sdsdup_name_conflict(unsigned long long a0) {\n  return sdsnewlen(a0, ::0x406ec9 ::sdslen(a0));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7pv8mr95/sdsdup_name_conflict.c:21:26: error: expected expression\n   21 |     return sdsnewlen(a0, ::0x406ec9::sdslen(a0));\n      |                          ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsMakeRoomFor(sds s, size_t addlen) {\n    struct sdshdr *sh, *newsh;\n    size_t free = sdsavail(s);\n    size_t len, newlen;\n    if (free >= addlen)\n        return s;\n    len = sdslen(s);\n    sh = (void *)(s - sizeof *sh);\n    ;\n    newlen = (len + addlen);\n    if (newlen < (1024 * 1024))\n        newlen *= 2;\n    else\n        newlen += (1024 * 1024);\n    newsh = realloc(sh, sizeof *newsh + newlen + 1);\n    if (newsh == ((void *)0))\n        return ((void *)0);\n    newsh->free = newlen - len;\n    return newsh->buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsavail)(long long);\nlong long(sdslen)(long long);\nvoid *(realloc)(void *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nlong long sdsMakeRoomFor_name_conflict(unsigned long long a0, unsigned long a1) {\n  struct_0 *v0;          // [bp-0x30]\n  void *v1;              // [bp-0x28]\n  unsigned long v2;      // [bp-0x20]\n  unsigned long v3;      // [bp-0x18]\n  unsigned long v4;      // [bp-0x10]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n\n  v7 = &v5;\n  v3 = sdsavail(a0);\n  if (v3 >= a1)\n    return a0;\n  v2 = ::0x406ec9 ::sdslen(a0);\n  v1 = a0 - 8;\n  v4 = a1 + v2;\n  if (v4 <= 1048575)\n    v4 *= 2;\n  else\n    v4 += 0x100000;\n  v0 = realloc(v1, v4 + 9);\n  if (!v0)\n    return 0;\n  v0->field_4 = v4 - v2;\n  return v0 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4usjm24i/sdsMakeRoomFor_name_conflict.c:39:10: error: expected expression\n   39 |     v2 = ::0x406ec9::sdslen(a0);\n      |          ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsRemoveFreeSpace(sds s) {\n    struct sdshdr *sh;\n    sh = (void *)(s - sizeof *sh);\n    ;\n    sh = realloc(sh, sizeof *sh + sh->len + 1);\n    sh->free = 0;\n    return sh->buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\n\nlong long sdsRemoveFreeSpace_name_conflict(unsigned long a0) {\n  unsigned int v0[2]; // [bp-0x10]\n\n  *((unsigned long *)&v0[0]) = a0 - 8;\n  *((void **)&v0[0]) = realloc(v0, v0[0] + 9);\n  v0[1] = 0;\n  return v0 + 1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"size_t sdsAllocSize(sds s) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    return sizeof (*sh) + sh->len + sh->free + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sdsAllocSize_name_conflict(unsigned long a0) {\n  unsigned int v0[2]; // [bp-0x10]\n\n  *((unsigned long *)&v0[0]) = a0 - 8;\n  return v0[1] + v0[0] + 9;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsgrowzero(sds s, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    size_t totlen, curlen = sh->len;\n    if (len <= curlen)\n        return s;\n    s = sdsMakeRoomFor(s, len - curlen);\n    if (s == ((void *)0))\n        return ((void *)0);\n    sh = (void *)(s - sizeof *sh);\n    memset(s + curlen, 0, (len - curlen + 1));\n    totlen = sh->len + sh->free;\n    sh->len = len;\n    sh->free = totlen - sh->len;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsMakeRoomFor)(long long, long long);\n\nlong long sdsgrowzero_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v0; // [bp-0x30], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x20]\n  unsigned long v2;      // [bp-0x18]\n  unsigned int v3[2];    // [bp-0x10]\n\n  v0 = a0;\n  *((unsigned long long *)&v3[0]) = v0 - 8;\n  v2 = v3[0];\n  if (v2 >= a1)\n    return v0;\n  v0 = sdsMakeRoomFor(v0, a1 - v2);\n  if (!v0)\n    return 0;\n  *((unsigned long long *)&v3[0]) = v0 - 8;\n  memset(v2 + v0, 0, a1 - v2 + 1);\n  v1 = v3[1] + v3[0];\n  v3[0] = a1;\n  v3[1] = v1 - v3[0];\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscat_name_conflictlen)(long long, long long, long long);\n\nlong long sdscat_name_conflict(unsigned long long a0, char *a1) {\n  return sdscat_name_conflictlen(a0, a1, strlen(a1));\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdslen)(long long);\nlong long(sdscatlen)(long long, long long, long long);\n\nlong long sdscatsds_name_conflict(unsigned long long a0, unsigned long long a1) {\n  return sdscatlen(a0, a1, ::0x406ec9 ::sdslen(a1));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpitw5a1ro/sdscatsds_name_conflict.c:21:30: error: expected expression\n   21 |     return sdscatlen(a0, a1, ::0x406ec9::sdslen(a1));\n      |                              ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpylen(sds s, const char *t, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    size_t totlen = sh->free + sh->len;\n    if (totlen < len) {\n        s = sdsMakeRoomFor(s, len - sh->len);\n        if (s == ((void *)0))\n            return ((void *)0);\n        sh = (void *)(s - sizeof *sh);\n        ;\n        totlen = sh->free + sh->len;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\x00';\n    sh->len = len;\n    sh->free = totlen - len;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsMakeRoomFor)(long long, long long);\n\nlong long sdscpylen_name_conflict(char *a0, void *a1, unsigned long a2) {\n  char *v0;           // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v1;   // [bp-0x18]\n  unsigned int v2[2]; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  *((char **)&v2[0]) = v0 + 8;\n  v1 = v2[0] + v2[1];\n  if (v1 < a2) {\n    v0 = sdsMakeRoomFor(v0, a2 - v2[0]);\n    if (!v0)\n      return 0;\n    v2 = v0 + 8;\n    v1 = v2[0] + v2[1];\n  }\n  memcpy(v0, a1, a2);\n  *((char *)(a2 + v0)) = 0;\n  *((unsigned int *)v2) = a2;\n  *((unsigned int *)(v2 + 4)) = v1 - a2;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2i544uc1/sdscpylen_name_conflict.c:32:12: error: array type 'unsigned int[2]' is not\nassignable 32 |         v2 = v0 + 8; |         ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscpy_name_conflictlen)(long long, long long, long long);\n\nlong long sdscpy_name_conflict(unsigned long long a0, char *a1) {\n  return sdscpy_name_conflictlen(a0, a1, strlen(a1));\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    __builtin_va_start(ap, fmt);\n    t = sdscatvprintf(s, fmt, ap);\n    __builtin_va_end(ap);\n    return t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscatvprintf)(long long, long long, long long);\n\nlong long sdscatprintf_name_conflict() {\n  unsigned int v0;        // [bp-0xd8]\n  unsigned int v1;        // [bp-0xd4]\n  unsigned long v2;       // [bp-0xd0]\n  unsigned long v3;       // [bp-0xc8]\n  unsigned long v4;       // [bp-0xc0]\n  char v5;                // [bp-0xb8]\n  unsigned long v6;       // [bp-0xa8]\n  unsigned long v7;       // [bp-0xa0]\n  unsigned long v8;       // [bp-0x98]\n  unsigned long v9;       // [bp-0x90]\n  int v10;                // [bp-0x88]\n  int v11;                // [bp-0x78]\n  int v12;                // [bp-0x68]\n  int v13;                // [bp-0x58]\n  int v14;                // [bp-0x48]\n  int v15;                // [bp-0x38]\n  int v16;                // [bp-0x28]\n  int v17;                // [bp-0x18]\n  unsigned long v18;      // [bp+0x8]\n  unsigned long v19;      // rdx\n  unsigned long v20;      // rcx\n  unsigned long v21;      // r8\n  unsigned long v22;      // r9\n  char v23;               // al\n  int v24;                // xmm0\n  int v25;                // xmm1\n  int v26;                // xmm2\n  int v27;                // xmm3\n  int v28;                // xmm4\n  int v29;                // xmm5\n  int v30;                // xmm6\n  int v31;                // xmm7\n  unsigned long long v32; // rdi\n  unsigned long long v33; // rsi\n\n  v6 = v19;\n  v7 = v20;\n  v8 = v21;\n  v9 = v22;\n  if (v23) {\n    v10 = v24;\n    v11 = v25;\n    v12 = v26;\n    v13 = v27;\n    v14 = v28;\n    v15 = v29;\n    v16 = v30;\n    v17 = v31;\n  }\n  v0 = 16;\n  v1 = 48;\n  v2 = &v18;\n  v3 = &v5;\n  v4 = sdscatvprintf(v32, v33, &v0);\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1, s2, minlen);\n    if (cmp == 0)\n        return l1 - l2;\n    return cmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdslen)(long long);\n\nlong long sdscmp_name_conflict(void *a0, void *a1) {\n  unsigned int v0;  // [bp-0x24]\n  unsigned int v1;  // [bp-0x20]\n  unsigned long v2; // [bp-0x18]\n  unsigned long v3; // [bp-0x10]\n  unsigned long v5; // rax, Other Possible Types: unsigned long long\n\n  v3 = ::0x406ec9 ::sdslen(a0);\n  v2 = ::0x406ec9 ::sdslen(a1);\n  v5 = v3;\n  if (v5 <= v5)\n    v5 = v2;\n  *((unsigned long *)&v1) = v5;\n  v0 = memcmp(a0, a1, *((long long *)&v1));\n  return (!v0 ? v0 : v3 - v2);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq8o6k3od/sdscmp_name_conflict.c:26:10: error: expected expression\n   26 |     v3 = ::0x406ec9::sdslen(a0);\n      |          ^\n/tmp/tmpq8o6k3od/sdscmp_name_conflict.c:27:10: error: expected expression\n   27 |     v2 = ::0x406ec9::sdslen(a1);\n      |          ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5, start = 0, j;\n    sds *tokens;\n    if (seplen < 1 || len < 0)\n        return ((void *)0);\n    tokens = malloc(sizeof(sds) * slots);\n    if (tokens == ((void *)0))\n        return ((void *)0);\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len - (seplen - 1)); j++) {\n        if (slots < elements + 2) {\n            sds *newtokens;\n            slots *= 2;\n            newtokens = realloc(tokens, sizeof(sds) * slots);\n            if (newtokens == ((void *)0))\n                goto cleanup;\n            tokens = newtokens;\n        }\n        if ((seplen == 1 && *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s + start, j - start);\n            if (tokens[elements] == ((void *)0))\n                goto cleanup;\n            elements++;\n            start = j + seplen;\n            j = j + seplen - 1;\n        }\n    }\n    tokens[elements] = sdsnewlen(s + start, len - start);\n    if (tokens[elements] == ((void *)0))\n        goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n  cleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++)\n            sdsfree(tokens[i]);\n        free(tokens);\n        *count = 0;\n        return ((void *)0);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\nvoid *(realloc)(void *, unsigned long);\nlong long(sdsfree)(long long);\n\nlong long sdssplitlen(char *a0, unsigned long a1, char *a2, unsigned long a3,\n                      unsigned int *a4) {\n  unsigned long long *v0; // [bp-0x40]\n  unsigned int v1;        // [bp-0x34]\n  unsigned long long *v2; // [bp-0x30], Other Possible Types: unsigned long\n  unsigned int v3;        // [bp-0x28]\n  unsigned int v4;        // [bp-0x24]\n  unsigned int v5;        // [bp-0x20]\n  unsigned int v6;        // [bp-0x1c]\n\n  v6 = 0;\n  v5 = 5;\n  v4 = 0;\n  if (!((unsigned int)a3 > 0 && (unsigned int)a1 >= 0))\n    return 0;\n  v2 = malloc(v5 * 8);\n  if (!v2) {\n    return 0;\n  } else if (!(unsigned int)a1) {\n    *(a4) = 0;\n    return v2;\n  } else {\n    v3 = 0;\n    while (true) {\n      if (v3 >= (unsigned int)a1 - ((unsigned int)a3 - 1)) {\n        *((long long *)(v6 * 8 + v2)) =\n            sdsnewlen(&a0[v4], (unsigned int)a1 - v4);\n        if (*((long long *)(v2 + (v6 << 3)))) {\n          v6 += 1;\n          *(a4) = v6;\n          return v2;\n        }\n        goto LABEL_407d81;\n      }\n      if (v5 <= v6 + 1) {\n        v5 *= 2;\n        v0 = realloc(v2, v5 * 8);\n        if (!v0)\n          goto LABEL_407d81;\n        else\n          v2 = v0;\n      }\n      if (!((unsigned int)a3 != 1) && !(a0[v3] != *(a2)) ||\n          !(memcmp(&a0[v3], a2, (unsigned int)a3))) {\n        *((long long *)(v6 * 8 + v2)) = sdsnewlen(&a0[v4], v3 - v4);\n        if (*((long long *)(v2 + (v6 << 3)))) {\n          v6 += 1;\n          v4 = (unsigned int)a3 + v3;\n          v3 = (unsigned int)a3 + v3 - 1;\n        } else {\n        LABEL_407d81:\n          for (v1 = 0; v1 < v6; v1 += 1) {\n            sdsfree(*((long long *)(v2 + v1 * 8)));\n          }\n        }\n      }\n      v3 += 1;\n    }\n    free(v2);\n    *(a4) = 0;\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsfromlonglong(long long value) {\n    char buf[32], *p;\n    unsigned long long v;\n    v = (value < 0) ? -value : value;\n    p = buf + 31;\n    do {\n        *p-- = '0' + (v % 10);\n        v /= 10;\n    } while (v);\n    if (value < 0)\n        *p-- = '-';\n    p++;\n    return sdsnewlen(p, 32 - (p - buf));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\n\nlong long sdsfromlonglong_name_conflict(unsigned long a0) {\n  char v0;          // [bp-0x38]\n  char v1;          // [bp-0x19]\n  unsigned long v2; // [bp-0x18], Other Possible Types: unsigned long long\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long v5; // rax, Other Possible Types: unsigned long long\n  char v8;          // cl\n  char *v9;         // rax\n  char *v10;        // rax\n\n  v5 = a0;\n  if ((char)(-(a0) >> 63 ^ 1))\n    v5 = -(a0);\n  v2 = v5;\n  v3 = &v1;\n  do {\n    v8 = (char)v2 - 5 * (char)(v2 * 14757395258967641293 >> 64 >> 3) * 2 + 48;\n    v9 = v3;\n    v3 = v9 + 1;\n    *(v9) = v8;\n    v2 = v2 * 14757395258967641293 >> 64 >> 3;\n  } while (v2);\n  if ((char)(a0 - 0 >> 63)) {\n    v10 = v3;\n    v3 = v10 + 1;\n    *(v10) = 45;\n  }\n  v3 += 1;\n  return sdsnewlen(v3, 32 - (v3 - &v0));\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s, \"\\\"\", 1);\n    while (len--)\n        {\n            switch (*p) {\n              case '\\\\':\n              case '\"':\n                s = sdscatprintf(s, \"\\\\%c\", *p);\n                break;\n              case '\\n':\n                s = sdscatlen(s, \"\\\\n\", 2);\n                break;\n              case '\\r':\n                s = sdscatlen(s, \"\\\\r\", 2);\n                break;\n              case '\\t':\n                s = sdscatlen(s, \"\\\\t\", 2);\n                break;\n              case '\\a':\n                s = sdscatlen(s, \"\\\\a\", 2);\n                break;\n              case '\\b':\n                s = sdscatlen(s, \"\\\\b\", 2);\n                break;\n              default:\n                if (((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISprint))\n                    s = sdscatprintf(s, \"%c\", *p);\n                else\n                    s = sdscatprintf(s, \"\\\\x%02x\", (unsigned char)*p);\n                break;\n            }\n            p++;\n        }\n    return sdscatlen(s, \"\\\"\", 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscatlen)(long long, long long, long long);\nlong long(sdscatprintf)(...);\n\ntypedef struct struct_0 {\n  char padding_0[4234728];\n  unsigned int field_409de8;\n} struct_0;\n\nextern char g_409de8;\n\nlong long sdscatrepr_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned long v0;      // [bp-0x20]\n  char *v1;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long v2;      // [bp-0x10], Other Possible Types: unsigned long long\n  unsigned long long v4; // rax\n  unsigned int v5;       // eax\n\n  v2 = a0;\n  v1 = a1;\n  v0 = a2;\n  v2 = sdscatlen(v2, \"\\\"\", 1);\n  while (v4) {\n    v4 = v0;\n    v0 = v4 - 1;\n    v5 = *(v1);\n    if (v5 > 34) {\n      if (v5 == 92)\n        goto LABEL_407f85;\n      else\n        goto LABEL_408064;\n    } else if (v5 < 7) {\n    LABEL_408064:\n    } else {\n      switch (v5) {\n      case 7:\n        v2 = sdscatlen(v2, \"\\\\a\", 2);\n        break;\n      case 8:\n        v2 = sdscatlen(v2, \"\\\\b\", 2);\n        break;\n      case 9:\n        v2 = sdscatlen(v2, \"\\\\t\", 2);\n        break;\n      case 10:\n        v2 = sdscatlen(v2, \"\\\\n\", 2);\n        break;\n      case 11:\n      case 12:\n      case 14:\n      case 15:\n      case 16:\n      case 17:\n      case 18:\n      case 19:\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 28:\n      case 29:\n      case 30:\n      case 31:\n      case 32:\n      case 33:\n      LABEL_408064:\n        if (!(*((short *)((*(v1) << 1) + *((long long *)&__ctype_b_loc()))) &\n              0x4000))\n          v2 = sdscatprintf();\n        else\n          v2 = sdscatprintf();\n        break;\n      case 13:\n        v2 = sdscatlen(v2, \"\\\\r\", 2);\n        break;\n      case 34:\n      LABEL_407f85:\n        v2 = sdscatprintf();\n        break;\n      default:\n      LABEL_408064:\n        if (!(*((short *)((*(v1) << 1) + *((long long *)&__ctype_b_loc()))) &\n              0x4000))\n          v2 = sdscatprintf();\n        else\n          v2 = sdscatprintf();\n        break;\n      }\n      v1 += 1;\n    }\n  }\n  return sdscatlen(v2, \"\\\"\", 1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:17:26: error: ISO C requires a named parameter\nbefore '...' 17 | long long (sdscatprintf)(...); |                          ^\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:72:65: error: cannot take the address of an rvalue\nof type 'int' 72 |                 if (!(*((short *)((*(v1) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x4000)) | ^~~~~~~~~~~~~~~~\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:71:1: error: redefinition of label 'LABEL_408064'\n   71 | LABEL_408064:\n      | ^\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:52:1: note: previous definition is here\n   52 | LABEL_408064:\n      | ^\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:86:65: error: cannot take the address of an rvalue\nof type 'int' 86 |                 if (!(*((short *)((*(v1) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x4000)) | ^~~~~~~~~~~~~~~~\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:85:1: error: redefinition of label 'LABEL_408064'\n   85 | LABEL_408064:\n      | ^\n/tmp/tmpty0mj0ea/sdscatrepr_name_conflict.c:52:1: note: previous definition is here\n   52 | LABEL_408064:\n      | ^\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_hex_digit_name_conflict(unsigned long a0) {\n  if (((char)a0 <= 47 || (char)a0 > 57) && ((char)a0 <= 96 || (char)a0 > 102) &&\n      (!((char)a0 > 64) || !((char)a0 <= 70)))\n    return 0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int hex_digit_to_int(char c) {\n    switch (c) {\n      case '0':\n        return 0;\n      case '1':\n        return 1;\n      case '2':\n        return 2;\n      case '3':\n        return 3;\n      case '4':\n        return 4;\n      case '5':\n        return 5;\n      case '6':\n        return 6;\n      case '7':\n        return 7;\n      case '8':\n        return 8;\n      case '9':\n        return 9;\n      case 'a':\n      case 'A':\n        return 10;\n      case 'b':\n      case 'B':\n        return 11;\n      case 'c':\n      case 'C':\n        return 12;\n      case 'd':\n      case 'D':\n        return 13;\n      case 'e':\n      case 'E':\n        return 14;\n      case 'f':\n      case 'F':\n        return 15;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4234840];\n  unsigned int field_409e58;\n} struct_0;\n\nextern char g_409e58;\n\nlong long hex_digit_to_int_name_conflict(unsigned long a0) {\n  switch ((char)a0) {\n  case 48:\n    return 0;\n  case 49:\n    return 1;\n  case 50:\n    return 2;\n  case 51:\n    return 3;\n  case 52:\n    return 4;\n  case 53:\n    return 5;\n  case 54:\n    return 6;\n  case 55:\n    return 7;\n  case 56:\n    return 8;\n  case 57:\n    return 9;\n  case 65:\n  case 97:\n    return 10;\n  case 66:\n  case 98:\n    return 11;\n  case 67:\n  case 99:\n    return 12;\n  case 68:\n  case 100:\n    return 13;\n  case 69:\n  case 101:\n    return 14;\n  case 70:\n  case 102:\n    return 15;\n  default:\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = ((void *)0);\n    char **vector = ((void *)0);\n    *argc = 0;\n    while (1)\n        {\n            while (*p && ((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISspace))\n                p++;\n            if (*p) {\n                int inq = 0;\n                int insq = 0;\n                int done = 0;\n                if (current == ((void *)0))\n                    current = sdsempty();\n                while (!done)\n                    {\n                        if (inq) {\n                            if (*p == '\\\\' && *(p + 1) == 'x' && is_hex_digit(*(p + 2)) && is_hex_digit(*(p + 3))) {\n                                unsigned char byte;\n                                byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3));\n                                current = sdscatlen(current, (char *)&byte, 1);\n                                p += 3;\n                            } else if (*p == '\\\\' && *(p + 1)) {\n                                char c;\n                                p++;\n                                switch (*p) {\n                                  case 'n':\n                                    c = '\\n';\n                                    break;\n                                  case 'r':\n                                    c = '\\r';\n                                    break;\n                                  case 't':\n                                    c = '\\t';\n                                    break;\n                                  case 'b':\n                                    c = '\\b';\n                                    break;\n                                  case 'a':\n                                    c = '\\a';\n                                    break;\n                                  default:\n                                    c = *p;\n                                    break;\n                                }\n                                current = sdscatlen(current, &c, 1);\n                            } else if (*p == '\"') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else if (insq) {\n                            if (*p == '\\\\' && *(p + 1) == '\\'') {\n                                p++;\n                                current = sdscatlen(current, \"'\", 1);\n                            } else if (*p == '\\'') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else {\n                            switch (*p) {\n                              case ' ':\n                              case '\\n':\n                              case '\\r':\n                              case '\\t':\n                              case '\\x00':\n                                done = 1;\n                                break;\n                              case '\"':\n                                inq = 1;\n                                break;\n                              case '\\'':\n                                insq = 1;\n                                break;\n                              default:\n                                current = sdscatlen(current, p, 1);\n                                break;\n                            }\n                        }\n                        if (*p)\n                            p++;\n                    }\n                vector = realloc(vector, ((*argc) + 1) * sizeof(char *));\n                vector[*argc] = current;\n                (*argc)++;\n                current = ((void *)0);\n            } else {\n                if (vector == ((void *)0))\n                    vector = malloc(sizeof(void *));\n                return vector;\n            }\n        }\n  err:\n    while ((*argc)--)\n        sdsfree(vector[*argc]);\n    free(vector);\n    if (current)\n        sdsfree(current);\n    *argc = 0;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsempty)();\nvoid *(realloc)(void *, unsigned long);\nlong long(sdscatlen)(long long, long long, long long);\nlong long(is_hex_digit)(long long);\nlong long(sdsfree)(long long);\nlong long(hex_digit_to_int)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[4235064];\n  unsigned int field_409f38;\n} struct_0;\n\nextern char g_409f38;\n\nlong long sdssplitargs_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int *v0;       // [bp-0x58]\n  char v1;                // [bp-0x3e]\n  char v2;                // [bp-0x3d]\n  unsigned int v3;        // [bp-0x3c]\n  unsigned int v4;        // [bp-0x38]\n  unsigned int v5;        // [bp-0x34]\n  unsigned long long *v6; // [bp-0x30], Other Possible Types: unsigned long\n  void *v7;               // [bp-0x28], Other Possible Types: unsigned long\n  char v8[4];             // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long v10; // rax\n  unsigned long long v11; // rax\n  unsigned int v13;       // eax\n  struct_0 *v15;          // rax\n  unsigned int v18;       // eax\n  unsigned int v19;       // eax\n\n  v0 = a1;\n  *(&v8) = a0;\n  v7 = 0;\n  v6 = 0;\n  while (true) {\n    for (*(a1) = 0;\n         *((char *)v8) && (*((short *)((*((char *)v8) << 1) +\n                                       *((long long *)&__ctype_b_loc()))) &\n                           0x2000);\n         v8 += 1)\n      ;\n    if (!*((char *)v8))\n      break;\n    v5 = 0;\n    v4 = 0;\n    v3 = 0;\n    if (!v7)\n      v7 = sdsempty();\n    while (true) {\n      if (v3) {\n        v6 = realloc(v6, (*(a1) + 1) * 8);\n        v6[*(a1)] = v7;\n        *(a1) = *(a1) + 1;\n        v7 = 0;\n        break;\n      }\n      if (v5) {\n        if (v8[0] == 92 && v8[1] == 120 && (int)is_hex_digit(v8[2]) &&\n            (int)is_hex_digit(v8[3])) {\n          v2 = (char)hex_digit_to_int(v8[3]) +\n               (char)hex_digit_to_int(v8[2]) * 16;\n          v7 = sdscatlen(v7, &v2, 1);\n          v8 = &v8[3];\n          goto LABEL_408605;\n        }\n        if (v8[0] == 92 && v8[1]) {\n          v8 += 1;\n          v15 = *((char *)v8) - 97;\n          switch ((unsigned int)v15) {\n          case 0:\n            v1 = 7;\n            break;\n          case 1:\n            v1 = 8;\n            break;\n          case 13:\n            v1 = 10;\n            break;\n          case 17:\n            v1 = 13;\n            break;\n          case 19:\n            v1 = 9;\n            break;\n          default:\n            v1 = *((char *)v8);\n            break;\n          }\n          v7 = sdscatlen(v7, &v1, 1);\n          goto LABEL_408605;\n        }\n        if (v8[0] == 34) {\n          if (!v8[1] || (v18 = (unsigned int)(unsigned short)*(\n                                   (short *)(*((long long *)&__ctype_b_loc()) +\n                                             (long long)(char)v8[1] * 2)) &\n                               0x2000,\n                         v18)) {\n            v3 = 1;\n            goto LABEL_408605;\n          } else {\n            goto LABEL_4086c8;\n          }\n        } else {\n          if (!*((char *)v8)) {\n            goto LABEL_4086c8;\n          } else {\n            v7 = sdscatlen(v7, v8, 1);\n            goto LABEL_408605;\n          }\n        }\n      } else if (!v4) {\n        v10 = v8[0];\n        if (39 >= (unsigned int)v10) {\n          v11 = 1 << ((char)v10 & 63);\n          if ((4294977025 & v11)) {\n            v3 = 1;\n            goto LABEL_408605;\n          }\n          if ((0x8000000000 & v11)) {\n            v4 = 1;\n            goto LABEL_408605;\n          } else if ((v11 & 0x400000000)) {\n            v5 = 1;\n            goto LABEL_408605;\n          }\n        }\n        v7 = sdscatlen(v7, v8, 1);\n      LABEL_408605:\n        if (*((char *)v8))\n          v8 += 1;\n      } else {\n        if (v8[0] == 92 && v8[1] == 39) {\n          v8 += 1;\n          v7 = sdscatlen(v7, \"'\", 1);\n          goto LABEL_408605;\n        }\n        if (v8[0] == 39) {\n          if (!v8[1] || (v13 = (unsigned int)(unsigned short)*(\n                                   (short *)(*((long long *)&__ctype_b_loc()) +\n                                             (long long)(char)v8[1] * 2)) &\n                               0x2000,\n                         v13)) {\n            v3 = 1;\n            goto LABEL_408605;\n          }\n        } else {\n          if (*((char *)v8)) {\n            v7 = sdscatlen(v7, v8, 1);\n            goto LABEL_408605;\n          }\n        }\n        while (true) {\n        LABEL_4086c8:\n          v19 = *(a1);\n          *(a1) = v19 - 1;\n          if (!v19)\n            break;\n          sdsfree(v6[*(a1)]);\n        }\n        free(v6);\n        if (v7)\n          sdsfree(v7);\n        *(a1) = 0;\n        return 0;\n      }\n    }\n  }\n  if (!v6)\n    v6 = malloc(8);\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:49:12: error: array type 'char[4]' is not\nassignable 49 |     *(&v8) = a0; |     ~~~~~~ ^\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:54:93: error: cannot take the address of an\nrvalue of type 'int' 54 |         for (*(a1) = 0; *((char *)v8) && (*((short\n*)((*((char *)v8) << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000); v8 +=\n1); | ^~~~~~~~~~~~~~~~ /tmp/tmp2ros535a/sdssplitargs_name_conflict.c:54:127: error: invalid\noperands to binary expression ('char[4]' and 'int') 54 |         for (*(a1) = 0;\n*((char *)v8) && (*((short *)((*((char *)v8) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v8 += 1); | ~~ ^  ~\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:78:24: error: array type 'char[4]' is not\nassignable 78 |                     v8 = &v8[3]; |                     ~~ ^\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:83:24: error: invalid operands to binary\nexpression ('char[4]' and 'int') 83 |                     v8 += 1; | ~~ ^  ~\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:111:99: error: cannot take the address of an\nrvalue of type 'int' 111 |                     if (!v8[1] || (v18 = (unsigned\nint)(unsigned short)*((short *)(*((long long *)&__ctype_b_loc()) + (long\nlong)(char)v8[1] * 2)) & 0x2000, v18)) | ^~~~~~~~~~~~~~~~\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:159:24: error: invalid operands to binary\nexpression ('char[4]' and 'int') 159 |                     v8 += 1; | ~~ ^  ~\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:165:24: error: invalid operands to binary\nexpression ('char[4]' and 'int') 165 |                     v8 += 1; | ~~ ^  ~\n/tmp/tmp2ros535a/sdssplitargs_name_conflict.c:171:99: error: cannot take the address of an\nrvalue of type 'int' 171 |                     if (!v8[1] || (v13 = (unsigned\nint)(unsigned short)*((short *)(*((long long *)&__ctype_b_loc()) + (long\nlong)(char)v8[1] * 2)) & 0x2000, v13)) | ^~~~~~~~~~~~~~~~ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdslen)(long long);\n\nlong long sdsmapchars(char *a0, unsigned long a1, unsigned long a2,\n                      unsigned long a3) {\n  unsigned long v0; // [bp-0x20]\n  char *v1;         // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long v2; // [bp-0x10]\n\n  v0 = ::0x406ec9 ::sdslen(a0);\n  for (v2 = 0; v2 < v0; v2 += 1) {\n    for (v1 = 0; v1 < a3; v1 += 1) {\n      if (a0[v2] == v1[a1]) {\n        a0[v2] = *((char *)(v1 + a2));\n        break;\n      }\n    }\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq2007v9k/sdsmapchars.c:24:10: error: expected expression\n   24 |     v0 = ::0x406ec9::sdslen(a0);\n      |          ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoin(char **argv, int argc, char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsempty)();\nlong long(sdscat)(long long, long long);\nlong long(sdscatlen)(long long, long long, long long);\n\nlong long sdsjoin(unsigned long long *a0, unsigned long a1,\n                  unsigned long long a2, unsigned long long a3) {\n  unsigned int v0;       // [bp-0x14]\n  unsigned long long v1; // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = sdsempty();\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    v1 = sdscat(v1, a0[v0]);\n    if (v0 != (unsigned int)a1 - 1)\n      v1 = sdscatlen(v1, a2, a3);\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsempty)();\nlong long(sdscatsds)(long long, long long);\nlong long(sdscatlen)(long long, long long, long long);\n\nlong long sdsjoinsds(unsigned long long *a0, unsigned long a1,\n                     unsigned long long a2, unsigned long long a3) {\n  unsigned int v0;       // [bp-0x14]\n  unsigned long v1;      // [bp-0x10], Other Possible Types: unsigned long long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = sdsempty();\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    v1 = sdscatsds(v1, a0[v0]);\n    if (v0 != (unsigned int)a1 - 1)\n      v1 = sdscatlen(v1, a2, a3);\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_ceil_half_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = (1 << ((char)a1 & 63)) - 1;\n  return ((v0 & a0)) + (a0 >> ((char)a1 & 63));\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_ceil_half)(long long, long long);\n\nlong long jbg_stripes_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long long v2; // rdx\n\n  v0 = jbg_ceil_half(a1, v2);\n  return ((0 CONCAT v0) / m a0 >> 64) + (0 CONCAT v0) / m a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:16: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                ^\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:13: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |             ^\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:30: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                              ^\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:12: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |            ^\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:45: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                             ^\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:42: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                          ^\n/tmp/tmp9avse6ro/jbg_stripes_name_conflict.c:26:58: error: expected ';' after return statement\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                                          ^\n      |                                                          ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char errmsg;\n\nlong long jbg_strerror_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 >>= 4;\n  if (v0 >= 0 && v0 <= 8)\n    return *((long long *)&(&errmsg)[8 * v0]);\n  return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_next_pscdms_name_conflict(char a0[6], unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  char v1[6];            // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v2;      // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  unsigned int v8;       // eax\n\n  v6 = &v4;\n  *(&v1) = a0;\n  v0 = a1;\n  if (v0 <= 1)\n    return 0;\n  if (v1[0] == 255 && v1[1]) {\n    v8 = v1[1];\n    if (v8 != 7) {\n      if (v8 > 7)\n        return 0;\n      if (v8 == 6) {\n        v7 = (v0 <= 7 ? (char[6]) & v1[1 + 2] : 0);\n        return v7;\n      }\n      if (v8 <= 6) {\n        if (v8 > 4) {\n          if (v8 == 5) {\n            v7 = (v0 <= 5 ? v1 + 1 : 0);\n            return v7;\n          }\n        } else {\n          if (v8 >= 2)\n            return &v1[2];\n        }\n      }\n    } else if (v0 <= 5) {\n      return 0;\n    } else {\n      v3 = v1[5] | v1[2] * 0x1000000 | v1[3] * 0x10000 | v1[4] * 0x100;\n      v7 = (v0 - 6 < v3 ? (char[6]) & v1[1 + v3] : 0);\n      return v7;\n    }\n  }\n  while (true) {\n    if (v1[0] != 255 || v1[1]) {\n      v2 = memchr(v1, 255, v0 - 1);\n      if (!v2)\n        return 0;\n      v3 = v2 - (char *)v1;\n      v1 = &v1[v3];\n      v0 -= v3;\n      if (v1[1])\n        return v1;\n    } else {\n      v1 = &v1[2];\n      v0 -= 2;\n      if (v0 <= 1)\n        return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqypks7mg/jbg_next_pscdms_name_conflict.c:29:12: error: array type 'char[6]' is not\nassignable 29 |     *(&v1) = a0; |     ~~~~~~ ^\n/tmp/tmpqypks7mg/jbg_next_pscdms_name_conflict.c:42:33: error: used type 'char[6]' where\narithmetic or pointer type is required 42 |                 v7 = (v0 <= 7 ?\n(char [6])&v1[1 + 2] : 0); |                                 ^ ~~~~~~~~~~\n/tmp/tmpqypks7mg/jbg_next_pscdms_name_conflict.c:69:33: error: used type 'char[6]' where\narithmetic or pointer type is required 69 |             v7 = (v0 - 6 < v3 ?\n(char [6])&v1[1 + v3] : 0); |                                 ^ ~~~~~~~~~~~\n/tmp/tmpqypks7mg/jbg_next_pscdms_name_conflict.c:80:21: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 80 |             v3 = v2 - (char *)v1;\n      |                  ~~ ^ ~~~~~~~~~~\n/tmp/tmpqypks7mg/jbg_next_pscdms_name_conflict.c:81:16: error: array type 'char[6]' is not\nassignable 81 |             v1 = &v1[v3]; |             ~~ ^\n/tmp/tmpqypks7mg/jbg_next_pscdms_name_conflict.c:88:16: error: array type 'char[6]' is not\nassignable 88 |             v1 = &v1[2]; |             ~~ ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_next_pscdms)(long long, long long);\n\nlong long jbg_newlen_name_conflict(char a0[20], unsigned long a1) {\n  unsigned int v0; // [bp-0x14]\n  char v1[2];      // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v4; // eax\n\n  *((char *[20]) & v1) = a0 + 1;\n  if (a1 <= 19)\n    return 32;\n  if ((a0[19] & 7) == 6)\n    v1 += 864;\n  if (v1 >= &a0[a1])\n    return 32;\n  while (true) {\n    do {\n      *((long long *)&v1) = jbg_next_pscdms(v1, &a0[a1 + -1 * v1]);\n      if (!v1)\n        return 96;\n      if (v1 == &a0[a1])\n        return 0;\n    } while (v1[0] != 255);\n    v4 = v1[1];\n    if (v4 == 4) {\n      return 64;\n    } else if (v4 == 5) {\n      for (v0 = 0; v0 <= 3; v0 += 1) {\n        a0[8 + v0] = v1[1 + v0];\n      }\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1_1c3vuv/jbg_newlen_name_conflict.c:24:7: error: used type 'char *[20]' where\narithmetic or pointer type is required 24 |     *((char *[20])&v1) = a0 + 1; |\n^           ~~~ /tmp/tmp1_1c3vuv/jbg_newlen_name_conflict.c:28:12: error: invalid operands to\nbinary expression ('char[2]' and 'int') 28 |         v1 += 864; |         ~~ ^\n~~~ /tmp/tmp1_1c3vuv/jbg_newlen_name_conflict.c:35:67: error: invalid operands to binary\nexpression ('int' and 'char[2]') 35 |             *((long long *)&v1) =\njbg_next_pscdms(v1, &a0[a1 + -1 * v1]); | ~~ ^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char errmsg;\n\nlong long jbg85_strerror_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 >>= 4;\n  if (v0 >= 0 && v0 <= 7)\n    return *((long long *)&(&errmsg)[8 * v0]);\n  return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_ceil_half_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = (1 << ((char)a1 & 63)) - 1;\n  return ((v0 & a0)) + (a0 >> ((char)a1 & 63));\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_ceil_half)(long long, long long);\n\nlong long jbg_stripes_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long long v2; // rdx\n\n  v0 = jbg_ceil_half(a1, v2);\n  return ((0 CONCAT v0) / m a0 >> 64) + (0 CONCAT v0) / m a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:16: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                ^\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:13: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |             ^\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:30: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                              ^\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:12: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |            ^\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:45: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                             ^\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:42: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                          ^\n/tmp/tmplwjchruy/jbg_stripes_name_conflict.c:26:58: error: expected ';' after return statement\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                                          ^\n      |                                                          ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char errmsg;\n\nlong long jbg_strerror_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 >>= 4;\n  if (v0 >= 0 && v0 <= 8)\n    return *((long long *)&(&errmsg)[8 * v0]);\n  return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_next_pscdms_name_conflict(char a0[6], unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  char v1[6];            // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v2;      // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  unsigned int v8;       // eax\n\n  v6 = &v4;\n  *(&v1) = a0;\n  v0 = a1;\n  if (v0 <= 1)\n    return 0;\n  if (v1[0] == 255 && v1[1]) {\n    v8 = v1[1];\n    if (v8 != 7) {\n      if (v8 > 7)\n        return 0;\n      if (v8 == 6) {\n        v7 = (v0 <= 7 ? (char[6]) & v1[1 + 2] : 0);\n        return v7;\n      }\n      if (v8 <= 6) {\n        if (v8 > 4) {\n          if (v8 == 5) {\n            v7 = (v0 <= 5 ? v1 + 1 : 0);\n            return v7;\n          }\n        } else {\n          if (v8 >= 2)\n            return &v1[2];\n        }\n      }\n    } else if (v0 <= 5) {\n      return 0;\n    } else {\n      v3 = v1[5] | v1[2] * 0x1000000 | v1[3] * 0x10000 | v1[4] * 0x100;\n      v7 = (v0 - 6 < v3 ? (char[6]) & v1[1 + v3] : 0);\n      return v7;\n    }\n  }\n  while (!(v1[0] != 255) && !(v1[1])) {\n  LABEL_40cf54:\n    v1 = &v1[2];\n    v0 -= 2;\n    if (v0 <= 1)\n      return 0;\n  }\n  v2 = memchr(v1, 255, v0 - 1);\n  if (!v2)\n    return 0;\n  v3 = v2 - (char *)v1;\n  v1 = &v1[v3];\n  v0 -= v3;\n  if (v1[1])\n    return v1;\n  goto LABEL_40cf54;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1jk7nnjy/jbg_next_pscdms_name_conflict.c:29:12: error: array type 'char[6]' is not\nassignable 29 |     *(&v1) = a0; |     ~~~~~~ ^\n/tmp/tmp1jk7nnjy/jbg_next_pscdms_name_conflict.c:42:33: error: used type 'char[6]' where\narithmetic or pointer type is required 42 |                 v7 = (v0 <= 7 ?\n(char [6])&v1[1 + 2] : 0); |                                 ^ ~~~~~~~~~~\n/tmp/tmp1jk7nnjy/jbg_next_pscdms_name_conflict.c:69:33: error: used type 'char[6]' where\narithmetic or pointer type is required 69 |             v7 = (v0 - 6 < v3 ?\n(char [6])&v1[1 + v3] : 0); |                                 ^ ~~~~~~~~~~~\n/tmp/tmp1jk7nnjy/jbg_next_pscdms_name_conflict.c:76:12: error: array type 'char[6]' is not\nassignable 76 |         v1 = &v1[2]; |         ~~ ^\n/tmp/tmp1jk7nnjy/jbg_next_pscdms_name_conflict.c:84:13: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 84 |     v3 = v2 - (char *)v1; | ~~ ^\n~~~~~~~~~~ /tmp/tmp1jk7nnjy/jbg_next_pscdms_name_conflict.c:85:8: error: array type 'char[6]'\nis not assignable 85 |     v1 = &v1[v3]; |     ~~ ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_next_pscdms)(long long, long long);\n\nlong long jbg_newlen_name_conflict(char a0[20], unsigned long a1) {\n  unsigned int v0; // [bp-0x14]\n  char v1[2];      // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v4; // eax\n\n  *((char *[20]) & v1) = a0 + 1;\n  if (a1 <= 19)\n    return 32;\n  if ((a0[19] & 7) == 6)\n    v1 += 864;\n  if (v1 >= &a0[a1])\n    return 32;\n  while (true) {\n    do {\n      *((long long *)&v1) = jbg_next_pscdms(v1, &a0[a1 + -1 * v1]);\n      if (!v1)\n        return 96;\n      if (v1 == &a0[a1])\n        return 0;\n    } while (v1[0] != 255);\n    v4 = v1[1];\n    if (v4 == 4) {\n      return 64;\n    } else if (v4 == 5) {\n      for (v0 = 0; v0 <= 3; v0 += 1) {\n        a0[8 + v0] = v1[1 + v0];\n      }\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd7fahb5a/jbg_newlen_name_conflict.c:24:7: error: used type 'char *[20]' where\narithmetic or pointer type is required 24 |     *((char *[20])&v1) = a0 + 1; |\n^           ~~~ /tmp/tmpd7fahb5a/jbg_newlen_name_conflict.c:28:12: error: invalid operands to\nbinary expression ('char[2]' and 'int') 28 |         v1 += 864; |         ~~ ^\n~~~ /tmp/tmpd7fahb5a/jbg_newlen_name_conflict.c:35:67: error: invalid operands to binary\nexpression ('int' and 'char[2]') 35 |             *((long long *)&v1) =\njbg_next_pscdms(v1, &a0[a1 + -1 * v1]); | ~~ ^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char errmsg;\n\nlong long jbg85_strerror_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 >>= 4;\n  if (v0 >= 0 && v0 <= 7)\n    return *((long long *)&(&errmsg)[8 * v0]);\n  return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char **orig_image, int width, int height, int options, int order, int layers, int planes, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg_enc_state sje;\n    struct jbg_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size;\n    int i, result;\n    unsigned char **image;\n    plane_size = ((width + 7) / 8) * height;\n    image = (unsigned char **)checkedmalloc(planes * sizeof(unsigned char *));\n    for (i = 0; i < planes; i++) {\n        image[i] = (unsigned char *)checkedmalloc(plane_size);\n        memcpy(image[i], orig_image[i], plane_size);\n    }\n    printf(\"\\nTest %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg_enc_init(&sje, width, height, planes, image, testbuf_writel, ((void *)0));\n    jbg_enc_layers(&sje, layers);\n    jbg_enc_options(&sje, order, options, l0, mx, 0);\n    jbg_enc_out(&sje);\n    jbg_enc_free(&sje);\n    for (i = 0; i < planes; i++)\n        free(image[i]);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    printf(\"Test %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = jbg_dec_in(&sjd, testbuf, testbuf_len, ((void *)0));\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value %d: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        for (i = 0; i < planes; i++) {\n            if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n            }\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    jbg_dec_free(&sjd);\n    printf(\"Test %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value %d at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value %d at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            for (i = 0; i < planes; i++) {\n                if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                    result = 0;\n                    trouble++;\n                    printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n                }\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    jbg_dec_free(&sjd);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint testbuf_writel; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkedmalloc)(long long);\nlong long(jbg_enc_init)(long long, long long, long long, long long, long long,\n                        long long, long long);\nlong long(jbg_enc_layers)(long long, long long);\nlong long(jbg_enc_options)(long long, long long, long long, long long,\n                           long long, long long);\nlong long(jbg_enc_out)(long long);\nlong long(jbg_enc_free)(long long);\nlong long(jbg_dec_init)(long long);\nlong long(jbg_dec_in)(long long, long long, long long, long long);\nlong long(jbg_strerror)(long long);\nlong long(jbg_dec_free)(long long);\n\nextern char g_40e0b8;\nextern char g_40e0e9;\nextern char g_40e118;\nextern char g_40e178;\nextern char g_40e1d0;\nextern char g_40e228;\nextern unsigned long long testbuf;\nextern void *testbuf_len;\n\nlong long test_cycle(void **a0, unsigned long a1, unsigned long a2,\n                     unsigned long a3, unsigned long a4, unsigned long a5,\n                     unsigned int v8, unsigned long long a6, unsigned int a7,\n                     unsigned long a8, unsigned long a9) {\n  char v0;           // [bp-0x638]\n  char v1;           // [bp-0x108]\n  void **v2;         // [bp-0x40]\n  unsigned long v3;  // [bp-0x38]\n  unsigned int v4;   // [bp-0x30]\n  unsigned int v5;   // [bp-0x2c]\n  void *v6;          // [bp-0x28], Other Possible Types: unsigned long\n  unsigned int v7;   // [bp-0x1c]\n  unsigned int v9;   // eax\n  unsigned long v11; // rax\n  unsigned int v12;  // eax\n  unsigned int v14;  // rax\n  unsigned int v15;  // eax\n  unsigned int v17;  // rax\n\n  v7 = 0;\n  v9 = (unsigned int)a1 + 7;\n  v11 = (unsigned int)a2 * (unsigned int)((v9 < 0 ? v9 + 7 : v9) >> 3);\n  v3 = v11;\n  v2 = checkedmalloc(v8 * 8);\n  for (v5 = 0; v5 < v8; v5 += 1) {\n    v2[v5] = checkedmalloc(v3);\n    memcpy(v2[v5], a0[v5], v3);\n  }\n  printf(\"\\nTest %s.1: Encoding ...\\n\", (unsigned int)a9);\n  testbuf_len = 0;\n  jbg_enc_init(&v1, (unsigned int)a1, (unsigned int)a2, v8, v2, testbuf_writel,\n               0);\n  jbg_enc_layers(&v1, (unsigned int)a5);\n  jbg_enc_options(&v1, (unsigned int)a4, (unsigned int)a3, a6, a7, 0);\n  jbg_enc_out(&v1);\n  jbg_enc_free(&v1);\n  for (v5 = 0; v5 < v8; v5 += 1) {\n    free(v2[v5]);\n  }\n  free(v2);\n  printf(\"Encoded BIE has %6ld bytes: \", (unsigned int)testbuf_len);\n  if ((char)(a8 - 0 >> 63)) {\n    puts(&g_40e0e9);\n  } else if (a8 == testbuf_len) {\n    puts(\"PASSED\");\n  } else {\n    v7 += 1;\n    printf(&g_40e0b8, (unsigned int)a8);\n  }\n  printf(\"Test %s.2: Decoding whole chunk ...\\n\", (unsigned int)a9);\n  jbg_dec_init(&v0);\n  v4 = jbg_dec_in(&v0, testbuf, testbuf_len, 0);\n  if (v4) {\n    printf(&g_40e118, v4, (int)jbg_strerror(v4));\n    v7 += 1;\n  } else {\n    printf(\"Image comparison: \");\n    v4 = 1;\n    for (v5 = 0; v5 < v8; v5 += 1) {\n      v12 = (unsigned int)a1 + 7;\n      v14 = (unsigned int)a2 * (unsigned int)((v12 < 0 ? v12 + 7 : v12) >> 3);\n      if (memcmp(a0[v5],\n                 *((long long *)(*((long long *)&(\n                                     &v0)[96 + 8 * ((unsigned int)a5 & 1)]) +\n                                 (v5 << 3))),\n                 v14)) {\n        v4 = 0;\n        v7 += 1;\n        printf(&g_40e178, v5);\n      }\n    }\n    if (v4)\n      puts(\"PASSED\");\n  }\n  jbg_dec_free(&v0);\n  printf(\"Test %s.3: Decoding with single-byte feed ...\\n\", (unsigned int)a9);\n  jbg_dec_init(&v0);\n  v4 = 32;\n  for (v6 = 0; v6 < testbuf_len; v6 += 1) {\n    v4 = jbg_dec_in(&v0, testbuf + v6, 1, 0);\n    if (!(v6 >= testbuf_len - 1 || v4 == 32)) {\n      printf(&g_40e1d0, v4, (unsigned int)v6, (int)jbg_strerror(v4));\n      v7 += 1;\n      break;\n    }\n  }\n  if (v6 != testbuf_len) {\n    jbg_dec_free(&v0);\n    puts(&g_40e0e9);\n    return v7;\n  }\n  if (v4) {\n    printf(&g_40e228, v4, (int)jbg_strerror(v4));\n    v7 += 1;\n  } else {\n    printf(\"Image comparison: \");\n    v4 = 1;\n    for (v5 = 0; v5 < v8; v5 += 1) {\n      v15 = (unsigned int)a1 + 7;\n      v17 = (unsigned int)a2 * (unsigned int)((v15 < 0 ? v15 + 7 : v15) >> 3);\n      if (memcmp(a0[v5],\n                 *((long long *)(*((long long *)&(\n                                     &v0)[96 + 8 * ((unsigned int)a5 & 1)]) +\n                                 (v5 << 3))),\n                 v17)) {\n        v4 = 0;\n        v7 += 1;\n        printf(&g_40e178, v5);\n      }\n    }\n    if (v4)\n      puts(\"PASSED\");\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec.c"}
{"compilable":1,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_ceil_half_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = (1 << ((char)a1 & 63)) - 1;\n  return ((v0 & a0)) + (a0 >> ((char)a1 & 63));\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_ceil_half)(long long, long long);\n\nlong long jbg_stripes_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long long v2; // rdx\n\n  v0 = jbg_ceil_half(a1, v2);\n  return ((0 CONCAT v0) / m a0 >> 64) + (0 CONCAT v0) / m a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:16: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                ^\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:13: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |             ^\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:30: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                              ^\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:12: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |            ^\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:45: error: expected ')'\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                             ^\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:42: note: to match this '('\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                          ^\n/tmp/tmpk2oqmrl9/jbg_stripes_name_conflict.c:26:58: error: expected ';' after return statement\n   26 |     return ((0 CONCAT v0) /m a0 >> 64) + (0 CONCAT v0) /m a0;\n      |                                                          ^\n      |                                                          ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char errmsg;\n\nlong long jbg_strerror_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 >>= 4;\n  if (v0 >= 0 && v0 <= 8)\n    return *((long long *)&(&errmsg)[8 * v0]);\n  return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_next_pscdms_name_conflict(char a0[6], unsigned long a1) {\n  unsigned long v0;      // [bp-0x28]\n  char v1[6];            // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v2;      // [bp-0x18]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  unsigned int v8;       // eax\n\n  v6 = &v4;\n  *(&v1) = a0;\n  v0 = a1;\n  if (v0 <= 1)\n    return 0;\n  if (v1[0] == 255 && v1[1]) {\n    v8 = v1[1];\n    if (v8 != 7) {\n      if (v8 > 7)\n        return 0;\n      if (v8 == 6) {\n        v7 = (v0 <= 7 ? (char[6]) & v1[1 + 2] : 0);\n        return v7;\n      }\n      if (v8 <= 6) {\n        if (v8 > 4) {\n          if (v8 == 5) {\n            v7 = (v0 <= 5 ? v1 + 1 : 0);\n            return v7;\n          }\n        } else {\n          if (v8 >= 2)\n            return &v1[2];\n        }\n      }\n    } else if (v0 <= 5) {\n      return 0;\n    } else {\n      v3 = v1[5] | v1[2] * 0x1000000 | v1[3] * 0x10000 | v1[4] * 0x100;\n      v7 = (v0 - 6 < v3 ? (char[6]) & v1[1 + v3] : 0);\n      return v7;\n    }\n  }\n  while (true) {\n    if (v1[0] != 255 || v1[1]) {\n      v2 = memchr(v1, 255, v0 - 1);\n      if (!v2)\n        return 0;\n      v3 = v2 - (char *)v1;\n      v1 = &v1[v3];\n      v0 -= v3;\n      if (v1[1])\n        return v1;\n    } else {\n      v1 = &v1[2];\n      v0 -= 2;\n      if (v0 <= 1)\n        return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgcaff1xl/jbg_next_pscdms_name_conflict.c:29:12: error: array type 'char[6]' is not\nassignable 29 |     *(&v1) = a0; |     ~~~~~~ ^\n/tmp/tmpgcaff1xl/jbg_next_pscdms_name_conflict.c:42:33: error: used type 'char[6]' where\narithmetic or pointer type is required 42 |                 v7 = (v0 <= 7 ?\n(char [6])&v1[1 + 2] : 0); |                                 ^ ~~~~~~~~~~\n/tmp/tmpgcaff1xl/jbg_next_pscdms_name_conflict.c:69:33: error: used type 'char[6]' where\narithmetic or pointer type is required 69 |             v7 = (v0 - 6 < v3 ?\n(char [6])&v1[1 + v3] : 0); |                                 ^ ~~~~~~~~~~~\n/tmp/tmpgcaff1xl/jbg_next_pscdms_name_conflict.c:80:21: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 80 |             v3 = v2 - (char *)v1;\n      |                  ~~ ^ ~~~~~~~~~~\n/tmp/tmpgcaff1xl/jbg_next_pscdms_name_conflict.c:81:16: error: array type 'char[6]' is not\nassignable 81 |             v1 = &v1[v3]; |             ~~ ^\n/tmp/tmpgcaff1xl/jbg_next_pscdms_name_conflict.c:88:16: error: array type 'char[6]' is not\nassignable 88 |             v1 = &v1[2]; |             ~~ ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_next_pscdms)(long long, long long);\n\nlong long jbg_newlen_name_conflict(char a0[20], unsigned long a1) {\n  unsigned int v0; // [bp-0x14]\n  char v1[2];      // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v4; // eax\n\n  *((char *[20]) & v1) = a0 + 1;\n  if (a1 <= 19)\n    return 32;\n  if ((a0[19] & 7) == 6)\n    v1 += 864;\n  if (v1 >= &a0[a1])\n    return 32;\n  while (true) {\n    do {\n      *((long long *)&v1) = jbg_next_pscdms(v1, &a0[a1 + -1 * v1]);\n      if (!v1)\n        return 96;\n      if (v1 == &a0[a1])\n        return 0;\n    } while (v1[0] != 255);\n    v4 = v1[1];\n    if (v4 == 4) {\n      return 64;\n    } else if (v4 == 5) {\n      for (v0 = 0; v0 <= 3; v0 += 1) {\n        a0[8 + v0] = v1[1 + v0];\n      }\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplssf1de6/jbg_newlen_name_conflict.c:24:7: error: used type 'char *[20]' where\narithmetic or pointer type is required 24 |     *((char *[20])&v1) = a0 + 1; |\n^           ~~~ /tmp/tmplssf1de6/jbg_newlen_name_conflict.c:28:12: error: invalid operands to\nbinary expression ('char[2]' and 'int') 28 |         v1 += 864; |         ~~ ^\n~~~ /tmp/tmplssf1de6/jbg_newlen_name_conflict.c:35:67: error: invalid operands to binary\nexpression ('int' and 'char[2]') 35 |             *((long long *)&v1) =\njbg_next_pscdms(v1, &a0[a1 + -1 * v1]); | ~~ ^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char errmsg;\n\nlong long jbg85_strerror_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 >>= 4;\n  if (v0 >= 0 && v0 <= 7)\n    return *((long long *)&(&errmsg)[8 * v0]);\n  return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char *orig_image, int width, int height, int options, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg85_enc_state sje;\n    struct jbg85_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size, buffer_len;\n    int i, result;\n    unsigned char *image, *buffer;\n    size_t bpl;\n    size_t cnt;\n    bpl = (width + 7) / 8;\n    plane_size = bpl * height;\n    image = (unsigned char *)checkedmalloc(plane_size);\n    memcpy(image, orig_image, plane_size);\n    printf(\"\\nTest-85 %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg85_enc_init(&sje, width, height, testbuf_writel, ((void *)0));\n    jbg85_enc_options(&sje, options, l0, mx);\n    for (i = 0; i < height; i++)\n        jbg85_enc_lineout(&sje, image + i * bpl, image + (i - 1) * bpl, image + (i - 2) * bpl);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    buffer_len = ((width >> 3) + !!(width & 7)) * 3;\n    buffer = (unsigned char *)checkedmalloc(buffer_len);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = jbg85_dec_in(&sjd, testbuf, testbuf_len, &cnt);\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value 0x%02x: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n        printf(\"%ld bytes of BIE read, %lu lines decoded.\\n\", (long)cnt, sjd.y);\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        if (memcmp(orig_image, image, plane_size)) {\n            result = 0;\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    free(image);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg85_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg85_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            if (memcmp(orig_image, image, plane_size)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    free(image);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint testbuf_writel; // add global variable by heuristics\nint line_out;       // add global variable by heuristics\nint line_out;       // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkedmalloc)(long long);\nlong long(jbg85_enc_init)(long long, long long, long long, long long,\n                          long long);\nlong long(jbg85_enc_options)(long long, long long, long long, long long);\nlong long(jbg85_enc_lineout)(long long, long long, long long, long long);\nlong long(jbg85_dec_init)(long long, long long, long long, long long,\n                          long long);\nlong long(jbg85_dec_in)(long long, long long, long long, long long);\nlong long(jbg85_strerror)(long long);\n\nextern char g_4070c0;\nextern char g_4070f1;\nextern char g_407120;\nextern char g_4071ae;\nextern char g_407200;\nextern char g_407260;\nextern unsigned long long testbuf;\nextern void *testbuf_len;\n\nlong long test_cycle(void *a0, unsigned long a1, unsigned long a2,\n                     unsigned long a3, unsigned long long a4, unsigned long a5,\n                     unsigned long v14, unsigned long a6) {\n  unsigned int v0;       // [bp-0x2628]\n  char v1;               // [bp-0x2610]\n  char v2;               // [bp-0x2608]\n  char v3;               // [bp-0x1550]\n  char v4;               // [bp-0x14e8]\n  unsigned long long v5; // [bp-0x48]\n  unsigned long long v6; // [bp-0x40]\n  void *v7;              // [bp-0x38]\n  unsigned long v8;      // [bp-0x30]\n  unsigned long long v9; // [bp-0x28]\n  unsigned int v10;      // [bp-0x20]\n  unsigned int v11;      // [bp-0x1c]\n  void *v12;             // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v13;      // [bp-0xc]\n  unsigned int v15;      // eax\n  unsigned long v17;     // rdx\n\n  v0 = a2;\n  v13 = 0;\n  v15 = (unsigned int)a1 + 7;\n  v9 = (v15 < 0 ? v15 + 7 : v15) >> 3;\n  v8 = v9 * v0;\n  v7 = checkedmalloc(v8);\n  memcpy(v7, a0, v8);\n  printf(\"\\nTest-85 %s.1: Encoding ...\\n\", (unsigned int)a6);\n  testbuf_len = 0;\n  jbg85_enc_init(&v4, (unsigned int)a1, v0, testbuf_writel, 0);\n  jbg85_enc_options(&v4, (unsigned int)a3, a4, (unsigned int)a5);\n  for (v11 = 0; v11 < v0; v11 += 1) {\n    jbg85_enc_lineout(&v4, v9 * v11 + v7, v9 * (v11 - 1) + v7,\n                      v9 * (v11 - 2) + v7);\n  }\n  free(v7);\n  printf(\"Encoded BIE has %6ld bytes: \", (unsigned int)testbuf_len);\n  if ((char)(v14 - 0 >> 63)) {\n    puts(&g_4070f1);\n  } else if (v14 == testbuf_len) {\n    puts(\"PASSED\");\n  } else {\n    v13 += 1;\n    printf(&g_4070c0, (unsigned int)v14);\n  }\n  v17 = ((unsigned int)a1 >> 3) + (((unsigned int)a1 & 7));\n  v6 = (unsigned int)v17 * 2 + v17;\n  v5 = checkedmalloc(v6);\n  v7 = checkedmalloc(v8);\n  printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", (unsigned int)a6);\n  jbg85_dec_init(&v2, v5, v6, line_out, v7);\n  v10 = jbg85_dec_in(&v2, testbuf, testbuf_len, &v1);\n  if (v10) {\n    printf(&g_407120, v10, (int)jbg85_strerror(v10));\n    printf(\"%ld bytes of BIE read, %lu lines decoded.\\n\",\n           (int)*((long long *)&v1), (int)*((long long *)&v3));\n    v13 += 1;\n  } else {\n    printf(\"Image comparison: \");\n    v10 = 1;\n    if (memcmp(a0, v7, v8)) {\n      v10 = 0;\n      v13 += 1;\n      printf(&g_4071ae);\n    }\n    if (v10)\n      puts(\"PASSED\");\n  }\n  free(v7);\n  v7 = checkedmalloc(v8);\n  printf(\"Test-85 %s.3: Decoding with single-byte feed ...\\n\",\n         (unsigned int)a6);\n  jbg85_dec_init(&v2, v5, v6, line_out, v7);\n  v10 = 32;\n  for (v12 = 0; v12 < testbuf_len; v12 += 1) {\n    v10 = jbg85_dec_in(&v2, testbuf + v12, 1, 0);\n    if (!(v12 >= testbuf_len - 1 || v10 == 32)) {\n      printf(&g_407200, v10, (unsigned int)v12, (int)jbg85_strerror(v10));\n      v13 += 1;\n      break;\n    }\n  }\n  if (v12 == testbuf_len) {\n    if (v10) {\n      printf(&g_407260, v10, (int)jbg85_strerror(v10));\n      v13 += 1;\n    } else {\n      printf(\"Image comparison: \");\n      v10 = 1;\n      if (memcmp(a0, v7, v8)) {\n        v10 = 0;\n        v13 += 1;\n        printf(&g_4071ae);\n      }\n      if (v10)\n        puts(\"PASSED\");\n    }\n  }\n  free(v7);\n  puts(&g_4070f1);\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec85.c"}
{"compilable":0,"function":"int discovery() {\n    DIR *dir;\n    struct dirent *ent;\n    bool comma = 0;\n    if ((dir = opendir(\"/sys/kernel/debug/ieee80211/\")) != ((void *)0)) {\n        printf(\"{\\\"data\\\":[\");\n        while ((ent = readdir(dir)) != ((void *)0))\n            {\n                if (strcmp(\".\", ent->d_name) && strcmp(\"..\", ent->d_name)) {\n                    if (comma)\n                        printf(\",\");\n                    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", ent->d_name);\n                    comma = 1;\n                }\n            }\n        printf(\"]}\\n\");\n        closedir(dir);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(opendir)(char *);\nvoid(perror)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nint(putchar)(int);\n\nextern char g_402047;\n\nlong long discovery_name_conflict() {\n  unsigned long v0; // [bp-0x20]\n  char *v1;         // [bp-0x18]\n  char v2;          // [bp-0x9]\n\n  v2 = 0;\n  v1 = opendir(\"/sys/kernel/debug/ieee80211/\");\n  if (!v1) {\n    perror(&g_402047);\n    return 1;\n  }\n  printf(\"{\\\"data\\\":[\");\n  while (true) {\n    do {\n      do {\n        v0 = readdir(v1);\n        if (!v0) {\n          puts(\"]}\");\n          closedir(v1);\n          return 0;\n        }\n      } while (!strcmp(\".\", v0 + 19));\n    } while (!strcmp(\"..\", v0 + 19));\n    if (v2)\n      putchar(44);\n    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", (unsigned int)(v0 + 19));\n    v2 = 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzud_1gfj/discovery_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"int get_param(char *phy, char *stat) {\n    char *filename = ((void *)0);\n    FILE *f = ((void *)0);\n    phy = basename(phy);\n    stat = basename(stat);\n    if (asprintf(&filename, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\", phy, stat) > 0)\n        f = fopen(filename, \"r\");\n    if (f != ((void *)0)) {\n        char temp[256];\n        while (fgets(temp, 256, f) != ((void *)0))\n            printf(\"%s\", temp);\n        fclose(f);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    free(filename);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(basename)(char *);\nint(asprintf)(char **, char *, ...);\nvoid(perror)(char *);\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\n\nextern char g_402047;\n\nlong long get_param(unsigned long a0, unsigned long a1) {\n  char *v0; // [bp-0x128], Other Possible Types: unsigned long\n  char *v1; // [bp-0x120], Other Possible Types: unsigned long\n  char v2;  // [bp-0x118]\n  void *v3; // [bp-0x18]\n  void *v4; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = a0;\n  v0 = a1;\n  v3 = 0;\n  v4 = 0;\n  v1 = basename(v1);\n  v0 = basename(v0);\n  if (asprintf(&v3, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\",\n               (unsigned int)v1, (unsigned int)v0) > 0)\n    v4 = fopen(v3, \"r\");\n  if (!v4) {\n    perror(&g_402047);\n    return 1;\n  }\n  while (fgets(&v2, 0x100, v4)) {\n    printf(\"%s\", (unsigned int)&v2);\n  }\n  fclose(v4);\n  free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzzwmdyht/get_param.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpzzwmdyht/get_param.c:33:16: error: nested redefinition of '_IO_marker'\n   33 |         struct _IO_marker {\n      |                ^\n/tmp/tmpzzwmdyht/get_param.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmpzzwmdyht/get_param.c:76:13: error: declaration of anonymous union must\nbe a definition 76 |             union <anon> { |             ^\n/tmp/tmpzzwmdyht/get_param.c:79:22: error: type name requires a specifier or\nqualifier 79 |             } __value; |                      ^\n/tmp/tmpzzwmdyht/get_param.c:83:13: error: declaration of anonymous union must\nbe a definition 83 |             union <anon> { |             ^\n/tmp/tmpzzwmdyht/get_param.c:86:22: error: type name requires a specifier or\nqualifier 86 |             } __value; |                      ^\n/tmp/tmpzzwmdyht/get_param.c:19:8: error: conflicting types for 'fgets'\n   19 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"int usage(char *name) {\n    fprintf(stderr, \"Usage:\\n\");\n    fprintf(stderr, \" %s discovery\\n\", name);\n    fprintf(stderr, \" => print mac80211.phydiscovery discovery rule\\n\");\n    fprintf(stderr, \" %s PHY STAT\\n\", name);\n    fprintf(stderr, \" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\");\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long usage_name_conflict(unsigned long a0) {\n  fwrite(\"Usage:\\n\", 1, 7, stderr @GLIBC_2.2.5);\n  fprintf(stderr @GLIBC_2.2.5, \" %s discovery\\n\", (unsigned int)a0);\n  fwrite(\" => print mac80211.phydiscovery discovery rule\\n\", 1, 47,\n         stderr @GLIBC_2.2.5);\n  fprintf(stderr @GLIBC_2.2.5, \" %s PHY STAT\\n\", (unsigned int)a0);\n  fwrite(\" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\", 1,\n         64, stderr @GLIBC_2.2.5);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi3oxqck4/usage_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpi3oxqck4/usage_name_conflict.c:17:22: error: expected ';' after top level declarator\n   17 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpi3oxqck4/usage_name_conflict.c:21:36: error: expected ')'\n   21 |     fwrite(\"Usage:\\n\", 1, 7, stderr@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmpi3oxqck4/usage_name_conflict.c:21:11: note: to match this '('\n   21 |     fwrite(\"Usage:\\n\", 1, 7, stderr@GLIBC_2.2.5);\n      |           ^\n/tmp/tmpi3oxqck4/usage_name_conflict.c:22:19: error: expected ')'\n   22 |     fprintf(stderr@GLIBC_2.2.5, \" %s discovery\\n\", (unsigned int)a0);\n      |                   ^\n/tmp/tmpi3oxqck4/usage_name_conflict.c:22:12: note: to match this '('\n   22 |     fprintf(stderr@GLIBC_2.2.5, \" %s discovery\\n\", (unsigned int)a0);\n      |            ^\n/tmp/tmpi3oxqck4/usage_name_conflict.c:23:77: error: expected ')'\n   23 |     fwrite(\" => print mac80211.phydiscovery discovery rule\\n\", 1, 47,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpi3oxqck4/usage_name_conflict.c:23:11: note: to match this '('\n   23 |     fwrite(\" => print mac80211.phydiscovery discovery rule\\n\", 1, 47,\nstderr@GLIBC_2.2.5); |           ^ /tmp/tmpi3oxqck4/usage_name_conflict.c:24:19: error:\nexpected ')' 24 |     fprintf(stderr@GLIBC_2.2.5, \" %s PHY STAT\\n\", (unsigned\nint)a0); |                   ^ /tmp/tmpi3oxqck4/usage_name_conflict.c:24:12: note: to match\nthis '(' 24 |     fprintf(stderr@GLIBC_2.2.5, \" %s PHY STAT\\n\", (unsigned\nint)a0); |            ^ /tmp/tmpi3oxqck4/usage_name_conflict.c:25:94: error: expected ')' 25 |\nfwrite(\" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\", 1,\n64, stderr@GLIBC_2.2.5); | ^ /tmp/tmpi3oxqck4/usage_name_conflict.c:25:11: note: to match this\n'(' 25 |     fwrite(\" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as\nroot\\n\", 1, 64, stderr@GLIBC_2.2.5); |           ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"static char *xasprintf(const char *fmt, ...) {\n    va_list ap;\n    char *ret;\n    __builtin_va_start(ap, fmt);\n    ret = xvasprintf(fmt, ap);\n    __builtin_va_end(ap);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xvasprintf)(long long, long long);\n\nlong long xasprintf_name_conflict() {\n  unsigned int v0;        // [bp-0xd8]\n  unsigned int v1;        // [bp-0xd4]\n  unsigned long v2;       // [bp-0xd0]\n  unsigned long v3;       // [bp-0xc8]\n  unsigned long v4;       // [bp-0xc0]\n  char v5;                // [bp-0xb8]\n  unsigned long v6;       // [bp-0xb0]\n  unsigned long v7;       // [bp-0xa8]\n  unsigned long v8;       // [bp-0xa0]\n  unsigned long v9;       // [bp-0x98]\n  unsigned long v10;      // [bp-0x90]\n  int v11;                // [bp-0x88]\n  int v12;                // [bp-0x78]\n  int v13;                // [bp-0x68]\n  int v14;                // [bp-0x58]\n  int v15;                // [bp-0x48]\n  int v16;                // [bp-0x38]\n  int v17;                // [bp-0x28]\n  int v18;                // [bp-0x18]\n  unsigned long v19;      // [bp+0x8]\n  unsigned long v20;      // rsi\n  unsigned long v21;      // rdx\n  unsigned long v22;      // rcx\n  unsigned long v23;      // r8\n  unsigned long v24;      // r9\n  char v25;               // al\n  int v26;                // xmm0\n  int v27;                // xmm1\n  int v28;                // xmm2\n  int v29;                // xmm3\n  int v30;                // xmm4\n  int v31;                // xmm5\n  int v32;                // xmm6\n  int v33;                // xmm7\n  unsigned long long v34; // rdi\n\n  v6 = v20;\n  v7 = v21;\n  v8 = v22;\n  v9 = v23;\n  v10 = v24;\n  if (v25) {\n    v11 = v26;\n    v12 = v27;\n    v13 = v28;\n    v14 = v29;\n    v15 = v30;\n    v16 = v31;\n    v17 = v32;\n    v18 = v33;\n  }\n  v0 = 8;\n  v1 = 48;\n  v2 = &v19;\n  v3 = &v5;\n  v4 = xvasprintf(v34, &v0);\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static char *fieldcpy(char *dst, char *fld) {\n    while (*fld && *fld != ':')\n        fld++;\n    if (!*(fld++))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*fld))] & (unsigned short)_ISspace))\n        fld++;\n    return strcpy(dst, fld);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fieldcpy_name_conflict(char *a0, char *a1) {\n  char *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n  char *v4;              // rax\n\n  v3 = &v1;\n  for (v0 = a1; *((char *)v0) && *((char *)v0) != 58; v0 += 1)\n    ;\n  v4 = v0;\n  if (!*(v4))\n    return 0;\n  for (v0 = v4 + 1;\n       (*((short *)((*((char *)v0) << 1) + *((long long *)&__ctype_b_loc()))) &\n        0x2000);\n       v0 += 1)\n    ;\n  return strcpy(a0, v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6m96wr7f/fieldcpy_name_conflict.c:29:74: error: cannot take the address of an rvalue\nof type 'int' 29 |     for (v0 = v4 + 1; (*((short *)((*((char *)v0) << 1) +\n*((long long *)&__ctype_b_loc()))) & 0x2000); v0 += 1); | ^~~~~~~~~~~~~~~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static int dotranslatewgetpercent(int low, int high, int end, char *str) {\n    int ch;\n    int val, lastval;\n    lastval = val = 0;\n    while ((ch = getchar()) != (-1))\n        {\n            if (((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit)) {\n                val *= 10;\n                val += ch - '0';\n            } else if (ch == '%') {\n                float f = (float)val / 100. * (high - low) + low;\n                if (str) {\n                    printf(\"P: %d %d %s\\n\", (int)f, end, str);\n                } else {\n                    printf(\"P: %d %d\\n\", (int)f, end);\n                }\n                lastval = val;\n            } else {\n                val = 0;\n            }\n        }\n    return lastval == 100;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getchar)();\n\nlong long dotranslatewgetpercent(unsigned long a0, unsigned long a1,\n                                 unsigned long a2, unsigned long a3) {\n  int tmp_33;      // tmp #33\n  int tmp_35;      // tmp #35\n  int tmp_34;      // tmp #34\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v6; // eax\n  int v8;          // xmm0\n  int v9;          // xmm0\n\n  v3 = 0;\n  v2 = v3;\n  while (true) {\n    v1 = getchar();\n    if (v1 == -1)\n      break;\n    v6 = *((short *)(*((long long *)&__ctype_b_loc()) + v1 * 2)) & 0x800;\n    if (v6) {\n      a2 = v3;\n      v3 = 5 * a2 * 2;\n      v3 += v1 - 48;\n    } else if (v1 != 37) {\n      v3 = 0;\n    } else {\n      tmp_33 = DivV(tmp_35, tmp_34);\n      v8 = 0;\n      *((unsigned long long *)&v8) = (unsigned int)a1 - (unsigned int)a0;\n      v9 = (0 CONCAT(int) a0) + tmp_33 * v8;\n      v0 = (unsigned int)v9;\n      if (!a3)\n        printf(\"P: %d %d\\n\", v0, (unsigned int)a2);\n      else\n        printf(\"P: %d %d %s\\n\", v0, (unsigned int)a2, (unsigned int)a3);\n      v2 = v3;\n    }\n  }\n  return v2 == 100;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkzmnzpte/dotranslatewgetpercent.c:38:41: error: cannot take the address\nof an rvalue of type 'int' 38 |         v6 = *((short *)(*((long long\n*)&__ctype_b_loc()) + v1 * 2)) & 0x800; | ^~~~~~~~~~~~~~~~\n/tmp/tmpkzmnzpte/dotranslatewgetpercent.c:54:21: error: expected ')'\n   54 |             v9 = (0 CONCAT (int)a0) + tmp_33 * v8;\n      |                     ^\n/tmp/tmpkzmnzpte/dotranslatewgetpercent.c:54:18: note: to match this '('\n   54 |             v9 = (0 CONCAT (int)a0) + tmp_33 * v8;\n      |                  ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":1,"function":"static int luaO_int2fb(unsigned int x) {\n    int e = 0;\n    while (x >= 16)\n        {\n            x = (x + 1) >> 1;\n            e++;\n        }\n    if (x < 8)\n        return x;\n    else\n        return ((e + 1) << 3) | (((int)((x))) - 8);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long luaO_int2fb_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0;\n  for (v1 = 0; v0 > 15; v1 += 1) {\n    v0 = v0 + 1 >> 1;\n  }\n  return (v0 <= 7 ? v0 - 8 | (v1 + 1) * 8 : v0);\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int luaO_fb2int(int x) {\n    int e = (x >> 3) & 31;\n    if (e == 0)\n        return x;\n    else\n        return ((x & 7) + 8) << (e - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long luaO_fb2int_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = (unsigned int)((unsigned int)a0 >> 3) & 31;\n  return (!v0 ? ((unsigned int)a0 & 7) + 8 << ((char)(v0 - 1) & 31)\n              : (unsigned int)a0);\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int luaO_log2(unsigned int x) {\n    static const lu_byte log_2[256] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};\n    int l = -1;\n    while (x >= 256)\n        {\n            l += 8;\n            x >>= 8;\n        }\n    return l + log_2[x];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char log_2.1;\n\nlong long luaO_log2_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0;\n  for (v1 = -1; v0 > 255; v0 >>= 8) {\n    v1 += 8;\n  }\n  return v1 + *(&(&log_2.1)[v0]);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp61fi06mg/luaO_log2_name_conflict.c:17:18: error: expected ';' after top level\ndeclarator 17 | extern char log_2.1; |                  ^ |                  ;\n/tmp/tmp61fi06mg/luaO_log2_name_conflict.c:29:27: error: expected ')'\n   29 |     return v1 + *(&(&log_2.1)[v0]);\n      |                           ^\n/tmp/tmp61fi06mg/luaO_log2_name_conflict.c:29:20: note: to match this '('\n   29 |     return v1 + *(&(&log_2.1)[v0]);\n      |                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int computesizes(int nums[], int *narray) {\n    int i;\n    int twotoi;\n    int a = 0;\n    int na = 0;\n    int n = 0;\n    for (i = 0 , twotoi = 1; twotoi / 2 < *narray; i++ , twotoi *= 2) {\n        if (nums[i] > 0) {\n            a += nums[i];\n            if (a > twotoi / 2) {\n                n = twotoi;\n                na = a;\n            }\n        }\n        if (a == *narray)\n            break;\n    }\n    *narray = n;\n    return na;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long computesizes_name_conflict(unsigned int *a0, unsigned int *a1) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x18]\n  unsigned int v2; // [bp-0x14]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  v0 = 0;\n  v4 = 0;\n  for (v3 = 1; (unsigned int)(v3 + (v3 >> 31) >> 1) < *(a1); v3 *= 2) {\n    if (a0[v4] > 0) {\n      v2 += a0[v4];\n      if (v2 > (unsigned int)(v3 + (v3 >> 31) >> 1)) {\n        v0 = v3;\n        v1 = v2;\n      }\n    }\n    if (v2 == *(a1))\n      break;\n    v4 += 1;\n  }\n  *(a1) = v0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static UnOpr getunopr(int op) {\n    switch (op) {\n      case TK_NOT:\n        return OPR_NOT;\n      case '-':\n        return OPR_MINUS;\n      case '#':\n        return OPR_LEN;\n      default:\n        return OPR_NOUNOPR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long getunopr_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 270)\n    return 1;\n  if ((unsigned int)a0 > 270)\n    return 3;\n  if ((unsigned int)a0 == 35) {\n    return 2;\n  } else if ((unsigned int)a0 == 45) {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static BinOpr getbinopr(int op) {\n    switch (op) {\n      case '+':\n        return OPR_ADD;\n      case '-':\n        return OPR_SUB;\n      case '*':\n        return OPR_MUL;\n      case '/':\n        return OPR_DIV;\n      case '%':\n        return OPR_MOD;\n      case '^':\n        return OPR_POW;\n      case TK_CONCAT:\n        return OPR_CONCAT;\n      case TK_NE:\n        return OPR_NE;\n      case TK_EQ:\n        return OPR_EQ;\n      case '<':\n        return OPR_LT;\n      case TK_LE:\n        return OPR_LE;\n      case '>':\n        return OPR_GT;\n      case TK_GE:\n        return OPR_GE;\n      case TK_AND:\n        return OPR_AND;\n      case TK_OR:\n        return OPR_OR;\n      default:\n        return OPR_NOBINOPR;\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int block_follow(int token) {\n    switch (token) {\n      case TK_ELSE:\n      case TK_ELSEIF:\n      case TK_END:\n      case TK_UNTIL:\n      case TK_EOS:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long block_follow_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rax\n\n  v1 = (unsigned int)a0 - 260;\n  if (27 >= (unsigned int)v1 && ((int)(134283271 >> ((char)v1 & 63)) & 1))\n    return 1;\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static ptrdiff_t posrelat(ptrdiff_t pos, size_t len) {\n    if (pos < 0)\n        pos += (ptrdiff_t)len + 1;\n    return (pos >= 0) ? pos : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long posrelat_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  if ((char)(v0 - 0 >> 63))\n    v0 += a1 + 1;\n  if (v0 >= 0)\n    return v0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int match_class(int c, int cl) {\n    int res;\n    switch (tolower(cl)) {\n      case 'a':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha);\n        break;\n      case 'c':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_IScntrl);\n        break;\n      case 'd':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit);\n        break;\n      case 'l':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower);\n        break;\n      case 'p':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISpunct);\n        break;\n      case 's':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISspace);\n        break;\n      case 'u':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper);\n        break;\n      case 'w':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum);\n        break;\n      case 'x':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISxdigit);\n        break;\n      case 'z':\n        res = (c == 0);\n        break;\n      default:\n        return (cl == c);\n    }\n    return (((*__ctype_b_loc())[(int)((cl))] & (unsigned short)_ISlower) ? res : !res);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tolower)(int);\n\ntypedef struct struct_0 {\n  char padding_0[4326224];\n  unsigned int field_420350;\n} struct_0;\n\nextern char g_420350;\n\nlong long match_class_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;           // [bp-0x20]\n  unsigned int v1;   // [bp-0xc]\n  unsigned int v15;  // eax\n  unsigned long v16; // rax\n\n  switch (tolower(a1)) {\n  case 97:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         0x400;\n    break;\n  case 99:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         2;\n    break;\n  case 100:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         0x800;\n    break;\n  case 108:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         0x200;\n    break;\n  case 112:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         4;\n    break;\n  case 115:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         0x2000;\n    break;\n  case 117:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         0x100;\n    break;\n  case 119:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         8;\n    break;\n  case 120:\n    v1 = *((short *)(*((long long *)&__ctype_b_loc()) + (unsigned int)a0 * 2)) &\n         0x1000;\n    break;\n  case 122:\n    v1 = !(unsigned int)a0;\n    break;\n  default:\n    v16 = *((int *)&v0) == (unsigned int)a0;\n    return v16;\n  }\n  v15 = *((short *)(*((long long *)&__ctype_b_loc()) + *((int *)&v0) * 2)) &\n        0x200;\n  v16 = (!v15 ? v1 : !v1);\n  return v16;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpao51_je_/match_class_name_conflict.c:35:41: error: cannot take the address of an\nrvalue of type 'int' 35 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 0x400; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:38:41: error: cannot take the address of an\nrvalue of type 'int' 38 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 2; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:41:41: error: cannot take the address of an\nrvalue of type 'int' 41 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 0x800; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:44:41: error: cannot take the address of an\nrvalue of type 'int' 44 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 0x200; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:47:41: error: cannot take the address of an\nrvalue of type 'int' 47 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 4; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:50:41: error: cannot take the address of an\nrvalue of type 'int' 50 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 0x2000; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:53:41: error: cannot take the address of an\nrvalue of type 'int' 53 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 0x100; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:56:41: error: cannot take the address of an\nrvalue of type 'int' 56 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 8; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:59:41: error: cannot take the address of an\nrvalue of type 'int' 59 |         v1 = *((short *)(*((long long\n*)&__ctype_b_loc()) + (unsigned int)a0 * 2)) & 0x1000; | ^~~~~~~~~~~~~~~~\n/tmp/tmpao51_je_/match_class_name_conflict.c:68:38: error: cannot take the address of an\nrvalue of type 'int' 68 |     v15 = *((short *)(*((long long *)&__ctype_b_loc())\n+ *((int *)&v0) * 2)) & 0x200; | ^~~~~~~~~~~~~~~~ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int matchbracketclass(int c, const char *p, const char *ec) {\n    int sig = 1;\n    if (*(p + 1) == '^') {\n        sig = 0;\n        p++;\n    }\n    while (++p < ec)\n        {\n            if (*p == '%') {\n                p++;\n                if (match_class(c, ((unsigned char)(*p))))\n                    return sig;\n            } else if ((*(p + 1) == '-') && (p + 2 < ec)) {\n                p += 2;\n                if (((unsigned char)(*(p - 2))) <= c && c <= ((unsigned char)(*p)))\n                    return sig;\n            } else if (((unsigned char)(*p)) == c)\n                return sig;\n        }\n    return !sig;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(match_class)(long long, long long);\n\nlong long matchbracketclass_name_conflict(unsigned long a0, char a1[2], unsigned long a2) {\n  char v0[2];      // [bp-0x28], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n\n  *(&v0) = a1;\n  v1 = 1;\n  if (v0[1] == 94) {\n    v1 = 0;\n    v0 = &v0[1];\n  }\n  do {\n    while (true) {\n      while (true) {\n        v0 = &v0[1];\n        if (v0 >= a2)\n          return !v1;\n        if (*((char *)v0) != 37)\n          break;\n        v0 = &v0[1];\n        if ((int)match_class((unsigned int)a0, *((char *)v0)))\n          return v1;\n      }\n      if (!(*((char *)(v0 + 1)) != 45 || v0 + 2 >= a2)) {\n        v0 += 2;\n        if ((unsigned int)a0 >= *((char *)(v0 - 2)))\n          break;\n      } else if ((unsigned int)a0 == *((char *)v0)) {\n        return v1;\n      }\n    }\n  } while ((unsigned int)a0 > *((char *)v0));\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbt1mwo64/matchbracketclass_name_conflict.c:23:12: error: array type 'char[2]' is not\nassignable 23 |     *(&v0) = a1; |     ~~~~~~ ^\n/tmp/tmpbt1mwo64/matchbracketclass_name_conflict.c:28:12: error: array type 'char[2]' is not\nassignable 28 |         v0 = &v0[1]; |         ~~ ^\n/tmp/tmpbt1mwo64/matchbracketclass_name_conflict.c:36:20: error: array type 'char[2]' is not\nassignable 36 |                 v0 = &v0[1]; |                 ~~ ^\n/tmp/tmpbt1mwo64/matchbracketclass_name_conflict.c:41:20: error: array type 'char[2]' is not\nassignable 41 |                 v0 = &v0[1]; |                 ~~ ^\n/tmp/tmpbt1mwo64/matchbracketclass_name_conflict.c:47:20: error: invalid operands to binary\nexpression ('char[2]' and 'int') 47 |                 v0 += 2; | ~~ ^  ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int singlematch(int c, const char *p, const char *ep) {\n    switch (*p) {\n      case '.':\n        return 1;\n      case '%':\n        return match_class(c, ((unsigned char)(*(p + 1))));\n      case '[':\n        return matchbracketclass(c, p, ep - 1);\n      default:\n        return (((unsigned char)(*p)) == c);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(matchbracketclass)(long long, long long, long long);\nlong long(match_class)(long long, long long);\n\nlong long singlematch_name_conflict(unsigned long a0, char a1[2], unsigned long a2) {\n  unsigned int v1;  // eax\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1[0];\n  if (v1 == 91) {\n    v2 = matchbracketclass((unsigned int)a0, a1, a2 - 1);\n    return v2;\n  }\n  if (v1 > 91)\n    return (unsigned int)a0 == a1[0];\n  if (v1 == 37) {\n    v2 = match_class((unsigned int)a0, a1[1]);\n    return v2;\n  } else if (v1 == 46) {\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static const char *lmemfind(const char *s1, size_t l1, const char *s2, size_t l2) {\n    if (l2 == 0)\n        return s1;\n    else if (l2 > l1)\n        return ((void *)0);\n    else {\n        const char *init;\n        l2--;\n        l1 = l1 - l2;\n        while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != ((void *)0))\n            {\n                init++;\n                if (memcmp(init, s2 + 1, l2) == 0)\n                    return init - 1;\n                else {\n                    l1 -= init - s1;\n                    s1 = init;\n                }\n            }\n        return ((void *)0);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long lmemfind(unsigned long a0, unsigned long a1, char *a2,\n                   unsigned long a3) {\n  unsigned int v0;       // [bp-0x38], Other Possible Types: unsigned long\n  unsigned long v1;      // [bp-0x28], Other Possible Types: unsigned int\n  void *v2;              // [bp-0x20], Other Possible Types: unsigned long\n  void *v3;              // [bp-0x10], Other Possible Types: unsigned long\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v2 = a0;\n  v1 = a1;\n  v0 = a3;\n  if (!v0) {\n    return v2;\n  } else if (v1 < v0) {\n    return 0;\n  } else {\n    *((unsigned long *)&v0) = v0 - 1;\n    for (*((unsigned long *)&v1) = v1 - *((long long *)&v0);\n         *((long long *)&v1) &&\n         (v3 = (unsigned long)memchr(v2, (unsigned int)*(a2),\n                                     *((long long *)&v1)),\n         v3);\n         v2 = v3) {\n      v3 += 1;\n      if (!memcmp(v3, a2 + 1, *((long long *)&v0)))\n        return v3 - 1;\n      v1 = *((long long *)&v1) - (v3 - v2);\n    }\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static inline char base64_encode_value(char value_in) {\n    static const char *encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    return value_in > 63 ? '=' : encoding[(int)value_in];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long encoding.0;\n\nlong long base64_encode_value_name_conflict(unsigned long a0) {\n  return ((char)a0 <= 63 ? 61 : *((char *)((char)a0 + encoding.0)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp81m15ij5/base64_encode_value_name_conflict.c:17:35: error: expected ';' after top\nlevel declarator 17 | extern unsigned long long encoding.0; | ^ | ;\n/tmp/tmp81m15ij5/base64_encode_value_name_conflict.c:21:65: error: expected ')'\n   21 |     return ((char)a0 <= 63 ? 61 : *((char *)((char)a0 + encoding.0)));\n      |                                                                 ^\n/tmp/tmp81m15ij5/base64_encode_value_name_conflict.c:21:45: note: to match this '('\n   21 |     return ((char)a0 <= 63 ? 61 : *((char *)((char)a0 + encoding.0)));\n      |                                             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"size_t base64_encode_block(const char *plaintext_in, size_t length_in, char *code_out, base64_encodestate *state_in) {\n    const char *plainchar = plaintext_in;\n    const char *const plaintextend = plaintext_in + length_in;\n    char *codechar = code_out;\n    char result;\n    char fragment;\n    result = state_in->result;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_A:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_A;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)((fragment & 252) >> 2);\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 3) << 4);\n              case step_B:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_B;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 240) >> 4));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 15) << 2);\n              case step_C:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_C;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 192) >> 6));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 63) >> 0);\n                *codechar++ = base64_encode_value(result);\n                ++(state_in->stepcount);\n            }\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(base64_encode_value)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n  char padding_5[3];\n  unsigned int field_8;\n} struct_0;\n\nlong long base64_encode_block(char *a0, unsigned long a1, char *a2,\n                              struct_0 *a3) {\n  char v0;          // [bp-0x31]\n  unsigned long v1; // [bp-0x30]\n  char v2;          // [bp-0x21]\n  char *v3;         // [bp-0x20], Other Possible Types: unsigned long\n  char *v4;         // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v6;  // eax\n  char *v7;         // rax\n  char *v8;         // rbx\n  char *v9;         // rax\n  char *v10;        // rbx\n  char *v11;        // rbx\n  char *v12;        // rax\n  char *v13;        // rbx\n\n  v4 = a0;\n  v1 = &a0[a1];\n  v3 = a2;\n  v2 = a3->field_4;\n  if (v6 == 2) {\n    for (v6 = a3->field_0; v4 != v1; v2 = v0 * 4 & 60) {\n      v9 = v4;\n      v4 = v9 + 1;\n      v0 = *(v9);\n      v2 |= (char)((unsigned int)(v0 >> 6) & 3);\n      v10 = v3;\n      v3 = v10 + 1;\n      *(v10) = base64_encode_value(v2);\n      v2 = v0 & 63;\n      v11 = v3;\n      v3 = v11 + 1;\n      *(v11) = base64_encode_value(v2);\n      a3->field_8 = a3->field_8 + 1;\n    LABEL_401347:\n      if (v4 == v1) {\n        a3->field_4 = v2;\n        a3->field_0 = 0;\n        return v3 - a2;\n      }\n      v12 = v4;\n      v4 = v12 + 1;\n      v0 = *(v12);\n      v2 = (unsigned int)(v0 >> 2) & 63;\n      v13 = v3;\n      v3 = v13 + 1;\n      *(v13) = base64_encode_value(v2);\n      v2 = v0 * 16 & 48;\n    LABEL_4013b8:\n      if (v4 == v1) {\n        a3->field_4 = v2;\n        a3->field_0 = 1;\n        return v3 - a2;\n      }\n      v7 = v4;\n      v4 = v7 + 1;\n      v0 = *(v7);\n      v2 |= (char)((unsigned int)(v0 >> 4) & 15);\n      v8 = v3;\n      v3 = v8 + 1;\n      *(v8) = base64_encode_value(v2);\n    }\n    a3->field_4 = v2;\n    a3->field_0 = 2;\n    return v3 - a2;\n  } else {\n    if (v6 > 2)\n      return v3 - a2;\n    if (!v6)\n      goto LABEL_401347;\n    if (v6 == 1)\n      goto LABEL_4013b8;\n    return v3 - a2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"size_t base64_encode_blockend(char *code_out, base64_encodestate *state_in) {\n    char *codechar = code_out;\n    switch (state_in->step) {\n      case step_B:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        *codechar++ = '=';\n        break;\n      case step_C:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        break;\n      case step_A:\n        break;\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(base64_encode_value)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n} struct_0;\n\nlong long base64_encode_blockend_name_conflict(char *a0, struct_0 *a1) {\n  char *v0;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v2; // eax\n  char *v3;        // rbx\n  char *v4;        // rax\n  char *v5;        // rbx\n  char *v6;        // rax\n  char *v7;        // rax\n\n  v0 = a0;\n  v2 = a1->field_0;\n  if (v2 == 2) {\n    v3 = v0;\n    v0 = v3 + 1;\n    *(v3) = base64_encode_value(a1->field_4);\n    v4 = v0;\n    v0 = v4 + 1;\n    *(v4) = 61;\n    return v0 - a0;\n  } else if (v2 > 2) {\n    return v0 - a0;\n  } else if (!v2) {\n    return v0 - a0;\n  } else if (v2 != 1) {\n    return v0 - a0;\n  } else {\n    v5 = v0;\n    v0 = v5 + 1;\n    *(v5) = base64_encode_value(a1->field_4);\n    v6 = v0;\n    v0 = v6 + 1;\n    *(v6) = 61;\n    v7 = v0;\n    v0 = v7 + 1;\n    *(v7) = 61;\n    return v0 - a0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"static inline char base64_decode_value(char value_in) {\n    static const char decoding[] = {62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};\n    static const char decoding_size = (char)sizeof (decoding);\n    value_in -= 43;\n    return (value_in < 0 || value_in >= decoding_size) ? -1 : decoding[(int)value_in];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char decoding.0;\n\nlong long base64_decode_value_name_conflict(unsigned long a0) {\n  char v0; // [bp-0xc]\n\n  v0 = a0;\n  v0 -= 43;\n  if (v0 >= 0 && v0 < 80)\n    return *(&(&decoding.0)[v0]);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpffikrv7i/base64_decode_value_name_conflict.c:17:21: error: expected ';' after top\nlevel declarator 17 | extern char decoding.0; |                     ^ | ;\n/tmp/tmpffikrv7i/base64_decode_value_name_conflict.c:26:29: error: expected ')'\n   26 |         return *(&(&decoding.0)[v0]);\n      |                             ^\n/tmp/tmpffikrv7i/base64_decode_value_name_conflict.c:26:19: note: to match this '('\n   26 |         return *(&(&decoding.0)[v0]);\n      |                   ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"size_t base64_decode_block(const char *code_in, size_t length_in, char *plaintext_out, base64_decodestate *state_in) {\n    const char *codechar = code_in;\n    char *plainchar = plaintext_out;\n    char fragment;\n    *plainchar = state_in->plainchar;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_a:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_a;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)((fragment & 63) << 2);\n              case step_b:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_b;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 48) >> 4));\n                ++plainchar;\n                *plainchar = (char)((fragment & 15) << 4);\n              case step_c:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_c;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 60) >> 2));\n                ++plainchar;\n                *plainchar = (char)((fragment & 3) << 6);\n              case step_d:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_d;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | (fragment & 63));\n                ++plainchar;\n            }\n    }\n    return (size_t)(plainchar - plaintext_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(base64_decode_value)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n} struct_0;\n\nlong long base64_decode_block(char *a0, unsigned long a1, char *a2,\n                              struct_0 *a3) {\n  char v0;               // [bp-0x19]\n  char *v1;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v2;              // [bp-0x10], Other Possible Types: unsigned long\n  char *v5;              // rax\n  unsigned long long v6; // rax\n\n  while (true) {\n    do {\n      if (v2 == &a0[a1]) {\n        a3->field_0 = 1;\n        a3->field_4 = *((char *)v1);\n        return v1 - a2;\n      }\n    } while ((v5 = v2, v2 = (unsigned long)(v5 + 1),\n              v6 = (unsigned long long)*(v5),\n              v0 = (char)base64_decode_value(v6), v0 < 0));\n    *(v1) = *(v1) | (unsigned int)(v0 >> 4) & 3;\n    v1 += 1;\n    *((char *)v1) = v0 * 16;\n    do {\n      if (v2 == &a0[a1]) {\n        a3->field_0 = 2;\n        a3->field_4 = *((char *)v1);\n        return v1 - a2;\n      }\n    } while ((v5 = v2, v2 = (unsigned long)(v5 + 1),\n              v6 = (unsigned long long)*(v5),\n              v0 = (char)base64_decode_value(v6), v0 < 0));\n    *((char *)v1) = *(v1) | (unsigned int)(v0 >> 2) & 15;\n    v1 += 1;\n    *((char *)v1) = v0 * 64;\n    do {\n      if (v2 == &a0[a1]) {\n        a3->field_0 = 3;\n        a3->field_4 = *((char *)v1);\n        return v1 - a2;\n      }\n    } while ((v5 = v2, v2 = (unsigned long)(v5 + 1),\n              v6 = (unsigned long long)*(v5),\n              v0 = (char)base64_decode_value(v6), v0 < 0));\n    *((char *)v1) = *(v1) | v0 & 63;\n    v1 += 1;\n    do {\n      if (v2 == &a0[a1]) {\n        a3->field_0 = 0;\n        a3->field_4 = *((char *)v1);\n        return v1 - a2;\n      }\n    } while ((v5 = v2, v2 = (unsigned long)(v5 + 1),\n              v6 = (unsigned long long)*(v5),\n              v0 = (char)base64_decode_value(v6), v0 < 0));\n    *((char *)v1) = v0 * 4;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"static int argindex(int n) {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v0 = a0;\n  v1 = 0;\n  if (argv && argv->field_0) {\n    for (v2 = 1; argv[v2].field_0; v2 += 1) {\n      if (v1 || *((char *)argv[v2].field_0) != 45 &&\n                    *((char *)argv[v2].field_0) != 43 &&\n                    !strchr(argv[v2].field_0, 61)) {\n        if (v0)\n          v0 -= 1;\n        else\n          return v2;\n      }\n      if (!strcmp(argv[v2].field_0, \"--\"))\n        v1 = 1;\n    }\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8xfjxxie/argindex_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmp8xfjxxie/argindex_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmp8xfjxxie/argindex_name_conflict.c:34:23: error: member reference type\n'int' is not a pointer 34 |     if (argv && argv->field_0) | ~~~~  ^\n/tmp/tmp8xfjxxie/argindex_name_conflict.c:36:26: error: subscripted value is not an array,\npointer, or vector 36 |         for (v2 = 1; argv[v2].field_0; v2 += 1) |\n~~~~^~~ /tmp/tmp8xfjxxie/argindex_name_conflict.c:38:37: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmp8xfjxxie/argindex_name_conflict.c:38:74: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmp8xfjxxie/argindex_name_conflict.c:38:109: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmp8xfjxxie/argindex_name_conflict.c:45:29: error: subscripted value is not an\narray, pointer, or vector 45 |             if (!strcmp(argv[v2].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  if (!argv) {\n    return v2;\n  } else if (!argv->field_0) {\n    return v2;\n  } else {\n    for (v0 = 1; argv[v0].field_0; v0 += 1) {\n      if (v1 || *((char *)argv[v0].field_0) != 45 &&\n                    *((char *)argv[v0].field_0) != 43 &&\n                    !strchr(argv[v0].field_0, 61))\n        v2 += 1;\n      if (!strcmp(argv[v0].field_0, \"--\"))\n        v1 = 1;\n    }\n    return v2;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:38:21: error: member reference type\n'int' is not a pointer 38 |     else if (!argv->field_0) |               ~~~~  ^\n/tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:44:26: error: subscripted value is not an array,\npointer, or vector 44 |         for (v0 = 1; argv[v0].field_0; v0 += 1) |\n~~~~^~~ /tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:46:37: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:46:74: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:46:109: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpe1_fahvi/OptNArgs_name_conflict.c:48:29: error: subscripted value is not an\narray, pointer, or vector 48 |             if (!strcmp(argv[v0].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *OptArg(int n) {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = argindex((unsigned int)a0);\n  return (v0 < 0 ? *((long long *)(argv + v0 * 8)) : 0);\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *pathsearch(char *argv0, char *name, int modemask) {\n    const char *pathlist;\n    char *pathbufptr;\n    char *pathbuf;\n    char *path, *cp;\n    char c;\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(((int)strlen(argv0)) + ((int)strlen(name)) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        pathbuf = (char *)malloc(((int)strlen(pathlist)) + 1);\n        path = (char *)malloc(((int)strlen(pathlist)) + ((int)strlen(name)) + 2);\n        if ((pathbuf != 0) && (path != 0)) {\n            pathbufptr = pathbuf;\n            strcpy(pathbuf, pathlist);\n            while (*pathbuf)\n                {\n                    cp = strchr(pathbuf, ':');\n                    if (cp == 0)\n                        cp = &pathbuf[((int)strlen(pathbuf))];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathbuf, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathbuf[0] = 0;\n                    else\n                        pathbuf = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n            free(pathbufptr);\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char v0;  // [bp-0x41]\n  char *v1; // [bp-0x40]\n  char *v2; // [bp-0x38], Other Possible Types: unsigned long\n  char *v3; // [bp-0x30], Other Possible Types: unsigned long\n  char *v4; // [bp-0x28], Other Possible Types: unsigned long\n  char *v5; // [bp-0x20], Other Possible Types: unsigned long\n\n  v2 = strrchr(a0, 47);\n  if (v2) {\n    v0 = *(v2);\n    *(v2) = 0;\n    v3 = malloc((unsigned int)strlen(a1) + (unsigned int)strlen(a0) + 2);\n    if (v3)\n      sprintf(v3, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v2) = v0;\n    return v3;\n  } else {\n    v5 = getenv(\"PATH\");\n    if (!v5)\n      v5 = \".:/bin:/usr/bin\";\n    v4 = malloc((unsigned int)strlen(v5) + 1);\n    v3 = malloc((unsigned int)strlen(a1) + (unsigned int)strlen(v5) + 2);\n    if (!v4) {\n      return v3;\n    } else if (!v3) {\n      return v3;\n    } else {\n      v1 = v4;\n      strcpy(v4, v5);\n      while (*(v4)) {\n        v2 = strchr(v4, 58);\n        if (!v2)\n          v2 = &v4[strlen(v4)];\n        v0 = *((char *)v2);\n        *((char *)v2) = 0;\n        sprintf(v3, \"%s/%s\", (unsigned int)v4, (unsigned int)a1);\n        *((char *)v2) = v0;\n        if (!v0)\n          *((char *)v4) = 0;\n        else\n          v4 = v2 + 1;\n        if (!access(v3, a2))\n          break;\n      }\n      free(v1);\n      return v3;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 >= 0)\n    return ((unsigned int)a1 <= 255\n                ? ((unsigned int)a1 <= 65534 ? \"unsigned int\"\n                                             : \"unsigned short int\")\n                : \"unsigned char\");\n  if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n    return \"signed char\";\n  if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n    return \"int\";\n  return \"short\";\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    s = (char *)calloc(size, 1);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = calloc(size, 1);\n  if (!v0)\n    memory_error(); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int SetUnion(char *s1, char *s2) {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  for (v1 = 0; v1 < size; v1 += 1) {\n    if (a1[v1] && !a0[v1]) {\n      v0 = 1;\n      a0[v1] = 1;\n    }\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int strhash(const char *x) {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  char *v4;              // rax\n\n  v0 = a0;\n  for (v1 = 0; *((char *)v0);\n       v1 = *(v4) + (unsigned int)(((unsigned int)v3 * 2 + v3) * 4 + v3)) {\n    v3 = v1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe(const char *y) {\n    const char *z;\n    char *cpy;\n    if (y == 0)\n        return 0;\n    z = Strsafe_find(y);\n    if (z == 0 && (cpy = (char *)malloc(((int)strlen(y)) + 1)) != 0) {\n        strcpy(cpy, y);\n        z = cpy;\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v0;         // [bp-0x18]\n  unsigned long v1; // [bp-0x10], Other Possible Types: unsigned long long\n\n  if (!a0)\n    return 0;\n  v1 = Strsafe_name_conflict_find(a0);\n  if (!v1) {\n    v0 = malloc((unsigned int)strlen(a0) + 1);\n    if (v0) {\n      strcpy(v0, a0);\n      v1 = v0;\n      Strsafe_name_conflict_insert(v1);\n    }\n  }\n  if (v1)\n    return v1;\n  memory_error(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(const char *data) {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n  unsigned long long field_10;\n} struct_1;\n\ntypedef struct struct_3 {\n  unsigned long long field_0;\n  struct struct_3 *field_8;\n  unsigned long long field_10;\n} struct_3;\n\nextern struct_2 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned int v0;          // [bp-0x48]\n  unsigned int v1;          // [bp-0x44]\n  unsigned long v2;         // [bp-0x40]\n  struct struct_0 **v3;     // [bp-0x38]\n  unsigned long long v4[3]; // [bp-0x30]\n  unsigned long long *v5;   // [bp-0x28]\n  unsigned int v6;          // [bp-0x20]\n  unsigned int v7;          // [bp-0x1c]\n  unsigned int v8;          // [bp-0x18]\n  unsigned int v9;          // [bp-0x14]\n  struct_1 *v10; // [bp-0x10], Other Possible Types: unsigned long, struct_3 *\n  char v11;      // [bp-0x8]\n  unsigned long long v13; // rbp\n  unsigned long long v18; // rsi\n  unsigned long long v19; // rdx\n\n  v13 = &v11;\n  if (!x1a)\n    return 0;\n  v8 = strhash(a0);\n  v7 = x1a->field_0 - 1 & v8;\n  for (v10 = *((long long *)(x1a->field_10 + v7 * 8)); v10;\n       v10 = *((long long *)(v10 + 8))) {\n    if (!strcmp(*((long long *)v10), a0))\n      return 0;\n  }\n  if (x1a->padding_4 >= x1a->field_0) {\n    v6 = x1a->field_0 * 2;\n    v0 = v6;\n    *((char[4]) & v1) = x1a->padding_4;\n    v2 = malloc(v6 * 32);\n    if (!v2)\n      return 0;\n    v3 = 3 * v6 * 8 + v2;\n    for (v9 = 0; v9 < v6; v9 += 1) {\n      v3[v9] = 0;\n    }\n    for (v9 = 0; v9 < x1a->padding_4; v9 += 1) {\n      v5 = 24 * v9 + (char *)x1a->field_8;\n      v7 = (int)strhash(*(v5)) & v6 - 1;\n      v4[0] = 3 * v9 * 8 + v2;\n      if (v3[v7])\n        v3[v7]->field_10 = &v4[1];\n      v4[1] = v3[v7];\n      v4[0] = *(v5);\n      v4[2] = &v3[v7];\n      v3[v7] = &v4[0];\n    }\n    free(x1a->field_8);\n    *((long long *)&x1a->field_0) = *((long long *)&v0);\n    x1a->field_8 = v2;\n    x1a->field_10 = v3;\n  }\n  v7 = x1a->field_0 - 1 & v8;\n  v18 = x1a->field_8;\n  v19 = (unsigned long long)x1a->padding_4;\n  *((unsigned int *)&x1a->padding_4[0]) = (unsigned int)v19 + 1;\n  v10 = 3 * v19 * 8 + v18;\n  v10->field_0 = a0;\n  if (*((long long *)(x1a->field_10 + (v7 << 3))))\n    *((struct_3 **)(*((long long *)(x1a->field_10 + v7 * 8)) + 16)) =\n        &v10->field_8;\n  v10->field_8 = *((long long *)(x1a->field_10 + v7 * 8));\n  *((struct_3 **)(v7 * 8 + x1a->field_10)) = v10;\n  v10->field_10 = v7 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9j7rd042/Strsafe_insert_name_conflict.c:30:8: error: unknown type name 'struct_2'\n   30 | extern struct_2 *x1a;\n      |        ^\n/tmp/tmp9j7rd042/Strsafe_insert_name_conflict.c:64:11: error: used type 'char[4]' where\narithmetic or pointer type is required 64 |         *((char [4])&v1) =\nx1a->padding_4; |           ^         ~~~\n/tmp/tmp9j7rd042/Strsafe_insert_name_conflict.c:79:23: error: incomplete definition of type\n'struct struct_0' 79 |                 v3[v7]->field_10 = &v4[1]; | ~~~~~~^\n/tmp/tmp9j7rd042/Strsafe_insert_name_conflict.c:37:12: note: forward declaration of 'struct\nstruct_0' 37 |     struct struct_0 **v3;  // [bp-0x38] |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe_find(const char *key) {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_0 {\n  char *field_0;\n  struct struct_0 *field_8;\n} struct_0;\n\nextern struct_1 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_0 *v1;    // [bp-0x10], Other Possible Types: unsigned long\n\n  if (!x1a)\n    return 0;\n  v0 = (int)strhash(a0) & x1a->field_0 - 1;\n  for (v1 = *((long long *)(x1a->field_10 + v0 * 8));\n       v1 && strcmp(*((long long *)v1), a0); v1 = *((long long *)(v1 + 8)))\n    ;\n  return (!v1 ? *((long long *)v1) : 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpykyp9jiu/Strsafe_find_name_conflict.c:23:8: error: unknown type name 'struct_1'; did\nyou mean 'struct_0'? 23 | extern struct_1 *x1a; |        ^~~~~~~~ | struct_0\n/tmp/tmpykyp9jiu/Strsafe_find_name_conflict.c:21:3: note: 'struct_0' declared here\n   21 | } struct_0;\n      |   ^\n/tmp/tmpykyp9jiu/Strsafe_find_name_conflict.c:32:27: error: invalid operands to binary\nexpression ('int' and 'char *') 32 |     v0 = (int)strhash(a0) & x1a->field_0 -\n1; |          ~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n/tmp/tmpykyp9jiu/Strsafe_find_name_conflict.c:33:36: error: no member named 'field_10' in\n'struct struct_0'; did you mean 'field_0'? 33 |     for (v1 = *((long long\n*)(x1a->field_10 + v0 * 8)); v1 && strcmp(*((long long *)v1), a0); v1 = *((long\nlong *)(v1 + 8))); |                                    ^~~~~~~~ | field_0\n/tmp/tmpykyp9jiu/Strsafe_find_name_conflict.c:19:11: note: 'field_0' declared here\n   19 |     char *field_0;\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() { return (!x2a ? x2a->field_4 : 0); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw_xicwg0/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmpw_xicwg0/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpw_xicwg0/Symbol_count_name_conflict.c:23:25: error: member\nreference type 'int' is not a pointer 23 |     return (!x2a ? x2a->field_4 : 0);\n      |                    ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Configcmp(const char *_a, const char *_b) {\n    const struct config *a = (struct config *)_a;\n    const struct config *b = (struct config *)_b;\n    int x;\n    x = a->rp->index - b->rp->index;\n    if (x == 0)\n        x = a->dot - b->dot;\n    return x;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_0 *field_0;\n  unsigned int field_8;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[72];\n  unsigned int field_48;\n} struct_0;\n\nlong long Configcmp_name_conflict(struct_1 *a0, struct_1 *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0->field_0->field_48 - a1->field_0->field_48;\n  if (!v0)\n    v0 = a0->field_8 - a1->field_8;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long check_path_name_conflict(char *a0) { return (!a0 ? access(a0, 4) != -1 : 0); }\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(check_path)(long long);\nchar *(getenv)(char *);\nchar *(getcwd)(char *, unsigned long);\nint(snprintf)(char *, unsigned long, char *, ...);\nvoid(perror)(char *);\n\nextern char g_4020ca;\n\nlong long get_config_path_name_conflict(unsigned long a0, char *a1, unsigned int a2) {\n  char v0;          // [bp-0x218]\n  unsigned long v1; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v1 = a0;\n  if ((int)check_path(v1))\n    return v1;\n  v1 = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if ((int)check_path(v1))\n    return v1;\n  v1 = getcwd(&v0, 0x200);\n  snprintf(a1, a2, \"%s/%s\", (unsigned int)v1, &g_4020ca);\n  v1 = a1;\n  if ((int)check_path(v1))\n    return v1;\n  v1 = getenv(\"HOME\");\n  snprintf(a1, a2, \"%s/.proxychains/%s\", (unsigned int)v1, &g_4020ca);\n  v1 = a1;\n  if ((int)check_path(v1))\n    return v1;\n  v1 = \"/etc/proxychains.conf\";\n  if ((int)check_path(v1))\n    return v1;\n  v1 = \"/etc/proxychains.conf\";\n  if (!(int)check_path(v1)) {\n    perror(\"couldnt find configuration file\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk0438v5n/get_config_path_name_conflict.c:19:6: error: conflicting types for 'snprintf'\n   19 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpk0438v5n/get_config_path_name_conflict.c:20:7: error: conflicting types for 'perror'\n   20 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long check_path_name_conflict(char *a0) { return (!a0 ? access(a0, 4) != -1 : 0); }\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(check_path)(long long);\nchar *(getenv)(char *);\nchar *(getcwd)(char *, unsigned long);\nint(snprintf)(char *, unsigned long, char *, ...);\nvoid(perror)(char *);\n\nextern char g_4020ea;\n\nlong long get_config_path_name_conflict(unsigned long a0, char *a1, unsigned int a2) {\n  char v0;          // [bp-0x218]\n  unsigned long v1; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v1 = a0;\n  if ((int)check_path(v1))\n    return v1;\n  v1 = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if ((int)check_path(v1))\n    return v1;\n  v1 = getcwd(&v0, 0x200);\n  snprintf(a1, a2, \"%s/%s\", (unsigned int)v1, &g_4020ea);\n  v1 = a1;\n  if ((int)check_path(v1))\n    return v1;\n  v1 = getenv(\"HOME\");\n  snprintf(a1, a2, \"%s/.proxychains/%s\", (unsigned int)v1, &g_4020ea);\n  v1 = a1;\n  if ((int)check_path(v1))\n    return v1;\n  v1 = \"/etc/proxychains.conf\";\n  if ((int)check_path(v1))\n    return v1;\n  v1 = \"/etc/proxychains.conf\";\n  if (!(int)check_path(v1)) {\n    perror(\"couldnt find configuration file\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp27qqcoqt/get_config_path_name_conflict.c:19:6: error: conflicting types for 'snprintf'\n   19 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp27qqcoqt/get_config_path_name_conflict.c:20:7: error: conflicting types for 'perror'\n   20 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"int info(int level, const char *fmt, ...) {\n    va_list ap;\n    int length;\n    if (level > verbose)\n        return 0;\n    __builtin_va_start(ap, fmt);\n    length = vfprintf(stdout, fmt, ap);\n    __builtin_va_end(ap);\n    return length;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\n\nextern FILE_t *stdout @GLIBC_2.2.5;\nextern unsigned int verbose;\n\nlong long info(unsigned long a0, char *a1, unsigned long a2, unsigned long a3,\n               unsigned long a4, unsigned long a5) {\n  unsigned int v0;   // [bp-0xd8]\n  unsigned int v1;   // [bp-0xd4]\n  unsigned long v2;  // [bp-0xd0]\n  unsigned long v3;  // [bp-0xc8]\n  unsigned int v4;   // [bp-0xbc]\n  char v5;           // [bp-0xb8]\n  unsigned long v6;  // [bp-0xa8]\n  unsigned long v7;  // [bp-0xa0]\n  unsigned long v8;  // [bp-0x98]\n  unsigned long v9;  // [bp-0x90]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  int v16;           // [bp-0x28]\n  int v17;           // [bp-0x18]\n  unsigned long v18; // [bp+0x8]\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n\n  v6 = a2;\n  v7 = a3;\n  v8 = a4;\n  v9 = a5;\n  if (v19) {\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n    v17 = v27;\n  }\n  if ((unsigned int)a0 > verbose)\n    return 0;\n  v0 = 16;\n  v1 = 48;\n  v2 = &v18;\n  v3 = &v5;\n  v4 = vfprintf(stdout @GLIBC_2.2.5, a1, &v0);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnza_pc8s/info.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpnza_pc8s/info.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpnza_pc8s/info.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpnza_pc8s/info.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpnza_pc8s/info.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpnza_pc8s/info.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpnza_pc8s/info.c:104:28: error: array has incomplete element type 'struct\nva_list' 104 | } *, char *, struct va_list[1]); |                            ^\n/tmp/tmpnza_pc8s/info.c:104:21: note: forward declaration of 'struct va_list'\n  104 | } *, char *, struct va_list[1]);\n      |                     ^\n/tmp/tmpnza_pc8s/info.c:106:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 106 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpnza_pc8s/info.c:106:22: error: expected ';' after top level declarator\n  106 | extern FILE_t *stdout@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpnza_pc8s/info.c:161:25: error: expected ')'\n  161 |     v4 = vfprintf(stdout@GLIBC_2.2.5, a1, &v0);\n      |                         ^\n/tmp/tmpnza_pc8s/info.c:161:18: note: to match this '('\n  161 |     v4 = vfprintf(stdout@GLIBC_2.2.5, a1, &v0);\n      |                  ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"unsigned short CALC_CRC1a(unsigned short crc, uint8_t byte) {\n    int i = 8;\n    unsigned short b = byte << 8;\n    while (i--)\n        {\n            crc = (crc << 1) ^ (((crc ^ b) & 32768) ? 4129 : 0);\n            b <<= 1;\n        }\n    return crc;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long CALC_CRC1a_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x1c]\n  unsigned short v1; // [bp-0xe]\n  unsigned int v2;   // [bp-0xc]\n  unsigned int v4;   // eax\n  unsigned short v5; // ax\n\n  v0 = a0;\n  v2 = 8;\n  v1 = (char)a1 * 0x100;\n  while (true) {\n    v4 = v2;\n    v2 = v4 - 1;\n    if (!v4)\n      break;\n    if ((v0 ^ v1) >= 0)\n      v5 = 0;\n    else\n      v5 = 4129;\n    v0 = v5 ^ (unsigned short)(v0 * 2);\n    v1 *= 2;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *detokenize(uint8_t *src, int maxsize) {\n    static char buff[8192];\n    char *dst = buff;\n    int string = 0;\n    while (0 != *src && maxsize-- > 0)\n        {\n            if (string) {\n                if ('\"' == *src)\n                    string = 0;\n                if (*src >= 32 && *src < 127)\n                    *dst++ = *src;\n                else\n                    dst += sprintf(dst, \"\\\\%03o\", *src);\n            } else {\n                if (255 == *src) {\n                    src++;\n                    if (*src < 128 + 26)\n                        dst += sprintf(dst, \"%s\", token[*src]);\n                    else\n                        dst += sprintf(dst, \"<ff%02x>\", *src);\n                } else if (*src > 127) {\n                    dst += sprintf(dst, \"%s\", token[*src & 127]);\n                } else {\n                    *dst++ = *src;\n                    if ('\"' == *src)\n                        string = 1;\n                }\n            }\n            src++;\n        }\n    *dst = '\\x00';\n    return buff;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char buff.3;\nextern char token;\n\nlong long detokenize_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x24]\n  char *v1;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0x14]\n  char *v3;        // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v5; // eax\n  char *v6;        // rax\n  char *v7;        // rax\n\n  v1 = a0;\n  v0 = a1;\n  v3 = &buff.3;\n  for (v2 = 0; *((char *)v1) && (v5 = v0, v0 = v5 - 1, v5 > 0); v1 += 1) {\n    if (v2) {\n      if (*((char *)v1) == 34)\n        v2 = 0;\n      if (*((char *)v1) <= 31 || *((char *)v1) > 126) {\n        v3 += sprintf(v3, \"\\\\%03o\", *((char *)v1));\n      } else {\n        v7 = v3;\n        v3 = v7 + 1;\n        *(v7) = *((char *)v1);\n      }\n    } else if (*((char *)v1) == 255) {\n      v1 += 1;\n      if (*((char *)v1) > 153)\n        v3 += sprintf(v3, \"<ff%02x>\", *((char *)v1));\n      else\n        v3 += sprintf(v3, \"%s\",\n                      (int)*((long long *)&(&token)[8 * *((char *)v1)]));\n    } else if (*((char *)v1) < 0) {\n      v3 += sprintf(v3, \"%s\",\n                    (int)*((long long *)&(&token)[8 * (*((char *)v1) & 127)]));\n    } else {\n      v6 = v3;\n      v3 = v6 + 1;\n      *(v6) = *((char *)v1);\n      if (*((char *)v1) == 34)\n        v2 = 1;\n    }\n  }\n  *((char *)v3) = 0;\n  return &buff.3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpum8rqbyy/detokenize_name_conflict.c:17:17: error: expected ';' after top level\ndeclarator 17 | extern char buff.3; |                 ^ |                 ;\n/tmp/tmpum8rqbyy/detokenize_name_conflict.c:32:15: error: expected ';' after expression\n   32 |     v3 = &buff.3;\n      |               ^\n      |               ;\n/tmp/tmpum8rqbyy/detokenize_name_conflict.c:72:17: error: expected ';' after return statement\n   72 |     return &buff.3;\n      |                 ^\n      |                 ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_scan_sectors(track_stat_t *ts) {\n    uint8_t *p;\n    int ip;\n    unsigned long dp;\n    unsigned long dd;\n    unsigned long len;\n    unsigned short crc, c;\n    dam_t *dam;\n    memset(ts, 0, sizeof (*ts));\n    for (ip = 0; ip < 128; ip += 2) {\n        p = dmk.track;\n        dam = &ts->sector[ip / 2];\n        dp = p[ip + 0] + 256 * p[ip + 1];\n        if (0 == dp)\n            break;\n        dd = dp & 32768;\n        dp = dp & ~32768;\n        info(1, \"#%02x @%04x\", ip / 2, dp);\n        crc = 65535;\n        if (32768 == dd) {\n            dam->flags |= 1;\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        if (p[dp] != 254) {\n            info(1, \" - not pointing to AM (0xfe)\\n\");\n            dam->flags |= 2;\n            ts->am_bad += 1;\n            continue;\n        }\n        ts->am_good += 1;\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->c = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->h = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->r = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->n = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        len = 1 << (7 + (dam->n & 3));\n        info(1, \" C:%02x H:%02x R:%02x N:%02x\", dam->c, dam->h, dam->r, dam->n);\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" AM-CRC:good\");\n            dam->flags &= ~4;\n        } else {\n            info(1, \" AM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 4;\n            ts->am_crc_bad += 1;\n        }\n        for (; dp < (256UL * dmk.trklen[1] + dmk.trklen[0]); dp++) {\n            if (p[dp] >= 248 && p[dp] <= 251)\n                break;\n        }\n        if (dp >= (256UL * dmk.trklen[1] + dmk.trklen[0])) {\n            info(1, \" no DAM!\\n\");\n            dam->flags |= 8;\n            ts->dam_missing += 1;\n            continue;\n        }\n        crc = 65535;\n        if (32768 == dd) {\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        switch (p[dp]) {\n          case 248:\n          case 249:\n          case 250:\n            dam->flags |= 32;\n            break;\n          case 251:\n            dam->flags &= ~32;\n            break;\n        }\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        info(1, \" DAM:%02x\", p[dp]);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->dp = dp;\n        dam->flags |= 128;\n        while (len-- > 0)\n            {\n                if (0 != (dam->flags & 128) && 229 != p[dp])\n                    dam->flags &= ~128;\n                crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n                dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n            }\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" DAM-CRC:good\");\n            dam->flags &= ~16;\n        } else {\n            info(1, \" DAM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 16;\n            ts->dam_crc_bad += 1;\n        }\n        if (dam->flags & 128)\n            info(1, \" empty\");\n        info(1, \"\\n\");\n    }\n    ts->sector_count = ip / 2;\n    info(1, \"\\n\");\n    if (0 == ts->am_bad && 0 == ts->am_crc_bad && 0 == ts->dam_crc_bad)\n        ts->perfect = 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\n\ntypedef struct struct_1 {\n  char field_0;\n  char padding_1[4223007];\n  unsigned short field_407020;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  char field_4;\n  char field_5;\n  char field_6;\n  char field_7;\n  char field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4223008];\n  unsigned short field_407020;\n} struct_0;\n\nextern char crc16;\nextern char g_40a5e2;\nextern char g_40a5e3;\nextern char g_40a5e4;\nextern struct_1 g_40a5f0;\n\nlong long dmk_scan_sectors(char a0[7], unsigned long a1, unsigned long a2,\n                           unsigned long a3, unsigned long long a4,\n                           unsigned long long a5) {\n  unsigned short v0;      // [bp-0x42]\n  unsigned long v1;       // [bp-0x40]\n  struct_2 *v2;           // [bp-0x38]\n  struct_1 *v3;           // [bp-0x30]\n  unsigned short v4;      // [bp-0x22]\n  unsigned long v5;       // [bp-0x20], Other Possible Types: unsigned long long\n  struct_1 *v6;           // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v7;        // [bp-0xc]\n  struct_0 *v10;          // rax\n  struct_0 *v11;          // rax\n  struct_1 *v12;          // rax\n  unsigned long v13;      // rdx\n  unsigned long v20;      // rdx\n  unsigned long long v22; // rdx\n  struct_0 *v23;          // rax\n  struct_0 *v24;          // rax\n  struct_0 *v25;          // rax\n  unsigned int v26;       // eax\n  unsigned long long v28; // rax\n  unsigned long v31;      // rdx\n  unsigned long v33;      // rdx, Other Possible Types: unsigned long long\n  unsigned long long v34; // rdx\n\n  memset(a0, 0, 776);\n  for (v7 = 0;\n       v7 <= 127 &&\n       (v3 = (struct_1 *)&g_40a5f0.field_0,\n       v2 = (struct_2 *)(3 *\n                             ((unsigned long long)v7 +\n                                  ((unsigned long long)v7 >> 31) >>\n                              1) *\n                             4 +\n                         a0 + 8),\n       a3 = (unsigned long long)(v7 + 1),\n       v6 = (struct_1 *)((unsigned long long)(&v3->field_0)[v7] +\n                         (unsigned long long)(&v3->field_0)[a3] * 0x100),\n       v6);\n       v7 += 2) {\n    v1 = (unsigned int)v6 & 0x8000;\n    v6 &= -32769;\n    info(1, \"#%02x @%04x\", v7 + (v7 >> 31) >> 1, v6, a4, a5);\n    v4 = 65535;\n    if (v1 == 0x8000) {\n      v2->field_8 = v2->field_8 | 1;\n      v10 = v4;\n      *((unsigned short *)&v10) = (unsigned short)v10 >> 8;\n      *((char *)&v10) = (char)v10 ^ 161;\n      v4 = *((short *)(0x2 * v10 + &crc16)) ^ (unsigned short)(v4 * 0x100);\n      v11 = v4;\n      *((unsigned short *)&v11) = (unsigned short)v11 >> 8;\n      *((char *)&v11) = (char)v11 ^ 161;\n      v4 = *((short *)(0x2 * v11 + &crc16)) ^ (unsigned short)(v4 * 0x100);\n      a3 = v4 * 0x100;\n      v12 = v4;\n      *((unsigned short *)&v12) = (unsigned short)v12 >> 8;\n      *((char *)&v12) = (char)v12 ^ 161;\n      v4 = *((short *)(0x2 * v12 + &crc16)) ^ (unsigned short)a3;\n    }\n    v13 = v3;\n    if (*((char *)(v6 + v13)) != 254) {\n      info(1, \" - not pointing to AM (0xfe)\\n\", v13, a3, a4, a5);\n      v2->field_8 = v2->field_8 | 2;\n      a0[2] = a0[2] + 1;\n    } else {\n      a0[1] = a0[1] + 1;\n      v4 = *((short *)&(\n               &crc16)[2 * ((&v3->field_0)[v6] ^ (unsigned int)(v4 >> 8))]) ^\n           v4 * 0x100;\n      v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n      v2->field_4 = (&v3->field_0)[v6];\n      v4 = *((short *)&(\n               &crc16)[2 * ((&v3->field_0)[v6] ^ (unsigned int)(v4 >> 8))]) ^\n           v4 * 0x100;\n      v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n      v2->field_5 = (&v3->field_0)[v6];\n      v4 = *((short *)&(\n               &crc16)[2 * ((&v3->field_0)[v6] ^ (unsigned int)(v4 >> 8))]) ^\n           v4 * 0x100;\n      v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n      v2->field_6 = (&v3->field_0)[v6];\n      v4 = *((short *)&(\n               &crc16)[2 * ((&v3->field_0)[v6] ^ (unsigned int)(v4 >> 8))]) ^\n           v4 * 0x100;\n      v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n      v2->field_7 = (&v3->field_0)[v6];\n      v4 = *((short *)&(\n               &crc16)[2 * ((&v3->field_0)[v6] ^ (unsigned int)(v4 >> 8))]) ^\n           v4 * 0x100;\n      v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n      v5 = 1 << ((v2->field_7 & 3) + 7 & 31);\n      info(1, \" C:%02x H:%02x R:%02x N:%02x\", v2->field_4, v2->field_5,\n           v2->field_6, v2->field_7);\n      v0 = (&v3->field_0)[v6] * 0x100;\n      v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n      v20 = v3;\n      v0 |= (&v6->field_0)[v20];\n      v6 = &(&v6->field_0)[(!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2))];\n      if (v0 == v4) {\n        info(1, \" AM-CRC:good\", v20, a3, a4, a5);\n        v2->field_8 = v2->field_8 & 4294967291;\n      } else {\n        info(1, \" AM-CRC:bad (%04x != %04x)\", v0, v4, a4, a5);\n        v2->field_8 = v2->field_8 | 4;\n        a0[3] = a0[3] + 1;\n      }\n      for (; v6 < g_40a5e2 + (g_40a5e3 << 8) &&\n             ((&v3->field_0)[v6] <= 247 || (&v3->field_0)[v6] > 251);\n           v6 += 1)\n        ;\n      v22 = g_40a5e3 * 0x100;\n      if (v6 >= g_40a5e2 + v22) {\n        info(1, \" no DAM!\\n\", v22, a3, a4, a5);\n        v2->field_8 = v2->field_8 | 8;\n        a0[4] = a0[4] + 1;\n      } else {\n        v4 = 65535;\n        if (v1 == 0x8000) {\n          v23 = v4;\n          *((unsigned short *)&v23) = (unsigned short)v23 >> 8;\n          *((char *)&v23) = (char)v23 ^ 161;\n          v4 = *((short *)(0x2 * v23 + &crc16)) ^ (unsigned short)(v4 * 0x100);\n          v24 = v4;\n          *((unsigned short *)&v24) = (unsigned short)v24 >> 8;\n          *((char *)&v24) = (char)v24 ^ 161;\n          v4 = *((short *)(0x2 * v24 + &crc16)) ^ (unsigned short)(v4 * 0x100);\n          v25 = v4;\n          *((unsigned short *)&v25) = (unsigned short)v25 >> 8;\n          *((char *)&v25) = (char)v25 ^ 161;\n          v4 = *((short *)(0x2 * v25 + &crc16)) ^ (unsigned short)(v4 * 0x100);\n        }\n        v26 = (&v3->field_0)[v6];\n        if (v26 > 250) {\n          if (v26 == 251)\n            v2->field_8 = v2->field_8 & 4294967263;\n        } else {\n          if (v26 >= 248)\n            v2->field_8 = v2->field_8 | 32;\n        }\n        a3 = v3;\n        v4 =\n            *((short *)&(\n                &crc16)[2 * (*((char *)(v6 + a3)) ^ (unsigned int)(v4 >> 8))]) ^\n            v4 * 0x100;\n        info(1, \" DAM:%02x\", (&v3->field_0)[v6], a3, a4, a5);\n        v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n        v2->field_0 = v6;\n        v2->field_8 = v2->field_8 | -128;\n        while (true) {\n          v28 = v5;\n          v5 = v28 - 1;\n          if (!v28)\n            break;\n          if (v2->field_8 < 0 && (&v3->field_0)[v6] != 229)\n            v2->field_8 = v2->field_8 & 127;\n          a3 = v3;\n          v4 = *((short *)&(&crc16)[2 * (*((char *)(v6 + a3)) ^\n                                         (unsigned int)(v4 >> 8))]) ^\n               v4 * 0x100;\n          v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n        }\n        v0 = (&v3->field_0)[v6] * 0x100;\n        v6 += (!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2));\n        v31 = v3;\n        v0 |= (&v6->field_0)[v31];\n        v6 = &(&v6->field_0)[(!v1 ? 1 : (!(g_40a5e4 & 64) ? 1 : 2))];\n        if (v0 == v4) {\n          info(1, \" DAM-CRC:good\", v31, a3, a4, a5);\n          v33 = v2->field_8 & 4294967279;\n          v2->field_8 = v33;\n        } else {\n          info(1, \" DAM-CRC:bad (%04x != %04x)\", v0, v4, a4, a5);\n          v2->field_8 = v2->field_8 | 16;\n          v33 = a0[5] + 1;\n          a0[5] = v33;\n        }\n        if (v2->field_8 < 0)\n          info(1, \" empty\", v33, a3, a4, a5);\n        info(1, \"\\n\", v33, a3, a4, a5);\n      }\n    }\n  }\n  v34 = v7 + (v7 >> 31) >> 1;\n  a0[6] = v34;\n  info(1, \"\\n\", v34, a3, a4, a5);\n  if (a0[2]) {\n    return 0;\n  } else if (a0[3]) {\n    return 0;\n  } else if (a0[5]) {\n    return 0;\n  } else {\n    a0[0] = 1;\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:73:12: error: invalid operands to binary\nexpression ('struct_1 *' (aka 'struct struct_1 *') and 'int') 73 |         v6 &=\n-32769; |         ~~ ^  ~~~~~~ /tmp/tmprw6wmud8/dmk_scan_sectors.c:82:34: error:\ninvalid operands to binary expression ('int' and 'struct_0 *' (aka 'struct\nstruct_0 *')) 82 |             v4 = *((short *)(0x2 * v10 + &crc16)) ^ (unsigned\nshort)(v4 * 0x100); |                              ~~~ ^ ~~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:86:34: error: invalid operands to binary\nexpression ('int' and 'struct_0 *' (aka 'struct struct_0 *')) 86 | v4 = *((short\n*)(0x2 * v11 + &crc16)) ^ (unsigned short)(v4 * 0x100); | ~~~ ^ ~~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:91:34: error: invalid operands to binary\nexpression ('int' and 'struct_1 *' (aka 'struct struct_1 *')) 91 | v4 = *((short\n*)(0x2 * v12 + &crc16)) ^ (unsigned short)a3; |                              ~~~\n^ ~~~ /tmp/tmprw6wmud8/dmk_scan_sectors.c:103:58: error: array subscript is not\nan integer 103 |             v4 = *((short *)&(&crc16)[2 * ((&v3->field_0)[v6] ^\n(unsigned int)(v4 >> 8))]) ^ v4 * 0x100; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:105:41: error: array subscript is not an\ninteger 105 |             v2->field_4 = (&v3->field_0)[v6]; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:106:58: error: array subscript is not an\ninteger 106 |             v4 = *((short *)&(&crc16)[2 * ((&v3->field_0)[v6] ^\n(unsigned int)(v4 >> 8))]) ^ v4 * 0x100; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:108:41: error: array subscript is not an\ninteger 108 |             v2->field_5 = (&v3->field_0)[v6]; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:109:58: error: array subscript is not an\ninteger 109 |             v4 = *((short *)&(&crc16)[2 * ((&v3->field_0)[v6] ^\n(unsigned int)(v4 >> 8))]) ^ v4 * 0x100; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:111:41: error: array subscript is not an\ninteger 111 |             v2->field_6 = (&v3->field_0)[v6]; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:112:58: error: array subscript is not an\ninteger 112 |             v4 = *((short *)&(&crc16)[2 * ((&v3->field_0)[v6] ^\n(unsigned int)(v4 >> 8))]) ^ v4 * 0x100; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:114:41: error: array subscript is not an\ninteger 114 |             v2->field_7 = (&v3->field_0)[v6]; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:115:58: error: array subscript is not an\ninteger 115 |             v4 = *((short *)&(&crc16)[2 * ((&v3->field_0)[v6] ^\n(unsigned int)(v4 >> 8))]) ^ v4 * 0x100; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:119:32: error: array subscript is not an\ninteger 119 |             v0 = (&v3->field_0)[v6] * 0x100; | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:135:70: error: array subscript is not an\ninteger 135 |             for (; v6 < g_40a5e2 + (g_40a5e3 << 8) &&\n((&v3->field_0)[v6] <= 247 || (&v3->field_0)[v6] > 251); v6 += 1); | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:135:99: error: array subscript is not an\ninteger 135 |             for (; v6 < g_40a5e2 + (g_40a5e3 << 8) &&\n((&v3->field_0)[v6] <= 247 || (&v3->field_0)[v6] > 251); v6 += 1); | ^~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:151:42: error: invalid operands to binary\nexpression ('int' and 'struct_0 *' (aka 'struct struct_0 *')) 151 | v4 =\n*((short *)(0x2 * v23 + &crc16)) ^ (unsigned short)(v4 * 0x100); | ~~~ ^ ~~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:155:42: error: invalid operands to binary\nexpression ('int' and 'struct_0 *' (aka 'struct struct_0 *')) 155 | v4 =\n*((short *)(0x2 * v24 + &crc16)) ^ (unsigned short)(v4 * 0x100); | ~~~ ^ ~~~\n/tmp/tmprw6wmud8/dmk_scan_sectors.c:159:42: error: invalid operands to binary\nexpression ('int' and 'struct_0 *' (aka 'struct struct_0 *')) 159 | v4 =\n*((short *)(0x2 * v25 + &crc16)) ^ (unsigned short)(v4 * 0x100); | ~~~ ^ ~~~\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_sort_by_sector(track_stat_t *ts) {\n    qsort(ts->sector, ts->sector_count, sizeof(dam_t), qsort_sector);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint qsort_sector; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[6];\n  char field_6;\n} struct_0;\n\nlong long dmk_sort_by_sector_name_conflict(struct_0 *a0) {\n  qsort(&a0[1].padding_0[1], a0->field_6, 12, qsort_sector);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *newdos_flags_str(newdos_dirent_t *de) {\n    static char flags[13];\n    flags[0] = de->fl0 & 64 ? 'S' : '.';\n    flags[1] = de->fl0 & 8 ? 'I' : '.';\n    flags[2] = de->fl0 & 16 ? 'U' : '.';\n    if (de->fl0 & 64) {\n        flags[3] = de->fl1 & 128 ? 'E' : '.';\n        flags[4] = de->fl1 & 64 ? 'C' : '.';\n        flags[5] = de->fl1 & 1 ? '0' : '.';\n        flags[6] = de->fl1 & 2 ? '1' : '.';\n        flags[7] = de->fl1 & 4 ? '2' : '.';\n        flags[8] = de->fl0 & 8 ? '3' : '.';\n        flags[9] = de->fl0 & 32 ? 'U' : '.';\n        flags[10] = de->fl0 & 64 ? 'A' : '.';\n    } else {\n        flags[3] = '.';\n        flags[4] = '.';\n        flags[5] = '.';\n        flags[6] = '.';\n        flags[7] = '.';\n        flags[8] = '.';\n        flags[9] = '.';\n        flags[10] = '.';\n    }\n    flags[11] = '0' + (de->fl0 & 7);\n    flags[12] = '\\x00';\n    return flags;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char flags.2;\nextern char g_475641;\nextern char g_475642;\nextern char g_475643;\nextern char g_475644;\nextern char g_475645;\nextern char g_475646;\nextern char g_475647;\nextern char g_475648;\nextern char g_475649;\nextern char g_47564a;\nextern char g_47564b;\nextern char g_47564c;\n\nlong long newdos_flags_str_name_conflict(char a0[2]) {\n  *((int *)&flags.2) = (!(a0[0] & 64) ? 83 : 46);\n  *((int *)&g_475641) = (!(a0[0] & 8) ? 73 : 46);\n  *((int *)&g_475642) = (!(a0[0] & 16) ? 85 : 46);\n  if (!(a0[0] & 64)) {\n    g_475643 = 46;\n    g_475644 = 46;\n    g_475645 = 46;\n    g_475646 = 46;\n    g_475647 = 46;\n    g_475648 = 46;\n    g_475649 = 46;\n    g_47564a = 46;\n  } else {\n    *((int *)&g_475643) = (a0[1] < 0 ? 46 : 69);\n    *((int *)&g_475644) = (!(a0[1] & 64) ? 67 : 46);\n    *((int *)&g_475645) = (!(a0[1] & 1) ? 48 : 46);\n    *((int *)&g_475646) = (!(a0[1] & 2) ? 49 : 46);\n    *((int *)&g_475647) = (!(a0[1] & 4) ? 50 : 46);\n    *((int *)&g_475648) = (!(a0[0] & 8) ? 51 : 46);\n    *((int *)&g_475649) = (!(a0[0] & 32) ? 85 : 46);\n    *((int *)&g_47564a) = (!(a0[0] & 64) ? 65 : 46);\n  }\n  g_47564b = (a0[0] & 7) + 48;\n  g_47564c = 0;\n  return &flags.2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzali5t0u/newdos_flags_str_name_conflict.c:17:18: error: expected ';' after top level\ndeclarator 17 | extern char flags.2; |                  ^ |                  ;\n/tmp/tmpzali5t0u/newdos_flags_str_name_conflict.c:33:20: error: expected ')'\n   33 |     *((int *)&flags.2) = (!(a0[0] & 64) ? 83 : 46);\n      |                    ^\n/tmp/tmpzali5t0u/newdos_flags_str_name_conflict.c:33:6: note: to match this '('\n   33 |     *((int *)&flags.2) = (!(a0[0] & 64) ? 83 : 46);\n      |      ^\n/tmp/tmpzali5t0u/newdos_flags_str_name_conflict.c:60:18: error: expected ';' after return\nstatement 60 |     return &flags.2; |                  ^ |                  ; 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *binstr(int val, int bits) {\n    static char buff[33];\n    int i;\n    if (bits > 32)\n        bits = 32;\n    for (i = 0; i < bits; i++ , val >>= 1)\n        buff[i] = '0' + (val & 1);\n    buff[bits] = '\\x00';\n    return buff;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char buff.1;\n\nlong long binstr_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0xc]\n\n  v1 = a0;\n  v0 = a1;\n  if (v0 > 32)\n    v0 = 32;\n  for (v2 = 0; v2 < (int)v0; v1 >>= 1) {\n    *(&(&buff.1)[v2]) = (v1 & 1) + 48;\n    v2 += 1;\n  }\n  *(&(&buff.1)[v0]) = 0;\n  return &buff.1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpec7kswa5/binstr_name_conflict.c:17:17: error: expected ';' after top level declarator\n   17 | extern char buff.1;\n      |                 ^\n      |                 ;\n/tmp/tmpec7kswa5/binstr_name_conflict.c:31:18: error: expected ')'\n   31 |         *(&(&buff.1)[v2]) = (v1 & 1) + 48;\n      |                  ^\n/tmp/tmpec7kswa5/binstr_name_conflict.c:31:12: note: to match this '('\n   31 |         *(&(&buff.1)[v2]) = (v1 & 1) + 48;\n      |            ^\n/tmp/tmpec7kswa5/binstr_name_conflict.c:34:14: error: expected ')'\n   34 |     *(&(&buff.1)[v0]) = 0;\n      |              ^\n/tmp/tmpec7kswa5/binstr_name_conflict.c:34:8: note: to match this '('\n   34 |     *(&(&buff.1)[v0]) = 0;\n      |        ^\n/tmp/tmpec7kswa5/binstr_name_conflict.c:35:17: error: expected ';' after return statement\n   35 |     return &buff.1;\n      |                 ^\n      |                 ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *dmk_filename_ext(newdos_dirent_t *de, char delim) {\n    static char name[13];\n    char *dst, *src;\n    int i;\n    dst = name;\n    for (i = 0 , src = de->filename; i < 8; i++) {\n        if (*src == ' ')\n            break;\n        *dst++ = *src++;\n    }\n    if (*de->extension != ' ') {\n        *dst++ = delim;\n        for (i = 0 , src = de->extension; i < 3; i++) {\n            if (*src == ' ')\n                break;\n            *dst++ = *src++;\n        }\n    }\n    *dst = '\\x00';\n    return name;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[13];\n  char field_d;\n} struct_0;\n\nextern char name.0;\n\nlong long dmk_filename_ext_name_conflict(struct_0 *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x1c]\n  char *v1;        // [bp-0x18], Other Possible Types: unsigned long\n  char *v2;        // [bp-0x10], Other Possible Types: unsigned long\n  char *v4;        // rdx\n  char *v5;        // rax\n  char *v6;        // rax\n  char *v7;        // rdx\n  char *v8;        // rax\n\n  v2 = &name.0;\n  v0 = 0;\n  for (v1 = &a0->padding_0[5]; v0 <= 7 && *(v1) != 32; v0 += 1) {\n    v4 = v1;\n    v1 = v4 + 1;\n    v5 = v2;\n    v2 = v5 + 1;\n    *(v5) = *(v4);\n  }\n  if (a0->field_d != 32) {\n    v6 = v2;\n    v2 = v6 + 1;\n    *(v6) = a1;\n    v0 = 0;\n    for (v1 = &a0->field_d; v0 <= 2 && *(v1) != 32; v0 += 1) {\n      v7 = v1;\n      v1 = v7 + 1;\n      v8 = v2;\n      v2 = v8 + 1;\n      *(v8) = *(v7);\n    }\n  }\n  *((char *)v2) = 0;\n  return &name.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm7vhsi_l/dmk_filename_ext_name_conflict.c:22:17: error: expected ';' after top level\ndeclarator 22 | extern char name.0; |                 ^ |                 ;\n/tmp/tmpm7vhsi_l/dmk_filename_ext_name_conflict.c:35:15: error: expected ';' after expression\n   35 |     v2 = &name.0;\n      |               ^\n      |               ;\n/tmp/tmpm7vhsi_l/dmk_filename_ext_name_conflict.c:61:17: error: expected ';' after return\nstatement 61 |     return &name.0; |                 ^ |                 ; 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_bas(uint8_t *buff, int *psize) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    if (255 != *buff) {\n        info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\", *buff);\n        return -1;\n    }\n    info(2, \"*** verify BAS\\n\");\n    state = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr) {\n                if (offs + 1 < *psize) {\n                    info(1, \"  data after program (0x%x)\\n\", *psize - 1 - offs);\n                }\n                *psize = offs + 1;\n            }\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            state = 5;\n            info(2, \"  line %5d at 0x%04x\", line, addr);\n            blen = 0;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(2, \" - 0x%02x bytes\\n\", blen);\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    info(2, \"  %d lines\\n\", lcnt);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\n\nlong long verify_bas(char *a0, unsigned int *a1, unsigned long long a2,\n                     unsigned long long a3, unsigned long long a4,\n                     unsigned long long a5) {\n  unsigned int v0; // [bp-0x20]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0x18]\n  unsigned int v3; // [bp-0x14]\n  unsigned int v4; // [bp-0x10]\n  unsigned int v5; // [bp-0xc]\n\n  v3 = 0;\n  v2 = 0;\n  v1 = 0;\n  v0 = 0;\n  if (*(a0) != 255) {\n    info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\", *(a0), a3, a4,\n         a5);\n    return 4294967295;\n  }\n  info(2, \"*** verify BAS\\n\", a2, a3, a4, a5);\n  v5 = 0;\n  for (v4 = 0; v4 < *(a1); v4 += 1) {\n    switch (v5) {\n    case 0:\n      v5 = 1;\n      break;\n    case 1:\n      v3 = a0[v4];\n      v5 = 2;\n      break;\n    case 2:\n      v3 += a0[v4] * 0x100;\n      v5 = 3;\n      if (!v3) {\n        if (v4 + 1 < *(a1))\n          info(1, \"  data after program (0x%x)\\n\", *(a1)-1 - v4, a3, a4, a5);\n        *(a1) = v4 + 1;\n      }\n      break;\n    case 3:\n      v2 = a0[v4];\n      v5 = 4;\n      break;\n    case 4:\n      v2 += a0[v4] * 0x100;\n      v5 = 5;\n      info(2, \"  line %5d at 0x%04x\", v2, v3, a4, a5);\n      v1 = 0;\n      break;\n    case 5:\n      v1 += 1;\n      if (!a0[v4]) {\n        info(2, \" - 0x%02x bytes\\n\", v1, a3, a4, a5);\n        v5 = 1;\n        v0 += 1;\n        break;\n      }\n    }\n  }\n  info(2, \"  %d lines\\n\", v0, a3, a4, a5);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_cmd(uint8_t *buff, int *psize) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    info(2, \"*** verify CMD\\n\");\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                state = 1;\n                break;\n              case 2:\n                state = 2;\n                break;\n              default:\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  comment block type 0x%02x\\n\", buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  bogus entry block length (%02x)\\n\", blen);\n                blen = 2;\n                buff[offs] = 2;\n            }\n            break;\n          case 3:\n            blen = buff[offs];\n            state = 6;\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            break;\n          case 6:\n            if (--blen <= 0)\n                state = 0;\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            if (blen <= 0)\n                blen += 256;\n            if (addr != chain) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  data at %04x\", addr);\n            }\n            chain = addr;\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            if (chain)\n                info(2, \" - %04x\\n\", chain - 1);\n            chain = 0;\n            info(1, \"  entry point at 0x%04x\\n\", badr);\n            if (offs + 1 < *psize)\n                info(1, \"  data after entry point (0x%x)\\n\", *psize - 1 - offs);\n            *psize = offs + 1;\n            break;\n          case 9:\n            chain += 1;\n            if (--blen <= 0)\n                state = 0;\n            break;\n        }\n    }\n    if (chain)\n        info(2, \" - %04x\\n\", chain - 1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\n\nlong long verify_cmd(char *a0, unsigned int *a1, unsigned long long a2,\n                     unsigned long long a3, unsigned long long a4,\n                     unsigned long long a5) {\n  unsigned int v0; // [bp-0x20]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0x18]\n  unsigned int v3; // [bp-0x14]\n  unsigned int v4; // [bp-0x10]\n  unsigned int v5; // [bp-0xc]\n  unsigned int v7; // eax\n\n  v3 = 0;\n  v2 = 0;\n  v1 = 0;\n  v0 = 0;\n  info(2, \"*** verify CMD\\n\", a2, a3, a4, a5);\n  v5 = 0;\n  v1 = 0;\n  for (v4 = 0; v4 < *(a1); v4 += 1) {\n    switch (v5) {\n    case 0:\n      v7 = a0[v4];\n      if (v7 == 1) {\n        v5 = 1;\n      } else if (v7 == 2) {\n        v5 = 2;\n      } else {\n        if (v1)\n          info(2, \" - %04x\\n\", v1 - 1, a3, a4, a5);\n        v1 = 0;\n        info(1, \"  comment block type 0x%02x\\n\", a0[v4], a3, a4, a5);\n        v5 = 3;\n      }\n      break;\n    case 1:\n      v3 = a0[v4];\n      v5 = 4;\n      break;\n    case 2:\n      v3 = a0[v4];\n      v5 = 5;\n      if (v3 != 2) {\n        if (v1)\n          info(2, \" - %04x\\n\", v1 - 1, a3, a4, a5);\n        v1 = 0;\n        info(1, \"  bogus entry block length (%02x)\\n\", v3, a3, a4, a5);\n        v3 = 2;\n        a0[v4] = 2;\n      }\n      break;\n    case 3:\n      v3 = a0[v4];\n      v5 = 6;\n      break;\n    case 4:\n      v3 -= 1;\n      v2 = a0[v4];\n      v5 = 7;\n      break;\n    case 5:\n      v3 -= 1;\n      v0 = a0[v4];\n      v5 = 8;\n      break;\n    case 6:\n      v3 -= 1;\n      if (v3 <= 0)\n        v5 = 0;\n      break;\n    case 7:\n      v3 -= 1;\n      v2 += a0[v4] * 0x100;\n      v5 = 9;\n      if (v3 <= 0)\n        v3 += 0x100;\n      if (v2 != v1) {\n        if (v1)\n          info(2, \" - %04x\\n\", v1 - 1, a3, a4, a5);\n        v1 = 0;\n        info(1, \"  data at %04x\", v2, a3, a4, a5);\n      }\n      v1 = v2;\n      break;\n    case 8:\n      v3 -= 1;\n      v0 += a0[v4] * 0x100;\n      if (v1)\n        info(2, \" - %04x\\n\", v1 - 1, a3, a4, a5);\n      v1 = 0;\n      info(1, \"  entry point at 0x%04x\\n\", v0, a3, a4, a5);\n      if (v4 + 1 < *(a1))\n        info(1, \"  data after entry point (0x%x)\\n\", *(a1)-1 - v4, a3, a4, a5);\n      *(a1) = v4 + 1;\n      break;\n    case 9:\n      v1 += 1;\n      v3 -= 1;\n      if (v3 <= 0)\n        v5 = 0;\n      break;\n    }\n  }\n  if (v1)\n    info(2, \" - %04x\\n\", v1 - 1, a3, a4, a5);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_txt(uint8_t *buff, int *psize) {\n    int offs;\n    uint8_t *dst;\n    dst = memchr(buff, '\\x03', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^C (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    dst = memchr(buff, '\\x00', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^@ (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\n\nlong long verify_txt(void *a0, unsigned int *a1, unsigned long a2,\n                     unsigned long long a3, unsigned long long a4,\n                     unsigned long long a5) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned long v1; // [bp-0x10]\n\n  v1 = memchr(a0, 3, *(a1));\n  v0 = (!v1 ? (unsigned int)(v1 - a0) : *(a1));\n  if (v0 + 1 < *(a1)) {\n    info(1, \"  data after end-of-file code ^C (0x%x)\\n\", *(a1)-1 - v0, a3, a4,\n         a5);\n    *(a1) = v0 + 1;\n  }\n  v1 = memchr(a0, 0, *(a1));\n  v0 = (!v1 ? (unsigned int)(v1 - a0) : *(a1));\n  if (v0 + 1 < *(a1)) {\n    info(1, \"  data after end-of-file code ^@ (0x%x)\\n\", *(a1)-1 - v0, a3, a4,\n         a5);\n    *(a1) = v0 + 1;\n    return 0;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpti885rnm/verify_txt.c:24:35: error: invalid operands to binary\nexpression ('unsigned long' and 'void *') 24 |     v0 = (!v1 ? (unsigned int)(v1\n- a0) : *(a1)); |                                ~~ ^ ~~\n/tmp/tmpti885rnm/verify_txt.c:31:35: error: invalid operands to binary\nexpression ('unsigned long' and 'void *') 31 |     v0 = (!v1 ? (unsigned int)(v1\n- a0) : *(a1)); |                                ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_bas(uint8_t *buff, int size) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    state = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr)\n                offs = size;\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            info(0, \"%05x:(%04x) %5d\", offs, addr, line);\n            blen = 0;\n            state = 5;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(0, \" %s\\n\", detokenize(buff + offs - blen + 1, blen));\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\nlong long(detokenize)(long long, long long);\n\nlong long hexdump_bas(char *a0, unsigned long a1, unsigned long a2,\n                      unsigned long long a3, unsigned long long a4,\n                      unsigned long long a5) {\n  unsigned int v0; // [bp-0x20]\n  unsigned int v1; // [bp-0x1c]\n  unsigned int v2; // [bp-0x18]\n  unsigned int v3; // [bp-0x14]\n  unsigned int v4; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v5; // [bp-0xc]\n\n  v3 = 0;\n  v2 = 0;\n  v1 = 0;\n  v0 = 0;\n  v5 = 0;\n  for (v4 = 0; v4 < (unsigned int)a1; v4 = (int)v4 + 1) {\n    switch (v5) {\n    case 0:\n      v5 = 1;\n      break;\n    case 1:\n      v3 = a0[v4];\n      v5 = 2;\n      break;\n    case 2:\n      v3 += a0[v4] * 0x100;\n      v5 = 3;\n      if (!v3)\n        v4 = a1;\n      break;\n    case 3:\n      v2 = a0[v4];\n      v5 = 4;\n      break;\n    case 4:\n      v2 += a0[v4] * 0x100;\n      info(0, \"%05x:(%04x) %5d\", v4, v3, v2, a5);\n      v1 = 0;\n      v5 = 5;\n      break;\n    case 5:\n      v1 += 1;\n      if (!a0[v4]) {\n        info(0, \" %s\\n\", detokenize(&a0[1 + v4 + -1 * v1], v1), a3, a4, a5);\n        v5 = 1;\n        v0 += 1;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_cmd(uint8_t *buff, int size) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    int bcnt = 0;\n    int i;\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 1;\n                break;\n              case 2:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 2;\n                break;\n              default:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                blen = 2;\n            }\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 3:\n            blen = buff[offs];\n            bcnt = 0;\n            state = 6;\n            info(0, \" %02x (comment length %03x)\\n\", buff[offs], blen);\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 6:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15))\n                info(0, \"\\n\");\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15))\n                    info(0, \"\\n\");\n                state = 0;\n            }\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            bcnt = 0;\n            if (blen <= 0)\n                blen += 256;\n            info(0, \" %02x (data length %03x @ %04x)\\n\", buff[offs], blen, addr);\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            bcnt = 0;\n            info(0, \" %02x (entry point %04x)\\n\", buff[offs], badr);\n            offs = size;\n            break;\n          case 9:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, addr + bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15)) {\n                info(0, \" - \");\n                for (i = -15; i <= 0; i++)\n                    info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                info(0, \"\\n\");\n            }\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15)) {\n                    info(0, \"%-*s - \", 3 * (16 - (bcnt & 15)), \"\");\n                    for (i = -(bcnt & 15); i <= 0; i++)\n                        info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                    info(0, \"\\n\");\n                }\n                state = 0;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\n\nextern unsigned long long g_40746d;\n\nlong long hexdump_cmd(char *a0, unsigned long a1, unsigned long long a2,\n                      unsigned long long a3, unsigned long long a4,\n                      unsigned long long a5) {\n  unsigned int v0;        // [bp-0x28]\n  unsigned int v1;        // [bp-0x24]\n  unsigned int v2;        // [bp-0x20]\n  unsigned int v3;        // [bp-0x1c]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v7;        // [bp-0xc]\n  unsigned int v9;        // eax\n  unsigned long v10;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v11; // rdx\n  unsigned long v12;      // rax, Other Possible Types: unsigned long long\n\n  v5 = 0;\n  v4 = 0;\n  v0 = 0;\n  v3 = 0;\n  v2 = 0;\n  v7 = 0;\n  v0 = 0;\n  for (v6 = 0; v6 < (unsigned int)a1; v6 = (int)v6 + 1) {\n    switch (v7) {\n    case 0:\n      v9 = a0[v6];\n      if (v9 == 1) {\n        info(0, \"%05x: %02x\", v6, a0[v6], a4, a5);\n        v7 = 1;\n      } else if (v9 == 2) {\n        info(0, \"%05x: %02x\", v6, a0[v6], a4, a5);\n        v7 = 2;\n      } else {\n        info(0, \"%05x: %02x\", v6, a0[v6], a4, a5);\n        v7 = 3;\n      }\n      break;\n    case 1:\n      v5 = a0[v6];\n      v7 = 4;\n      info(0, \" %02x\", a0[v6], a3, a4, a5);\n      break;\n    case 2:\n      v5 = a0[v6];\n      v7 = 5;\n      if (v5 != 2)\n        v5 = 2;\n      info(0, \" %02x\", a0[v6], a3, a4, a5);\n      break;\n    case 3:\n      v5 = a0[v6];\n      v2 = 0;\n      v7 = 6;\n      info(0, \" %02x (comment length %03x)\\n\", a0[v6], v5, a4, a5);\n      break;\n    case 4:\n      v5 -= 1;\n      v4 = a0[v6];\n      v7 = 7;\n      info(0, \" %02x\", a0[v6], a3, a4, a5);\n      break;\n    case 5:\n      v5 -= 1;\n      v3 = a0[v6];\n      v7 = 8;\n      info(0, \" %02x\", a0[v6], a3, a4, a5);\n      break;\n    case 6:\n      if (!((char)v2 & 15))\n        info(0, \"%05x:(%04x)\", v6, v2, a4, a5);\n      info(0, \" %02x\", a0[v6], a3, a4, a5);\n      v2 += 1;\n      if (!((char)v2 & 15))\n        info(0, \"\\n\", a2, a3, a4, a5);\n      v5 -= 1;\n      if (v5 <= 0) {\n        if (((char)v2 & 15))\n          info(0, \"\\n\", a2, a3, a4, a5);\n        v7 = 0;\n      }\n      break;\n    case 7:\n      v5 -= 1;\n      v4 += a0[v6] * 0x100;\n      v7 = 9;\n      v2 = 0;\n      if (v5 <= 0)\n        v5 += 0x100;\n      info(0, \" %02x (data length %03x @ %04x)\\n\", a0[v6], v5, v4, a5);\n      break;\n    case 8:\n      v5 -= 1;\n      v3 += a0[v6] * 0x100;\n      v2 = 0;\n      info(0, \" %02x (entry point %04x)\\n\", a0[v6], v3, a4, a5);\n      v6 = a1;\n      break;\n    case 9:\n      if (!((char)v2 & 15))\n        info(0, \"%05x:(%04x)\", v6, v4 + v2, a4, a5);\n      info(0, \" %02x\", a0[v6], a3, a4, a5);\n      v2 += 1;\n      if (!((char)v2 & 15)) {\n        info(0, \" - \", a2, a3, a4, a5);\n        for (v1 = -15; v1 <= 0; v1 += 1) {\n          if (a0[v6 + v1] <= 31 || a0[v6 + v1] > 126)\n            v10 = 46;\n          else\n            v10 = a0[v6 + v1];\n          info(0, \"%c\", v10, a3, a4, a5);\n        }\n        info(0, \"\\n\", a2, a3, a4, a5);\n      }\n      v5 -= 1;\n      if (v5 <= 0) {\n        if (((char)v2 & 15)) {\n          v11 = 16 - (v2 & 15);\n          a2 = (unsigned int)v11 * 2 + v11;\n          info(0, \"%-*s - \", a2, &g_40746d, a4, a5);\n          for (v1 = -(v2 & 15); v1 <= 0; v1 += 1) {\n            if (a0[v6 + v1] <= 31 || a0[v6 + v1] > 126)\n              v12 = 46;\n            else\n              v12 = a0[v6 + v1];\n            info(0, \"%c\", v12, &g_40746d, a4, a5);\n          }\n          info(0, \"\\n\", a2, &g_40746d, a4, a5);\n        }\n        v7 = 0;\n      }\n      break;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_raw(uint8_t *buff, int size) {\n    int y, x;\n    for (y = 0; y < size; y += 16) {\n        info(0, \"%05x:\", y);\n        for (x = 0; x < 16; x++)\n            info(0, \" %02x\", buff[y + x]);\n        info(0, \" - \");\n        for (x = 0; x < 16; x++)\n            info(0, \"%c\", ((buff[y + x]) < 32 || (buff[y + x]) > 126 ? '.' : (buff[y + x])));\n        info(0, \"\\n\");\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, long long, long long, long long,\n                long long);\n\nlong long hexdump_raw(char *a0, unsigned long a1, unsigned long long a2,\n                      unsigned long long a3, unsigned long long a4,\n                      unsigned long long a5) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rax, Other Possible Types: unsigned long long\n\n  v4 = &v2;\n  for (v1 = 0; v1 < (unsigned int)a1; v1 += 16) {\n    info(0, \"%05x:\", v1, a3, a4, a5);\n    for (v0 = 0; v0 <= 15; v0 += 1) {\n      info(0, \" %02x\", a0[v1 + v0], a3, a4, a5);\n    }\n    info(0, \" - \", a2, a3, a4, a5);\n    for (v0 = 0; v0 <= 15; v0 += 1) {\n      if (a0[v1 + v0] <= 31 || a0[v1 + v0] > 126)\n        v5 = 46;\n      else\n        v5 = a0[v1 + v0];\n      info(0, \"%c\", v5, a3, a4, a5);\n    }\n    info(0, \"\\n\", a2, a3, a4, a5);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"unsigned long HTcopy(char *ul) {\n    unsigned long retval;\n    memcpy(&retval, ul, sizeof (retval));\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTcopy_name_conflict(unsigned long long *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = *(a0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long SparseMemory(u_long cBuckets, u_long cOccupied) {\n    return (cOccupied * sizeof(HTItem) + ((((cBuckets) - 1) >> (0 + 6)) + 1) * sizeof(SparseBin));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SparseMemory_name_conflict(unsigned long a0, unsigned long a1) {\n  return 3 * ((a0 - 1 >> 6) + 1) * 8 + a1 * 16;\n}\n","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long DenseMemory(u_long cBuckets, u_long cOccupied) {\n    return cBuckets * sizeof(HTItem);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long DenseMemory_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a1;\n  return a0 * 16;\n}\n","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long NextPow2(u_long x) {\n    if (((x << 1) >> 1) != x)\n        x >>= 1;\n    while ((x & (x - 1)) != 0)\n        x &= (x - 1);\n    return x << 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long NextPow2_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = a0;\n  if (v0 != (9223372036854775807 & v0))\n    v0 >>= 1;\n  for (; (v0 - 1 & v0); v0 &= v0 - 1)\n    ;\n  return v0 * 2;\n}\n","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"int sendAll(SOCKET s, char *buf, int len) {\n    int total = 0;\n    int bytesleft = len;\n    int n = 0;\n    while (total < len)\n        {\n            n = send(s, buf + total, bytesleft, MSG_NOSIGNAL);\n            if (n == -1) {\n                break;\n            }\n            total += n;\n            bytesleft -= n;\n        }\n    return n == -1 ? 0 : total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\n\nlong long sendAll_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = a2;\n  for (v0 = 0; v2 < (unsigned int)a2 &&\n               (v0 = (unsigned int)(int)send((unsigned int)a0,\n                                             (unsigned long long)v2 + a1,\n                                             (unsigned long long)v1, 0x4000),\n               v0 != -1);\n       v1 -= v0) {\n    v2 += v0;\n  }\n  return (v0 == -1 ? v2 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"int sendFileArg(char *filename) {\n    int i, f;\n    if ((f = open(filename, 0)) < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    i = read(f, buf, (2048));\n    while (i > 0)\n        {\n            sendChunk(i, 'L', buf);\n            i = read(f, buf, (2048));\n        }\n    if (i < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    sendChunk(0, 'L', buf);\n    close(f);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(read)(int, void *, unsigned long);\nlong long(sendChunk)(long long, long long, long long);\nint(close)(int);\n\nextern void buf;\n\nlong long sendFileArg_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = open(a0, 0, a2);\n  if (v0 < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  for (v1 = read(v0, &buf, 0x800); v1 > 0; v1 = read(v0, &buf, 0x800)) {\n    sendChunk(v1, 76, &buf);\n  }\n  if (v1 < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  sendChunk(0, 76, &buf);\n  close(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4z20yztg/sendFileArg_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"unsigned long recvToBuffer(unsigned long len) {\n    unsigned long bytesRead = 0;\n    while (bytesRead < len)\n        {\n            int thisPass = recv(nailgunsocket, buf + bytesRead, len - bytesRead, MSG_WAITALL);\n            if (thisPass == 0 || thisPass == -1) {\n                perror(\"recv\");\n                handleSocketClose();\n            }\n            bytesRead += thisPass;\n        }\n    return bytesRead;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\nvoid(perror)(char *);\nlong long(handleSocketClose)();\n\nextern char buf;\nextern unsigned int nailgunsocket;\n\nlong long recvToBuffer_name_conflict(unsigned long a0) {\n  unsigned int v0;       // [bp-0x14]\n  void *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = 0;\n  while (true) {\n    if (v1 >= a0)\n      return v1;\n    v0 = recv(nailgunsocket, &buf + v1, a0 - v1, 0x100);\n    if (!(v0) || !(v0 != -1))\n      break;\n    v1 += v0;\n  }\n  perror(\"recv\");\n  handleSocketClose(); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2f98dkk_/recvToBuffer_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp2f98dkk_/recvToBuffer_name_conflict.c:36:39: error: invalid operands to binary\nexpression ('char *' and 'void *') 36 |         v0 = recv(nailgunsocket, &buf +\nv1, a0 - v1, 0x100); |                                  ~~~~ ^ ~~\n/tmp/tmp2f98dkk_/recvToBuffer_name_conflict.c:36:48: error: invalid operands to binary\nexpression ('unsigned long' and 'void *') 36 |         v0 = recv(nailgunsocket,\n&buf + v1, a0 - v1, 0x100); |                                             ~~ ^\n~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"int processStdin() {\n    int bytesread = read(0, buf, (2048));\n    if (bytesread > 0) {\n        sendStdin(buf, bytesread);\n    } else if (bytesread == 0) {\n        processEof();\n    }\n    return (bytesread);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(sendStdin)(long long, long long);\nlong long(processEof)();\n\nextern void buf;\n\nlong long processStdin_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = read(0, &buf, 0x800);\n  if (v0 > 0) {\n    sendStdin(&buf, v0);\n    return v0;\n  }\n  if (v0)\n    return v0;\n  processEof();\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"int intervalMillis(struct timeval end, struct timeval start) {\n    return ((end.tv_sec - start.tv_sec) * 1000) + ((end.tv_usec - start.tv_usec) / 1000);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long intervalMillis(unsigned long a0, unsigned long a1, unsigned long a2,\n                         unsigned long a3) {\n  return ((a1 - a3) * 2361183241434822607 >> 64 >> 7) - (a1 - a3 >> 63) +\n         ((unsigned int)a0 - (unsigned int)a2) * 1000;\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"char *shortClientName(char *s) {\n    char *result = strrchr(s, '/');\n    return ((result == ((void *)0)) ? s : result + 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shortClientName_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strrchr(a0, 47);\n  return (!v0 ? v0 + 1 : a0);\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int isNailgunClientName(char *s) {\n    return (!(strcmp(s, \"ng\")));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isNailgunClientName_name_conflict(char *a0) { return !strcmp(a0, \"ng\"); }\n","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"pid_t do_driver(char *driver) {\n    pid_t child;\n    int pipe[2];\n    if (socketpair(1, SOCK_STREAM, 0, pipe) < 0)\n        err_sys(\"can't create socketpair\");\n    if ((child = fork()) < 0)\n        err_sys(\"fork error\");\n    else if (child == 0) {\n        close(pipe[1]);\n        if (dup2(1, 2) != 2)\n            err_sys(\"dup2 error to sterr\");\n        if (dup2(pipe[0], 0) != 0)\n            err_sys(\"dup2 error to stdin\");\n        if (dup2(pipe[0], 1) != 1)\n            err_sys(\"dup2 error to stdout\");\n        close(pipe[0]);\n        execlp(driver, driver, (char *)0);\n        err_sys(\"execlp error for: %s\", driver);\n    }\n    close(pipe[0]);\n    if (dup2(pipe[1], 0) != 0)\n        err_sys(\"dup2 error to stdin\");\n    if (dup2(pipe[1], 1) != 1)\n        err_sys(\"dup2 error to stdout\");\n    close(pipe[1]);\n    return child;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socketpair)(int, int, int, int(32 bits)[2]);\nlong long(err_sys)(...);\nint(fork)();\nint(close)(int);\nint(dup2)(int, int);\n\nlong long do_driver_name_conflict(char *a0) {\n  char v0;         // [bp-0x14]\n  char v1;         // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  if (socketpair(1, 1, 0, &v0) < 0)\n    err_sys(); /* do not return */\n  v2 = fork();\n  if (v2 < 0) {\n    err_sys(); /* do not return */\n  } else if (v2) {\n    close(*((int *)&v0));\n    if (dup2(*((int *)&v1), 0)) {\n      err_sys(); /* do not return */\n    } else if (dup2(*((int *)&v1), 1) != 1) {\n      err_sys(); /* do not return */\n    } else {\n      close(*((int *)&v1));\n      return v2;\n    }\n  } else {\n    close(*((int *)&v1));\n    if (dup2(1, 2) != 2) {\n      err_sys(); /* do not return */\n    } else if (dup2(*((int *)&v0), 0)) {\n      err_sys(); /* do not return */\n    } else if (dup2(*((int *)&v0), 1) != 1) {\n      err_sys(); /* do not return */\n    } else {\n      close(*((int *)&v0));\n      execlp(a0, a0);\n      err_sys(); /* do not return */\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjxzp7iid/do_driver_name_conflict.c:16:38: error: expected ')'\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                      ^\n/tmp/tmpjxzp7iid/do_driver_name_conflict.c:16:37: note: to match this '('\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                     ^\n/tmp/tmpjxzp7iid/do_driver_name_conflict.c:17:21: error: ISO C requires a named parameter\nbefore '...' 17 | long long (err_sys)(...); |                     ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/driver.c"}
{"compilable":0,"function":"int tty_cbreak(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = CBREAK;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern unsigned long long g_405188;\nextern unsigned long long g_405190;\nextern unsigned long long g_405198;\nextern unsigned long long g_4051a0;\nextern unsigned long long g_4051a8;\nextern unsigned long long g_4051ac;\nextern unsigned long long g_4051b4;\nextern termios save_termios;\nextern unsigned int ttysavefd;\nextern unsigned int ttystate;\n\nlong long tty_cbreak_name_conflict(unsigned long a0) {\n  char v0;           // [bp-0x4c]\n  termios v1;        // [bp-0x48]\n  unsigned long v2;  // [bp-0x40]\n  unsigned int v3;   // [bp-0x3c]\n  unsigned long v4;  // [bp-0x38]\n  char v5;           // [bp-0x32]\n  char v6;           // [bp-0x31]\n  unsigned long v7;  // [bp-0x30]\n  unsigned long v8;  // [bp-0x28]\n  unsigned long v9;  // [bp-0x20]\n  unsigned long v10; // [bp-0x1c]\n  unsigned long v11; // [bp-0x14]\n\n  if (tcgetattr(a0, &save_termios.c_iflag) < 0)\n    return 4294967295;\n  *((long long *)&v1.c_iflag) = *((long long *)&save_termios.c_iflag);\n  v2 = g_405188;\n  v4 = g_405190;\n  v7 = g_405198;\n  v8 = g_4051a0;\n  v9 = g_4051a8;\n  v10 = g_4051ac;\n  v11 = g_4051b4;\n  v3 = *((int *)((char *)&v2 + 4)) & -11;\n  v6 = 1;\n  v5 = 0;\n  if (tcsetattr(*((int *)&v0), 2, &v1) < 0)\n    return 4294967295;\n  ttystate = 2;\n  ttysavefd = *((int *)&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"int tty_raw(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2 | 32768 | 1);\n    buf.c_iflag &= ~(2 | 256 | 16 | 32 | 1024);\n    buf.c_cflag &= ~(48 | 256);\n    buf.c_cflag |= 48;\n    buf.c_oflag &= ~(1);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = RAW;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern unsigned long long g_405188;\nextern unsigned long long g_405190;\nextern unsigned long long g_405198;\nextern unsigned long long g_4051a0;\nextern unsigned long long g_4051a8;\nextern unsigned long long g_4051ac;\nextern unsigned long long g_4051b4;\nextern termios save_termios;\nextern unsigned int ttysavefd;\nextern unsigned int ttystate;\n\nlong long tty_raw_name_conflict(unsigned long a0) {\n  char v0;           // [bp-0x4c]\n  termios v1;        // [bp-0x48], Other Possible Types: unsigned int\n  unsigned int v2;   // [bp-0x44]\n  unsigned int v3;   // [bp-0x40], Other Possible Types: unsigned long\n  unsigned int v4;   // [bp-0x3c]\n  unsigned long v5;  // [bp-0x38]\n  char v6;           // [bp-0x32]\n  char v7;           // [bp-0x31]\n  unsigned long v8;  // [bp-0x30]\n  unsigned long v9;  // [bp-0x28]\n  unsigned long v10; // [bp-0x20]\n  unsigned long v11; // [bp-0x1c]\n  unsigned long v12; // [bp-0x14]\n\n  if (tcgetattr(a0, &save_termios.c_iflag) < 0)\n    return 4294967295;\n  *((long long *)&v1.c_iflag) = *((long long *)&save_termios.c_iflag);\n  v3 = g_405188;\n  v5 = g_405190;\n  v8 = g_405198;\n  v9 = g_4051a0;\n  v10 = g_4051a8;\n  v11 = g_4051ac;\n  v12 = g_4051b4;\n  v4 = *((int *)((char *)&v3 + 4)) & -32780;\n  v1 = v1.c_iflag & -1331;\n  v3 = (int)v3 & -305;\n  v3 |= 48;\n  *((char[4]) & v2) = v1.padding_4 & -2;\n  v7 = 1;\n  v6 = 0;\n  if (tcsetattr(*((int *)&v0), 2, &v1) < 0)\n    return 4294967295;\n  ttystate = 1;\n  ttysavefd = *((int *)&v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp22tpg5ze/tty_raw_name_conflict.c:89:8: error: assigning to 'termios' (aka 'struct\ntermios') from incompatible type 'unsigned int' 89 |     v1 = v1.c_iflag &\n-1331; |        ^ ~~~~~~~~~~~~~~~~~~ /tmp/tmp22tpg5ze/tty_raw_name_conflict.c:92:7: error:\nused type 'char[4]' where arithmetic or pointer type is required 92 | *((char\n[4])&v2) = v1.padding_4 & -2; |       ^         ~~~\n/tmp/tmp22tpg5ze/tty_raw_name_conflict.c:92:37: error: invalid operands to binary expression\n('char[4]' and 'int') 92 |     *((char [4])&v2) = v1.padding_4 & -2; |\n~~~~~~~~~~~~ ^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"int tty_reset(int fd) {\n    if (ttystate != CBREAK && ttystate != RAW)\n        return (0);\n    if (tcsetattr(fd, 2, &save_termios) < 0)\n        return (-1);\n    ttystate = RESET;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\nextern termios save_termios;\nextern unsigned int ttystate;\n\nlong long tty_reset_name_conflict(unsigned long a0) {\n  if (ttystate != 2 && ttystate != 1)\n    return 0;\n  if (tcsetattr(a0, 2, &save_termios.c_iflag) < 0)\n    return 4294967295;\n  ttystate = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcsllve_y/tty_reset_name_conflict.c:26:8: error: unknown type name 'termios'\n   26 | extern termios save_termios;\n      |        ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"struct termios *tty_termios(void) {\n    return (&save_termios);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char save_termios;\n\nlong long tty_termios_name_conflict() { return &save_termios; }\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long func1_name_conflict() { return 42; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/exclusion/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hello2_name_conflict() {\n  puts(\"Hello, two!\");\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int asm_function() {\n    return 41;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long asm_function_name_conflict() { return 41; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/rules/src/subdir4/program.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long func1_name_conflict() { return 42; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/product/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hello2_name_conflict() {\n  puts(\"Hello, two!\");\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int funcB() {\n    return 3;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long funcB_name_conflict() { return 3; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/b/b3.c"}
{"compilable":0,"function":"int funcA() {\n    return funcB();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(funcB)();\n\nlong long funcA_name_conflict() { return funcB(); }\n","pass":0,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/a.c"}
{"compilable":0,"function":"char *create_pkt(char *ip) {\n    char *ptr;\n    char *adr;\n    char *token;\n    int fd;\n    int arp_proto = htons(2054);\n    int hw_tp = htons(1);\n    int pro_type = htons(2048);\n    int hw_size = 6;\n    int pr_size = 4;\n    int opcode = htons(1);\n    int i;\n    unsigned char seq;\n    struct ifreq buffer;\n    struct sockaddr_in *ipadd;\n    ptr = malloc(sizeof(char[44]));\n    memset(ptr, 0, sizeof(char[44]));\n    fd = socket(2, SOCK_DGRAM, IPPROTO_IP);\n    memset(&buffer, 0, sizeof (buffer));\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    ioctl(fd, 35111, &buffer);\n    close(fd);\n    memcpy(ptr, \"\\377\\377\\377\\377\\377\\377\", 6);\n    memcpy(ptr + 6, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memcpy(ptr + (2 * 6), &arp_proto, 2);\n    memcpy(ptr + 14, &hw_tp, 2);\n    memcpy(ptr + 14 + 2, &pro_type, 2);\n    memcpy(ptr + 14 + 4, &hw_size, 1);\n    memcpy(ptr + 14 + 5, &pr_size, 1);\n    memcpy(ptr + 14 + 6, &opcode, 2);\n    memcpy(ptr + 14 + 8, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memset(&buffer, 0, sizeof buffer);\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    fd = socket(2, SOCK_DGRAM, 0);\n    if (ioctl(fd, 35093, &buffer) == -1)\n        printf(\"ioctl ip checking error\\n\");\n    close(fd);\n    ipadd = (struct sockaddr_in *)&(buffer.ifr_ifru.ifru_addr);\n    adr = inet_ntoa(ipadd->sin_addr);\n    printf(\"alamat ipmu adalah : %s\\n\", adr);\n    token = strtok(adr, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + 6 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    i = 0;\n    token = strtok(ip, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + (2 * 6) + 4 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    return ptr;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(socket)(int, int, int);\nint(close)(int);\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nchar *(strtok)(char *, char *);\nint(atoi)(char *);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[11];\n  unsigned short field_c;\n  unsigned short field_e;\n  unsigned short field_10;\n  char field_12;\n  char field_13;\n  unsigned short field_14;\n} struct_0;\n\nextern void g_402008;\n\nlong long create_pkt(char *a0) {\n  char v0;                // [bp-0x88]\n  unsigned short v1;      // [bp-0x84]\n  char v2;                // [bp-0x78]\n  char v3;                // [bp-0x76]\n  char v4;                // [bp-0x51]\n  unsigned int v5;        // [bp-0x50]\n  unsigned int v6;        // [bp-0x4c]\n  unsigned int v7;        // [bp-0x48]\n  unsigned int v8;        // [bp-0x44]\n  unsigned int v9;        // [bp-0x40]\n  unsigned int v10;       // [bp-0x3c]\n  char *v11;              // [bp-0x38]\n  unsigned long v12;      // [bp-0x30]\n  unsigned int v13;       // [bp-0x24]\n  struct_0 *v14;          // [bp-0x20]\n  unsigned int v15;       // [bp-0x14]\n  char *v16;              // [bp-0x10], Other Possible Types: unsigned long\n  char v17;               // [bp-0x8]\n  unsigned long long v19; // rbp\n  unsigned int v24;       // esi\n  unsigned int v25;       // esi\n\n  v19 = &v17;\n  v10 = htons(2054);\n  v9 = htons(1);\n  v8 = htons(0x800);\n  v7 = 6;\n  v6 = 4;\n  v5 = htons(1);\n  v14 = malloc(44);\n  memset(v14, 0, 44);\n  v13 = socket(2, 2, 0);\n  v24 = 0;\n  memset(&v0, 0, 40);\n  strncpy(&v0, \"wlan\", 4);\n  v1 = 48;\n  ioctl(v13, 35111);\n  close(v13);\n  memcpy(v14, &g_402008, 6);\n  memcpy(&v14->padding_1[5], &v3, 6);\n  v14->field_c = v10;\n  v14->field_e = v9;\n  v14->field_10 = v8;\n  v14->field_12 = v7;\n  v14->field_13 = v6;\n  v14->field_14 = v5;\n  memcpy(v14 + 1, &v3, 6);\n  v25 = 0;\n  memset(&v0, 0, 40);\n  strncpy(&v0, \"wlan\", 4);\n  v1 = 48;\n  v13 = socket(2, 2, 0);\n  if (ioctl(v13, 35093) == -1)\n    puts(\"ioctl ip checking error\");\n  close(v13);\n  v12 = &v2;\n  v11 = inet_ntoa();\n  printf(\"alamat ipmu adalah : %s\\n\", (unsigned int)v11);\n  for (v16 = strtok(v11, \".\"); v16; v15 += 1) {\n    v4 = atoi(v16);\n    v14[1].padding_1[5 + v15] = v4;\n    v16 = strtok(NULL, \".\");\n  }\n  v15 = 0;\n  for (v16 = strtok(a0, \".\"); v16; v15 += 1) {\n    v4 = atoi(v16);\n    *(&(&v14->field_0)[v15 + 38]) = v4;\n    v16 = strtok(NULL, \".\");\n  }\n  return v14;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzgdkuzh8/create_pkt.c:96:21: error: too few arguments to function call,\nexpected 1, have 0 96 |     v11 = inet_ntoa(); |           ~~~~~~~~~ ^\n/tmp/tmpzgdkuzh8/create_pkt.c:19:8: note: 'inet_ntoa' declared here\n   19 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int are_equal(const unsigned char *str1, const unsigned char *str2, int len) {\n    int i;\n    for (i = 0; i < len; i++) {\n        if (!(*(str1 + i) & *(str2 + i)))\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long are_equal_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 < (unsigned int)a2; v0 += 1) {\n    if (!(char)(a1[v0] & a0[v0]))\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int create_socket() {\n    int fd;\n    fd = socket(17, SOCK_RAW, htons(2054));\n    if (fd == -1)\n        printf(\"socket error\\n\");\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(socket)(int, int, int);\n\nlong long create_socket_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = socket(17, 3, htons(2054));\n  if (v0 == -1) {\n    puts(\"socket error\");\n    return v0;\n  }\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"int examine_addr(char *addr) {\n    char *ex;\n    char sec_addr[3];\n    char *token;\n    unsigned int tes;\n    int chk_ip = 0;\n    ex = strchr(addr, ' ');\n    if (ex != ((void *)0)) {\n        printf(\"alamat yang di masukkan salah, mohon jangan ada spasi\\n\");\n        return 0;\n    }\n    token = strtok(addr, \".\");\n    while (token != ((void *)0))\n        {\n            chk_ip++;\n            tes = atoi(token);\n            if (tes > 255) {\n                printf(\"alamat ip tidak ada yang lebih dari 255\\n\");\n                return 0;\n            }\n            token = strtok(((void *)0), \".\");\n        }\n    if (chk_ip != 4) {\n        printf(\"alamat tidak valid\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok)(char *, char *);\nint(atoi)(char *);\n\nlong long examine_addr_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0x24]\n  unsigned long v1; // [bp-0x20]\n  unsigned int v2;  // [bp-0x14]\n  char *v3;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v2 = 0;\n  v1 = strchr(a0, 32);\n  if (v1) {\n    puts(\"alamat yang di masukkan salah, mohon jangan ada spasi\");\n    return 0;\n  }\n  for (v3 = strtok(a0, \".\"); v3; v3 = strtok(NULL, \".\")) {\n    v2 += 1;\n    v0 = atoi(v3);\n    if (v0 > 255) {\n      puts(\"alamat ip tidak ada yang lebih dari 255\");\n      return 0;\n    }\n  }\n  if (v2 == 4)\n    return 1;\n  puts(\"alamat tidak valid\");\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"static int make_user_test(void) {\n    struct user *user = psylbm_make_user();\n    psylbm_free_user(user);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(psylbm_make_user)();\nlong long(psylbm_free_user)(long long);\n\nlong long make_user_test_name_conflict() {\n  unsigned long long v0; // [bp-0x10]\n\n  v0 = psylbm_make_user();\n  psylbm_free_user(v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int make_bookmark_test(void) {\n    struct bookmark *bookmark = psylbm_make_bookmark();\n    psylbm_free_bookmark(bookmark);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(psylbm_make_bookmark)();\nlong long(psylbm_free_bookmark)(long long);\n\nlong long make_bookmark_test_name_conflict() {\n  unsigned long long v0; // [bp-0x10]\n\n  v0 = psylbm_make_bookmark();\n  psylbm_free_bookmark(v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int parse_insert_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_INSERT;\n    const char *curr = &buffer[4];\n    {\n        char *dst = &message->message.insert.name[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.title[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.volume_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.chapter_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.page_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.token[0];\n        while (*curr != 0 && *curr != '|')\n            *(dst++) = *(curr++);\n    }\n    if (*curr != 0) {\n        curr++;\n        char *dst = &message->message.insert.book_id_str[0];\n        while (*curr != 0)\n            *(dst++) = *(curr++);\n    }\n    message->message.insert.volume = atoi(message->message.insert.volume_str);\n    message->message.insert.chapter = atoi(message->message.insert.chapter_str);\n    message->message.insert.page = atoi(message->message.insert.page_str);\n    message->message.insert.book_id = atoi(message->message.insert.book_id_str);\n    return 0;\n  error:\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(atoi)(char *);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[1795];\n  unsigned int field_704;\n  unsigned int field_708;\n  unsigned int field_70c;\n  unsigned int field_710;\n} struct_0;\n\nlong long parse_insert_message_name_conflict(unsigned long a0, struct_0 *a1) {\n  char *v0;  // [bp-0x48], Other Possible Types: unsigned long\n  char *v1;  // [bp-0x40], Other Possible Types: unsigned long\n  char *v2;  // [bp-0x38], Other Possible Types: unsigned long\n  char *v3;  // [bp-0x30], Other Possible Types: unsigned long\n  char *v4;  // [bp-0x28], Other Possible Types: unsigned long\n  char *v5;  // [bp-0x20], Other Possible Types: unsigned long\n  char *v6;  // [bp-0x18], Other Possible Types: unsigned long\n  char *v7;  // [bp-0x10], Other Possible Types: unsigned long\n  char *v9;  // rdx\n  char *v10; // rax\n  char *v11; // rdx\n  char *v12; // rax\n  char *v13; // rdx\n  char *v14; // rax\n  char *v15; // rdx\n  char *v16; // rax\n  char *v17; // rdx\n  char *v18; // rax\n  char *v20; // rdx\n  char *v21; // rax\n  char *v22; // rdx\n  char *v23; // rax\n\n  a1->field_0 = 1;\n  v7 = a0 + 4;\n  for (v6 = &a1->padding_1[7]; *(v7) != 124; *(v10) = *(v9)) {\n    v9 = v7;\n    v7 = v9 + 1;\n    v10 = v6;\n    v6 = v10 + 1;\n  }\n  v7 += 1;\n  if (!*(v7))\n    return 1;\n  for (v5 = &a1->padding_1[262]; *(v7) != 124; *(v12) = *(v11)) {\n    v11 = v7;\n    v7 = v11 + 1;\n    v12 = v5;\n    v5 = v12 + 1;\n  }\n  v7 += 1;\n  if (*(v7)) {\n    for (v4 = &a1->padding_1[517]; *(v7) != 124; *(v14) = *(v13)) {\n      v13 = v7;\n      v7 = v13 + 1;\n      v14 = v4;\n      v4 = v14 + 1;\n    }\n    v7 += 1;\n    if (*(v7)) {\n      for (v3 = &a1->padding_1[772]; *(v7) != 124; *(v16) = *(v15)) {\n        v15 = v7;\n        v7 = v15 + 1;\n        v16 = v3;\n        v3 = v16 + 1;\n      }\n      v7 += 1;\n      if (*(v7)) {\n        for (v2 = &a1->padding_1[1027]; *(v7) != 124; *(v18) = *(v17)) {\n          v17 = v7;\n          v7 = v17 + 1;\n          v18 = v2;\n          v2 = v18 + 1;\n        }\n        v7 += 1;\n        if (*(v7)) {\n          for (v1 = &a1->padding_1[1282]; *(v7) && *(v7) != 124;\n               *(v21) = *(v20)) {\n            v20 = v7;\n            v7 = v20 + 1;\n            v21 = v1;\n            v1 = v21 + 1;\n          }\n          if (*(v7)) {\n            v7 += 1;\n            for (v0 = &a1->padding_1[1537]; *(v7); *(v23) = *(v22)) {\n              v22 = v7;\n              v7 = v22 + 1;\n              v23 = v0;\n              v0 = v23 + 1;\n            }\n          }\n          a1->field_704 = atoi(&a1->padding_1[517]);\n          a1->field_708 = atoi(&a1->padding_1[772]);\n          a1->field_70c = atoi(&a1->padding_1[1027]);\n          a1->field_710 = atoi(&a1->padding_1[1537]);\n          return 0;\n        }\n      }\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_auth_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_AUTH;\n    const char *curr = &buffer[5];\n    char *username = &message->message.auth.username[0];\n    while (*curr != '|')\n        *(username++) = *(curr++);\n    curr++;\n    char *password = &message->message.auth.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_auth_message_name_conflict(unsigned long a0, char *a1) {\n  char *v0; // [bp-0x20], Other Possible Types: unsigned long\n  char *v1; // [bp-0x18], Other Possible Types: unsigned long\n  char *v2; // [bp-0x10], Other Possible Types: unsigned long\n  char *v4; // rdx\n  char *v5; // rax\n  char *v6; // rdx\n  char *v7; // rax\n\n  *(a1) = 0;\n  v2 = a0 + 5;\n  for (v1 = a1 + 8; *(v2) != 124; *(v5) = *(v4)) {\n    v4 = v2;\n    v2 = v4 + 1;\n    v5 = v1;\n    v1 = v5 + 1;\n  }\n  v2 += 1;\n  for (v0 = a1 + 59; *(v2); *(v7) = *(v6)) {\n    v6 = v2;\n    v2 = v6 + 1;\n    v7 = v0;\n    v0 = v7 + 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_register_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_REGISTER;\n    struct received_message recv_mess = {0};\n    const size_t max_username_len = sizeof (recv_mess.message.regist.username) - 1;\n    const char *curr = &buffer[4];\n    char *username = &message->message.regist.username[0];\n    size_t count = 0;\n    while (*curr != '|')\n        {\n            if (count == max_username_len)\n                break;\n            *(username++) = *(curr++);\n            count++;\n        }\n    curr++;\n    char *password = &message->message.regist.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_register_message_name_conflict(unsigned long a0, char *a1) {\n  unsigned long v0;       // [bp-0x760]\n  char v1;                // [bp-0x758]\n  unsigned long long v2;  // [bp-0x30]\n  char *v3;               // [bp-0x28], Other Possible Types: unsigned long\n  void *v4;               // [bp-0x20], Other Possible Types: unsigned long\n  char *v5;               // [bp-0x18], Other Possible Types: unsigned long\n  char *v6;               // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long v8;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v9; // rdi, Other Possible Types: unsigned long\n  unsigned long v10;      // d\n  char *v11;              // rdx\n  char *v12;              // rax\n  char *v13;              // rdx\n  char *v14;              // rax\n\n  v0 = a0;\n  *(a1) = 2;\n  v8 = 228;\n  for (v9 = &v1; v8; v9 += v10 * 8) {\n    v8 -= 1;\n    *((long long *)v9) = 0;\n  }\n  v2 = 254;\n  v6 = v0 + 4;\n  v5 = a1 + 8;\n  for (v4 = 0; *(v6) != 124 && v4 != v2; v4 += 1) {\n    v11 = v6;\n    v6 = v11 + 1;\n    v12 = v5;\n    v5 = v12 + 1;\n    *(v12) = *(v11);\n  }\n  v6 += 1;\n  for (v3 = a1 + 263; *((char *)v6); *(v14) = *(v13)) {\n    v13 = v6;\n    v6 = v13 + 1;\n    v14 = v3;\n    v3 = v14 + 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_delete_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_DELETE;\n    const char *curr = &buffer[4];\n    char *bookmark_id_str = &message->message.delete.bookmark_id_str[0];\n    while (*curr != '|')\n        *(bookmark_id_str++) = *(curr++);\n    curr++;\n    char *token = &message->message.delete.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    message->message.delete.bookmark_id = atoi(message->message.delete.bookmark_id_str);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(atoi)(char *);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[519];\n  unsigned long long field_208;\n} struct_0;\n\nlong long parse_delete_message_name_conflict(unsigned long a0, struct_0 *a1) {\n  char *v0; // [bp-0x20], Other Possible Types: unsigned long\n  char *v1; // [bp-0x18], Other Possible Types: unsigned long\n  char *v2; // [bp-0x10], Other Possible Types: unsigned long\n  char *v4; // rdx\n  char *v5; // rax\n  char *v6; // rdx\n  char *v7; // rax\n\n  a1->field_0 = 3;\n  v2 = a0 + 4;\n  for (v1 = &a1->padding_1[262]; *(v2) != 124; *(v5) = *(v4)) {\n    v4 = v2;\n    v2 = v4 + 1;\n    v5 = v1;\n    v1 = v5 + 1;\n  }\n  v2 += 1;\n  for (v0 = &a1->padding_1[7]; *(v2); *(v7) = *(v6)) {\n    v6 = v2;\n    v2 = v6 + 1;\n    v7 = v0;\n    v0 = v7 + 1;\n  }\n  a1->field_208 = atoi(&a1->padding_1[262]);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_purge_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_PURGE;\n    const char *curr = &buffer[6];\n    char *token = &message->message.purge.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_purge_message_name_conflict(unsigned long a0, char *a1) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n  char *v3; // rdx\n  char *v4; // rax\n\n  *(a1) = 4;\n  v1 = a0 + 6;\n  for (v0 = a1 + 8; *(v1); *(v4) = *(v3)) {\n    v3 = v1;\n    v1 = v3 + 1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_sync_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNC;\n    const char *curr = &buffer[5];\n    char *token = &message->message.sync.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_sync_message_name_conflict(unsigned long a0, char *a1) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n  char *v3; // rdx\n  char *v4; // rax\n\n  *(a1) = 5;\n  v1 = a0 + 5;\n  for (v0 = a1 + 8; *(v1); *(v4) = *(v3)) {\n    v3 = v1;\n    v1 = v3 + 1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_syncdata_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNCDATA;\n    const char *curr = &buffer[9];\n    char *token = &message->message.syncdata.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_syncdata_message_name_conflict(unsigned long a0, char *a1) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n  char *v3; // rdx\n  char *v4; // rax\n\n  *(a1) = 6;\n  v1 = a0 + 9;\n  for (v0 = a1 + 8; *(v1); *(v4) = *(v3)) {\n    v3 = v1;\n    v1 = v3 + 1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"char *psylbm_strndup(const unsigned char *src, size_t len) {\n    const size_t c_str_len = len + 1;\n    char *ret = calloc(1, sizeof(char) * c_str_len);\n    memcpy(ret, src, len);\n    ret[len] = 0;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long psylbm_strndup_name_conflict(void *a0, char *a1) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0x10]\n\n  *((char **)&v1) = a1 + 1;\n  v0 = calloc(1, *((long long *)&v1));\n  memcpy(v0, a0, a1);\n  a1[v0] = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/common.c"}
{"compilable":0,"function":"char *get_executable() {\n    char buffer[4096];\n    snprintf(buffer, 4096, \"/proc/%u/exe\", getpid());\n    char *filename = malloc(4096);\n    ssize_t len = readlink(buffer, filename, 4096);\n    if (len == -1) {\n        fprintf(stderr, \"Can't get executable name from %s - %s\\n\", buffer, strerror((*__errno_location())));\n        exit(-1);\n    } else if (len >= 4096) {\n        fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\", 4096, filename, 4096);\n        exit(-1);\n    }\n    filename[len] = '\\x00';\n    return filename;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nlong(readlink)(char *, char *, unsigned long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_executable_name_conflict() {\n  char v0;               // [bp-0x1018]\n  unsigned long v1;      // [bp-0x18]\n  char *v2;              // [bp-0x10]\n  unsigned long long v5; // rax\n\n  snprintf(&v0, 0x1000, \"/proc/%u/exe\", getpid());\n  v2 = malloc(0x1000);\n  v1 = readlink(&v0, v2, 0x1000);\n  if (v1 == -1) {\n    (unsigned int)v5 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"Can't get executable name from %s - %s\\n\",\n            (unsigned int)&v0, (unsigned int)v5);\n    exit(-1); /* do not return */\n  } else if (v1 <= 4095) {\n    v2[v1] = 0;\n    return v2;\n  } else {\n    fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\",\n            0x1000, (unsigned int)v2);\n    exit(-1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 20 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:21:22: error: expected ';' after top level\ndeclarator 21 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:35:37: error: indirection requires pointer\noperand ('int' invalid) 35 |         (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:36:23: error: expected ')'\n   36 |         fprintf(stderr@GLIBC_2.2.5, \"Can't get executable name from %s -\n%s\\n\", (unsigned int)&v0, (unsigned int)v5); |                       ^\n/tmp/tmp64ktuiw8/get_executable_name_conflict.c:36:16: note: to match this '('\n   36 |         fprintf(stderr@GLIBC_2.2.5, \"Can't get executable name from %s -\n%s\\n\", (unsigned int)&v0, (unsigned int)v5); |                ^ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int check_taskcontroller_permissions(char *executable_file) {\n    (*__errno_location()) = 0;\n    char *resolved_path = realpath(executable_file, ((void *)0));\n    if (resolved_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Error resolving the canonical name for the executable : %s!\", strerror((*__errno_location())));\n        return -1;\n    }\n    struct stat filestat;\n    (*__errno_location()) = 0;\n    if (stat(resolved_path, &filestat) != 0) {\n        fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\", strerror((*__errno_location())));\n        return -1;\n    }\n    uid_t binary_euid = filestat.st_uid;\n    gid_t binary_gid = filestat.st_gid;\n    if (binary_euid != 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be user-owned by root.\\n\");\n        return -1;\n    }\n    if (binary_gid != getgid()) {\n        fprintf(LOGFILE, \"The configured tasktracker group %d is different from the group of the executable %d\\n\", getgid(), binary_gid);\n        return -1;\n    }\n    if ((filestat.st_mode & ((256 >> 3) >> 3)) == ((256 >> 3) >> 3) || (filestat.st_mode & ((128 >> 3) >> 3)) == ((128 >> 3) >> 3) || (filestat.st_mode & ((64 >> 3) >> 3)) == ((64 >> 3) >> 3)) {\n        fprintf(LOGFILE, \"The task-controller binary should not have read or write or execute for others.\\n\");\n        return -1;\n    }\n    if ((filestat.st_mode & 2048) == 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be set setuid.\\n\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(realpath)(char *, char *);\nchar *(strerror)(int);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nunsigned int(getgid)();\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern FILE_t *LOGFILE;\n\nlong long check_taskcontroller_permissions_name_conflict(char *a0) {\n  stat v0;                // [bp-0xa8]\n  char v1;                // [bp-0x90]\n  char v2;                // [bp-0x8c]\n  char v3;                // [bp-0x88]\n  unsigned int v4;        // [bp-0x18]\n  unsigned int v5;        // [bp-0x14]\n  char *v6;               // [bp-0x10]\n  unsigned long long v9;  // rax\n  unsigned long long v11; // rax\n\n  *(__errno_location()) = 0;\n  v6 = realpath(a0, NULL);\n  if (!v6) {\n    (unsigned int)v9 = strerror(*(__errno_location()));\n    fprintf(LOGFILE,\n            \"Error resolving the canonical name for the executable : %s!\",\n            (unsigned int)v9);\n    return 4294967295;\n  }\n  *(__errno_location()) = 0;\n  if (stat(v6, &v0)) {\n    (unsigned int)v11 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\",\n            (unsigned int)v11);\n    return 4294967295;\n  }\n  v5 = *((int *)&v2);\n  v4 = *((int *)&v3);\n  if (v5) {\n    fwrite(\"The task-controller binary should be user-owned by root.\\n\", 1, 57,\n           LOGFILE);\n    return 4294967295;\n  } else if (v4 != getgid()) {\n    fprintf(LOGFILE,\n            \"The configured tasktracker group %d is different from the group \"\n            \"of the executable %d\\n\",\n            getgid(), v4);\n    return 4294967295;\n  } else {\n    if (!((char)*((int *)&v1) & 4) && !((char)*((int *)&v1) & 2) &&\n        !((char)*((int *)&v1) & 1)) {\n      if (!((short)*((int *)&v1) & 0x800)) {\n        fwrite(\"The task-controller binary should be set setuid.\\n\", 1, 49,\n               LOGFILE);\n        return 4294967295;\n      }\n      return 0;\n    }\n    fwrite(\"The task-controller binary should not have read or write or \"\n           \"execute for others.\\n\",\n           1, 80, LOGFILE);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:50:3: error: redefinition of\n'stat' as different kind of symbol 50 | } stat; |   ^\n/tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:18:6: note: previous\ndefinition is here 18 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:52:8: error: unknown type\nname 'FILE_t'; did you mean 'FILE'? 52 | extern FILE_t *LOGFILE; |        ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:56:5: error: must use\n'struct' tag to refer to type 'stat' 56 |     stat v0;  // [bp-0xa8] |     ^ |\nstruct /tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:18:6: note: struct\n'stat' is hidden by a non-type declaration of 'stat' here 18 | int (stat)(char\n*, struct stat { |      ^\n/tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:66:5: error: indirection\nrequires pointer operand ('int' invalid) 66 |     *(__errno_location()) = 0; |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:70:37:\nerror: indirection requires pointer operand ('int' invalid) 70 | (unsigned\nint)v9 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:74:5: error: indirection\nrequires pointer operand ('int' invalid) 74 |     *(__errno_location()) = 0; |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpt70wos1n/check_taskcontroller_permissions_name_conflict.c:77:38:\nerror: indirection requires pointer operand ('int' invalid) 77 | (unsigned\nint)v11 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 7 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_effective_user(uid_t user, gid_t group) {\n    if (geteuid() == user) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        return -1;\n    }\n    if (setegid(group) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", group, strerror((*__errno_location())));\n        return -1;\n    }\n    if (seteuid(user) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", user, strerror((*__errno_location())));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nint(seteuid)(unsigned int);\nint(setegid)(unsigned int);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\n\nlong long change_effective_user_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v3; // rax\n  unsigned long long v5; // rax\n\n  if ((unsigned int)a0 == geteuid()) {\n    return 0;\n  } else if (seteuid(0)) {\n    return 4294967295;\n  } else if (setegid(a1)) {\n    (unsigned int)v3 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\",\n            (unsigned int)a1, (unsigned int)v3);\n    return 4294967295;\n  } else if (seteuid(a0)) {\n    (unsigned int)v5 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\",\n            (unsigned int)a0, (unsigned int)v5);\n    return 4294967295;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgbbvisy6/change_effective_user_name_conflict.c:21:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpgbbvisy6/change_effective_user_name_conflict.c:38:37: error: indirection requires\npointer operand ('int' invalid) 38 |         (unsigned int)v3 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgbbvisy6/change_effective_user_name_conflict.c:44:37: error: indirection requires\npointer operand ('int' invalid) 44 |         (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int change_user(uid_t user, gid_t group) {\n    if (user == getuid() && user == geteuid() && group == getgid() && group == getegid()) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        fprintf(LOGFILE, \"unable to reacquire root - %s\\n\", strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setgid(group) != 0) {\n        fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", group, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setuid(user) != 0) {\n        fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", user, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(getuid)();\nunsigned int(geteuid)();\nint(seteuid)(unsigned int);\nunsigned int(getgid)();\nint(setgid)(unsigned int);\nchar *(strerror)(int);\nunsigned int(getegid)();\nint(setuid)(unsigned int);\n\nextern FILE_t *LOGFILE;\n\nlong long change_user_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v3; // rax\n  unsigned long long v5; // rax\n  unsigned long long v7; // rax\n\n  if ((unsigned int)a0 == getuid() && (unsigned int)a0 == geteuid() &&\n      (unsigned int)a1 == getgid() && (unsigned int)a1 == getegid())\n    return 0;\n  if (seteuid(0)) {\n    (unsigned int)v3 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"unable to reacquire root - %s\\n\", (unsigned int)v3);\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  } else if (setgid(a1)) {\n    (unsigned int)v5 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", (unsigned int)a1,\n            (unsigned int)v5);\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  } else if (setuid(a0)) {\n    (unsigned int)v7 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", (unsigned int)a0,\n            (unsigned int)v7);\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpweksu8st/change_user_name_conflict.c:25:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 25 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpweksu8st/change_user_name_conflict.c:37:37: error: indirection requires pointer\noperand ('int' invalid) 37 |         (unsigned int)v3 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpweksu8st/change_user_name_conflict.c:44:37: error: indirection requires pointer\noperand ('int' invalid) 44 |         (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpweksu8st/change_user_name_conflict.c:51:37: error: indirection requires pointer\noperand ('int' invalid) 51 |         (unsigned int)v7 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char **get_mapred_local_dirs(const char *good_local_dirs) {\n    return extract_values(strdup(good_local_dirs));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(extract_values)(long long);\n\nlong long get_mapred_local_dirs_name_conflict(char *a0) { return extract_values(strdup(a0)); }\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *concatenate(char *concat_pattern, char *return_path_name, int numArgs, ...) {\n    va_list ap;\n    __builtin_va_start(ap, numArgs);\n    int strlen_args = 0;\n    char *arg = ((void *)0);\n    int j;\n    for (j = 0; j < numArgs; j++) {\n        arg = __builtin_va_arg(ap, char *);\n        if (arg == ((void *)0)) {\n            fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\", return_path_name);\n            return ((void *)0);\n        }\n        strlen_args += strlen(arg);\n    }\n    __builtin_va_end(ap);\n    char *return_path = ((void *)0);\n    int str_len = strlen(concat_pattern) + strlen_args + 1;\n    return_path = (char *)malloc(str_len);\n    if (return_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", return_path_name);\n        return ((void *)0);\n    }\n    __builtin_va_start(ap, numArgs);\n    vsnprintf(return_path, str_len, concat_pattern, ap);\n    __builtin_va_end(ap);\n    return return_path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vsnprintf)(char *, unsigned long, char *, struct va_list[1]);\n\nextern FILE_t *LOGFILE;\n\nlong long concatenate(char *a0, unsigned long a1, unsigned long a2,\n                      unsigned long a3, unsigned long a4, unsigned long a5) {\n  unsigned int v0;         // [bp-0xf0]\n  unsigned int v1;         // [bp-0xec]\n  unsigned long long *v2;  // [bp-0xe8]\n  unsigned long v3;        // [bp-0xe0]\n  unsigned int v4;         // [bp-0xd4]\n  char *v5;                // [bp-0xd0], Other Possible Types: void*\n  void *v6;                // [bp-0xc8], Other Possible Types: char *\n  unsigned int v7;         // [bp-0xc0]\n  unsigned int v8;         // [bp-0xbc]\n  char v9;                 // [bp-0xb8]\n  unsigned long v10;       // [bp-0xa0]\n  unsigned long v11;       // [bp-0x98]\n  unsigned long v12;       // [bp-0x90]\n  int v13;                 // [bp-0x88]\n  int v14;                 // [bp-0x78]\n  int v15;                 // [bp-0x68]\n  int v16;                 // [bp-0x58]\n  int v17;                 // [bp-0x48]\n  int v18;                 // [bp-0x38]\n  int v19;                 // [bp-0x28]\n  int v20;                 // [bp-0x18]\n  unsigned long v21;       // [bp+0x8]\n  char v22;                // al\n  int v23;                 // xmm0\n  int v24;                 // xmm1\n  int v25;                 // xmm2\n  int v26;                 // xmm3\n  int v27;                 // xmm4\n  int v28;                 // xmm5\n  int v29;                 // xmm6\n  int v30;                 // xmm7\n  unsigned long long *v31; // rax, Other Possible Types: unsigned long\n\n  v10 = a3;\n  v11 = a4;\n  v12 = a5;\n  if (v22) {\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n    v17 = v27;\n    v18 = v28;\n    v19 = v29;\n    v20 = v30;\n  }\n  v0 = 24;\n  v1 = 48;\n  v2 = &v21;\n  v3 = &v9;\n  v8 = 0;\n  v6 = 0;\n  for (v7 = 0; v7 < (unsigned int)a2; v7 += 1) {\n    if (v0 > 47) {\n      v31 = v2;\n      v2 = v31 + 8;\n    } else {\n      v31 = v3 + v0;\n      v0 += 8;\n    }\n    v6 = *((long long *)v31);\n    if (!v6) {\n      fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\",\n              (unsigned int)a1);\n      return 0;\n    }\n    v8 += (unsigned int)strlen(v6);\n  }\n  v5 = 0;\n  v4 = v8 + (unsigned int)strlen(a0) + 1;\n  v5 = malloc(v4);\n  if (v5) {\n    v0 = 24;\n    v1 = 48;\n    v2 = &v21;\n    v3 = &v9;\n    vsnprintf(v5, v4, a0, &v0);\n    return v5;\n  }\n  fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", (unsigned int)a1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpebwa5gxr/concatenate.c:16:62: error: array has incomplete element type\n'struct va_list' 16 | int (vsnprintf)(char *, unsigned long, char *, struct\nva_list[1]); |                                                              ^\n/tmp/tmpebwa5gxr/concatenate.c:16:55: note: forward declaration of 'struct\nva_list' 16 | int (vsnprintf)(char *, unsigned long, char *, struct va_list[1]);\n      |                                                       ^\n/tmp/tmpebwa5gxr/concatenate.c:18:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 18 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_directory(const char *tt_root, const char *user, const char *jobid) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3, tt_root, user, jobid);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nlong long get_job_directory(unsigned long long a0, unsigned long long a1,\n                            unsigned long long a2) {\n  return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3, a0, a1,\n                     a2);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_directory(const char *tt_root, const char *user) {\n    return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2, tt_root, user);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nlong long get_user_directory(unsigned long long a0, unsigned long long a1,\n                             unsigned long a2, unsigned long a3,\n                             unsigned long a4, unsigned long long a5) {\n  return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2, a0, a1, a5);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_work_directory(const char *job_dir) {\n    return concatenate(\"%s/work\", \"job work\", 1, job_dir);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nlong long get_job_work_directory(unsigned long long a0, unsigned long a1,\n                                 unsigned long a2, unsigned long a3,\n                                 unsigned long long a4, unsigned long long a5) {\n  return concatenate(\"%s/work\", \"job work\", 1, a0, a4, a5);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_attempt_work_directory(const char *tt_root, const char *user, const char *job_id, const char *attempt_id) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\", \"attempt_dir_path\", 4, tt_root, user, job_id, attempt_id);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nlong long get_attempt_work_directory(unsigned long long a0,\n                                     unsigned long long a1,\n                                     unsigned long long a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x38]\n\n  v0 = a3;\n  return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\",\n                     \"attempt_dir_path\", 4, a0, a1, a2);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_task_launcher_file(const char *work_dir) {\n    return concatenate(\"%s/%s\", \"task launcher\", 2, work_dir, \"taskjvm.sh\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nlong long get_task_launcher_file(unsigned long long a0, unsigned long a1,\n                                 unsigned long a2, unsigned long a3,\n                                 unsigned long a4, unsigned long long a5) {\n  return concatenate(\"%s/%s\", \"task launcher\", 2, a0, \"taskjvm.sh\", a5);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_log_directory(const char *jobid) {\n    char *log_dir = get_value(\"hadoop.log.dir\");\n    if (log_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n        return ((void *)0);\n    }\n    char *result = concatenate(\"%s/userlogs/%s\", \"job log dir\", 2, log_dir, jobid);\n    if (result == ((void *)0)) {\n        fprintf(LOGFILE, \"failed to get memory in get_job_log_directory for %s and %s\\n\", log_dir, jobid);\n    }\n    free(log_dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_40aa55; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_value)(long long);\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nextern FILE_t *LOGFILE;\n\nlong long get_job_log_directory(unsigned long long a0, unsigned long a1,\n                                unsigned long a2, unsigned long a3,\n                                unsigned long a4, unsigned long long a5) {\n  unsigned long v0; // [bp-0x18]\n  void *v1;         // [bp-0x10]\n\n  v1 = get_value(\"hadoop.log.dir\");\n  if (!v1) {\n    fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", &g_40aa55);\n    return 0;\n  }\n  v0 = concatenate(\"%s/userlogs/%s\", \"job log dir\", 2, v1, a0, a5);\n  if (!v0)\n    fprintf(LOGFILE,\n            \"failed to get memory in get_job_log_directory for %s and %s\\n\",\n            (unsigned int)v1, (unsigned int)a0);\n  free(v1);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbaqlisp9/get_job_log_directory.c:20:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 20 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_subdirectory(const char *tt_root, const char *user, const char *subdir) {\n    char *user_dir = get_user_directory(tt_root, user);\n    char *result = concatenate(\"%s/%s\", \"user subdir\", 2, user_dir, subdir);\n    free(user_dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_user_directory)(long long, long long, long long, long long,\n                              long long, long long);\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\n\nlong long get_user_subdirectory(unsigned long long a0, unsigned long long a1,\n                                unsigned long long a2, unsigned long long a3,\n                                unsigned long long a4, unsigned long long a5) {\n  unsigned long v0; // [bp-0x18]\n  void *v1;         // [bp-0x10]\n\n  v1 = get_user_directory(a0, a1, a1, a3, a4, a5);\n  v0 = concatenate(\"%s/%s\", \"user subdir\", 2, v1, a2, a5);\n  free(v1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int mkdirs(const char *path, mode_t perm) {\n    char *buffer = strdup(path);\n    char *token;\n    int cwd = open(\"/\", 0);\n    if (cwd == -1) {\n        fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", path, strerror((*__errno_location())));\n        free(buffer);\n        return -1;\n    }\n    for (token = strtok(buffer, \"/\"); token != ((void *)0); token = strtok(((void *)0), \"/\")) {\n        if (mkdirat(cwd, token, perm) != 0) {\n            if ((*__errno_location()) != 17) {\n                fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n                close(cwd);\n                free(buffer);\n                return -1;\n            }\n        }\n        int new_dir = openat(cwd, token, 0);\n        close(cwd);\n        cwd = new_dir;\n        if (cwd == -1) {\n            fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n            free(buffer);\n            return -1;\n        }\n    }\n    free(buffer);\n    close(cwd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nint(open)(char *, int, unsigned short);\nchar *(strtok)(char *, char *);\nchar *(strerror)(int);\nint(close)(int);\n\nextern FILE_t *LOGFILE;\n\nlong long mkdirs_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;        // [bp-0x24]\n  void *v1;               // [bp-0x20]\n  unsigned int v2;        // [bp-0x14]\n  unsigned long v3;       // [bp-0x10]\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rcx\n  unsigned long long v9;  // rcx\n  unsigned long long v11; // rax\n  unsigned long long v13; // rax\n\n  v1 = strdup(a0);\n  v2 = open(\"/\", 0, a2);\n  if (v2 == -1) {\n    (unsigned int)v6 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", (unsigned int)a0,\n            (unsigned int)v6);\n    free(v1);\n    return 4294967295;\n  }\n  for (v3 = strtok(v1, \"/\"); v3; v3 = strtok(NULL, \"/\")) {\n    v7 = v3;\n    if (mkdirat(v2, v7, (unsigned int)a1, v7) && *(__errno_location()) != 17) {\n      (unsigned int)v11 = strerror(*(__errno_location()));\n      fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\",\n              (unsigned int)v3, (unsigned int)a0, (unsigned int)v11);\n      close(v2);\n      free(v1);\n      return 4294967295;\n    }\n    v9 = v3;\n    v0 = openat(v2, v9, 0, v9);\n    close(v2);\n    v2 = v0;\n    if (v2 == -1) {\n      (unsigned int)v13 = strerror(*(__errno_location()));\n      fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", (unsigned int)v3,\n              (unsigned int)a0, (unsigned int)v13);\n      free(v1);\n      return 4294967295;\n    }\n  }\n  free(v1);\n  close(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw6vwbef3/mkdirs_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpw6vwbef3/mkdirs_name_conflict.c:40:37: error: indirection requires pointer operand\n('int' invalid) 40 |         (unsigned int)v6 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw6vwbef3/mkdirs_name_conflict.c:48:54: error: indirection requires pointer operand\n('int' invalid) 48 |         if (mkdirat(v2, v7, (unsigned int)a1, v7) &&\n*(__errno_location()) != 17) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw6vwbef3/mkdirs_name_conflict.c:50:42: error: indirection requires pointer operand\n('int' invalid) 50 |             (unsigned int)v11 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw6vwbef3/mkdirs_name_conflict.c:62:42: error: indirection requires pointer operand\n('int' invalid) 62 |             (unsigned int)v13 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static short get_current_local_dir_count(char **local_dir) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        ++count;\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long get_current_local_dir_count_name_conflict(unsigned long long *a0) {\n  unsigned short v0;      // [bp-0x12]\n  unsigned long long *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = 0;\n  for (v1 = a0; *((long long *)v1); v1 += 8) {\n    v0 += 1;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_nth_local_dir(char **local_dir, int nth) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        if (count == nth) {\n            return strdup(*local_dir_ptr);\n        }\n        ++count;\n    }\n    fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\", nth, count);\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nextern FILE_t *LOGFILE;\n\nlong long get_nth_local_dir_name_conflict(unsigned long long *a0, unsigned long a1) {\n  unsigned short v0;     // [bp-0x12]\n  char **v1;             // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = a0; *(v1); v1 += 1) {\n    if ((unsigned int)a1 != v0)\n      v0 += 1;\n    else\n      return strdup(*((long long *)v1));\n  }\n  fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\",\n          (unsigned int)a1, v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcg12yoji/get_nth_local_dir_name_conflict.c:18:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 18 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_random_local_dir(char **local_dir) {\n    struct timeval tv;\n    short nth;\n    gettimeofday(&tv, ((void *)0));\n    srand((long)tv.tv_sec * 1000000 + tv.tv_usec);\n    short cnt = get_current_local_dir_count(local_dir);\n    if (cnt == 0) {\n        fprintf(LOGFILE, \"No valid local directories\\n\");\n        return ((void *)0);\n    }\n    nth = rand() % cnt;\n    return get_nth_local_dir(local_dir, nth);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nvoid(srand)(unsigned int);\nlong long(get_current_local_dir_count)(long long);\nint(rand)();\nlong long(get_nth_local_dir)(long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern FILE_t *LOGFILE;\n\nlong long get_random_local_dir_name_conflict(unsigned long long a0) {\n  timeval v0;            // [bp-0x28]\n  char v1;               // [bp-0x20]\n  unsigned short v2;     // [bp-0xc]\n  unsigned short v3;     // [bp-0xa]\n  unsigned long long v5; // rax\n\n  gettimeofday(&v0, NULL);\n  srand((int)*((long long *)&v0.tv_sec) * 1000000 + *((long long *)&v1));\n  v3 = get_current_local_dir_count(a0);\n  if (!v3) {\n    fwrite(\"No valid local directories\\n\", 1, 27, LOGFILE);\n    return 0;\n  }\n  (unsigned int)v5 = rand();\n  v2 = ((unsigned int)v5 >> 31 CONCAT(unsigned int) v5) / m v3 >> 32;\n  return get_nth_local_dir(a0, v2);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqzzas9x9/get_random_local_dir_name_conflict.c:35:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 35 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqzzas9x9/get_random_local_dir_name_conflict.c:53:5: error: assignment to cast is\nillegal, lvalue casts are not supported 53 |     (unsigned int)v5 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpqzzas9x9/get_random_local_dir_name_conflict.c:54:34: error:\nexpected ')' 54 |     v2 = ((unsigned int)v5 >> 31 CONCAT (unsigned int)v5) /m\nv3 >> 32; |                                  ^\n/tmp/tmpqzzas9x9/get_random_local_dir_name_conflict.c:54:10: note: to match this '('\n   54 |     v2 = ((unsigned int)v5 >> 31 CONCAT (unsigned int)v5) /m v3 >> 32;\n      |          ^\n/tmp/tmpqzzas9x9/get_random_local_dir_name_conflict.c:54:61: error: expected ';' after\nexpression 54 |     v2 = ((unsigned int)v5 >> 31 CONCAT (unsigned int)v5) /m v3\n>> 32; |                                                             ^ | ; 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_attempt_directories(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id) {\n    const mode_t perms = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    if (job_id == ((void *)0) || task_id == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either task_id is null or the user passed is null.\\n\");\n        return -1;\n    }\n    int result = 0;\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could not be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *task_dir = get_attempt_work_directory(*local_dir_ptr, user, job_id, task_id);\n        if (task_dir == ((void *)0)) {\n            free_values(local_dir);\n            return -1;\n        }\n        if (mkdirs(task_dir, perms) != 0) {\n            free(task_dir);\n        } else {\n            free(task_dir);\n        }\n    }\n    char *job_task_name = malloc(strlen(job_id) + strlen(task_id) + 2);\n    char *real_task_dir = ((void *)0);\n    char *real_job_dir = ((void *)0);\n    char *random_local_dir = ((void *)0);\n    char *link_task_log_dir = ((void *)0);\n    if (job_task_name == ((void *)0)) {\n        fprintf(LOGFILE, \"Malloc of job task name failed\\n\");\n        result = -1;\n    } else {\n        sprintf(job_task_name, \"%s/%s\", job_id, task_id);\n        link_task_log_dir = get_job_log_directory(job_task_name);\n        random_local_dir = get_random_local_dir(local_dir);\n        if (random_local_dir == ((void *)0)) {\n            result = -1;\n            goto cleanup;\n        }\n        real_job_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + 3);\n        if (real_job_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real job directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        real_task_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + strlen(task_id) + 4);\n        if (real_task_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real task directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_job_dir, \"%s/userlogs/%s\", random_local_dir, job_id);\n        result = create_directory_for_user(real_job_dir);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_task_dir, \"%s/userlogs/%s/%s\", random_local_dir, job_id, task_id);\n        result = mkdirs(real_task_dir, perms);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        result = symlink(real_task_dir, link_task_log_dir);\n        if (result != 0) {\n            fprintf(LOGFILE, \"Failed to create symlink %s to %s - %s\\n\", link_task_log_dir, real_task_dir, strerror((*__errno_location())));\n            result = -1;\n        }\n    }\n  cleanup:\n    free(random_local_dir);\n    free(job_task_name);\n    free(link_task_log_dir);\n    free(real_job_dir);\n    free(real_task_dir);\n    free_values(local_dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_mapred_local_dirs)(long long);\nlong long(get_attempt_work_directory)(long long, long long, long long,\n                                      long long);\nlong long(free_values)(long long);\nlong long(mkdirs)(long long, long long, long long);\nlong long(get_job_log_directory)(long long, long long, long long, long long,\n                                 long long, long long);\nlong long(get_random_local_dir)(long long);\nlong long(create_directory_for_user)(long long);\nint(symlink)(char *, char *);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\n\nlong long create_attempt_directories(unsigned long long a0,\n                                     unsigned long long a1, unsigned long a2,\n                                     char *a3, unsigned long long a4,\n                                     unsigned long long a5) {\n  char *v0;               // [bp-0x80]\n  void *v1;               // [bp-0x68]\n  void *v2;               // [bp-0x60]\n  unsigned long long *v3; // [bp-0x58]\n  unsigned int v4;        // [bp-0x4c]\n  void *v5;               // [bp-0x48], Other Possible Types: unsigned long\n  void *v6;               // [bp-0x40], Other Possible Types: unsigned long\n  void *v7;               // [bp-0x38], Other Possible Types: unsigned long\n  void *v8;               // [bp-0x30], Other Possible Types: unsigned long\n  unsigned long long *v9; // [bp-0x28], Other Possible Types: unsigned long\n  unsigned int v10;       // [bp-0x1c]\n  unsigned long long v13; // rdx\n  unsigned int v14;       // edx\n  unsigned long long v16; // rdx\n  unsigned long long v18; // rax\n\n  v0 = a2;\n  v4 = 488;\n  if (v0 && a3 && a0) {\n    v10 = 0;\n    v3 = get_mapred_local_dirs(a1);\n    if (!v3) {\n      fwrite(\"Good mapred local directories could not be obtained.\\n\", 1, 53,\n             LOGFILE);\n      return 5;\n    }\n    for (v9 = v3; *((long long *)v9); v9 += 1) {\n      v1 = get_attempt_work_directory(*((long long *)v9), a0, v0, a3);\n      if (!v1) {\n        free_values(v3);\n        return 4294967295;\n      }\n      v13 = v4;\n      if ((int)mkdirs(v1, v13, v13))\n        free(v1);\n      else\n        free(v1);\n    }\n    v2 = malloc(strlen(a3) + strlen(v0) + 2);\n    v8 = 0;\n    v7 = 0;\n    v6 = 0;\n    v5 = 0;\n    if (!v2) {\n      fwrite(\"Malloc of job task name failed\\n\", 1, 31, LOGFILE);\n      v10 = -1;\n    } else {\n      v14 = (unsigned int)v0;\n      sprintf(v2, \"%s/%s\", v14, (unsigned int)a3);\n      v5 = get_job_log_directory(v2, \"%s/%s\", *((unsigned long long *)&v14), a3,\n                                 a4, a5);\n      v6 = get_random_local_dir(v3);\n      if (!v6) {\n        v10 = -1;\n      } else {\n        v7 = malloc(strlen(v0) + strlen(v6) + 11);\n        if (!v7) {\n          fwrite(\"Malloc of real job directory failed\\n\", 1, 36, LOGFILE);\n          v10 = -1;\n        } else {\n          v8 = malloc(strlen(a3) + strlen(v6) + strlen(v0) + 12);\n          if (!v8) {\n            fwrite(\"Malloc of real task directory failed\\n\", 1, 37, LOGFILE);\n            v10 = -1;\n          } else {\n            sprintf(v7, \"%s/userlogs/%s\", (unsigned int)v6, (unsigned int)v0);\n            v10 = create_directory_for_user(v7);\n            if (v10) {\n              v10 = -1;\n            } else {\n              sprintf(v8, \"%s/userlogs/%s/%s\", (unsigned int)v6,\n                      (unsigned int)v0, (unsigned int)a3);\n              v16 = v4;\n              v10 = mkdirs(v8, v16, v16);\n              if (v10) {\n                v10 = -1;\n              } else {\n                v10 = symlink(v8, v5);\n                if (v10) {\n                  (unsigned int)v18 = strerror(*(__errno_location()));\n                  fprintf(LOGFILE, \"Failed to create symlink %s to %s - %s\\n\",\n                          (unsigned int)v5, (unsigned int)v8,\n                          (unsigned int)v18);\n                  v10 = -1;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    free(v6);\n    free(v2);\n    free(v5);\n    free(v7);\n    free(v8);\n    free_values(v3);\n    return v10;\n  }\n  fwrite(\"Either task_id is null or the user passed is null.\\n\", 1, 51,\n         LOGFILE);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjuz5sj7n/create_attempt_directories.c:26:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 26 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpjuz5sj7n/create_attempt_directories.c:129:66: error: indirection\nrequires pointer operand ('int' invalid) 129 | (unsigned int)v18 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int set_user(const char *user) {\n    if (user_detail != ((void *)0)) {\n        free(user_detail);\n        user_detail = ((void *)0);\n    }\n    user_detail = check_user(user);\n    if (user_detail == ((void *)0)) {\n        return -1;\n    }\n    return change_effective_user(user_detail->pw_uid, user_detail->pw_gid);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(check_user)(long long);\nlong long(change_effective_user)(long long, long long);\n\nextern struct_0 *user_detail;\n\nlong long set_user_name_conflict(unsigned long long a0) {\n  if (user_detail) {\n    free(user_detail);\n    user_detail = 0;\n  }\n  user_detail = check_user(a0);\n  if (user_detail)\n    return change_effective_user(user_detail->field_10, user_detail->field_14);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvl_p893o/set_user_name_conflict.c:26:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 26 | extern struct_0 *user_detail; |        ^~~~~~~~ | struct\n/tmp/tmpvl_p893o/set_user_name_conflict.c:26:8: error: declaration of anonymous struct must be\na definition /tmp/tmpvl_p893o/set_user_name_conflict.c:37:51: error: member reference type\n'int' is not a pointer 37 |         return\nchange_effective_user(user_detail->field_10, user_detail->field_14); |\n~~~~~~~~~~~  ^ /tmp/tmpvl_p893o/set_user_name_conflict.c:37:74: error: member reference type\n'int' is not a pointer 37 |         return\nchange_effective_user(user_detail->field_10, user_detail->field_14); |\n~~~~~~~~~~~  ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_owner(const char *path, uid_t user, gid_t group) {\n    if (geteuid() == user && getegid() == group) {\n        return 0;\n    } else {\n        uid_t old_user = geteuid();\n        gid_t old_group = getegid();\n        if (change_effective_user(0, group) != 0) {\n            return -1;\n        }\n        if (chown(path, user, group) != 0) {\n            fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", path, user, group, strerror((*__errno_location())));\n            return -1;\n        }\n        return change_effective_user(old_user, old_group);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nunsigned int(getegid)();\nlong long(change_effective_user)(long long, long long);\nint(chown)(char *, unsigned int, unsigned int);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\n\nlong long change_owner_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v5; // rax\n\n  if ((unsigned int)a1 == geteuid() && (unsigned int)a2 == getegid())\n    return 0;\n  v1 = geteuid();\n  v0 = getegid();\n  if ((int)change_effective_user(0, (unsigned int)a2)) {\n    return 4294967295;\n  } else if (chown(a0, a1, a2)) {\n    (unsigned int)v5 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", (unsigned int)a0,\n            (unsigned int)a1, (unsigned int)a2, (unsigned int)v5);\n    return 4294967295;\n  } else {\n    return change_effective_user(v1, v0);\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvrz139bt/change_owner_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpvrz139bt/change_owner_name_conflict.c:40:37: error: indirection requires pointer\noperand ('int' invalid) 40 |         (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_directory_for_user(const char *path) {\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3) | 1024;\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    int ret = 0;\n    uid_t root = 0;\n    if (getuid() == root) {\n        ret = change_effective_user(root, tt_gid);\n    }\n    if (ret == 0) {\n        if (mkdir(path, permissions) == 0 || (*__errno_location()) == 17) {\n            if (chmod(path, permissions) != 0) {\n                fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\", path, strerror((*__errno_location())));\n                ret = -1;\n            } else if (change_owner(path, user, tt_gid) != 0) {\n                ret = -1;\n            }\n        } else {\n            fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user, group) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nunsigned int(getegid)();\nunsigned int(getuid)();\nlong long(change_effective_user)(long long, long long);\nint(chmod)(char *, unsigned short);\nlong long(change_owner)(long long, long long, long long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern unsigned int tt_gid;\n\nlong long create_directory_for_user_name_conflict(char *a0) {\n  unsigned int v0;        // [bp-0x1c]\n  unsigned int v1;        // [bp-0x18]\n  unsigned int v2;        // [bp-0x14]\n  unsigned int v3;        // [bp-0x10]\n  unsigned int v4;        // [bp-0xc]\n  unsigned long long v8;  // rax\n  unsigned long long v10; // rax\n\n  v3 = 1512;\n  v2 = geteuid();\n  v1 = getegid();\n  v4 = 0;\n  v0 = 0;\n  if (v0 == getuid())\n    v4 = change_effective_user(v0, tt_gid);\n  if (!v4) {\n    if (!(!mkdir(a0, v3) || *(__errno_location()) == 17)) {\n      (unsigned int)v8 = strerror(*(__errno_location()));\n      fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", (unsigned int)a0,\n              (unsigned int)v8);\n      v4 = -1;\n    } else if (chmod(a0, v3)) {\n      (unsigned int)v10 = strerror(*(__errno_location()));\n      fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\",\n              (unsigned int)a0, (unsigned int)v10);\n      v4 = -1;\n    } else if ((int)change_owner(a0, v2, tt_gid)) {\n      v4 = -1;\n    }\n  }\n  if ((int)change_effective_user(v2, v1)) {\n    v4 = -1;\n    return v4;\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphftsryw1/create_directory_for_user_name_conflict.c:24:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 24 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmphftsryw1/create_directory_for_user_name_conflict.c:46:33: error: indirection requires\npointer operand ('int' invalid) 46 |         if (!(!mkdir(a0, v3) ||\n*(__errno_location()) == 17)) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphftsryw1/create_directory_for_user_name_conflict.c:48:41: error: indirection requires\npointer operand ('int' invalid) 48 |             (unsigned int)v8 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphftsryw1/create_directory_for_user_name_conflict.c:54:42: error: indirection requires\npointer operand ('int' invalid) 54 |             (unsigned int)v10 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int open_file_as_task_tracker(const char *filename) {\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    if (change_effective_user(tt_uid, tt_gid) != 0) {\n        return -1;\n    }\n    int result = open(filename, 0);\n    if (result == -1) {\n        fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\", filename, strerror((*__errno_location())));\n    }\n    if (change_effective_user(user, group)) {\n        result = -1;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nunsigned int(getegid)();\nlong long(change_effective_user)(long long, long long);\nint(open)(char *, int, unsigned short);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern unsigned int tt_gid;\nextern unsigned int tt_uid;\n\nlong long open_file_as_task_tracker_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x14]\n  unsigned int v1;       // [bp-0x10]\n  unsigned int v2;       // [bp-0xc]\n  unsigned short v5;     // dx\n  unsigned long long v7; // rax\n\n  v1 = geteuid();\n  v0 = getegid();\n  if ((int)change_effective_user(tt_uid, tt_gid))\n    return 4294967295;\n  v2 = open(a0, 0, v5);\n  if (v2 == -1) {\n    (unsigned int)v7 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\",\n            (unsigned int)a0, (unsigned int)v7);\n  }\n  if (!(int)change_effective_user(v1, v0))\n    return v2;\n  v2 = -1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl533t0zb/open_file_as_task_tracker_name_conflict.c:22:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpl533t0zb/open_file_as_task_tracker_name_conflict.c:41:37: error: indirection requires\npointer operand ('int' invalid) 41 |         (unsigned int)v7 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int copy_file(int input, const char *in_filename, const char *out_filename, mode_t perm) {\n    const int buffer_size = 128 * 1024;\n    char buffer[buffer_size];\n    int out_fd = open(out_filename, 1 | 64 | 128 | 131072, perm);\n    if (out_fd == -1) {\n        fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    ssize_t len = read(input, buffer, buffer_size);\n    while (len > 0)\n        {\n            ssize_t pos = 0;\n            while (pos < len)\n                {\n                    ssize_t write_result = write(out_fd, buffer + pos, len - pos);\n                    if (write_result <= 0) {\n                        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", out_filename, strerror((*__errno_location())));\n                        close(out_fd);\n                        return -1;\n                    }\n                    pos += write_result;\n                }\n            len = read(input, buffer, buffer_size);\n        }\n    if (len < 0) {\n        fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", in_filename, strerror((*__errno_location())));\n        close(out_fd);\n        return -1;\n    }\n    if (close(out_fd) != 0) {\n        fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    close(input);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nlong(read)(int, void *, unsigned long);\nchar *(strerror)(int);\nint(close)(int);\nlong(write)(int, void *, unsigned long);\n\nextern FILE_t *LOGFILE;\nextern char g_40701a;\n\nlong long copy_file(unsigned long a0, unsigned long a1, char *a2,\n                    unsigned long a3) {\n  char v0;                // [bp-0x80]\n  char v1;                // [bp-0x78]\n  unsigned long v2;       // [bp-0x50]\n  unsigned int v3;        // [bp-0x44]\n  void *v4;               // [bp-0x40]\n  unsigned long v5;       // [bp-0x38]\n  unsigned int v6;        // [bp-0x2c]\n  void *v7;               // [bp-0x28], Other Possible Types: unsigned long\n  unsigned long v8;       // [bp-0x20]\n  unsigned long v10;      // rax\n  unsigned long long v12; // rax\n  unsigned long long v14; // rax\n  unsigned long long v16; // rax\n  unsigned long long v18; // rax\n\n  v6 = 0x20000;\n  v5 = v6 - 1;\n  v10 = (0 CONCAT v6 + 15) / m 16 * 16;\n  v4 = &(&v1)[-1 * v10];\n  *((char **)&(&v0)[-1 * v10]) = &g_40701a;\n  v3 = open(a2, 131265, a3);\n  if (v3 == -1) {\n    (unsigned int)v12 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", (unsigned int)a2,\n            (unsigned int)v12);\n    return 4294967295;\n  }\n  for (v8 = read(a0, v4, v6); v8 > 0; v8 = read(a0, v4, v6)) {\n    for (v7 = 0; v7 < v8; v7 += v2) {\n      v2 = write(v3, v7 + v4, v8 - v7);\n      if (v2 <= 0) {\n        (unsigned int)v14 = strerror(*(__errno_location()));\n        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", (unsigned int)a2,\n                (unsigned int)v14);\n        close(v3);\n        return 4294967295;\n      }\n    }\n  }\n  if ((char)(v8 - 0 >> 63)) {\n    (unsigned int)v16 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", (unsigned int)a1,\n            (unsigned int)v16);\n    close(v3);\n    return 4294967295;\n  } else if (close(v3)) {\n    (unsigned int)v18 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", (unsigned int)a2,\n            (unsigned int)v18);\n    return 4294967295;\n  } else {\n    close(a0);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjr1gq8ku/copy_file.c:23:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 23 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpjr1gq8ku/copy_file.c:45:14: error: expected ')'\n   45 |     v10 = (0 CONCAT v6 + 15) /m 16 * 16;\n      |              ^\n/tmp/tmpjr1gq8ku/copy_file.c:45:11: note: to match this '('\n   45 |     v10 = (0 CONCAT v6 + 15) /m 16 * 16;\n      |           ^\n/tmp/tmpjr1gq8ku/copy_file.c:45:32: error: expected ';' after expression\n   45 |     v10 = (0 CONCAT v6 + 15) /m 16 * 16;\n      |                                ^\n      |                                ;\n/tmp/tmpjr1gq8ku/copy_file.c:51:38: error: indirection requires pointer operand\n('int' invalid) 51 |         (unsigned int)v12 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjr1gq8ku/copy_file.c:59:31: error: invalid operands to binary expression\n('void *' and 'void *') 59 |             v2 = write(v3, v7 + v4, v8 - v7); | ~~\n^ ~~ /tmp/tmpjr1gq8ku/copy_file.c:59:40: error: invalid operands to binary\nexpression ('unsigned long' and 'void *') 59 |             v2 = write(v3, v7 +\nv4, v8 - v7); |                                     ~~ ^ ~~\n/tmp/tmpjr1gq8ku/copy_file.c:62:46: error: indirection requires pointer operand\n('int' invalid) 62 |                 (unsigned int)v14 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjr1gq8ku/copy_file.c:71:38: error: indirection requires pointer operand\n('int' invalid) 71 |         (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjr1gq8ku/copy_file.c:78:38: error: indirection requires pointer operand\n('int' invalid) 78 |         (unsigned int)v18 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_user(const char *user, const char *good_local_dirs) {\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char *user_dir;\n    char **local_dir_ptr = local_dir;\n    int failed = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != 0; ++local_dir_ptr) {\n        user_dir = get_user_directory(*local_dir_ptr, user);\n        if (user_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\", user);\n            failed = 1;\n            break;\n        }\n        if (create_directory_for_user(user_dir) != 0) {\n            failed = 1;\n        }\n        free(user_dir);\n    }\n    free_values(local_dir);\n    return failed ? INITIALIZE_USER_FAILED : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_mapred_local_dirs)(long long);\nlong long(free_values)(long long);\nlong long(get_user_directory)(long long, long long, long long, long long,\n                              long long, long long);\nlong long(create_directory_for_user)(long long);\n\nextern FILE_t *LOGFILE;\n\nlong long initialize_user(unsigned long long a0, unsigned long long a1,\n                          unsigned long a2, unsigned long long a3,\n                          unsigned long long a4, unsigned long long a5) {\n  void *v0;               // [bp-0x28]\n  unsigned long long *v1; // [bp-0x20]\n  unsigned int v2;        // [bp-0x14]\n  unsigned long long *v3; // [bp-0x10], Other Possible Types: unsigned long\n  char v4;                // [bp-0x8]\n  unsigned long long v6;  // rbp\n\n  v6 = &v4;\n  v1 = get_mapred_local_dirs(a1);\n  if (!v1) {\n    fwrite(\"Good mapred local directories could ot be obtained.\\n\", 1, 52,\n           LOGFILE);\n    return 5;\n  }\n  v3 = v1;\n  v2 = 0;\n  for (v3 = v1; *(v3); v3 += 1) {\n    v0 = get_user_directory(*(v3), a0, a0, a3, a4, a5);\n    if (v0) {\n      if ((int)create_directory_for_user(v0))\n        v2 = 1;\n      free(v0);\n    } else {\n      fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\",\n              (unsigned int)a0);\n      v2 = 1;\n      break;\n    }\n  }\n  free_values(v1);\n  return (!v2 ? 20 : 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd4p35tyu/initialize_user.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_job(const char *user, const char *good_local_dirs, const char *jobid, const char *credentials, const char *job_xml, char *const *args) {\n    if (jobid == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either jobid is null or the user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    int result = initialize_user(user, good_local_dirs);\n    if (result != 0) {\n        return result;\n    }\n    char *job_log_dir = get_job_log_directory(jobid);\n    if (job_log_dir == ((void *)0)) {\n        return -1;\n    }\n    result = create_directory_for_user(job_log_dir);\n    free(job_log_dir);\n    if (result != 0) {\n        return -1;\n    }\n    int cred_file = open_file_as_task_tracker(credentials);\n    if (cred_file == -1) {\n        return -1;\n    }\n    int job_file = open_file_as_task_tracker(job_xml);\n    if (job_file == -1) {\n        return -1;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    if (tt_roots == ((void *)0)) {\n        return INVALID_TT_ROOT;\n    }\n    char **tt_root;\n    char *primary_job_dir = ((void *)0);\n    for (tt_root = tt_roots; *tt_root != ((void *)0); ++tt_root) {\n        char *job_dir = get_job_directory(*tt_root, user, jobid);\n        if (job_dir == ((void *)0)) {\n        } else if (mkdirs(job_dir, permissions) != 0) {\n            free(job_dir);\n        } else if (primary_job_dir == ((void *)0)) {\n            primary_job_dir = job_dir;\n        } else {\n            free(job_dir);\n        }\n    }\n    free_values(tt_roots);\n    if (primary_job_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Did not create any job directories\\n\");\n        return -1;\n    }\n    char *cred_file_name = concatenate(\"%s/%s\", \"cred file\", 2, primary_job_dir, \"jobToken\");\n    if (cred_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(cred_file, credentials, cred_file_name, 256 | 128) != 0) {\n        return -1;\n    }\n    char *job_file_name = concatenate(\"%s/%s\", \"job file\", 2, primary_job_dir, \"job.xml\");\n    if (job_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(job_file, job_xml, job_file_name, 256 | 128 | (256 >> 3)) != 0) {\n        return -1;\n    }\n    fclose(stdin);\n    fflush(LOGFILE);\n    if (LOGFILE != stdout) {\n        fclose(stdout);\n    }\n    fclose(stderr);\n    chdir(primary_job_dir);\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec job initialization process - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(initialize_user)(long long, long long, long long, long long,\n                           long long, long long);\nlong long(get_job_log_directory)(long long, long long, long long, long long,\n                                 long long, long long);\nlong long(create_directory_for_user)(long long);\nlong long(open_file_as_task_tracker)(long long);\nlong long(change_user)(long long, long long);\nlong long(get_mapred_local_dirs)(long long);\nlong long(free_values)(long long);\nlong long(get_job_directory)(long long, long long, long long);\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(mkdirs)(long long, long long, long long);\nlong long(copy_file)(long long, long long, long long, long long);\nint(chdir)(char *);\nint(execvp)(char *, char *[0]);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern FILE_t *__TMC_END__;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern FILE_t *stdin @GLIBC_2.2.5;\nextern struct_0 *user_detail;\n\nlong long initialize_job(unsigned long long a0, unsigned long long a1,\n                         unsigned long a2, unsigned long long a3,\n                         unsigned long long a4, char **a5) {\n  unsigned long long v0;   // [bp-0x70]\n  void *v1;                // [bp-0x58]\n  unsigned long long v2;   // [bp-0x50]\n  unsigned long long v3;   // [bp-0x48]\n  unsigned long long *v4;  // [bp-0x40]\n  unsigned int v5;         // [bp-0x34]\n  unsigned int v6;         // [bp-0x30]\n  unsigned int v7;         // [bp-0x2c]\n  void *v8;                // [bp-0x28]\n  unsigned int v9;         // [bp-0x1c]\n  void *v10;               // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long long *v11; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long v14;  // rdx\n  unsigned long long v16;  // rax\n\n  v0 = a2;\n  if (v0 && a0) {\n    v9 = initialize_user(a0, a1, a1, a3, a4, a5);\n    if (v9)\n      return v9;\n    v8 = get_job_log_directory(v0, a1, a1, a3, a4, a5);\n    if (!v8)\n      return 4294967295;\n    v9 = create_directory_for_user(v8);\n    free(v8);\n    if (v9)\n      return 4294967295;\n    v7 = open_file_as_task_tracker(a3);\n    if (v7 == -1)\n      return 4294967295;\n    v6 = open_file_as_task_tracker(a4);\n    if (v6 == -1) {\n      return 4294967295;\n    } else if (!(int)change_user(user_detail->field_10,\n                                 user_detail->field_14)) {\n      v5 = 488;\n      v4 = get_mapred_local_dirs(a1);\n      if (!v4)\n        return 5;\n      v10 = 0;\n      for (v11 = v4; *((long long *)v11); v11 += 8) {\n        v1 = get_job_directory(*((long long *)v11), a0, v0);\n        if (v1) {\n          v14 = v5;\n          if ((int)mkdirs(v1, v14, v14)) {\n            free(v1);\n          } else if (!v10) {\n            v10 = v1;\n          } else {\n            free(v1);\n          }\n        }\n      }\n      free_values(v4);\n      if (!v10) {\n        fwrite(\"Did not create any job directories\\n\", 1, 35, LOGFILE);\n        return 4294967295;\n      }\n      v3 = concatenate(\"%s/%s\", \"cred file\", 2, v10, \"jobToken\", a5);\n      if (!v3) {\n        return 4294967295;\n      } else if (!(int)copy_file(v7, a3, v3, 384)) {\n        v2 = concatenate(\"%s/%s\", \"job file\", 2, v10, \"job.xml\", a5);\n        if (!v2) {\n          return 4294967295;\n        } else if (!(int)copy_file(v6, a4, v2, 416)) {\n          fclose(stdin @GLIBC_2.2.5);\n          fflush(LOGFILE);\n          if (LOGFILE != __TMC_END__)\n            fclose(__TMC_END__);\n          fclose(stderr @GLIBC_2.2.5);\n          chdir(v10);\n          execvp(*(a5), a5);\n          (unsigned int)v16 = strerror(*(__errno_location()));\n          fprintf(LOGFILE, \"Failure to exec job initialization process - %s\\n\",\n                  (unsigned int)v16);\n          return 4294967295;\n        } else {\n          return 4294967295;\n        }\n      } else {\n        return 4294967295;\n      }\n    } else {\n      return 4294967295;\n    }\n  }\n  fwrite(\"Either jobid is null or the user passed is null.\\n\", 1, 49, LOGFILE);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfclyzi6s/initialize_job.c:33:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 33 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfclyzi6s/initialize_job.c:34:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 34 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfclyzi6s/initialize_job.c:35:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 35 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfclyzi6s/initialize_job.c:35:22: error: expected ';' after top level\ndeclarator 35 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpfclyzi6s/initialize_job.c:36:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 36 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfclyzi6s/initialize_job.c:36:21: error: expected ';' after top level\ndeclarator 36 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpfclyzi6s/initialize_job.c:37:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 37 | extern struct_0 *user_detail; |        ^~~~~~~~ | struct\n/tmp/tmpfclyzi6s/initialize_job.c:37:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpfclyzi6s/initialize_job.c:77:49: error: member\nreference type 'int' is not a pointer 77 |         else if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmpfclyzi6s/initialize_job.c:77:72: error: member reference type 'int' is\nnot a pointer 77 |         else if (!(int)change_user(user_detail->field_10,\nuser_detail->field_14)) | ~~~~~~~~~~~  ^\n/tmp/tmpfclyzi6s/initialize_job.c:124:33: error: expected ')'\n  124 |                     fclose(stdin@GLIBC_2.2.5);\n      |                                 ^\n/tmp/tmpfclyzi6s/initialize_job.c:124:27: note: to match this '('\n  124 |                     fclose(stdin@GLIBC_2.2.5);\n      |                           ^\n/tmp/tmpfclyzi6s/initialize_job.c:128:34: error: expected ')'\n  128 |                     fclose(stderr@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpfclyzi6s/initialize_job.c:128:27: note: to match this '('\n  128 |                     fclose(stderr@GLIBC_2.2.5);\n      |                           ^\n/tmp/tmpfclyzi6s/initialize_job.c:131:50: error: indirection requires pointer\noperand ('int' invalid) 131 |                     (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_task_as_user(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id, const char *work_dir, const char *script_name) {\n    int exit_code = -1;\n    char *task_script_path = ((void *)0);\n    if (create_attempt_directories(user, good_local_dirs, job_id, task_id) != 0) {\n        goto cleanup;\n    }\n    int task_file_source = open_file_as_task_tracker(script_name);\n    if (task_file_source == -1) {\n        goto cleanup;\n    }\n    task_script_path = get_task_launcher_file(work_dir);\n    if (task_script_path == ((void *)0)) {\n        exit_code = OUT_OF_MEMORY;\n        goto cleanup;\n    }\n    if (copy_file(task_file_source, script_name, task_script_path, (256 | 128 | 64)) != 0) {\n        goto cleanup;\n    }\n    fcloseall();\n    umask(23);\n    if (chdir(work_dir) != 0) {\n        fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", work_dir, strerror((*__errno_location())));\n        goto cleanup;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        exit_code = SETUID_OPER_FAILED;\n        goto cleanup;\n    }\n    if (execlp(task_script_path, task_script_path, ((void *)0)) != 0) {\n        fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\", task_script_path, strerror((*__errno_location())));\n        exit_code = UNABLE_TO_EXECUTE_TASK_SCRIPT;\n        goto cleanup;\n    }\n    exit_code = 0;\n  cleanup:\n    free(task_script_path);\n    return exit_code;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(create_attempt_directories)(long long, long long, long long,\n                                      long long, long long, long long);\nlong long(open_file_as_task_tracker)(long long);\nlong long(get_task_launcher_file)(long long, long long, long long, long long,\n                                  long long, long long);\nlong long(copy_file)(long long, long long, long long, long long);\nint(fcloseall)();\nunsigned short(umask)(unsigned short);\nint(chdir)(char *);\nlong long(change_user)(long long, long long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern struct_0 *user_detail;\n\nlong long run_task_as_user(unsigned long long a0, unsigned long long a1,\n                           unsigned long long a2, unsigned long long a3,\n                           char *a4, unsigned long long a5) {\n  unsigned int v0;       // [bp-0x1c]\n  void *v1;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v2;       // [bp-0xc]\n  unsigned long long v5; // rax\n  unsigned long long v7; // rax\n\n  v2 = -1;\n  v1 = 0;\n  if ((int)create_attempt_directories(a0, a1, a2, a3, a4, a5)) {\n    free(v1);\n    return v2;\n  }\n  v0 = open_file_as_task_tracker(a5);\n  if (v0 != -1) {\n    v1 = get_task_launcher_file(a4, a1, a2, a3, a4, a5);\n    if (!v1) {\n      v2 = 18;\n    } else if (!(int)copy_file(v0, a5, v1, 448)) {\n      fcloseall();\n      umask(23);\n      if (chdir(a4)) {\n        (unsigned int)v5 = strerror(*(__errno_location()));\n        fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", (unsigned int)a4,\n                (unsigned int)v5);\n      } else if ((int)change_user(user_detail->field_10,\n                                  user_detail->field_14)) {\n        v2 = 6;\n      } else if (!execlp(v1, v1)) {\n        v2 = 0;\n      } else {\n        (unsigned int)v7 = strerror(*(__errno_location()));\n        fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\",\n                (unsigned int)v1, (unsigned int)v7);\n        v2 = 7;\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpufkk4y2e/run_task_as_user.c:28:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 28 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpufkk4y2e/run_task_as_user.c:29:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 29 | extern struct_0 *user_detail; |        ^~~~~~~~ |\nstruct /tmp/tmpufkk4y2e/run_task_as_user.c:29:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmpufkk4y2e/run_task_as_user.c:60:45: error:\nindirection requires pointer operand ('int' invalid) 60 | (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpufkk4y2e/run_task_as_user.c:63:52: error: member reference type 'int' is\nnot a pointer 63 |             else if ((int)change_user(user_detail->field_10,\nuser_detail->field_14)) |                                       ~~~~~~~~~~~  ^\n/tmp/tmpufkk4y2e/run_task_as_user.c:63:75: error: member reference type 'int' is\nnot a pointer 63 |             else if ((int)change_user(user_detail->field_10,\nuser_detail->field_14)) | ~~~~~~~~~~~  ^\n/tmp/tmpufkk4y2e/run_task_as_user.c:73:45: error: indirection requires pointer\noperand ('int' invalid) 73 |                 (unsigned int)v7 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int signal_user_task(const char *user, int pid, int sig) {\n    if (pid <= 0) {\n        return INVALID_TASK_PID;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return SETUID_OPER_FAILED;\n    }\n    int has_group = 1;\n    if (kill(-pid, 0) < 0) {\n        if (kill(pid, 0) < 0) {\n            if ((*__errno_location()) == 3) {\n                return INVALID_TASK_PID;\n            }\n            fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\", pid, sig, strerror((*__errno_location())));\n            return -1;\n        } else {\n            has_group = 0;\n        }\n    }\n    if (kill((has_group ? -1 : 1) * pid, sig) < 0) {\n        if ((*__errno_location()) != 3) {\n            fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\", -pid, sig, strerror((*__errno_location())));\n            return UNABLE_TO_KILL_TASK;\n        } else {\n            return INVALID_TASK_PID;\n        }\n    }\n    fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", (has_group ? \"group \" : \"\"), pid, sig);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(change_user)(long long, long long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern char g_40b0af;\nextern char g_40b0b6;\nextern struct_0 *user_detail;\n\nlong long signal_user_task(unsigned long a0, unsigned long a1,\n                           unsigned long a2) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned int v1;        // [bp-0xc]\n  unsigned long long v6;  // rax\n  unsigned long long v8;  // rax\n  unsigned int v10;       // eax\n  unsigned long long v12; // rax\n\n  v0 = a0;\n  if ((unsigned int)a1 <= 0) {\n    return 9;\n  } else if (!(int)change_user(user_detail->field_10, user_detail->field_14)) {\n    v1 = 1;\n    if (kill(-((unsigned int)a1), 0) < 0) {\n      if (kill(a1, 0) >= 0) {\n        v1 = 0;\n      } else if (*(__errno_location()) != 3) {\n        (unsigned int)v8 = strerror(*(__errno_location()));\n        fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\",\n                (unsigned int)a1, (unsigned int)a2, (unsigned int)v8);\n        return 4294967295;\n      } else {\n        return 9;\n      }\n    }\n    (unsigned int)v6 = kill((unsigned int)a1 * (!v1 ? -1 : 1), a2);\n    if ((unsigned int)v6 >= 0) {\n      if (!v1)\n        v10 = &g_40b0b6;\n      else\n        v10 = &g_40b0af;\n      fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", v10, (unsigned int)a1,\n              (unsigned int)a2);\n      return 0;\n    } else if (*(__errno_location()) != 3) {\n      (unsigned int)v12 = strerror(*(__errno_location()));\n      fprintf(LOGFILE,\n              \"Error signalling process group %d with signal %d - %s\\n\",\n              -((unsigned int)a1), (unsigned int)a2, (unsigned int)v12);\n      return 8;\n    } else {\n      return 9;\n    }\n  } else {\n    return 6;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6aquvpa4/signal_user_task.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp6aquvpa4/signal_user_task.c:24:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 24 | extern struct_0 *user_detail; |        ^~~~~~~~ |\nstruct /tmp/tmp6aquvpa4/signal_user_task.c:24:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmp6aquvpa4/signal_user_task.c:40:45: error:\nmember reference type 'int' is not a pointer 40 |     else if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmp6aquvpa4/signal_user_task.c:40:68: error: member reference type 'int'\nis not a pointer 40 |     else if (!(int)change_user(user_detail->field_10,\nuser_detail->field_14)) | ~~~~~~~~~~~  ^\n/tmp/tmp6aquvpa4/signal_user_task.c:49:22: error: indirection requires pointer\noperand ('int' invalid) 49 |             else if (*(__errno_location()) != 3) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp6aquvpa4/signal_user_task.c:51:45: error:\nindirection requires pointer operand ('int' invalid) 51 | (unsigned int)v8 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6aquvpa4/signal_user_task.c:60:9: error: assignment to cast is illegal,\nlvalue casts are not supported 60 |         (unsigned int)v6 = kill((unsigned\nint)a1 * (!v1 ? -1 : 1), a2); |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp6aquvpa4/signal_user_task.c:70:18: error: indirection requires pointer\noperand ('int' invalid) 70 |         else if (*(__errno_location()) != 3) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp6aquvpa4/signal_user_task.c:72:42: error:\nindirection requires pointer operand ('int' invalid) 72 |             (unsigned\nint)v12 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 10 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int rmdir_as_tasktracker(const char *path) {\n    int user_uid = geteuid();\n    int user_gid = getegid();\n    int ret = change_effective_user(tt_uid, tt_gid);\n    if (ret == 0) {\n        if (rmdir(path) != 0) {\n            fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user_uid, user_gid) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nunsigned int(getegid)();\nlong long(change_effective_user)(long long, long long);\nint(rmdir)(char *);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern unsigned int tt_gid;\nextern unsigned int tt_uid;\n\nlong long rmdir_as_tasktracker_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x14]\n  unsigned int v1;       // [bp-0x10]\n  unsigned int v2;       // [bp-0xc]\n  unsigned long long v5; // rax\n\n  v1 = geteuid();\n  v0 = getegid();\n  v2 = change_effective_user(tt_uid, tt_gid);\n  if (!v2 && rmdir(a0)) {\n    (unsigned int)v5 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", (unsigned int)a0,\n            (unsigned int)v5);\n    v2 = -1;\n  }\n  if ((int)change_effective_user(v1, v0)) {\n    v2 = -1;\n    return v2;\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptwbs2ljp/rmdir_as_tasktracker_name_conflict.c:22:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmptwbs2ljp/rmdir_as_tasktracker_name_conflict.c:38:37: error: indirection requires\npointer operand ('int' invalid) 38 |         (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int delete_path(const char *full_path, int needs_tt_user) {\n    int exit_code = 0;\n    if (full_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Path is null\\n\");\n        exit_code = UNABLE_TO_BUILD_PATH;\n    } else {\n        char *(paths[]) = {strdup(full_path), 0};\n        if (paths[0] == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc failed in delete_path\\n\");\n            return -1;\n        }\n        if (access(full_path, 0) != 0) {\n            if ((*__errno_location()) == 2) {\n                free(paths[0]);\n                return 0;\n            }\n        }\n        FTS *tree = fts_open(paths, 16 | 64, ((void *)0));\n        FTSENT *entry = ((void *)0);\n        int ret = 0;\n        if (tree == ((void *)0)) {\n            fprintf(LOGFILE, \"Cannot open file traversal structure for the path %s:%s.\\n\", full_path, strerror((*__errno_location())));\n            free(paths[0]);\n            return -1;\n        }\n        while (((entry = fts_read(tree)) != ((void *)0)) && exit_code == 0)\n            {\n                switch (entry->fts_info) {\n                  case 6:\n                    if (!needs_tt_user || strcmp(entry->fts_path, full_path) != 0) {\n                        if (rmdir(entry->fts_accpath) != 0) {\n                            fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                            exit_code = -1;\n                        }\n                    }\n                    break;\n                  case 8:\n                  case 12:\n                  case 13:\n                  case 3:\n                    if (unlink(entry->fts_accpath) != 0) {\n                        fprintf(LOGFILE, \"Couldn't delete file %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                        exit_code = -1;\n                    }\n                    break;\n                  case 4:\n                    fprintf(LOGFILE, \"Unreadable directory %s. Skipping..\\n\", entry->fts_path);\n                    break;\n                  case 1:\n                    if ((entry->fts_statp->st_mode & 128) == 0) {\n                        fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\", entry->fts_path);\n                        if (chmod(entry->fts_accpath, 448) != 0) {\n                            fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\", entry->fts_path, strerror((*__errno_location())));\n                        }\n                    }\n                    break;\n                  case 10:\n                    fprintf(LOGFILE, \"Directory not found %s\\n\", entry->fts_path);\n                    break;\n                  case 2:\n                  case 5:\n                  case 11:\n                    break;\n                  case 7:\n                    fprintf(LOGFILE, \"Error traversing directory %s - %s\\n\", entry->fts_path, strerror(entry->fts_errno));\n                    exit_code = -1;\n                    break;\n                    break;\n                  default:\n                    exit_code = -1;\n                    break;\n                }\n            }\n        ret = fts_close(tree);\n        if (exit_code == 0 && ret != 0) {\n            fprintf(LOGFILE, \"Error in fts_close while deleting %s\\n\", full_path);\n            exit_code = -1;\n        }\n        if (needs_tt_user) {\n            exit_code = rmdir_as_tasktracker(full_path);\n        }\n        free(paths[0]);\n    }\n    return exit_code;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nint(access)(char *, int);\nchar *(strerror)(int);\nlong long(rmdir_as_tasktracker)(long long);\nint(unlink)(char *);\nint(rmdir)(char *);\nint(chmod)(char *, unsigned short);\n\ntypedef struct struct_3 {\n  char padding_0[40];\n  unsigned long long field_28;\n  unsigned long long field_30;\n  unsigned int field_38;\n  char padding_3c[38];\n  unsigned short field_62;\n  char padding_64[4];\n  struct struct_1 *field_68;\n} struct_3;\n\ntypedef struct struct_2 {\n  char padding_0[40];\n  char *field_28;\n  char *field_30;\n  unsigned int field_38;\n  char padding_3c[38];\n  unsigned short field_62;\n  char padding_64[4];\n  struct struct_1 *field_68;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[4240008];\n  unsigned int field_40b288;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[24];\n  unsigned int field_18;\n} struct_1;\n\nextern FILE_t *LOGFILE;\nextern char g_40b288;\n\nlong long delete_path_name_conflict(char *a0, unsigned long a1) {\n  void *v0;               // [bp-0x38]\n  void *v1;               // [bp-0x30]\n  unsigned int v2;        // [bp-0x24]\n  struct_2 *v3;           // [bp-0x20], Other Possible Types: struct_3 *\n  unsigned long long v4;  // [bp-0x18]\n  unsigned int v5;        // [bp-0xc]\n  struct_0 *v9;           // rax\n  unsigned long long v12; // rax\n  unsigned long long v14; // rax\n  unsigned long long v16; // rax\n  unsigned long long v18; // rax\n\n  v5 = 0;\n  if (!a0) {\n    fwrite(\"Path is null\\n\", 1, 13, LOGFILE);\n    v5 = 21;\n  } else {\n    v0 = strdup(a0);\n    v1 = 0;\n    if (!v0) {\n      fwrite(\"Malloc failed in delete_path_name_conflict\\n\", 1, 29, LOGFILE);\n      return 4294967295;\n    }\n    if (access(a0, 0) && *(__errno_location()) == 2) {\n      free(v0);\n      return 0;\n    }\n    v4 = fts_open(&v0, 80, 0);\n    v3 = 0;\n    v2 = 0;\n    if (!v4) {\n      (unsigned int)v18 = strerror(*(__errno_location()));\n      fprintf(LOGFILE,\n              \"Cannot open file traversal structure for the path %s:%s.\\n\",\n              (unsigned int)a0, (unsigned int)v18);\n      free(v0);\n      return 4294967295;\n    }\n    while (true) {\n      v3 = fts_read(v4);\n      if (!v3 || v5)\n        break;\n      v9 = v3->field_62;\n      switch ((unsigned int)v9) {\n      case 1:\n        if (!((char)v3->field_68->field_18 & 128)) {\n          fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\",\n                  (unsigned int)v3->field_30);\n          if (chmod(v3->field_28, 448)) {\n            (unsigned int)v14 = strerror(*(__errno_location()));\n            fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\",\n                    (unsigned int)v3->field_30, (unsigned int)v14);\n            break;\n          }\n        }\n      case 2:\n      case 5:\n      case 11:\n        break;\n      case 3:\n      case 8:\n      case 12:\n      case 13:\n        if (unlink(v3->field_28)) {\n          (unsigned int)v12 = strerror(*(__errno_location()));\n          fprintf(LOGFILE, \"Couldn't delete file %s - %s\\n\",\n                  (unsigned int)v3->field_30, (unsigned int)v12);\n          v5 = -1;\n          break;\n        }\n      case 4:\n        fprintf(LOGFILE, \"Unreadable directory %s. Skipping..\\n\",\n                (unsigned int)v3->field_30);\n        break;\n      case 6:\n        if ((!(unsigned int)a1 || strcmp(v3->field_30, a0)) &&\n            rmdir(v3->field_28)) {\n          (unsigned int)v16 = strerror(*(__errno_location()));\n          fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\",\n                  (unsigned int)v3->field_30, (unsigned int)v16);\n          v5 = -1;\n          break;\n        }\n      case 7:\n        fprintf(LOGFILE, \"Error traversing directory %s - %s\\n\",\n                (unsigned int)v3->field_30,\n                (unsigned int)strerror(v3->field_38));\n        v5 = -1;\n        break;\n      case 10:\n        fprintf(LOGFILE, \"Directory not found %s\\n\",\n                (unsigned int)v3->field_30);\n        break;\n      default:\n        v5 = -1;\n        break;\n      }\n    }\n    v2 = fts_close(v4);\n    if (!v5 && v2) {\n      fprintf(LOGFILE, \"Error in fts_close while deleting %s\\n\",\n              (unsigned int)a0);\n      v5 = -1;\n    }\n    if ((unsigned int)a1)\n      v5 = rmdir_as_tasktracker(a0);\n    free(v0);\n  }\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9sceuzfl/delete_path_name_conflict.c:56:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 56 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp9sceuzfl/delete_path_name_conflict.c:88:30: error: indirection requires pointer\noperand ('int' invalid) 88 |         if (access(a0, 0) && *(__errno_location())\n== 2) |                              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9sceuzfl/delete_path_name_conflict.c:98:42: error: indirection requires pointer\noperand ('int' invalid) 98 |             (unsigned int)v18 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9sceuzfl/delete_path_name_conflict.c:117:54: error: indirection requires pointer\noperand ('int' invalid) 117 |                         (unsigned int)v14 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9sceuzfl/delete_path_name_conflict.c:127:50: error: indirection requires pointer\noperand ('int' invalid) 127 |                     (unsigned int)v12 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9sceuzfl/delete_path_name_conflict.c:138:50: error: indirection requires pointer\noperand ('int' invalid) 138 |                     (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_as_user(const char *user, const char *good_local_dirs, const char *subdir) {\n    int ret = 0;\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    char **ptr;\n    if (tt_roots == ((void *)0) || *tt_roots == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    for (ptr = tt_roots; *ptr != ((void *)0); ++ptr) {\n        char *full_path = get_user_subdirectory(*ptr, user, subdir);\n        if (full_path == ((void *)0)) {\n            return -1;\n        }\n        int this_ret = delete_path(full_path, strlen(subdir) == 0);\n        free(full_path);\n        if (this_ret != 0) {\n            ret = this_ret;\n        }\n    }\n    free_values(tt_roots);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_mapred_local_dirs)(long long);\nlong long(free_values)(long long);\nlong long(get_user_subdirectory)(long long, long long, long long, long long,\n                                 long long, long long);\nlong long(delete_path)(long long, long long);\n\nextern FILE_t *LOGFILE;\n\nlong long delete_as_user(unsigned long long a0, unsigned long long a1, char *a2,\n                         unsigned long a3, unsigned long long a4,\n                         unsigned long long a5) {\n  unsigned int v0;        // [bp-0x2c]\n  void *v1;               // [bp-0x28]\n  unsigned long long *v2; // [bp-0x20]\n  unsigned long long *v3; // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v4;        // [bp-0xc]\n\n  v4 = 0;\n  v2 = get_mapred_local_dirs(a1);\n  if (v2 && *(v2)) {\n    for (v3 = v2; *(v3); v3 += 1) {\n      v1 = get_user_subdirectory(*(v3), a0, a2, a0, a4, a5);\n      if (!v1)\n        return 4294967295;\n      v0 = delete_path(v1, !*(a2));\n      free(v1);\n      if (v0)\n        v4 = v0;\n    }\n    free_values(v2);\n    return v4;\n  }\n  fwrite(\"Good mapred local directories could ot be obtained.\\n\", 1, 52,\n         LOGFILE);\n  return 5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz6b4n3el/delete_as_user.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_log_directory(const char *subdir, const char *good_local_dirs) {\n    char *job_log_dir = get_job_log_directory(subdir);\n    int ret = -1;\n    if (job_log_dir == ((void *)0))\n        return ret;\n    delete_path(job_log_dir, 1);\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *mapred_local_log_dir = concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2, *local_dir_ptr, subdir);\n        if (mapred_local_log_dir != ((void *)0)) {\n            delete_path(mapred_local_log_dir, 1);\n            free(mapred_local_log_dir);\n        } else\n            fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\", subdir);\n    }\n    free(job_log_dir);\n    free_values(local_dir);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_job_log_directory)(long long, long long, long long, long long,\n                                 long long, long long);\nlong long(delete_path)(long long, long long);\nlong long(get_mapred_local_dirs)(long long);\nlong long(concatenate)(long long, long long, long long, long long, long long,\n                       long long);\nlong long(free_values)(long long);\n\nextern FILE_t *LOGFILE;\n\nlong long delete_log_directory(unsigned long long a0, unsigned long long a1,\n                               unsigned long long a2, unsigned long long a3,\n                               unsigned long long a4, unsigned long long a5) {\n  void *v0;               // [bp-0x30]\n  unsigned long long *v1; // [bp-0x28]\n  unsigned int v2;        // [bp-0x1c]\n  void *v3;               // [bp-0x18]\n  unsigned long long *v4; // [bp-0x10], Other Possible Types: unsigned long\n  char v5;                // [bp-0x8]\n  unsigned long long v7;  // rbp\n\n  v7 = &v5;\n  v3 = get_job_log_directory(a0, a1, a2, a3, a4, a5);\n  v2 = -1;\n  if (!v3)\n    return v2;\n  delete_path(v3, 1);\n  v1 = get_mapred_local_dirs(a1);\n  for (v4 = v1; *(v4); v4 += 1) {\n    v0 = concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2, *(v4), a0,\n                     a5);\n    if (!v0) {\n      fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\",\n              (unsigned int)a0);\n    } else {\n      delete_path(v0, 1);\n      free(v0);\n    }\n  }\n  free(v3);\n  free_values(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf8d2lxw0/delete_log_directory.c:22:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_command_as_user(const char *user, char *const *args) {\n    if (user == ((void *)0)) {\n        fprintf(LOGFILE, \"The user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(change_user)(long long, long long);\nint(execvp)(char *, char *[0]);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern struct_0 *user_detail;\n\nlong long run_command_as_user_name_conflict(unsigned long a0, char **a1) {\n  unsigned long long v3; // rax\n\n  if (!a0) {\n    fwrite(\"The user passed is null.\\n\", 1, 25, LOGFILE);\n    return 1;\n  } else if (!(int)change_user(user_detail->field_10, user_detail->field_14)) {\n    execvp(*(a1), a1);\n    (unsigned int)v3 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\", (unsigned int)v3);\n    return 4294967295;\n  } else {\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps1px0e0m/run_command_as_user_name_conflict.c:22:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmps1px0e0m/run_command_as_user_name_conflict.c:23:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 23 | extern struct_0 *user_detail; | ^~~~~~~~\n      |        struct\n/tmp/tmps1px0e0m/run_command_as_user_name_conflict.c:23:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmps1px0e0m/run_command_as_user_name_conflict.c:34:45: error:\nmember reference type 'int' is not a pointer 34 |     else if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmps1px0e0m/run_command_as_user_name_conflict.c:34:68: error: member reference type\n'int' is not a pointer 34 |     else if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmps1px0e0m/run_command_as_user_name_conflict.c:37:37: error: indirection requires\npointer operand ('int' invalid) 37 |         (unsigned int)v3 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int is_only_root_writable(const char *file) {\n    struct stat file_stat;\n    if (stat(file, &file_stat) != 0) {\n        fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", file, strerror((*__errno_location())));\n        return 0;\n    }\n    if (file_stat.st_uid != 0) {\n        fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\", file, file_stat.st_uid);\n        return 0;\n    }\n    if ((file_stat.st_mode & ((128 >> 3) | ((128 >> 3) >> 3))) != 0) {\n        fprintf(LOGFILE, \"File %s must not be world or group writable, but is %03o\\n\", file, file_stat.st_mode & (~61440));\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nchar *(strerror)(int);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern FILE_t *LOGFILE;\n\nlong long is_only_root_writable_name_conflict(char *a0) {\n  stat v0;               // [bp-0x98]\n  int tmp_16;            // tmp #16\n  char v1;               // [bp-0x80]\n  char v2;               // [bp-0x7c]\n  unsigned long long v5; // rax\n  unsigned long long v7; // rax\n\n  if (stat(a0, &v0)) {\n    (unsigned int)v5 = strerror(*(__errno_location()));\n    fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", (unsigned int)a0,\n            (unsigned int)v5);\n    return 0;\n  } else if (*((int *)&v2)) {\n    fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\",\n            (unsigned int)a0, *((int *)&v2));\n    return 0;\n  } else if (((char)*((int *)&v1) & 18)) {\n    v7 = *((int *)&v1);\n    *((char *)&v7) = (char)v7 & 15;\n    tmp_16 = v7;\n    fprintf(LOGFILE,\n            \"File %s must not be world or group writable, but is %03o\\n\",\n            (unsigned int)a0, (int)tmp_16);\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpijx20qix/is_only_root_writable_name_conflict.c:48:3: error: redefinition of 'stat' as\ndifferent kind of symbol 48 | } stat; |   ^\n/tmp/tmpijx20qix/is_only_root_writable_name_conflict.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpijx20qix/is_only_root_writable_name_conflict.c:50:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 50 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpijx20qix/is_only_root_writable_name_conflict.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpijx20qix/is_only_root_writable_name_conflict.c:16:6: note: struct 'stat' is hidden by\na non-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^\n/tmp/tmpijx20qix/is_only_root_writable_name_conflict.c:63:37: error: indirection requires\npointer operand ('int' invalid) 63 |         (unsigned int)v5 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int check_configuration_permissions(const char *file_name) {\n    char *dir = strdup(file_name);\n    char *buffer = dir;\n    do {\n        if (!is_only_root_writable(dir)) {\n            free(buffer);\n            return -1;\n        }\n        dir = dirname(dir);\n    } while (strcmp(dir, \"/\") != 0);\n    free(buffer);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(is_only_root_writable)(long long);\nchar *(dirname)(char *);\n\nlong long check_configuration_permissions_name_conflict(char *a0) {\n  void *v0; // [bp-0x18]\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = strdup(a0);\n  v0 = v1;\n  while ((int)is_only_root_writable(v1)) {\n    v1 = dirname(v1);\n    if (!strcmp(v1, \"/\")) {\n      free(v0);\n      return 0;\n    }\n  }\n  free(v0);\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char *get_value(const char *key) {\n    int count;\n    for (count = 0; count < config.size; count++) {\n        if (strcmp(config.confdetails[count]->key, key) == 0) {\n            return strdup(config.confdetails[count]->value);\n        }\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nextern unsigned int config;\nextern unsigned long long g_40d2e8;\n\nlong long get_value_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 0;\n  while (true) {\n    if (v0 >= config) {\n      return 0;\n    } else if (strcmp(*((long long *)*((long long *)(g_40d2e8 + (v0 << 3)))),\n                      a0)) {\n      v0 += 1;\n    } else {\n      return strdup(*((long long *)(*((long long *)(g_40d2e8 + v0 * 8)) + 8)));\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **get_values(const char *key) {\n    char *value = get_value(key);\n    return extract_values(value);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_value)(long long);\nlong long(extract_values)(long long);\n\nlong long get_values_name_conflict(unsigned long long a0) {\n  unsigned long long v0; // [bp-0x10]\n\n  v0 = get_value(a0);\n  return extract_values(v0);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **extract_values(char *value) {\n    char **toPass = ((void *)0);\n    char *tempTok = ((void *)0);\n    char *tempstr = ((void *)0);\n    int size = 0;\n    int toPassSize = 10;\n    if (value != ((void *)0)) {\n        toPass = (char **)malloc(sizeof(char *) * toPassSize);\n        tempTok = strtok_r((char *)value, \",\", &tempstr);\n        while (tempTok != ((void *)0))\n            {\n                toPass[size++] = tempTok;\n                if (size == toPassSize) {\n                    toPassSize += 10;\n                    toPass = (char **)realloc(toPass, (sizeof(char *) * (10 * toPassSize)));\n                }\n                tempTok = strtok_r(((void *)0), \",\", &tempstr);\n            }\n    }\n    if (size > 0) {\n        toPass[size] = ((void *)0);\n    }\n    return toPass;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok_r)(char *, char *, char **);\nvoid *(realloc)(void *, unsigned long);\n\nlong long extract_values_name_conflict(char *a0) {\n  void *v0;               // [bp-0x28]\n  unsigned int v1;        // [bp-0x20]\n  unsigned int v2;        // [bp-0x1c]\n  void *v3;               // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long long *v4; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long v6;       // rax\n\n  v4 = 0;\n  v3 = 0;\n  v0 = 0;\n  v2 = 0;\n  v1 = 10;\n  if (a0) {\n    v4 = malloc(v1 * 8);\n    for (v3 = strtok_r(a0, \",\", &v0); v3; v3 = strtok_r(NULL, \",\", &v0)) {\n      v6 = v2;\n      v2 = (unsigned int)v6 + 1;\n      *((unsigned long *)(v6 * 8 + v4)) = v3;\n      if (v2 == v1) {\n        v1 += 10;\n        v4 = realloc(v4, 5 * v1 * 2 * 8);\n      }\n    }\n  }\n  if (v2 > 0)\n    *((long long *)(v4 + v2 * 8)) = 0;\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int write_config_file(char *file_name) {\n    FILE *file;\n    file = fopen(file_name, \"w\");\n    if (file == ((void *)0)) {\n        printf(\"Failed to open %s.\\n\", file_name);\n        return 1;\n    }\n    fprintf(file, \"mapred.local.dir=/tmp/test-task-controller/local-1\");\n    int i;\n    for (i = 2; i < 5; ++i) {\n        fprintf(file, \",/tmp/test-task-controller/local-%d\", i);\n    }\n    fprintf(file, \"\\n\");\n    fprintf(file, \"hadoop.log.dir=/tmp/test-task-controller/logs\\n\");\n    fclose(file);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long write_config_file_name_conflict(char *a0) {\n  FILE_t *v0;      // [bp-0x18]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = &fopen(a0, \"w\")->_flags;\n  if (!v0) {\n    printf(\"Failed to open %s.\\n\", (unsigned int)a0);\n    return 1;\n  }\n  fwrite(\"mapred.local.dir=/tmp/test-task-controller/local-1\", 1, 50, v0);\n  for (v1 = 2; v1 <= 4; v1 += 1) {\n    fprintf(v0, \",/tmp/test-task-controller/local-%d\", v1);\n  }\n  fputc(10, v0);\n  fwrite(\"hadoop.log.dir=/tmp/test-task-controller/logs\\n\", 1, 46, v0);\n  fclose(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:16:6: error: conflicting types for 'fputc'\n   16 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:141:16: error: redefinition of '_IO_marker'\n  141 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:147:16: error: redefinition of\n'_IO_codecvt' 147 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:151:16: error: redefinition of\n'_IO_wide_data' 151 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpuqz8sk8b/write_config_file_name_conflict.c:174:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 174 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/test/test-task-controller.c"}
{"compilable":1,"function":"int edgecmp(Fibnode *a, Fibnode *b) {\n    Edge *e, *f;\n    e = (Edge *)a;\n    f = (Edge *)b;\n    if (e->dist < f->dist)\n        return -1;\n    if (e->dist > f->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned int field_38;\n} struct_0;\n\nlong long edgecmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  return (a0->field_38 < a1->field_38 ? (a0->field_38 <= a1->field_38 ? 1 : 0)\n                                      : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":0,"function":"int prim(int start) {\n    Fibheap pq;\n    Node *n;\n    Edge *e;\n    int primsum;\n    fibinit(&pq, edgecmp);\n    n = nodedata(start);\n    n->intree = 1;\n    primsum = 0;\n    insertedges(&pq, n);\n    while (pq.min != ((void *)0))\n        {\n            e = (Edge *)pq.min;\n            if (fibdeletemin(&pq) < 0)\n                sysfatal(\"deletion failed\");\n            n = e->node;\n            if (n->intree)\n                continue;\n            n->intree = 1;\n            primsum += e->dist;\n            insertedges(&pq, n);\n        }\n    fibfree(&pq);\n    return primsum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint edgecmp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fibinit)(long long, long long);\nlong long(nodedata)(long long);\nlong long(insertedges)(long long, long long);\nlong long(fibfree)(long long);\nlong long(fibdeletemin)(long long);\nlong long(sysfatal)(...);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[48];\n  struct struct_0 *field_30;\n  unsigned int field_38;\n} struct_1;\n\nlong long prim_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x48]\n  char v1;         // [bp-0x40]\n  struct_1 *v2;    // [bp-0x20]\n  struct_0 *v3;    // [bp-0x18]\n  unsigned int v4; // [bp-0xc]\n\n  fibinit(&v0, edgecmp);\n  v3 = nodedata((unsigned int)a0);\n  v3->field_10 = 1;\n  v4 = 0;\n  insertedges(&v0, v3);\n  while (*((long long *)&v1)) {\n    v2 = *((long long *)&v1);\n    if ((int)fibdeletemin(&v0) < 0)\n      sysfatal(); /* do not return */\n    v3 = v2->field_30;\n    if (!v3->field_10) {\n      v3->field_10 = 1;\n      v4 += v2->field_38;\n      insertedges(&v0, v3);\n    }\n  }\n  fibfree(&v0);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn56ugt1q/prim_name_conflict.c:22:22: error: ISO C requires a named parameter before\n'...' 22 | long long (sysfatal)(...); |                      ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":1,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[40];\n  unsigned int field_28;\n} struct_0;\n\nlong long intcmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  return (a0->field_28 < a1->field_28 ? (a0->field_28 <= a1->field_28 ? 1 : 0)\n                                      : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/fibheaptest.c"}
{"compilable":1,"function":"int nodecmp(Fibnode *a, Fibnode *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    if (m->dist < n->dist)\n        return -1;\n    if (m->dist > n->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned int field_38;\n} struct_0;\n\nlong long nodecmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  return (a0->field_38 < a1->field_38 ? (a0->field_38 <= a1->field_38 ? 1 : 0)\n                                      : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/dijkstra.c"}
{"compilable":1,"function":"int Intcmp(Avl *a, Avl *b) {\n    Int *ai, *bi;\n    ai = (Int *)a;\n    bi = (Int *)b;\n    if (ai->i < bi->i)\n        return -1;\n    if (ai->i > bi->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[32];\n  unsigned int field_20;\n} struct_0;\n\nlong long Intcmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  return (a0->field_20 < a1->field_20 ? (a0->field_20 <= a1->field_20 ? 1 : 0)\n                                      : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":1,"function":"int depth(Avl *n) {\n    int dl, dr, d;\n    if (n == ((void *)0))\n        return 0;\n    dl = depth(n->c[0]);\n    dr = depth(n->c[1]);\n    d = dl > dr ? dl : dr;\n    return d + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(depth_name_conflict)(unsigned long long[2]);\n\nlong long depth_name_conflict(unsigned long long a0[2]) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n  unsigned int v5; // eax\n\n  if (!a0)\n    return 0;\n  v2 = depth_name_conflict(a0[0]);\n  v1 = depth_name_conflict(a0[1]);\n  v5 = v2;\n  if (v5 <= v5)\n    v5 = v1;\n  v0 = v5;\n  return v0 + 1;\n}\n","pass":1,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int nodecmp(Avl *a, Avl *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    return strcmp(m->key, n->key);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[32];\n  char *field_20;\n} struct_0;\n\nlong long nodecmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  return strcmp(a0->field_20, a1->field_20);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/avlexample.c"}
{"compilable":1,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[40];\n  unsigned int field_28;\n} struct_0;\n\nlong long intcmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  return (a0->field_28 < a1->field_28 ? (a0->field_28 <= a1->field_28 ? 1 : 0)\n                                      : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/fibheaptest.c"}
{"compilable":1,"function":"uint32_t pcg32_random_r(pcg32_random_t *rng) {\n    uint64_t oldstate = rng->state;\n    rng->state = oldstate * 6364136223846793005ULL + rng->inc;\n    uint32_t xorshifted = ((oldstate >> 18U) ^ oldstate) >> 27U;\n    uint32_t rot = oldstate >> 59U;\n    return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pcg32_random_r_name_conflict(unsigned long long a0[2]) {\n  unsigned int v0;       // [bp-0x18]\n  unsigned int v1;       // [bp-0x14]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long long v6; // rdx\n\n  v2 = a0[0];\n  a0[0] = v2 * 6364136223846793005 + a0[1];\n  v1 = (v2 >> 18 ^ v2) >> 27;\n  v0 = v2 >> 59;\n  v6 = v1 >> ((char)v0 & 31 & 31) | v1 << 32 - ((char)v0 & 31 & 31);\n  return v6;\n}\n","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_random() {\n    return pcg32_random_r(&pcg32_global);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pcg32_random_name_conflict_r)(long long);\n\nextern unsigned long long pcg32_global;\n\nlong long pcg32_random_name_conflict() { return pcg32_random_name_conflict_r(&pcg32_global); }\n","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_boundedrand_r(pcg32_random_t *rng, uint32_t bound) {\n    uint32_t threshold = -bound % bound;\n    for (;;) {\n        uint32_t r = pcg32_random_r(rng);\n        if (r >= threshold)\n            return r % bound;\n    }\n}\n","function_prediction":"int set_user(char *user) {\n  if (user_detail) {\n    free(user_detail);\n    user_detail = NULL;\n  }\n\n  user_detail = check_user(user);\n  if (!user_detail)\n    return -1;\n\n  return change_effective_user(user_detail->uid, user_detail->gid);\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_boundedrand(uint32_t bound) {\n    return pcg32_boundedrand_r(&pcg32_global, bound);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pcg32_boundedrand_name_conflict_r)(long long, long long);\n\nextern unsigned long long pcg32_global;\n\nlong long pcg32_boundedrand_name_conflict(unsigned long a0) {\n  return pcg32_boundedrand_name_conflict_r(&pcg32_global, (unsigned int)a0);\n}\n","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":1,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4202712];\n  unsigned int field_4020d8;\n} struct_0;\n\nextern char g_40207b;\nextern char g_40207f;\nextern char g_402083;\nextern char g_402087;\nextern char g_4020d8;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  if ((unsigned int)a0 < 27)\n    return \"unknown\";\n  switch ((unsigned int)a0) {\n  case 1444872192:\n    return \"Tab\";\n  case 1444872194:\n    return \"F1\";\n  case 1444872195:\n    return \"F2\";\n  case 1444872196:\n    return \"F3\";\n  case 1444872197:\n    return \"F4\";\n  case 1444872198:\n    return \"F5\";\n  case 1444872199:\n    return \"F6\";\n  case 1444872200:\n    return \"F7\";\n  case 1444872201:\n    return \"F8\";\n  case 1444872202:\n    return \"F9\";\n  case 1444872203:\n    return \"F10\";\n  case 1444872204:\n    return \"F11\";\n  case 1444872205:\n    return \"F12\";\n  case 1444872230:\n    return &g_40207f;\n  case 1444872231:\n    return &g_402087;\n  case 1444872232:\n    return &g_402083;\n  case 1444872233:\n    return &g_40207b;\n  case 1444872234:\n    return \"CtrlUp\";\n  case 1444872235:\n    return \"CtrlDown\";\n  case 1444872236:\n    return \"CtrlRight\";\n  case 1444872237:\n    return \"CtrlLeft\";\n  case 1444872238:\n    return \"Enter\";\n  case 1444872239:\n    return \"Delete\";\n  case 1444872240:\n    return \"Backspace\";\n  case 1444872241:\n    return \"CtrlBackspace\";\n  case 1444872244:\n    return \"Insert\";\n  case 1444872245:\n    return \"Home\";\n  case 1444872246:\n    return \"PageUp\";\n  case 1444872247:\n    return \"PageDown\";\n  case 1444872248:\n    return \"End\";\n  default:\n    break;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  char v0;         // [bp-0x10]\n  char v1;         // [bp-0xf]\n  char v2;         // [bp-0xe]\n  char v3;         // [bp-0xd]\n  unsigned int v4; // [bp-0xc]\n\n  v0 = getc(stdin @GLIBC_2.2.5);\n  if ((v0 & 248) == 240) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v3 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 15;\n    v1 &= 127;\n    v2 &= 127;\n    v3 &= 127;\n    v4 = v0 * 0x40000 + v2 * 64 + v3 + v1 * 0x1000;\n    if (v4 <= 65535)\n      return 4294967295;\n  } else if ((v0 & 240) == 224) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 31;\n    v1 &= 127;\n    v2 &= 127;\n    v4 = v0 * 0x1000 + v1 * 64 + v2;\n    if (v4 <= 2047)\n      return 4294967295;\n  } else if ((v0 & 224) == 192) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 63;\n    v1 &= 127;\n    v4 = v1 + v0 * 64;\n    if (v4 <= 127)\n      return 4294967295;\n  } else if (v0 >= 0) {\n    v4 = v0;\n  } else {\n    return 4294967295;\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:116:20: error: expected ')'\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:116:14: note: to match this '('\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:119:24: error: expected ')'\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:119:18: note: to match this '('\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:120:24: error: expected ')'\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:120:18: note: to match this '('\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:121:24: error: expected ')'\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:121:18: note: to match this '('\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:132:24: error: expected ')'\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:132:18: note: to match this '('\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:133:24: error: expected ')'\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:133:18: note: to match this '('\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:143:24: error: expected ')'\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmppqm2qiir/decode_regular_key_pressed.c:143:18: note: to match this '('\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\ntypedef struct struct_0 {\n  char padding_0[4202940];\n  unsigned int field_4021bc;\n} struct_0;\n\nextern char g_4021bc;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  char v0;               // [bp-0x15]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  struct_0 *v8;          // rax\n  unsigned int v10;      // eax\n\n  v6 = &v4;\n  v3 = getc(stdin @GLIBC_2.2.5);\n  if (v3 == 10) {\n    return 1444872238;\n  } else if (v3 == 9) {\n    return 0x561f0000;\n  } else if (v3 == 127) {\n    return 1444872240;\n  } else if (v3 == 8) {\n    return 1444872241;\n  } else {\n    if (!(v3 != -1 && v3 != -1))\n      return 4;\n    if (v3 == 23) {\n      return 1444872242;\n    } else if (!v3) {\n      return 1444872243;\n    } else if (v3 == 27) {\n      v3 = getc(stdin @GLIBC_2.2.5);\n      v2 = v3;\n      if (v3 == 79) {\n        v3 = getc(stdin @GLIBC_2.2.5);\n        if (!(v3 > 79 && v3 <= 83))\n          return 4294967295;\n        return v3 + 1444872114;\n      } else if (v3 == 91) {\n        v8 = getc(stdin @GLIBC_2.2.5) - 49;\n        switch ((unsigned int)v8) {\n        case 0:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          v1 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 59 && v1 == 53) {\n            v0 = getc(stdin @GLIBC_2.2.5);\n            v10 = v0;\n            if (v10 == 68) {\n              return 1444872237;\n            } else if (v10 <= 68) {\n              if (v10 == 67) {\n                return 1444872236;\n              } else if (v10 <= 67) {\n                if (v10 == 65) {\n                  return 1444872234;\n                } else if (v10 == 66) {\n                  return 1444872235;\n                }\n              }\n            }\n          }\n          if (v1 != 126) {\n            return 4294967295;\n          } else if (v3 == 54) {\n            return 4294967295;\n          } else if (v3 <= 57) {\n            if (v3 <= 54)\n              return v3 + 1444872145;\n            v3 -= 1;\n            break;\n          } else {\n            return 4294967295;\n          }\n        case 1:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 126) {\n            return 1444872244;\n          } else if (v3 == 50) {\n            return 4294967295;\n          } else if (v3 <= 52) {\n            if (v3 > 50)\n              v3 -= 1;\n            v7 = (getc(stdin @GLIBC_2.2.5) == 126 ? 4294967295\n                                                  : v3 + 1444872154);\n            return v7;\n          } else {\n            return 4294967295;\n          }\n        case 2:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872239);\n          return v7;\n        case 4:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872246);\n          return v7;\n        case 5:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872247);\n          return v7;\n        case 6:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872245);\n          return v7;\n        case 7:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872248);\n          return v7;\n        case 16:\n          return 1444872230;\n        case 17:\n          return 1444872231;\n        case 18:\n          return 1444872232;\n        case 19:\n          return 1444872233;\n        case 21:\n          return 1444872248;\n        case 23:\n          return 1444872245;\n        default:\n          return 4294967295;\n        }\n      } else {\n        ungetc(v2, stdin @GLIBC_2.2.5);\n        return 27;\n      }\n    } else {\n      ungetc(v3, stdin @GLIBC_2.2.5);\n      v7 = decode_regular_key_pressed();\n      return v7;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5p888xsu/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:202:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 202 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:202:21: error: expected ';' after top\nlevel declarator 202 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmp5p888xsu/decode_key_pressed.c:217:20: error: expected ')'\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:217:14: note: to match this '('\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:248:28: error: expected ')'\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:248:22: note: to match this '('\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                      ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:252:32: error: expected ')'\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                                ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:252:26: note: to match this '('\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                          ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:259:32: error: expected ')'\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                                ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:259:26: note: to match this '('\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                          ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:263:36: error: expected ')'\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:263:30: note: to match this '('\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:264:36: error: expected ')'\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmp5p888xsu/decode_key_pressed.c:264:30: note: to match this '('\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 <= 31 || ((unsigned int)a0 & 0x56000000) == 0x56000000)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4210892];\n  unsigned int field_4040cc;\n} struct_0;\n\nextern char g_40406f;\nextern char g_404073;\nextern char g_404077;\nextern char g_40407b;\nextern char g_4040cc;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  if ((unsigned int)a0 < 27)\n    return \"unknown\";\n  switch ((unsigned int)a0) {\n  case 1444872192:\n    return \"Tab\";\n  case 1444872194:\n    return \"F1\";\n  case 1444872195:\n    return \"F2\";\n  case 1444872196:\n    return \"F3\";\n  case 1444872197:\n    return \"F4\";\n  case 1444872198:\n    return \"F5\";\n  case 1444872199:\n    return \"F6\";\n  case 1444872200:\n    return \"F7\";\n  case 1444872201:\n    return \"F8\";\n  case 1444872202:\n    return \"F9\";\n  case 1444872203:\n    return \"F10\";\n  case 1444872204:\n    return \"F11\";\n  case 1444872205:\n    return \"F12\";\n  case 1444872230:\n    return &g_404073;\n  case 1444872231:\n    return &g_40407b;\n  case 1444872232:\n    return &g_404077;\n  case 1444872233:\n    return &g_40406f;\n  case 1444872234:\n    return \"CtrlUp\";\n  case 1444872235:\n    return \"CtrlDown\";\n  case 1444872236:\n    return \"CtrlRight\";\n  case 1444872237:\n    return \"CtrlLeft\";\n  case 1444872238:\n    return \"Enter\";\n  case 1444872239:\n    return \"Delete\";\n  case 1444872240:\n    return \"Backspace\";\n  case 1444872241:\n    return \"CtrlBackspace\";\n  case 1444872244:\n    return \"Insert\";\n  case 1444872245:\n    return \"Home\";\n  case 1444872246:\n    return \"PageUp\";\n  case 1444872247:\n    return \"PageDown\";\n  case 1444872248:\n    return \"End\";\n  default:\n    break;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  char v0;         // [bp-0x10]\n  char v1;         // [bp-0xf]\n  char v2;         // [bp-0xe]\n  char v3;         // [bp-0xd]\n  unsigned int v4; // [bp-0xc]\n\n  v0 = getc(stdin @GLIBC_2.2.5);\n  if ((v0 & 248) == 240) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v3 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 15;\n    v1 &= 127;\n    v2 &= 127;\n    v3 &= 127;\n    v4 = v0 * 0x40000 + v2 * 64 + v3 + v1 * 0x1000;\n    if (v4 <= 65535)\n      return 4294967295;\n  } else if ((v0 & 240) == 224) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 31;\n    v1 &= 127;\n    v2 &= 127;\n    v4 = v0 * 0x1000 + v1 * 64 + v2;\n    if (v4 <= 2047)\n      return 4294967295;\n  } else if ((v0 & 224) == 192) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 63;\n    v1 &= 127;\n    v4 = v1 + v0 * 64;\n    if (v4 <= 127)\n      return 4294967295;\n  } else if (v0 >= 0) {\n    v4 = v0;\n  } else {\n    return 4294967295;\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:116:20: error: expected ')'\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:116:14: note: to match this '('\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:119:24: error: expected ')'\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:119:18: note: to match this '('\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:120:24: error: expected ')'\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:120:18: note: to match this '('\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:121:24: error: expected ')'\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:121:18: note: to match this '('\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:132:24: error: expected ')'\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:132:18: note: to match this '('\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:133:24: error: expected ')'\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:133:18: note: to match this '('\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:143:24: error: expected ')'\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpdoegfnz3/decode_regular_key_pressed.c:143:18: note: to match this '('\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\ntypedef struct struct_0 {\n  char padding_0[4211120];\n  unsigned int field_4041b0;\n} struct_0;\n\nextern char g_4041b0;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  char v0;               // [bp-0x15]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  struct_0 *v8;          // rax\n  unsigned int v10;      // eax\n\n  v6 = &v4;\n  v3 = getc(stdin @GLIBC_2.2.5);\n  if (v3 == 10) {\n    return 1444872238;\n  } else if (v3 == 9) {\n    return 0x561f0000;\n  } else if (v3 == 127) {\n    return 1444872240;\n  } else if (v3 == 8) {\n    return 1444872241;\n  } else {\n    if (!(v3 != -1 && v3 != -1))\n      return 4;\n    if (v3 == 23) {\n      return 1444872242;\n    } else if (!v3) {\n      return 1444872243;\n    } else if (v3 == 27) {\n      v3 = getc(stdin @GLIBC_2.2.5);\n      v2 = v3;\n      if (v3 == 79) {\n        v3 = getc(stdin @GLIBC_2.2.5);\n        if (!(v3 > 79 && v3 <= 83))\n          return 4294967295;\n        return v3 + 1444872114;\n      } else if (v3 == 91) {\n        v8 = getc(stdin @GLIBC_2.2.5) - 49;\n        switch ((unsigned int)v8) {\n        case 0:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          v1 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 59 && v1 == 53) {\n            v0 = getc(stdin @GLIBC_2.2.5);\n            v10 = v0;\n            if (v10 == 68) {\n              return 1444872237;\n            } else if (v10 <= 68) {\n              if (v10 == 67) {\n                return 1444872236;\n              } else if (v10 <= 67) {\n                if (v10 == 65) {\n                  return 1444872234;\n                } else if (v10 == 66) {\n                  return 1444872235;\n                }\n              }\n            }\n          }\n          if (v1 != 126) {\n            return 4294967295;\n          } else if (v3 == 54) {\n            return 4294967295;\n          } else if (v3 <= 57) {\n            if (v3 <= 54)\n              return v3 + 1444872145;\n            v3 -= 1;\n            break;\n          } else {\n            return 4294967295;\n          }\n        case 1:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 126) {\n            return 1444872244;\n          } else if (v3 == 50) {\n            return 4294967295;\n          } else if (v3 <= 52) {\n            if (v3 > 50)\n              v3 -= 1;\n            v7 = (getc(stdin @GLIBC_2.2.5) == 126 ? 4294967295\n                                                  : v3 + 1444872154);\n            return v7;\n          } else {\n            return 4294967295;\n          }\n        case 2:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872239);\n          return v7;\n        case 4:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872246);\n          return v7;\n        case 5:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872247);\n          return v7;\n        case 6:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872245);\n          return v7;\n        case 7:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872248);\n          return v7;\n        case 16:\n          return 1444872230;\n        case 17:\n          return 1444872231;\n        case 18:\n          return 1444872232;\n        case 19:\n          return 1444872233;\n        case 21:\n          return 1444872248;\n        case 23:\n          return 1444872245;\n        default:\n          return 4294967295;\n        }\n      } else {\n        ungetc(v2, stdin @GLIBC_2.2.5);\n        return 27;\n      }\n    } else {\n      ungetc(v3, stdin @GLIBC_2.2.5);\n      v7 = decode_regular_key_pressed();\n      return v7;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7hw27cl6/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:202:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 202 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:202:21: error: expected ';' after top\nlevel declarator 202 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmp7hw27cl6/decode_key_pressed.c:217:20: error: expected ')'\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:217:14: note: to match this '('\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:248:28: error: expected ')'\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:248:22: note: to match this '('\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                      ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:252:32: error: expected ')'\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                                ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:252:26: note: to match this '('\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                          ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:259:32: error: expected ')'\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                                ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:259:26: note: to match this '('\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                          ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:263:36: error: expected ')'\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:263:30: note: to match this '('\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:264:36: error: expected ')'\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmp7hw27cl6/decode_key_pressed.c:264:30: note: to match this '('\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 <= 31 || ((unsigned int)a0 & 0x56000000) == 0x56000000)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(compute_completion_ranges)(long long, long long, long long,\n                                     long long);\n\nextern char completions;\nextern unsigned long long current_num_completions;\nextern char line.1;\n\nlong long search_completion_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;               // [bp-0x30]\n  char v1;               // [bp-0x28]\n  unsigned int *v2;      // [bp-0x20]\n  unsigned long long v3; // [bp-0x18]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v7; // rax\n  unsigned long long v9; // rax\n\n  compute_completion_ranges(a0, (unsigned int)a1, &v1, &v0);\n  if (*((long long *)&v1) && (unsigned int)a1) {\n    v7 = *((long long *)&v0) - *((long long *)&v1) >> 2;\n    *((int *)&v3) = (v7 < 0 ? v7 + 4095 : v7) >> 12;\n    v2 = *((long long *)&v1);\n    v9 = v2 - &completions >> 2;\n    if ((v9 < 0 ? v9 + 4095 : v9) >> 12 == current_num_completions - 1)\n      return &v2[(unsigned int)a1];\n    for (v4 = 0; v2[v4] && v2[a1 + v4] == v2[0x1000 + 0x1000 * v3 + a1 + v4];\n         v4 += 1) {\n      *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n    }\n    *((int *)&(&line.1)[4 * v4]) = 0;\n    return &line.1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpix94_g09/search_completion_name_conflict.c:20:17: error: expected ';' after top level\ndeclarator 20 | extern char line.1; |                 ^ |                 ;\n/tmp/tmpix94_g09/search_completion_name_conflict.c:38:17: error: 'unsigned int *' and 'char *'\nare not pointers to compatible types 38 |         v9 = v2 - &completions >> 2;\n      |              ~~ ^ ~~~~~~~~~~~~\n/tmp/tmpix94_g09/search_completion_name_conflict.c:43:38: error: expected ')'\n   43 |             *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n      |                                      ^\n/tmp/tmpix94_g09/search_completion_name_conflict.c:43:32: note: to match this '('\n   43 |             *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n      |                                ^\n/tmp/tmpix94_g09/search_completion_name_conflict.c:45:25: error: expected ')'\n   45 |         *((int *)&(&line.1)[4 * v4]) = 0;\n      |                         ^\n/tmp/tmpix94_g09/search_completion_name_conflict.c:45:19: note: to match this '('\n   45 |         *((int *)&(&line.1)[4 * v4]) = 0;\n      |                   ^\n/tmp/tmpix94_g09/search_completion_name_conflict.c:46:21: error: expected ';' after return\nstatement 46 |         return &line.1; |                     ^ | ; 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_stopkey_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 46 || (unsigned int)a0 == 47 ||\n      (unsigned int)a0 == 91 || (unsigned int)a0 == 32)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sighandler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(echo_disable)();\nlong long(print_prompt)(long long);\nlong long(decode_key_pressed)();\nlong long(is_special)(long long);\nlong long(putc_utf8)(long long);\nlong long(echo_enable)();\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(is_stopkey)(long long);\nlong long(trans_utf8)(long long, long long);\nlong long(search_completion)(long long, long long);\nlong long(print_all_completions)(long long, long long);\n\nextern unsigned int cursorpos;\nextern char g_404270;\nextern char g_40427d;\nextern char g_404281;\nextern char g_40429f;\nextern char g_4042a5;\nextern char g_4042ab;\nextern char g_4042ca;\nextern void *gprompt;\nextern unsigned int history[4];\nextern void *last_history_entry;\nextern unsigned int line[4];\nextern unsigned int line_len;\nextern unsigned long long line_t.0;\nextern unsigned long long total_history_entries;\n\nlong long getline_complete_name_conflict(unsigned long long a0) {\n  unsigned long long v0; // [bp-0x50]\n  unsigned int *v1;      // [bp-0x48]\n  unsigned int v2;       // [bp-0x3c]\n  unsigned long long v3; // [bp-0x38]\n  unsigned int v4;       // [bp-0x2c]\n  unsigned int v5;       // [bp-0x28]\n  unsigned int v6;       // [bp-0x24]\n  unsigned int v7;       // [bp-0x20]\n  unsigned int v8;       // [bp-0x1c]\n  unsigned int v9;       // [bp-0x18]\n  unsigned int v10;      // [bp-0x14]\n  unsigned int v11;      // [bp-0x10]\n  unsigned int v12;      // [bp-0xc]\n  char v15;              // al\n  char v16;              // al\n\n  memset(&line[0], 0, 0x4000);\n  gprompt = a0;\n  v3 = __sysv_signal(2, sighandler);\n  v12 = (unsigned int)last_history_entry + 1;\n  line_len = 0;\n  cursorpos = 0;\n  v10 = 0;\n  if (v12 > 199)\n    v12 = 0;\n  echo_disable();\n  printf(&g_404281);\n  print_prompt(a0);\n  while (true) {\n    v2 = decode_key_pressed();\n    if (v2 == -1) {\n      puts(\"\\nInvalid input sequence!\");\n      printf(&g_4042ca);\n    }\n    if ((char)((int)is_special(v2) ^ 1)) {\n      putc_utf8(v2);\n      memmove(&line[1 + cursorpos], &line[cursorpos],\n              (line_len - cursorpos) * 4);\n      line[cursorpos] = v2;\n      cursorpos = cursorpos + 1;\n      line_len = line_len + 1;\n      v10 = 0;\n    } else {\n      if (v2 == 1444872237 && cursorpos) {\n        v9 = 0;\n        do {\n          cursorpos = cursorpos - 1;\n          v9 += 1;\n          v15 = (int)is_stopkey(line[cursorpos]) ^ 1;\n        } while (v15 && cursorpos);\n        printf(&g_40429f, v9);\n      }\n      if (v2 == 1444872236 && cursorpos < line_len) {\n        v8 = 0;\n        do {\n          cursorpos = cursorpos + 1;\n          v8 += 1;\n          v16 = (int)is_stopkey(line[cursorpos]) ^ 1;\n        } while (v16 && cursorpos < line_len);\n        printf(&g_4042a5, v8);\n      }\n      if (v2 == 1444872233 && cursorpos) {\n        printf(&g_40429f, 1);\n        cursorpos = cursorpos - 1;\n      }\n      if (v2 == 1444872232 && cursorpos < line_len) {\n        printf(&g_4042a5, 1);\n        cursorpos = cursorpos + 1;\n      }\n      if (v2 == 1444872245 && cursorpos) {\n        printf(&g_40429f, cursorpos);\n        cursorpos = 0;\n      }\n      if (v2 == 1444872248 && cursorpos != line_len) {\n        printf(&g_4042a5, line_len - cursorpos);\n        cursorpos = line_len;\n      }\n      if (v2 == 1444872240 && cursorpos ||\n          v2 == 1444872239 && cursorpos < line_len) {\n        line_len = line_len - 1;\n        if (v2 == 1444872240) {\n          cursorpos = cursorpos - 1;\n          printf(&g_40429f, 1);\n        }\n        memmove(&line[cursorpos], &line[1 + cursorpos],\n                (line_len - cursorpos) * 4);\n        printf(&g_4042ab);\n        if (cursorpos != line_len) {\n          for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          printf(&g_40429f, line_len - cursorpos);\n        }\n      }\n      if (v2 == 1444872242) {\n        v7 = cursorpos;\n        v6 = (cursorpos == line_len ? cursorpos + 1 : cursorpos);\n        while (true) {\n          if (!((char)((int)is_stopkey(line[v7]) ^ 1)) || !(v7))\n            break;\n          v7 -= 1;\n        }\n        while (true) {\n          if (!((char)((int)is_stopkey(line[v6]) ^ 1)) || !(v6 < line_len))\n            break;\n          v6 += 1;\n        }\n        memmove(&line[v7], &line[v6], (line_len - v6) * 4);\n        if (v7 < cursorpos) {\n          printf(&g_40429f, cursorpos - v7);\n          cursorpos = v7;\n        }\n        line_len = line_len - (v6 - v7);\n        printf(&g_4042ab);\n        if (cursorpos != line_len) {\n          for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          printf(&g_40429f, line_len - cursorpos);\n        }\n      }\n      if (total_history_entries && (v2 == 1444872230 || v2 == 1444872231)) {\n        if (v2 == 1444872230)\n          v12 -= 1;\n        if (v2 == 1444872231)\n          v12 += 1;\n        if (v12 >= (unsigned int)total_history_entries)\n          v12 = 0;\n        if (v12 < 0)\n          v12 = (unsigned int)total_history_entries - 1;\n        if (cursorpos)\n          printf(&g_40429f, cursorpos);\n        printf(&g_4042ab);\n        cursorpos = 0;\n        line_len = 0;\n        for (v11 = 0; history[0x1000 * v12 + v11]; v11 += 1) {\n          putc_utf8(history[0x1000 * v12 + v11]);\n          line[cursorpos] = history[0x1000 * v12 + v11];\n          cursorpos = cursorpos + 1;\n          line_len = line_len + 1;\n        }\n      }\n      if (!(v2 != 0x561f0000 || cursorpos)) {\n        v10 += 1;\n      } else if (v2 != 0x561f0000 || !cursorpos) {\n        v10 = 0;\n      } else {\n        for (v5 = cursorpos; line[1 + v5] != 32 && v5; v5 -= 1)\n          ;\n        v1 = &line[v5];\n        v1 = search_completion(v1, cursorpos - v5);\n        if (v1) {\n          printf(&g_4042ab);\n          for (v11 = 0; v1[v11]; v11 += 1) {\n            putc_utf8(v1[v11]);\n            memmove(&line[1 + cursorpos], &line[cursorpos],\n                    (line_len - cursorpos) * 4);\n            line[cursorpos] = v1[v11];\n            cursorpos = cursorpos + 1;\n            line_len = line_len + 1;\n          }\n          if (cursorpos != line_len) {\n            for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n              putc_utf8(line[v11]);\n            }\n            printf(&g_40429f, line_len - cursorpos);\n          }\n        }\n        v10 += 1;\n      }\n      if (v2 == 0x561f0000 && v10 > 1) {\n        printf(&g_404270, 1);\n        puts(\"\\npossible completions are:\");\n        printf(&g_404270, 0);\n        if (cursorpos) {\n          for (v4 = cursorpos; line[1 + v4] != 32 && v4; v4 -= 1)\n            ;\n          v0 = &line[v4];\n          print_all_completions(v0, cursorpos - v4);\n          print_prompt(a0);\n          for (v11 = 0; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          if (line_len != cursorpos)\n            printf(&g_40429f, line_len - cursorpos);\n        } else {\n          print_all_completions(&line[0], 0);\n          print_prompt(a0);\n          for (v11 = 0; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          if (line_len != cursorpos)\n            printf(&g_40429f, line_len - cursorpos);\n          continue;\n        }\n      }\n    }\n    if (!(v2 != 4) || !(v2 != 1444872238))\n      break;\n  }\n  puts(&g_40427d);\n  printf(&g_4042ca);\n  echo_enable();\n  __sysv_signal(2, v3);\n  memset(&line[line_len], 0, (0x1000 - line_len) * 4);\n  if (memcmp(&line[0], (char *)&history[0] + 0x4000 * last_history_entry,\n             0x4000)) {\n    last_history_entry = last_history_entry + 1;\n    if (last_history_entry == 200)\n      last_history_entry = 0;\n    if (total_history_entries < last_history_entry + 1)\n      total_history_entries = last_history_entry + 1;\n    memset((char *)&history[0] + 0x4000 * last_history_entry, 0, 0x4000);\n    memcpy(0x4000 * last_history_entry + (char *)&history[0], &line[0],\n           line_len * 4);\n  }\n  if (!line_len && v2 == 4) {\n    __sysv_signal(2, v3);\n    gprompt = 0;\n    return 0;\n  }\n  gprompt = 0;\n  trans_utf8(&line_t.0, &line[0]);\n  return &line_t.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwubwc6wu/getline_complete_name_conflict.c:42:33: error: expected ';' after top level\ndeclarator 42 | extern unsigned long long line_t.0; | ^ | ;\n/tmp/tmpwubwc6wu/getline_complete_name_conflict.c:286:55: error: invalid operands to binary\nexpression ('int' and 'void *') 286 |     if (memcmp(&line[0], (char\n*)&history[0] + 0x4000 * last_history_entry, 0x4000)) | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmpwubwc6wu/getline_complete_name_conflict.c:293:45: error: invalid\noperands to binary expression ('int' and 'void *') 293 |         memset((char\n*)&history[0] + 0x4000 * last_history_entry, 0, 0x4000); | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmpwubwc6wu/getline_complete_name_conflict.c:294:23: error: invalid\noperands to binary expression ('int' and 'void *') 294 |         memcpy(0x4000 *\nlast_history_entry + (char *)&history[0], &line[0], line_len * 4); | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmpwubwc6wu/getline_complete_name_conflict.c:303:23: error: expected\n')' 303 |     trans_utf8(&line_t.0, &line[0]); |                       ^\n/tmp/tmpwubwc6wu/getline_complete_name_conflict.c:303:15: note: to match this '('\n  303 |     trans_utf8(&line_t.0, &line[0]);\n      |               ^\n/tmp/tmpwubwc6wu/getline_complete_name_conflict.c:304:19: error: expected ';' after return\nstatement 304 |     return &line_t.0; |                   ^ | ; 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char completions;\nextern unsigned long long current_num_completions;\n\nlong long init_completion_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (current_num_completions == 0x800)\n    return 1;\n  for (v0 = 0; a0[v0]; v0 += 1) {\n    if (v0 <= 4094) {\n      *((unsigned int *)&(\n          &completions)[0x4000 * current_num_completions + 4 * v0]) = a0[v0];\n    } else {\n      memset(&(&completions)[0x4000 * current_num_completions], 0, 0x4000);\n      return 1;\n    }\n  }\n  *((int *)&(&completions)[0x4000 * current_num_completions + 4 * v0]) = 0;\n  current_num_completions = current_num_completions + 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint compl_eqcompar; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long completions;\nextern unsigned long long current_num_completions;\nextern unsigned long long memsize;\n\nlong long completion_exists_name_conflict(char *a0) {\n  char v0;               // [bp-0x4018]\n  unsigned long v1;      // [bp-0x18]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  for (v2 = 0; a0[v2] && v2 != 4095; v2 += 1) {\n    *((unsigned int *)&(&v0)[4 * v2]) = a0[v2];\n  }\n  *((int *)&(&v0)[4 * v2]) = 0;\n  memsize = v2;\n  v1 = lfind(&v0, &completions, &current_num_completions, 0x4000,\n             compl_eqcompar);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4210888];\n  unsigned int field_4040c8;\n} struct_0;\n\nextern char g_40406b;\nextern char g_40406f;\nextern char g_404073;\nextern char g_404077;\nextern char g_4040c8;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  if ((unsigned int)a0 < 27)\n    return \"unknown\";\n  switch ((unsigned int)a0) {\n  case 1444872192:\n    return \"Tab\";\n  case 1444872194:\n    return \"F1\";\n  case 1444872195:\n    return \"F2\";\n  case 1444872196:\n    return \"F3\";\n  case 1444872197:\n    return \"F4\";\n  case 1444872198:\n    return \"F5\";\n  case 1444872199:\n    return \"F6\";\n  case 1444872200:\n    return \"F7\";\n  case 1444872201:\n    return \"F8\";\n  case 1444872202:\n    return \"F9\";\n  case 1444872203:\n    return \"F10\";\n  case 1444872204:\n    return \"F11\";\n  case 1444872205:\n    return \"F12\";\n  case 1444872230:\n    return &g_40406f;\n  case 1444872231:\n    return &g_404077;\n  case 1444872232:\n    return &g_404073;\n  case 1444872233:\n    return &g_40406b;\n  case 1444872234:\n    return \"CtrlUp\";\n  case 1444872235:\n    return \"CtrlDown\";\n  case 1444872236:\n    return \"CtrlRight\";\n  case 1444872237:\n    return \"CtrlLeft\";\n  case 1444872238:\n    return \"Enter\";\n  case 1444872239:\n    return \"Delete\";\n  case 1444872240:\n    return \"Backspace\";\n  case 1444872241:\n    return \"CtrlBackspace\";\n  case 1444872244:\n    return \"Insert\";\n  case 1444872245:\n    return \"Home\";\n  case 1444872246:\n    return \"PageUp\";\n  case 1444872247:\n    return \"PageDown\";\n  case 1444872248:\n    return \"End\";\n  default:\n    break;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  char v0;         // [bp-0x10]\n  char v1;         // [bp-0xf]\n  char v2;         // [bp-0xe]\n  char v3;         // [bp-0xd]\n  unsigned int v4; // [bp-0xc]\n\n  v0 = getc(stdin @GLIBC_2.2.5);\n  if ((v0 & 248) == 240) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v3 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 15;\n    v1 &= 127;\n    v2 &= 127;\n    v3 &= 127;\n    v4 = v0 * 0x40000 + v2 * 64 + v3 + v1 * 0x1000;\n    if (v4 <= 65535)\n      return 4294967295;\n  } else if ((v0 & 240) == 224) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 31;\n    v1 &= 127;\n    v2 &= 127;\n    v4 = v0 * 0x1000 + v1 * 64 + v2;\n    if (v4 <= 2047)\n      return 4294967295;\n  } else if ((v0 & 224) == 192) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 63;\n    v1 &= 127;\n    v4 = v1 + v0 * 64;\n    if (v4 <= 127)\n      return 4294967295;\n  } else if (v0 >= 0) {\n    v4 = v0;\n  } else {\n    return 4294967295;\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:116:20: error: expected ')'\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:116:14: note: to match this '('\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:119:24: error: expected ')'\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:119:18: note: to match this '('\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:120:24: error: expected ')'\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:120:18: note: to match this '('\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:121:24: error: expected ')'\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:121:18: note: to match this '('\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:132:24: error: expected ')'\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:132:18: note: to match this '('\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:133:24: error: expected ')'\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:133:18: note: to match this '('\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:143:24: error: expected ')'\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpij39d7nc/decode_regular_key_pressed.c:143:18: note: to match this '('\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\ntypedef struct struct_0 {\n  char padding_0[4211116];\n  unsigned int field_4041ac;\n} struct_0;\n\nextern char g_4041ac;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  char v0;               // [bp-0x15]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  struct_0 *v8;          // rax\n  unsigned int v10;      // eax\n\n  v6 = &v4;\n  v3 = getc(stdin @GLIBC_2.2.5);\n  if (v3 == 10) {\n    return 1444872238;\n  } else if (v3 == 9) {\n    return 0x561f0000;\n  } else if (v3 == 127) {\n    return 1444872240;\n  } else if (v3 == 8) {\n    return 1444872241;\n  } else {\n    if (!(v3 != -1 && v3 != -1))\n      return 4;\n    if (v3 == 23) {\n      return 1444872242;\n    } else if (!v3) {\n      return 1444872243;\n    } else if (v3 == 27) {\n      v3 = getc(stdin @GLIBC_2.2.5);\n      v2 = v3;\n      if (v3 == 79) {\n        v3 = getc(stdin @GLIBC_2.2.5);\n        if (!(v3 > 79 && v3 <= 83))\n          return 4294967295;\n        return v3 + 1444872114;\n      } else if (v3 == 91) {\n        v8 = getc(stdin @GLIBC_2.2.5) - 49;\n        switch ((unsigned int)v8) {\n        case 0:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          v1 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 59 && v1 == 53) {\n            v0 = getc(stdin @GLIBC_2.2.5);\n            v10 = v0;\n            if (v10 == 68) {\n              return 1444872237;\n            } else if (v10 <= 68) {\n              if (v10 == 67) {\n                return 1444872236;\n              } else if (v10 <= 67) {\n                if (v10 == 65) {\n                  return 1444872234;\n                } else if (v10 == 66) {\n                  return 1444872235;\n                }\n              }\n            }\n          }\n          if (v1 != 126) {\n            return 4294967295;\n          } else if (v3 == 54) {\n            return 4294967295;\n          } else if (v3 <= 57) {\n            if (v3 <= 54)\n              return v3 + 1444872145;\n            v3 -= 1;\n            break;\n          } else {\n            return 4294967295;\n          }\n        case 1:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 126) {\n            return 1444872244;\n          } else if (v3 == 50) {\n            return 4294967295;\n          } else if (v3 <= 52) {\n            if (v3 > 50)\n              v3 -= 1;\n            v7 = (getc(stdin @GLIBC_2.2.5) == 126 ? 4294967295\n                                                  : v3 + 1444872154);\n            return v7;\n          } else {\n            return 4294967295;\n          }\n        case 2:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872239);\n          return v7;\n        case 4:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872246);\n          return v7;\n        case 5:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872247);\n          return v7;\n        case 6:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872245);\n          return v7;\n        case 7:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872248);\n          return v7;\n        case 16:\n          return 1444872230;\n        case 17:\n          return 1444872231;\n        case 18:\n          return 1444872232;\n        case 19:\n          return 1444872233;\n        case 21:\n          return 1444872248;\n        case 23:\n          return 1444872245;\n        default:\n          return 4294967295;\n        }\n      } else {\n        ungetc(v2, stdin @GLIBC_2.2.5);\n        return 27;\n      }\n    } else {\n      ungetc(v3, stdin @GLIBC_2.2.5);\n      v7 = decode_regular_key_pressed();\n      return v7;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpow1_i6zh/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:202:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 202 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:202:21: error: expected ';' after top\nlevel declarator 202 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmpow1_i6zh/decode_key_pressed.c:217:20: error: expected ')'\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:217:14: note: to match this '('\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:248:28: error: expected ')'\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:248:22: note: to match this '('\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                      ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:252:32: error: expected ')'\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                                ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:252:26: note: to match this '('\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                          ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:259:32: error: expected ')'\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                                ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:259:26: note: to match this '('\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                          ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:263:36: error: expected ')'\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:263:30: note: to match this '('\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:264:36: error: expected ')'\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmpow1_i6zh/decode_key_pressed.c:264:30: note: to match this '('\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 <= 31 || ((unsigned int)a0 & 0x56000000) == 0x56000000)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(compute_completion_ranges)(long long, long long, long long,\n                                     long long);\n\nextern char completions;\nextern unsigned long long current_num_completions;\nextern char line.1;\n\nlong long search_completion_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;               // [bp-0x30]\n  char v1;               // [bp-0x28]\n  unsigned int *v2;      // [bp-0x20]\n  unsigned long long v3; // [bp-0x18]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v7; // rax\n  unsigned long long v9; // rax\n\n  compute_completion_ranges(a0, (unsigned int)a1, &v1, &v0);\n  if (*((long long *)&v1) && (unsigned int)a1) {\n    v7 = *((long long *)&v0) - *((long long *)&v1) >> 2;\n    *((int *)&v3) = (v7 < 0 ? v7 + 4095 : v7) >> 12;\n    v2 = *((long long *)&v1);\n    v9 = v2 - &completions >> 2;\n    if ((v9 < 0 ? v9 + 4095 : v9) >> 12 == current_num_completions - 1)\n      return &v2[(unsigned int)a1];\n    for (v4 = 0; v2[v4] && v2[a1 + v4] == v2[0x1000 + 0x1000 * v3 + a1 + v4];\n         v4 += 1) {\n      *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n    }\n    *((int *)&(&line.1)[4 * v4]) = 0;\n    return &line.1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:20:17: error: expected ';' after top level\ndeclarator 20 | extern char line.1; |                 ^ |                 ;\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:38:17: error: 'unsigned int *' and 'char *'\nare not pointers to compatible types 38 |         v9 = v2 - &completions >> 2;\n      |              ~~ ^ ~~~~~~~~~~~~\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:43:38: error: expected ')'\n   43 |             *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n      |                                      ^\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:43:32: note: to match this '('\n   43 |             *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n      |                                ^\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:45:25: error: expected ')'\n   45 |         *((int *)&(&line.1)[4 * v4]) = 0;\n      |                         ^\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:45:19: note: to match this '('\n   45 |         *((int *)&(&line.1)[4 * v4]) = 0;\n      |                   ^\n/tmp/tmp5knmo8or/search_completion_name_conflict.c:46:21: error: expected ';' after return\nstatement 46 |         return &line.1; |                     ^ | ; 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_stopkey_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 46 || (unsigned int)a0 == 47 ||\n      (unsigned int)a0 == 91 || (unsigned int)a0 == 32)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sighandler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(echo_disable)();\nlong long(print_prompt)(long long);\nlong long(decode_key_pressed)();\nlong long(is_special)(long long);\nlong long(putc_utf8)(long long);\nlong long(echo_enable)();\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(is_stopkey)(long long);\nlong long(trans_utf8)(long long, long long);\nlong long(search_completion)(long long, long long);\nlong long(print_all_completions)(long long, long long);\n\nextern unsigned int cursorpos;\nextern char g_404270;\nextern char g_40427d;\nextern char g_404281;\nextern char g_40429f;\nextern char g_4042a5;\nextern char g_4042ab;\nextern char g_4042ca;\nextern void *gprompt;\nextern unsigned int history[4];\nextern void *last_history_entry;\nextern unsigned int line[4];\nextern unsigned int line_len;\nextern unsigned long long line_t.0;\nextern unsigned long long total_history_entries;\n\nlong long getline_complete_name_conflict(unsigned long long a0) {\n  unsigned long long v0; // [bp-0x50]\n  unsigned int *v1;      // [bp-0x48]\n  unsigned int v2;       // [bp-0x3c]\n  unsigned long long v3; // [bp-0x38]\n  unsigned int v4;       // [bp-0x2c]\n  unsigned int v5;       // [bp-0x28]\n  unsigned int v6;       // [bp-0x24]\n  unsigned int v7;       // [bp-0x20]\n  unsigned int v8;       // [bp-0x1c]\n  unsigned int v9;       // [bp-0x18]\n  unsigned int v10;      // [bp-0x14]\n  unsigned int v11;      // [bp-0x10]\n  unsigned int v12;      // [bp-0xc]\n  char v15;              // al\n  char v16;              // al\n\n  memset(&line[0], 0, 0x4000);\n  gprompt = a0;\n  v3 = __sysv_signal(2, sighandler);\n  v12 = (unsigned int)last_history_entry + 1;\n  line_len = 0;\n  cursorpos = 0;\n  v10 = 0;\n  if (v12 > 199)\n    v12 = 0;\n  echo_disable();\n  printf(&g_404281);\n  print_prompt(a0);\n  while (true) {\n    v2 = decode_key_pressed();\n    if (v2 == -1) {\n      puts(\"\\nInvalid input sequence!\");\n      printf(&g_4042ca);\n    }\n    if ((char)((int)is_special(v2) ^ 1)) {\n      putc_utf8(v2);\n      memmove(&line[1 + cursorpos], &line[cursorpos],\n              (line_len - cursorpos) * 4);\n      line[cursorpos] = v2;\n      cursorpos = cursorpos + 1;\n      line_len = line_len + 1;\n      v10 = 0;\n    } else {\n      if (v2 == 1444872237 && cursorpos) {\n        v9 = 0;\n        do {\n          cursorpos = cursorpos - 1;\n          v9 += 1;\n          v15 = (int)is_stopkey(line[cursorpos]) ^ 1;\n        } while (v15 && cursorpos);\n        printf(&g_40429f, v9);\n      }\n      if (v2 == 1444872236 && cursorpos < line_len) {\n        v8 = 0;\n        do {\n          cursorpos = cursorpos + 1;\n          v8 += 1;\n          v16 = (int)is_stopkey(line[cursorpos]) ^ 1;\n        } while (v16 && cursorpos < line_len);\n        printf(&g_4042a5, v8);\n      }\n      if (v2 == 1444872233 && cursorpos) {\n        printf(&g_40429f, 1);\n        cursorpos = cursorpos - 1;\n      }\n      if (v2 == 1444872232 && cursorpos < line_len) {\n        printf(&g_4042a5, 1);\n        cursorpos = cursorpos + 1;\n      }\n      if (v2 == 1444872245 && cursorpos) {\n        printf(&g_40429f, cursorpos);\n        cursorpos = 0;\n      }\n      if (v2 == 1444872248 && cursorpos != line_len) {\n        printf(&g_4042a5, line_len - cursorpos);\n        cursorpos = line_len;\n      }\n      if (v2 == 1444872240 && cursorpos ||\n          v2 == 1444872239 && cursorpos < line_len) {\n        line_len = line_len - 1;\n        if (v2 == 1444872240) {\n          cursorpos = cursorpos - 1;\n          printf(&g_40429f, 1);\n        }\n        memmove(&line[cursorpos], &line[1 + cursorpos],\n                (line_len - cursorpos) * 4);\n        printf(&g_4042ab);\n        if (cursorpos != line_len) {\n          for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          printf(&g_40429f, line_len - cursorpos);\n        }\n      }\n      if (v2 == 1444872242) {\n        v7 = cursorpos;\n        v6 = (cursorpos == line_len ? cursorpos + 1 : cursorpos);\n        while (true) {\n          if (!((char)((int)is_stopkey(line[v7]) ^ 1)) || !(v7))\n            break;\n          v7 -= 1;\n        }\n        while (true) {\n          if (!((char)((int)is_stopkey(line[v6]) ^ 1)) || !(v6 < line_len))\n            break;\n          v6 += 1;\n        }\n        memmove(&line[v7], &line[v6], (line_len - v6) * 4);\n        if (v7 < cursorpos) {\n          printf(&g_40429f, cursorpos - v7);\n          cursorpos = v7;\n        }\n        line_len = line_len - (v6 - v7);\n        printf(&g_4042ab);\n        if (cursorpos != line_len) {\n          for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          printf(&g_40429f, line_len - cursorpos);\n        }\n      }\n      if (total_history_entries && (v2 == 1444872230 || v2 == 1444872231)) {\n        if (v2 == 1444872230)\n          v12 -= 1;\n        if (v2 == 1444872231)\n          v12 += 1;\n        if (v12 >= (unsigned int)total_history_entries)\n          v12 = 0;\n        if (v12 < 0)\n          v12 = (unsigned int)total_history_entries - 1;\n        if (cursorpos)\n          printf(&g_40429f, cursorpos);\n        printf(&g_4042ab);\n        cursorpos = 0;\n        line_len = 0;\n        for (v11 = 0; history[0x1000 * v12 + v11]; v11 += 1) {\n          putc_utf8(history[0x1000 * v12 + v11]);\n          line[cursorpos] = history[0x1000 * v12 + v11];\n          cursorpos = cursorpos + 1;\n          line_len = line_len + 1;\n        }\n      }\n      if (!(v2 != 0x561f0000 || cursorpos)) {\n        v10 += 1;\n      } else if (v2 != 0x561f0000 || !cursorpos) {\n        v10 = 0;\n      } else {\n        for (v5 = cursorpos; line[1 + v5] != 32 && v5; v5 -= 1)\n          ;\n        v1 = &line[v5];\n        v1 = search_completion(v1, cursorpos - v5);\n        if (v1) {\n          printf(&g_4042ab);\n          for (v11 = 0; v1[v11]; v11 += 1) {\n            putc_utf8(v1[v11]);\n            memmove(&line[1 + cursorpos], &line[cursorpos],\n                    (line_len - cursorpos) * 4);\n            line[cursorpos] = v1[v11];\n            cursorpos = cursorpos + 1;\n            line_len = line_len + 1;\n          }\n          if (cursorpos != line_len) {\n            for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n              putc_utf8(line[v11]);\n            }\n            printf(&g_40429f, line_len - cursorpos);\n          }\n        }\n        v10 += 1;\n      }\n      if (v2 == 0x561f0000 && v10 > 1) {\n        printf(&g_404270, 1);\n        puts(\"\\npossible completions are:\");\n        printf(&g_404270, 0);\n        if (cursorpos) {\n          for (v4 = cursorpos; line[1 + v4] != 32 && v4; v4 -= 1)\n            ;\n          v0 = &line[v4];\n          print_all_completions(v0, cursorpos - v4);\n          print_prompt(a0);\n          for (v11 = 0; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          if (line_len != cursorpos)\n            printf(&g_40429f, line_len - cursorpos);\n        } else {\n          print_all_completions(&line[0], 0);\n          print_prompt(a0);\n          for (v11 = 0; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          if (line_len != cursorpos)\n            printf(&g_40429f, line_len - cursorpos);\n          continue;\n        }\n      }\n    }\n    if (!(v2 != 4) || !(v2 != 1444872238))\n      break;\n  }\n  puts(&g_40427d);\n  printf(&g_4042ca);\n  echo_enable();\n  __sysv_signal(2, v3);\n  memset(&line[line_len], 0, (0x1000 - line_len) * 4);\n  if (memcmp(&line[0], (char *)&history[0] + 0x4000 * last_history_entry,\n             0x4000)) {\n    last_history_entry = last_history_entry + 1;\n    if (last_history_entry == 200)\n      last_history_entry = 0;\n    if (total_history_entries < last_history_entry + 1)\n      total_history_entries = last_history_entry + 1;\n    memset((char *)&history[0] + 0x4000 * last_history_entry, 0, 0x4000);\n    memcpy(0x4000 * last_history_entry + (char *)&history[0], &line[0],\n           line_len * 4);\n  }\n  if (!line_len && v2 == 4) {\n    __sysv_signal(2, v3);\n    gprompt = 0;\n    return 0;\n  }\n  gprompt = 0;\n  trans_utf8(&line_t.0, &line[0]);\n  return &line_t.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4pcps8rd/getline_complete_name_conflict.c:42:33: error: expected ';' after top level\ndeclarator 42 | extern unsigned long long line_t.0; | ^ | ;\n/tmp/tmp4pcps8rd/getline_complete_name_conflict.c:286:55: error: invalid operands to binary\nexpression ('int' and 'void *') 286 |     if (memcmp(&line[0], (char\n*)&history[0] + 0x4000 * last_history_entry, 0x4000)) | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmp4pcps8rd/getline_complete_name_conflict.c:293:45: error: invalid\noperands to binary expression ('int' and 'void *') 293 |         memset((char\n*)&history[0] + 0x4000 * last_history_entry, 0, 0x4000); | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmp4pcps8rd/getline_complete_name_conflict.c:294:23: error: invalid\noperands to binary expression ('int' and 'void *') 294 |         memcpy(0x4000 *\nlast_history_entry + (char *)&history[0], &line[0], line_len * 4); | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmp4pcps8rd/getline_complete_name_conflict.c:303:23: error: expected\n')' 303 |     trans_utf8(&line_t.0, &line[0]); |                       ^\n/tmp/tmp4pcps8rd/getline_complete_name_conflict.c:303:15: note: to match this '('\n  303 |     trans_utf8(&line_t.0, &line[0]);\n      |               ^\n/tmp/tmp4pcps8rd/getline_complete_name_conflict.c:304:19: error: expected ';' after return\nstatement 304 |     return &line_t.0; |                   ^ | ; 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char completions;\nextern unsigned long long current_num_completions;\n\nlong long init_completion_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (current_num_completions == 0x800)\n    return 1;\n  v0 = 0;\n  while (true) {\n    if (!a0[v0]) {\n      *((int *)&(&completions)[0x4000 * current_num_completions + 4 * v0]) = 0;\n      current_num_completions = current_num_completions + 1;\n      return 0;\n    } else if (v0 <= 4094) {\n      *((unsigned int *)&(\n          &completions)[0x4000 * current_num_completions + 4 * v0]) = a0[v0];\n      v0 += 1;\n    } else {\n      memset(&(&completions)[0x4000 * current_num_completions], 0, 0x4000);\n      return 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint compl_eqcompar; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long completions;\nextern unsigned long long current_num_completions;\nextern unsigned long long memsize;\n\nlong long completion_exists_name_conflict(char *a0) {\n  char v0;               // [bp-0x4018]\n  unsigned long v1;      // [bp-0x18]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  for (v2 = 0; a0[v2] && v2 != 4095; v2 += 1) {\n    *((unsigned int *)&(&v0)[4 * v2]) = a0[v2];\n  }\n  *((int *)&(&v0)[4 * v2]) = 0;\n  memsize = v2;\n  v1 = lfind(&v0, &completions, &current_num_completions, 0x4000,\n             compl_eqcompar);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4211580];\n  unsigned int field_40437c;\n} struct_0;\n\nextern char g_40431f;\nextern char g_404323;\nextern char g_404327;\nextern char g_40432b;\nextern char g_40437c;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  if ((unsigned int)a0 < 27)\n    return \"unknown\";\n  switch ((unsigned int)a0) {\n  case 1444872192:\n    return \"Tab\";\n  case 1444872194:\n    return \"F1\";\n  case 1444872195:\n    return \"F2\";\n  case 1444872196:\n    return \"F3\";\n  case 1444872197:\n    return \"F4\";\n  case 1444872198:\n    return \"F5\";\n  case 1444872199:\n    return \"F6\";\n  case 1444872200:\n    return \"F7\";\n  case 1444872201:\n    return \"F8\";\n  case 1444872202:\n    return \"F9\";\n  case 1444872203:\n    return \"F10\";\n  case 1444872204:\n    return \"F11\";\n  case 1444872205:\n    return \"F12\";\n  case 1444872230:\n    return &g_404323;\n  case 1444872231:\n    return &g_40432b;\n  case 1444872232:\n    return &g_404327;\n  case 1444872233:\n    return &g_40431f;\n  case 1444872234:\n    return \"CtrlUp\";\n  case 1444872235:\n    return \"CtrlDown\";\n  case 1444872236:\n    return \"CtrlRight\";\n  case 1444872237:\n    return \"CtrlLeft\";\n  case 1444872238:\n    return \"Enter\";\n  case 1444872239:\n    return \"Delete\";\n  case 1444872240:\n    return \"Backspace\";\n  case 1444872241:\n    return \"CtrlBackspace\";\n  case 1444872244:\n    return \"Insert\";\n  case 1444872245:\n    return \"Home\";\n  case 1444872246:\n    return \"PageUp\";\n  case 1444872247:\n    return \"PageDown\";\n  case 1444872248:\n    return \"End\";\n  default:\n    break;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  char v0;         // [bp-0x10]\n  char v1;         // [bp-0xf]\n  char v2;         // [bp-0xe]\n  char v3;         // [bp-0xd]\n  unsigned int v4; // [bp-0xc]\n\n  v0 = getc(stdin @GLIBC_2.2.5);\n  if ((v0 & 248) == 240) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v3 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 15;\n    v1 &= 127;\n    v2 &= 127;\n    v3 &= 127;\n    v4 = v0 * 0x40000 + v2 * 64 + v3 + v1 * 0x1000;\n    if (v4 <= 65535)\n      return 4294967295;\n  } else if ((v0 & 240) == 224) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v2 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 31;\n    v1 &= 127;\n    v2 &= 127;\n    v4 = v0 * 0x1000 + v1 * 64 + v2;\n    if (v4 <= 2047)\n      return 4294967295;\n  } else if ((v0 & 224) == 192) {\n    v1 = getc(stdin @GLIBC_2.2.5);\n    v0 &= 63;\n    v1 &= 127;\n    v4 = v1 + v0 * 64;\n    if (v4 <= 127)\n      return 4294967295;\n  } else if (v0 >= 0) {\n    v4 = v0;\n  } else {\n    return 4294967295;\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:116:20: error: expected ')'\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:116:14: note: to match this '('\n  116 |     v0 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:119:24: error: expected ')'\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:119:18: note: to match this '('\n  119 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:120:24: error: expected ')'\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:120:18: note: to match this '('\n  120 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:121:24: error: expected ')'\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:121:18: note: to match this '('\n  121 |         v3 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:132:24: error: expected ')'\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:132:18: note: to match this '('\n  132 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:133:24: error: expected ')'\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:133:18: note: to match this '('\n  133 |         v2 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:143:24: error: expected ')'\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmpog1gu1cc/decode_regular_key_pressed.c:143:18: note: to match this '('\n  143 |         v1 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\ntypedef struct struct_0 {\n  char padding_0[4211808];\n  unsigned int field_404460;\n} struct_0;\n\nextern char g_404460;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  char v0;               // [bp-0x15]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rax\n  struct_0 *v8;          // rax\n  unsigned int v10;      // eax\n\n  v6 = &v4;\n  v3 = getc(stdin @GLIBC_2.2.5);\n  if (v3 == 10) {\n    return 1444872238;\n  } else if (v3 == 9) {\n    return 0x561f0000;\n  } else if (v3 == 127) {\n    return 1444872240;\n  } else if (v3 == 8) {\n    return 1444872241;\n  } else {\n    if (!(v3 != -1 && v3 != -1))\n      return 4;\n    if (v3 == 23) {\n      return 1444872242;\n    } else if (!v3) {\n      return 1444872243;\n    } else if (v3 == 27) {\n      v3 = getc(stdin @GLIBC_2.2.5);\n      v2 = v3;\n      if (v3 == 79) {\n        v3 = getc(stdin @GLIBC_2.2.5);\n        if (!(v3 > 79 && v3 <= 83))\n          return 4294967295;\n        return v3 + 1444872114;\n      } else if (v3 == 91) {\n        v8 = getc(stdin @GLIBC_2.2.5) - 49;\n        switch ((unsigned int)v8) {\n        case 0:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          v1 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 59 && v1 == 53) {\n            v0 = getc(stdin @GLIBC_2.2.5);\n            v10 = v0;\n            if (v10 == 68) {\n              return 1444872237;\n            } else if (v10 <= 68) {\n              if (v10 == 67) {\n                return 1444872236;\n              } else if (v10 <= 67) {\n                if (v10 == 65) {\n                  return 1444872234;\n                } else if (v10 == 66) {\n                  return 1444872235;\n                }\n              }\n            }\n          }\n          if (v1 != 126) {\n            return 4294967295;\n          } else if (v3 == 54) {\n            return 4294967295;\n          } else if (v3 <= 57) {\n            if (v3 <= 54)\n              return v3 + 1444872145;\n            v3 -= 1;\n            break;\n          } else {\n            return 4294967295;\n          }\n        case 1:\n          v3 = getc(stdin @GLIBC_2.2.5);\n          if (v3 == 126) {\n            return 1444872244;\n          } else if (v3 == 50) {\n            return 4294967295;\n          } else if (v3 <= 52) {\n            if (v3 > 50)\n              v3 -= 1;\n            v7 = (getc(stdin @GLIBC_2.2.5) == 126 ? 4294967295\n                                                  : v3 + 1444872154);\n            return v7;\n          } else {\n            return 4294967295;\n          }\n        case 2:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872239);\n          return v7;\n        case 4:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872246);\n          return v7;\n        case 5:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872247);\n          return v7;\n        case 6:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872245);\n          return v7;\n        case 7:\n          v1 = getc(stdin @GLIBC_2.2.5);\n          v7 = (v1 == 126 ? 4294967295 : 1444872248);\n          return v7;\n        case 16:\n          return 1444872230;\n        case 17:\n          return 1444872231;\n        case 18:\n          return 1444872232;\n        case 19:\n          return 1444872233;\n        case 21:\n          return 1444872248;\n        case 23:\n          return 1444872245;\n        default:\n          return 4294967295;\n        }\n      } else {\n        ungetc(v2, stdin @GLIBC_2.2.5);\n        return 27;\n      }\n    } else {\n      ungetc(v3, stdin @GLIBC_2.2.5);\n      v7 = decode_regular_key_pressed();\n      return v7;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp902kk7ji/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:202:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 202 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:202:21: error: expected ';' after top\nlevel declarator 202 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmp902kk7ji/decode_key_pressed.c:217:20: error: expected ')'\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:217:14: note: to match this '('\n  217 |     v3 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:248:28: error: expected ')'\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:248:22: note: to match this '('\n  248 |             v3 = getc(stdin@GLIBC_2.2.5);\n      |                      ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:252:32: error: expected ')'\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                                ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:252:26: note: to match this '('\n  252 |                 v3 = getc(stdin@GLIBC_2.2.5);\n      |                          ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:259:32: error: expected ')'\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                                ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:259:26: note: to match this '('\n  259 |                 v8 = getc(stdin@GLIBC_2.2.5) - 49;\n      |                          ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:263:36: error: expected ')'\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:263:30: note: to match this '('\n  263 |                     v3 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:264:36: error: expected ')'\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmp902kk7ji/decode_key_pressed.c:264:30: note: to match this '('\n  264 |                     v1 = getc(stdin@GLIBC_2.2.5);\n      |                              ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 <= 31 || ((unsigned int)a0 & 0x56000000) == 0x56000000)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(compute_completion_ranges)(long long, long long, long long,\n                                     long long);\n\nextern char completions;\nextern unsigned long long current_num_completions;\nextern char line.1;\n\nlong long search_completion_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0;               // [bp-0x30]\n  char v1;               // [bp-0x28]\n  unsigned int *v2;      // [bp-0x20]\n  unsigned long long v3; // [bp-0x18]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v7; // rax\n  unsigned long long v9; // rax\n\n  compute_completion_ranges(a0, (unsigned int)a1, &v1, &v0);\n  if (*((long long *)&v1) && (unsigned int)a1) {\n    v7 = *((long long *)&v0) - *((long long *)&v1) >> 2;\n    *((int *)&v3) = (v7 < 0 ? v7 + 4095 : v7) >> 12;\n    v2 = *((long long *)&v1);\n    v9 = v2 - &completions >> 2;\n    if ((v9 < 0 ? v9 + 4095 : v9) >> 12 == current_num_completions - 1)\n      return &v2[(unsigned int)a1];\n    for (v4 = 0; v2[v4] && v2[a1 + v4] == v2[0x1000 + 0x1000 * v3 + a1 + v4];\n         v4 += 1) {\n      *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n    }\n    *((int *)&(&line.1)[4 * v4]) = 0;\n    return &line.1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:20:17: error: expected ';' after top level\ndeclarator 20 | extern char line.1; |                 ^ |                 ;\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:38:17: error: 'unsigned int *' and 'char *'\nare not pointers to compatible types 38 |         v9 = v2 - &completions >> 2;\n      |              ~~ ^ ~~~~~~~~~~~~\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:43:38: error: expected ')'\n   43 |             *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n      |                                      ^\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:43:32: note: to match this '('\n   43 |             *((unsigned int *)&(&line.1)[4 * v4]) = v2[v4 + a1];\n      |                                ^\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:45:25: error: expected ')'\n   45 |         *((int *)&(&line.1)[4 * v4]) = 0;\n      |                         ^\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:45:19: note: to match this '('\n   45 |         *((int *)&(&line.1)[4 * v4]) = 0;\n      |                   ^\n/tmp/tmpeq9kvro2/search_completion_name_conflict.c:46:21: error: expected ';' after return\nstatement 46 |         return &line.1; |                     ^ | ; 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_stopkey_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 46 || (unsigned int)a0 == 47 ||\n      (unsigned int)a0 == 91 || (unsigned int)a0 == 32)\n    v1 = 1;\n  else\n    v1 = 0;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sighandler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(echo_disable)();\nlong long(print_prompt)(long long);\nlong long(decode_key_pressed)();\nlong long(is_special)(long long);\nlong long(putc_utf8)(long long);\nlong long(echo_enable)();\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(is_stopkey)(long long);\nlong long(trans_utf8)(long long, long long);\nlong long(search_completion)(long long, long long);\nlong long(print_all_completions)(long long, long long);\n\nextern unsigned int cursorpos;\nextern char g_404520;\nextern char g_40452d;\nextern char g_404531;\nextern char g_40454f;\nextern char g_404555;\nextern char g_40455b;\nextern char g_40457a;\nextern void *gprompt;\nextern unsigned int history[4];\nextern void *last_history_entry;\nextern unsigned int line[4];\nextern unsigned int line_len;\nextern unsigned long long line_t.0;\nextern unsigned long long total_history_entries;\n\nlong long getline_complete_name_conflict(unsigned long long a0) {\n  unsigned long long v0; // [bp-0x50]\n  unsigned int *v1;      // [bp-0x48]\n  unsigned int v2;       // [bp-0x3c]\n  unsigned long long v3; // [bp-0x38]\n  unsigned int v4;       // [bp-0x2c]\n  unsigned int v5;       // [bp-0x28]\n  unsigned int v6;       // [bp-0x24]\n  unsigned int v7;       // [bp-0x20]\n  unsigned int v8;       // [bp-0x1c]\n  unsigned int v9;       // [bp-0x18]\n  unsigned int v10;      // [bp-0x14]\n  unsigned int v11;      // [bp-0x10]\n  unsigned int v12;      // [bp-0xc]\n  char v15;              // al\n  char v16;              // al\n\n  memset(&line[0], 0, 0x4000);\n  gprompt = a0;\n  v3 = __sysv_signal(2, sighandler);\n  v12 = (unsigned int)last_history_entry + 1;\n  line_len = 0;\n  cursorpos = 0;\n  v10 = 0;\n  if (v12 > 199)\n    v12 = 0;\n  echo_disable();\n  printf(&g_404531);\n  print_prompt(a0);\n  while (true) {\n    v2 = decode_key_pressed();\n    if (v2 == -1) {\n      puts(\"\\nInvalid input sequence!\");\n      printf(&g_40457a);\n    }\n    if ((char)((int)is_special(v2) ^ 1)) {\n      putc_utf8(v2);\n      memmove(&line[1 + cursorpos], &line[cursorpos],\n              (line_len - cursorpos) * 4);\n      line[cursorpos] = v2;\n      cursorpos = cursorpos + 1;\n      line_len = line_len + 1;\n      v10 = 0;\n    } else {\n      if (v2 == 1444872237 && cursorpos) {\n        v9 = 0;\n        do {\n          cursorpos = cursorpos - 1;\n          v9 += 1;\n          v15 = (int)is_stopkey(line[cursorpos]) ^ 1;\n        } while (v15 && cursorpos);\n        printf(&g_40454f, v9);\n      }\n      if (v2 == 1444872236 && cursorpos < line_len) {\n        v8 = 0;\n        do {\n          cursorpos = cursorpos + 1;\n          v8 += 1;\n          v16 = (int)is_stopkey(line[cursorpos]) ^ 1;\n        } while (v16 && cursorpos < line_len);\n        printf(&g_404555, v8);\n      }\n      if (v2 == 1444872233 && cursorpos) {\n        printf(&g_40454f, 1);\n        cursorpos = cursorpos - 1;\n      }\n      if (v2 == 1444872232 && cursorpos < line_len) {\n        printf(&g_404555, 1);\n        cursorpos = cursorpos + 1;\n      }\n      if (v2 == 1444872245 && cursorpos) {\n        printf(&g_40454f, cursorpos);\n        cursorpos = 0;\n      }\n      if (v2 == 1444872248 && cursorpos != line_len) {\n        printf(&g_404555, line_len - cursorpos);\n        cursorpos = line_len;\n      }\n      if (v2 == 1444872240 && cursorpos ||\n          v2 == 1444872239 && cursorpos < line_len) {\n        line_len = line_len - 1;\n        if (v2 == 1444872240) {\n          cursorpos = cursorpos - 1;\n          printf(&g_40454f, 1);\n        }\n        memmove(&line[cursorpos], &line[1 + cursorpos],\n                (line_len - cursorpos) * 4);\n        printf(&g_40455b);\n        if (cursorpos != line_len) {\n          for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          printf(&g_40454f, line_len - cursorpos);\n        }\n      }\n      if (v2 == 1444872242) {\n        v7 = cursorpos;\n        v6 = (cursorpos == line_len ? cursorpos + 1 : cursorpos);\n        while (true) {\n          if (!((char)((int)is_stopkey(line[v7]) ^ 1)) || !(v7))\n            break;\n          v7 -= 1;\n        }\n        while (true) {\n          if (!((char)((int)is_stopkey(line[v6]) ^ 1)) || !(v6 < line_len))\n            break;\n          v6 += 1;\n        }\n        memmove(&line[v7], &line[v6], (line_len - v6) * 4);\n        if (v7 < cursorpos) {\n          printf(&g_40454f, cursorpos - v7);\n          cursorpos = v7;\n        }\n        line_len = line_len - (v6 - v7);\n        printf(&g_40455b);\n        if (cursorpos != line_len) {\n          for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          printf(&g_40454f, line_len - cursorpos);\n        }\n      }\n      if (total_history_entries && (v2 == 1444872230 || v2 == 1444872231)) {\n        if (v2 == 1444872230)\n          v12 -= 1;\n        if (v2 == 1444872231)\n          v12 += 1;\n        if (v12 >= (unsigned int)total_history_entries)\n          v12 = 0;\n        if (v12 < 0)\n          v12 = (unsigned int)total_history_entries - 1;\n        if (cursorpos)\n          printf(&g_40454f, cursorpos);\n        printf(&g_40455b);\n        cursorpos = 0;\n        line_len = 0;\n        for (v11 = 0; history[0x1000 * v12 + v11]; v11 += 1) {\n          putc_utf8(history[0x1000 * v12 + v11]);\n          line[cursorpos] = history[0x1000 * v12 + v11];\n          cursorpos = cursorpos + 1;\n          line_len = line_len + 1;\n        }\n      }\n      if (!(v2 != 0x561f0000 || cursorpos)) {\n        v10 += 1;\n      } else if (v2 != 0x561f0000 || !cursorpos) {\n        v10 = 0;\n      } else {\n        for (v5 = cursorpos; line[1 + v5] != 32 && v5; v5 -= 1)\n          ;\n        v1 = &line[v5];\n        v1 = search_completion(v1, cursorpos - v5);\n        if (v1) {\n          printf(&g_40455b);\n          for (v11 = 0; v1[v11]; v11 += 1) {\n            putc_utf8(v1[v11]);\n            memmove(&line[1 + cursorpos], &line[cursorpos],\n                    (line_len - cursorpos) * 4);\n            line[cursorpos] = v1[v11];\n            cursorpos = cursorpos + 1;\n            line_len = line_len + 1;\n          }\n          if (cursorpos != line_len) {\n            for (v11 = cursorpos; v11 != line_len; v11 += 1) {\n              putc_utf8(line[v11]);\n            }\n            printf(&g_40454f, line_len - cursorpos);\n          }\n        }\n        v10 += 1;\n      }\n      if (v2 == 0x561f0000 && v10 > 1) {\n        printf(&g_404520, 1);\n        puts(\"\\npossible completions are:\");\n        printf(&g_404520, 0);\n        if (cursorpos) {\n          for (v4 = cursorpos; line[1 + v4] != 32 && v4; v4 -= 1)\n            ;\n          v0 = &line[v4];\n          print_all_completions(v0, cursorpos - v4);\n          print_prompt(a0);\n          for (v11 = 0; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          if (line_len != cursorpos)\n            printf(&g_40454f, line_len - cursorpos);\n        } else {\n          print_all_completions(&line[0], 0);\n          print_prompt(a0);\n          for (v11 = 0; v11 != line_len; v11 += 1) {\n            putc_utf8(line[v11]);\n          }\n          if (line_len != cursorpos)\n            printf(&g_40454f, line_len - cursorpos);\n          continue;\n        }\n      }\n    }\n    if (!(v2 != 4) || !(v2 != 1444872238))\n      break;\n  }\n  puts(&g_40452d);\n  printf(&g_40457a);\n  echo_enable();\n  __sysv_signal(2, v3);\n  memset(&line[line_len], 0, (0x1000 - line_len) * 4);\n  if (memcmp(&line[0], (char *)&history[0] + 0x4000 * last_history_entry,\n             0x4000)) {\n    last_history_entry = last_history_entry + 1;\n    if (last_history_entry == 200)\n      last_history_entry = 0;\n    if (total_history_entries < last_history_entry + 1)\n      total_history_entries = last_history_entry + 1;\n    memset((char *)&history[0] + 0x4000 * last_history_entry, 0, 0x4000);\n    memcpy(0x4000 * last_history_entry + (char *)&history[0], &line[0],\n           line_len * 4);\n  }\n  if (!line_len && v2 == 4) {\n    __sysv_signal(2, v3);\n    gprompt = 0;\n    return 0;\n  }\n  gprompt = 0;\n  trans_utf8(&line_t.0, &line[0]);\n  return &line_t.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwbq5hodq/getline_complete_name_conflict.c:42:33: error: expected ';' after top level\ndeclarator 42 | extern unsigned long long line_t.0; | ^ | ;\n/tmp/tmpwbq5hodq/getline_complete_name_conflict.c:286:55: error: invalid operands to binary\nexpression ('int' and 'void *') 286 |     if (memcmp(&line[0], (char\n*)&history[0] + 0x4000 * last_history_entry, 0x4000)) | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmpwbq5hodq/getline_complete_name_conflict.c:293:45: error: invalid\noperands to binary expression ('int' and 'void *') 293 |         memset((char\n*)&history[0] + 0x4000 * last_history_entry, 0, 0x4000); | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmpwbq5hodq/getline_complete_name_conflict.c:294:23: error: invalid\noperands to binary expression ('int' and 'void *') 294 |         memcpy(0x4000 *\nlast_history_entry + (char *)&history[0], &line[0], line_len * 4); | ~~~~~~ ^\n~~~~~~~~~~~~~~~~~~ /tmp/tmpwbq5hodq/getline_complete_name_conflict.c:303:23: error: expected\n')' 303 |     trans_utf8(&line_t.0, &line[0]); |                       ^\n/tmp/tmpwbq5hodq/getline_complete_name_conflict.c:303:15: note: to match this '('\n  303 |     trans_utf8(&line_t.0, &line[0]);\n      |               ^\n/tmp/tmpwbq5hodq/getline_complete_name_conflict.c:304:19: error: expected ';' after return\nstatement 304 |     return &line_t.0; |                   ^ | ; 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char completions;\nextern unsigned long long current_num_completions;\n\nlong long init_completion_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (current_num_completions == 0x800)\n    return 1;\n  for (v0 = 0; a0[v0]; v0 += 1) {\n    if (v0 <= 4094) {\n      *((unsigned int *)&(\n          &completions)[0x4000 * current_num_completions + 4 * v0]) = a0[v0];\n    } else {\n      memset(&(&completions)[0x4000 * current_num_completions], 0, 0x4000);\n      return 1;\n    }\n  }\n  *((int *)&(&completions)[0x4000 * current_num_completions + 4 * v0]) = 0;\n  current_num_completions = current_num_completions + 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint compl_eqcompar; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long completions;\nextern unsigned long long current_num_completions;\nextern unsigned long long memsize;\n\nlong long completion_exists_name_conflict(char *a0) {\n  char v0;               // [bp-0x4018]\n  unsigned long v1;      // [bp-0x18]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  for (v2 = 0; a0[v2] && v2 != 4095; v2 += 1) {\n    *((unsigned int *)&(&v0)[4 * v2]) = a0[v2];\n  }\n  *((int *)&(&v0)[4 * v2]) = 0;\n  memsize = v2;\n  v1 = lfind(&v0, &completions, &current_num_completions, 0x4000,\n             compl_eqcompar);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\nlong long(cleanup)();\n\nextern unsigned long long done;\nextern unsigned int max;\nextern unsigned int root;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long beenhere(unsigned long a0, unsigned long a1, unsigned long a2,\n                   unsigned long a3, unsigned long a4) {\n  unsigned int v0;        // [bp-0x48]\n  unsigned int v1;        // [bp-0x2c]\n  char *v2;               // [bp-0x28]\n  unsigned long long *v3; // [bp-0x20]\n  unsigned long v4;       // [bp-0x18]\n  unsigned long v5;       // [bp-0x10], Other Possible Types: unsigned long long\n\n  v0 = a3;\n  v3 = (unsigned int)a1 +\n       (max - 1) *\n           (((unsigned int)a2 >> 1) +\n            ((unsigned int)a0 - 2 >> 1) * ((unsigned int)a0 - 1 >> 1) - 1) -\n       1;\n  v0 -= (int)(1 << ((char)root & 31));\n  v2 = (unsigned int)a4 + (v0 >> 3);\n  v2 = (unsigned int)a4 + (v2 * (v2 + 1) >> 1);\n  v1 = 1 << ((char)(v0 & 7) & 31);\n  v5 = *((long long *)(done + v3 * 16));\n  if (v2 < v5 && (v2[*((long long *)(done + (v3 << 4) + 8))] & v1))\n    return 1;\n  if (v2 >= v5) {\n    if (v5) {\n      do {\n        v5 *= 2;\n      } while (v2 >= v5);\n      v4 = realloc(*((long long *)(done + v3 * 16 + 8)), v5);\n      if (v4)\n        memset(v4 + *((long long *)(done + v3 * 16)), 0,\n               v5 - *((long long *)(done + v3 * 16)));\n    } else {\n      for (v5 = 1 << ((char)((unsigned int)a1 - root) & 31); v2 >= v5; v5 *= 2)\n        ;\n      v4 = calloc(v5, 1);\n    }\n    if (!v4) {\n      fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40,\n             stderr @GLIBC_2.2.5);\n      cleanup();\n      exit(1); /* do not return */\n    }\n    *((unsigned long *)(v3 * 16 + done)) = v5;\n    *((unsigned long *)(v3 * 16 + done + 8)) = v4;\n  }\n  v2[*((long long *)(done + v3 * 16 + 8))] =\n      v2[*((long long *)(done + v3 * 16 + 8))] | v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmq8l5lev/beenhere.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpmq8l5lev/beenhere.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpmq8l5lev/beenhere.c:37:33: error: invalid operands to binary expression\n('char *' and 'char *') 37 |     v2 = (unsigned int)a4 + (v2 * (v2 + 1) >> 1);\n      |                              ~~ ^ ~~~~~~~~\n/tmp/tmpmq8l5lev/beenhere.c:39:36: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 39 |     v5 = *((long long *)(done + v3 *\n16)); |                                 ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:40:51: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 40 |     if (v2 < v5 && (v2[*((long long\n*)(done + (v3 << 4) + 8))] & v1)) | ~~ ^  ~ /tmp/tmpmq8l5lev/beenhere.c:50:52:\nerror: invalid operands to binary expression ('unsigned long long *' and 'int')\n   50 |             v4 = realloc(*((long long *)(done + v3 * 16 + 8)), v5);\n      |                                                 ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:52:55: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 52 |                 memset(v4 + *((long long\n*)(done + v3 * 16)), 0, v5 - *((long long *)(done + v3 * 16))); | ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:52:97: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 52 |                 memset(v4 + *((long long\n*)(done + v3 * 16)), 0, v5 - *((long long *)(done + v3 * 16))); | ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:61:78: error: expected ')'\n   61 |             fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpmq8l5lev/beenhere.c:61:19: note: to match this\n'(' 61 |             fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmpmq8l5lev/beenhere.c:65:32:\nerror: invalid operands to binary expression ('unsigned long long *' and 'int')\n   65 |         *((unsigned long *)(v3 * 16 + done)) = v5;\n      |                             ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:66:32: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 66 |         *((unsigned long *)(v3 * 16 +\ndone + 8)) = v4; |                             ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:68:34: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 68 |     v2[*((long long *)(done + v3 * 16 +\n8))] = v2[*((long long *)(done + v3 * 16 + 8))] | v1; | ~~ ^ ~~\n/tmp/tmpmq8l5lev/beenhere.c:68:77: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 68 |     v2[*((long long *)(done + v3 * 16 +\n8))] = v2[*((long long *)(done + v3 * 16 + 8))] | v1; | ~~ ^ ~~ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sergiobenrocha2_mgba/src/third-party/zlib/examples/enough.c"}
{"compilable":1,"function":"int unique_chars(char str[]) {\n    char c;\n    int i, j, len = strlen(str);\n    for (i = 0; i < len; i++) {\n        c = str[i];\n        for (j = i + 1; j < len; j++) {\n            if (str[j] == c)\n                return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long unique_chars_name_conflict(char *a0) {\n  char v0;               // [bp-0x15]\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  v1 = strlen(a0);\n  for (v3 = 0; v3 < v1; v3 += 1) {\n    v0 = a0[v3];\n    for (v2 = v3 + 1; v2 < v1; v2 += 1) {\n      if (v0 == a0[v2])\n        return 0;\n    }\n  }\n  return 1;\n}\n","pass":1,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":0,"function":"int unique_chars2(char str[]) {\n    char freq[26];\n    int i, len = strlen(str);\n    for (i = 0; i < 26; i++)\n        freq[i] = 0;\n    for (i = 0; i < len; i++)\n        freq[tolower(str[i]) - 'a']++;\n    for (i = 0; i < 26; i++)\n        if (freq[i] > 1)\n            return 0;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tolower)(int);\n\nlong long unique_chars2_name_conflict(char *a0) {\n  char v0;               // [bp-0x38]\n  unsigned int v1;       // [bp-0x10]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  unsigned long v6;      // rax\n\n  v5 = &v3;\n  v1 = strlen(a0);\n  for (v2 = 0; v2 <= 25; v2 += 1) {\n    (&v0)[v2] = 0;\n  }\n  for (v2 = 0; v2 < v1; v2 += 1) {\n    v6 = tolower(a0[v2]) - 97;\n    (&v0)[v6] = (&v0)[v6] + 1;\n  }\n  for (v2 = 0; v2 <= 25; v2 += 1) {\n    if ((&v0)[v2] > 1)\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":0,"function":"int *shuffle(int n) {\n    int *shuffled = (int *)calloc(n, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        shuffled[i] = i;\n    }\n    int temp;\n    for (int i = n - 1; i >= 0; i--) {\n        int pos = rand() % (i + 1);\n        temp = shuffled[i];\n        shuffled[i] = shuffled[pos];\n        shuffled[pos] = temp;\n    }\n    return shuffled;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long shuffle_name_conflict(unsigned long a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned int *v2;      // [bp-0x18]\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n  unsigned long long v8; // rax\n\n  v7 = &v5;\n  v2 = calloc((unsigned int)a0, 4);\n  for (v4 = 0; v4 < (unsigned int)a0; v4 += 1) {\n    v2[v4] = v4;\n  }\n  for (v3 = (unsigned int)a0 - 1; v3 >= 0; v3 -= 1) {\n    (unsigned int)v8 = rand();\n    v1 = ((unsigned int)v8 >> 31 CONCAT(unsigned int) v8) / m(v3 + 1) >> 32;\n    v0 = v2[v3];\n    v2[v3] = v2[v1];\n    v2[v1] = v0;\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpru7ia07c/shuffle_name_conflict.c:37:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 37 |         (unsigned int)v8 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpru7ia07c/shuffle_name_conflict.c:38:38: error: expected ')' 38 | v1\n= ((unsigned int)v8 >> 31 CONCAT (unsigned int)v8) /m (v3 + 1) >> 32; | ^\n/tmp/tmpru7ia07c/shuffle_name_conflict.c:38:14: note: to match this '('\n   38 |         v1 = ((unsigned int)v8 >> 31 CONCAT (unsigned int)v8) /m (v3 +\n1) >> 32; |              ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"int check_prefix(const char *prefix, const char *str) {\n    return strncmp(prefix, str, strlen(prefix)) == 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long check_prefix_name_conflict(char *a0, char *a1) {\n  return !strncmp(a0, a1, strlen(a0));\n}\n","pass":1,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":0,"function":"int read_labels(int **vector, int out_instances, int out_nodes, char *filename) {\n    FILE *labelset = fopen(filename, \"r\");\n    int bufflen = 20;\n    char *line = (char *)calloc(bufflen, sizeof(char));\n    int i = 0;\n    int min = 2147483647;\n    int max = (-2147483647 - 1);\n    while (fgets(line, bufflen, labelset))\n        {\n            (*vector)[i] = atoi(line);\n            if ((*vector)[i] < min)\n                min = (*vector)[i];\n            if ((*vector)[i] > max)\n                max = (*vector)[i];\n            i++;\n            if (i > out_instances) {\n                fprintf(stderr, \"ERROR: Too few allocated out rows!\\n\");\n                exit(1);\n            }\n        }\n    if (pow(2., out_nodes) < (max - min)) {\n        fprintf(stderr, \"ERROR: Too few nodes to represent the outputs!\\n\");\n        exit(1);\n    }\n    if (min != 0) {\n        for (int i = 0; i < out_instances; i++)\n            (*vector)[i] -= min;\n    }\n    free(line);\n    fclose(labelset);\n    return min;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\ndouble(pow)(double, double);\nint(atoi)(char *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_labels(unsigned long long *a0, unsigned long a1,\n                      unsigned long a2, char *a3) {\n  void *v0;        // [bp-0x40]\n  unsigned int v1; // [bp-0x34]\n  FILE_t *v2;      // [bp-0x30]\n  unsigned int v3; // [bp-0x28]\n  unsigned int v4; // [bp-0x24]\n  unsigned int v5; // [bp-0x20]\n  unsigned int v6; // [bp-0x1c]\n\n  v2 = &fopen(a3, \"r\")->_flags;\n  v1 = 20;\n  v0 = calloc(v1, 1);\n  v6 = 0;\n  v5 = 2147483647;\n  v4 = 0x80000000;\n  while (fgets(v0, v1, v2)) {\n    *((int *)(*(a0) + v6 * 4)) = atoi(v0);\n    if (v5 > *((int *)(*(a0) + (v6 << 2))))\n      v5 = *((int *)(*(a0) + v6 * 4));\n    if (v4 < *((int *)(*(a0) + (v6 << 2))))\n      v4 = *((int *)(*(a0) + v6 * 4));\n    v6 += 1;\n    if (v6 > (unsigned int)a1) {\n      fwrite(\"ERROR: Too few allocated out rows!\\n\", 1, 35,\n             stderr @GLIBC_2.2.5);\n      exit(1); /* do not return */\n    }\n  }\n  pow(0x4000000000000000, 0 CONCAT(int) a2);\n  if ((((char)(CmpF(v4 - v5, 0x4000000000000000) & 69) |\n        (char)((CmpF(v4 - v5, 0x4000000000000000) & 69) >> 6)) &\n       1) != 1) {\n    fwrite(\"ERROR: Too few nodes to represent the outputs!\\n\", 1, 47,\n           stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n  if (!v5) {\n    free(v0);\n    fclose(v2);\n    return v5;\n  }\n  for (v3 = 0; v3 < (unsigned int)a1; v3 += 1) {\n    *((unsigned int *)(*(a0) + v3 * 4)) = *((int *)(*(a0) + v3 * 4)) - v5;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgpjikurv/read_labels.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpgpjikurv/read_labels.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpgpjikurv/read_labels.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmpgpjikurv/read_labels.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpgpjikurv/read_labels.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmpgpjikurv/read_labels.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpgpjikurv/read_labels.c:16:8: error: conflicting types for 'fgets'\n   16 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpgpjikurv/read_labels.c:143:16: error:\nredefinition of '_IO_marker' 143 | typedef struct _IO_marker { | ^\n/tmp/tmpgpjikurv/read_labels.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpgpjikurv/read_labels.c:149:16: error: redefinition of '_IO_codecvt'\n  149 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpgpjikurv/read_labels.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpgpjikurv/read_labels.c:153:16: error: redefinition of '_IO_wide_data'\n  153 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpgpjikurv/read_labels.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpgpjikurv/read_labels.c:176:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 176 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpgpjikurv/read_labels.c:178:16: error: redeclaration of 'stderr' with a\ndifferent type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka 'struct\n_IO_FILE *') 178 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpgpjikurv /\n        read_labels.c : 178 : 22 : error\n    : expected ';' after top level declarator 178 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpgpjikurv / read_labels.c : 206 : 73 : error : expected ')' 206 |\n    fwrite(\"ERROR: Too few allocated out rows!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpgpjikurv /\n        read_labels.c : 206 : 19 : note : to match this '(' 206 |\n    fwrite(\"ERROR: Too few allocated out rows!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n| ^/ tmp / tmpgpjikurv / read_labels.c : 210 : 31 : error : expected ')' 210 |\n    pow(0x4000000000000000, 0 CONCAT(int) a2);\n|\n    ^/ tmp / tmpgpjikurv /\n        read_labels.c : 210 : 8 : note : to match this '(' 210 |\n    pow(0x4000000000000000, 0 CONCAT(int) a2);\n| ^/ tmp / tmpgpjikurv / read_labels.c : 213 : 81 : error : expected ')' 213 |\n    fwrite(\"ERROR: Too few nodes to represent the outputs!\\n\", 1, 47,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpgpjikurv /\n        read_labels.c : 213 : 15 : note : to match this '(' 213 |\n    fwrite(\"ERROR: Too few nodes to represent the outputs!\\n\", 1, 47,\n           stderr @GLIBC_2.2.5);\n| ^15 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":0,"function":"char *remove_whitespace(char *str) {\n    char *end;\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISspace))\n        str++;\n    if (*str == 0)\n        return str;\n    end = str + strlen(str) - 1;\n    while (end > str && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        end--;\n    *(end + 1) = 0;\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long remove_whitespace_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  char v1[2];            // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  for (v0 = a0;\n       (*((short *)((*(v0) << 1) + *((long long *)&__ctype_b_loc()))) & 0x2000);\n       v0 += 1)\n    ;\n  if (!*((char *)v0))\n    return v0;\n  for (*((unsigned long *)&v1) = v0 + strlen(v0) - 1;\n       v0 < v1 &&\n       (*((short *)((*((char *)v1) << 1) + *((long long *)&__ctype_b_loc()))) &\n        0x2000);\n       v1 -= 1)\n    ;\n  *((char *)(v1 + 1)) = 0;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxkqqbpvd/remove_whitespace_name_conflict.c:25:62: error: cannot take the address of an\nrvalue of type 'int' 25 |     for (v0 = a0; (*((short *)((*(v0) << 1) + *((long\nlong *)&__ctype_b_loc()))) & 0x2000); v0 += 1); | ^~~~~~~~~~~~~~~~\n/tmp/tmpxkqqbpvd/remove_whitespace_name_conflict.c:28:119: error: cannot take the address of\nan rvalue of type 'int' 28 |     for (*((unsigned long *)&v1) = v0 + strlen(v0)\n- 1; v0 < v1 && (*((short *)((*((char *)v1) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v1 -= 1); | ^~~~~~~~~~~~~~~~\n/tmp/tmpxkqqbpvd/remove_whitespace_name_conflict.c:28:153: error: invalid operands to binary\nexpression ('char[2]' and 'int') 28 |     for (*((unsigned long *)&v1) = v0 +\nstrlen(v0) - 1; v0 < v1 && (*((short *)((*((char *)v1) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x2000); v1 -= 1); | ~~ ^  ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kevinvandervlist_kesh/tokenize.c"}
{"compilable":0,"function":"int p(z)\n    int z;\n {\n    putchar(\"UniBwM\"[z % 6]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntyp_name_conflictedef unsigned int BOT;\ntyp_name_conflictedef unsigned int uint;\ntyp_name_conflictedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntyp_name_conflictedef unsigned int BOT;\ntyp_name_conflictedef unsigned int uint;\ntyp_name_conflictedef unsigned long ulong;\n\nint(p_name_conflictutchar)(int);\n\nextern char g_402004;\n\nlong long p_name_conflict(unsigned long a0) {\n  return p_name_conflictutchar(*(&(&g_402004)[a0 + -6 * (unsigned int)a0 / 6]));\n}\n","pass":0,"source_file":"C_COMPILE/florianl_stander/stander.c"}
{"compilable":1,"function":"unsigned int get_baud(unsigned int baud_rate) {\n    unsigned int BAUD = 0;\n    switch (baud_rate) {\n      case 921600:\n        BAUD = 4103;\n        break;\n      case 460800:\n        BAUD = 4100;\n        break;\n      case 230400:\n        BAUD = 4099;\n        break;\n      case 115200:\n        BAUD = 4098;\n        break;\n      default:\n        printf(\"Baud rate not recognized, using default B57600\\n\");\n      case 57600:\n        BAUD = 4097;\n        break;\n      case 38400:\n        BAUD = 15;\n        break;\n      case 19200:\n        BAUD = 14;\n        break;\n      case 9600:\n        BAUD = 13;\n        break;\n      case 4800:\n        BAUD = 12;\n        break;\n      case 2400:\n        BAUD = 11;\n        break;\n      case 1800:\n        BAUD = 10;\n        break;\n      case 1200:\n        BAUD = 9;\n        break;\n      case 600:\n        BAUD = 8;\n        break;\n      case 300:\n        BAUD = 7;\n        break;\n      case 200:\n        BAUD = 6;\n        break;\n      case 150:\n        BAUD = 5;\n        break;\n      case 134:\n        BAUD = 4;\n        break;\n      case 110:\n        BAUD = 3;\n        break;\n      case 75:\n        BAUD = 2;\n        break;\n      case 50:\n        BAUD = 1;\n        break;\n    }\n    return BAUD;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long get_baud_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  switch ((unsigned int)a0) {\n  case 921600:\n    v0 = 4103;\n    return v0;\n  default:\n    if ((unsigned int)a0 <= 0xe1000) {\n      if ((unsigned int)a0 == 0x70800) {\n        v0 = 4100;\n        return v0;\n      } else if ((unsigned int)a0 <= 0x70800) {\n        if ((unsigned int)a0 == 0x38400) {\n          v0 = 4099;\n          return v0;\n        } else if ((unsigned int)a0 <= 0x38400) {\n          if ((unsigned int)a0 == 0x1c200) {\n            v0 = 4098;\n            return v0;\n          } else if ((unsigned int)a0 <= 0x1c200) {\n            if ((unsigned int)a0 == 0xe100) {\n              v0 = 4097;\n              return v0;\n            } else if ((unsigned int)a0 <= 0xe100) {\n              if ((unsigned int)a0 == 0x9600) {\n                v0 = 15;\n                return v0;\n              } else if ((unsigned int)a0 <= 0x9600) {\n                if ((unsigned int)a0 == 0x4b00) {\n                  v0 = 14;\n                  return v0;\n                } else if ((unsigned int)a0 <= 0x4b00) {\n                  if ((unsigned int)a0 == 9600) {\n                    v0 = 13;\n                    return v0;\n                  } else if ((unsigned int)a0 <= 9600) {\n                    if ((unsigned int)a0 == 4800) {\n                      v0 = 12;\n                      return v0;\n                    } else if ((unsigned int)a0 <= 4800) {\n                      if ((unsigned int)a0 == 2400) {\n                        v0 = 11;\n                        return v0;\n                      } else if ((unsigned int)a0 <= 2400) {\n                        if ((unsigned int)a0 == 1800) {\n                          v0 = 10;\n                          return v0;\n                        } else if ((unsigned int)a0 <= 1800) {\n                          if ((unsigned int)a0 == 1200) {\n                            v0 = 9;\n                            return v0;\n                          } else if ((unsigned int)a0 <= 1200) {\n                            if ((unsigned int)a0 == 600) {\n                              v0 = 8;\n                              return v0;\n                            } else if ((unsigned int)a0 <= 600) {\n                              if ((unsigned int)a0 == 300) {\n                                v0 = 7;\n                                return v0;\n                              } else if ((unsigned int)a0 <= 300) {\n                                if ((unsigned int)a0 == 200) {\n                                  v0 = 6;\n                                  return v0;\n                                } else if ((unsigned int)a0 <= 200) {\n                                  if ((unsigned int)a0 == 150) {\n                                    v0 = 5;\n                                    return v0;\n                                  } else if ((unsigned int)a0 <= 150) {\n                                    if ((unsigned int)a0 == 134) {\n                                      v0 = 4;\n                                      return v0;\n                                    } else if ((unsigned int)a0 <= 134) {\n                                      if ((unsigned int)a0 == 110) {\n                                        v0 = 3;\n                                        return v0;\n                                      } else if ((unsigned int)a0 <= 110) {\n                                        if ((unsigned int)a0 == 50) {\n                                          v0 = 1;\n                                          return v0;\n                                        } else if ((unsigned int)a0 == 75) {\n                                          v0 = 2;\n                                          return v0;\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    puts(\"Baud rate not recognized, using default B57600\");\n    v0 = 4097;\n    return v0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"int serial_init(char *port_name, unsigned int baud) {\n    struct termios orig_termios, cur_termios;\n    int br = get_baud(baud);\n    fd = open(port_name, 2 | 256 | 2048);\n    if (fd == -1) {\n        printf(\"opening modem serial device : fd < 0\\n\");\n        return -1;\n    }\n    if (tcgetattr(fd, &orig_termios)) {\n        printf(\"getting modem serial device attr\\n\");\n        return -2;\n    }\n    cur_termios = orig_termios;\n    cur_termios.c_iflag &= ~(1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 1024 | 2048 | 4096 | 8192);\n    cur_termios.c_iflag |= 2;\n    cur_termios.c_oflag &= ~(1 | 4 | 8 | 16 | 32);\n    cur_termios.c_cflag &= ~(48 | 64 | 128 | 256 | 512 | 1024 | 2048);\n    cur_termios.c_cflag |= 128 | 48 | 2048;\n    cur_termios.c_cflag &= ~(2147483648U);\n    cur_termios.c_lflag &= ~(1 | 2 | 32768 | 8 | 4096 | 16384);\n    cur_termios.c_lflag |= 128;\n    if (cfsetspeed(&cur_termios, br)) {\n        printf(\"setting modem serial device speed\\n\");\n        return -3;\n    }\n    if (tcsetattr(fd, 1, &cur_termios)) {\n        printf(\"setting modem serial device attr\\n\");\n        return -4;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_baud)(long long);\nint(open)(char *, int, unsigned short);\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(cfsetspeed)(\n    struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *,\n    unsigned int);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern unsigned int fd;\n\nlong long serial_init_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  termios\n      v0; // [bp-0x88], Other Possible Types: unsigned long long, unsigned int\n  int tmp_135;            // tmp #135\n  int tmp_183;            // tmp #183\n  unsigned int v1;        // [bp-0x84]\n  unsigned int v2;        // [bp-0x80], Other Possible Types: unsigned long long\n  unsigned int v3;        // [bp-0x7c]\n  unsigned long long v4;  // [bp-0x78]\n  unsigned long long v5;  // [bp-0x70]\n  unsigned long long v6;  // [bp-0x68]\n  unsigned long long v7;  // [bp-0x60]\n  unsigned long v8;       // [bp-0x5c]\n  unsigned long long v9;  // [bp-0x54]\n  termios v10;            // [bp-0x48]\n  char v11;               // [bp-0x40]\n  char v12;               // [bp-0x38]\n  char v13;               // [bp-0x30]\n  char v14;               // [bp-0x28]\n  char v15;               // [bp-0x20]\n  unsigned long v16;      // [bp-0x1c]\n  char v17;               // [bp-0x14]\n  unsigned int v18;       // [bp-0xc]\n  unsigned long long v23; // rax\n\n  v18 = get_baud((unsigned int)a1);\n  fd = open(a0, 2306, a2);\n  if (fd == -1) {\n    puts(\"opening modem serial device : fd < 0\");\n    return 4294967295;\n  } else if (!tcgetattr(fd, &v10)) {\n    v0 = *((long long *)&v10.c_iflag);\n    v2 = *((long long *)&v11);\n    v4 = *((long long *)&v12);\n    v5 = *((long long *)&v13);\n    v6 = *((long long *)&v14);\n    v7 = *((long long *)&v15);\n    v8 = v16;\n    v9 = *((long long *)&v17);\n    v0 = (int)v0 & -0x3e00;\n    v0.c_iflag = v0 | 2;\n    tmp_135 = *((int *)((char *)&v0 + 4));\n    v1 = tmp_135 & -62;\n    v2 = (int)v2 & -4081;\n    v2 |= 2224;\n    v2 &= 2147483647;\n    tmp_183 = *((int *)((char *)&v2 + 4));\n    v3 = tmp_183 & -53260;\n    v23 = v3;\n    *((char *)&v23) = (char)v23 | 128;\n    v3 = v23;\n    if (cfsetspeed(&v0, v18)) {\n      puts(\"setting modem serial device speed\");\n      return 4294967293;\n    } else if (tcsetattr(fd, 1, &v0)) {\n      puts(\"setting modem serial device attr\");\n      return 0xfffffffc;\n    } else {\n      return 0;\n    }\n  } else {\n    puts(\"getting modem serial device attr\");\n    return 4294967294;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwk7_y342/serial_init_name_conflict.c:98:12: error: assigning to 'termios' (aka 'struct\ntermios') from incompatible type 'long long' 98 |         v0 = *((long long\n*)&v10.c_iflag); |            ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwk7_y342/serial_init_name_conflict.c:106:19: error: operand of type 'termios' (aka\n'struct termios') where arithmetic or pointer type is required 106 |         v0\n= (int)v0 & -0x3e00; |                   ^~\n/tmp/tmpwk7_y342/serial_init_name_conflict.c:107:25: error: invalid operands to binary\nexpression ('termios' (aka 'struct termios') and 'int') 107 |         v0.c_iflag\n= v0 | 2; |                      ~~ ^ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":1,"function":"bool in_download_range(int download_id) {\n    if (download_id <= log_index.last_completed_log && download_id > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_405464;\n\nlong long in_download_range_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 <= g_405464 && (unsigned int)a0 > 0)\n    return 1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\nlong long uri_decode_name_conflict(char *a0) {\n  char v0;         // [bp-0x2c]\n  char v1;         // [bp-0x2b]\n  char *v2;        // [bp-0x28]\n  unsigned int v3; // [bp-0x20]\n  unsigned int v4; // [bp-0x1c]\n  unsigned int v6; // eax\n\n  v4 = 0;\n  v3 = 0;\n  v2 = malloc(strlen(a0));\n  for (v4 = 0; v4 < strlen(a0); v4 += 1) {\n    v6 = a0[v4];\n    if (v6 == 37) {\n      sprintf(&v1, \"%c%c\", a0[1 + v4], a0[2 + v4]);\n      v4 += 2;\n      __isoc99_sscanf(&v1, \"%x\", (unsigned int)&v0);\n      v2[v3] = v0;\n      v3 += 1;\n    } else if (v6 != 43) {\n      v2[v3] = a0[v4];\n      v3 += 1;\n    } else {\n      v2[v3] = 32;\n      v3 += 1;\n    }\n  }\n  v2[v3] = 0;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/certego_webshell/fuzzdb-webshell/c/cmd.c"}
{"compilable":0,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\nlong long uri_decode_name_conflict(char *a0) {\n  char v0;         // [bp-0x2c]\n  char v1;         // [bp-0x2b]\n  char *v2;        // [bp-0x28]\n  unsigned int v3; // [bp-0x20]\n  unsigned int v4; // [bp-0x1c]\n  unsigned int v6; // eax\n\n  v4 = 0;\n  v3 = 0;\n  v2 = malloc(strlen(a0));\n  for (v4 = 0; v4 < strlen(a0); v4 += 1) {\n    v6 = a0[v4];\n    if (v6 == 37) {\n      sprintf(&v1, \"%c%c\", a0[1 + v4], a0[2 + v4]);\n      v4 += 2;\n      __isoc99_sscanf(&v1, \"%x\", (unsigned int)&v0);\n      v2[v3] = v0;\n      v3 += 1;\n    } else if (v6 != 43) {\n      v2[v3] = a0[v4];\n      v3 += 1;\n    } else {\n      v2[v3] = 32;\n      v3 += 1;\n    }\n  }\n  v2[v3] = 0;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/certego_webshell/web-malware-collection-13-06-2012/Other/cmd.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isAlphanum_name_conflict(unsigned long a0) {\n  if (((unsigned int)a0 <= 96 || (unsigned int)a0 > 122) &&\n      ((unsigned int)a0 <= 47 || (unsigned int)a0 > 57) &&\n      ((unsigned int)a0 <= 64 || (unsigned int)a0 > 90) &&\n      (unsigned int)a0 != 95 && (unsigned int)a0 != 36 &&\n      (unsigned int)a0 != 92 && (unsigned int)a0 <= 126)\n    return 0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\nextern unsigned int theLookahead;\n\nlong long get() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = theLookahead;\n  theLookahead = -1;\n  if (v0 == -1)\n    v0 = getc(stdin @GLIBC_2.2.5);\n  if (v0 <= 31 && v0 != 10 && v0 != -1)\n    return (v0 == 13 ? 32 : 10);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0q6ewxyx/get.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp0q6ewxyx/get.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp0q6ewxyx/get.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmp0q6ewxyx/get.c:76:22: error: type name requires a specifier or qualifier\n   76 |             } __value;\n      |                      ^\n/tmp/tmp0q6ewxyx/get.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmp0q6ewxyx/get.c:83:22: error: type name requires a specifier or qualifier\n   83 |             } __value;\n      |                      ^\n/tmp/tmp0q6ewxyx/get.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp0q6ewxyx/get.c:106:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp0q6ewxyx/get.c:106:21: error: expected ';' after top level declarator\n  106 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmp0q6ewxyx/get.c:116:24: error: expected ')'\n  116 |         v0 = getc(stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmp0q6ewxyx/get.c:116:18: note: to match this '('\n  116 |         v0 = getc(stdin@GLIBC_2.2.5);\n      |                  ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get)();\n\nextern unsigned int theLookahead;\n\nlong long peek_name_conflict() {\n  theLookahead = get();\n  return theLookahead;\n}\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get)();\nlong long(peek)();\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long next_name_conflict() {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n  unsigned long long v4; // rax\n\n  v0 = get();\n  if (v0 != 47)\n    return v0;\n  (unsigned int)v2 = peek();\n  if ((unsigned int)v2 == 42) {\n    get();\n    while (true) {\n      do {\n        (unsigned int)v4 = get();\n        if ((unsigned int)v4 == -1) {\n          fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35,\n                 stderr @GLIBC_2.2.5);\n          exit(1); /* do not return */\n        }\n      } while ((unsigned int)v4 != 42);\n      if ((int)peek() == 47)\n        break;\n    }\n    get();\n    return 32;\n  } else if ((unsigned int)v2 == 47) {\n    do {\n      v0 = get();\n    } while (v0 > 10);\n    return v0;\n  } else {\n    return v0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgl2h5_mi/next_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpgl2h5_mi/next_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpgl2h5_mi/next_name_conflict.c:30:5: error: assignment to cast is illegal, lvalue casts\nare not supported 30 |     (unsigned int)v2 = peek(); |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpgl2h5_mi/next_name_conflict.c:38:17: error: assignment to cast is illegal, lvalue\ncasts are not supported 38 |                 (unsigned int)v4 = get(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpgl2h5_mi/next_name_conflict.c:41:81: error: expected ')' 41 |\nfwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpgl2h5_mi/next_name_conflict.c:41:27: note: to match this '('\n   41 |                     fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1,\n35, stderr@GLIBC_2.2.5); |                           ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"int readNlSock(int sockFd, char *bufPtr, size_t buf_size, int seqNum, int pId) {\n    struct nlmsghdr *nlHdr;\n    int readLen = 0, msgLen = 0;\n    do {\n        if ((readLen = recv(sockFd, bufPtr, buf_size - msgLen, 0)) < 0) {\n            perror(\"SOCK READ: \");\n            return -1;\n        }\n        nlHdr = (struct nlmsghdr *)bufPtr;\n        if ((((readLen) >= (int)sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len <= (readLen)) == 0) || (nlHdr->nlmsg_type == 2)) {\n            perror(\"Error in recieved packet\");\n            return -1;\n        }\n        if (nlHdr->nlmsg_type == 3) {\n            break;\n        } else {\n            bufPtr += readLen;\n            msgLen += readLen;\n        }\n        if ((nlHdr->nlmsg_flags & 2) == 0) {\n            break;\n        }\n    } while ((nlHdr->nlmsg_seq != seqNum) || (nlHdr->nlmsg_pid != pId));\n    return msgLen;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\nvoid(perror)(char *);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n  unsigned short field_6;\n  unsigned int field_8;\n  unsigned int field_c;\n} struct_0;\n\nlong long readNlSock(unsigned long a0, struct_0 *a1, unsigned long a2,\n                     unsigned long a3, unsigned long a4) {\n  struct_0 *v0;    // [bp-0x28], Other Possible Types: unsigned long\n  struct_0 *v1;    // [bp-0x18]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v5; // eax\n\n  v0 = a1;\n  v2 = 0;\n  v3 = 0;\n  while (true) {\n    v2 = recv(a0, v0, a2 - v3, 0);\n    if (v2 < 0) {\n      perror(\"SOCK READ: \");\n      return 4294967295;\n    }\n    v1 = v0;\n    if (v2 <= 15 || v1->field_0 <= 15 || v2 < v1->field_0)\n      v5 = 0;\n    else\n      v5 = 1;\n    if (!(v5) || !(v1->field_4 != 2)) {\n      perror(\"Error in recieved packet\");\n      return 4294967295;\n    }\n    if (v1->field_4 != 3) {\n      v0 = (char *)v0 + v2;\n      v3 += v2;\n    } else {\n      break;\n    }\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4328uc3z/readNlSock.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":1,"function":"int parseRoutes(struct nlmsghdr *nlHdr, struct route_info *rtInfo) {\n    struct rtmsg *rtMsg;\n    struct rtattr *rtAttr;\n    int rtLen;\n    rtMsg = (struct rtmsg *)((void *)(((char *)nlHdr) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    if ((rtMsg->rtm_family != 2) || (rtMsg->rtm_table != RT_TABLE_MAIN))\n        return -1;\n    rtAttr = (struct rtattr *)((struct rtattr *)(((char *)(rtMsg)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1))));\n    rtLen = ((nlHdr)->nlmsg_len - ((((((sizeof(struct rtmsg))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    for (; ((rtLen) >= (int)sizeof(struct rtattr) && (rtAttr)->rta_len >= sizeof(struct rtattr) && (rtAttr)->rta_len <= (rtLen)); rtAttr = ((rtLen) -= ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rtAttr)) + ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1))))) {\n        switch (rtAttr->rta_type) {\n          case RTA_OIF:\n            if_indextoname(*(int *)((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), rtInfo->ifName);\n            break;\n          case RTA_GATEWAY:\n            memcpy(&rtInfo->gateWay, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->gateWay));\n            break;\n          case RTA_PREFSRC:\n            memcpy(&rtInfo->srcAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->srcAddr));\n            break;\n          case RTA_DST:\n            memcpy(&rtInfo->dstAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->dstAddr));\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(if_indextoname)(unsigned int, char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long parseRoutes_name_conflict(unsigned int *a0, unsigned int a1[3]) {\n  char v0[5];      // [bp-0x20]\n  unsigned int v1; // [bp-0x14]\n  struct_0 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v5; // eax\n\n  *((unsigned int **)&v0) = a0 + 4;\n  if (v0[0] == 2 && v0[4] == 254) {\n    v2 = &v0[2 + 2];\n    for (v1 = *(a0)-28;\n         v1 > 3 && v2->field_0 << 48 > 0x3000000000000 && v1 >= v2->field_0;\n         v2 = (char *)v2 + (v2->field_0 + 3 & 0xfffffffc)) {\n      v5 = v2->field_2;\n      if (v5 == 7) {\n        a1[1] = v2->field_4;\n      } else if (v5 <= 7) {\n        if (v5 == 5) {\n          a1[2] = v2->field_4;\n        } else if (v5 <= 5) {\n          if (v5 == 1) {\n            a1[0] = v2->field_4;\n          } else if (v5 == 4) {\n            if_indextoname(v2->field_4, a1 + 1);\n          }\n        }\n      }\n      v1 -= v2->field_0 + 3 & 0xfffffffc;\n    }\n    return 0;\n  }\n  return 4294967295;\n}\n","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int get_gatewayip(char *gatewayip, socklen_t size) {\n    int found_gatewayip = 0;\n    struct nlmsghdr *nlMsg;\n    struct route_info route_info;\n    char msgBuf[8192];\n    int sock, len, msgSeq = 0;\n    if ((sock = socket(16, SOCK_DGRAM, 0)) < 0) {\n        perror(\"Socket Creation: \");\n        return (-1);\n    }\n    memset(msgBuf, 0, sizeof (msgBuf));\n    nlMsg = (struct nlmsghdr *)msgBuf;\n    nlMsg->nlmsg_len = ((sizeof(struct rtmsg)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n    nlMsg->nlmsg_type = RTM_GETROUTE;\n    nlMsg->nlmsg_flags = (256 | 512) | 1;\n    nlMsg->nlmsg_seq = msgSeq++;\n    nlMsg->nlmsg_pid = getpid();\n    if (send(sock, nlMsg, nlMsg->nlmsg_len, 0) < 0) {\n        fprintf(stderr, \"Write To Socket Failed...\\n\");\n        return -1;\n    }\n    if ((len = readNlSock(sock, msgBuf, sizeof (msgBuf), msgSeq, getpid())) < 0) {\n        fprintf(stderr, \"Read From Socket Failed...\\n\");\n        return -1;\n    }\n    for (; ((len) >= (int)sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len <= (len)); nlMsg = ((len) -= ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlMsg)) + ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n        memset(&route_info, 0, sizeof (route_info));\n        if (parseRoutes(nlMsg, &route_info) < 0)\n            continue;\n        if (strstr((char *)inet_ntoa(route_info.dstAddr), \"0.0.0.0\")) {\n            inet_ntop(2, &route_info.gateWay, gatewayip, size);\n            found_gatewayip = 1;\n            break;\n        }\n    }\n    close(sock);\n    return found_gatewayip;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nvoid(perror)(char *);\nlong(send)(int, void *, unsigned long, int);\nlong long(readNlSock)(long long, long long, long long, long long, long long);\nint(close)(int);\nlong long(parseRoutes)(long long, long long);\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nchar *(inet_ntop)(int, void *, char *, int);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[3];\n  unsigned short field_4;\n  unsigned short field_6;\n  unsigned int field_8;\n  unsigned int field_c;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_gatewayip(char *a0, unsigned long a1) {\n  char v0;          // [bp-0x2048]\n  char v1;          // [bp-0x48]\n  char v2;          // [bp-0x40]\n  unsigned int v3;  // [bp-0x24]\n  unsigned int v4;  // [bp-0x20]\n  unsigned int v5;  // [bp-0x1c]\n  struct_0 *v6;     // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v7;  // [bp-0xc]\n  unsigned int v10; // eax\n\n  v7 = 0;\n  v4 = 0;\n  v3 = socket(16, 2, 0);\n  if (v3 < 0) {\n    perror(\"Socket Creation: \");\n    return 4294967295;\n  }\n  memset(&v0, 0, 0x2000);\n  v6 = &v0;\n  *((int *)&v6->field_0) = 28;\n  v6->field_4 = 26;\n  v6->field_6 = 769;\n  v10 = v4;\n  v4 = v10 + 1;\n  v6->field_8 = v10;\n  v6->field_c = getpid();\n  if (send(v3, v6, *((int *)&v6->field_0), 0) < 0) {\n    fwrite(\"Write To Socket Failed...\\n\", 1, 26, stderr @GLIBC_2.2.5);\n    return 4294967295;\n  } else if (v5 >= 0) {\n    for (v5 = readNlSock(v3, &v0, 0x2000, v4, getpid());\n         v5 > 15 && *((int *)v6) > 15 && v5 >= *((int *)v6);\n         v6 += *((int *)v6) + 3 & -0x4) {\n      memset(&v1, 0, 28);\n      if ((int)parseRoutes(v6, &v1) < 0 || !strstr(inet_ntoa(), \"0.0.0.0\")) {\n        v5 -= *((int *)v6) + 3 & -0x4;\n      } else {\n        inet_ntop(2, &v2, a0, a1);\n        v7 = 1;\n        break;\n      }\n    }\n    close(v3);\n    return v7;\n  } else {\n    fwrite(\"Read From Socket Failed...\\n\", 1, 27, stderr @GLIBC_2.2.5);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5s573t5j/get_gatewayip.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp5s573t5j/get_gatewayip.c:36:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 36 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5s573t5j/get_gatewayip.c:36:22: error: expected ';' after top level\ndeclarator 36 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp5s573t5j/get_gatewayip.c:69:60: error: expected ')'\n   69 |         fwrite(\"Write To Socket Failed...\\n\", 1, 26,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5s573t5j/get_gatewayip.c:69:15: note: to match\nthis '(' 69 |         fwrite(\"Write To Socket Failed...\\n\", 1, 26,\nstderr@GLIBC_2.2.5); |               ^ /tmp/tmp5s573t5j/get_gatewayip.c:77:68:\nerror: too few arguments to function call, expected 1, have 0 77 | if\n((int)parseRoutes(v6, &v1) < 0 || !strstr(inet_ntoa(), \"0.0.0.0\")) | ~~~~~~~~~ ^\n/tmp/tmp5s573t5j/get_gatewayip.c:22:8: note: 'inet_ntoa' declared here\n   22 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n/tmp/tmp5s573t5j/get_gatewayip.c:93:61: error: expected ')'\n   93 |         fwrite(\"Read From Socket Failed...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp5s573t5j/get_gatewayip.c:93:15: note: to match\nthis '(' 93 |         fwrite(\"Read From Socket Failed...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); |               ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":1,"function":"int compare_mac(MAC *m1, MAC *m2) {\n    return memcmp(m1, m2, 6);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long compare_mac_name_conflict(void *a0, void *a1) { return memcmp(a0, a1, 6); }\n","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":1,"function":"int compare_ip(IP *ip1, IP *ip2) {\n    return memcmp(ip1, ip2, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long compare_ip_name_conflict(void *a0, void *a1) { return memcmp(a0, a1, 4); }\n","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x18], Other Possible Types: unsigned long long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 1;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 0x1dcd6500 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwgid4va5/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |             ^\n/tmp/tmpwgid4va5/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |          ^\n/tmp/tmpwgid4va5/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |                          ^\n      |                          ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) == -1) {\n      return 4294967295;\n    } else if (strcmp(a0, *((long long *)(vocab +\n                                          (*((int *)(vocab_hash + (v0 << 2)))\n                                           << 4) +\n                                          8)))) {\n      v0 = (0 CONCAT v0 + 1) / m 0x1dcd6500 >> 32;\n    } else {\n      return *((int *)(vocab_hash + v0 * 4));\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpls5w6yrm/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                     ^\n/tmp/tmpls5w6yrm/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                  ^\n/tmp/tmpls5w6yrm/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 60)\n    v0 = 60;\n  *((void **)(8 + (char *)vocab + 16 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(8 + (char *)vocab + 16 * vocab_size)), a0);\n  *((long long *)((char *)vocab + 16 * vocab_size)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 0x1dcd6500 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvqn5sp_6/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpvqn5sp_6/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpvqn5sp_6/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpvqn5sp_6/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 30000000 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn66d0007/GetWordHash_name_conflict.c:29:27: error: invalid operands to binary\nexpression ('int' and 'void *') 29 |         v0 = v1[a0] + 257 * v0; | ~~~ ^ ~~\n/tmp/tmpn66d0007/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |             ^\n/tmp/tmpn66d0007/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |          ^\n/tmp/tmpn66d0007/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |                          ^\n      |                          ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) != -1) {\n      v2 = *((int *)(vocab_hash + v0 * 4));\n      if (!strcmp(a0, *((long long *)(((v2 << 2) + v2 << 3) + vocab + 16))))\n        return *((int *)(vocab_hash + v0 * 4));\n      v0 = (0 CONCAT v0 + 1) / m 30000000 >> 32;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_aunw6c8/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                     ^\n/tmp/tmp_aunw6c8/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                  ^\n/tmp/tmp_aunw6c8/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 100)\n    v0 = 100;\n  *((void **)(16 + (char *)vocab + 40 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(16 + 40 * vocab_size + (char *)vocab)), a0);\n  *((long long *)(40 * vocab_size + (char *)vocab)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 30000000 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcsr6iykc/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpcsr6iykc/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpcsr6iykc/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpcsr6iykc/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"char *rat(char *message) {\n    char *cyphertext = (char *)malloc(sizeof(char) * strlen(message));\n    int i;\n    for (i = 0; i < strlen(message); i++) {\n        cyphertext[i] = (isalpha(message[i])) ? (((message[i] + 13 - 'a') % 26) + 'a') : message[i];\n    }\n    return cyphertext;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(isalpha)(int);\n\nlong long rat_name_conflict(char *a0) {\n  char *v0;              // [bp-0x28]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n  unsigned long v6;      // rbx\n  unsigned long long v8; // rbx\n\n  v5 = &v3;\n  v2 = v6;\n  v0 = malloc(strlen(a0));\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    *((int *)&v0[v1]) =\n        (!isalpha(a0[v1]) ? (char)(a0[v1] - 84 -\n                                   (unsigned int)((a0[v1] - 84) / 26) * 26 + 97)\n                          : a0[v1]);\n  }\n  v8 = v2;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/chamoysvoice_rat13/rat13.c"}
{"compilable":1,"function":"int is_delimeter(char c) {\n    int ii = 0;\n    char dlms[] = \"\\t\\r\\n (){}[]+-*/%\\\"'&|^~:;<>.,\";\n    while (dlms[ii])\n        {\n            if (c == dlms[ii++])\n                return 1;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_delimeter_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x28]\n  char v1;               // [bp-0x1c]\n  unsigned int v2;       // [bp-0xc]\n  unsigned long long v4; // rdx\n  unsigned long v5;      // rax\n\n  v2 = 0;\n  strncpy(&v0, \"\\t\\r\\n (){}[]+-*/%\\\"\", 16);\n  v4 = 12435743808633470;\n  strncpy(&v1, \"*/%\\\"\\'&|^~:;<>.,\", 15);\n  while (true) {\n    if ((&v0)[v2]) {\n      v5 = v2;\n      v2 = (unsigned int)v5 + 1;\n      if ((char)a0 == (&v0)[v5])\n        return 1;\n    } else {\n      return 0;\n    }\n  }\n}\n","pass":1,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":1,"function":"int is_keyword(char *str) {\n    char *kwords[] = {\"asm\", \"auto\", \"break\", \"case\", \"cdecl\", \"char\", \"class\", \"const\", \"continue\", \"default\", \"delete\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"far\", \"float\", \"for\", \"friend\", \"goto\", \"huge\", \"if\", \"inline\", \"int\", \"interrupt\", \"long\", \"near\", \"new\", \"operator\", \"pascal\", \"private\", \"protected\", \"public\", \"register\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"template\", \"this\", \"typedef\", \"union\", \"unsigned\", \"virtual\", \"void\", \"volatile\", \"while\", ((void *)0)};\n    int ii = 0;\n    int jj;\n    int check;\n    while (kwords[ii])\n        {\n            jj = 0;\n            check = 1;\n            while (kwords[ii][jj] && check)\n                {\n                    if (str[jj] != kwords[ii][jj]) {\n                        check = 0;\n                    }\n                    jj++;\n                }\n            if (check)\n                return 1;\n            ii++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern unsigned long long g_404080;\n\nlong long is_keyword_name_conflict(char *a0) {\n  char *v0;               // [bp-0x1c0]\n  char v1;                // [bp-0x1b8]\n  unsigned int v2;        // [bp-0x14]\n  unsigned int v3;        // [bp-0x10]\n  unsigned int v4;        // [bp-0xc]\n  unsigned long v6;       // rcx, Other Possible Types: unsigned long long\n  struct_0 *v7;           // rdi, Other Possible Types: unsigned long\n  unsigned long long *v8; // rsi, Other Possible Types: unsigned long\n  unsigned long v9;       // d\n\n  v0 = a0;\n  v6 = 52;\n  v7 = &v1;\n  for (v8 = &g_404080; v6; v8 += v9 * 8) {\n    v6 -= 1;\n    *((long long *)v7) = *((long long *)v8);\n    v7 += v9 * 8;\n  }\n  for (v4 = 0; *((long long *)&(&v1)[8 * v4]); v4 += 1) {\n    v3 = 0;\n    for (v2 = 1; *((char *)(v3 + *((long long *)&(&v1)[8 * v4]))) && v2;\n         v3 += 1) {\n      if (v0[v3] != *((char *)(v3 + *((long long *)&(&v1)[8 * v4]))))\n        v2 = 0;\n    }\n    if (v2)\n      return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":0,"function":"static int load_uca_file(MY_UCA *uca, size_t maxchar, int *pageloaded) {\n    char str[512];\n    size_t lineno, out_of_range_chars = 0;\n    char *weights[64];\n    for (lineno = 0; fgets(str, sizeof (str), stdin); lineno++) {\n        char *comment;\n        char *weight;\n        char *s, *ch[6];\n        size_t codenum, i, code;\n        MY_UCA_ITEM *item = ((void *)0);\n        if (*str == '\\r' || *str == '\\n' || *str == '#')\n            continue;\n        if (*str == '@' && !strncmp(str, \"@version \", 9)) {\n            const char *value;\n            if (strtok(str, \" \\r\\n\\t\") && (value = strtok(((void *)0), \" \\r\\n\\t\")))\n                snprintf(uca->version, 32, value);\n            continue;\n        }\n        if ((code = strtol(str, ((void *)0), 16)) > maxchar) {\n            out_of_range_chars++;\n            continue;\n        }\n        if ((comment = strchr(str, '#'))) {\n            *comment++ = '\\x00';\n            for (; *comment == ' '; comment++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n'%s'\\n\", lineno, str);\n            continue;\n        }\n        if ((weight = strchr(str, ';'))) {\n            *weight++ = '\\x00';\n            for (; *weight == ' '; weight++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n%s\\n\", lineno, str);\n            continue;\n        }\n        for (codenum = 0 , s = strtok(str, \" \\t\"); s; codenum++ , s = strtok(((void *)0), \" \\t\")) {\n            if (codenum == 6) {\n                fprintf(stderr, \"Contraction length is too long (%d) line #%d\", codenum, lineno);\n                exit(1);\n            }\n            ch[codenum] = s;\n            ch[codenum + 1] = 0;\n        }\n        if (codenum > 1) {\n            MY_UCA_CONTRACTION *c = &uca->contraction[uca->ncontractions++];\n            size_t i;\n            if (uca->ncontractions >= 1024) {\n                fprintf(stderr, \"Too many contractions (%d) at line #%d\\nRebuild with a bigger MY_UCA_MAXCONTRACTIONS value\\n\", uca->ncontractions, lineno);\n                exit(1);\n            }\n            for (i = 0; i < 6; i++) {\n                c->ch[i] = (i < codenum) ? (uint)strtol(ch[i], ((void *)0), 16) : 0;\n            }\n            if (uca->debug)\n                fprintf(stderr, \"Contraction: %04X-%04X-%04X\\n\", c->ch[0], c->ch[1], c->ch[2]);\n            item = &c->item;\n        } else {\n            item = &uca->item[code];\n        }\n        item->num = 0;\n        s = strtok(weight, \" []\");\n        while (s)\n            {\n                if (item->num >= 64) {\n                    fprintf(stderr, \"Line #%d has more than %d weights\\n\", lineno, 64);\n                    fprintf(stderr, \"Can't continue.\\n\");\n                    exit(1);\n                }\n                weights[item->num] = s;\n                s = strtok(((void *)0), \" []\");\n                item->num++;\n            }\n        for (i = 0; i < item->num; i++) {\n            size_t level = 0;\n            if (i >= 8) {\n                fprintf(stderr, \"Warning: at line %d: character %04X has more than %d many weights (%d). Skipping the extra weights.\\n\", lineno, code, 8, item->num);\n                item->num = 8;\n                break;\n            }\n            for (s = weights[i]; *s;) {\n                char *endptr;\n                size_t part = strtol(s + 1, &endptr, 16);\n                if (i < 8) {\n                    item->weight[level][i] = part;\n                } else {\n                    fprintf(stderr, \"Too many weights (%d) at line %d\\n\", i, lineno);\n                    exit(1);\n                }\n                s = endptr;\n                level++;\n            }\n        }\n        pageloaded[code >> 8]++;\n    }\n    if (out_of_range_chars)\n        fprintf(stderr, \"%d out-of-range characters skipped\\n\", out_of_range_chars);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\nchar *(strtok)(char *, char *);\nint(snprintf)(char *, unsigned long, char *, ...);\n\ntypedef struct struct_0 {\n  char padding_0[91357216];\n  unsigned long long field_5720020;\n  char padding_5720028[110596];\n  unsigned int field_573b02c;\n} struct_0;\n\ntypedef struct struct_1 {\n  char *field_0;\n  unsigned int field_8;\n} struct_1;\n\nextern FILE_t *__TMC_END__;\nextern char g_403120;\nextern char g_5720020;\nextern char g_573b02c;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long load_uca_file(struct_0 *a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0;       // [bp-0x4d0]\n  char v1;                // [bp-0x4b8]\n  char *v2;               // [bp-0x480]\n  char v3;                // [bp-0x478]\n  char v4;                // [bp-0x278]\n  unsigned long v5;       // [bp-0x78]\n  unsigned long v6;       // [bp-0x70]\n  unsigned long v7;       // [bp-0x68]\n  char *v8;               // [bp-0x60]\n  void *v9;               // [bp-0x58], Other Possible Types: unsigned long\n  unsigned long v10;      // [bp-0x50]\n  char *v11;              // [bp-0x48], Other Possible Types: unsigned long\n  unsigned long v12;      // [bp-0x40]\n  struct_1 *v13;          // [bp-0x38], Other Possible Types: unsigned long\n  char *v14;              // [bp-0x30], Other Possible Types: unsigned long\n  char *v15;              // [bp-0x28], Other Possible Types: unsigned long\n  char *v16;              // [bp-0x20], Other Possible Types: unsigned long\n  void *v17;              // [bp-0x18], Other Possible Types: unsigned long\n  void *v18;              // [bp-0x10], Other Possible Types: unsigned long\n  char *v20;              // rax\n  char *v21;              // rax\n  unsigned long long v22; // rdx\n  unsigned long long v23; // rax\n  unsigned long long v24; // rdx\n  unsigned int *v26;      // rax\n\n  v0 = a2;\n  v17 = 0;\n  for (v18 = 0; fgets(&v4, 0x200, __TMC_END__); v18 += 1) {\n    v11 = 0;\n    if (!(v4 == 13 || v4 == 10 || v4 == 35)) {\n      if (v4 != 64 || strncmp(&v4, \"@version \", 9)) {\n        v7 = strtol(&v4, NULL, 16);\n        if (a1 < v7) {\n          v17 += 1;\n        } else {\n          v16 = strchr(&v4, 35);\n          if (!v16) {\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"Warning: could not parse line #%d:\\n'%s'\\n\",\n                    (unsigned int)v18, (unsigned int)&v4);\n          } else {\n            v20 = v16;\n            v16 = v20 + 1;\n            for (*(v20) = 0; *((char *)v16) == 32; v16 += 1)\n              ;\n            v15 = strchr(&v4, 59);\n            if (!v15) {\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"Warning: could not parse line #%d:\\n%s\\n\",\n                      (unsigned int)v18, (unsigned int)&v4);\n            } else {\n              v21 = v15;\n              v15 = v21 + 1;\n              for (*(v21) = 0; *(v15) == 32; v15 += 1)\n                ;\n              v13 = 0;\n              for (v14 = strtok(&v4, \" \\t\"); v14; v14 = strtok(NULL, \" \\t\")) {\n                if (v13 != 6) {\n                  *((unsigned long *)&(&v1)[8 * v13]) = v14;\n                  *((long long *)&(&v1)[8 + 8 * v13]) = 0;\n                  v13 += 1;\n                } else {\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Contraction length is too long (%d) line #%d\",\n                          (unsigned int)v13, (unsigned int)v18);\n                  exit(1); /* do not return */\n                }\n              }\n              if (v13 <= 1) {\n                v24 = v7;\n                v11 = &a0->padding_0[32 + 80 * v24 + 2 * v24];\n              } else {\n                v22 = *((long long *)(a0 + &g_5720020));\n                *((unsigned long long *)(a0 + &g_5720020)) = v22 + 1;\n                v23 = 3 * v22;\n                v6 = a0 + &(&g_5720020)[32 * v23 + 4 * v23] + 8;\n                if (*((long long *)(a0 + &g_5720020)) > 1023) {\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Too many contractions (%d) at line #%d\\nRebuild \"\n                          \"with a bigger MY_UCA_MAXCONTRACTIONS value\\n\",\n                          (int)*((long long *)(a0 + &g_5720020)),\n                          (unsigned int)v18);\n                  exit(1); /* do not return */\n                }\n                for (v10 = 0; v10 <= 5; v10 += 1) {\n                  *((int *)(v6 + v10 * 4)) =\n                      (v10 < v13 ? 0\n                                 : (int)strtol(*((long long *)&(&v1)[8 * v10]),\n                                               NULL, 16));\n                }\n                if (*((int *)(a0 + &g_573b02c)))\n                  fprintf(stderr @GLIBC_2.2.5, \"Contraction: %04X-%04X-%04X\\n\",\n                          *((int *)v6), *((int *)(v6 + 4)), *((int *)(v6 + 8)));\n                v11 = v6 + 24;\n              }\n              *((char *)v11) = 0;\n              for (v14 = strtok(v15, &g_403120); v14;\n                   *((char *)v11) = *((char *)v11) + 1) {\n                if (*((char *)v11) > 63) {\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Line #%d has more than %d weights\\n\",\n                          (unsigned int)v18, 64);\n                  fwrite(\"Can't continue.\\n\", 1, 16, stderr @GLIBC_2.2.5);\n                  exit(1); /* do not return */\n                }\n                *((char **)&(&v3)[8 * *((char *)v11)]) = v14;\n                v14 = strtok(NULL, &g_403120);\n              }\n              for (v12 = 0; v12 < *((char *)v11); v12 += 1) {\n                v9 = 0;\n                if (v12 <= 7) {\n                  for (v14 = *((long long *)&(&v3)[8 * v12]); *((char *)v14);\n                       v9 += 1) {\n                    v5 = strtol(v14 + 1, &v2, 16);\n                    if (v12 > 7) {\n                      fprintf(stderr @GLIBC_2.2.5,\n                              \"Too many weights (%d) at line %d\\n\",\n                              (unsigned int)v12, (unsigned int)v18);\n                      exit(1); /* do not return */\n                    }\n                    *((unsigned short *)(v11 + (v12 + v9 * 8) * 2 + 2)) = v5;\n                    v14 = v2;\n                  }\n                } else {\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Warning: at line %d: character %04X has more than \"\n                          \"%d many weights (%d). Skipping the extra weights.\\n\",\n                          (unsigned int)v18, (unsigned int)v7, 8,\n                          *((char *)v11));\n                  *((char *)v11) = 8;\n                  break;\n                }\n              }\n              v26 = v0 + (v7 >> 8) * 4;\n              *(v26) = *(v26) + 1;\n            }\n          }\n        }\n      } else if (strtok(&v4, \" \\r\\n\\t\")) {\n        v8 = strtok(NULL, \" \\r\\n\\t\");\n        if (v8)\n          snprintf(a0, 32, v8);\n      }\n    }\n  }\n  if (v17)\n    fprintf(stderr @GLIBC_2.2.5, \"%d out-of-range characters skipped\\n\",\n            (unsigned int)v17);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2w12sf_j/load_uca_file.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp2w12sf_j/load_uca_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp2w12sf_j/load_uca_file.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmp2w12sf_j/load_uca_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp2w12sf_j/load_uca_file.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmp2w12sf_j/load_uca_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp2w12sf_j/load_uca_file.c:16:8: error: conflicting types for 'fgets'\n   16 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmp2w12sf_j/load_uca_file.c:106:6: error:\nconflicting types for 'snprintf' 106 | int (snprintf)(char *, unsigned long,\nchar *, ...); |      ^ /usr/include/stdio.h:378:12: note: previous declaration\nis here 378 | extern int snprintf (char *__restrict __s, size_t __maxlen, | ^\n/tmp/tmp2w12sf_j/load_uca_file.c:120:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 120 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp2w12sf_j/load_uca_file.c:124:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 124 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp2w12sf_j/load_uca_file.c:124:22: error: expected ';' after top level\ndeclarator 124 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp2w12sf_j/load_uca_file.c:173:39: error: expected ')'\n  173 |                         fprintf(stderr@GLIBC_2.2.5, \"Warning: could not\nparse line #%d:\\n'%s'\\n\", (unsigned int)v18, (unsigned int)&v4); | ^\n/tmp/tmp2w12sf_j/load_uca_file.c:173:32: note: to match this '('\n  173 |                         fprintf(stderr@GLIBC_2.2.5, \"Warning: could not\nparse line #%d:\\n'%s'\\n\", (unsigned int)v18, (unsigned int)&v4); | ^\n/tmp/tmp2w12sf_j/load_uca_file.c:183:43: error: expected ')'\n  183 |                             fprintf(stderr@GLIBC_2.2.5, \"Warning: could\nnot parse line #%d:\\n%s\\n\", (unsigned int)v18, (unsigned int)&v4); | ^\n/tmp/tmp2w12sf_j/load_uca_file.c:183:36: note: to match this '('\n  183 |                             fprintf(stderr@GLIBC_2.2.5, \"Warning: could\nnot parse line #%d:\\n%s\\n\", (unsigned int)v18, (unsigned int)&v4); | ^\n/tmp/tmp2w12sf_j/load_uca_file.c:195:65: error: invalid operands to binary\nexpression ('int' and 'struct_1 *' (aka 'struct struct_1 *')) 195 | *((unsigned\nlong *)&(&v1)[8 * v13]) = v14; | ~ ^ ~~~\n/tmp/tmp2w12sf_j/load_uca_file.c:196:65: error: invalid operands to binary\nexpression ('int' and 'struct_1 *' (aka 'struct struct_1 *')) 196 | *((long long\n*)&(&v1)[8 + 8 * v13]) = 0; | ~ ^ ~~~ /tmp/tmp2w12sf_j/load_uca_file.c:201:51:\nerror: expected ')' 201 | fprintf(stderr@GLIBC_2.2.5, \"Contraction length is too\nlong (%d) line #%d\", (unsigned int)v13, (unsigned int)v18); | ^\n/tmp/tmp2w12sf_j/load_uca_file.c:201:44: note: to match this '('\n  201 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"Contraction length is too long (%d) line #%d\", (unsigned int)v13, (unsigned\nint)v18); |                                            ^\n/tmp/tmp2w12sf_j/load_uca_file.c:212:58: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'char *') 212 | v22 =\n*((long long *)(a0 + &g_5720020)); | ~~ ^ ~~~~~~~~~~\n/tmp/tmp2w12sf_j/load_uca_file.c:213:61: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'char *') 213 |\n*((unsigned long long *)(a0 + &g_5720020)) = v22 + 1; | ~~ ^ ~~~~~~~~~~\n/tmp/tmp2w12sf_j/load_uca_file.c:215:41: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'char *') 215 | v6 = a0 +\n&(&g_5720020)[32 * v23 + 4 * v23] + 8; |                                      ~~\n^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /tmp/tmp2w12sf_j/load_uca_file.c:216:56:\nerror: invalid operands to binary expression ('struct_0 *' (aka 'struct struct_0\n*') and 'char *') 216 |                                 if (*((long long *)(a0 +\n&g_5720020)) > 1023) |                                                     ~~ ^\n~~~~~~~~~~ fatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *prefix_name(MY_UCA *uca) {\n    static char prefix[32];\n    char *s, *d;\n    strcpy(prefix, \"uca\");\n    for (s = uca->version , d = prefix + strlen(prefix); *s; s++) {\n        if ((*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'z'))\n            *d++ = *s;\n    }\n    *d = '\\x00';\n    return prefix;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_616375;\nextern unsigned int prefix.3;\n\nlong long prefix_name_name_conflict(char *a0) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n  char *v3; // rax\n\n  *((char **)&prefix.3) = &g_616375;\n  v1 = a0;\n  for (v0 = strlen(&prefix.3) + (char *)&prefix.3; *(v1); v1 += 1) {\n    if (*(v1) > 47 && *(v1) <= 57 || *(v1) > 96 && *(v1) <= 122) {\n      v3 = v0;\n      v0 = v3 + 1;\n      *(v3) = *(v1);\n    }\n  }\n  *((char *)v0) = 0;\n  return &prefix.3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcxlvjkzp/prefix_name_name_conflict.c:18:27: error: expected ';' after top level\ndeclarator 18 | extern unsigned int prefix.3; |                           ^ | ;\n/tmp/tmpcxlvjkzp/prefix_name_name_conflict.c:26:23: error: expected ')'\n   26 |     *((char **)&prefix.3) = &g_616375;\n      |                       ^\n/tmp/tmpcxlvjkzp/prefix_name_name_conflict.c:26:6: note: to match this '('\n   26 |     *((char **)&prefix.3) = &g_616375;\n      |      ^\n/tmp/tmpcxlvjkzp/prefix_name_name_conflict.c:28:29: error: expected ')'\n   28 |     for (v0 = strlen(&prefix.3) + (char *)&prefix.3; *(v1); v1 += 1)\n      |                             ^\n/tmp/tmpcxlvjkzp/prefix_name_name_conflict.c:28:21: note: to match this '('\n   28 |     for (v0 = strlen(&prefix.3) + (char *)&prefix.3; *(v1); v1 += 1)\n      |                     ^\n/tmp/tmpcxlvjkzp/prefix_name_name_conflict.c:38:19: error: expected ';' after return statement\n   38 |     return &prefix.3;\n      |                   ^\n      |                   ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *page_name(MY_UCA *uca, size_t page, size_t level) {\n    static char page_name_buf[120];\n    snprintf(page_name_buf, sizeof (page_name_buf), \"%s_p%03X%s\", prefix_name(uca), page, pname[level]);\n    return page_name_buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(prefix_name)(long long);\nint(snprintf)(char *, unsigned long, char *, ...);\n\ntypedef struct struct_0 {\n  char padding_0[4214944];\n  unsigned long long field_4050a0;\n} struct_0;\n\nextern char page_name_name_conflict_buf.2;\nextern char pname;\n\nlong long page_name_name_conflict(unsigned long long a0, unsigned long a1, struct_0 *a2) {\n  snprintf(&page_name_name_conflict_buf.2, 120, \"%s_p%03X%s\", (int)prefix_name(a0),\n           (unsigned int)a1, (int)*((long long *)(0x8 * a2 + &pname)));\n  return &page_name_name_conflict_buf.2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6r7iniup/page_name_name_conflict.c:17:6: error: conflicting types for 'snprintf'\n   17 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp6r7iniup/page_name_name_conflict.c:24:26: error: expected ';' after top level\ndeclarator 24 | extern char page_name_name_conflict_buf.2; |                          ^ | ;\n/tmp/tmp6r7iniup/page_name_name_conflict.c:29:28: error: expected ')'\n   29 |     snprintf(&page_name_name_conflict_buf.2, 120, \"%s_p%03X%s\", (int)prefix_name(a0),\n(unsigned int)a1, (int)*((long long *)(0x8 * a2 + &pname))); | ^\n/tmp/tmp6r7iniup/page_name_name_conflict.c:29:13: note: to match this '('\n   29 |     snprintf(&page_name_name_conflict_buf.2, 120, \"%s_p%03X%s\", (int)prefix_name(a0),\n(unsigned int)a1, (int)*((long long *)(0x8 * a2 + &pname))); |             ^\n/tmp/tmp6r7iniup/page_name_name_conflict.c:30:26: error: expected ';' after return statement\n   30 |     return &page_name_name_conflict_buf.2;\n      |                          ^\n      |                          ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static size_t normalize_weight(MY_UCA_ITEM *item, size_t level, uint16 *weight, size_t weight_elements) {\n    size_t num, i;\n    memset(weight, 0, weight_elements * sizeof (*weight));\n    for (num = 0 , i = 0; i < item->num && i < 8; i++) {\n        if (item->weight[level][i]) {\n            weight[num] = item->weight[level][i];\n            num++;\n        }\n    }\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long normalize_weight(char *a0, unsigned long a1, unsigned short *a2,\n                           unsigned int a3) {\n  void *v0;           // [bp-0x18], Other Possible Types: unsigned long\n  unsigned short *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  memset(a2, 0, a3 * 2);\n  v1 = 0;\n  for (v0 = 0; v0 < *(a0); v0 += 1) {\n    if (v0 > 7)\n      return v1;\n    if (*((short *)(2 + a0 + 0x2 * v0 + 16 * a1))) {\n      a2[v1] = *((short *)(2 + a0 + 0x2 * v0 + 16 * a1));\n      v1 += 1;\n    }\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn2yaze2u/normalize_weight.c:28:38: error: invalid operands to binary\nexpression ('int' and 'void *') 28 |         if (*((short *)(2 + a0 + 0x2 * v0 +\n16 * a1))) |                                  ~~~ ^ ~~\n/tmp/tmpn2yaze2u/normalize_weight.c:30:15: error: array subscript is not an\ninteger 30 |             a2[v1] = *((short *)(2 + a0 + 0x2 * v0 + 16 * a1)); |\n^~~ /tmp/tmpn2yaze2u/normalize_weight.c:30:47: error: invalid operands to binary\nexpression ('int' and 'void *') 30 |             a2[v1] = *((short *)(2 + a0 +\n0x2 * v0 + 16 * a1)); |                                           ~~~ ^ ~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static int weight_cmp(uint16 *w1, uint16 *w2, size_t len) {\n    size_t i;\n    for (i = 0; i < len; i++) {\n        if (w1[i] != w2[i])\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long weight_cmp_name_conflict(unsigned short *a0, unsigned short *a1, unsigned long a2) {\n  void *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = 0;\n  while (true) {\n    if (v0 >= a2) {\n      return 0;\n    } else if (*((short *)((char *)a0 + 0x2 * v0)) ==\n               *((short *)((char *)a1 + 0x2 * v0))) {\n      v0 += 1;\n    } else {\n      return 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn9peoj6f/weight_cmp_name_conflict.c:28:47: error: invalid operands to binary\nexpression ('int' and 'void *') 28 |         else if (*((short *)((char *)a0 +\n0x2 * v0)) == *((short *)((char *)a1 + 0x2 * v0))) | ~~~ ^ ~~\n/tmp/tmpn9peoj6f/weight_cmp_name_conflict.c:28:86: error: invalid operands to binary\nexpression ('int' and 'void *') 28 |         else if (*((short *)((char *)a0 +\n0x2 * v0)) == *((short *)((char *)a1 + 0x2 * v0))) | ~~~ ^ ~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static int get_int_option(const char *str, const char *name, int *num) {\n    size_t namelen = strlen(name);\n    if (!strncmp(str, name, namelen)) {\n        *num = atoi(str + namelen);\n        if (*num == 0 && str[namelen] != '0') {\n            fprintf(stderr, \"\\nBad numeric option value: %s\\n\\n\", str);\n            usage(stderr, 1);\n        }\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(atoi)(char *);\nlong long(usage)(long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_int_option_name_conflict(unsigned long a0, char *a1, unsigned int *a2) {\n  char *v0; // [bp-0x10]\n\n  v0 = strlen(a1);\n  if (strncmp(a0, a1, v0))\n    return 0;\n  *(a2) = atoi(&v0[a0]);\n  if (!(!*(a2) && v0[a0] != 48))\n    return 1;\n  fprintf(stderr @GLIBC_2.2.5, \"\\nBad numeric option value: %s\\n\\n\",\n          (unsigned int)a0);\n  usage(stderr @GLIBC_2.2.5, 1); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa8awvbc4/get_int_option_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpa8awvbc4/get_int_option_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpa8awvbc4/get_int_option_name_conflict.c:31:19: error: expected ')'\n   31 |     fprintf(stderr@GLIBC_2.2.5, \"\\nBad numeric option value: %s\\n\\n\",\n(unsigned int)a0); |                   ^\n/tmp/tmpa8awvbc4/get_int_option_name_conflict.c:31:12: note: to match this '('\n   31 |     fprintf(stderr@GLIBC_2.2.5, \"\\nBad numeric option value: %s\\n\\n\",\n(unsigned int)a0); |            ^ /tmp/tmpa8awvbc4/get_int_option_name_conflict.c:32:17:\nerror: expected ')' 32 |     usage(stderr@GLIBC_2.2.5, 1); /* do not return */\n|\n    ^/ tmp / tmpa8awvbc4 /\n        get_int_option_name_conflict.c : 32 : 10 : note : to match this '(' 32 |\n    usage(stderr @GLIBC_2.2.5, 1); /* do not return */\n| ^4 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static _Bool is_color_enabled(void) {\n    const char *env = getenv(\"LESS\");\n    return (env != 0 && (strstr(env, \"-r\") != 0 || strstr(env, \"-R\") != 0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\n\nlong long is_color_enabled_name_conflict() {\n  char *v0;              // [bp-0x10]\n  unsigned int v2;       // eax\n  unsigned long long v3; // rax\n\n  v0 = getenv(\"LESS\");\n  if (!v0 || !strstr(v0, \"-r\") && !strstr(v0, \"-R\"))\n    v2 = 0;\n  else\n    v2 = 1;\n  v3 = v2 & 1;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/frugalware_frugalware-stable/source/apps/lesspipe/code2color.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long findbreak_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x11]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v1 = a1;\n  for (v2 = v1; v2 <= (unsigned int)a2; v2 += 1) {\n    v0 = a0[v2];\n    if (v0 == 9)\n      a0[v2] = 32;\n    if (v0 == 10) {\n      a0[v2] = 32;\n      v1 = v2;\n      return v1;\n    }\n    if (!v0) {\n      v1 = v2;\n      return v1;\n    }\n    if (v0 == 45 && v2 < (unsigned int)a2 - 1)\n      v1 = v2 + 1;\n    if (v0 == 32)\n      v1 = v2;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v0 = a0;\n  v1 = 0;\n  if (argv && argv->field_0) {\n    for (v2 = 1; argv[v2].field_0; v2 += 1) {\n      if (v1 || *((char *)argv[v2].field_0) != 45 &&\n                    *((char *)argv[v2].field_0) != 43 &&\n                    !strchr(argv[v2].field_0, 61)) {\n        if (v0)\n          v0 -= 1;\n        else\n          return v2;\n      }\n      if (!strcmp(argv[v2].field_0, \"--\"))\n        v1 = 1;\n    }\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzwon6tn5/argindex_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpzwon6tn5/argindex_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpzwon6tn5/argindex_name_conflict.c:34:23: error: member reference type\n'int' is not a pointer 34 |     if (argv && argv->field_0) | ~~~~  ^\n/tmp/tmpzwon6tn5/argindex_name_conflict.c:36:26: error: subscripted value is not an array,\npointer, or vector 36 |         for (v2 = 1; argv[v2].field_0; v2 += 1) |\n~~~~^~~ /tmp/tmpzwon6tn5/argindex_name_conflict.c:38:37: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpzwon6tn5/argindex_name_conflict.c:38:74: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpzwon6tn5/argindex_name_conflict.c:38:109: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpzwon6tn5/argindex_name_conflict.c:45:29: error: subscripted value is not an\narray, pointer, or vector 45 |             if (!strcmp(argv[v2].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  if (!argv) {\n    return v2;\n  } else if (!argv->field_0) {\n    return v2;\n  } else {\n    for (v0 = 1; argv[v0].field_0; v0 += 1) {\n      if (v1 || *((char *)argv[v0].field_0) != 45 &&\n                    *((char *)argv[v0].field_0) != 43 &&\n                    !strchr(argv[v0].field_0, 61))\n        v2 += 1;\n      if (!strcmp(argv[v0].field_0, \"--\"))\n        v1 = 1;\n    }\n    return v2;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:38:21: error: member reference type\n'int' is not a pointer 38 |     else if (!argv->field_0) |               ~~~~  ^\n/tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:44:26: error: subscripted value is not an array,\npointer, or vector 44 |         for (v0 = 1; argv[v0].field_0; v0 += 1) |\n~~~~^~~ /tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:46:37: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:46:74: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:46:109: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpyh3czxn5/OptNArgs_name_conflict.c:48:29: error: subscripted value is not an\narray, pointer, or vector 48 |             if (!strcmp(argv[v0].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = argindex((unsigned int)a0);\n  return (v0 < 0 ? *((long long *)(argv + v0 * 8)) : 0);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long azDefine;\nextern unsigned int nDefine;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long preprocess_input_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0x28]\n  unsigned int v1;  // [bp-0x24]\n  char v2;          // [bp-0x20], Other Possible Types: unsigned int\n  unsigned int v3;  // [bp-0x1c]\n  unsigned int v4;  // [bp-0x18]\n  unsigned int v5;  // [bp-0x14]\n  unsigned int v6;  // [bp-0x10]\n  unsigned int v7;  // [bp-0xc]\n  unsigned int v10; // eax\n  unsigned int v12; // eax\n  unsigned int v14; // eax\n  unsigned int v16; // eax\n  unsigned int v18; // eax\n\n  v3 = 0;\n  v1 = 1;\n  for (v7 = 0; a0[v7]; v7 += 1) {\n    if (a0[v7] == 10)\n      v1 += 1;\n    if (!(a0[v7] != 37 || v7 > 0 && a0[1 + v7] != 10)) {\n      if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n            (v10 = (unsigned int)(unsigned short)*(\n                       (short *)(*((long long *)&__ctype_b_loc()) +\n                                 (long long)(char)a0[6 + v7] * 2)) &\n                   0x2000,\n             !v10))) {\n        if (v3) {\n          v3 -= 1;\n          if (!v3) {\n            for (v6 = *((int *)&v2); v6 < v7; v6 += 1) {\n              if (a0[v6] != 10)\n                a0[v6] = 32;\n            }\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      } else if (!strncmp(&a0[v7], \"%ifdef\", 6) &&\n                     !((v12 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[6 + v7] * 2)) &\n                              0x2000,\n                        !v12)) ||\n                 !strncmp(&a0[v7], \"%ifndef\", 7) && v14) {\n        if (v3) {\n          v3 += 1;\n        } else {\n          v6 = v7 + 7;\n          while (true) {\n            v16 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) &\n                  0x2000;\n            if (!v16)\n              break;\n            v6 += 1;\n          }\n          for (v4 = 0; a0[v6 + v4] &&\n                       (v18 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[v6 + v4] * 2)) &\n                              0x2000,\n                       !v18);\n               v4 += 1)\n            ;\n          v3 = 1;\n          for (v5 = 0; v5 < nDefine; v5 += 1) {\n            if (!(strncmp(*((long long *)(azDefine + (v5 << 3))), &a0[v6],\n                          v4) ||\n                  strlen(*((long long *)(azDefine + (v5 << 3)))) != v4)) {\n              v3 = 0;\n              break;\n            }\n          }\n          if (a0[3 + v7] == 110)\n            v3 = !v3;\n          if (v3) {\n            v2 = v7;\n            v0 = v1;\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      }\n    }\n  }\n  if (v3) {\n    fprintf(stderr @GLIBC_2.2.5, \"unterminated %%ifdef starting on line %d\\n\",\n            v0);\n    exit(1); /* do not return */\n  }\n  return a0[v7];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:45:116: error: cannot take the address of an\nrvalue of type 'int' 45 |             if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n(v10 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[6 + v7] * 2)) & 0x2000, !v10))) |\n^~~~~~~~~~~~~~~~ /tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:64:122: error: cannot take\nthe address of an rvalue of type 'int' 64 |             else if\n(!strncmp(&a0[v7], \"%ifdef\", 6) && !((v12 = (unsigned int)(unsigned\nshort)*((short *)(*((long long *)&__ctype_b_loc()) + (long long)(char)a0[6 + v7]\n* 2)) & 0x2000, !v12)) || !strncmp(&a0[v7], \"%ifndef\", 7) && v14) |\n^~~~~~~~~~~~~~~~ /tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:75:58: error: cannot take\nthe address of an rvalue of type 'int' 75 |                         v16 =\n*((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) & 0x2000; |\n^~~~~~~~~~~~~~~~ /tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:80:113: error: cannot take\nthe address of an rvalue of type 'int' 80 |                     for (v4 = 0;\na0[v6 + v4] && (v18 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[v6 + v4] * 2)) & 0x2000, !v18); v4 +=\n1); | ^~~~~~~~~~~~~~~~ /tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:107:23: error:\nexpected ')' 107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef\nstarting on line %d\\n\", v0); |                       ^\n/tmp/tmpi_wpsavm/preprocess_input_name_conflict.c:107:16: note: to match this '('\n  107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef starting on\nline %d\\n\", v0); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40f3e0;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char v0;  // [bp-0x31]\n  char *v1; // [bp-0x30], Other Possible Types: unsigned long\n  char *v2; // [bp-0x28], Other Possible Types: unsigned long\n  char *v3; // [bp-0x20], Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v0 = *(v1);\n    *(v1) = 0;\n    v2 = malloc(strlen(a1) + strlen(a0) + 2);\n    if (v2)\n      sprintf(v2, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v0;\n    return v2;\n  } else {\n    v3 = getenv(\"PATH\");\n    if (!v3)\n      v3 = \".:/bin:/usr/bin\";\n    v2 = malloc(strlen(a1) + strlen(v3) + 2);\n    if (!v2)\n      return v2;\n    while (*((char *)v3)) {\n      v1 = strchr(v3, 58);\n      if (!v1)\n        v1 = strlen(v3) + v3;\n      v0 = *((char *)v1);\n      *((char *)v1) = 0;\n      sprintf(v2, \"%s/%s\", (unsigned int)v3, (unsigned int)a1);\n      *((char *)v1) = v0;\n      if (!v0)\n        v3 = &g_40f3e0;\n      else\n        v3 = v1 + 1;\n      if (!access(v2, a2))\n        return v2;\n    }\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 >= 0)\n    return ((unsigned int)a1 <= 255\n                ? ((unsigned int)a1 <= 65534 ? \"unsigned int\"\n                                             : \"unsigned short int\")\n                : \"unsigned char\");\n  if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n    return \"signed char\";\n  if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n    return \"int\";\n  return \"short\";\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v0;              // [bp-0x18]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = malloc(size);\n  if (!v0)\n    memory_error(); /* do not return */\n  for (v1 = 0; v1 < size; v1 += 1) {\n    v0[v1] = 0;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = *((char *)(a0 + (unsigned int)a1));\n  *((char *)(a0 + (unsigned int)a1)) = 1;\n  return !v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  for (v1 = 0; v1 < size; v1 += 1) {\n    if (a1[v1] && !a0[v1]) {\n      v0 = 1;\n      a0[v1] = 1;\n    }\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  char *v4;              // rax\n\n  v0 = a0;\n  for (v1 = 0; *(v0);\n       v1 = *(v4) + (unsigned int)(((unsigned int)v3 * 2 + v3) * 4 + v3)) {\n    v3 = v1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = Strsafe_name_conflict_find(a0);\n  if (!v0) {\n    v0 = malloc(strlen(a0) + 1);\n    if (v0) {\n      strcpy(v0, a0);\n      Strsafe_name_conflict_insert(v0);\n    }\n  }\n  if (!v0)\n    memory_error(); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_3 {\n  char *field_0;\n  struct struct_3 *field_8;\n  unsigned long long field_10;\n} struct_3;\n\ntypedef struct struct_1 {\n  unsigned long long field_0;\n  struct struct_1 *field_8;\n  unsigned long long field_10;\n} struct_1;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned int v0;          // [bp-0x48]\n  unsigned int v1;          // [bp-0x44]\n  unsigned long v2;         // [bp-0x40]\n  struct struct_2 **v3;     // [bp-0x38]\n  unsigned long long v4[3]; // [bp-0x30]\n  unsigned long long *v5;   // [bp-0x28]\n  unsigned int v6;          // [bp-0x20]\n  unsigned int v7;          // [bp-0x1c]\n  unsigned int v8;          // [bp-0x18]\n  unsigned int v9;          // [bp-0x14]\n  struct_3 *v10; // [bp-0x10], Other Possible Types: unsigned long, struct_1 *\n  char v11;      // [bp-0x8]\n  unsigned long long v13; // rbp\n  unsigned long long v18; // rsi\n  unsigned long long v19; // rdx\n\n  v13 = &v11;\n  if (!x1a)\n    return 0;\n  v8 = strhash(a0);\n  v7 = x1a->field_0 - 1 & v8;\n  for (v10 = *((long long *)(x1a->field_10 + v7 * 8)); v10;\n       v10 = *((long long *)(v10 + 8))) {\n    if (!strcmp(*((long long *)v10), a0))\n      return 0;\n  }\n  if (x1a->padding_4 >= x1a->field_0) {\n    v6 = x1a->field_0 * 2;\n    v0 = v6;\n    *((char[4]) & v1) = x1a->padding_4;\n    v2 = malloc(v6 * 32);\n    if (!v2)\n      return 0;\n    v3 = 3 * v6 * 8 + v2;\n    for (v9 = 0; v9 < v6; v9 += 1) {\n      v3[v9] = 0;\n    }\n    for (v9 = 0; v9 < x1a->padding_4; v9 += 1) {\n      v5 = 24 * v9 + (char *)x1a->field_8;\n      v7 = (int)strhash(*(v5)) & v6 - 1;\n      v4[0] = 3 * v9 * 8 + v2;\n      if (v3[v7])\n        v3[v7]->field_10 = &v4[1];\n      v4[1] = v3[v7];\n      v4[0] = *(v5);\n      v4[2] = &v3[v7];\n      v3[v7] = &v4[0];\n    }\n    free(x1a->field_8);\n    *((long long *)&x1a->field_0) = *((long long *)&v0);\n    x1a->field_8 = v2;\n    x1a->field_10 = v3;\n  }\n  v7 = x1a->field_0 - 1 & v8;\n  v18 = x1a->field_8;\n  v19 = (unsigned long long)x1a->padding_4;\n  *((unsigned int *)&x1a->padding_4[0]) = (unsigned int)v19 + 1;\n  v10 = 3 * v19 * 8 + v18;\n  v10->field_0 = a0;\n  if (*((long long *)(x1a->field_10 + (v7 << 3))))\n    *((struct_1 **)(*((long long *)(x1a->field_10 + v7 * 8)) + 16)) =\n        &v10->field_8;\n  v10->field_8 = *((long long *)(x1a->field_10 + v7 * 8));\n  *((struct_1 **)(v7 * 8 + x1a->field_10)) = v10;\n  v10->field_10 = v7 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4mxsmk0p/Strsafe_insert_name_conflict.c:30:8: error: unknown type name 'struct_0'\n   30 | extern struct_0 *x1a;\n      |        ^\n/tmp/tmp4mxsmk0p/Strsafe_insert_name_conflict.c:64:11: error: used type 'char[4]' where\narithmetic or pointer type is required 64 |         *((char [4])&v1) =\nx1a->padding_4; |           ^         ~~~\n/tmp/tmp4mxsmk0p/Strsafe_insert_name_conflict.c:79:23: error: incomplete definition of type\n'struct struct_2' 79 |                 v3[v7]->field_10 = &v4[1]; | ~~~~~~^\n/tmp/tmp4mxsmk0p/Strsafe_insert_name_conflict.c:37:12: note: forward declaration of 'struct\nstruct_2' 37 |     struct struct_2 **v3;  // [bp-0x38] |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n} struct_1;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_1 *v1;    // [bp-0x10], Other Possible Types: unsigned long\n\n  if (!x1a)\n    return 0;\n  v0 = (int)strhash(a0) & x1a->field_0 - 1;\n  for (v1 = *((long long *)(x1a->field_10 + v0 * 8));\n       v1 && strcmp(*((long long *)v1), a0); v1 = *((long long *)(v1 + 8)))\n    ;\n  return (!v1 ? *((long long *)v1) : 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_5behsr4/Strsafe_find_name_conflict.c:23:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 23 | extern struct_0 *x1a; |        ^~~~~~~~ | struct_1\n/tmp/tmp_5behsr4/Strsafe_find_name_conflict.c:21:3: note: 'struct_1' declared here\n   21 | } struct_1;\n      |   ^\n/tmp/tmp_5behsr4/Strsafe_find_name_conflict.c:32:27: error: invalid operands to binary\nexpression ('int' and 'char *') 32 |     v0 = (int)strhash(a0) & x1a->field_0 -\n1; |          ~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n/tmp/tmp_5behsr4/Strsafe_find_name_conflict.c:33:36: error: no member named 'field_10' in\n'struct struct_1'; did you mean 'field_0'? 33 |     for (v1 = *((long long\n*)(x1a->field_10 + v0 * 8)); v1 && strcmp(*((long long *)v1), a0); v1 = *((long\nlong *)(v1 + 8))); |                                    ^~~~~~~~ | field_0\n/tmp/tmp_5behsr4/Strsafe_find_name_conflict.c:19:11: note: 'field_0' declared here\n   19 |     char *field_0;\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() { return (!x2a ? x2a->field_4 : 0); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6nb1p04v/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmp6nb1p04v/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmp6nb1p04v/Symbol_count_name_conflict.c:23:25: error: member\nreference type 'int' is not a pointer 23 |     return (!x2a ? x2a->field_4 : 0);\n      |                    ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long findbreak_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x11]\n  unsigned int v1; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0xc]\n\n  v1 = a1;\n  for (v2 = v1; v2 <= (unsigned int)a2; v2 += 1) {\n    v0 = a0[v2];\n    if (v0 == 9)\n      a0[v2] = 32;\n    if (v0 == 10) {\n      a0[v2] = 32;\n      v1 = v2;\n      return (unsigned int)v1;\n    } else if (v0) {\n      if (v0 == 45 && v2 < (unsigned int)a2 - 1)\n        v1 = v2 + 1;\n      if (v0 == 32)\n        v1 = v2;\n    } else {\n      v1 = v2;\n      return (unsigned int)v1;\n    }\n  }\n  return (unsigned int)v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v0 = a0;\n  v1 = 0;\n  if (argv && argv->field_0) {\n    for (v2 = 1; argv[v2].field_0; v2 += 1) {\n      if (v1 || *((char *)argv[v2].field_0) != 45 &&\n                    *((char *)argv[v2].field_0) != 43 &&\n                    !strchr(argv[v2].field_0, 61)) {\n        if (v0)\n          v0 -= 1;\n        else\n          return v2;\n      }\n      if (!strcmp(argv[v2].field_0, \"--\"))\n        v1 = 1;\n    }\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpc5iaa3ch/argindex_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpc5iaa3ch/argindex_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpc5iaa3ch/argindex_name_conflict.c:34:23: error: member reference type\n'int' is not a pointer 34 |     if (argv && argv->field_0) | ~~~~  ^\n/tmp/tmpc5iaa3ch/argindex_name_conflict.c:36:26: error: subscripted value is not an array,\npointer, or vector 36 |         for (v2 = 1; argv[v2].field_0; v2 += 1) |\n~~~~^~~ /tmp/tmpc5iaa3ch/argindex_name_conflict.c:38:37: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpc5iaa3ch/argindex_name_conflict.c:38:74: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpc5iaa3ch/argindex_name_conflict.c:38:109: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpc5iaa3ch/argindex_name_conflict.c:45:29: error: subscripted value is not an\narray, pointer, or vector 45 |             if (!strcmp(argv[v2].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  if (!argv) {\n    return v2;\n  } else if (!argv->field_0) {\n    return v2;\n  } else {\n    for (v0 = 1; argv[v0].field_0; v0 += 1) {\n      if (v1 || *((char *)argv[v0].field_0) != 45 &&\n                    *((char *)argv[v0].field_0) != 43 &&\n                    !strchr(argv[v0].field_0, 61))\n        v2 += 1;\n      if (!strcmp(argv[v0].field_0, \"--\"))\n        v1 = 1;\n    }\n    return v2;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:38:21: error: member reference type\n'int' is not a pointer 38 |     else if (!argv->field_0) |               ~~~~  ^\n/tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:44:26: error: subscripted value is not an array,\npointer, or vector 44 |         for (v0 = 1; argv[v0].field_0; v0 += 1) |\n~~~~^~~ /tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:46:37: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:46:74: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:46:109: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpoudsc8j1/OptNArgs_name_conflict.c:48:29: error: subscripted value is not an\narray, pointer, or vector 48 |             if (!strcmp(argv[v0].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = argindex((unsigned int)a0);\n  return (v0 < 0 ? *((long long *)(argv + v0 * 8)) : 0);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long azDefine;\nextern unsigned int nDefine;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long preprocess_input_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0x28]\n  unsigned int v1;  // [bp-0x24]\n  unsigned int v2;  // [bp-0x20], Other Possible Types: char\n  unsigned int v3;  // [bp-0x1c]\n  unsigned int v4;  // [bp-0x18]\n  unsigned int v5;  // [bp-0x14]\n  unsigned int v6;  // [bp-0x10]\n  unsigned int v7;  // [bp-0xc]\n  unsigned int v10; // eax\n  unsigned int v12; // eax\n  unsigned int v14; // eax\n  unsigned int v16; // eax\n  unsigned int v18; // eax\n\n  v3 = 0;\n  v1 = 1;\n  for (v7 = 0; a0[v7]; v7 += 1) {\n    if (a0[v7] == 10)\n      v1 += 1;\n    if (!(a0[v7] != 37 || v7 > 0 && a0[1 + v7] != 10)) {\n      if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n            (v10 = (unsigned int)(unsigned short)*(\n                       (short *)(*((long long *)&__ctype_b_loc()) +\n                                 (long long)(char)a0[6 + v7] * 2)) &\n                   0x2000,\n             !v10))) {\n        if (v3) {\n          v3 -= 1;\n          if (!v3) {\n            for (v6 = *((int *)&v2); v6 < v7; v6 += 1) {\n              if (a0[v6] != 10)\n                a0[v6] = 32;\n            }\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      } else if (!strncmp(&a0[v7], \"%ifdef\", 6) &&\n                     !((v12 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[6 + v7] * 2)) &\n                              0x2000,\n                        !v12)) ||\n                 !strncmp(&a0[v7], \"%ifndef\", 7) && v14) {\n        if (v3) {\n          v3 += 1;\n        } else {\n          v6 = v7 + 7;\n          while (true) {\n            v16 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) &\n                  0x2000;\n            if (!v16)\n              break;\n            v6 += 1;\n          }\n          for (v4 = 0; a0[v6 + v4] &&\n                       (v18 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[v6 + v4] * 2)) &\n                              0x2000,\n                       !v18);\n               v4 += 1)\n            ;\n          v3 = 1;\n          for (v5 = 0; v5 < nDefine; v5 += 1) {\n            if (!(strncmp(*((long long *)(azDefine + (v5 << 3))), &a0[v6],\n                          v4) ||\n                  strlen(*((long long *)(azDefine + (v5 << 3)))) != v4)) {\n              v3 = 0;\n              break;\n            }\n          }\n          if (a0[3 + v7] == 110)\n            v3 = !v3;\n          if (v3) {\n            v2 = v7;\n            v0 = v1;\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      }\n    }\n  }\n  if (v3) {\n    fprintf(stderr @GLIBC_2.2.5, \"unterminated %%ifdef starting on line %d\\n\",\n            v0);\n    exit(1); /* do not return */\n  }\n  return a0[v7];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:45:116: error: cannot take the address of an\nrvalue of type 'int' 45 |             if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n(v10 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[6 + v7] * 2)) & 0x2000, !v10))) |\n^~~~~~~~~~~~~~~~ /tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:64:122: error: cannot take\nthe address of an rvalue of type 'int' 64 |             else if\n(!strncmp(&a0[v7], \"%ifdef\", 6) && !((v12 = (unsigned int)(unsigned\nshort)*((short *)(*((long long *)&__ctype_b_loc()) + (long long)(char)a0[6 + v7]\n* 2)) & 0x2000, !v12)) || !strncmp(&a0[v7], \"%ifndef\", 7) && v14) |\n^~~~~~~~~~~~~~~~ /tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:75:58: error: cannot take\nthe address of an rvalue of type 'int' 75 |                         v16 =\n*((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) & 0x2000; |\n^~~~~~~~~~~~~~~~ /tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:80:113: error: cannot take\nthe address of an rvalue of type 'int' 80 |                     for (v4 = 0;\na0[v6 + v4] && (v18 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[v6 + v4] * 2)) & 0x2000, !v18); v4 +=\n1); | ^~~~~~~~~~~~~~~~ /tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:107:23: error:\nexpected ')' 107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef\nstarting on line %d\\n\", v0); |                       ^\n/tmp/tmprlmgm1mr/preprocess_input_name_conflict.c:107:16: note: to match this '('\n  107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef starting on\nline %d\\n\", v0); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40f3d8;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char v0;  // [bp-0x31]\n  char *v1; // [bp-0x30], Other Possible Types: unsigned long\n  char *v2; // [bp-0x28], Other Possible Types: unsigned long\n  char *v3; // [bp-0x20], Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v0 = *(v1);\n    *(v1) = 0;\n    v2 = malloc(strlen(a1) + strlen(a0) + 2);\n    if (v2)\n      sprintf(v2, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v0;\n    return v2;\n  } else {\n    v3 = getenv(\"PATH\");\n    if (!v3)\n      v3 = \".:/bin:/usr/bin\";\n    v2 = malloc(strlen(a1) + strlen(v3) + 2);\n    if (!v2)\n      return v2;\n    while (*((char *)v3)) {\n      v1 = strchr(v3, 58);\n      if (!v1)\n        v1 = strlen(v3) + v3;\n      v0 = *((char *)v1);\n      *((char *)v1) = 0;\n      sprintf(v2, \"%s/%s\", (unsigned int)v3, (unsigned int)a1);\n      *((char *)v1) = v0;\n      if (!v0)\n        v3 = &g_40f3d8;\n      else\n        v3 = v1 + 1;\n      if (!access(v2, a2))\n        return v2;\n    }\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 >= 0)\n    return ((unsigned int)a1 <= 255\n                ? ((unsigned int)a1 <= 65534 ? \"unsigned int\"\n                                             : \"unsigned short int\")\n                : \"unsigned char\");\n  if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n    return \"signed char\";\n  if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n    return \"int\";\n  return \"short\";\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v0;              // [bp-0x18]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = malloc(size);\n  if (!v0)\n    memory_error(); /* do not return */\n  for (v1 = 0; v1 < size; v1 += 1) {\n    v0[v1] = 0;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = *((char *)(a0 + (unsigned int)a1));\n  *((char *)(a0 + (unsigned int)a1)) = 1;\n  return !v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  for (v1 = 0; v1 < size; v1 += 1) {\n    if (a1[v1] && !a0[v1]) {\n      v0 = 1;\n      a0[v1] = 1;\n    }\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  char *v4;              // rax\n\n  v0 = a0;\n  for (v1 = 0; *(v0);\n       v1 = *(v4) + (unsigned int)(((unsigned int)v3 * 2 + v3) * 4 + v3)) {\n    v3 = v1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = Strsafe_name_conflict_find(a0);\n  if (!v0) {\n    v0 = malloc(strlen(a0) + 1);\n    if (v0) {\n      strcpy(v0, a0);\n      Strsafe_name_conflict_insert(v0);\n    }\n  }\n  if (!v0)\n    memory_error(); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n  unsigned long long field_10;\n} struct_1;\n\ntypedef struct struct_3 {\n  unsigned long long field_0;\n  struct struct_3 *field_8;\n  unsigned long long field_10;\n} struct_3;\n\nextern struct_2 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned int v0;          // [bp-0x48]\n  unsigned int v1;          // [bp-0x44]\n  unsigned long v2;         // [bp-0x40]\n  struct struct_0 **v3;     // [bp-0x38]\n  unsigned long long v4[3]; // [bp-0x30]\n  unsigned long long *v5;   // [bp-0x28]\n  unsigned int v6;          // [bp-0x20]\n  unsigned int v7;          // [bp-0x1c]\n  unsigned int v8;          // [bp-0x18]\n  unsigned int v9;          // [bp-0x14]\n  struct_3 *v10; // [bp-0x10], Other Possible Types: unsigned long, struct_1 *\n  char v11;      // [bp-0x8]\n  unsigned long long v13; // rbp\n  unsigned long long v18; // rsi\n  unsigned long long v19; // rdx\n\n  v13 = &v11;\n  if (!x1a)\n    return 0;\n  v8 = strhash(a0);\n  v7 = x1a->field_0 - 1 & v8;\n  for (v10 = *((long long *)(x1a->field_10 + v7 * 8)); v10;\n       v10 = *((long long *)(v10 + 8))) {\n    if (!strcmp(*((long long *)v10), a0))\n      return 0;\n  }\n  if (x1a->padding_4 >= x1a->field_0) {\n    v6 = x1a->field_0 * 2;\n    v0 = v6;\n    *((char[4]) & v1) = x1a->padding_4;\n    v2 = malloc(v6 * 32);\n    if (!v2)\n      return 0;\n    v3 = 3 * v6 * 8 + v2;\n    for (v9 = 0; v9 < v6; v9 += 1) {\n      v3[v9] = 0;\n    }\n    for (v9 = 0; v9 < x1a->padding_4; v9 += 1) {\n      v5 = 24 * v9 + (char *)x1a->field_8;\n      v7 = (int)strhash(*(v5)) & v6 - 1;\n      v4[0] = 3 * v9 * 8 + v2;\n      if (v3[v7])\n        v3[v7]->field_10 = &v4[1];\n      v4[1] = v3[v7];\n      v4[0] = *(v5);\n      v4[2] = &v3[v7];\n      v3[v7] = &v4[0];\n    }\n    free(x1a->field_8);\n    *((long long *)&x1a->field_0) = *((long long *)&v0);\n    x1a->field_8 = v2;\n    x1a->field_10 = v3;\n  }\n  v7 = x1a->field_0 - 1 & v8;\n  v18 = x1a->field_8;\n  v19 = (unsigned long long)x1a->padding_4;\n  *((unsigned int *)&x1a->padding_4[0]) = (unsigned int)v19 + 1;\n  v10 = 3 * v19 * 8 + v18;\n  v10->field_0 = a0;\n  if (*((long long *)(x1a->field_10 + (v7 << 3))))\n    *((struct_3 **)(*((long long *)(x1a->field_10 + v7 * 8)) + 16)) =\n        &v10->field_8;\n  v10->field_8 = *((long long *)(x1a->field_10 + v7 * 8));\n  *((struct_3 **)(v7 * 8 + x1a->field_10)) = v10;\n  v10->field_10 = v7 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf4ze26aa/Strsafe_insert_name_conflict.c:30:8: error: unknown type name 'struct_2'\n   30 | extern struct_2 *x1a;\n      |        ^\n/tmp/tmpf4ze26aa/Strsafe_insert_name_conflict.c:64:11: error: used type 'char[4]' where\narithmetic or pointer type is required 64 |         *((char [4])&v1) =\nx1a->padding_4; |           ^         ~~~\n/tmp/tmpf4ze26aa/Strsafe_insert_name_conflict.c:79:23: error: incomplete definition of type\n'struct struct_0' 79 |                 v3[v7]->field_10 = &v4[1]; | ~~~~~~^\n/tmp/tmpf4ze26aa/Strsafe_insert_name_conflict.c:37:12: note: forward declaration of 'struct\nstruct_0' 37 |     struct struct_0 **v3;  // [bp-0x38] |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n} struct_1;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_1 *v1;    // [bp-0x10], Other Possible Types: unsigned long\n\n  if (!x1a)\n    return 0;\n  v0 = (int)strhash(a0) & x1a->field_0 - 1;\n  for (v1 = *((long long *)(x1a->field_10 + v0 * 8));\n       v1 && strcmp(*((long long *)v1), a0); v1 = *((long long *)(v1 + 8)))\n    ;\n  return (!v1 ? *((long long *)v1) : 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzh0sv3ht/Strsafe_find_name_conflict.c:23:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 23 | extern struct_0 *x1a; |        ^~~~~~~~ | struct_1\n/tmp/tmpzh0sv3ht/Strsafe_find_name_conflict.c:21:3: note: 'struct_1' declared here\n   21 | } struct_1;\n      |   ^\n/tmp/tmpzh0sv3ht/Strsafe_find_name_conflict.c:32:27: error: invalid operands to binary\nexpression ('int' and 'char *') 32 |     v0 = (int)strhash(a0) & x1a->field_0 -\n1; |          ~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n/tmp/tmpzh0sv3ht/Strsafe_find_name_conflict.c:33:36: error: no member named 'field_10' in\n'struct struct_1'; did you mean 'field_0'? 33 |     for (v1 = *((long long\n*)(x1a->field_10 + v0 * 8)); v1 && strcmp(*((long long *)v1), a0); v1 = *((long\nlong *)(v1 + 8))); |                                    ^~~~~~~~ | field_0\n/tmp/tmpzh0sv3ht/Strsafe_find_name_conflict.c:19:11: note: 'field_0' declared here\n   19 |     char *field_0;\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() { return (!x2a ? x2a->field_4 : 0); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb0xfhd4d/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmpb0xfhd4d/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpb0xfhd4d/Symbol_count_name_conflict.c:23:25: error: member\nreference type 'int' is not a pointer 23 |     return (!x2a ? x2a->field_4 : 0);\n      |                    ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long findbreak_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x11]\n  unsigned int v1; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0xc]\n\n  v1 = a1;\n  for (v2 = v1; v2 <= (unsigned int)a2; v2 += 1) {\n    v0 = a0[v2];\n    if (v0 == 9)\n      a0[v2] = 32;\n    if (v0 == 10) {\n      a0[v2] = 32;\n      v1 = v2;\n      return (unsigned int)v1;\n    }\n    if (!v0) {\n      v1 = v2;\n      return (unsigned int)v1;\n    }\n    if (v0 == 45 && v2 < (unsigned int)a2 - 1)\n      v1 = v2 + 1;\n    if (v0 == 32)\n      v1 = v2;\n  }\n  return (unsigned int)v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v0 = a0;\n  v1 = 0;\n  if (argv && argv->field_0) {\n    for (v2 = 1; argv[v2].field_0; v2 += 1) {\n      if (v1 || *((char *)argv[v2].field_0) != 45 &&\n                    *((char *)argv[v2].field_0) != 43 &&\n                    !strchr(argv[v2].field_0, 61)) {\n        if (v0)\n          v0 -= 1;\n        else\n          return v2;\n      }\n      if (!strcmp(argv[v2].field_0, \"--\"))\n        v1 = 1;\n    }\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptm86xlpw/argindex_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmptm86xlpw/argindex_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmptm86xlpw/argindex_name_conflict.c:34:23: error: member reference type\n'int' is not a pointer 34 |     if (argv && argv->field_0) | ~~~~  ^\n/tmp/tmptm86xlpw/argindex_name_conflict.c:36:26: error: subscripted value is not an array,\npointer, or vector 36 |         for (v2 = 1; argv[v2].field_0; v2 += 1) |\n~~~~^~~ /tmp/tmptm86xlpw/argindex_name_conflict.c:38:37: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmptm86xlpw/argindex_name_conflict.c:38:74: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmptm86xlpw/argindex_name_conflict.c:38:109: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmptm86xlpw/argindex_name_conflict.c:45:29: error: subscripted value is not an\narray, pointer, or vector 45 |             if (!strcmp(argv[v2].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  if (!argv) {\n    return v2;\n  } else if (!argv->field_0) {\n    return v2;\n  } else {\n    for (v0 = 1; argv[v0].field_0; v0 += 1) {\n      if (v1 || *((char *)argv[v0].field_0) != 45 &&\n                    *((char *)argv[v0].field_0) != 43 &&\n                    !strchr(argv[v0].field_0, 61))\n        v2 += 1;\n      if (!strcmp(argv[v0].field_0, \"--\"))\n        v1 = 1;\n    }\n    return v2;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgx1r612a/OptNArgs_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpgx1r612a/OptNArgs_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpgx1r612a/OptNArgs_name_conflict.c:38:21: error: member reference type\n'int' is not a pointer 38 |     else if (!argv->field_0) |               ~~~~  ^\n/tmp/tmpgx1r612a/OptNArgs_name_conflict.c:44:26: error: subscripted value is not an array,\npointer, or vector 44 |         for (v0 = 1; argv[v0].field_0; v0 += 1) |\n~~~~^~~ /tmp/tmpgx1r612a/OptNArgs_name_conflict.c:46:37: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpgx1r612a/OptNArgs_name_conflict.c:46:74: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpgx1r612a/OptNArgs_name_conflict.c:46:109: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpgx1r612a/OptNArgs_name_conflict.c:48:29: error: subscripted value is not an\narray, pointer, or vector 48 |             if (!strcmp(argv[v0].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = argindex((unsigned int)a0);\n  return (v0 < 0 ? *((long long *)(argv + v0 * 8)) : 0);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long azDefine;\nextern unsigned int nDefine;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long preprocess_input_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0x28]\n  unsigned int v1;  // [bp-0x24]\n  char v2;          // [bp-0x20], Other Possible Types: unsigned int\n  unsigned int v3;  // [bp-0x1c]\n  unsigned int v4;  // [bp-0x18]\n  unsigned int v5;  // [bp-0x14]\n  unsigned int v6;  // [bp-0x10]\n  unsigned int v7;  // [bp-0xc]\n  unsigned int v10; // eax\n  unsigned int v12; // eax\n  unsigned int v14; // eax\n  unsigned int v16; // eax\n  unsigned int v18; // eax\n\n  v3 = 0;\n  v1 = 1;\n  for (v7 = 0; a0[v7]; v7 += 1) {\n    if (a0[v7] == 10)\n      v1 += 1;\n    if (!(a0[v7] != 37 || v7 > 0 && a0[1 + v7] != 10)) {\n      if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n            (v10 = (unsigned int)(unsigned short)*(\n                       (short *)(*((long long *)&__ctype_b_loc()) +\n                                 (long long)(char)a0[6 + v7] * 2)) &\n                   0x2000,\n             !v10))) {\n        if (v3) {\n          v3 -= 1;\n          if (!v3) {\n            for (v6 = *((int *)&v2); v6 < v7; v6 += 1) {\n              if (a0[v6] != 10)\n                a0[v6] = 32;\n            }\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      } else if (!strncmp(&a0[v7], \"%ifdef\", 6) &&\n                     !((v12 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[6 + v7] * 2)) &\n                              0x2000,\n                        !v12)) ||\n                 !strncmp(&a0[v7], \"%ifndef\", 7) && v14) {\n        if (v3) {\n          v3 += 1;\n        } else {\n          v6 = v7 + 7;\n          while (true) {\n            v16 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) &\n                  0x2000;\n            if (!v16)\n              break;\n            v6 += 1;\n          }\n          for (v4 = 0; a0[v6 + v4] &&\n                       (v18 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[v6 + v4] * 2)) &\n                              0x2000,\n                       !v18);\n               v4 += 1)\n            ;\n          v3 = 1;\n          for (v5 = 0; v5 < nDefine; v5 += 1) {\n            if (!(strncmp(*((long long *)(azDefine + (v5 << 3))), &a0[v6],\n                          v4) ||\n                  strlen(*((long long *)(azDefine + (v5 << 3)))) != v4)) {\n              v3 = 0;\n              break;\n            }\n          }\n          if (a0[3 + v7] == 110)\n            v3 = !v3;\n          if (v3) {\n            v2 = v7;\n            v0 = v1;\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      }\n    }\n  }\n  if (v3) {\n    fprintf(stderr @GLIBC_2.2.5, \"unterminated %%ifdef starting on line %d\\n\",\n            v0);\n    exit(1); /* do not return */\n  }\n  return a0[v7];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:45:116: error: cannot take the address of an\nrvalue of type 'int' 45 |             if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n(v10 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[6 + v7] * 2)) & 0x2000, !v10))) |\n^~~~~~~~~~~~~~~~ /tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:64:122: error: cannot take\nthe address of an rvalue of type 'int' 64 |             else if\n(!strncmp(&a0[v7], \"%ifdef\", 6) && !((v12 = (unsigned int)(unsigned\nshort)*((short *)(*((long long *)&__ctype_b_loc()) + (long long)(char)a0[6 + v7]\n* 2)) & 0x2000, !v12)) || !strncmp(&a0[v7], \"%ifndef\", 7) && v14) |\n^~~~~~~~~~~~~~~~ /tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:75:58: error: cannot take\nthe address of an rvalue of type 'int' 75 |                         v16 =\n*((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) & 0x2000; |\n^~~~~~~~~~~~~~~~ /tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:80:113: error: cannot take\nthe address of an rvalue of type 'int' 80 |                     for (v4 = 0;\na0[v6 + v4] && (v18 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[v6 + v4] * 2)) & 0x2000, !v18); v4 +=\n1); | ^~~~~~~~~~~~~~~~ /tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:107:23: error:\nexpected ')' 107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef\nstarting on line %d\\n\", v0); |                       ^\n/tmp/tmpp7eu83a0/preprocess_input_name_conflict.c:107:16: note: to match this '('\n  107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef starting on\nline %d\\n\", v0); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40f3b8;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char v0;  // [bp-0x31]\n  char *v1; // [bp-0x30], Other Possible Types: unsigned long\n  char *v2; // [bp-0x28], Other Possible Types: unsigned long\n  char *v3; // [bp-0x20], Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v0 = *(v1);\n    *(v1) = 0;\n    v2 = malloc(strlen(a1) + strlen(a0) + 2);\n    if (v2)\n      sprintf(v2, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v0;\n    return v2;\n  } else {\n    v3 = getenv(\"PATH\");\n    if (!v3)\n      v3 = \".:/bin:/usr/bin\";\n    v2 = malloc(strlen(a1) + strlen(v3) + 2);\n    if (!v2)\n      return v2;\n    while (*((char *)v3)) {\n      v1 = strchr(v3, 58);\n      if (!v1)\n        v1 = strlen(v3) + v3;\n      v0 = *((char *)v1);\n      *((char *)v1) = 0;\n      sprintf(v2, \"%s/%s\", (unsigned int)v3, (unsigned int)a1);\n      *((char *)v1) = v0;\n      if (!v0)\n        v3 = &g_40f3b8;\n      else\n        v3 = v1 + 1;\n      if (!access(v2, a2))\n        return v2;\n    }\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 >= 0)\n    return ((unsigned int)a1 <= 255\n                ? ((unsigned int)a1 <= 65534 ? \"unsigned int\"\n                                             : \"unsigned short int\")\n                : \"unsigned char\");\n  if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n    return \"signed char\";\n  if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n    return \"int\";\n  return \"short\";\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v0;              // [bp-0x18]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = malloc(size);\n  if (!v0)\n    memory_error(); /* do not return */\n  for (v1 = 0; v1 < size; v1 += 1) {\n    v0[v1] = 0;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = *((char *)(a0 + (unsigned int)a1));\n  *((char *)(a0 + (unsigned int)a1)) = 1;\n  return !v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  for (v1 = 0; v1 < size; v1 += 1) {\n    if (a1[v1] && !a0[v1]) {\n      v0 = 1;\n      a0[v1] = 1;\n    }\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  char *v4;              // rax\n\n  v0 = a0;\n  for (v1 = 0; *(v0);\n       v1 = *(v4) + (unsigned int)(((unsigned int)v3 * 2 + v3) * 4 + v3)) {\n    v3 = v1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = Strsafe_name_conflict_find(a0);\n  if (!v0) {\n    v0 = malloc(strlen(a0) + 1);\n    if (v0) {\n      strcpy(v0, a0);\n      Strsafe_name_conflict_insert(v0);\n    }\n  }\n  if (!v0)\n    memory_error(); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n  unsigned long long field_10;\n} struct_1;\n\ntypedef struct struct_3 {\n  unsigned long long field_0;\n  struct struct_3 *field_8;\n  unsigned long long field_10;\n} struct_3;\n\nextern struct_2 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned int v0;          // [bp-0x48]\n  unsigned int v1;          // [bp-0x44]\n  unsigned long v2;         // [bp-0x40]\n  struct struct_0 **v3;     // [bp-0x38]\n  unsigned long long v4[3]; // [bp-0x30]\n  unsigned long long *v5;   // [bp-0x28]\n  unsigned int v6;          // [bp-0x20]\n  unsigned int v7;          // [bp-0x1c]\n  unsigned int v8;          // [bp-0x18]\n  unsigned int v9;          // [bp-0x14]\n  struct_1 *v10; // [bp-0x10], Other Possible Types: unsigned long, struct_3 *\n  char v11;      // [bp-0x8]\n  unsigned long long v13; // rbp\n  unsigned long long v18; // rsi\n  unsigned long long v19; // rdx\n\n  v13 = &v11;\n  if (!x1a)\n    return 0;\n  v8 = strhash(a0);\n  v7 = x1a->field_0 - 1 & v8;\n  for (v10 = *((long long *)(x1a->field_10 + v7 * 8)); v10;\n       v10 = *((long long *)(v10 + 8))) {\n    if (!strcmp(*((long long *)v10), a0))\n      return 0;\n  }\n  if (x1a->padding_4 >= x1a->field_0) {\n    v6 = x1a->field_0 * 2;\n    v0 = v6;\n    *((char[4]) & v1) = x1a->padding_4;\n    v2 = malloc(v6 * 32);\n    if (!v2)\n      return 0;\n    v3 = 3 * v6 * 8 + v2;\n    for (v9 = 0; v9 < v6; v9 += 1) {\n      v3[v9] = 0;\n    }\n    for (v9 = 0; v9 < x1a->padding_4; v9 += 1) {\n      v5 = 24 * v9 + (char *)x1a->field_8;\n      v7 = (int)strhash(*(v5)) & v6 - 1;\n      v4[0] = 3 * v9 * 8 + v2;\n      if (v3[v7])\n        v3[v7]->field_10 = &v4[1];\n      v4[1] = v3[v7];\n      v4[0] = *(v5);\n      v4[2] = &v3[v7];\n      v3[v7] = &v4[0];\n    }\n    free(x1a->field_8);\n    *((long long *)&x1a->field_0) = *((long long *)&v0);\n    x1a->field_8 = v2;\n    x1a->field_10 = v3;\n  }\n  v7 = x1a->field_0 - 1 & v8;\n  v18 = x1a->field_8;\n  v19 = (unsigned long long)x1a->padding_4;\n  *((unsigned int *)&x1a->padding_4[0]) = (unsigned int)v19 + 1;\n  v10 = 3 * v19 * 8 + v18;\n  v10->field_0 = a0;\n  if (*((long long *)(x1a->field_10 + (v7 << 3))))\n    *((struct_3 **)(*((long long *)(x1a->field_10 + v7 * 8)) + 16)) =\n        &v10->field_8;\n  v10->field_8 = *((long long *)(x1a->field_10 + v7 * 8));\n  *((struct_3 **)(v7 * 8 + x1a->field_10)) = v10;\n  v10->field_10 = v7 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfgq4vjsf/Strsafe_insert_name_conflict.c:30:8: error: unknown type name 'struct_2'\n   30 | extern struct_2 *x1a;\n      |        ^\n/tmp/tmpfgq4vjsf/Strsafe_insert_name_conflict.c:64:11: error: used type 'char[4]' where\narithmetic or pointer type is required 64 |         *((char [4])&v1) =\nx1a->padding_4; |           ^         ~~~\n/tmp/tmpfgq4vjsf/Strsafe_insert_name_conflict.c:79:23: error: incomplete definition of type\n'struct struct_0' 79 |                 v3[v7]->field_10 = &v4[1]; | ~~~~~~^\n/tmp/tmpfgq4vjsf/Strsafe_insert_name_conflict.c:37:12: note: forward declaration of 'struct\nstruct_0' 37 |     struct struct_0 **v3;  // [bp-0x38] |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n} struct_1;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_1 *v1;    // [bp-0x10], Other Possible Types: unsigned long\n\n  if (!x1a)\n    return 0;\n  v0 = (int)strhash(a0) & x1a->field_0 - 1;\n  for (v1 = *((long long *)(x1a->field_10 + v0 * 8));\n       v1 && strcmp(*((long long *)v1), a0); v1 = *((long long *)(v1 + 8)))\n    ;\n  return (!v1 ? *((long long *)v1) : 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7nlhyam1/Strsafe_find_name_conflict.c:23:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 23 | extern struct_0 *x1a; |        ^~~~~~~~ | struct_1\n/tmp/tmp7nlhyam1/Strsafe_find_name_conflict.c:21:3: note: 'struct_1' declared here\n   21 | } struct_1;\n      |   ^\n/tmp/tmp7nlhyam1/Strsafe_find_name_conflict.c:32:27: error: invalid operands to binary\nexpression ('int' and 'char *') 32 |     v0 = (int)strhash(a0) & x1a->field_0 -\n1; |          ~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n/tmp/tmp7nlhyam1/Strsafe_find_name_conflict.c:33:36: error: no member named 'field_10' in\n'struct struct_1'; did you mean 'field_0'? 33 |     for (v1 = *((long long\n*)(x1a->field_10 + v0 * 8)); v1 && strcmp(*((long long *)v1), a0); v1 = *((long\nlong *)(v1 + 8))); |                                    ^~~~~~~~ | field_0\n/tmp/tmp7nlhyam1/Strsafe_find_name_conflict.c:19:11: note: 'field_0' declared here\n   19 |     char *field_0;\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() { return (!x2a ? x2a->field_4 : 0); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2yxze8jp/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmp2yxze8jp/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmp2yxze8jp/Symbol_count_name_conflict.c:23:25: error: member\nreference type 'int' is not a pointer 23 |     return (!x2a ? x2a->field_4 : 0);\n      |                    ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long findbreak_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x11]\n  unsigned int v1; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v2; // [bp-0xc]\n\n  v1 = a1;\n  for (v2 = v1; v2 <= (unsigned int)a2; v2 += 1) {\n    v0 = a0[v2];\n    if (v0 == 9)\n      a0[v2] = 32;\n    if (v0 == 10) {\n      a0[v2] = 32;\n      v1 = v2;\n      return (unsigned int)v1;\n    } else if (v0) {\n      if (v0 == 45 && v2 < (unsigned int)a2 - 1)\n        v1 = v2 + 1;\n      if (v0 == 32)\n        v1 = v2;\n    } else {\n      v1 = v2;\n      return (unsigned int)v1;\n    }\n  }\n  return (unsigned int)v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v0 = a0;\n  v1 = 0;\n  if (argv && argv->field_0) {\n    for (v2 = 1; argv[v2].field_0; v2 += 1) {\n      if (v1 || *((char *)argv[v2].field_0) != 45 &&\n                    *((char *)argv[v2].field_0) != 43 &&\n                    !strchr(argv[v2].field_0, 61)) {\n        if (v0)\n          v0 -= 1;\n        else\n          return v2;\n      }\n      if (!strcmp(argv[v2].field_0, \"--\"))\n        v1 = 1;\n    }\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcz_xx873/argindex_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpcz_xx873/argindex_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpcz_xx873/argindex_name_conflict.c:34:23: error: member reference type\n'int' is not a pointer 34 |     if (argv && argv->field_0) | ~~~~  ^\n/tmp/tmpcz_xx873/argindex_name_conflict.c:36:26: error: subscripted value is not an array,\npointer, or vector 36 |         for (v2 = 1; argv[v2].field_0; v2 += 1) |\n~~~~^~~ /tmp/tmpcz_xx873/argindex_name_conflict.c:38:37: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpcz_xx873/argindex_name_conflict.c:38:74: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpcz_xx873/argindex_name_conflict.c:38:109: error: subscripted value is not an\narray, pointer, or vector 38 |             if (v1 || *((char *)argv[v2].field_0)\n!= 45 && *((char *)argv[v2].field_0) != 43 && !strchr(argv[v2].field_0, 61)) |\n~~~~^~~ /tmp/tmpcz_xx873/argindex_name_conflict.c:45:29: error: subscripted value is not an\narray, pointer, or vector 45 |             if (!strcmp(argv[v2].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  if (!argv) {\n    return v2;\n  } else if (!argv->field_0) {\n    return v2;\n  } else {\n    for (v0 = 1; argv[v0].field_0; v0 += 1) {\n      if (v1 || *((char *)argv[v0].field_0) != 45 &&\n                    *((char *)argv[v0].field_0) != 43 &&\n                    !strchr(argv[v0].field_0, 61))\n        v2 += 1;\n      if (!strcmp(argv[v0].field_0, \"--\"))\n        v1 = 1;\n    }\n    return v2;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgubmut1t/OptNArgs_name_conflict.c:24:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 24 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpgubmut1t/OptNArgs_name_conflict.c:24:8: error: declaration of anonymous struct must be\na definition /tmp/tmpgubmut1t/OptNArgs_name_conflict.c:38:21: error: member reference type\n'int' is not a pointer 38 |     else if (!argv->field_0) |               ~~~~  ^\n/tmp/tmpgubmut1t/OptNArgs_name_conflict.c:44:26: error: subscripted value is not an array,\npointer, or vector 44 |         for (v0 = 1; argv[v0].field_0; v0 += 1) |\n~~~~^~~ /tmp/tmpgubmut1t/OptNArgs_name_conflict.c:46:37: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpgubmut1t/OptNArgs_name_conflict.c:46:74: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpgubmut1t/OptNArgs_name_conflict.c:46:109: error: subscripted value is not an\narray, pointer, or vector 46 |             if (v1 || *((char *)argv[v0].field_0)\n!= 45 && *((char *)argv[v0].field_0) != 43 && !strchr(argv[v0].field_0, 61)) |\n~~~~^~~ /tmp/tmpgubmut1t/OptNArgs_name_conflict.c:48:29: error: subscripted value is not an\narray, pointer, or vector 48 |             if (!strcmp(argv[v0].field_0, \"--\"))\n      |                         ~~~~^~~\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = argindex((unsigned int)a0);\n  return (v0 < 0 ? *((long long *)(argv + v0 * 8)) : 0);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long azDefine;\nextern unsigned int nDefine;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long preprocess_input_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0x28]\n  unsigned int v1;  // [bp-0x24]\n  unsigned int v2;  // [bp-0x20], Other Possible Types: char\n  unsigned int v3;  // [bp-0x1c]\n  unsigned int v4;  // [bp-0x18]\n  unsigned int v5;  // [bp-0x14]\n  unsigned int v6;  // [bp-0x10]\n  unsigned int v7;  // [bp-0xc]\n  unsigned int v10; // eax\n  unsigned int v12; // eax\n  unsigned int v14; // eax\n  unsigned int v16; // eax\n  unsigned int v18; // eax\n\n  v3 = 0;\n  v1 = 1;\n  for (v7 = 0; a0[v7]; v7 += 1) {\n    if (a0[v7] == 10)\n      v1 += 1;\n    if (!(a0[v7] != 37 || v7 > 0 && a0[1 + v7] != 10)) {\n      if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n            (v10 = (unsigned int)(unsigned short)*(\n                       (short *)(*((long long *)&__ctype_b_loc()) +\n                                 (long long)(char)a0[6 + v7] * 2)) &\n                   0x2000,\n             !v10))) {\n        if (v3) {\n          v3 -= 1;\n          if (!v3) {\n            for (v6 = *((int *)&v2); v6 < v7; v6 += 1) {\n              if (a0[v6] != 10)\n                a0[v6] = 32;\n            }\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      } else if (!strncmp(&a0[v7], \"%ifdef\", 6) &&\n                     !((v12 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[6 + v7] * 2)) &\n                              0x2000,\n                        !v12)) ||\n                 !strncmp(&a0[v7], \"%ifndef\", 7) && v14) {\n        if (v3) {\n          v3 += 1;\n        } else {\n          v6 = v7 + 7;\n          while (true) {\n            v16 = *((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) &\n                  0x2000;\n            if (!v16)\n              break;\n            v6 += 1;\n          }\n          for (v4 = 0; a0[v6 + v4] &&\n                       (v18 = (unsigned int)(unsigned short)*(\n                                  (short *)(*((long long *)&__ctype_b_loc()) +\n                                            (long long)(char)a0[v6 + v4] * 2)) &\n                              0x2000,\n                       !v18);\n               v4 += 1)\n            ;\n          v3 = 1;\n          for (v5 = 0; v5 < nDefine; v5 += 1) {\n            if (!(strncmp(*((long long *)(azDefine + (v5 << 3))), &a0[v6],\n                          v4) ||\n                  strlen(*((long long *)(azDefine + (v5 << 3)))) != v4)) {\n              v3 = 0;\n              break;\n            }\n          }\n          if (a0[3 + v7] == 110)\n            v3 = !v3;\n          if (v3) {\n            v2 = v7;\n            v0 = v1;\n          }\n        }\n        for (v6 = v7; a0[v6] && a0[v6] != 10; v6 += 1) {\n          a0[v6] = 32;\n        }\n      }\n    }\n  }\n  if (v3) {\n    fprintf(stderr @GLIBC_2.2.5, \"unterminated %%ifdef starting on line %d\\n\",\n            v0);\n    exit(1); /* do not return */\n  }\n  return a0[v7];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:45:116: error: cannot take the address of an\nrvalue of type 'int' 45 |             if (!(strncmp(&a0[v7], \"%endif\", 6) ||\n(v10 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[6 + v7] * 2)) & 0x2000, !v10))) |\n^~~~~~~~~~~~~~~~ /tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:64:122: error: cannot take\nthe address of an rvalue of type 'int' 64 |             else if\n(!strncmp(&a0[v7], \"%ifdef\", 6) && !((v12 = (unsigned int)(unsigned\nshort)*((short *)(*((long long *)&__ctype_b_loc()) + (long long)(char)a0[6 + v7]\n* 2)) & 0x2000, !v12)) || !strncmp(&a0[v7], \"%ifndef\", 7) && v14) |\n^~~~~~~~~~~~~~~~ /tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:75:58: error: cannot take\nthe address of an rvalue of type 'int' 75 |                         v16 =\n*((short *)(*((long long *)&__ctype_b_loc()) + a0[v6] * 2)) & 0x2000; |\n^~~~~~~~~~~~~~~~ /tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:80:113: error: cannot take\nthe address of an rvalue of type 'int' 80 |                     for (v4 = 0;\na0[v6 + v4] && (v18 = (unsigned int)(unsigned short)*((short *)(*((long long\n*)&__ctype_b_loc()) + (long long)(char)a0[v6 + v4] * 2)) & 0x2000, !v18); v4 +=\n1); | ^~~~~~~~~~~~~~~~ /tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:107:23: error:\nexpected ')' 107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef\nstarting on line %d\\n\", v0); |                       ^\n/tmp/tmpdcy_m4vf/preprocess_input_name_conflict.c:107:16: note: to match this '('\n  107 |         fprintf(stderr@GLIBC_2.2.5, \"unterminated %%ifdef starting on\nline %d\\n\", v0); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40f3e0;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char v0;  // [bp-0x31]\n  char *v1; // [bp-0x30], Other Possible Types: unsigned long\n  char *v2; // [bp-0x28], Other Possible Types: unsigned long\n  char *v3; // [bp-0x20], Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v0 = *(v1);\n    *(v1) = 0;\n    v2 = malloc(strlen(a1) + strlen(a0) + 2);\n    if (v2)\n      sprintf(v2, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v0;\n    return v2;\n  } else {\n    v3 = getenv(\"PATH\");\n    if (!v3)\n      v3 = \".:/bin:/usr/bin\";\n    v2 = malloc(strlen(a1) + strlen(v3) + 2);\n    if (!v2)\n      return v2;\n    while (*((char *)v3)) {\n      v1 = strchr(v3, 58);\n      if (!v1)\n        v1 = strlen(v3) + v3;\n      v0 = *((char *)v1);\n      *((char *)v1) = 0;\n      sprintf(v2, \"%s/%s\", (unsigned int)v3, (unsigned int)a1);\n      *((char *)v1) = v0;\n      if (!v0)\n        v3 = &g_40f3e0;\n      else\n        v3 = v1 + 1;\n      if (!access(v2, a2))\n        return v2;\n    }\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 >= 0)\n    return ((unsigned int)a1 <= 255\n                ? ((unsigned int)a1 <= 65534 ? \"unsigned int\"\n                                             : \"unsigned short int\")\n                : \"unsigned char\");\n  if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n    return \"signed char\";\n  if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n    return \"int\";\n  return \"short\";\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v0;              // [bp-0x18]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = malloc(size);\n  if (!v0)\n    memory_error(); /* do not return */\n  for (v1 = 0; v1 < size; v1 += 1) {\n    v0[v1] = 0;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = *((char *)(a0 + (unsigned int)a1));\n  *((char *)(a0 + (unsigned int)a1)) = 1;\n  return !v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(char *a0, char *a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  for (v1 = 0; v1 < size; v1 += 1) {\n    if (a1[v1] && !a0[v1]) {\n      v0 = 1;\n      a0[v1] = 1;\n    }\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  char *v0;              // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rdx\n  char *v4;              // rax\n\n  v0 = a0;\n  for (v1 = 0; *(v0);\n       v1 = *(v4) + (unsigned int)(((unsigned int)v3 * 2 + v3) * 4 + v3)) {\n    v3 = v1;\n    v4 = v0;\n    v0 = v4 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = Strsafe_name_conflict_find(a0);\n  if (!v0) {\n    v0 = malloc(strlen(a0) + 1);\n    if (v0) {\n      strcpy(v0, a0);\n      Strsafe_name_conflict_insert(v0);\n    }\n  }\n  if (!v0)\n    memory_error(); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_2 {\n  char *field_0;\n  struct struct_2 *field_8;\n  unsigned long long field_10;\n} struct_2;\n\ntypedef struct struct_1 {\n  unsigned long long field_0;\n  struct struct_1 *field_8;\n  unsigned long long field_10;\n} struct_1;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned int v0;          // [bp-0x48]\n  unsigned int v1;          // [bp-0x44]\n  unsigned long v2;         // [bp-0x40]\n  struct struct_3 **v3;     // [bp-0x38]\n  unsigned long long v4[3]; // [bp-0x30]\n  unsigned long long *v5;   // [bp-0x28]\n  unsigned int v6;          // [bp-0x20]\n  unsigned int v7;          // [bp-0x1c]\n  unsigned int v8;          // [bp-0x18]\n  unsigned int v9;          // [bp-0x14]\n  struct_2 *v10; // [bp-0x10], Other Possible Types: unsigned long, struct_1 *\n  char v11;      // [bp-0x8]\n  unsigned long long v13; // rbp\n  unsigned long long v18; // rsi\n  unsigned long long v19; // rdx\n\n  v13 = &v11;\n  if (!x1a)\n    return 0;\n  v8 = strhash(a0);\n  v7 = x1a->field_0 - 1 & v8;\n  for (v10 = *((long long *)(x1a->field_10 + v7 * 8)); v10;\n       v10 = *((long long *)(v10 + 8))) {\n    if (!strcmp(*((long long *)v10), a0))\n      return 0;\n  }\n  if (x1a->padding_4 >= x1a->field_0) {\n    v6 = x1a->field_0 * 2;\n    v0 = v6;\n    *((char[4]) & v1) = x1a->padding_4;\n    v2 = malloc(v6 * 32);\n    if (!v2)\n      return 0;\n    v3 = 3 * v6 * 8 + v2;\n    for (v9 = 0; v9 < v6; v9 += 1) {\n      v3[v9] = 0;\n    }\n    for (v9 = 0; v9 < x1a->padding_4; v9 += 1) {\n      v5 = 24 * v9 + (char *)x1a->field_8;\n      v7 = (int)strhash(*(v5)) & v6 - 1;\n      v4[0] = 3 * v9 * 8 + v2;\n      if (v3[v7])\n        v3[v7]->field_10 = &v4[1];\n      v4[1] = v3[v7];\n      v4[0] = *(v5);\n      v4[2] = &v3[v7];\n      v3[v7] = &v4[0];\n    }\n    free(x1a->field_8);\n    *((long long *)&x1a->field_0) = *((long long *)&v0);\n    x1a->field_8 = v2;\n    x1a->field_10 = v3;\n  }\n  v7 = x1a->field_0 - 1 & v8;\n  v18 = x1a->field_8;\n  v19 = (unsigned long long)x1a->padding_4;\n  *((unsigned int *)&x1a->padding_4[0]) = (unsigned int)v19 + 1;\n  v10 = 3 * v19 * 8 + v18;\n  v10->field_0 = a0;\n  if (*((long long *)(x1a->field_10 + (v7 << 3))))\n    *((struct_1 **)(*((long long *)(x1a->field_10 + v7 * 8)) + 16)) =\n        &v10->field_8;\n  v10->field_8 = *((long long *)(x1a->field_10 + v7 * 8));\n  *((struct_1 **)(v7 * 8 + x1a->field_10)) = v10;\n  v10->field_10 = v7 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4iojeyj0/Strsafe_insert_name_conflict.c:30:8: error: unknown type name 'struct_0'\n   30 | extern struct_0 *x1a;\n      |        ^\n/tmp/tmp4iojeyj0/Strsafe_insert_name_conflict.c:64:11: error: used type 'char[4]' where\narithmetic or pointer type is required 64 |         *((char [4])&v1) =\nx1a->padding_4; |           ^         ~~~\n/tmp/tmp4iojeyj0/Strsafe_insert_name_conflict.c:79:23: error: incomplete definition of type\n'struct struct_3' 79 |                 v3[v7]->field_10 = &v4[1]; | ~~~~~~^\n/tmp/tmp4iojeyj0/Strsafe_insert_name_conflict.c:37:12: note: forward declaration of 'struct\nstruct_3' 37 |     struct struct_3 **v3;  // [bp-0x38] |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n} struct_1;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  struct_1 *v1;    // [bp-0x10], Other Possible Types: unsigned long\n\n  if (!x1a)\n    return 0;\n  v0 = (int)strhash(a0) & x1a->field_0 - 1;\n  for (v1 = *((long long *)(x1a->field_10 + v0 * 8));\n       v1 && strcmp(*((long long *)v1), a0); v1 = *((long long *)(v1 + 8)))\n    ;\n  return (!v1 ? *((long long *)v1) : 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpynynn8ik/Strsafe_find_name_conflict.c:23:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 23 | extern struct_0 *x1a; |        ^~~~~~~~ | struct_1\n/tmp/tmpynynn8ik/Strsafe_find_name_conflict.c:21:3: note: 'struct_1' declared here\n   21 | } struct_1;\n      |   ^\n/tmp/tmpynynn8ik/Strsafe_find_name_conflict.c:32:27: error: invalid operands to binary\nexpression ('int' and 'char *') 32 |     v0 = (int)strhash(a0) & x1a->field_0 -\n1; |          ~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n/tmp/tmpynynn8ik/Strsafe_find_name_conflict.c:33:36: error: no member named 'field_10' in\n'struct struct_1'; did you mean 'field_0'? 33 |     for (v1 = *((long long\n*)(x1a->field_10 + v0 * 8)); v1 && strcmp(*((long long *)v1), a0); v1 = *((long\nlong *)(v1 + 8))); |                                    ^~~~~~~~ | field_0\n/tmp/tmpynynn8ik/Strsafe_find_name_conflict.c:19:11: note: 'field_0' declared here\n   19 |     char *field_0;\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() { return (!x2a ? x2a->field_4 : 0); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2cxk0s8_/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmp2cxk0s8_/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmp2cxk0s8_/Symbol_count_name_conflict.c:23:25: error: member\nreference type 'int' is not a pointer 23 |     return (!x2a ? x2a->field_4 : 0);\n      |                    ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parseHex_name_conflict(char *a0, unsigned long long *a1) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  for (*(a1) = 0; v0; v1 += 1) {\n    v0 = a0[v1];\n    if (!(v0 <= 47 || v0 > 57)) {\n      *(a1) = *(a1) * 16 + v0 - 48;\n    } else if (v0 <= 64 || v0 > 70) {\n      if (v0 <= 96)\n        return v1;\n      if (v0 > 102)\n        return v1;\n      *(a1) = *(a1) * 16 + v0 - 87;\n    } else {\n      *(a1) = *(a1) * 16 + v0 - 55;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/ucm2cp.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parseHex_name_conflict(char *a0, unsigned long long *a1) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  for (*(a1) = 0; v0; v1 += 1) {\n    v0 = a0[v1];\n    if (!(v0 <= 47 || v0 > 57)) {\n      *(a1) = *(a1) * 16 + v0 - 48;\n    } else if (v0 <= 64 || v0 > 70) {\n      if (v0 <= 96)\n        return v1;\n      if (v0 > 102)\n        return v1;\n      *(a1) = *(a1) * 16 + v0 - 87;\n    } else {\n      *(a1) = *(a1) * 16 + v0 - 55;\n    }\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":0,"function":"static int createTables(void) {\n    FILE *file;\n    if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n        if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n            perror(\"jis.table\");\n            return 1;\n        }\n    }\n    writeJis(file);\n    fclose(file);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(writeJis)(long long);\nvoid(perror)(char *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long createTables_name_conflict() {\n  FILE_t *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = &fopen(\"jis.table\", \"wb\")->_flags;\n  if (!v0) {\n    v0 = fopen(\"jis.table\", \"wb\");\n    if (!v0) {\n      perror(\"jis.table\");\n      return 1;\n    }\n  }\n  writeJis(v0);\n  fclose(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi6161pm2/createTables_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpi6161pm2/createTables_name_conflict.c:87:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 87 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":0,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(long long, long long, long long, long long);\n\nlong long wordCount_name_conflict(unsigned long long a0, unsigned int *a1) {\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  *(a1) = CountWords(a0, 0, 0, 1000);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(char *, unsigned long, unsigned long, unsigned long);\n\nlong long CountWords(char *a0, unsigned long a1, unsigned long a2,\n                     unsigned long a3) {\n  unsigned int v0;       // [bp-0x2c]\n  unsigned int v1;       // [bp-0x24]\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = a1;\n  v0 = a3;\n  if (v1 < 0) {\n    puts(\"ERROR: count needs to be greater than 0.\");\n    return 1;\n  } else if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else if ((unsigned int)a2 > v0) {\n    puts(\"ERROR: the start point was greater than the max size.\");\n    return 1;\n  } else {\n    if ((unsigned int)a2 >= 0 && v0 >= 0) {\n      if (*(a0) == 32) {\n        puts(\"ERROR: the first character in the array was empty. Please start \"\n             \"your sentence from the beginning.\");\n        return 1;\n      }\n      for (v2 = 0; a0[v2]; v2 += 1)\n        ;\n      v0 = v2;\n      if (a0[(unsigned int)a2] == 32 && a0[1 + a2] != 32 &&\n          (unsigned int)a2 != v0 - 1)\n        v1 += 1;\n      if ((unsigned int)a2 != v0)\n        v1 = CountWords(a0, v1, (unsigned int)a2 + 1, v0);\n      if ((unsigned int)a2 != v0)\n        return v1;\n      v1 += 1;\n      printf(\"number of words: %d\\n\", v1);\n      return v1;\n    }\n    puts(\"ERROR: the start point or the max size were set less than zero.\");\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long wordRemove_name_conflict(char *a0, char *a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0x20]\n  unsigned int v2;       // [bp-0x1c]\n  unsigned int v3;       // [bp-0x18]\n  unsigned int v4;       // [bp-0x14]\n  unsigned int v5;       // [bp-0x10]\n  unsigned int v6;       // [bp-0xc]\n  char v7;               // [bp-0x8]\n  unsigned long long v9; // rbp\n\n  v9 = &v7;\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else if (!a1) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else {\n    for (v6 = 0; a0[v6]; v6 += 1)\n      ;\n    for (v5 = 0; a1[v5]; v5 += 1)\n      ;\n    v4 = -1;\n    v0 = v6 - v5;\n    v2 = 0;\n    while (v4 <= v0 && !v2) {\n      v4 += 1;\n      v3 = 0;\n      if (!(a0[v4] == *(a1)))\n        continue;\n      for (; v3 < v5; v3 += 1) {\n        v2 = 1;\n        if (a0[v4 + v3] != a1[v3]) {\n          v2 = 0;\n          break;\n        }\n      }\n    }\n    for (v1 = v4; a0[v1 + v5]; v1 += 1) {\n      a0[v1] = a0[v1 + v5];\n    }\n    a0[v1] = 0;\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long vowelCheck_name_conflict(char *a0, unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  *(a1) = 0;\n  for (v0 = 0; a0[v0]; v0 += 1) {\n    if (a0[v0] == 97 || a0[v0] == 101 || a0[v0] == 105 || a0[v0] == 111 ||\n        a0[v0] == 117 || a0[v0] == 65 || a0[v0] == 69 || a0[v0] == 73 ||\n        a0[v0] == 79 || a0[v0] == 85)\n      *(a1) = *(a1) + 1;\n  }\n  printf(\"No. of vowels in %s = %d\\n\", (unsigned int)a0, *(a1));\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long subString_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  if (!a0)\n    return 1;\n  v1 = a1;\n  for (v0 = 0; a0[v0]; v1 += 1) {\n    if (v1 <= (unsigned int)a2)\n      a0[v0] = a0[v1];\n    else\n      a0[v0] = 0;\n    v0 += 1;\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long concatenateStrings_name_conflict(char *a0, char *a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = 0;\n  for (v0 = 0; a0[v1]; v1 += 1)\n    ;\n  printf(\"%d\", v1);\n  for (; a1[v0]; v1 += 1) {\n    a0[v1] = a1[v0];\n    v0 += 1;\n  }\n  a0[v1] = 0;\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long printString_name_conflict() {\n  char v0; // [bp-0x48]\n\n  puts(\"Please type a string\\n\");\n  __isoc99_scanf(\"\\n%50[^\\n]s\");\n  return puts(&v0);\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printStringWLen_name_conflict(char *a0, unsigned int *a1) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (!*(a0)) {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  for (v0 = 0; a0[v0]; v0 += 1)\n    ;\n  *(a1) = v0;\n  printf(\"You Entered:%s\\n\", (unsigned int)a0);\n  printf(\"The Length of the string is: %d\\n\", *(a1));\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long alphaNumeric_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n  if ((char)a0 > 64 && (char)a0 <= 90) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n  if ((char)a0 > 96 && (char)a0 <= 122) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n  printf(\"%c is not alphanumeric.\\n\", (char)a0);\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int testFindLength() {\n    int i, strLength, strLengthResponse = -5, returnValue;\n    for (i = 0; i < numArrays; i++) {\n        strLength = strings[i].length;\n        char *string = malloc(strLength * sizeof(char));\n        string = strings[i].value;\n        strLength = strlen(string);\n        returnValue = printStringWLen(string, &strLengthResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strLengthResponse == -5) {\n            return -2;\n        }\n        if (strLengthResponse != strLength) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(printStringWLen)(long long, long long);\n\nextern char g_4050a8;\nextern unsigned int numArrays;\nextern char strings;\n\nlong long testFindLength_name_conflict() {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  char *v2;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v3;       // [bp-0x10]\n  unsigned int v4;       // [bp-0xc]\n  char v5;               // [bp-0x8]\n  unsigned long long v7; // rbp\n\n  v7 = &v5;\n  v0 = -5;\n  for (v4 = 0; v4 < numArrays; v4 += 1) {\n    v3 = *((int *)&(&strings)[16 * v4]);\n    v2 = malloc(v3);\n    v2 = *((long long *)&(&g_4050a8)[16 * v4]);\n    v3 = strlen(v2);\n    v1 = printStringWLen(v2, &v0);\n    if (v1)\n      return 1;\n    if (v0 == -5) {\n      return 4294967294;\n    } else if (v3 != v0) {\n      return 4294967295;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testVowels() {\n    int i, e, numVowels, strLength, strVowelResponse, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        numVowels = 0;\n        strVowelResponse = -5;\n        for (i = 0; string[i] != '\\x00'; i++) {\n            if (string[i] == 'a' || string[i] == 'e' || string[i] == 'i' || string[i] == 'o' || string[i] == 'u' || string[i] == 'A' || string[i] == 'E' || string[i] == 'I' || string[i] == 'O' || string[i] == 'U')\n                numVowels++;\n        }\n        returnValue = vowelCheck(string, &strVowelResponse);\n        printf(\"Num Vowels Response -- %d\\n\", strVowelResponse);\n        printf(\"Num Vowels -- %d\\n\", numVowels);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strVowelResponse == -5) {\n            return -2;\n        }\n        if (strVowelResponse != numVowels) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(loadArrays)();\nlong long(vowelCheck)(long long, long long);\n\nextern char g_4050a8;\nextern unsigned int numArrays;\nextern char strings;\n\nlong long testVowels_name_conflict() {\n  unsigned int v0;       // [bp-0x28]\n  unsigned int v1;       // [bp-0x24]\n  char *v2;              // [bp-0x20]\n  unsigned int v3;       // [bp-0x18]\n  unsigned int v4;       // [bp-0x14]\n  unsigned int v5;       // [bp-0x10]\n  unsigned int v6;       // [bp-0xc]\n  char v7;               // [bp-0x8]\n  unsigned long long v9; // rbp\n\n  v9 = &v7;\n  v5 = 0;\n  while (v5 >= numArrays) {\n  LABEL_401508:\n    return 0;\n  }\n  loadArrays();\n  v3 = *((int *)&(&strings)[16 * v5]);\n  v2 = malloc(v3);\n  v2 = *((long long *)&(&g_4050a8)[16 * v5]);\n  v4 = 0;\n  v0 = -5;\n  for (v6 = 0; v2[v6]; v6 += 1) {\n    if (v2[v6] == 97 || v2[v6] == 101 || v2[v6] == 105 || v2[v6] == 111 ||\n        v2[v6] == 117 || v2[v6] == 65 || v2[v6] == 69 || v2[v6] == 73 ||\n        v2[v6] == 79 || v2[v6] == 85)\n      v4 += 1;\n  }\n  v1 = vowelCheck(v2, &v0);\n  printf(\"Num Vowels Response -- %d\\n\", v0);\n  printf(\"Num Vowels -- %d\\n\", v4);\n  if (v1)\n    return 1;\n  if (v0 == -5)\n    return 4294967294;\n  if (v4 != v0)\n    return 4294967295;\n  v5 += 1;\n  goto LABEL_401508;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testNumberWords() {\n    int i, e, numWords, strLength, strWordResponse = -5, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        string[0] = 'A';\n        numWords = 1;\n        strWordResponse = 0;\n        for (i = 1; string[i] != '\\x00'; i++) {\n            if ((string[i] == ' ' && string[i - 1] != ' ')) {\n                numWords++;\n            }\n        }\n        returnValue = wordCount(string, &strWordResponse);\n        printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", string, numWords, strWordResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strWordResponse == -5) {\n            return -2;\n        }\n        if (strWordResponse != numWords) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(loadArrays)();\nlong long(wordCount)(long long, long long);\n\nextern char g_4050a8;\nextern unsigned int numArrays;\nextern char strings;\n\nlong long testNumberWords_name_conflict() {\n  unsigned int v0;       // [bp-0x28]\n  unsigned int v1;       // [bp-0x24]\n  char *v2;              // [bp-0x20]\n  unsigned int v3;       // [bp-0x18]\n  unsigned int v4;       // [bp-0x14]\n  unsigned int v5;       // [bp-0x10]\n  unsigned int v6;       // [bp-0xc]\n  char v7;               // [bp-0x8]\n  unsigned long long v9; // rbp\n\n  v9 = &v7;\n  v0 = -5;\n  for (v5 = 0; v5 < numArrays; v5 += 1) {\n    loadArrays();\n    v3 = *((int *)&(&strings)[16 * v5]);\n    v2 = malloc(v3);\n    v2 = *((long long *)&(&g_4050a8)[16 * v5]);\n    *(v2) = 65;\n    v4 = 1;\n    v0 = 0;\n    for (v6 = 1; v2[v6]; v6 += 1) {\n      if (v2[v6] == 32 && v2[1 + v6] != 32)\n        v4 += 1;\n    }\n    v1 = wordCount(v2, &v0);\n    printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", (unsigned int)v2, v4,\n           v0);\n    if (v1)\n      return 1;\n    if (v0 == -5) {\n      return 4294967294;\n    } else if (v4 != v0) {\n      return 4294967295;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testAlphaNumericChar() {\n    int value;\n    int first;\n    int second;\n    int third;\n    value = alphaNumeric('n');\n    if (value == 0) {\n        first = 0;\n    }\n    if (value == 1) {\n        first = 1;\n    }\n    value = alphaNumeric('9');\n    if (value == 0) {\n        second = 0;\n    }\n    if (value == 1) {\n        second = 1;\n    }\n    value = alphaNumeric('!');\n    if (value == 0) {\n        third = 0;\n    }\n    if (value == 1) {\n        third = 1;\n    }\n    if (third == 0 && second == 0 && first == 0) {\n        return 0;\n    } else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(alphaNumeric)(long long);\n\nlong long testAlphaNumericChar_name_conflict() {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  v0 = alphaNumeric(110);\n  if (!v0)\n    v3 = 0;\n  if (v0 == 1)\n    v3 = 1;\n  v0 = alphaNumeric(57);\n  if (!v0)\n    v2 = 0;\n  if (v0 == 1)\n    v2 = 1;\n  v0 = alphaNumeric(33);\n  if (!v0)\n    v1 = 0;\n  if (v0 == 1)\n    v1 = 1;\n  if (!v1 && !v2 && !v3)\n    return 0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testSubString() {\n    char string[] = \"lucille\";\n    subString(string, 2, 5);\n    if (strcmp(string, \"cill\") != 0) {\n        printf(\"Testing Sub String -- %s\\n\", string);\n        return -1;\n    }\n    if (string == ((void *)0)) {\n        return -2;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(subString)(long long, long long, long long);\n\nlong long testSubString_name_conflict() {\n  char v0; // [bp-0x10]\n\n  strncpy(&v0, \"lucille\", 7);\n  subString(&v0, 2, 5);\n  if (!strcmp(&v0, \"cill\"))\n    return 0;\n  printf(\"Testing Sub String -- %s\\n\", (unsigned int)&v0);\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testConcat() {\n    char string1[500] = \"A melancholy-looking man, he had the appearance of one \";\n    char string2[] = \"who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    char stringTotal[] = \"A melancholy-looking man, he had the appearance of one who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    int returnValue = concatenateStrings(string1, string2);\n    if (returnValue != 0) {\n        return 1;\n    }\n    int i = 0;\n    while (stringTotal[i] != '\\x00')\n        {\n            if (string1[i] != stringTotal[i]) {\n                return -2;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenateStrings)(long long, long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long testConcat_name_conflict() {\n  char v0;                // [bp-0x308]\n  char v1;                // [bp-0x298]\n  char v2;                // [bp-0x28b]\n  char v3;                // [bp-0x278]\n  char v4;                // [bp-0x22a]\n  char v5;                // [bp-0x218]\n  char v6;                // [bp-0x1f8]\n  void *v7;               // [bp-0x1e0]\n  char v8;                // [bp-0x1d8]\n  unsigned int v9;        // [bp-0x20]\n  unsigned int v10;       // [bp-0x1c]\n  unsigned long long v12; // r8\n  unsigned long long v13; // r9\n  unsigned long long v14; // rsi\n  struct_0 *v15;          // rdx\n  unsigned long v16;      // rcx, Other Possible Types: unsigned long long\n  unsigned long v17;      // d\n  struct_0 *v18;          // rdi, Other Possible Types: unsigned long\n  unsigned long long v19; // rdx\n\n  v12 = 7164771175379050561;\n  v13 = 8029755603191361384;\n  strncpy(&v5, \"A melancholy-looking man, he had\", 32);\n  v14 = 2334381307593908581;\n  strncpy(&v6, \" the appearance of one \", 23);\n  v7 = 0;\n  v15 = &v8;\n  v16 = 54;\n  for (v18 = &v8; v16; v18 += v17 * 8) {\n    v16 -= 1;\n    *((long long *)v18) = 0;\n  }\n  *((int *)v18) = 0;\n  strncpy(&v3,\n          \"who has searched for the leak in life's gas-pipe with a lighted \"\n          \"candle - PG Wode\",\n          80);\n  strncpy(&v4, \"dehouse\", 7);\n  strncpy(&v0,\n          \"A melancholy-looking man, he had the appearance of one who has \"\n          \"searched for the leak in life's gas-pipe with a l\",\n          112);\n  v19 = 2318545003147980385;\n  strncpy(&v1, \"ighted candle - \", 16);\n  strncpy(&v2, \" - PG Wodehouse\", 15);\n  v9 = concatenateStrings(&v5, &v3);\n  if (v9)\n    return 1;\n  v10 = 0;\n  while (true) {\n    if (!(&v0)[v10]) {\n      return 0;\n    } else if ((&v5)[v10] == (&v0)[v10]) {\n      v10 += 1;\n    } else {\n      return 4294967294;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testRemove() {\n    char chararray[] = \"mother hubbard\";\n    char removeword[] = \"hubbard\";\n    wordRemove(chararray, removeword);\n    if (strcmp(chararray, \"mother \") != 0) {\n        return 0;\n    }\n    if (strcmp(chararray, \"mother\") != 0) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(wordRemove)(long long, long long);\n\nlong long testRemove_name_conflict() {\n  char v0; // [bp-0x1f]\n  char v1; // [bp-0x17]\n  char v2; // [bp-0x10]\n\n  strncpy(&v1, \"mother h\", 8);\n  strncpy(&v2, \"hubbard\", 7);\n  strncpy(&v0, \"hubbard\", 7);\n  wordRemove(&v1, &v0);\n  return (!strcmp(&v1, \"mother \") ? 0\n                                  : (!strcmp(&v1, \"mother\") ? 0 : 4294967295));\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int generateReport(char *file) {\n    FILE *outFile;\n    outFile = fopen(file, \"a\");\n    int functionResponse, i, numFunctions = 7, numErrors = 0;\n    struct TesterFunction functions[7] = {{\"Find Length Function\", &testFindLength}, {\"Find Vowels Function\", &testVowels}, {\"Find Number of Words Function\", &testNumberWords}, {\"Test if char is alpha-numeric\", &testAlphaNumericChar}, {\"Create Substring function\", &testSubString}, {\"Contatenate Function\", &testConcat}, {\"Remove Word Function\", &testRemove}};\n    addStrings(outFile, \"\\n\\nGenerall Tests ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    for (i = 0; i < numFunctions; i++) {\n        functionResponse = functions[i].function();\n        printf(\"Index %d Function %s returned %d\\n\", i, functions[i].name, functionResponse);\n        addStrings(outFile, functions[i].name);\n        switch (functionResponse) {\n          case 0:\n            addStrings(outFile, \" function ---  passed all tests.\\n\\n\");\n            break;\n          case 1:\n            addStrings(outFile, \" function ---- failed to run.\\n\\n\");\n            break;\n          case -1:\n            addStrings(outFile, \" function ---- did not return the correct result\\n\\n\");\n            break;\n          case -2:\n            addStrings(outFile, \" function ---- did not return result\\n\\n\");\n            break;\n        }\n    }\n    addStrings(outFile, \"\\n\\nExtra Targeted Testing ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    addStrings(outFile, \"ALL PASS\");\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n-----------------------------------------------------------------\\n\");\n    printf(\"REPORT HAS BEEN SAVED in file '%s' \\n\", file);\n    printf(\"Output fclose - %d\", fclose(outFile));\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint testFindLength;       // add global variable by heuristics\nint testVowels;           // add global variable by heuristics\nint testNumberWords;      // add global variable by heuristics\nint testAlphaNumericChar; // add global variable by heuristics\nint testSubString;        // add global variable by heuristics\nint testConcat;           // add global variable by heuristics\nint testRemove;           // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(addStrings)(long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long generateReport_name_conflict(char *a0) {\n  unsigned long long v0; // [bp-0x98]\n  unsigned long v1;      // [bp-0x90]\n  unsigned long v2;      // [bp-0x88]\n  unsigned long v3;      // [bp-0x80]\n  unsigned long v4;      // [bp-0x78]\n  unsigned long v5;      // [bp-0x70]\n  unsigned long v6;      // [bp-0x68]\n  unsigned long v7;      // [bp-0x60]\n  unsigned long v8;      // [bp-0x58]\n  unsigned long v9;      // [bp-0x50]\n  unsigned long v10;     // [bp-0x48]\n  unsigned long v11;     // [bp-0x40]\n  unsigned long v12;     // [bp-0x38]\n  unsigned long v13;     // [bp-0x30]\n  unsigned int v14;      // [bp-0x24]\n  unsigned int v15;      // [bp-0x20]\n  unsigned int v16;      // [bp-0x1c]\n  FILE_t *v17;           // [bp-0x18]\n  unsigned int v18;      // [bp-0xc]\n\n  v17 = &fopen(a0, \"a\")->_flags;\n  v16 = 7;\n  v15 = 0;\n  v0 = \"Find Length Function\";\n  v1 = testFindLength;\n  v2 = \"Find Vowels Function\";\n  v3 = testVowels;\n  v4 = \"Find Number of Words Function\";\n  v5 = testNumberWords;\n  v6 = \"Test if char is alpha-numeric\";\n  v7 = testAlphaNumericChar;\n  v8 = \"Create Substring function\";\n  v9 = testSubString;\n  v10 = \"Contatenate Function\";\n  v11 = testConcat;\n  v12 = \"Remove Word Function\";\n  v13 = testRemove;\n  addStrings(v17, \"\\n\\nGenerall Tests ...\\n\");\n  addStrings(\n      v17,\n      \"-----------------------------------------------------------------\\n\");\n  for (v18 = 0; v18 < v16; v18 += 1) {\n    v14 = (&v1)[2 * v18]();\n    printf(\"Index %d Function %s returned %d\\n\", v18,\n           (unsigned int)(&v0)[2 * v18], v14);\n    addStrings(v17, (&v0)[2 * v18]);\n    if (v14 == 1) {\n      addStrings(v17, \" function ---- failed to run.\\n\\n\");\n    } else if (v14 <= 1) {\n      if (!v14) {\n        addStrings(v17, \" function ---  passed all tests.\\n\\n\");\n      } else if (v14 <= 0) {\n        if (v14 == -2) {\n          addStrings(v17, \" function ---- did not return result\\n\\n\");\n        } else if (v14 == -1) {\n          addStrings(v17,\n                     \" function ---- did not return the correct result\\n\\n\");\n        }\n      }\n    }\n  }\n  addStrings(v17, \"\\n\\nExtra Targeted Testing ...\\n\");\n  addStrings(\n      v17,\n      \"-----------------------------------------------------------------\\n\");\n  addStrings(v17, \"ALL PASS\");\n  puts(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n-----------------------------------------------------\"\n       \"------------\");\n  printf(\"REPORT HAS BEEN SAVED in file '%s' \\n\", (unsigned int)a0);\n  printf(\"Output fclose - %d\", fclose(v17));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvd60k3v3/generateReport_name_conflict.c:93:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 93 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpvd60k3v3/generateReport_name_conflict.c:138:29: error: called object type 'unsigned\nlong' is not a function or function pointer 138 |         v14 = (&v1)[2 *\nv18](); |               ~~~~~~~~~~~~~~^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int generate_random_string_array(char *array, int array_length) {\n    int i;\n    if (!array) {\n        printf(\"Error: Input array was NULL\\n\");\n        return 1;\n    }\n    if (array_length < 1) {\n        printf(\"Error: required array size < 1\\n\");\n        return 1;\n    }\n    for (i = 0; i < array_length; i++) {\n        switch (rand() % 5) {\n          case 0:\n            array[i] = 'A' + (rand() % 26);\n            break;\n          case 1:\n            array[i] = ' ';\n            break;\n          default:\n            array[i] = 'a' + (rand() % 26);\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long generate_random_string_array_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0xc]\n  char v1;                // [bp-0x8]\n  unsigned long long v3;  // rbp\n  unsigned long long v5;  // rax\n  unsigned int v8;        // eax\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n\n  v3 = &v1;\n  if (!a0) {\n    puts(\"Error: Input array was NULL\");\n    return 1;\n  } else if ((unsigned int)a1 <= 0) {\n    puts(\"Error: required array size < 1\");\n    return 1;\n  } else {\n    for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n      (unsigned int)v5 = rand();\n      v8 = (unsigned int)v5 -\n           (unsigned int)(5 * ((v5 * 1717986919 >> 33) - (v5 >> 31)));\n      if (!v8) {\n        (unsigned int)v9 = rand();\n        a0[v0] =\n            v9 - (unsigned int)((v9 * 1321528399 >> 35) - (v9 >> 31)) * 26 + 65;\n      } else if (v8 == 1) {\n        a0[v0] = 32;\n      } else {\n        (unsigned int)v10 = rand();\n        a0[v0] = v10 -\n                 (unsigned int)((v10 * 1321528399 >> 35) - (v10 >> 31)) * 26 +\n                 97;\n      }\n    }\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp40aqo7f2/generate_random_string_array_name_conflict.c:43:13: error: assignment to cast\nis illegal, lvalue casts are not supported 43 |             (unsigned int)v5 =\nrand(); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp40aqo7f2/generate_random_string_array_name_conflict.c:47:17: error: assignment to cast\nis illegal, lvalue casts are not supported 47 |                 (unsigned int)v9\n= rand(); |                 ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp40aqo7f2/generate_random_string_array_name_conflict.c:56:17: error: assignment to cast\nis illegal, lvalue casts are not supported 56 |                 (unsigned\nint)v10 = rand(); |                 ^~~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int loadArrays() {\n    int i, currentArrayLength = 10;\n    for (i = 0; i < numArrays; i++) {\n        char array[currentArrayLength];\n        generate_random_string_array(array, currentArrayLength);\n        strings[i].value = malloc(currentArrayLength);\n        strcpy(strings[i].value, array);\n        strings[i].length = currentArrayLength;\n        currentArrayLength *= 5;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(generate_random_string_array)(long long, long long);\n\nextern char g_401f9b;\nextern char g_4050a8;\nextern unsigned int numArrays;\nextern char strings;\n\nlong long loadArrays_name_conflict() {\n  char *v0;              // [bp-0x50]\n  unsigned long v1;      // [bp-0x48]\n  unsigned int v2;       // [bp-0x40]\n  unsigned int v3;       // [bp-0x3c]\n  char v4;               // [bp-0x8]\n  char v5;               // [bp+0x0]\n  unsigned long long v7; // rax\n  unsigned long v8;      // rax\n\n  v2 = 10;\n  for (v3 = 0; v3 < numArrays; v3 += 1) {\n    v7 = v2;\n    v1 = v7 - 1;\n    v8 = (0 CONCAT v7 + 15) / m 16 * 16;\n    v0 = &(&v5)[-1 * v8];\n    *((char **)&(&v4)[-1 * v8]) = &g_401f9b;\n    generate_random_string_array(v0, v2);\n    *((void **)&(&g_4050a8)[16 * v3]) = malloc(v2);\n    strcpy(*((long long *)&(&g_4050a8)[16 * v3]), v0);\n    *((unsigned int *)&(&strings)[16 * v3]) = v2;\n    v2 = 5 * v2;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpofr1cp8s/loadArrays_name_conflict.c:40:17: error: expected ')'\n   40 |         v8 = (0 CONCAT v7 + 15) /m 16 * 16;\n      |                 ^\n/tmp/tmpofr1cp8s/loadArrays_name_conflict.c:40:14: note: to match this '('\n   40 |         v8 = (0 CONCAT v7 + 15) /m 16 * 16;\n      |              ^\n/tmp/tmpofr1cp8s/loadArrays_name_conflict.c:40:35: error: expected ';' after expression\n   40 |         v8 = (0 CONCAT v7 + 15) /m 16 * 16;\n      |                                   ^\n      |                                   ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int wordCount_handler(char *array) {\n    int numWords = 0;\n    wordCount(array, &numWords);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(wordCount)(long long, long long);\n\nlong long wordCount_handler_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  wordCount(a0, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int wordRemove_handler(char *array) {\n    char wordToRemove[1000];\n    char sentence[1000];\n    askQuestionString(sentence, \"Enter a sentence\");\n    askQuestionString(wordToRemove, \"Enter a word to remove\");\n    wordRemove(sentence, wordToRemove);\n    printf(\"Sentence after '%s' removed -- %s\\n\", wordToRemove, sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(askQuestionString)(long long, long long);\nlong long(wordRemove)(long long, long long);\n\nlong long wordRemove_handler_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x7f0]\n  char v1;          // [bp-0x7e8]\n  char v2;          // [bp-0x3f8]\n\n  v0 = a0;\n  askQuestionString(&v1, \"Enter a sentence\");\n  askQuestionString(&v2, \"Enter a word to remove\");\n  wordRemove(&v1, &v2);\n  printf(\"Sentence after '%s' removed -- %s\\n\", (unsigned int)&v2,\n         (unsigned int)&v1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int vowelCheck_handler(char *array) {\n    int vowels = 0;\n    vowelCheck(array, &vowels);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(vowelCheck)(long long, long long);\n\nlong long vowelCheck_handler_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  vowelCheck(a0, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int subString_handler(char *array) {\n    int start = 0, end = 0;\n    if (askQuestionInt(&start, \"Input start of substring\") == 1 || askQuestionInt(&end, \"Input end of substring\") == 1) {\n        return 1;\n    }\n    subString(array, start, end);\n    printf(\"String has been modified -- new string -- %s\\n\", array);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(askQuestionInt)(long long, long long);\nlong long(subString)(long long, long long, long long);\n\nlong long subString_handler_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  v0 = 0;\n  if ((int)askQuestionInt(&v1, \"Input start of substring\") != 1 &&\n      (int)askQuestionInt(&v0, \"Input end of substring\") != 1) {\n    subString(a0, v1, v0);\n    printf(\"String has been modified -- new string -- %s\\n\", (unsigned int)a0);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int concatStrings_handler(char *array) {\n    char one[100], two[100];\n    if (askQuestionString(one, \"Input first of string\") == 1 || askQuestionString(two, \"Input second of string\") == 1) {\n        return 1;\n    }\n    concatenateStrings(one, two);\n    printf(\"Concatenated Strings -- %s\\n\", one);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(askQuestionString)(long long, long long);\nlong long(concatenateStrings)(long long, long long);\n\nlong long concatStrings_handler_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0xf0]\n  char v1;          // [bp-0xe8]\n  char v2;          // [bp-0x78]\n\n  v0 = a0;\n  if ((int)askQuestionString(&v2, \"Input first of string\") != 1 &&\n      (int)askQuestionString(&v1, \"Input second of string\") != 1) {\n    concatenateStrings(&v2, &v1);\n    printf(\"Concatenated Strings -- %s\\n\", (unsigned int)&v2);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int printHandler(char *array) {\n    printf(\"%s\\n\", array);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printHandler_name_conflict(char *a0) {\n  puts(a0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int isAlpha_handler(char *array) {\n    char c;\n    printf(\"\\nEnter a Char :: \");\n    scanf(\" %c\", &c);\n    int isAlphaNum = alphaNumeric(c);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\nlong long(alphaNumeric)(long long);\n\nlong long isAlpha_handler_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x20]\n  char v1;          // [bp-0xd]\n  unsigned int v2;  // [bp-0xc]\n\n  v0 = a0;\n  printf(\"\\nEnter a Char :: \");\n  __isoc99_scanf(\" %c\", (unsigned int)&v1);\n  v2 = alphaNumeric(v1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int printMenu(char **array, int arrayLength) {\n    int i;\n    printf(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\\n\");\n    for (i = 0; i < arrayLength; i++) {\n        printf(\"\\t%d for %s\\n\", i, array[i]);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printMenu_name_conflict(unsigned long long *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  puts(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\");\n  for (v0 = 0; v0 < (unsigned int)a1; v0 += 1) {\n    printf(\"\\t%d for %s\\n\", v0, (unsigned int)a0[v0]);\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int askQuestionInt(int *value, char *q) {\n    printf(\"\\n%s : \", q);\n    scanf(\"%d\", value);\n    if (*value == -1) {\n        return -1;\n    }\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\nint(getchar)();\n\nlong long askQuestionInt_name_conflict(unsigned int *a0, unsigned long a1) {\n  printf(\"\\n%s : \", (unsigned int)a1);\n  __isoc99_scanf(\"%d\", (unsigned int)a0);\n  if (*(a0) == -1)\n    return 4294967295;\n  do {\n  } while (getchar() != 10);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int askQuestionString(char *value, char *q) {\n    printf(\"%s : \", q);\n    scanf(\"%[^\\t\\n]s\", value);\n    printf(\"%s\\n\", value);\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\nint(getchar)();\n\nlong long askQuestionString_name_conflict(char *a0, unsigned long a1) {\n  printf(\"%s : \", (unsigned int)a1);\n  __isoc99_scanf(\"%[^\\t\\n]s\");\n  puts(a0);\n  do {\n  } while (getchar() != 10);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(long long, long long, long long, long long);\n\nlong long wordCount_name_conflict(unsigned long long a0, unsigned int *a1) {\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  *(a1) = CountWords(a0, 0, 0, 1000);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(char *, unsigned long, unsigned long, unsigned long);\n\nlong long CountWords(char *a0, unsigned long a1, unsigned long a2,\n                     unsigned long a3) {\n  unsigned int v0;       // [bp-0x2c]\n  unsigned int v1;       // [bp-0x24], Other Possible Types: unsigned long\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = a1;\n  v0 = a3;\n  if (v1 < 0) {\n    puts(\"ERROR: count needs to be greater than 0.\");\n    return 1;\n  } else if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else if ((unsigned int)a2 > v0) {\n    puts(\"ERROR: the start point was greater than the max size.\");\n    return 1;\n  } else {\n    if ((unsigned int)a2 >= 0 && v0 >= 0) {\n      if (*(a0) == 32) {\n        puts(\"ERROR: the first character in the array was empty. Please start \"\n             \"your sentence from the beginning.\");\n        return 1;\n      }\n      for (v2 = 0; a0[v2]; v2 += 1)\n        ;\n      v0 = v2;\n      if (a0[(unsigned int)a2] == 32 && a0[1 + a2] != 32 &&\n          (unsigned int)a2 != v0 - 1)\n        v1 += 1;\n      if ((unsigned int)a2 != v0)\n        v1 = CountWords(a0, (unsigned int)v1, (unsigned int)a2 + 1, v0);\n      if ((unsigned int)a2 != v0)\n        return (unsigned int)v1;\n      v1 = (int)v1 + 1;\n      printf(\"number of words: %d\\n\", v1);\n      return (unsigned int)v1;\n    }\n    puts(\"ERROR: the start point or the max size were set less than zero.\");\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long wordRemove_name_conflict(char *a0, char *a1) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0x20]\n  unsigned int v2;       // [bp-0x1c]\n  unsigned int v3;       // [bp-0x18]\n  unsigned int v4;       // [bp-0x14]\n  unsigned int v5;       // [bp-0x10]\n  unsigned int v6;       // [bp-0xc]\n  char v7;               // [bp-0x8]\n  unsigned long long v9; // rbp\n\n  v9 = &v7;\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else if (!a1) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else {\n    for (v6 = 0; a0[v6]; v6 += 1)\n      ;\n    for (v5 = 0; a1[v5]; v5 += 1)\n      ;\n    v4 = -1;\n    v0 = v6 - v5;\n    v2 = 0;\n    while (v4 <= v0 && !v2) {\n      v4 += 1;\n      v3 = 0;\n      if (!(a0[v4] == *(a1)))\n        continue;\n      for (; v3 < v5; v3 += 1) {\n        v2 = 1;\n        if (a0[v4 + v3] != a1[v3]) {\n          v2 = 0;\n          break;\n        }\n      }\n    }\n    for (v1 = v4; a0[v1 + v5]; v1 += 1) {\n      a0[v1] = a0[v1 + v5];\n    }\n    a0[v1] = 0;\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long vowelCheck_name_conflict(char *a0, unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  *(a1) = 0;\n  for (v0 = 0; a0[v0]; v0 += 1) {\n    if (a0[v0] == 97 || a0[v0] == 101 || a0[v0] == 105 || a0[v0] == 111 ||\n        a0[v0] == 117 || a0[v0] == 65 || a0[v0] == 69 || a0[v0] == 73 ||\n        a0[v0] == 79 || a0[v0] == 85)\n      *(a1) = *(a1) + 1;\n  }\n  printf(\"No. of vowels in %s = %d\\n\", (unsigned int)a0, *(a1));\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long subString_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  if (!a0)\n    return 1;\n  v1 = a1;\n  for (v0 = 0; a0[v0]; v1 += 1) {\n    if (v1 > (unsigned int)a2)\n      a0[v0] = 0;\n    else\n      a0[v0] = a0[v1];\n    v0 += 1;\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long concatenateStrings_name_conflict(char *a0, char *a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = 0;\n  for (v0 = 0; a0[v1]; v1 += 1)\n    ;\n  printf(\"%d\", v1);\n  for (; a1[v0]; v1 += 1) {\n    a0[v1] = a1[v0];\n    v0 += 1;\n  }\n  a0[v1] = 0;\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long printString_name_conflict() {\n  char v0; // [bp-0x48]\n\n  puts(\"Please type a string\\n\");\n  __isoc99_scanf(\"\\n%50[^\\n]s\");\n  return puts(&v0);\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printStringWLen_name_conflict(char *a0, unsigned int *a1) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  if (!*(a0)) {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  for (v0 = 0; a0[v0]; v0 += 1)\n    ;\n  *(a1) = v0;\n  printf(\"You Entered:%s\\n\", (unsigned int)a0);\n  printf(\"The Length of the string is: %d\\n\", *(a1));\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long alphaNumeric_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n  if ((char)a0 > 64 && (char)a0 <= 90) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n  if ((char)a0 > 96 && (char)a0 <= 122) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n  printf(\"%c is not alphanumeric.\\n\", (char)a0);\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"static int foo1(void) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long foo1_name_conflict() { return 1; }\n","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":1,"function":"static int foo2(void) {\n    return 2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long foo2_name_conflict() { return 2; }\n","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":0,"function":"int tty_break() {\n    struct termio modmodes;\n    if (ioctl(fileno(stdin), 21509, &saved_modes) == -1) {\n        return -1;\n    }\n    have_modes = 1;\n    modmodes = saved_modes;\n    modmodes.c_lflag &= ~(2 | 8);\n    modmodes.c_cc[6] = 1;\n    modmodes.c_cc[5] = 0;\n    return ioctl(fileno(stdin), 21511, &modmodes);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *__TMC_END__;\nextern unsigned long long g_4040d8;\nextern unsigned short g_4040e0;\nextern unsigned int have_modes;\nextern unsigned long long saved_modes;\n\nlong long tty_break_name_conflict() {\n  unsigned long v0;  // [bp-0x28]\n  unsigned short v1; // [bp-0x22]\n  unsigned long v2;  // [bp-0x20]\n  char v3;           // [bp-0x1a]\n  char v4;           // [bp-0x19]\n  unsigned short v5; // [bp-0x18]\n\n  if (ioctl(fileno(__TMC_END__), 21509) == -1)\n    return 4294967295;\n  have_modes = 1;\n  v0 = saved_modes;\n  v2 = g_4040d8;\n  v5 = g_4040e0;\n  v1 = *((short *)((char *)&v0 + 6)) & 4294967285;\n  v4 = 1;\n  v3 = 0;\n  return ioctl(fileno(__TMC_END__), 21511);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9c8smt_7/tty_break_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 17 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"int tty_fix() {\n    if (!have_modes) {\n        return 0;\n    }\n    return ioctl(fileno(stdin), 21511, &saved_modes);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *__TMC_END__;\nextern unsigned int have_modes;\n\nlong long tty_fix_name_conflict() {\n  if (!have_modes)\n    return 0;\n  return ioctl(fileno(__TMC_END__), 21511);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy06mxmf6/tty_fix_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 17 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"size_t fmsynth_preset_size(void) {\n    return 8 + sizeof(struct fmsynth_preset_metadata) + FMSYNTH_PARAM_END * 8 * sizeof(uint32_t) + FMSYNTH_GLOBAL_PARAM_END * sizeof(uint32_t);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fmsynth_preset_size_name_conflict() { return 1040; }\n","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"static uint32_t read_u32(const uint8_t *buffer) {\n    return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] << 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long read_u32_name_conflict(char a0[4]) {\n  return a0[3] | a0[0] * 0x1000000 | a0[1] * 0x10000 | a0[2] * 0x100;\n}\n","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"unsigned int fmsynth_get_version(void) {\n    return 2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fmsynth_get_version_name_conflict() { return 2; }\n","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"int User_Authonrize(struct user *list_head, struct user *login) {\n    User_Login(login);\n    list_head = list_head->next;\n    while (list_head != ((void *)0))\n        {\n            if (!strcmp(login->ID, list_head->ID)) {\n                if (!strcmp(login->Key, list_head->Key)) {\n                    memcpy(login, list_head, sizeof(struct user));\n                    return 0;\n                }\n            }\n            list_head = list_head->next;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(User_Login)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  struct struct_0 *field_38;\n} struct_0;\n\nlong long User_Authonrize_name_conflict(struct_0 *a0, char *a1) {\n  struct_0 *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  User_Login(a1);\n  v0 = v0->field_38;\n  while (true) {\n    if (v0) {\n      if (!strcmp(a1, v0) && !strcmp(a1 + 28, v0 + 28)) {\n        memcpy(a1, v0, 64);\n        return 0;\n      }\n      v0 = *((long long *)(v0 + 56));\n    } else {\n      return 4294967295;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/sys.c"}
{"compilable":0,"function":"int getch(void) {\n    struct termios tm, tm_bak;\n    if (tcgetattr(0, &tm) < 0) {\n        perror(\"tcgetattr\");\n        exit(-1);\n    }\n    tm_bak = tm;\n    cfmakeraw(&tm);\n    if (tcsetattr(0, 0, &tm) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    int ch = getchar();\n    if (tcsetattr(0, 0, &tm_bak) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    if (ch == 3 || ch == 4)\n        exit(0);\n    else\n        return ch;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nvoid(perror)(char *);\nvoid(cfmakeraw)(struct termios {\n  unsigned long c_iflag;\n  unsigned long c_oflag;\n  unsigned long c_cflag;\n  unsigned long c_lflag;\n  char c_cc[20];\n  long __ispeed;\n  long __ospeed;\n} *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(getchar)();\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nlong long getch() {\n  unsigned long long v0; // [bp-0x88]\n  unsigned long long v1; // [bp-0x80]\n  unsigned long long v2; // [bp-0x78]\n  unsigned long long v3; // [bp-0x70]\n  unsigned long long v4; // [bp-0x68]\n  unsigned long long v5; // [bp-0x60]\n  unsigned long v6;      // [bp-0x5c]\n  unsigned long long v7; // [bp-0x54]\n  termios v8;            // [bp-0x48]\n  char v9;               // [bp-0x40]\n  char v10;              // [bp-0x38]\n  char v11;              // [bp-0x30]\n  char v12;              // [bp-0x28]\n  char v13;              // [bp-0x20]\n  unsigned long v14;     // [bp-0x1c]\n  char v15;              // [bp-0x14]\n  unsigned int v16;      // [bp-0xc]\n\n  if (tcgetattr(0, &v8) < 0) {\n    perror(\"tcgetattr\");\n    exit(-1); /* do not return */\n  }\n  v0 = *((long long *)&v8.c_iflag);\n  v1 = *((long long *)&v9);\n  v2 = *((long long *)&v10);\n  v3 = *((long long *)&v11);\n  v4 = *((long long *)&v12);\n  v5 = *((long long *)&v13);\n  v6 = v14;\n  v7 = *((long long *)&v15);\n  cfmakeraw(&v8);\n  if (tcsetattr(0, 0, &v8) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1); /* do not return */\n  }\n  v16 = getchar();\n  if (tcsetattr(0, 0, &v0) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1); /* do not return */\n  }\n  if (!(v16 != 3 && v16 != 4))\n    exit(0); /* do not return */\n  return v16;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_4o_0kd9/getch.c:25:7: error: conflicting types for 'perror'\n   25 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/getch.c"}
{"compilable":0,"function":"int Change_User_Passwd(struct user **list_head, char *key) {\n    struct user *pcur = (*list_head)->next;\n    while (pcur != ((void *)0))\n        {\n            if (!(strcmp(pcur->ID, key) && strcmp(pcur->Name, key))) {\n                char passwd_1[20] = {0};\n                char passwd_2[20] = {0};\n                int i;\n                for (i = 0; i < 3; i++) {\n                    printf(\"New password:\");\n                    scanf(\"%s\", passwd_1);\n                    printf(\"Retype new password:\");\n                    scanf(\"%s\", passwd_2);\n                    if (!strcmp(passwd_1, passwd_2)) {\n                        strcpy(pcur->Key, passwd_1);\n                        puts(\"all authentication tokens updated successfully.\");\n                        break;\n                    } else\n                        puts(\"Sorry, passwords do not match.\");\n                }\n                if (i == 3)\n                    puts(\"Have exhausted maximum number of retries for service\");\n                break;\n            }\n            pcur = pcur->next;\n        }\n    if (pcur == ((void *)0))\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  struct struct_0 *field_38;\n} struct_0;\n\nlong long Change_User_Passwd_name_conflict(struct struct_1 **a0, char *a1) {\n  void *v0;        // [bp-0x48]\n  void *v1;        // [bp-0x40]\n  unsigned int v2; // [bp-0x38]\n  void *v3;        // [bp-0x28]\n  void *v4;        // [bp-0x20]\n  unsigned int v5; // [bp-0x18]\n  unsigned int v6; // [bp-0x14]\n  struct_0 *v7;    // [bp-0x10], Other Possible Types: unsigned long\n\n  for (v7 = *(a0)->field_38; v7; v7 = v7->field_38) {\n    if (!strcmp(v7, a1) || !strcmp(&v7->padding_0[12], a1)) {\n      v3 = 0;\n      v4 = 0;\n      v5 = 0;\n      v0 = 0;\n      v1 = 0;\n      v2 = 0;\n      for (v6 = 0; v6 <= 2; v6 += 1) {\n        printf(\"New password:\");\n        __isoc99_scanf(\"%s\", (unsigned int)&v3);\n        printf(\"Retype new password:\");\n        __isoc99_scanf(\"%s\", (unsigned int)&v0);\n        if (strcmp(&v3, &v0)) {\n          puts(\"Sorry, passwords do not match.\");\n        } else {\n          strcpy(v7 + 28, &v3);\n          puts(\"all authentication tokens updated successfully.\");\n          break;\n        }\n      }\n      if (v6 == 3)\n        puts(\"Have exhausted maximum number of retries for service\");\n      break;\n    }\n  }\n  return (!v7 ? 0 : 4294967295);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpylz3a1v5/Change_User_Passwd_name_conflict.c:34:20: error: member reference base type\n'struct struct_1 *' is not a structure or union 34 |     for (v7 =\n*(a0)->field_38; v7; v7 = v7->field_38) |                ~~~~^ ~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/linklist.c"}
{"compilable":1,"function":"const char *memstr(const char *full_data, int full_data_len, const char *substr) {\n    if (full_data == ((void *)0) || full_data_len <= 0 || substr == ((void *)0)) {\n        return ((void *)0);\n    }\n    if (*substr == '\\x00') {\n        return ((void *)0);\n    }\n    int sublen = strlen(substr);\n    int i;\n    const char *cur = full_data;\n    int last_possible = full_data_len - sublen + 1;\n    for (i = 0; i < last_possible; i++) {\n        if (*cur == *substr) {\n            if (memcmp(cur, substr, sublen) == 0) {\n                return cur;\n            }\n        }\n        cur++;\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long memstr_name_conflict(char *a0, unsigned long a1, char *a2) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  char *v2;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v3;       // [bp-0xc]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n\n  v6 = &v4;\n  if (a0 && (unsigned int)a1 > 0 && a2) {\n    if (*(a2)) {\n      v1 = strlen(a2);\n      v2 = a0;\n      v0 = (unsigned int)a1 - v1 + 1;\n      for (v3 = 0; v3 < v0; v3 += 1) {\n        if (*(v2) == *(a2) && !memcmp(v2, a2, v1))\n          return v2;\n        v2 += 1;\n      }\n      return 0;\n    } else {\n      return 0;\n    }\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/qwerty258_HLSDownload_old/utils.c"}
{"compilable":0,"function":"int isdirreducable() {\n    int ndirs = (int)pow(2, directory->globle_depth);\n    for (int i = 0; i < ndirs; ++i) {\n        if (directory->dir_elem_list[i].flag == -1) {\n            if (directory->dir_elem_list[i].bucket->local_depth == directory->globle_depth) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint directory; // add global variable by heuristics\nint xmm1;      // add global variable by heuristics\nint directory; // add global variable by heuristics\nint directory; // add global variable by heuristics\nint directory; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble(pow)(double, double);\n\nextern struct_0 *directory;\n\nlong long isdirreducable_name_conflict() {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n  int v3;          // xmm0\n  int v4;          // xmm1\n  int v5;          // xmm0\n\n  v3 = 0;\n  *((unsigned long long *)&v3) = directory->field_0;\n  v4 = v3;\n  v5 = 0x4000000000000000;\n  pow(0x4000000000000000, xmm1);\n  v0 = 0;\n  for (v1 = 0; v1 < v0; v1 += 1) {\n    if (*((int *)(directory->field_8 + (v1 << 4) + 8)) == -1 &&\n        *((int *)*((long long *)(directory->field_8 + (v1 << 4)))) ==\n            directory->field_0)\n      return 0;\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf6y19t1x/isdirreducable_name_conflict.c:23:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 23 | extern struct_0 *directory; |        ^~~~~~~~ | struct\n/tmp/tmpf6y19t1x/isdirreducable_name_conflict.c:23:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpf6y19t1x/isdirreducable_name_conflict.c:34:47: error: member\nreference type 'int' is not a pointer 34 |     *((unsigned long long *)&v3) =\ndirectory->field_0; |                                    ~~~~~~~~~  ^\n/tmp/tmpf6y19t1x/isdirreducable_name_conflict.c:41:34: error: member reference type 'int' is\nnot a pointer 41 |         if (*((int *)(directory->field_8 + (v1 << 4) + 8)) ==\n-1 && *((int *)*((long long *)(directory->field_8 + (v1 << 4)))) ==\ndirectory->field_0) |                       ~~~~~~~~~  ^\n/tmp/tmpf6y19t1x/isdirreducable_name_conflict.c:41:105: error: member reference type 'int' is\nnot a pointer 41 |         if (*((int *)(directory->field_8 + (v1 << 4) + 8)) ==\n-1 && *((int *)*((long long *)(directory->field_8 + (v1 << 4)))) ==\ndirectory->field_0) | ~~~~~~~~~  ^ /tmp/tmpf6y19t1x/isdirreducable_name_conflict.c:41:142:\nerror: member reference type 'int' is not a pointer 41 |         if (*((int\n*)(directory->field_8 + (v1 << 4) + 8)) == -1 && *((int *)*((long long\n*)(directory->field_8 + (v1 << 4)))) == directory->field_0) | ~~~~~~~~~  ^ 6\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nilesh2014_Extendible-Hashing/hashing.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= 23) {\n        if (buffer_size >= 1) {\n            buffer[0] = value + offset;\n            return 1;\n        }\n    } else {\n        if (buffer_size >= 2) {\n            buffer[0] = 24 + offset;\n            buffer[1] = value;\n            return 2;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint8(unsigned long a0, char a1[2], unsigned long a2,\n                             unsigned long a3) {\n  if ((char)a0 > 23) {\n    if (a2 > 1) {\n      a1[0] = (char)a3 + 24;\n      a1[1] = a0;\n      return 2;\n    }\n  } else {\n    if (a2) {\n      a1[0] = (char)a0 + (char)a3;\n      return 1;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 3) {\n        buffer[0] = 25 + offset;\n        buffer[1] = (unsigned char)(value >> 8);\n        buffer[2] = (unsigned char)value;\n        return 3;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint16(unsigned long a0, char a1[3], unsigned long a2,\n                              unsigned long a3) {\n  if (a2 <= 2)\n    return 0;\n  a1[0] = (char)a3 + 25;\n  a1[1] = (unsigned short)a0 >> 8;\n  a1[2] = a0;\n  return 3;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 5) {\n        buffer[0] = 26 + offset;\n        buffer[1] = (unsigned char)(value >> 24);\n        buffer[2] = (unsigned char)(value >> 16);\n        buffer[3] = (unsigned char)(value >> 8);\n        buffer[4] = (unsigned char)value;\n        return 5;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint32(unsigned long a0, char a1[5], unsigned long a2,\n                              unsigned long a3) {\n  if (a2 <= 4)\n    return 0;\n  a1[0] = (char)a3 + 26;\n  a1[1] = (unsigned int)a0 >> 24;\n  a1[2] = (unsigned int)a0 >> 16;\n  a1[3] = (unsigned int)a0 >> 8;\n  a1[4] = a0;\n  return 5;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 9) {\n        buffer[0] = 27 + offset;\n        buffer[1] = (unsigned char)(value >> 56);\n        buffer[2] = (unsigned char)(value >> 48);\n        buffer[3] = (unsigned char)(value >> 40);\n        buffer[4] = (unsigned char)(value >> 32);\n        buffer[5] = (unsigned char)(value >> 24);\n        buffer[6] = (unsigned char)(value >> 16);\n        buffer[7] = (unsigned char)(value >> 8);\n        buffer[8] = (unsigned char)value;\n        return 9;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint64(unsigned long a0, char a1[9], unsigned long a2,\n                              unsigned long a3) {\n  if (a2 <= 8)\n    return 0;\n  a1[0] = (char)a3 + 27;\n  a1[1] = (char)a0 / 0x100000000000000;\n  a1[2] = (char)a0 / 0x1000000000000;\n  a1[3] = (char)a0 / 0x10000000000;\n  a1[4] = (char)a0 / 0x100000000;\n  a1[5] = (char)a0 / 0x1000000;\n  a1[6] = (char)a0 / 0x10000;\n  a1[7] = (char)a0 / 0x100;\n  a1[8] = a0;\n  return 9;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= (65535))\n        if (value <= (255))\n            return _cbor_encode_uint8((uint8_t)value, buffer, buffer_size, offset);\n        else\n            return _cbor_encode_uint16((uint16_t)value, buffer, buffer_size, offset);\n    else if (value <= (4294967295U))\n        return _cbor_encode_uint32((uint32_t)value, buffer, buffer_size, offset);\n    else\n        return _cbor_encode_uint64((uint64_t)value, buffer, buffer_size, offset);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\nlong long(_cbor_encode_uint16)(long long, long long, long long, long long);\nlong long(_cbor_encode_uint64)(long long, long long, long long, long long);\nlong long(_cbor_encode_uint32)(long long, long long, long long, long long);\n\nlong long _cbor_encode_uint(unsigned long long a0, unsigned long long a1,\n                            unsigned long long a2, unsigned long a3) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0 > 65535) {\n    if (4294967295 >= a0) {\n      v1 = _cbor_encode_uint32(a0, a1, a2, (char)a3);\n      return v1;\n    }\n    v1 = _cbor_encode_uint64(a0, a1, a2, (char)a3);\n    return v1;\n  } else {\n    if (a0 > 255) {\n      v1 = _cbor_encode_uint16(a0, a1, a2, (char)a3);\n      return v1;\n    }\n    v1 = _cbor_encode_uint8(a0, a1, a2, (char)a3);\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint8(unsigned long a0, unsigned long long a1,\n                            unsigned long long a2) {\n  return _cbor_encode_uint8((char)a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint16)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint16(unsigned long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint16((unsigned short)a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint32)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint32(unsigned long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint32((unsigned int)a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint64)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint64(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint64(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint(unsigned long long a0, unsigned long long a1,\n                           unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint8(unsigned long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  return _cbor_encode_uint8((char)a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint16)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint16(unsigned long a0, unsigned long long a1,\n                               unsigned long long a2) {\n  return _cbor_encode_uint16((unsigned short)a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint32)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint32(unsigned long a0, unsigned long long a1,\n                               unsigned long long a2) {\n  return _cbor_encode_uint32((unsigned int)a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint64)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint64(unsigned long long a0, unsigned long long a1,\n                               unsigned long long a2) {\n  return _cbor_encode_uint64(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bytestring_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 64);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_bytestring_start(unsigned long long a0,\n                                       unsigned long long a1,\n                                       unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 64);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t _cbor_encode_byte(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    if (buffer_size >= 1) {\n        buffer[0] = value;\n        return 1;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_byte_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  if (!a2)\n    return 0;\n  *(a1) = a0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_bytestring_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(95, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_indef_bytestring_start(unsigned long long a0,\n                                             unsigned long long a1) {\n  return _cbor_encode_byte(95, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_string_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 96);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_string_start(unsigned long long a0, unsigned long long a1,\n                                   unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 96);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_string_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(127, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_indef_string_start(unsigned long long a0,\n                                         unsigned long long a1) {\n  return _cbor_encode_byte(127, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_array_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 128);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_array_start(unsigned long long a0, unsigned long long a1,\n                                  unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 128);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_array_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(159, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_indef_array_start(unsigned long long a0,\n                                        unsigned long long a1) {\n  return _cbor_encode_byte(159, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_map_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 160);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_map_start(unsigned long long a0, unsigned long long a1,\n                                unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 160);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_map_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(191, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_indef_map_start(unsigned long long a0,\n                                      unsigned long long a1) {\n  return _cbor_encode_byte(191, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_tag(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 192);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_tag(unsigned long long a0, unsigned long long a1,\n                          unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 192);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bool(bool value, unsigned char *buffer, size_t buffer_size) {\n    return value ? _cbor_encode_byte(245, buffer, buffer_size) : _cbor_encode_byte(244, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_bool(unsigned long a0, unsigned long long a1,\n                           unsigned long long a2) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (!(char)a0) {\n    v1 = _cbor_encode_byte(244, a1, a2);\n    return v1;\n  }\n  v1 = _cbor_encode_byte(245, a1, a2);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_null(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(246, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_null_name_conflict(unsigned long long a0, unsigned long long a1) {\n  return _cbor_encode_byte(246, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_undef(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(247, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_undef_name_conflict(unsigned long long a0, unsigned long long a1) {\n  return _cbor_encode_byte(247, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_break(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(255, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_byte)(long long, long long, long long);\n\nlong long cbor_encode_break_name_conflict(unsigned long long a0, unsigned long long a1) {\n  return _cbor_encode_byte(255, a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_ctrl(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 224);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\n\nlong long cbor_encode_ctrl(unsigned long a0, unsigned long long a1,\n                           unsigned long long a2) {\n  return _cbor_encode_uint8((char)a0, a1, a2, 224);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  unsigned int v0;  // [bp-0x44]\n  unsigned int v1;  // [bp-0x2c]\n  char *v2;         // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x10]\n  unsigned long v6; // rbx\n\n  v4 = v6;\n  v0 = a1;\n  if (!*(a2))\n    return 0;\n  v3 = strchr(*(a2), 10);\n  v2 = &*(a2)->field_0;\n  if (!v3) {\n    if (*(v2))\n      v3 = &v2[strlen(v2)];\n    else\n      return 0;\n  }\n  v1 = (unsigned int)v3 + 1 - (unsigned int)v2;\n  if (v0 > v1)\n    v0 = v1;\n  memcpy(a0, *(a2), v0);\n  a0[v0] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[v0];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7ufs3zbj/sgets_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v2 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp7ufs3zbj/sgets_name_conflict.c:47:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 47 |         *(a2) = &(*(a2))[v0]; | ~~~~~~~^\n/tmp/tmp7ufs3zbj/sgets_name_conflict.c:17:52: note: forward declaration of 'struct struct_0'\n   17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":1,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpxdg3n8r1/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), (unsigned int)v1);\n  a0[(int)v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0ygz07k7/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp0ygz07k7/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[(int)v1]; |\n~~~~~~~^ /tmp/tmp0ygz07k7/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvpq99hpd/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpvpq99hpd/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpvpq99hpd/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpvpq99hpd/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpvpq99hpd/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpvpq99hpd/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpvpq99hpd/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), (unsigned int)v1);\n  a0[(int)v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpckob3sba/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpckob3sba/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[(int)v1]; |\n~~~~~~~^ /tmp/tmpckob3sba/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj_cpyvin/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpj_cpyvin/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpj_cpyvin/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpj_cpyvin/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpj_cpyvin/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpj_cpyvin/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpj_cpyvin/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), (unsigned int)v1);\n  a0[(int)v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuklkzz_g/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpuklkzz_g/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[(int)v1]; |\n~~~~~~~^ /tmp/tmpuklkzz_g/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfm3r8h10/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpfm3r8h10/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpfm3r8h10/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpfm3r8h10/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpfm3r8h10/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpfm3r8h10/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpfm3r8h10/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int work(long loop_count) {\n    while (loop_count-- > 0)\n        {\n            syslog(6, \"loglog\");\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(syslog)(int, char *, ...);\n\nlong long work_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long long v2; // rax\n\n  v0 = a0;\n  while (true) {\n    v2 = v0;\n    v0 = v2 - 1;\n    if (v2 <= 0)\n      break;\n    syslog(6, \"loglog\");\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":0,"function":"int test(long process_count, long loop_count) {\n    long i;\n    pid_t pid;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            work(loop_count);\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nlong long(work)(long long);\n\nlong long test_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned int v0;       // [bp-0x14]\n  void *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  for (v1 = 0; v1 < a0; v1 += 1) {\n    v0 = fork();\n    if (v0 < 0) {\n      puts(\"fork fail\");\n    } else if (!v0) {\n      work(a1);\n      return 0;\n    }\n  }\n  for (v1 = 0; v1 < a0; v1 += 1) {\n    v0 = wait(NULL);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), (unsigned int)v1);\n  a0[(int)v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb9nzuzbt/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpb9nzuzbt/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[(int)v1]; |\n~~~~~~~^ /tmp/tmpb9nzuzbt/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyqdo377_/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpyqdo377_/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpyqdo377_/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpyqdo377_/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpyqdo377_/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpyqdo377_/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpyqdo377_/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  unsigned int v0;  // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v1;  // [bp-0x2c]\n  char *v2;         // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x10]\n  unsigned long v6; // rbx\n\n  v4 = v6;\n  v0 = a1;\n  if (!*(a2))\n    return 0;\n  v3 = strchr(*(a2), 10);\n  v2 = &*(a2)->field_0;\n  if (!v3) {\n    if (*(v2))\n      v3 = &v2[strlen(v2)];\n    else\n      return 0;\n  }\n  v1 = (unsigned int)v3 + 1 - (unsigned int)v2;\n  if (v0 > v1)\n    v0 = v1;\n  memcpy(a0, *(a2), (unsigned int)v0);\n  a0[(int)v0] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v0];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpevnigg4b/sgets_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v2 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpevnigg4b/sgets_name_conflict.c:47:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 47 |         *(a2) = &(*(a2))[(int)v0]; |\n~~~~~~~^ /tmp/tmpevnigg4b/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyy5moho_/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpyy5moho_/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpyy5moho_/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpyy5moho_/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpyy5moho_/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpyy5moho_/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpyy5moho_/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), (unsigned int)v1);\n  a0[(int)v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9fij_m2a/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp9fij_m2a/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[(int)v1]; |\n~~~~~~~^ /tmp/tmp9fij_m2a/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp9tn_t_gj/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  unsigned int v0;  // [bp-0x44], Other Possible Types: unsigned long\n  unsigned int v1;  // [bp-0x2c]\n  char *v2;         // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x10]\n  unsigned long v6; // rbx\n\n  v4 = v6;\n  v0 = a1;\n  if (!*(a2))\n    return 0;\n  v3 = strchr(*(a2), 10);\n  v2 = &*(a2)->field_0;\n  if (!v3) {\n    if (*(v2))\n      v3 = &v2[strlen(v2)];\n    else\n      return 0;\n  }\n  v1 = (unsigned int)v3 + 1 - (unsigned int)v2;\n  if (v0 > v1)\n    v0 = v1;\n  memcpy(a0, *(a2), (unsigned int)v0);\n  a0[(int)v0] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[(int)v0];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7vjb6yvk/sgets_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v2 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp7vjb6yvk/sgets_name_conflict.c:47:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 47 |         *(a2) = &(*(a2))[(int)v0]; |\n~~~~~~~^ /tmp/tmp7vjb6yvk/sgets_name_conflict.c:17:52: note: forward declaration of 'struct\nstruct_0' 17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp02bcxkn9/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp02bcxkn9/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp02bcxkn9/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp02bcxkn9/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp02bcxkn9/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp02bcxkn9/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp02bcxkn9/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, (void *)j);\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m;    // add global variable by heuristics\nint work; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nchar *(pthread_create)(char *, char *, char *, char *);\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                // [bp-0x71]\n  unsigned long long *v1; // [bp-0x60]\n  unsigned long v2;       // [bp-0x58]\n  unsigned int v3;        // [bp-0x4c]\n  unsigned long long *v4; // [bp-0x48], Other Possible Types: unsigned long\n  void *v5;               // [bp-0x40], Other Possible Types: unsigned long\n  unsigned long v7;       // rdx\n\n  for (v5 = 0; v5 < a0; v5 += 1) {\n    v3 = fork();\n    if (v3 < 0) {\n      puts(\"fork fail\");\n    } else if (!v3) {\n      v2 = a1 - 1;\n      v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) / m 16] >> 3) * 8;\n      for (v4 = 0; v4 < a1; v4 = (char *)v4 + 1) {\n        pthread_create(0x8 * v4 + (char *)v1, NULL, work, v4);\n      }\n      for (v4 = 0; v4 < a1; v4 = (char *)v4 + 1) {\n        v7 = v4;\n        pthread_join(v1[v7], 0, v7);\n      }\n      return 0;\n    }\n  }\n  for (v5 = 0; v5 < a0; v5 += 1) {\n    v3 = wait(NULL);\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_a2nh0c0/test_name_conflict.c:42:35: error: expected ')'\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                                   ^\n/tmp/tmp_a2nh0c0/test_name_conflict.c:42:32: note: to match this '('\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                                ^\n/tmp/tmp_a2nh0c0/test_name_conflict.c:42:58: error: expected ']'\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                                                          ^\n/tmp/tmp_a2nh0c0/test_name_conflict.c:42:25: note: to match this '['\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                         ^\n/tmp/tmp_a2nh0c0/test_name_conflict.c:45:36: error: invalid operands to binary expression\n('int' and 'unsigned long long *') 45 |                 pthread_create(0x8 * v4\n+ (char *)v1, NULL, work, v4); |                                ~~~ ^ ~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write2.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  unsigned int v0;  // [bp-0x44]\n  unsigned int v1;  // [bp-0x2c]\n  char *v2;         // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x10]\n  unsigned long v6; // rbx\n\n  v4 = v6;\n  v0 = a1;\n  if (!*(a2))\n    return 0;\n  v3 = strchr(*(a2), 10);\n  v2 = &*(a2)->field_0;\n  if (!v3) {\n    if (*(v2))\n      v3 = &v2[strlen(v2)];\n    else\n      return 0;\n  }\n  v1 = (unsigned int)v3 + 1 - (unsigned int)v2;\n  if (v0 > v1)\n    v0 = v1;\n  memcpy(a0, *(a2), v0);\n  a0[v0] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[v0];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0bnpy_4s/sgets_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v2 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp0bnpy_4s/sgets_name_conflict.c:47:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 47 |         *(a2) = &(*(a2))[v0]; | ~~~~~~~^\n/tmp/tmp0bnpy_4s/sgets_name_conflict.c:17:52: note: forward declaration of 'struct struct_0'\n   17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0301_n0d/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp0301_n0d/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp0301_n0d/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp0301_n0d/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp0301_n0d/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp0301_n0d/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp0301_n0d/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m;    // add global variable by heuristics\nint work; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nchar *(pthread_create)(char *, char *, char *, char *);\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                // [bp-0x71]\n  unsigned long long *v1; // [bp-0x60]\n  unsigned long v2;       // [bp-0x58]\n  unsigned int v3;        // [bp-0x4c]\n  unsigned long long *v4; // [bp-0x48], Other Possible Types: unsigned long\n  void *v5;               // [bp-0x40], Other Possible Types: unsigned long\n  unsigned long v7;       // rdx\n\n  for (v5 = 0; v5 < a0; v5 += 1) {\n    v3 = fork();\n    if (v3 < 0) {\n      puts(\"fork fail\");\n    } else if (!v3) {\n      v2 = a1 - 1;\n      v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) / m 16] >> 3) * 8;\n      for (v4 = 0; v4 < a1; v4 = (char *)v4 + 1) {\n        pthread_create((char *)v1 + 0x8 * v4, NULL, work, NULL);\n      }\n      for (v4 = 0; v4 < a1; v4 = (char *)v4 + 1) {\n        v7 = v4;\n        pthread_join(v1[v7], 0, v7);\n      }\n      return 0;\n    }\n  }\n  for (v5 = 0; v5 < a0; v5 += 1) {\n    v3 = wait(NULL);\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9hrvsli7/test_name_conflict.c:42:35: error: expected ')'\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                                   ^\n/tmp/tmp9hrvsli7/test_name_conflict.c:42:32: note: to match this '('\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                                ^\n/tmp/tmp9hrvsli7/test_name_conflict.c:42:58: error: expected ']'\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                                                          ^\n/tmp/tmp9hrvsli7/test_name_conflict.c:42:25: note: to match this '['\n   42 |             v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) * 8;\n      |                         ^\n/tmp/tmp9hrvsli7/test_name_conflict.c:45:49: error: invalid operands to binary expression\n('int' and 'unsigned long long *') 45 |                 pthread_create((char\n*)v1 + 0x8 * v4, NULL, work, NULL); | ~~~ ^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_zlog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44]\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), v1);\n  a0[v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvmc6x1h6/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpvmc6x1h6/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[v1]; | ~~~~~~~^\n/tmp/tmpvmc6x1h6/sgets_name_conflict.c:17:52: note: forward declaration of 'struct struct_0'\n   17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3myo7o_1/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp3myo7o_1/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp3myo7o_1/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp3myo7o_1/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp3myo7o_1/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp3myo7o_1/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp3myo7o_1/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  struct struct_0 **v0; // [bp-0x50]\n  unsigned int v1;      // [bp-0x44]\n  unsigned int v2;      // [bp-0x2c]\n  char *v3;             // [bp-0x28]\n  unsigned long v4;     // [bp-0x20]\n  unsigned long v5;     // [bp-0x10]\n  unsigned long v7;     // rbx\n\n  v5 = v7;\n  v1 = a1;\n  v0 = a2;\n  if (!*(a2))\n    return 0;\n  v4 = strchr(*(a2), 10);\n  v3 = &*(a2)->field_0;\n  if (!v4) {\n    if (*(v3))\n      v4 = &v3[strlen(v3)];\n    else\n      return 0;\n  }\n  v2 = (unsigned int)v4 + 1 - (unsigned int)v3;\n  if (v1 > v2)\n    v1 = v2;\n  memcpy(a0, *(a2), v1);\n  a0[v1] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[v1];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpov_ud9lu/sgets_name_conflict.c:33:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     v3 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpov_ud9lu/sgets_name_conflict.c:49:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 49 |         *(a2) = &(*(a2))[v1]; | ~~~~~~~^\n/tmp/tmpov_ud9lu/sgets_name_conflict.c:17:52: note: forward declaration of 'struct struct_0'\n   17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9nolhzh9/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp9nolhzh9/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp9nolhzh9/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp9nolhzh9/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp9nolhzh9/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp9nolhzh9/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp9nolhzh9/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  unsigned int v0;  // [bp-0x44]\n  unsigned int v1;  // [bp-0x2c]\n  char *v2;         // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x10]\n  unsigned long v6; // rbx\n\n  v4 = v6;\n  v0 = a1;\n  if (!*(a2))\n    return 0;\n  v3 = strchr(*(a2), 10);\n  v2 = &*(a2)->field_0;\n  if (!v3) {\n    if (*(v2))\n      v3 = &v2[strlen(v2)];\n    else\n      return 0;\n  }\n  v1 = (unsigned int)v3 + 1 - (unsigned int)v2;\n  if (v0 > v1)\n    v0 = v1;\n  memcpy(a0, *(a2), v0);\n  a0[v0] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[v0];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6kt989rd/sgets_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v2 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp6kt989rd/sgets_name_conflict.c:47:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 47 |         *(a2) = &(*(a2))[v0]; | ~~~~~~~^\n/tmp/tmp6kt989rd/sgets_name_conflict.c:17:52: note: forward declaration of 'struct struct_0'\n   17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj76vjous/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpj76vjous/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpj76vjous/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpj76vjous/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpj76vjous/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpj76vjous/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpj76vjous/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpj76vjous/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpj76vjous/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpj76vjous/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpj76vjous/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpj76vjous/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpj76vjous/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpj76vjous/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpj76vjous/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpj76vjous/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpj76vjous/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpj76vjous/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpj76vjous/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpj76vjous/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpj76vjous/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpj76vjous/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2) {\n  unsigned int v0;  // [bp-0x44]\n  unsigned int v1;  // [bp-0x2c]\n  char *v2;         // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x10]\n  unsigned long v6; // rbx\n\n  v4 = v6;\n  v0 = a1;\n  if (!*(a2))\n    return 0;\n  v3 = strchr(*(a2), 10);\n  v2 = &*(a2)->field_0;\n  if (!v3) {\n    if (*(v2))\n      v3 = &v2[strlen(v2)];\n    else\n      return 0;\n  }\n  v1 = (unsigned int)v3 + 1 - (unsigned int)v2;\n  if (v0 > v1)\n    v0 = v1;\n  memcpy(a0, *(a2), v0);\n  a0[v0] = 0;\n  if (strlen(*(a2)) == strlen(a0))\n    *(a2) = 0;\n  else\n    *(a2) = &(*(a2))[v0];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5x08km14/sgets_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v2 = &*(a2)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmp5x08km14/sgets_name_conflict.c:47:25: error: subscript of pointer to\nincomplete type 'struct struct_0' 47 |         *(a2) = &(*(a2))[v0]; | ~~~~~~~^\n/tmp/tmp5x08km14/sgets_name_conflict.c:17:52: note: forward declaration of 'struct struct_0'\n   17 | long long sgets_name_conflict(char *a0, unsigned long a1, struct struct_0 **a2)\n      |                                                    ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(zc_time)(long long, long long);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3, unsigned long a4, unsigned long a5) {\n  char v0;           // [bp-0xf8]\n  unsigned int v1;   // [bp-0xd8]\n  unsigned int v2;   // [bp-0xd4]\n  unsigned long v3;  // [bp-0xd0]\n  unsigned long v4;  // [bp-0xc8]\n  void *v5;          // [bp-0xc0], Other Possible Types: unsigned long\n  char v6;           // [bp-0xb8]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  char v18;          // al\n  int v19;           // xmm0\n  int v20;           // xmm1\n  int v21;           // xmm2\n  int v22;           // xmm3\n  int v23;           // xmm4\n  int v24;           // xmm5\n  int v25;           // xmm6\n  int v26;           // xmm7\n\n  v7 = a4;\n  v8 = a5;\n  if (v18) {\n    v9 = v19;\n    v10 = v20;\n    v11 = v21;\n    v12 = v22;\n    v13 = v23;\n    v14 = v24;\n    v15 = v25;\n    v16 = v26;\n  }\n  v5 = 0;\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v5 = fopen64(error_log.0, \"a\");\n    if (!v5)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v5, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 <= 2) {\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return 0;\n      v5 = fopen64(debug_log.1, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    } else if ((unsigned int)a0 == 1) {\n      if (!error_log.0)\n        return 0;\n      v5 = fopen64(error_log.0, \"a\");\n      if (!v5)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v5, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v17;\n  v4 = &v6;\n  vfprintf(v5, a3, &v1);\n  fputc(10, v5);\n  fclose(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphe3jke6q/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:107:6: error: conflicting types for 'fputc'\n  107 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmphe3jke6q/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmphe3jke6q/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmphe3jke6q/zc_profile_inner.c:246:19: error: expected ')'\n  246 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:246:8: note: to match this '('\n  246 |     if (!init_flag.2)\n      |        ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:248:18: error: expected ';' after expression\n  248 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmphe3jke6q/zc_profile_inner.c:248:21: error: expression is not assignable\n  248 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmphe3jke6q/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmphe3jke6q/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m;    // add global variable by heuristics\nint work; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nchar *(pthread_create)(char *, char *, char *, char *);\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                // [bp-0x71]\n  unsigned long long *v1; // [bp-0x60]\n  unsigned long v2;       // [bp-0x58]\n  unsigned int v3;        // [bp-0x4c]\n  unsigned long long *v4; // [bp-0x48], Other Possible Types: unsigned long\n  void *v5;               // [bp-0x40], Other Possible Types: unsigned long\n  unsigned long v7;       // rdx\n\n  v5 = 0;\n  while (true) {\n    if (v5 < a0) {\n      v3 = fork();\n      if (v3 < 0) {\n        puts(\"fork fail\");\n      } else if (!v3) {\n        v2 = a1 - 1;\n        v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) / m 16] >> 3) * 8;\n        for (v4 = 0; v4 < a1; v4 = (char *)v4 + 1) {\n          pthread_create((char *)v1 + 0x8 * v4, NULL, work, NULL);\n        }\n        for (v4 = 0; v4 < a1; v4 = (char *)v4 + 1) {\n          v7 = v4;\n          pthread_join(v1[v7], 0, v7);\n        }\n        return 0;\n      }\n      v5 += 1;\n    } else {\n      for (v5 = 0; v5 < a0; v5 += 1) {\n        v3 = wait(NULL);\n      }\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgmttcrhh/test_name_conflict.c:45:39: error: expected ')'\n   45 |                 v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) *\n8; |                                       ^ /tmp/tmpgmttcrhh/test_name_conflict.c:45:36:\nnote: to match this '(' 45 |                 v1 = (&(&v0)[-16 * (0 CONCAT 15 +\na1 * 8) /m 16] >> 3) * 8; |                                    ^\n/tmp/tmpgmttcrhh/test_name_conflict.c:45:62: error: expected ']'\n   45 |                 v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) *\n8; |                                                              ^\n/tmp/tmpgmttcrhh/test_name_conflict.c:45:29: note: to match this '['\n   45 |                 v1 = (&(&v0)[-16 * (0 CONCAT 15 + a1 * 8) /m 16] >> 3) *\n8; |                             ^ /tmp/tmpgmttcrhh/test_name_conflict.c:48:53: error: invalid\noperands to binary expression ('int' and 'unsigned long long *') 48 |\npthread_create((char *)v1 + 0x8 * v4, NULL, work, NULL); | ~~~ ^ ~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  char field_4;\n  char field_5;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .3;\nextern unsigned int arp_sock;\nextern struct_0 buf.4;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_garp(unsigned long a0, unsigned long a1, void *a2,\n                    unsigned long a3, void *a4) {\n  timeval v0;             // [bp-0x48]\n  char v1;                // [bp-0x40]\n  char v2;                // [bp-0x38]\n  unsigned short v3;      // [bp-0x36]\n  unsigned int v4;        // [bp-0x34]\n  char v5;                // [bp-0x2d]\n  char v6;                // [bp-0x2c]\n  unsigned int *v7;       // [bp-0x18]\n  struct_0 *v8;           // [bp-0x10]\n  unsigned long long v13; // rax\n\n  v8 = &buf.4.field_0;\n  v7 = &v8[1].field_0;\n  v8->field_0 = htons(1);\n  v8->field_2 = htons(0x800);\n  v8->field_4 = 6;\n  v8->field_5 = 4;\n  v8->field_6 = htons(2);\n  memcpy(v7, a2, 6);\n  v7 = (char *)&v7[1] + 2;\n  *(v7) = a1;\n  v7 = (char *)v7 + 1;\n  memcpy(v7, a4, 6);\n  v7 = (char *)&v7[1] + 2;\n  *(v7) = a3;\n  v7 = (char *)v7 + 1;\n  memset(&v2, 0, 20);\n  v3 = htons(2054);\n  v4 = a0;\n  v5 = 6;\n  memset(&v6, 255, 6);\n  if (sendto(arp_sock, &buf.4.field_0, v7 - &buf.4.field_0, 0, &v2, 20) >= 0)\n    return 0;\n  if (foreground) {\n    gettimeofday(&v0, NULL);\n    (unsigned int)v13 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .3, (unsigned int)a0, (unsigned int)v13);\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\");\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptgbjqt3d/send_garp.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.3;\n      |             ^\n/tmp/tmptgbjqt3d/send_garp.c:47:20: error: expected ';' after top level\ndeclarator 47 | extern struct_0 buf.4; |                    ^ | ;\n/tmp/tmptgbjqt3d/send_garp.c:49:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 49 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmptgbjqt3d/send_garp.c:49:22: error: expected ';' after top level\ndeclarator 49 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmptgbjqt3d/send_garp.c:64:14: error: expected ';' after expression\n   64 |     v8 = &buf.4.field_0;\n      |              ^\n      |              ;\n/tmp/tmptgbjqt3d/send_garp.c:64:16: error: invalid suffix '.field_0' on floating\nconstant 64 |     v8 = &buf.4.field_0; |                ^\n/tmp/tmptgbjqt3d/send_garp.c:84:30: error: expected ')'\n   84 |     if (sendto(arp_sock, &buf.4.field_0, v7 - &buf.4.field_0, 0, &v2,\n20) >= 0) |                              ^ /tmp/tmptgbjqt3d/send_garp.c:84:15:\nnote: to match this '(' 84 |     if (sendto(arp_sock, &buf.4.field_0, v7 -\n&buf.4.field_0, 0, &v2, 20) >= 0) |               ^\n/tmp/tmptgbjqt3d/send_garp.c:89:38: error: indirection requires pointer operand\n('int' invalid) 89 |         (unsigned int)v13 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptgbjqt3d/send_garp.c:90:23: error: expected ')'\n   90 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)v13); |                       ^\n/tmp/tmptgbjqt3d/send_garp.c:90:16: note: to match this '('\n   90 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)v13); |                ^\n/tmp/tmptgbjqt3d/send_garp.c:94:18: error: indirection requires pointer operand\n('int' invalid) 94 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nunsigned short(htons)(unsigned short);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct struct_0 {\n  char padding_0[2];\n  unsigned short field_2;\n  char field_4;\n  char field_5;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[6];\n  unsigned int field_6;\n  char padding_a[6];\n  unsigned int field_10;\n} struct_1;\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern unsigned int arp_sock;\nextern struct_0 buf.2;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_arp(unsigned int *a0, unsigned short *a1, unsigned short *a2,\n                   unsigned int *a3, void *a4, unsigned int *a5, void *v11) {\n  timeval v0;             // [bp-0x78]\n  char v1;                // [bp-0x70]\n  timeval v2;             // [bp-0x68]\n  char v3;                // [bp-0x60]\n  unsigned int v4;        // [bp-0x4c]\n  sockaddr v5;            // [bp-0x48]\n  char v6;                // [bp-0x44]\n  char v7;                // [bp-0x3e]\n  unsigned int v8;        // [bp-0x2c]\n  struct_1 *v9;           // [bp-0x28]\n  struct_0 *v10;          // [bp-0x20]\n  unsigned long long v14; // rax\n\n  v4 = 20;\n  v10 = &buf.2.padding_0 [0];\n  v9 = &v10[1];\n  v8 = recvfrom(arp_sock, &buf.2.padding_0 [0], 0x400, 64, &v5, &v4);\n  if (v8 < 0) {\n    if (foreground) {\n      gettimeofday(&v2, NULL);\n      (unsigned int)v14 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .1, (unsigned int)v14);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    if (v8 > 7 && (v10->field_6 == htons(1) || v10->field_6 == htons(2)) &&\n        v10->field_5 == 4 && v10->field_2 == htons(0x800) &&\n        v10->field_4 == 6 && v8 > 27) {\n      *(a0) = *((int *)&v6);\n      *(a1) = v7;\n      *(a2) = ntohs(v10->field_6);\n      memcpy(a4, v9, 6);\n      *(a3) = *((int *)&(&v9->padding_0)[1]);\n      memcpy(v11, (char *)&v9->field_6 + 2, 6);\n      *(a5) = *((int *)&v9->padding_a[4]);\n      return 0;\n    }\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\");\n    } else {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid message\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1);\n    }\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy1o55dfu/recv_arp.c:58:13: error: expected identifier or '('\n   58 | extern char __func__.1;\n      |             ^\n/tmp/tmpy1o55dfu/recv_arp.c:60:20: error: expected ';' after top level\ndeclarator 60 | extern struct_0 buf.2; |                    ^ | ;\n/tmp/tmpy1o55dfu/recv_arp.c:62:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 62 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpy1o55dfu/recv_arp.c:62:22: error: expected ';' after top level\ndeclarator 62 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpy1o55dfu/recv_arp.c:80:15: error: expected ';' after expression\n   80 |     v10 = &buf.2.padding_0[0];\n      |               ^\n      |               ;\n/tmp/tmpy1o55dfu/recv_arp.c:80:17: error: invalid suffix '.padding_0' on\nfloating constant 80 |     v10 = &buf.2.padding_0[0]; |                 ^\n/tmp/tmpy1o55dfu/recv_arp.c:82:33: error: expected ')'\n   82 |     v8 = recvfrom(arp_sock, &buf.2.padding_0[0], 0x400, 64, &v5, &v4);\n      |                                 ^\n/tmp/tmpy1o55dfu/recv_arp.c:82:18: note: to match this '('\n   82 |     v8 = recvfrom(arp_sock, &buf.2.padding_0[0], 0x400, 64, &v5, &v4);\n      |                  ^\n/tmp/tmpy1o55dfu/recv_arp.c:88:42: error: indirection requires pointer operand\n('int' invalid) 88 |             (unsigned int)v14 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpy1o55dfu/recv_arp.c:89:27: error: expected ')'\n   89 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v14); |                           ^\n/tmp/tmpy1o55dfu/recv_arp.c:89:20: note: to match this '('\n   89 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v14); |                    ^ /tmp/tmpy1o55dfu/recv_arp.c:93:22:\nerror: indirection requires pointer operand ('int' invalid) 93 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpy1o55dfu/recv_arp.c:118:27: error: expected ')'\n  118 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nmessage\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                           ^ /tmp/tmpy1o55dfu/recv_arp.c:118:20:\nnote: to match this '(' 118 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid message\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.1); |                    ^ 11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(socket)(int, int, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int arp_sock;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_arp_name_conflict() {\n  timeval v0;            // [bp-0x18]\n  char v1;               // [bp-0x10]\n  unsigned long long v6; // rax\n\n  arp_sock = socket(17, 2, htons(2054));\n  if (arp_sock >= 0)\n    return arp_sock;\n  if (foreground) {\n    gettimeofday(&v0, NULL);\n    (unsigned int)v6 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)v6);\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvcms3mx7/open_arp_name_conflict.c:34:13: error: expected identifier or '('\n   34 | extern char __func__.0;\n      |             ^\n/tmp/tmpvcms3mx7/open_arp_name_conflict.c:37:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 37 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpvcms3mx7/open_arp_name_conflict.c:37:22: error: expected ';' after top level\ndeclarator 37 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpvcms3mx7/open_arp_name_conflict.c:51:37: error: indirection requires pointer operand\n('int' invalid) 51 |         (unsigned int)v6 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvcms3mx7/open_arp_name_conflict.c:52:23: error: expected ')'\n   52 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)v6); |                       ^ /tmp/tmpvcms3mx7/open_arp_name_conflict.c:52:16:\nnote: to match this '(' 52 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: socket %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)v6); |                ^\n/tmp/tmpvcms3mx7/open_arp_name_conflict.c:56:18: error: indirection requires pointer operand\n('int' invalid) 56 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nint(setsockopt)(int, int, int, void *, int);\nint(close)(int);\nunsigned short(htons)(unsigned short);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(ip2str)(long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .4;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long fill_if_addrs_name_conflict(unsigned int a0[7]) {\n  timeval v0;             // [bp-0xd8]\n  char v1;                // [bp-0xd0]\n  timeval v2;             // [bp-0xc8]\n  char v3;                // [bp-0xc0]\n  timeval v4;             // [bp-0xb8]\n  char v5;                // [bp-0xb0]\n  timeval v6;             // [bp-0xa8]\n  char v7;                // [bp-0xa0]\n  timeval v8;             // [bp-0x98]\n  char v9;                // [bp-0x90]\n  timeval v10;            // [bp-0x88]\n  char v11;               // [bp-0x80]\n  timeval v12;            // [bp-0x78]\n  char v13;               // [bp-0x70]\n  unsigned int v14;       // [bp-0x5c]\n  char v15;               // [bp-0x58], Other Possible Types: unsigned short\n  unsigned short v16;     // [bp-0x56]\n  unsigned int v17;       // [bp-0x54]\n  char v18;               // [bp-0x48]\n  unsigned int v19;       // [bp-0x38]\n  unsigned int v20;       // [bp-0x20]\n  unsigned int v21;       // [bp-0x1c]\n  unsigned long long v25; // rax\n  unsigned long long v28; // rax\n  unsigned long long v31; // rax\n  unsigned long long v34; // rax\n  unsigned long long v37; // rax\n  unsigned long long v40; // rax\n\n  v21 = -1;\n  v20 = socket(2, 2, 0);\n  if (v20 >= 0) {\n    memset(&v18, 0, 40);\n    v19 = a0[6];\n    if (!ioctl(v20, 35088)) {\n      if (!ioctl(v20, 35111)) {\n        if ((short)v19 == 1) {\n          if (setsockopt(v20, 1, 25, &v18, (unsigned int)strlen(&v18) + 1) >=\n              0) {\n            memset(&v15, 0, 16);\n            v15 = 2;\n            v16 = htons(1025);\n            v17 = a0[0];\n            if (connect(v20, &v15, 16) >= 0) {\n              v14 = 16;\n              if (getsockname(v20, &v15, &v14) >= 0) {\n                v21 = 0;\n                memcpy(&a0[4], &v19, 6);\n                a0[3] = v17;\n              } else {\n                if (foreground) {\n                  gettimeofday(&v0, NULL);\n                  (unsigned int)v40 = strerror(*(__errno_location()));\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"%ld.%06ld [error] %s: getsockname %s %s\\n\",\n                          (int)*((long long *)&v0.tv_sec),\n                          (int)*((long long *)&v1), &__func__ .4,\n                          (unsigned int)&v18, (unsigned int)v40);\n                } else {\n                  strerror(*(__errno_location()));\n                  syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                            \"getsockname %s %s\\\"}\");\n                }\n              }\n            } else {\n              if (!foreground) {\n                strerror(*(__errno_location()));\n                ip2str(a0[0]);\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to \"\n                          \"%s from %s %s\\\"}\");\n              } else {\n                gettimeofday(&v2, NULL);\n                (unsigned int)v37 = strerror(*(__errno_location()));\n                fprintf(stderr @GLIBC_2.2.5,\n                        \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\",\n                        (int)*((long long *)&v2.tv_sec),\n                        (int)*((long long *)&v3), &__func__ .4,\n                        (int)ip2str(a0[0]), (unsigned int)&v18,\n                        (unsigned int)v40);\n              }\n            }\n          } else if (foreground) {\n            gettimeofday(&v4, NULL);\n            (unsigned int)v34 = strerror(*(__errno_location()));\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: setsockopt %s %s\\n\",\n                    (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                    &__func__ .4, (unsigned int)&v18, (unsigned int)v40);\n          } else {\n            strerror(*(__errno_location()));\n            syslog(\n                3,\n                \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\");\n          }\n        } else {\n          if (!foreground) {\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\");\n          } else {\n            gettimeofday(&v6, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: invalid if %s\\n\",\n                    (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                    &__func__ .4, (unsigned int)&v18);\n          }\n        }\n      } else {\n        if (foreground) {\n          gettimeofday(&v8, NULL);\n          (unsigned int)v31 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\",\n                  (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n                  &__func__ .4, (unsigned int)&v18, (unsigned int)v40);\n        } else {\n          strerror(*(__errno_location()));\n          syslog(\n              3,\n              \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\");\n        }\n      }\n    } else {\n      if (foreground) {\n        gettimeofday(&v10, NULL);\n        (unsigned int)v28 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\",\n                (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n                &__func__ .4, a0[6], (unsigned int)v40);\n      } else {\n        strerror(*(__errno_location()));\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\");\n      }\n    }\n    close(v20);\n    return v21;\n  } else {\n    if (foreground) {\n      gettimeofday(&v12, NULL);\n      (unsigned int)v25 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket sock %s\\n\",\n              (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n              &__func__ .4, (unsigned int)v25);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\");\n    }\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.4;\n      |             ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:47:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 47 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:47:22: error: expected ';' after top level\ndeclarator 47 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:112:66: error: indirection requires pointer\noperand ('int' invalid) 112 |                                     (unsigned\nint)v40 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:113:51: error: expected ')'\n  113 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: getsockname %s %s\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, (unsigned int)&v18, (unsigned int)v40);\n      |                                                   ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:113:44: note: to match this '('\n  113 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: getsockname %s %s\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, (unsigned int)&v18, (unsigned int)v40);\n      |                                            ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:117:46: error: indirection requires pointer\noperand ('int' invalid) 117 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:126:42: error:\nindirection requires pointer operand ('int' invalid) 126 |\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:133:62: error: indirection requires pointer\noperand ('int' invalid) 133 |                                 (unsigned int)v37\n= strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:134:47: error: expected ')'\n  134 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: connect to %s from %s %s\\n\", (int)*((long long *)&v2.tv_sec),\n(int)*((long long *)&v3), &__func__.4, (int)ip2str(a0[0]), (unsigned int)&v18,\n(unsigned int)v40); |                                               ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:134:40: note: to match this '('\n  134 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: connect to %s from %s %s\\n\", (int)*((long long *)&v2.tv_sec),\n(int)*((long long *)&v3), &__func__.4, (int)ip2str(a0[0]), (unsigned int)&v18,\n(unsigned int)v40); |                                        ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:141:54: error: indirection requires pointer\noperand ('int' invalid) 141 |                         (unsigned int)v34 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:142:39: error: expected ')'\n  142 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: setsockopt %s %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:142:32: note: to match this '('\n  142 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: setsockopt %s %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:146:34: error: indirection requires pointer\noperand ('int' invalid) 146 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:159:39: error: expected\n')' 159 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid if %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.4, (unsigned int)&v18); |                                       ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:159:32: note: to match this '('\n  159 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid if %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.4, (unsigned int)&v18); |                                ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:168:50: error: indirection requires pointer\noperand ('int' invalid) 168 |                     (unsigned int)v31 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:169:35: error: expected ')'\n  169 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFHWADDR %s %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long\n*)&v9), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:169:28: note: to match this '('\n  169 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFHWADDR %s %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long\n*)&v9), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:173:30: error: indirection requires pointer\noperand ('int' invalid) 173 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:183:46: error:\nindirection requires pointer operand ('int' invalid) 183 | (unsigned int)v28 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:184:31: error: expected ')'\n  184 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFNAME %d %s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long\n*)&v11), &__func__.4, a0[6], (unsigned int)v40); | ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:184:24: note: to match this '('\n  184 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFNAME %d %s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long\n*)&v11), &__func__.4, a0[6], (unsigned int)v40); |                        ^\n/tmp/tmpiqzi893_/fill_if_addrs_name_conflict.c:188:26: error: indirection requires pointer\noperand ('int' invalid) 188 |                 strerror(*(__errno_location()));\n      |                          ^~~~~~~~~~~~~~~~~~~~~\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\nvoid(syslog)(int, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong long(fill_if_addrs)(long long);\nchar *(strerror)(int);\nlong long(update_mpgw)(long long, long long);\nvoid(srandom)(unsigned int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern char g_40a14c;\nextern char g_40a158;\nextern char g_40a15c;\nextern char g_40a160;\nextern char g_40a168;\nextern char g_40a170;\nextern char g_40a178;\nextern char mpgws;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long add_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x50], Other Possible Types: unsigned long\n  timeval v1;             // [bp-0x48]\n  char v2;                // [bp-0x40]\n  timeval v3;             // [bp-0x38]\n  char v4;                // [bp-0x30]\n  char v5;                // [bp-0x28]\n  char v6;                // [bp-0x20]\n  unsigned int v7;        // [bp-0x10]\n  unsigned int v8;        // [bp-0xc]\n  unsigned long long v17; // rax\n  void *v18;              // rax, Other Possible Types: unsigned long\n  unsigned long long v21; // rax\n  unsigned long long v23[529454]; // rsi\n  unsigned long long v25[529456]; // rsi\n\n  v0 = a1;\n  v7 = -1;\n  for (v8 = 0; v8 <= 31; v8 += 1) {\n    if (!*((int *)&(&g_40a15c)[72 * v8])) {\n      if (v7 == -1)\n        v7 = v8;\n    } else {\n      if ((unsigned int)a0 == *((int *)&(&mpgws)[72 * v8]) &&\n          v0 == *((int *)&(&g_40a158)[72 * v8])) {\n        v18 = &(&mpgws)[72 * v8];\n        return v18;\n      }\n    }\n  }\n  if (v7 == -1) {\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\");\n    } else {\n      gettimeofday(&v3, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: not enough memory\\n\",\n              (int)*((long long *)&v3.tv_sec), (int)*((long long *)&v4),\n              &__func__ .0);\n    }\n    return 0;\n  } else if ((unsigned int)clock_gettime(0x1, &v5) < 0) {\n    if (foreground) {\n      gettimeofday(&v1, NULL);\n      (unsigned int)v21 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v1.tv_sec), (int)*((long long *)&v2),\n              &__func__ .0, (unsigned int)v21);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n    }\n    return 0;\n  } else {\n    memset(&(&mpgws)[72 * v7], 0, 72);\n    *((unsigned int *)&(&mpgws)[72 * v7]) = a0;\n    *((int *)&(&g_40a158)[72 * v7]) = v0;\n    v17 = v7;\n    if ((int)fill_if_addrs(&(&mpgws)[64 * v17 + 8 * v17]) < 0)\n      return 0;\n    v23 = 9 * v7 * 8;\n    *((long long *)(v23 + &g_40a160)) = *((long long *)&v5);\n    *((long long *)(v23 + &g_40a168)) = *((long long *)&v6);\n    v25 = 9 * v7 * 8;\n    *((long long *)(v25 + &g_40a170)) = *((long long *)&v5);\n    *((long long *)(v25 + &g_40a178)) = *((long long *)&v6);\n    update_mpgw(&(&mpgws)[72 * v7], 1);\n    srandom(*((int *)&(&g_40a14c)[72 * v7]));\n    v18 = &(&mpgws)[72 * v7];\n    return v18;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:36:13: error: expected identifier or '('\n   36 | extern char __func__.0;\n      |             ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:46:22: error: expected ';' after top level\ndeclarator 46 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:92:27: error: expected ')'\n   92 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: not\nenough memory\\n\", (int)*((long long *)&v3.tv_sec), (int)*((long long *)&v4),\n&__func__.0); |                           ^ /tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:92:20:\nnote: to match this '(' 92 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: not enough memory\\n\", (int)*((long long *)&v3.tv_sec), (int)*((long\nlong *)&v4), &__func__.0); |                    ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:101:42: error: indirection requires pointer operand\n('int' invalid) 101 |             (unsigned int)v21 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:102:27: error: expected ')'\n  102 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v1.tv_sec), (int)*((long long *)&v2),\n&__func__.0, (unsigned int)v21); |                           ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:102:20: note: to match this '('\n  102 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v1.tv_sec), (int)*((long long *)&v2),\n&__func__.0, (unsigned int)v21); |                    ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:106:22: error: indirection requires pointer operand\n('int' invalid) 106 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:119:13: error: array type\n'unsigned long long[529454]' is not assignable 119 |         v23 = 9 * v7 * 8;\n      |         ~~~ ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:120:29: error: invalid operands to binary expression\n('unsigned long long[529454]' and 'char *') 120 |         *((long long *)(v23 +\n&g_40a160)) = *((long long *)&v5); |                         ~~~ ^ ~~~~~~~~~\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:121:29: error: invalid operands to binary expression\n('unsigned long long[529454]' and 'char *') 121 |         *((long long *)(v23 +\n&g_40a168)) = *((long long *)&v6); |                         ~~~ ^ ~~~~~~~~~\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:122:13: error: array type 'unsigned long\nlong[529456]' is not assignable 122 |         v25 = 9 * v7 * 8; |         ~~~ ^\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:123:29: error: invalid operands to binary expression\n('unsigned long long[529456]' and 'char *') 123 |         *((long long *)(v25 +\n&g_40a170)) = *((long long *)&v5); |                         ~~~ ^ ~~~~~~~~~\n/tmp/tmpg_vrn8ey/add_mpgw_name_conflict.c:124:29: error: invalid operands to binary expression\n('unsigned long long[529456]' and 'char *') 124 |         *((long long *)(v25 +\n&g_40a178)) = *((long long *)&v6); |                         ~~~ ^ ~~~~~~~~~ 13\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_40a158;\nextern char g_40a15c;\nextern char mpgws;\n\nlong long find_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 0; v0 <= 31; v0 += 1) {\n    if (*((int *)&(&g_40a15c)[72 * v0]) &&\n        (unsigned int)a0 == *((int *)&(&mpgws)[72 * v0]) &&\n        (unsigned int)a1 == *((int *)&(&g_40a158)[72 * v0]))\n      return &(&mpgws)[72 * v0];\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ip2str)(long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long update_mpgw_name_conflict(unsigned int a0[17], unsigned long a1) {\n  timeval v0;            // [bp-0x28]\n  char v1;               // [bp-0x20]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v6; // rax\n  unsigned long long v7; // rax\n\n  v2 = v4;\n  if (a0[7] == (unsigned int)a1)\n    return 0;\n  if (!foreground) {\n    ip2str(a0[0]);\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\");\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state %d\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            (int)ip2str(a0[0]), a0[6], (unsigned int)a1);\n  }\n  a0[7] = a1;\n  if (a0[7] == 1) {\n    v6 = random();\n    a0[16] = (unsigned int)(v6 - ((v6 * 2361183241434822607 >> 64 >> 7) -\n                                  (v6 >> 63)) *\n                                     1000) +\n             1010;\n  } else {\n    v7 = random();\n    a0[16] = (unsigned int)(v7 - ((v7 * 5037190915060954895 >> 64 >> 13) -\n                                  (v7 >> 63)) *\n                                     30000) +\n             60000;\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp37cb168a/update_mpgw_name_conflict.c:34:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 34 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp37cb168a/update_mpgw_name_conflict.c:34:22: error: expected ';' after top level\ndeclarator 34 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp37cb168a/update_mpgw_name_conflict.c:56:23: error: expected ')'\n   56 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n(int)ip2str(a0[0]), a0[6], (unsigned int)a1); |                       ^\n/tmp/tmp37cb168a/update_mpgw_name_conflict.c:56:16: note: to match this '('\n   56 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n(int)ip2str(a0[0]), a0[6], (unsigned int)a1); |                ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rta_find_name_conflict(unsigned short a0[2], unsigned long a1, unsigned long a2) {\n  unsigned int v0;      // [bp-0x24]\n  unsigned short v1[2]; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a1;\n  for (*(&v1) = a0;\n       v0 > 3 && *((short *)v1) << 48 > 0x3000000000000 && v0 >= *((short *)v1);\n       v1 += *((short *)v1) + 3 & 0xfffffffc) {\n    if ((unsigned int)a2 != *((short *)(v1 + 2)))\n      v0 -= *((short *)v1) + 3 & 0xfffffffc;\n    else\n      return v1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6hto0frb/rta_find_name_conflict.c:23:17: error: array type 'unsigned short[2]' is not\nassignable 23 |     for (*(&v1) = a0; v0 > 3 && *((short *)v1) << 48 >\n0x3000000000000 && v0 >= *((short *)v1); v1 += *((short *)v1) + 3 & 0xfffffffc)\n      |          ~~~~~~ ^\n/tmp/tmp6hto0frb/rta_find_name_conflict.c:23:100: error: invalid operands to binary expression\n('unsigned short[2]' and 'unsigned int') 23 |     for (*(&v1) = a0; v0 > 3 &&\n*((short *)v1) << 48 > 0x3000000000000 && v0 >= *((short *)v1); v1 += *((short\n*)v1) + 3 & 0xfffffffc) | ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(syslog)(int, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong long(rta_find)(long long, long long, long long);\nlong long(add_mpgw)(long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_0;\n\nextern char __func__ .4;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long process_rt_name_conflict(unsigned int *a0) {\n  timeval v0;      // [bp-0x58]\n  char v1;         // [bp-0x50]\n  timeval v2;      // [bp-0x48]\n  char v3;         // [bp-0x40]\n  unsigned int v4; // [bp-0x2c]\n  struct_0 *v5;    // [bp-0x28]\n  char v6[7];      // [bp-0x20]\n  struct_0 *v7;    // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v8; // [bp-0xc]\n\n  *((unsigned int **)&v6) = a0 + 4;\n  v8 = *(a0)-28;\n  if (v8 < 0) {\n    if (!foreground) {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\");\n    } else {\n      gettimeofday(&v2, NULL);\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .4, v8);\n    }\n    return 4294967295;\n  } else {\n    if (!(v6[0] == 2 && v6[6] <= 252))\n      return 0;\n    v5 = rta_find(&v6[1 + 5], v8, 9);\n    if (!v5)\n      return 0;\n    v8 = v5->field_0 - 4;\n    v7 = &v5->field_4;\n    while (true) {\n      if (!(v8 > 7) || !(v8 >= *((short *)v7)))\n        return 0;\n      v5 = rta_find(v7 + 8, *((short *)v7) - 8, 5);\n      if (!v5)\n        break;\n      v4 = v5->field_4;\n      if (!add_mpgw(v4, *((int *)(v7 + 4))))\n        return 4294967295;\n      v8 -= *((short *)v7) + 3 & 0xfffffffc;\n      v7 += *((short *)v7) + 3 & 0xfffffffc;\n    }\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [error] %s: no gateway in nh info\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .4);\n    } else {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\");\n    }\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk5oxe5fw/process_rt_name_conflict.c:39:13: error: expected identifier or '('\n   39 | extern char __func__.4;\n      |             ^\n/tmp/tmpk5oxe5fw/process_rt_name_conflict.c:41:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 41 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpk5oxe5fw/process_rt_name_conflict.c:41:22: error: expected ';' after top level\ndeclarator 41 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpk5oxe5fw/process_rt_name_conflict.c:66:27: error: expected ')'\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nnlmsg_len %d\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.4, v8); |                           ^\n/tmp/tmpk5oxe5fw/process_rt_name_conflict.c:66:20: note: to match this '('\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nnlmsg_len %d\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.4, v8); |                    ^ /tmp/tmpk5oxe5fw/process_rt_name_conflict.c:95:27:\nerror: expected ')' 95 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: no gateway in nh info\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4); |                           ^\n/tmp/tmpk5oxe5fw/process_rt_name_conflict.c:95:20: note: to match this '('\n   95 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: no\ngateway in nh info\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                    ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(reset_mpgws)();\nlong(send)(int, void *, unsigned long, int);\nlong(recv)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(process_rt)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char padding_6[2];\n  unsigned int field_8;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .3;\nextern unsigned int foreground;\nextern struct_0 recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long get_nhs_name_conflict() {\n  timeval v0;             // [bp-0xa8]\n  char v1;                // [bp-0xa0]\n  timeval v2;             // [bp-0x98]\n  char v3;                // [bp-0x90]\n  timeval v4;             // [bp-0x88]\n  char v5;                // [bp-0x80]\n  timeval v6;             // [bp-0x78]\n  char v7;                // [bp-0x70]\n  timeval v8;             // [bp-0x68]\n  char v9;                // [bp-0x60]\n  timeval v10;            // [bp-0x58]\n  char v11;               // [bp-0x50]\n  timeval v12;            // [bp-0x48]\n  char v13;               // [bp-0x40]\n  unsigned int v14;       // [bp-0x38], Other Possible Types: char\n  unsigned short v15;     // [bp-0x34]\n  unsigned short v16;     // [bp-0x32]\n  unsigned int v17;       // [bp-0x30]\n  unsigned int v18;       // [bp-0x2c]\n  char v19;               // [bp-0x28]\n  unsigned int v20;       // [bp-0x24]\n  unsigned int *v21;      // [bp-0x20]\n  struct_0 *v22;          // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v23;       // [bp-0xc]\n  char v24;               // [bp-0x8]\n  unsigned long long v26; // rbp\n  unsigned long long v31; // rax\n  unsigned long long v34; // rax\n\n  v26 = &v24;\n  reset_mpgws();\n  memset(&v14, 0, 20);\n  v14 = 20;\n  v15 = 26;\n  v16 = 257;\n  v18 = 0;\n  talk_seq = talk_seq + 1;\n  v17 = talk_seq;\n  v19 = 2;\n  if (send(talk_sock, &v14, 20, 0) < 0) {\n    if (foreground) {\n      gettimeofday(&v12, NULL);\n      (unsigned int)v31 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n              (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n              &__func__ .3, (unsigned int)v31);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    while (true) {\n      v23 = recv(talk_sock, &recv_buf.field_0, 0x4000, 0);\n      if (v23 >= 0) {\n        if (!v23) {\n          if (foreground) {\n            gettimeofday(&v8, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                    (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n                    &__func__ .3);\n          } else {\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n          }\n          return 4294967295;\n        }\n        for (v22 = &recv_buf.field_0;\n             v23 > 15 && v22->field_0 > 15 && v23 >= v22->field_0;\n             v22 = (char *)v22 + (v22->field_0 + 3 & -0x4)) {\n          if (v22->field_8 != talk_seq) {\n            if (!foreground) {\n              syslog(\n                  3,\n                  \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\");\n            } else {\n              gettimeofday(&v6, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                      (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                      &__func__ .3, v22->field_8);\n            }\n          } else {\n            if (v22->field_4 == 3)\n              return 0;\n            if (v22->field_4 == 2) {\n              v21 = v22 + 16;\n              if (*((int *)v22) <= 35) {\n                if (!foreground) {\n                  syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg \"\n                            \"truncated\\\"}\");\n                } else {\n                  gettimeofday(&v4, NULL);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                          (int)*((long long *)&v4.tv_sec),\n                          (int)*((long long *)&v5), &__func__ .3);\n                }\n                v20 = -1;\n              } else {\n                if (*(v21)) {\n                  if (foreground) {\n                    gettimeofday(&v2, NULL);\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                            (int)*((long long *)&v2.tv_sec),\n                            (int)*((long long *)&v3), &__func__ .3,\n                            (unsigned int)strerror(-(*(v21))));\n                  } else {\n                    strerror(-(*(v21)));\n                    syslog(\n                        3,\n                        \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n                  }\n                  v20 = -1;\n                }\n              }\n              v20 = 0;\n              return 4294967295;\n            } else {\n              if (v22->field_4 != 24) {\n                if (foreground) {\n                  gettimeofday(&v0, NULL);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                          (int)*((long long *)&v0.tv_sec),\n                          (int)*((long long *)&v1), &__func__ .3, v22->field_4);\n                } else {\n                  syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid \"\n                            \"type %d\\\"}\");\n                }\n              } else {\n                if ((int)process_rt(v22) < 0)\n                  return 4294967295;\n              }\n            }\n          }\n          v23 -= v22->field_0 + 3 & -0x4;\n        }\n      } else if (*(__errno_location()) != 4 && *(__errno_location()) != 11) {\n        if (foreground) {\n          gettimeofday(&v10, NULL);\n          (unsigned int)v34 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n                  (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n                  &__func__ .3, (unsigned int)v34);\n        } else {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n        }\n        return 4294967295;\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:43:13: error: expected identifier or '('\n   43 | extern char __func__.3;\n      |             ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:46:22: error: expected ';' after top level declarator\n   46 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:96:42: error: indirection requires pointer operand\n('int' invalid) 96 |             (unsigned int)v31 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:97:27: error: expected ')'\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13), &__func__.3,\n(unsigned int)v31); |                           ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:97:20: note: to match this '('\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13), &__func__.3,\n(unsigned int)v31); |                    ^ /tmp/tmp3ee70rie/get_nhs_name_conflict.c:101:22:\nerror: indirection requires pointer operand ('int' invalid) 101 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:118:39: error: expected ')'\n  118 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: recv len == 0\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.3); |                                       ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:118:32: note: to match this '('\n  118 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: recv len == 0\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.3); |                                ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:137:43: error: expected ')'\n  137 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long\nlong *)&v7), &__func__.3, v22->field_8); | ^ /tmp/tmp3ee70rie/get_nhs_name_conflict.c:137:36:\nnote: to match this '(' 137 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.3, v22->field_8); |                                    ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:156:51: error: expected ')'\n  156 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v4.tv_sec),\n(int)*((long long *)&v5), &__func__.3); | ^ /tmp/tmp3ee70rie/get_nhs_name_conflict.c:156:44:\nnote: to match this '(' 156 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nnlerr msg truncated\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.3); |                                            ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:167:55: error: expected ')'\n  167 |                                         fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr %s\\n\", (int)*((long long *)&v2.tv_sec),\n(int)*((long long *)&v3), &__func__.3, (unsigned int)strerror(-(*(v21)))); | ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:167:48: note: to match this '('\n  167 |                                         fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr %s\\n\", (int)*((long long *)&v2.tv_sec),\n(int)*((long long *)&v3), &__func__.3, (unsigned int)strerror(-(*(v21)))); | ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:187:51: error: expected ')'\n  187 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid type %d\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.3, v22->field_4); | ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:187:44: note: to match this '('\n  187 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid type %d\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.3, v22->field_4); | ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:204:22: error: indirection requires pointer operand\n('int' invalid) 204 |             else if (*(__errno_location()) != 4 &&\n*(__errno_location()) != 11) |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:204:52: error: indirection requires pointer operand\n('int' invalid) 204 |             else if (*(__errno_location()) != 4 &&\n*(__errno_location()) != 11) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:209:50: error: indirection requires pointer operand\n('int' invalid) 209 |                     (unsigned int)v34 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:210:35: error: expected ')'\n  210 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n&__func__.3, (unsigned int)v34); |                                   ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:210:28: note: to match this '('\n  210 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n&__func__.3, (unsigned int)v34); |                            ^\n/tmp/tmp3ee70rie/get_nhs_name_conflict.c:214:30: error: indirection requires pointer operand\n('int' invalid) 214 |                     strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 16 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\nlong(recv)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char padding_6[2];\n  unsigned int field_8;\n} struct_0;\n\nextern char __func__ .2;\nextern unsigned int foreground;\nextern struct_0 recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long update_neigh(unsigned long a0, unsigned long a1, void *a2,\n                       unsigned long a3) {\n  timeval v0;             // [bp-0xd8]\n  char v1;                // [bp-0xd0]\n  timeval v2;             // [bp-0xc8]\n  char v3;                // [bp-0xc0]\n  timeval v4;             // [bp-0xb8]\n  char v5;                // [bp-0xb0]\n  timeval v6;             // [bp-0xa8]\n  char v7;                // [bp-0xa0]\n  timeval v8;             // [bp-0x98]\n  char v9;                // [bp-0x90]\n  timeval v10;            // [bp-0x88]\n  char v11;               // [bp-0x80]\n  timeval v12;            // [bp-0x78]\n  char v13;               // [bp-0x70]\n  timeval v14;            // [bp-0x68]\n  char v15;               // [bp-0x60]\n  char v16;               // [bp-0x58], Other Possible Types: unsigned int\n  unsigned short v17;     // [bp-0x54]\n  unsigned short v18;     // [bp-0x52]\n  unsigned int v19;       // [bp-0x50]\n  char v20;               // [bp-0x48]\n  unsigned int v21;       // [bp-0x44]\n  unsigned short v22;     // [bp-0x40]\n  unsigned short v23;     // [bp-0x3c]\n  unsigned short v24;     // [bp-0x3a]\n  unsigned int v25;       // [bp-0x38]\n  unsigned short v26;     // [bp-0x34]\n  unsigned short v27;     // [bp-0x32]\n  char v28;               // [bp-0x30]\n  unsigned int v29;       // [bp-0x24]\n  unsigned int *v30;      // [bp-0x20]\n  struct_0 *v31;          // [bp-0x18]\n  unsigned int v32;       // [bp-0xc]\n  unsigned long long v39; // rax\n  unsigned long long v42; // rax\n\n  memset(&v16, 0, 48);\n  v16 = 48;\n  v17 = 28;\n  talk_seq = talk_seq + 1;\n  v19 = talk_seq;\n  v18 = 1285;\n  v20 = 2;\n  v21 = a0;\n  *((int *)&v22) = (!(unsigned int)a3 ? 2 : 32);\n  v23 = 8;\n  v24 = 1;\n  v25 = a1;\n  v26 = 10;\n  v27 = 2;\n  memcpy(&v28, a2, 6);\n  if (send(talk_sock, &v16, 48, 0) < 0) {\n    if (foreground) {\n      gettimeofday(&v14, NULL);\n      (unsigned int)v39 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n              (int)*((long long *)&v14.tv_sec), (int)*((long long *)&v15),\n              &__func__ .2, (unsigned int)v39);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    while (true) {\n      v32 = recv(talk_sock, &recv_buf.field_0, 0x4000, 0);\n      if (v32 >= 0)\n        break;\n      if (*(__errno_location()) != 4 && *(__errno_location()) != 11) {\n        if (!foreground) {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n        } else {\n          gettimeofday(&v12, NULL);\n          (unsigned int)v42 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n                  (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n                  &__func__ .2, (unsigned int)v42);\n        }\n        return 4294967295;\n      }\n    }\n    if (!v32) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n      } else {\n        gettimeofday(&v10, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n                &__func__ .2);\n      }\n      return 4294967295;\n    } else {\n      v31 = &recv_buf.field_0;\n      if (!(v32 > 15) || !(v31->field_0 > 15) || !(v32 >= v31->field_0)) {\n        if (foreground) {\n          gettimeofday(&v8, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid len %d\\n\",\n                  (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n                  &__func__ .2, v32);\n        } else {\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\");\n        }\n        return 4294967295;\n      } else if (v31->field_8 != talk_seq) {\n        if (foreground) {\n          gettimeofday(&v6, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                  (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                  &__func__ .2, v31->field_8);\n        } else {\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\");\n        }\n        return 4294967295;\n      } else if (v31->field_4 != 2) {\n        if (!foreground) {\n          syslog(3,\n                 \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\");\n        } else {\n          gettimeofday(&v4, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                  (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                  &__func__ .2, v31->field_4);\n        }\n        return 4294967295;\n      } else {\n        v30 = &v31[1].field_4;\n        if (v31->field_0 <= 35) {\n          if (!foreground) {\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg \"\n                      \"truncated\\\"}\");\n          } else {\n            gettimeofday(&v2, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                    (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                    &__func__ .2);\n          }\n          v29 = -1;\n        } else if (*(v30)) {\n          if (!foreground) {\n            strerror(-(*(v30)));\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n          } else {\n            gettimeofday(&v0, NULL);\n            fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                    (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                    &__func__ .2, (unsigned int)strerror(-(*(v30))));\n          }\n          v29 = -1;\n        }\n      }\n    }\n    v29 = 0;\n    return v29;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_j_125ku/update_neigh.c:41:13: error: expected identifier or '('\n   41 | extern char __func__.2;\n      |             ^\n/tmp/tmp_j_125ku/update_neigh.c:44:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 44 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp_j_125ku/update_neigh.c:44:22: error: expected ';' after top level\ndeclarator 44 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp_j_125ku/update_neigh.c:106:42: error: indirection requires pointer\noperand ('int' invalid) 106 |             (unsigned int)v39 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_j_125ku/update_neigh.c:107:27: error: expected ')'\n  107 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v14.tv_sec), (int)*((long long *)&v15), &__func__.2,\n(unsigned int)v39); |                           ^\n/tmp/tmp_j_125ku/update_neigh.c:107:20: note: to match this '('\n  107 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v14.tv_sec), (int)*((long long *)&v15), &__func__.2,\n(unsigned int)v39); |                    ^\n/tmp/tmp_j_125ku/update_neigh.c:111:22: error: indirection requires pointer\noperand ('int' invalid) 111 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp_j_125ku/update_neigh.c:123:17: error: indirection\nrequires pointer operand ('int' invalid) 123 |             if\n(*(__errno_location()) != 4 && *(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp_j_125ku/update_neigh.c:123:47: error: indirection\nrequires pointer operand ('int' invalid) 123 |             if\n(*(__errno_location()) != 4 && *(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp_j_125ku/update_neigh.c:127:30: error: indirection\nrequires pointer operand ('int' invalid) 127 | strerror(*(__errno_location()));\n      |                              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_j_125ku/update_neigh.c:133:50: error: indirection requires pointer\noperand ('int' invalid) 133 |                     (unsigned int)v42 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_j_125ku/update_neigh.c:134:35: error: expected ')'\n  134 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n&__func__.2, (unsigned int)v42); |                                   ^\n/tmp/tmp_j_125ku/update_neigh.c:134:28: note: to match this '('\n  134 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n&__func__.2, (unsigned int)v42); |                            ^\n/tmp/tmp_j_125ku/update_neigh.c:148:31: error: expected ')'\n  148 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n&__func__.2); |                               ^\n/tmp/tmp_j_125ku/update_neigh.c:148:24: note: to match this '('\n  148 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n&__func__.2); |                        ^ /tmp/tmp_j_125ku/update_neigh.c:160:35:\nerror: expected ')' 160 |                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid len %d\\n\", (int)*((long long *)&v8.tv_sec),\n(int)*((long long *)&v9), &__func__.2, v32); | ^\n/tmp/tmp_j_125ku/update_neigh.c:160:28: note: to match this '('\n  160 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid len %d\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.2, v32); |                            ^\n/tmp/tmp_j_125ku/update_neigh.c:173:35: error: expected ')'\n  173 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.2, v31->field_8); |                                   ^\n/tmp/tmp_j_125ku/update_neigh.c:173:28: note: to match this '('\n  173 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.2, v31->field_8); |                            ^\n/tmp/tmp_j_125ku/update_neigh.c:190:35: error: expected ')'\n  190 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.2, v31->field_4); |                                   ^\n/tmp/tmp_j_125ku/update_neigh.c:190:28: note: to match this '('\n  190 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.2, v31->field_4); |                            ^\n/tmp/tmp_j_125ku/update_neigh.c:206:39: error: expected ')'\n  206 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr msg truncated\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.2); |                                       ^\n/tmp/tmp_j_125ku/update_neigh.c:206:32: note: to match this '('\n  206 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr msg truncated\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.2); |                                ^\n/tmp/tmp_j_125ku/update_neigh.c:220:39: error: expected ')'\n  220 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(-(*(v30)))); | ^\n/tmp/tmp_j_125ku/update_neigh.c:220:32: note: to match this '('\n  220 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(-(*(v30)))); | ^ 17 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(get_nhs)();\nvoid(syslog)(int, char *, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern void recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_nl_name_conflict() {\n  timeval v0;             // [bp-0x38]\n  char v1;                // [bp-0x30]\n  timeval v2;             // [bp-0x28]\n  char v3;                // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  sockaddr v5;            // [bp-0x14]\n  char v6;                // [bp-0x10]\n  unsigned long long v11; // rax\n\n  v4 = 12;\n  if (recvfrom(poll_sock, &recv_buf, 0x4000, 64, &v5, &v4) < 0) {\n    if (foreground) {\n      gettimeofday(&v2, NULL);\n      (unsigned int)v11 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .1, (unsigned int)v11);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    }\n    return 0;\n  } else if (v4 != 12) {\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\");\n    } else {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1);\n    }\n    return 0;\n  } else if (!*((int *)&v6)) {\n    get_nhs();\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:42:13: error: expected identifier or '('\n   42 | extern char __func__.1;\n      |             ^\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:46:22: error: expected ';' after top level declarator\n   46 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:65:42: error: indirection requires pointer operand\n('int' invalid) 65 |             (unsigned int)v11 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:66:27: error: expected ')'\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v11); |                           ^\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:66:20: note: to match this '('\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v11); |                    ^ /tmp/tmp5izdt7mk/recv_nl_name_conflict.c:70:22:\nerror: indirection requires pointer operand ('int' invalid) 70 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5izdt7mk/recv_nl_name_conflict.c:84:27: error: expected ')'\n   84 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\naddr len\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                           ^ /tmp/tmp5izdt7mk/recv_nl_name_conflict.c:84:20:\nnote: to match this '(' 84 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid addr len\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.1); |                    ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\nint(close)(int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(get_nhs)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long open_nl_name_conflict() {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  timeval v2;             // [bp-0x58]\n  char v3;                // [bp-0x50]\n  timeval v4;             // [bp-0x48]\n  char v5;                // [bp-0x40]\n  timeval v6;             // [bp-0x38]\n  char v7;                // [bp-0x30]\n  timeval v8;             // [bp-0x28]\n  char v9;                // [bp-0x20]\n  unsigned int v10;       // [bp-0x18]\n  unsigned short v11;     // [bp-0x14], Other Possible Types: char\n  unsigned int v12;       // [bp-0xc]\n  unsigned long long v16; // rax\n  unsigned long long v19; // rax\n  unsigned long long v22; // rax\n  unsigned long long v25; // rax\n  unsigned long long v29; // rax\n\n  v10 = 12;\n  memset(&v11, 0, 12);\n  v11 = 16;\n  talk_sock = socket(16, 3, 0);\n  if (talk_sock >= 0) {\n    if (connect(talk_sock, &v11, 12) < 0) {\n      if (foreground) {\n        gettimeofday(&v6, NULL);\n        (unsigned int)v19 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: connect talk_sock %s\\n\",\n                (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                &__func__ .0, (unsigned int)v19);\n      } else {\n        strerror(*(__errno_location()));\n        syslog(\n            3,\n            \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\");\n      }\n    } else {\n      if (getsockname(talk_sock, &v11, &v10) < 0) {\n        if (foreground) {\n          gettimeofday(&v4, NULL);\n          (unsigned int)v22 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\",\n                  (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                  &__func__ .0, (unsigned int)v22);\n        } else {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname \"\n                    \"talk_sock %s\\\"}\");\n        }\n      } else {\n        talk_seq = random();\n        memset(&v11, 0, 12);\n        v11 = 16;\n        v12 = 64;\n        poll_sock = socket(16, 3, 0);\n        if (poll_sock < 0) {\n          if (foreground) {\n            gettimeofday(&v2, NULL);\n            (unsigned int)v25 = strerror(*(__errno_location()));\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: socket poll_sock %s\\n\",\n                    (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                    &__func__ .0, (unsigned int)v25);\n          } else {\n            strerror(*(__errno_location()));\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock \"\n                      \"%s\\\"}\");\n          }\n        } else {\n          if (bind(poll_sock, &v11, 12) < 0) {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              (unsigned int)v29 = strerror(*(__errno_location()));\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: bind poll_sock %s\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .0, (unsigned int)v29);\n            } else {\n              strerror(*(__errno_location()));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock \"\n                        \"%s\\\"}\");\n            }\n          } else {\n            if ((int)get_nhs() >= 0)\n              return poll_sock;\n          }\n          close(poll_sock);\n        }\n      }\n    }\n    close(talk_sock);\n  } else if (foreground) {\n    gettimeofday(&v8, NULL);\n    (unsigned int)v16 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\",\n            (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n            &__func__ .0, (unsigned int)v16);\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\");\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:48:13: error: expected identifier or '('\n   48 | extern char __func__.0;\n      |             ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:51:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:51:22: error: expected ';' after top level declarator\n   51 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:87:46: error: indirection requires pointer operand\n('int' invalid) 87 |                 (unsigned int)v19 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:88:31: error: expected ')'\n   88 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nconnect talk_sock %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long\n*)&v7), &__func__.0, (unsigned int)v19); |                               ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:88:24: note: to match this '('\n   88 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nconnect talk_sock %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long\n*)&v7), &__func__.0, (unsigned int)v19); |                        ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:92:26: error: indirection requires pointer operand\n('int' invalid) 92 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpqokpwa8c/open_nl_name_conflict.c:103:50: error: indirection\nrequires pointer operand ('int' invalid) 103 |                     (unsigned\nint)v22 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:104:35: error: expected ')'\n  104 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ngetsockname talk_sock %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.0, (unsigned int)v22); |                                   ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:104:28: note: to match this '('\n  104 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ngetsockname talk_sock %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.0, (unsigned int)v22); |                            ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:108:30: error: indirection requires pointer operand\n('int' invalid) 108 |                     strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpqokpwa8c/open_nl_name_conflict.c:124:54: error: indirection\nrequires pointer operand ('int' invalid) 124 |                         (unsigned\nint)v25 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:125:39: error: expected ')'\n  125 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: socket poll_sock %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v25); | ^ /tmp/tmpqokpwa8c/open_nl_name_conflict.c:125:32:\nnote: to match this '(' 125 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsocket poll_sock %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v25); |                                ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:129:34: error: indirection requires pointer operand\n('int' invalid) 129 |                         strerror(*(__errno_location()));\n      |                                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:140:58: error: indirection requires pointer operand\n('int' invalid) 140 |                             (unsigned int)v29 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:141:43: error: expected ')'\n  141 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)v29); | ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:141:36: note: to match this '('\n  141 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)v29); | ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:145:38: error: indirection requires pointer operand\n('int' invalid) 145 | strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:163:38: error: indirection requires pointer operand\n('int' invalid) 163 |         (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:164:23: error: expected ')'\n  164 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.0, (unsigned int)v16); |                       ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:164:16: note: to match this '('\n  164 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.0, (unsigned int)v16); |                ^\n/tmp/tmpqokpwa8c/open_nl_name_conflict.c:168:18: error: indirection requires pointer operand\n('int' invalid) 168 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 18 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\n\nlong long in_cksum_name_conflict(char *a0, unsigned long a1) {\n  char *v0;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v2; // r12d\n  void *v3;        // rbx, Other Possible Types: unsigned long\n  char *v4;        // rax\n\n  v2 = a1;\n  v3 = 0;\n  for (v0 = a0; v2 > 1; v2 -= 2) {\n    v4 = v0;\n    v0 = v4 + 2;\n    v3 += *((short *)&v4);\n  }\n  if (v2 == 1) {\n    v3 += htons(*((char *)v0) * 0x100);\n    return ~((unsigned int)((v3 >> 16) + (unsigned short)v3 +\n                            ((v3 >> 16) + (unsigned short)v3 >> 16)));\n  }\n  return ~((unsigned int)((v3 >> 16) + (unsigned short)v3 +\n                          ((v3 >> 16) + (unsigned short)v3 >> 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0dj1rlei/in_cksum_name_conflict.c:36:37: error: invalid operands to binary expression\n('void *' and 'int') 36 |         return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~\n/tmp/tmp0dj1rlei/in_cksum_name_conflict.c:36:72: error: invalid operands to binary expression\n('void *' and 'int') 36 |         return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~\n/tmp/tmp0dj1rlei/in_cksum_name_conflict.c:38:33: error: invalid operands to binary expression\n('void *' and 'int') 38 |     return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~\n/tmp/tmp0dj1rlei/in_cksum_name_conflict.c:38:68: error: invalid operands to binary expression\n('void *' and 'int') 38 |     return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(in_cksum)(long long, long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(ip2str)(long long);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  unsigned short field_2;\n  unsigned short field_4;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .6;\nextern struct_0 buf.10;\nextern unsigned int foreground;\nextern unsigned int g_4050e4;\nextern unsigned int g_405110;\nextern unsigned long long msg.7;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_ping_name_conflict(unsigned long a0, unsigned long long a1) {\n  timeval v0;            // [bp-0x38]\n  char v1;               // [bp-0x30]\n  unsigned int *v2;      // [bp-0x28]\n  struct_0 *v3;          // [bp-0x20]\n  unsigned long long v5; // rdx\n  unsigned long long v9; // rax\n\n  v3 = &buf.10.field_0;\n  v2 = &v3[1].field_0;\n  g_4050e4 = a1;\n  g_405110 = a0;\n  v3->field_0 = 8;\n  v3->field_1 = 0;\n  v3->field_4 = ping_id;\n  v3->field_6 = 0;\n  v3->field_2 = 0;\n  v5 = a0;\n  *(v2) = a0;\n  strncpy(v2 + 1, \"WGPM\", 4);\n  v3->field_2 = in_cksum(&buf.10.field_0, 16);\n  if (sendmsg(ping_sock, &msg.7, 4, &msg.7) >= 0)\n    return 0;\n  if (!foreground) {\n    strerror(*(__errno_location()));\n    ::0x401800 ::ip2str(a1);\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\");\n  } else {\n    gettimeofday(&v0, NULL);\n    (unsigned int)v9 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .6, (unsigned int)a0, (int)::0x401800 ::ip2str(a1),\n            (unsigned int)v9);\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:42:13: error: expected identifier or '('\n   42 | extern char __func__.6;\n      |             ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:43:20: error: expected ';' after top level\ndeclarator 43 | extern struct_0 buf.10; |                    ^ | ;\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:47:30: error: expected ';' after top level\ndeclarator 47 | extern unsigned long long msg.7; | ^ | ;\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:50:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 50 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:50:22: error: expected ';' after top level\ndeclarator 50 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:61:14: error: expected ';' after expression\n   61 |     v3 = &buf.10.field_0;\n      |              ^\n      |              ;\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:61:17: error: invalid suffix '.field_0' on floating\nconstant 61 |     v3 = &buf.10.field_0; |                 ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:73:32: error: expected ')'\n   73 |     v3->field_2 = in_cksum(&buf.10.field_0, 16);\n      |                                ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:73:27: note: to match this '('\n   73 |     v3->field_2 = in_cksum(&buf.10.field_0, 16);\n      |                           ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:74:32: error: expected ')'\n   74 |     if (sendmsg(ping_sock, &msg.7, 4, &msg.7) >= 0)\n      |                                ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:74:16: note: to match this '('\n   74 |     if (sendmsg(ping_sock, &msg.7, 4, &msg.7) >= 0)\n      |                ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:78:18: error: indirection requires pointer operand\n('int' invalid) 78 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpr_0glvs9/send_ping_name_conflict.c:79:9: error: expected\nexpression 79 |         ::0x401800::ip2str(a1); |         ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:85:37: error: indirection requires pointer operand\n('int' invalid) 85 |         (unsigned int)v9 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:86:23: error: expected ')'\n   86 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, (int)::0x401800::ip2str(a1), (unsigned int)v9); | ^\n/tmp/tmpr_0glvs9/send_ping_name_conflict.c:86:16: note: to match this '('\n   86 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, (int)::0x401800::ip2str(a1), (unsigned int)v9); | ^ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(in_cksum)(long long, long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  char padding_2[2];\n  unsigned short field_4;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern void buf.3;\nextern unsigned int foreground;\nextern struct_0 g_405214;\nextern unsigned int g_4057e4;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern sockaddr src.2;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_ping_name_conflict(unsigned int *a0, unsigned int *a1) {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  timeval v2;             // [bp-0x58]\n  char v3;                // [bp-0x50]\n  timeval v4;             // [bp-0x48]\n  char v5;                // [bp-0x40]\n  timeval v6;             // [bp-0x38]\n  char v7;                // [bp-0x30]\n  unsigned int v8;        // [bp-0x20]\n  unsigned int v9;        // [bp-0x1c]\n  unsigned int v10[2];    // [bp-0x18]\n  struct_0 *v11;          // [bp-0x10]\n  unsigned long long v16; // rax\n\n  v11 = &g_405214.field_0;\n  *((struct_0 **)&v10[0]) = v11 + 1;\n  v8 = 16;\n  v9 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v8);\n  if (v9 <= 27) {\n    if (foreground) {\n      gettimeofday(&v6, NULL);\n      (unsigned int)v16 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\",\n              (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n              &__func__ .1, v9, (unsigned int)v16);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\");\n    }\n    return 4294967295;\n  } else if (src.2.sin_family != 2) {\n    return 4294967295;\n  } else {\n    if (!(v11->field_4 == ping_id && !v11->field_0 && !v11->field_6 &&\n          !v11->field_1))\n      return 4294967295;\n    if (v9 <= 35) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\");\n      } else {\n        gettimeofday(&v4, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg too small\\n\",\n                (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                &__func__ .1);\n      }\n      return 4294967295;\n    } else if ((short)in_cksum(&buf.3, v9)) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\");\n      } else {\n        gettimeofday(&v2, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: checksum error\\n\",\n                (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                &__func__ .1);\n      }\n      return 4294967295;\n    } else if (v10[1] != 1297106775) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\");\n      } else {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: signature error\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .1);\n      }\n      return 4294967295;\n    } else {\n      *(a0) = v10[0];\n      *(a1) = g_4057e4;\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.1;\n      |             ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:46:16: error: expected ';' after top level\ndeclarator 46 | extern void buf.3; |                ^ |                ;\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:52:8: error: unknown type name 'sockaddr'\n   52 | extern sockaddr src.2;\n      |        ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:52:20: error: expected ';' after top level\ndeclarator 52 | extern sockaddr src.2; |                    ^ | ;\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:53:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 53 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:53:22: error: expected ';' after top level\ndeclarator 53 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:74:34: error: expected ')'\n   74 |     v9 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v8);\n      |                                  ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:74:18: note: to match this '('\n   74 |     v9 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v8);\n      |                  ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:80:42: error: indirection requires pointer operand\n('int' invalid) 80 |             (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:81:27: error: expected ')'\n   81 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg\nlen %d %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.1, v9, (unsigned int)v16); |                           ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:81:20: note: to match this '('\n   81 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg\nlen %d %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.1, v9, (unsigned int)v16); |                    ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:85:22: error: indirection requires pointer operand\n('int' invalid) 85 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpqtpnuynz/recv_ping_name_conflict.c:90:17: error: expected ')' 90\n|     else if (src.2.sin_family != 2) |                 ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:90:13: note: to match this '('\n   90 |     else if (src.2.sin_family != 2)\n      |             ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:107:31: error: expected ')'\n  107 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.1); |                               ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:107:24: note: to match this '('\n  107 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.1); |                        ^ /tmp/tmpqtpnuynz/recv_ping_name_conflict.c:111:38:\nerror: expected ')' 111 |         else if ((short)in_cksum(&buf.3, v9)) | ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:111:33: note: to match this '('\n  111 |         else if ((short)in_cksum(&buf.3, v9))\n      |                                 ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:120:31: error: expected ')'\n  120 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.1); |                               ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:120:24: note: to match this '('\n  120 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.1); |                        ^ /tmp/tmpqtpnuynz/recv_ping_name_conflict.c:133:31:\nerror: expected ')' 133 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: signature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.1); |                               ^\n/tmp/tmpqtpnuynz/recv_ping_name_conflict.c:133:24: note: to match this '('\n  133 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsignature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                        ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(setsockopt)(int, int, int, void *, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nunsigned short(htons)(unsigned short);\nint(close)(int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_ping_name_conflict() {\n  timeval v0;             // [bp-0x48]\n  char v1;                // [bp-0x40]\n  timeval v2;             // [bp-0x38]\n  char v3;                // [bp-0x30]\n  timeval v4;             // [bp-0x28]\n  char v5;                // [bp-0x20]\n  unsigned int v6;        // [bp-0xc]\n  unsigned long long v10; // rax\n  unsigned long long v13; // rax\n  unsigned long long v16; // rax\n\n  v6 = 1;\n  ping_sock = socket(2, 3, 1);\n  if (ping_sock < 0) {\n    if (foreground) {\n      gettimeofday(&v4, NULL);\n      (unsigned int)v10 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n              (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n              &__func__ .0, (unsigned int)v10);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    if (setsockopt(ping_sock, 0, 2, &v6, 4) >= 0) {\n      if (setsockopt(ping_sock, 0, 8, &v6, 4) >= 0) {\n        ping_id = htons(getpid());\n        return ping_sock;\n      }\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        (unsigned int)v16 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)v16);\n      } else {\n        strerror(*(__errno_location()));\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt \"\n                  \"IP_PKTINFO %s\\\"}\");\n      }\n    } else if (foreground) {\n      gettimeofday(&v2, NULL);\n      (unsigned int)v13 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .0, (unsigned int)v13);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\");\n    }\n    close(ping_sock);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:36:13: error: expected identifier or '('\n   36 | extern char __func__.0;\n      |             ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:40:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 40 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:40:22: error: expected ';' after top level\ndeclarator 40 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:62:42: error: indirection requires pointer operand\n('int' invalid) 62 |             (unsigned int)v10 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:63:27: error: expected ')'\n   63 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\n%s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5), &__func__.0,\n(unsigned int)v10); |                           ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:63:20: note: to match this '('\n   63 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\n%s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5), &__func__.0,\n(unsigned int)v10); |                    ^ /tmp/tmpdihp9gfc/open_ping_name_conflict.c:67:22:\nerror: indirection requires pointer operand ('int' invalid) 67 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:84:46: error: indirection requires pointer operand\n('int' invalid) 84 |                 (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:85:31: error: expected ')'\n   85 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)v16); |                               ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:85:24: note: to match this '('\n   85 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)v16); |                        ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:89:26: error: indirection requires pointer operand\n('int' invalid) 89 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpdihp9gfc/open_ping_name_conflict.c:96:42: error: indirection\nrequires pointer operand ('int' invalid) 96 |             (unsigned int)v13 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:97:27: error: expected ')'\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v13); |                           ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:97:20: note: to match this '('\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v13); |                    ^\n/tmp/tmpdihp9gfc/open_ping_name_conflict.c:101:22: error: indirection requires pointer operand\n('int' invalid) 101 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  char field_4;\n  char field_5;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .3;\nextern unsigned int arp_sock;\nextern struct_0 buf.4;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_garp(unsigned long a0, unsigned long a1, void *a2,\n                    unsigned long a3, void *a4) {\n  timeval v0;             // [bp-0x48]\n  char v1;                // [bp-0x40]\n  char v2;                // [bp-0x38]\n  unsigned short v3;      // [bp-0x36]\n  unsigned int v4;        // [bp-0x34]\n  char v5;                // [bp-0x2d]\n  char v6;                // [bp-0x2c]\n  unsigned int *v7;       // [bp-0x18]\n  struct_0 *v8;           // [bp-0x10]\n  unsigned long long v13; // rax\n\n  v8 = &buf.4.field_0;\n  v7 = &v8[1].field_0;\n  v8->field_0 = htons(1);\n  v8->field_2 = htons(0x800);\n  v8->field_4 = 6;\n  v8->field_5 = 4;\n  v8->field_6 = htons(2);\n  memcpy(v7, a2, 6);\n  v7 = (char *)&v7[1] + 2;\n  *(v7) = a1;\n  v7 = (char *)v7 + 1;\n  memcpy(v7, a4, 6);\n  v7 = (char *)&v7[1] + 2;\n  *(v7) = a3;\n  v7 = (char *)v7 + 1;\n  memset(&v2, 0, 20);\n  v3 = htons(2054);\n  v4 = a0;\n  v5 = 6;\n  memset(&v6, 255, 6);\n  if (sendto(arp_sock, &buf.4.field_0, v7 - &buf.4.field_0, 0, &v2, 20) >= 0)\n    return 0;\n  if (foreground) {\n    gettimeofday(&v0, NULL);\n    (unsigned int)v13 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .3, (unsigned int)a0, (unsigned int)v13);\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\");\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps4gdapgv/send_garp.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.3;\n      |             ^\n/tmp/tmps4gdapgv/send_garp.c:47:20: error: expected ';' after top level\ndeclarator 47 | extern struct_0 buf.4; |                    ^ | ;\n/tmp/tmps4gdapgv/send_garp.c:49:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 49 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmps4gdapgv/send_garp.c:49:22: error: expected ';' after top level\ndeclarator 49 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmps4gdapgv/send_garp.c:64:14: error: expected ';' after expression\n   64 |     v8 = &buf.4.field_0;\n      |              ^\n      |              ;\n/tmp/tmps4gdapgv/send_garp.c:64:16: error: invalid suffix '.field_0' on floating\nconstant 64 |     v8 = &buf.4.field_0; |                ^\n/tmp/tmps4gdapgv/send_garp.c:84:30: error: expected ')'\n   84 |     if (sendto(arp_sock, &buf.4.field_0, v7 - &buf.4.field_0, 0, &v2,\n20) >= 0) |                              ^ /tmp/tmps4gdapgv/send_garp.c:84:15:\nnote: to match this '(' 84 |     if (sendto(arp_sock, &buf.4.field_0, v7 -\n&buf.4.field_0, 0, &v2, 20) >= 0) |               ^\n/tmp/tmps4gdapgv/send_garp.c:89:38: error: indirection requires pointer operand\n('int' invalid) 89 |         (unsigned int)v13 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmps4gdapgv/send_garp.c:90:23: error: expected ')'\n   90 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)v13); |                       ^\n/tmp/tmps4gdapgv/send_garp.c:90:16: note: to match this '('\n   90 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)v13); |                ^\n/tmp/tmps4gdapgv/send_garp.c:94:18: error: indirection requires pointer operand\n('int' invalid) 94 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nunsigned short(htons)(unsigned short);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct struct_1 {\n  char padding_0[2];\n  unsigned short field_2;\n  char field_4;\n  char field_5;\n  unsigned short field_6;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[6];\n  unsigned int field_6;\n  char padding_a[6];\n  unsigned int field_10;\n} struct_0;\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern unsigned int arp_sock;\nextern struct_1 buf.2;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_arp(unsigned int *a0, unsigned short *a1, unsigned short *a2,\n                   unsigned int *a3, void *a4, unsigned int *a5, void *v11) {\n  timeval v0;             // [bp-0x78]\n  char v1;                // [bp-0x70]\n  timeval v2;             // [bp-0x68]\n  char v3;                // [bp-0x60]\n  unsigned int v4;        // [bp-0x4c]\n  sockaddr v5;            // [bp-0x48]\n  char v6;                // [bp-0x44]\n  char v7;                // [bp-0x3e]\n  unsigned int v8;        // [bp-0x2c]\n  struct_0 *v9;           // [bp-0x28]\n  struct_1 *v10;          // [bp-0x20]\n  unsigned long long v14; // rax\n\n  v4 = 20;\n  v10 = &buf.2.padding_0 [0];\n  v9 = &v10[1];\n  v8 = recvfrom(arp_sock, &buf.2.padding_0 [0], 0x400, 64, &v5, &v4);\n  if (v8 < 0) {\n    if (foreground) {\n      gettimeofday(&v2, NULL);\n      (unsigned int)v14 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .1, (unsigned int)v14);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    if (v8 > 7 && (v10->field_6 == htons(1) || v10->field_6 == htons(2)) &&\n        v10->field_5 == 4 && v10->field_2 == htons(0x800) &&\n        v10->field_4 == 6 && v8 > 27) {\n      *(a0) = *((int *)&v6);\n      *(a1) = v7;\n      *(a2) = ntohs(v10->field_6);\n      memcpy(a4, v9, 6);\n      *(a3) = *((int *)&(&v9->padding_0)[1]);\n      memcpy(v11, (char *)&v9->field_6 + 2, 6);\n      *(a5) = *((int *)&v9->padding_a[4]);\n      return 0;\n    }\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\");\n    } else {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid message\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1);\n    }\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkqihn7s3/recv_arp.c:58:13: error: expected identifier or '('\n   58 | extern char __func__.1;\n      |             ^\n/tmp/tmpkqihn7s3/recv_arp.c:60:20: error: expected ';' after top level\ndeclarator 60 | extern struct_1 buf.2; |                    ^ | ;\n/tmp/tmpkqihn7s3/recv_arp.c:62:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 62 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpkqihn7s3/recv_arp.c:62:22: error: expected ';' after top level\ndeclarator 62 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpkqihn7s3/recv_arp.c:80:15: error: expected ';' after expression\n   80 |     v10 = &buf.2.padding_0[0];\n      |               ^\n      |               ;\n/tmp/tmpkqihn7s3/recv_arp.c:80:17: error: invalid suffix '.padding_0' on\nfloating constant 80 |     v10 = &buf.2.padding_0[0]; |                 ^\n/tmp/tmpkqihn7s3/recv_arp.c:82:33: error: expected ')'\n   82 |     v8 = recvfrom(arp_sock, &buf.2.padding_0[0], 0x400, 64, &v5, &v4);\n      |                                 ^\n/tmp/tmpkqihn7s3/recv_arp.c:82:18: note: to match this '('\n   82 |     v8 = recvfrom(arp_sock, &buf.2.padding_0[0], 0x400, 64, &v5, &v4);\n      |                  ^\n/tmp/tmpkqihn7s3/recv_arp.c:88:42: error: indirection requires pointer operand\n('int' invalid) 88 |             (unsigned int)v14 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkqihn7s3/recv_arp.c:89:27: error: expected ')'\n   89 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v14); |                           ^\n/tmp/tmpkqihn7s3/recv_arp.c:89:20: note: to match this '('\n   89 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v14); |                    ^ /tmp/tmpkqihn7s3/recv_arp.c:93:22:\nerror: indirection requires pointer operand ('int' invalid) 93 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkqihn7s3/recv_arp.c:118:27: error: expected ')'\n  118 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nmessage\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                           ^ /tmp/tmpkqihn7s3/recv_arp.c:118:20:\nnote: to match this '(' 118 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid message\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.1); |                    ^ 11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(socket)(int, int, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int arp_sock;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_arp_name_conflict() {\n  timeval v0;            // [bp-0x18]\n  char v1;               // [bp-0x10]\n  unsigned long long v6; // rax\n\n  arp_sock = socket(17, 2, htons(2054));\n  if (arp_sock >= 0)\n    return arp_sock;\n  if (foreground) {\n    gettimeofday(&v0, NULL);\n    (unsigned int)v6 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)v6);\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcxveplmf/open_arp_name_conflict.c:34:13: error: expected identifier or '('\n   34 | extern char __func__.0;\n      |             ^\n/tmp/tmpcxveplmf/open_arp_name_conflict.c:37:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 37 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpcxveplmf/open_arp_name_conflict.c:37:22: error: expected ';' after top level\ndeclarator 37 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpcxveplmf/open_arp_name_conflict.c:51:37: error: indirection requires pointer operand\n('int' invalid) 51 |         (unsigned int)v6 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcxveplmf/open_arp_name_conflict.c:52:23: error: expected ')'\n   52 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)v6); |                       ^ /tmp/tmpcxveplmf/open_arp_name_conflict.c:52:16:\nnote: to match this '(' 52 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: socket %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)v6); |                ^\n/tmp/tmpcxveplmf/open_arp_name_conflict.c:56:18: error: indirection requires pointer operand\n('int' invalid) 56 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\n\nlong long in_cksum_name_conflict(char *a0, unsigned long a1) {\n  char *v0;        // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v2; // r12d\n  void *v3;        // rbx, Other Possible Types: unsigned long\n  char *v4;        // rax\n\n  v2 = a1;\n  v3 = 0;\n  for (v0 = a0; v2 > 1; v2 -= 2) {\n    v4 = v0;\n    v0 = v4 + 2;\n    v3 += *((short *)&v4);\n  }\n  if (v2 == 1) {\n    v3 += htons(*((char *)v0) * 0x100);\n    return ~((unsigned int)((v3 >> 16) + (unsigned short)v3 +\n                            ((v3 >> 16) + (unsigned short)v3 >> 16)));\n  }\n  return ~((unsigned int)((v3 >> 16) + (unsigned short)v3 +\n                          ((v3 >> 16) + (unsigned short)v3 >> 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbmod4p5v/in_cksum_name_conflict.c:36:37: error: invalid operands to binary expression\n('void *' and 'int') 36 |         return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~\n/tmp/tmpbmod4p5v/in_cksum_name_conflict.c:36:72: error: invalid operands to binary expression\n('void *' and 'int') 36 |         return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~\n/tmp/tmpbmod4p5v/in_cksum_name_conflict.c:38:33: error: invalid operands to binary expression\n('void *' and 'int') 38 |     return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~\n/tmp/tmpbmod4p5v/in_cksum_name_conflict.c:38:68: error: invalid operands to binary expression\n('void *' and 'int') 38 |     return ~((unsigned int)((v3 >> 16) + (unsigned\nshort)v3 + ((v3 >> 16) + (unsigned short)v3 >> 16))); | ~~ ^  ~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(in_cksum)(long long, long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(ip2str)(long long);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  unsigned short field_2;\n  unsigned short field_4;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .6;\nextern struct_0 buf.10;\nextern unsigned int foreground;\nextern unsigned int g_409144;\nextern unsigned int g_409170;\nextern unsigned long long msg.7;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_ping_name_conflict(unsigned long a0, unsigned long long a1) {\n  timeval v0;            // [bp-0x38]\n  char v1;               // [bp-0x30]\n  unsigned int *v2;      // [bp-0x28]\n  struct_0 *v3;          // [bp-0x20]\n  unsigned long long v5; // rdx\n  unsigned long long v9; // rax\n\n  v3 = &buf.10.field_0;\n  v2 = &v3[1].field_0;\n  g_409144 = a1;\n  g_409170 = a0;\n  v3->field_0 = 8;\n  v3->field_1 = 0;\n  v3->field_4 = ping_id;\n  v3->field_6 = 0;\n  v3->field_2 = 0;\n  v5 = a0;\n  *(v2) = a0;\n  strncpy(v2 + 1, \"WGPM\", 4);\n  v3->field_2 = in_cksum(&buf.10.field_0, 16);\n  if (sendmsg(ping_sock, &msg.7, 4, &msg.7) >= 0)\n    return 0;\n  if (!foreground) {\n    strerror(*(__errno_location()));\n    ::0x403941 ::ip2str(a1);\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\");\n  } else {\n    gettimeofday(&v0, NULL);\n    (unsigned int)v9 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .6, (unsigned int)a0, (int)::0x403941 ::ip2str(a1),\n            (unsigned int)v9);\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:42:13: error: expected identifier or '('\n   42 | extern char __func__.6;\n      |             ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:43:20: error: expected ';' after top level\ndeclarator 43 | extern struct_0 buf.10; |                    ^ | ;\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:47:30: error: expected ';' after top level\ndeclarator 47 | extern unsigned long long msg.7; | ^ | ;\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:50:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 50 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:50:22: error: expected ';' after top level\ndeclarator 50 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:61:14: error: expected ';' after expression\n   61 |     v3 = &buf.10.field_0;\n      |              ^\n      |              ;\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:61:17: error: invalid suffix '.field_0' on floating\nconstant 61 |     v3 = &buf.10.field_0; |                 ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:73:32: error: expected ')'\n   73 |     v3->field_2 = in_cksum(&buf.10.field_0, 16);\n      |                                ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:73:27: note: to match this '('\n   73 |     v3->field_2 = in_cksum(&buf.10.field_0, 16);\n      |                           ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:74:32: error: expected ')'\n   74 |     if (sendmsg(ping_sock, &msg.7, 4, &msg.7) >= 0)\n      |                                ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:74:16: note: to match this '('\n   74 |     if (sendmsg(ping_sock, &msg.7, 4, &msg.7) >= 0)\n      |                ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:78:18: error: indirection requires pointer operand\n('int' invalid) 78 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp43iaa_0h/send_ping_name_conflict.c:79:9: error: expected\nexpression 79 |         ::0x403941::ip2str(a1); |         ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:85:37: error: indirection requires pointer operand\n('int' invalid) 85 |         (unsigned int)v9 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:86:23: error: expected ')'\n   86 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, (int)::0x403941::ip2str(a1), (unsigned int)v9); | ^\n/tmp/tmp43iaa_0h/send_ping_name_conflict.c:86:16: note: to match this '('\n   86 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, (int)::0x403941::ip2str(a1), (unsigned int)v9); | ^ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(in_cksum)(long long, long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  char padding_2[2];\n  unsigned short field_4;\n  unsigned short field_6;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern void buf.3;\nextern unsigned int foreground;\nextern struct_0 g_40d734;\nextern unsigned int g_40dd04;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern sockaddr src.2;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_ping_name_conflict(unsigned int *a0, unsigned int *a1) {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  timeval v2;             // [bp-0x58]\n  char v3;                // [bp-0x50]\n  timeval v4;             // [bp-0x48]\n  char v5;                // [bp-0x40]\n  timeval v6;             // [bp-0x38]\n  char v7;                // [bp-0x30]\n  unsigned int v8;        // [bp-0x20]\n  unsigned int v9;        // [bp-0x1c]\n  unsigned int v10[2];    // [bp-0x18]\n  struct_0 *v11;          // [bp-0x10]\n  unsigned long long v16; // rax\n\n  v11 = &g_40d734.field_0;\n  *((struct_0 **)&v10[0]) = v11 + 1;\n  v8 = 16;\n  v9 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v8);\n  if (v9 <= 27) {\n    if (foreground) {\n      gettimeofday(&v6, NULL);\n      (unsigned int)v16 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\",\n              (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n              &__func__ .1, v9, (unsigned int)v16);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\");\n    }\n    return 4294967295;\n  } else if (src.2.sin_family != 2) {\n    return 4294967295;\n  } else {\n    if (!(v11->field_4 == ping_id && !v11->field_0 && !v11->field_6 &&\n          !v11->field_1))\n      return 4294967295;\n    if (v9 <= 35) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\");\n      } else {\n        gettimeofday(&v4, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg too small\\n\",\n                (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                &__func__ .1);\n      }\n      return 4294967295;\n    } else if ((short)in_cksum(&buf.3, v9)) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\");\n      } else {\n        gettimeofday(&v2, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: checksum error\\n\",\n                (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                &__func__ .1);\n      }\n      return 4294967295;\n    } else if (v10[1] != 1297106775) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\");\n      } else {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: signature error\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .1);\n      }\n      return 4294967295;\n    } else {\n      *(a0) = v10[0];\n      *(a1) = g_40dd04;\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.1;\n      |             ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:46:16: error: expected ';' after top level\ndeclarator 46 | extern void buf.3; |                ^ |                ;\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:52:8: error: unknown type name 'sockaddr'\n   52 | extern sockaddr src.2;\n      |        ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:52:20: error: expected ';' after top level\ndeclarator 52 | extern sockaddr src.2; |                    ^ | ;\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:53:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 53 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:53:22: error: expected ';' after top level\ndeclarator 53 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:74:34: error: expected ')'\n   74 |     v9 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v8);\n      |                                  ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:74:18: note: to match this '('\n   74 |     v9 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v8);\n      |                  ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:80:42: error: indirection requires pointer operand\n('int' invalid) 80 |             (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:81:27: error: expected ')'\n   81 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg\nlen %d %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.1, v9, (unsigned int)v16); |                           ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:81:20: note: to match this '('\n   81 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg\nlen %d %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.1, v9, (unsigned int)v16); |                    ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:85:22: error: indirection requires pointer operand\n('int' invalid) 85 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmplhcf6gsm/recv_ping_name_conflict.c:90:17: error: expected ')' 90\n|     else if (src.2.sin_family != 2) |                 ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:90:13: note: to match this '('\n   90 |     else if (src.2.sin_family != 2)\n      |             ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:107:31: error: expected ')'\n  107 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.1); |                               ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:107:24: note: to match this '('\n  107 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.1); |                        ^ /tmp/tmplhcf6gsm/recv_ping_name_conflict.c:111:38:\nerror: expected ')' 111 |         else if ((short)in_cksum(&buf.3, v9)) | ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:111:33: note: to match this '('\n  111 |         else if ((short)in_cksum(&buf.3, v9))\n      |                                 ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:120:31: error: expected ')'\n  120 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.1); |                               ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:120:24: note: to match this '('\n  120 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.1); |                        ^ /tmp/tmplhcf6gsm/recv_ping_name_conflict.c:133:31:\nerror: expected ')' 133 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: signature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.1); |                               ^\n/tmp/tmplhcf6gsm/recv_ping_name_conflict.c:133:24: note: to match this '('\n  133 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsignature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                        ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(setsockopt)(int, int, int, void *, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nunsigned short(htons)(unsigned short);\nint(close)(int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_ping_name_conflict() {\n  timeval v0;             // [bp-0x48]\n  char v1;                // [bp-0x40]\n  timeval v2;             // [bp-0x38]\n  char v3;                // [bp-0x30]\n  timeval v4;             // [bp-0x28]\n  char v5;                // [bp-0x20]\n  unsigned int v6;        // [bp-0xc]\n  unsigned long long v10; // rax\n  unsigned long long v13; // rax\n  unsigned long long v16; // rax\n\n  v6 = 1;\n  ping_sock = socket(2, 3, 1);\n  if (ping_sock < 0) {\n    if (foreground) {\n      gettimeofday(&v4, NULL);\n      (unsigned int)v10 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n              (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n              &__func__ .0, (unsigned int)v10);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    if (setsockopt(ping_sock, 0, 2, &v6, 4) >= 0) {\n      if (setsockopt(ping_sock, 0, 8, &v6, 4) >= 0) {\n        ping_id = htons(getpid());\n        return ping_sock;\n      }\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        (unsigned int)v16 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)v16);\n      } else {\n        strerror(*(__errno_location()));\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt \"\n                  \"IP_PKTINFO %s\\\"}\");\n      }\n    } else if (foreground) {\n      gettimeofday(&v2, NULL);\n      (unsigned int)v13 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .0, (unsigned int)v13);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\");\n    }\n    close(ping_sock);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:36:13: error: expected identifier or '('\n   36 | extern char __func__.0;\n      |             ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:40:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 40 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:40:22: error: expected ';' after top level\ndeclarator 40 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:62:42: error: indirection requires pointer operand\n('int' invalid) 62 |             (unsigned int)v10 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:63:27: error: expected ')'\n   63 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\n%s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5), &__func__.0,\n(unsigned int)v10); |                           ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:63:20: note: to match this '('\n   63 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\n%s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5), &__func__.0,\n(unsigned int)v10); |                    ^ /tmp/tmpmxkp2owr/open_ping_name_conflict.c:67:22:\nerror: indirection requires pointer operand ('int' invalid) 67 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:84:46: error: indirection requires pointer operand\n('int' invalid) 84 |                 (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:85:31: error: expected ')'\n   85 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)v16); |                               ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:85:24: note: to match this '('\n   85 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)v16); |                        ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:89:26: error: indirection requires pointer operand\n('int' invalid) 89 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpmxkp2owr/open_ping_name_conflict.c:96:42: error: indirection\nrequires pointer operand ('int' invalid) 96 |             (unsigned int)v13 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:97:27: error: expected ')'\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v13); |                           ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:97:20: note: to match this '('\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v13); |                    ^\n/tmp/tmpmxkp2owr/open_ping_name_conflict.c:101:22: error: indirection requires pointer operand\n('int' invalid) 101 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nint(setsockopt)(int, int, int, void *, int);\nint(close)(int);\nunsigned short(htons)(unsigned short);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(ip2str)(long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .4;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long fill_if_addrs_name_conflict(unsigned int a0[7]) {\n  timeval v0;             // [bp-0xd8]\n  char v1;                // [bp-0xd0]\n  timeval v2;             // [bp-0xc8]\n  char v3;                // [bp-0xc0]\n  timeval v4;             // [bp-0xb8]\n  char v5;                // [bp-0xb0]\n  timeval v6;             // [bp-0xa8]\n  char v7;                // [bp-0xa0]\n  timeval v8;             // [bp-0x98]\n  char v9;                // [bp-0x90]\n  timeval v10;            // [bp-0x88]\n  char v11;               // [bp-0x80]\n  timeval v12;            // [bp-0x78]\n  char v13;               // [bp-0x70]\n  unsigned int v14;       // [bp-0x5c]\n  char v15;               // [bp-0x58], Other Possible Types: unsigned short\n  unsigned short v16;     // [bp-0x56]\n  unsigned int v17;       // [bp-0x54]\n  char v18;               // [bp-0x48]\n  unsigned int v19;       // [bp-0x38]\n  unsigned int v20;       // [bp-0x20]\n  unsigned int v21;       // [bp-0x1c]\n  unsigned long long v25; // rax\n  unsigned long long v28; // rax\n  unsigned long long v31; // rax\n  unsigned long long v34; // rax\n  unsigned long long v37; // rax\n  unsigned long long v40; // rax\n\n  v21 = -1;\n  v20 = socket(2, 2, 0);\n  if (v20 >= 0) {\n    memset(&v18, 0, 40);\n    v19 = a0[6];\n    if (!ioctl(v20, 35088)) {\n      if (!ioctl(v20, 35111)) {\n        if ((short)v19 == 1) {\n          if (setsockopt(v20, 1, 25, &v18, (unsigned int)strlen(&v18) + 1) >=\n              0) {\n            memset(&v15, 0, 16);\n            v15 = 2;\n            v16 = htons(1025);\n            v17 = a0[0];\n            if (connect(v20, &v15, 16) >= 0) {\n              v14 = 16;\n              if (getsockname(v20, &v15, &v14) >= 0) {\n                v21 = 0;\n                memcpy(&a0[4], &v19, 6);\n                a0[3] = v17;\n              } else {\n                if (foreground) {\n                  gettimeofday(&v0, NULL);\n                  (unsigned int)v40 = strerror(*(__errno_location()));\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"%ld.%06ld [error] %s: getsockname %s %s\\n\",\n                          (int)*((long long *)&v0.tv_sec),\n                          (int)*((long long *)&v1), &__func__ .4,\n                          (unsigned int)&v18, (unsigned int)v40);\n                } else {\n                  strerror(*(__errno_location()));\n                  syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                            \"getsockname %s %s\\\"}\");\n                }\n              }\n            } else {\n              if (!foreground) {\n                strerror(*(__errno_location()));\n                ::0x404182 ::ip2str(a0[0]);\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to \"\n                          \"%s from %s %s\\\"}\");\n              } else {\n                gettimeofday(&v2, NULL);\n                (unsigned int)v37 = strerror(*(__errno_location()));\n                fprintf(stderr @GLIBC_2.2.5,\n                        \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\",\n                        (int)*((long long *)&v2.tv_sec),\n                        (int)*((long long *)&v3), &__func__ .4,\n                        (int)::0x404182 ::ip2str(a0[0]), (unsigned int)&v18,\n                        (unsigned int)v40);\n              }\n            }\n          } else if (foreground) {\n            gettimeofday(&v4, NULL);\n            (unsigned int)v34 = strerror(*(__errno_location()));\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: setsockopt %s %s\\n\",\n                    (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                    &__func__ .4, (unsigned int)&v18, (unsigned int)v40);\n          } else {\n            strerror(*(__errno_location()));\n            syslog(\n                3,\n                \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\");\n          }\n        } else {\n          if (!foreground) {\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\");\n          } else {\n            gettimeofday(&v6, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: invalid if %s\\n\",\n                    (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                    &__func__ .4, (unsigned int)&v18);\n          }\n        }\n      } else {\n        if (foreground) {\n          gettimeofday(&v8, NULL);\n          (unsigned int)v31 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\",\n                  (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n                  &__func__ .4, (unsigned int)&v18, (unsigned int)v40);\n        } else {\n          strerror(*(__errno_location()));\n          syslog(\n              3,\n              \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\");\n        }\n      }\n    } else {\n      if (foreground) {\n        gettimeofday(&v10, NULL);\n        (unsigned int)v28 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\",\n                (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n                &__func__ .4, a0[6], (unsigned int)v40);\n      } else {\n        strerror(*(__errno_location()));\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\");\n      }\n    }\n    close(v20);\n    return v21;\n  } else {\n    if (foreground) {\n      gettimeofday(&v12, NULL);\n      (unsigned int)v25 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket sock %s\\n\",\n              (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n              &__func__ .4, (unsigned int)v25);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\");\n    }\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.4;\n      |             ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:47:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 47 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:47:22: error: expected ';' after top level\ndeclarator 47 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:112:66: error: indirection requires pointer\noperand ('int' invalid) 112 |                                     (unsigned\nint)v40 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:113:51: error: expected ')'\n  113 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: getsockname %s %s\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, (unsigned int)&v18, (unsigned int)v40);\n      |                                                   ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:113:44: note: to match this '('\n  113 |                                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: getsockname %s %s\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, (unsigned int)&v18, (unsigned int)v40);\n      |                                            ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:117:46: error: indirection requires pointer\noperand ('int' invalid) 117 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:126:42: error:\nindirection requires pointer operand ('int' invalid) 126 |\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:127:33: error: expected expression\n  127 |                                 ::0x404182::ip2str(a0[0]);\n      |                                 ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:133:62: error: indirection requires pointer\noperand ('int' invalid) 133 |                                 (unsigned int)v37\n= strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:134:47: error: expected ')'\n  134 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: connect to %s from %s %s\\n\", (int)*((long long *)&v2.tv_sec),\n(int)*((long long *)&v3), &__func__.4, (int)::0x404182::ip2str(a0[0]), (unsigned\nint)&v18, (unsigned int)v40); |                                               ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:134:40: note: to match this '('\n  134 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: connect to %s from %s %s\\n\", (int)*((long long *)&v2.tv_sec),\n(int)*((long long *)&v3), &__func__.4, (int)::0x404182::ip2str(a0[0]), (unsigned\nint)&v18, (unsigned int)v40); |                                        ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:141:54: error: indirection requires pointer\noperand ('int' invalid) 141 |                         (unsigned int)v34 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:142:39: error: expected ')'\n  142 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: setsockopt %s %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:142:32: note: to match this '('\n  142 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: setsockopt %s %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:146:34: error: indirection requires pointer\noperand ('int' invalid) 146 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:159:39: error: expected\n')' 159 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid if %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.4, (unsigned int)&v18); |                                       ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:159:32: note: to match this '('\n  159 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid if %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.4, (unsigned int)&v18); |                                ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:168:50: error: indirection requires pointer\noperand ('int' invalid) 168 |                     (unsigned int)v31 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:169:35: error: expected ')'\n  169 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFHWADDR %s %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long\n*)&v9), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:169:28: note: to match this '('\n  169 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFHWADDR %s %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long\n*)&v9), &__func__.4, (unsigned int)&v18, (unsigned int)v40); | ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:173:30: error: indirection requires pointer\noperand ('int' invalid) 173 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:183:46: error:\nindirection requires pointer operand ('int' invalid) 183 | (unsigned int)v28 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:184:31: error: expected ')'\n  184 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFNAME %d %s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long\n*)&v11), &__func__.4, a0[6], (unsigned int)v40); | ^\n/tmp/tmp37fmo72k/fill_if_addrs_name_conflict.c:184:24: note: to match this '('\n  184 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nSIOCGIFNAME %d %s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long\n*)&v11), &__func__.4, a0[6], (unsigned int)v40); |                        ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\nvoid(syslog)(int, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong long(fill_if_addrs)(long long);\nchar *(strerror)(int);\nlong long(update_mpgw)(long long, long long);\nvoid(srandom)(unsigned int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern char g_40dd2c;\nextern char g_40dd38;\nextern char g_40dd3c;\nextern char g_40dd40;\nextern char g_40dd48;\nextern char g_40dd50;\nextern char g_40dd58;\nextern char mpgws;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long add_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;                // [bp-0x50]\n  timeval v1;                     // [bp-0x48]\n  char v2;                        // [bp-0x40]\n  timeval v3;                     // [bp-0x38]\n  char v4;                        // [bp-0x30]\n  char v5;                        // [bp-0x28]\n  char v6;                        // [bp-0x20]\n  unsigned int v7;                // [bp-0x10]\n  unsigned int v8;                // [bp-0xc]\n  unsigned long long v18;         // rax\n  void *v19;                      // rax, Other Possible Types: unsigned long\n  unsigned long long v22;         // rax\n  unsigned long long v24[531370]; // rsi\n  unsigned long long v26[531372]; // rsi\n\n  v0 = a1;\n  v7 = -1;\n  for (v8 = 0; v8 <= 31; v8 += 1) {\n    if (!*((int *)&(&g_40dd3c)[72 * v8])) {\n      if (v7 == -1)\n        v7 = v8;\n    } else {\n      if ((unsigned int)a0 == *((int *)&(&mpgws)[72 * v8]) &&\n          v0 == *((int *)&(&g_40dd38)[72 * v8])) {\n        v19 = &(&mpgws)[72 * v8];\n        return v19;\n      }\n    }\n  }\n  if (v7 == -1) {\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\");\n    } else {\n      gettimeofday(&v3, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: not enough memory\\n\",\n              (int)*((long long *)&v3.tv_sec), (int)*((long long *)&v4),\n              &__func__ .0);\n    }\n    return 0;\n  } else if ((unsigned int)clock_gettime(0x1, &v5) < 0) {\n    if (foreground) {\n      gettimeofday(&v1, NULL);\n      (unsigned int)v22 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v1.tv_sec), (int)*((long long *)&v2),\n              &__func__ .0, (unsigned int)v22);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n    }\n    return 0;\n  } else {\n    memset(&(&mpgws)[72 * v7], 0, 72);\n    *((unsigned int *)&(&mpgws)[72 * v7]) = a0;\n    *((unsigned int *)&(&g_40dd38)[72 * v7]) = v0;\n    v18 = v7;\n    if ((int)fill_if_addrs(&(&mpgws)[64 * v18 + 8 * v18]) < 0)\n      return 0;\n    v24 = 9 * v7 * 8;\n    *((long long *)(v24 + &g_40dd40)) = *((long long *)&v5);\n    *((long long *)(v24 + &g_40dd48)) = *((long long *)&v6);\n    v26 = 9 * v7 * 8;\n    *((long long *)(v26 + &g_40dd50)) = *((long long *)&v5);\n    *((long long *)(v26 + &g_40dd58)) = *((long long *)&v6);\n    update_mpgw(&(&mpgws)[72 * v7], 1);\n    srandom(*((int *)&(&g_40dd2c)[72 * v7]));\n    v19 = &(&mpgws)[72 * v7];\n    return v19;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:36:13: error: expected identifier or '('\n   36 | extern char __func__.0;\n      |             ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:46:22: error: expected ';' after top level\ndeclarator 46 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:92:27: error: expected ')'\n   92 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: not\nenough memory\\n\", (int)*((long long *)&v3.tv_sec), (int)*((long long *)&v4),\n&__func__.0); |                           ^ /tmp/tmp9na_5dph/add_mpgw_name_conflict.c:92:20:\nnote: to match this '(' 92 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: not enough memory\\n\", (int)*((long long *)&v3.tv_sec), (int)*((long\nlong *)&v4), &__func__.0); |                    ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:101:42: error: indirection requires pointer operand\n('int' invalid) 101 |             (unsigned int)v22 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:102:27: error: expected ')'\n  102 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v1.tv_sec), (int)*((long long *)&v2),\n&__func__.0, (unsigned int)v22); |                           ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:102:20: note: to match this '('\n  102 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v1.tv_sec), (int)*((long long *)&v2),\n&__func__.0, (unsigned int)v22); |                    ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:106:22: error: indirection requires pointer operand\n('int' invalid) 106 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp9na_5dph/add_mpgw_name_conflict.c:119:13: error: array type\n'unsigned long long[531370]' is not assignable 119 |         v24 = 9 * v7 * 8;\n      |         ~~~ ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:120:29: error: invalid operands to binary expression\n('unsigned long long[531370]' and 'char *') 120 |         *((long long *)(v24 +\n&g_40dd40)) = *((long long *)&v5); |                         ~~~ ^ ~~~~~~~~~\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:121:29: error: invalid operands to binary expression\n('unsigned long long[531370]' and 'char *') 121 |         *((long long *)(v24 +\n&g_40dd48)) = *((long long *)&v6); |                         ~~~ ^ ~~~~~~~~~\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:122:13: error: array type 'unsigned long\nlong[531372]' is not assignable 122 |         v26 = 9 * v7 * 8; |         ~~~ ^\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:123:29: error: invalid operands to binary expression\n('unsigned long long[531372]' and 'char *') 123 |         *((long long *)(v26 +\n&g_40dd50)) = *((long long *)&v5); |                         ~~~ ^ ~~~~~~~~~\n/tmp/tmp9na_5dph/add_mpgw_name_conflict.c:124:29: error: invalid operands to binary expression\n('unsigned long long[531372]' and 'char *') 124 |         *((long long *)(v26 +\n&g_40dd58)) = *((long long *)&v6); |                         ~~~ ^ ~~~~~~~~~ 13\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_40dd38;\nextern char g_40dd3c;\nextern char mpgws;\n\nlong long find_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (true) {\n    if (v0 <= 31) {\n      if (*((int *)&(&g_40dd3c)[72 * v0]) &&\n          (unsigned int)a0 == *((int *)&(&mpgws)[72 * v0]) &&\n          (unsigned int)a1 == *((int *)&(&g_40dd38)[72 * v0]))\n        return &(&mpgws)[72 * v0];\n      v0 += 1;\n    } else {\n      return 0;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ip2str)(long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long update_mpgw_name_conflict(unsigned int a0[17], unsigned long a1) {\n  timeval v0;            // [bp-0x28]\n  char v1;               // [bp-0x20]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v6; // rax\n  unsigned long long v7; // rax\n\n  v2 = v4;\n  if (a0[7] == (unsigned int)a1)\n    return 0;\n  if (!foreground) {\n    ::0x404182 ::ip2str(a0[0]);\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\");\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state %d\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            (int)::0x404182 ::ip2str(a0[0]), a0[6], (unsigned int)a1);\n  }\n  a0[7] = a1;\n  if (a0[7] == 1) {\n    v6 = random();\n    a0[16] = (unsigned int)(v6 - ((v6 * 2361183241434822607 >> 64 >> 7) -\n                                  (v6 >> 63)) *\n                                     1000) +\n             1010;\n  } else {\n    v7 = random();\n    a0[16] = (unsigned int)(v7 - ((v7 * 5037190915060954895 >> 64 >> 13) -\n                                  (v7 >> 63)) *\n                                     30000) +\n             60000;\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9qr8akqa/update_mpgw_name_conflict.c:34:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 34 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp9qr8akqa/update_mpgw_name_conflict.c:34:22: error: expected ';' after top level\ndeclarator 34 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp9qr8akqa/update_mpgw_name_conflict.c:50:9: error: expected expression\n   50 |         ::0x404182::ip2str(a0[0]);\n      |         ^\n/tmp/tmp9qr8akqa/update_mpgw_name_conflict.c:56:23: error: expected ')'\n   56 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n(int)::0x404182::ip2str(a0[0]), a0[6], (unsigned int)a1); | ^\n/tmp/tmp9qr8akqa/update_mpgw_name_conflict.c:56:16: note: to match this '('\n   56 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n(int)::0x404182::ip2str(a0[0]), a0[6], (unsigned int)a1); |                ^ 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static int process_ping(void) {\n    int ifindex;\n    __be32 addr;\n    struct mpgw *gw;\n    if (recv_ping(&ifindex, &addr) < 0)\n        return 0;\n    if ((gw = find_mpgw(addr, ifindex)) == ((void *)0))\n        return 0;\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (memcmp(gw->gw_hw, \"\\000\\000\\000\\000\\000\\000\", 6) == 0)\n        return 1;\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (gratuitous_arp)\n        send_garp(gw->if_id, gw->gw_ip, gw->gw_hw, gw->if_ip, gw->if_hw);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(recv_ping)(long long, long long);\nlong long(find_mpgw)(long long, long long);\nchar *(clock_gettime)(char *, char *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(update_neigh)(long long, long long, long long, long long);\nvoid(syslog)(int, char *, ...);\nlong long(update_mpgw)(long long, long long);\nlong long(send_garp)(long long, long long, long long, long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .5;\nextern unsigned int foreground;\nextern void g_406163;\nextern unsigned int gratuitous_arp;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long process_ping_name_conflict() {\n  timeval v0;            // [bp-0x28]\n  char v1;               // [bp-0x20]\n  char v2;               // [bp-0x18]\n  char v3;               // [bp-0x14]\n  unsigned int v4[7];    // [bp-0x10]\n  unsigned long long v9; // rax\n\n  if ((int)recv_ping(&v3, &v2) < 0)\n    return 0;\n  *((long long *)&v4[0]) = find_mpgw(*((int *)&v2), *((int *)&v3));\n  if (!v4) {\n    return 0;\n  } else if ((unsigned int)clock_gettime(0x1, &v4[1 + 5]) < 0) {\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      (unsigned int)v9 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .5, (unsigned int)v9);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n    }\n    return 1;\n  } else if (memcmp(&v4[1], &g_406163, 6)) {\n    if (!(int)update_neigh(v4[6], v4[0], &v4[1], 1))\n      update_mpgw(v4, 1);\n    if (!gratuitous_arp)\n      return 1;\n    send_garp(v4[6], v4[0], &v4[1], v4[3], &v4[4]);\n  } else {\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph96n02_9/process_ping_name_conflict.c:38:13: error: expected identifier or '('\n   38 | extern char __func__.5;\n      |             ^\n/tmp/tmph96n02_9/process_ping_name_conflict.c:42:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 42 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmph96n02_9/process_ping_name_conflict.c:42:22: error: expected ';' after top level\ndeclarator 42 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmph96n02_9/process_ping_name_conflict.c:65:41: error: indirection requires pointer\noperand ('int' invalid) 65 |             (unsigned int)v9 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph96n02_9/process_ping_name_conflict.c:66:27: error: expected ')'\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.5, (unsigned int)v9); |                           ^\n/tmp/tmph96n02_9/process_ping_name_conflict.c:66:20: note: to match this '('\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.5, (unsigned int)v9); |                    ^\n/tmp/tmph96n02_9/process_ping_name_conflict.c:70:22: error: indirection requires pointer\noperand ('int' invalid) 70 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int process_arp(void) {\n    int ifindex;\n    __u16 type, op;\n    __be32 sip, tip;\n    char sha[6], tha[6];\n    struct mpgw *gw;\n    if (recv_arp(&ifindex, &type, &op, &sip, sha, &tip, tha) < 0)\n        return 0;\n    if ((gw = find_mpgw(sip, ifindex)) == ((void *)0))\n        return 0;\n    if (tip == gw->if_ip && type == 1 && op == 2)\n        return 0;\n    if (memcmp(gw->gw_hw, sha, 6)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [info] gw %s on if %d changed mac to %s\\n\", tv.tv_sec, tv.tv_usec, ip2str(sip), ifindex, hw2str(sha));\n            } else\n                syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": gw %s on if %d changed mac to %s\\\"}\", ip2str(sip), ifindex, hw2str(sha));\n        });\n        memcpy(gw->gw_hw, sha, 6);\n    }\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (master_election && type == 1 && op == 2) {\n        if (tip < gw->if_ip)\n            gw->timeout = (1000 + 10 + random() % (1000));\n        else\n            gw->timeout = 1000;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(recv_arp)(long long, long long, long long, long long, long long,\n                    long long, long long);\nlong long(find_mpgw)(long long, long long);\nchar *(clock_gettime)(char *, char *);\nlong long(hw2str)(long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong long(update_neigh)(long long, long long, long long, long long);\nlong long(ip2str)(long long);\nvoid(syslog)(int, char *, ...);\nchar *(strerror)(int);\nlong long(update_mpgw)(long long, long long);\nlong(random)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\nextern char __func__ .4;\nextern unsigned int foreground;\nextern unsigned int master_election;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long process_arp_name_conflict() {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  timeval v2;             // [bp-0x58]\n  char v3;                // [bp-0x50]\n  char v4;                // [bp-0x3c]\n  char v5;                // [bp-0x36]\n  char v6;                // [bp-0x32]\n  char v7;                // [bp-0x30]\n  char v8;                // [bp-0x2c]\n  char v9;                // [bp-0x28]\n  char v10;               // [bp-0x26]\n  char v11;               // [bp-0x24]\n  unsigned int v12[17];   // [bp-0x20]\n  unsigned long long v15; // r12\n  struct_0 *v17;          // rax\n  unsigned long long v20; // rax\n  unsigned long long v21; // rax\n\n  if ((int)recv_arp(&v11, &v10, &v9, &v8, &v5, &v7, &v4) < 0)\n    return 0;\n  *((long long *)&v12[0]) = find_mpgw(*((int *)&v8), *((int *)&v11));\n  if (!v12)\n    return 0;\n  if (v12[3] == *((int *)&v7) && *((short *)&v10) == 1 && *((short *)&v9) == 2)\n    return 0;\n  if (memcmp(&v12[1], &v5, 6)) {\n    if (foreground) {\n      gettimeofday(&v2, NULL);\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [info] gw %s on if %d changed mac to %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              (int)::0x401349 ::ip2str(*((int *)&v8)), *((int *)&v11),\n              (int)::0x4013cd ::hw2str(&v5));\n    } else {\n      v15 = ::0x4013cd ::hw2str(&v5);\n      ::0x401349 ::ip2str(*((int *)&v8));\n      syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": gw %s on if %d changed mac \"\n                \"to %s\\\"}\");\n    }\n    v17 = &v12[1];\n    v17->field_0 = *((int *)&v5);\n    v17->field_4 = *((short *)&v6);\n  }\n  if ((unsigned int)clock_gettime(0x1, &v12[12]) >= 0) {\n    if (!(int)update_neigh(v12[6], v12[0], &v12[1], 1))\n      update_mpgw(v12, 1);\n    if (!(master_election && *((short *)&v10) == 1 && *((short *)&v9) == 2))\n      return 1;\n    if (*((int *)&v7) >= v12[3]) {\n      v12[16] = 1000;\n    } else {\n      v21 = random();\n      v12[16] = (unsigned int)(v21 - ((v21 * 2361183241434822607 >> 64 >> 7) -\n                                      (v21 >> 63)) *\n                                         1000) +\n                1010;\n    }\n  } else {\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      (unsigned int)v20 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .4, (unsigned int)v20);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n    }\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:45:13: error: expected identifier or '('\n   45 | extern char __func__.4;\n      |             ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:48:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 48 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:48:22: error: expected ';' after top level\ndeclarator 48 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:82:27: error: expected ')'\n   82 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] gw %s on if %d\nchanged mac to %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n(int)::0x401349::ip2str(*((int *)&v8)), *((int *)&v11),\n(int)::0x4013cd::hw2str(&v5)); |                           ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:82:20: note: to match this '('\n   82 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] gw %s on if %d\nchanged mac to %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n(int)::0x401349::ip2str(*((int *)&v8)), *((int *)&v11),\n(int)::0x4013cd::hw2str(&v5)); |                    ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:86:19: error: expected expression\n   86 |             v15 = ::0x4013cd::hw2str(&v5);\n      |                   ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:87:13: error: expected expression\n   87 |             ::0x401349::ip2str(*((int *)&v8));\n      |             ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:115:42: error: indirection requires pointer\noperand ('int' invalid) 115 |             (unsigned int)v20 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:116:27: error: expected ')'\n  116 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.4, (unsigned int)v20); |                           ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:116:20: note: to match this '('\n  116 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.4, (unsigned int)v20); |                    ^\n/tmp/tmpqc8u8jx0/process_arp_name_conflict.c:120:22: error: indirection requires pointer\noperand ('int' invalid) 120 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int refresh(void) {\n    int i, diff, timeout = 1000;\n    struct timespec now;\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return timeout;\n    }\n    for (i = 0; i < 32; i++) {\n        struct mpgw *gw = &mpgws[i];\n        if (gw->state == MPGW_S_UNUSED)\n            continue;\n        diff = (((&now)->tv_sec - (&gw->last_rcvd)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_rcvd)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            if (gw->timeout != 1000)\n                continue;\n        }\n        if (gw->state == MPGW_S_PROBE && diff > 3 * gw->timeout && update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 0) == 0) {\n            update_mpgw(gw, MPGW_S_FAILED);\n            memset(&gw->gw_hw, 0, sizeof (6));\n        }\n        diff = (((&now)->tv_sec - (&gw->last_sent)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_sent)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            continue;\n        }\n        send_ping(gw->if_id, gw->gw_ip);\n        gw->last_sent = now;\n        if (timeout > gw->timeout)\n            timeout = gw->timeout;\n    }\n    return timeout;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(update_neigh)(long long, long long, long long, long long);\nlong long(send_ping)(long long, long long);\nlong long(update_mpgw)(long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[20];\n  unsigned int field_18;\n  unsigned int field_1c;\n  unsigned long long field_20;\n  unsigned long long field_28;\n  unsigned long long field_30;\n  unsigned long long field_38;\n  unsigned int field_40;\n} struct_0;\n\nextern char __func__ .1;\nextern unsigned int foreground;\nextern char mpgws;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long refresh_name_conflict() {\n  timeval v0;             // [bp-0x48]\n  char v1;                // [bp-0x40]\n  char v2;                // [bp-0x38]\n  char v3;                // [bp-0x30]\n  struct_0 *v4;           // [bp-0x20]\n  unsigned int v5;        // [bp-0x14]\n  unsigned int v6;        // [bp-0x10]\n  unsigned int v7;        // [bp-0xc]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  struct_0 *v13;          // rcx\n  unsigned long long v16; // rax\n\n  v10 = &v8;\n  v5 = 1000;\n  if ((unsigned int)clock_gettime(0x1, &v2) < 0) {\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      (unsigned int)v16 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1, (unsigned int)v16);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n    }\n    return v5;\n  } else {\n    v7 = 0;\n    while (v7 <= 31) {\n      v4 = &(&mpgws)[72 * v7];\n      if (!v4->field_1c)\n        goto LABEL_401bf3;\n      v6 = (unsigned int)(((*((long long *)&v3) - v4->field_38) *\n                               4835703278458516699 >>\n                           64 >> 18) -\n                          (*((long long *)&v3) - v4->field_38 >> 63)) +\n           (unsigned int)(*((long long *)&v2) - v4->field_30) * 1000;\n      if (v6 >= v4->field_40) {\n      LABEL_401ac9:\n        if (v4->field_1c == 1 && v6 > (v4->field_40 << 1) + v4->field_40 &&\n            !(int)update_neigh(v4->field_18, v4->field_0, &v4->padding_4, 0)) {\n          update_mpgw(v4, 2);\n          memset(&v4->padding_4, 0, 4);\n        }\n        v6 = (unsigned int)(((*((long long *)&v3) - v4->field_28) *\n                                 4835703278458516699 >>\n                             64 >> 18) -\n                            (*((long long *)&v3) - v4->field_28 >> 63)) +\n             (unsigned int)(*((long long *)&v2) - v4->field_20) * 1000;\n        if (v6 < v4->field_40) {\n          v6 = v4->field_40 - v6;\n          if (v5 > v6)\n            v5 = v6;\n          goto LABEL_401bf3;\n        } else {\n          send_ping(v4->field_18, v4->field_0);\n          v13 = v4;\n          v13->field_20 = *((long long *)&v2);\n          v13->field_28 = *((long long *)&v3);\n          if (v5 > v4->field_40) {\n            v5 = v4->field_40;\n            goto LABEL_401bf3;\n          }\n        }\n      } else {\n        v6 = v4->field_40 - v6;\n        if (v5 > v6)\n          v5 = v6;\n        if (v4->field_40 == 1000)\n          goto LABEL_401ac9;\n      LABEL_401bf3:\n        v7 += 1;\n      }\n    }\n    return v5;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp05_suese/refresh_name_conflict.c:48:13: error: expected identifier or '('\n   48 | extern char __func__.1;\n      |             ^\n/tmp/tmp05_suese/refresh_name_conflict.c:51:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp05_suese/refresh_name_conflict.c:51:22: error: expected ';' after top level declarator\n   51 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp05_suese/refresh_name_conflict.c:75:42: error: indirection requires pointer operand\n('int' invalid) 75 |             (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp05_suese/refresh_name_conflict.c:76:27: error: expected ')'\n   76 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)v16); |                           ^\n/tmp/tmp05_suese/refresh_name_conflict.c:76:20: note: to match this '('\n   76 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nclock_gettime %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)v16); |                    ^\n/tmp/tmp05_suese/refresh_name_conflict.c:80:22: error: indirection requires pointer operand\n('int' invalid) 80 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rta_find_name_conflict(unsigned short a0[2], unsigned long a1, unsigned long a2) {\n  unsigned int v0;      // [bp-0x24]\n  unsigned short v1[2]; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a1;\n  for (*(&v1) = a0;\n       v0 > 3 && *((short *)v1) << 48 > 0x3000000000000 && v0 >= *((short *)v1);\n       v1 += *((short *)v1) + 3 & 0xfffffffc) {\n    if ((unsigned int)a2 != *((short *)(v1 + 2)))\n      v0 -= *((short *)v1) + 3 & 0xfffffffc;\n    else\n      return v1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphz9be_12/rta_find_name_conflict.c:23:17: error: array type 'unsigned short[2]' is not\nassignable 23 |     for (*(&v1) = a0; v0 > 3 && *((short *)v1) << 48 >\n0x3000000000000 && v0 >= *((short *)v1); v1 += *((short *)v1) + 3 & 0xfffffffc)\n      |          ~~~~~~ ^\n/tmp/tmphz9be_12/rta_find_name_conflict.c:23:100: error: invalid operands to binary expression\n('unsigned short[2]' and 'unsigned int') 23 |     for (*(&v1) = a0; v0 > 3 &&\n*((short *)v1) << 48 > 0x3000000000000 && v0 >= *((short *)v1); v1 += *((short\n*)v1) + 3 & 0xfffffffc) | ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(syslog)(int, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong long(rta_find)(long long, long long, long long);\nlong long(add_mpgw)(long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_0;\n\nextern char __func__ .4;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long process_rt_name_conflict(unsigned int *a0) {\n  timeval v0;      // [bp-0x58]\n  char v1;         // [bp-0x50]\n  timeval v2;      // [bp-0x48]\n  char v3;         // [bp-0x40]\n  unsigned int v4; // [bp-0x2c]\n  struct_0 *v5;    // [bp-0x28]\n  char v6[7];      // [bp-0x20]\n  struct_0 *v7;    // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v8; // [bp-0xc]\n\n  *((unsigned int **)&v6) = a0 + 4;\n  v8 = *(a0)-28;\n  if (v8 < 0) {\n    if (!foreground) {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\");\n    } else {\n      gettimeofday(&v2, NULL);\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .4, v8);\n    }\n    return 4294967295;\n  } else {\n    if (!(v6[0] == 2 && v6[6] <= 252))\n      return 0;\n    v5 = rta_find(&v6[1 + 5], v8, 9);\n    if (!v5)\n      return 0;\n    v8 = v5->field_0 - 4;\n    v7 = &v5->field_4;\n    while (true) {\n      if (!(v8 > 7) || !(v8 >= *((short *)v7)))\n        return 0;\n      v5 = rta_find(v7 + 8, *((short *)v7) - 8, 5);\n      if (!v5)\n        break;\n      v4 = v5->field_4;\n      if (!add_mpgw(v4, *((int *)(v7 + 4))))\n        return 4294967295;\n      v8 -= *((short *)v7) + 3 & 0xfffffffc;\n      v7 += *((short *)v7) + 3 & 0xfffffffc;\n    }\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5,\n              \"%ld.%06ld [error] %s: no gateway in nh info\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .4);\n    } else {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\");\n    }\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_yp14vx1/process_rt_name_conflict.c:39:13: error: expected identifier or '('\n   39 | extern char __func__.4;\n      |             ^\n/tmp/tmp_yp14vx1/process_rt_name_conflict.c:41:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 41 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp_yp14vx1/process_rt_name_conflict.c:41:22: error: expected ';' after top level\ndeclarator 41 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp_yp14vx1/process_rt_name_conflict.c:66:27: error: expected ')'\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nnlmsg_len %d\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.4, v8); |                           ^\n/tmp/tmp_yp14vx1/process_rt_name_conflict.c:66:20: note: to match this '('\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nnlmsg_len %d\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n&__func__.4, v8); |                    ^ /tmp/tmp_yp14vx1/process_rt_name_conflict.c:95:27:\nerror: expected ')' 95 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: no gateway in nh info\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4); |                           ^\n/tmp/tmp_yp14vx1/process_rt_name_conflict.c:95:20: note: to match this '('\n   95 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: no\ngateway in nh info\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                    ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(reset_mpgws)();\nlong(send)(int, void *, unsigned long, int);\nlong(recv)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(process_rt)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char padding_6[2];\n  unsigned int field_8;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .3;\nextern unsigned int foreground;\nextern struct_0 recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long get_nhs_name_conflict() {\n  timeval v0;             // [bp-0xa8]\n  char v1;                // [bp-0xa0]\n  timeval v2;             // [bp-0x98]\n  char v3;                // [bp-0x90]\n  timeval v4;             // [bp-0x88]\n  char v5;                // [bp-0x80]\n  timeval v6;             // [bp-0x78]\n  char v7;                // [bp-0x70]\n  timeval v8;             // [bp-0x68]\n  char v9;                // [bp-0x60]\n  timeval v10;            // [bp-0x58]\n  char v11;               // [bp-0x50]\n  timeval v12;            // [bp-0x48]\n  char v13;               // [bp-0x40]\n  char v14;               // [bp-0x38], Other Possible Types: unsigned int\n  unsigned short v15;     // [bp-0x34]\n  unsigned short v16;     // [bp-0x32]\n  unsigned int v17;       // [bp-0x30]\n  unsigned int v18;       // [bp-0x2c]\n  char v19;               // [bp-0x28]\n  unsigned int v20;       // [bp-0x24]\n  unsigned int *v21;      // [bp-0x20]\n  struct_0 *v22;          // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v23;       // [bp-0xc]\n  char v24;               // [bp-0x8]\n  unsigned long long v26; // rbp\n  unsigned long long v31; // rax\n  unsigned long long v34; // rax\n\n  v26 = &v24;\n  reset_mpgws();\n  memset(&v14, 0, 20);\n  v14 = 20;\n  v15 = 26;\n  v16 = 257;\n  v18 = 0;\n  talk_seq = talk_seq + 1;\n  v17 = talk_seq;\n  v19 = 2;\n  if (send(talk_sock, &v14, 20, 0) < 0) {\n    if (foreground) {\n      gettimeofday(&v12, NULL);\n      (unsigned int)v31 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n              (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n              &__func__ .3, (unsigned int)v31);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    }\n    return 4294967295;\n  }\n  while (v23 < 0) {\n    v23 = recv(talk_sock, &recv_buf.field_0, 0x4000, 0);\n    if (*(__errno_location()) != 4 && *(__errno_location()) != 11) {\n      if (!foreground) {\n        strerror(*(__errno_location()));\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n      } else {\n        gettimeofday(&v10, NULL);\n        (unsigned int)v34 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n                (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n                &__func__ .3, (unsigned int)v34);\n      }\n      return 4294967295;\n    }\n  }\n  if (!v23) {\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n    } else {\n      gettimeofday(&v8, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv len == 0\\n\",\n              (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n              &__func__ .3);\n    }\n    return 4294967295;\n  }\n  for (v22 = &recv_buf.field_0;\n       v23 > 15 && v22->field_0 > 15 && v23 >= v22->field_0;\n       v22 = (char *)v22 + (v22->field_0 + 3 & -0x4)) {\n    if (v22->field_8 != talk_seq) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\");\n      } else {\n        gettimeofday(&v6, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                &__func__ .3, v22->field_8);\n      }\n    } else {\n      if (v22->field_4 == 3) {\n        return 0;\n      } else if (v22->field_4 == 2) {\n        v21 = v22 + 16;\n        if (*((int *)v22) <= 35) {\n          if (!foreground) {\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg \"\n                      \"truncated\\\"}\");\n          } else {\n            gettimeofday(&v4, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                    (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                    &__func__ .3);\n          }\n          v20 = -1;\n        } else {\n          if (*(v21)) {\n            if (!foreground) {\n              strerror(-(*(v21)));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n            } else {\n              gettimeofday(&v2, NULL);\n              fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                      (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                      &__func__ .3, (unsigned int)strerror(-(*(v21))));\n            }\n            v20 = -1;\n          }\n        }\n        v20 = 0;\n        return 4294967295;\n      } else if (v22->field_4 != 24) {\n        if (!foreground) {\n          syslog(3,\n                 \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\");\n        } else {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .3, v22->field_4);\n        }\n      } else {\n        if ((int)process_rt(v22) < 0)\n          return 4294967295;\n      }\n    }\n    v23 -= v22->field_0 + 3 & -0x4;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:43:13: error: expected identifier or '('\n   43 | extern char __func__.3;\n      |             ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:46:22: error: expected ';' after top level declarator\n   46 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:96:42: error: indirection requires pointer operand\n('int' invalid) 96 |             (unsigned int)v31 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:97:27: error: expected ')'\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13), &__func__.3,\n(unsigned int)v31); |                           ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:97:20: note: to match this '('\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13), &__func__.3,\n(unsigned int)v31); |                    ^ /tmp/tmphqznkmr6/get_nhs_name_conflict.c:101:22:\nerror: indirection requires pointer operand ('int' invalid) 101 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:109:13: error: indirection requires pointer operand\n('int' invalid) 109 |         if (*(__errno_location()) != 4 &&\n*(__errno_location()) != 11) |             ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:109:43: error: indirection requires pointer operand\n('int' invalid) 109 |         if (*(__errno_location()) != 4 &&\n*(__errno_location()) != 11) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:113:26: error: indirection requires pointer operand\n('int' invalid) 113 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmphqznkmr6/get_nhs_name_conflict.c:119:46: error: indirection\nrequires pointer operand ('int' invalid) 119 |                 (unsigned int)v34\n= strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:120:31: error: expected ')'\n  120 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\n%s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11), &__func__.3,\n(unsigned int)v34); |                               ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:120:24: note: to match this '('\n  120 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\n%s\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11), &__func__.3,\n(unsigned int)v34); |                        ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:134:27: error: expected ')'\n  134 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv len\n== 0\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.3); |                           ^ /tmp/tmphqznkmr6/get_nhs_name_conflict.c:134:20:\nnote: to match this '(' 134 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: recv len == 0\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long\n*)&v9), &__func__.3); |                    ^ /tmp/tmphqznkmr6/get_nhs_name_conflict.c:149:31:\nerror: expected ')' 149 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long\nlong *)&v7), &__func__.3, v22->field_8); |                               ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:149:24: note: to match this '('\n  149 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.3, v22->field_8); |                        ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:170:39: error: expected ')'\n  170 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr msg truncated\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.3); |                                       ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:170:32: note: to match this '('\n  170 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr msg truncated\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.3); |                                ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:186:43: error: expected ')'\n  186 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.3, (unsigned int)strerror(-(*(v21)))); | ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:186:36: note: to match this '('\n  186 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.3, (unsigned int)strerror(-(*(v21)))); | ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:203:35: error: expected ')'\n  203 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.3, v22->field_4); |                                   ^\n/tmp/tmphqznkmr6/get_nhs_name_conflict.c:203:28: note: to match this '('\n  203 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.3, v22->field_4); |                            ^ 16 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\nlong(recv)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char padding_6[2];\n  unsigned int field_8;\n} struct_0;\n\nextern char __func__ .2;\nextern unsigned int foreground;\nextern struct_0 recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long update_neigh(unsigned long a0, unsigned long a1, void *a2,\n                       unsigned long a3) {\n  timeval v0;             // [bp-0xd8]\n  char v1;                // [bp-0xd0]\n  timeval v2;             // [bp-0xc8]\n  char v3;                // [bp-0xc0]\n  timeval v4;             // [bp-0xb8]\n  char v5;                // [bp-0xb0]\n  timeval v6;             // [bp-0xa8]\n  char v7;                // [bp-0xa0]\n  timeval v8;             // [bp-0x98]\n  char v9;                // [bp-0x90]\n  timeval v10;            // [bp-0x88]\n  char v11;               // [bp-0x80]\n  timeval v12;            // [bp-0x78]\n  char v13;               // [bp-0x70]\n  timeval v14;            // [bp-0x68]\n  char v15;               // [bp-0x60]\n  char v16;               // [bp-0x58], Other Possible Types: unsigned int\n  unsigned short v17;     // [bp-0x54]\n  unsigned short v18;     // [bp-0x52]\n  unsigned int v19;       // [bp-0x50]\n  char v20;               // [bp-0x48]\n  unsigned int v21;       // [bp-0x44]\n  unsigned short v22;     // [bp-0x40]\n  unsigned short v23;     // [bp-0x3c]\n  unsigned short v24;     // [bp-0x3a]\n  unsigned int v25;       // [bp-0x38]\n  unsigned short v26;     // [bp-0x34]\n  unsigned short v27;     // [bp-0x32]\n  char v28;               // [bp-0x30]\n  unsigned int v29;       // [bp-0x24]\n  unsigned int *v30;      // [bp-0x20]\n  struct_0 *v31;          // [bp-0x18]\n  unsigned int v32;       // [bp-0xc]\n  unsigned long long v39; // rax\n  unsigned long long v42; // rax\n\n  memset(&v16, 0, 48);\n  v16 = 48;\n  v17 = 28;\n  talk_seq = talk_seq + 1;\n  v19 = talk_seq;\n  v18 = 1285;\n  v20 = 2;\n  v21 = a0;\n  *((int *)&v22) = (!(unsigned int)a3 ? 2 : 32);\n  v23 = 8;\n  v24 = 1;\n  v25 = a1;\n  v26 = 10;\n  v27 = 2;\n  memcpy(&v28, a2, 6);\n  if (send(talk_sock, &v16, 48, 0) < 0) {\n    if (foreground) {\n      gettimeofday(&v14, NULL);\n      (unsigned int)v39 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n              (int)*((long long *)&v14.tv_sec), (int)*((long long *)&v15),\n              &__func__ .2, (unsigned int)v39);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    }\n    return 4294967295;\n  } else {\n    while (true) {\n      v32 = recv(talk_sock, &recv_buf.field_0, 0x4000, 0);\n      if (v32 >= 0)\n        break;\n      if (*(__errno_location()) != 4 && *(__errno_location()) != 11) {\n        if (foreground) {\n          gettimeofday(&v12, NULL);\n          (unsigned int)v42 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n                  (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n                  &__func__ .2, (unsigned int)v42);\n        } else {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n        }\n        return 4294967295;\n      }\n    }\n    if (!v32) {\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n      } else {\n        gettimeofday(&v10, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n                &__func__ .2);\n      }\n      return 4294967295;\n    } else {\n      v31 = &recv_buf.field_0;\n      if (!(v32 > 15) || !(v31->field_0 > 15) || !(v32 >= v31->field_0)) {\n        if (foreground) {\n          gettimeofday(&v8, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid len %d\\n\",\n                  (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n                  &__func__ .2, v32);\n        } else {\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\");\n        }\n        return 4294967295;\n      } else if (v31->field_8 != talk_seq) {\n        if (!foreground) {\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\");\n        } else {\n          gettimeofday(&v6, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                  (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                  &__func__ .2, v31->field_8);\n        }\n        return 4294967295;\n      } else if (v31->field_4 != 2) {\n        if (foreground) {\n          gettimeofday(&v4, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                  (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                  &__func__ .2, v31->field_4);\n        } else {\n          syslog(3,\n                 \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\");\n        }\n        return 4294967295;\n      } else {\n        v30 = &v31[1].field_4;\n        if (v31->field_0 <= 35) {\n          if (!foreground) {\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg \"\n                      \"truncated\\\"}\");\n          } else {\n            gettimeofday(&v2, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                    (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                    &__func__ .2);\n          }\n          v29 = -1;\n        } else if (*(v30)) {\n          if (!foreground) {\n            strerror(-(*(v30)));\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n          } else {\n            gettimeofday(&v0, NULL);\n            fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                    (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                    &__func__ .2, (unsigned int)strerror(-(*(v30))));\n          }\n          v29 = -1;\n        }\n      }\n    }\n    v29 = 0;\n    return v29;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpijzeuohq/update_neigh.c:41:13: error: expected identifier or '('\n   41 | extern char __func__.2;\n      |             ^\n/tmp/tmpijzeuohq/update_neigh.c:44:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 44 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpijzeuohq/update_neigh.c:44:22: error: expected ';' after top level\ndeclarator 44 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpijzeuohq/update_neigh.c:106:42: error: indirection requires pointer\noperand ('int' invalid) 106 |             (unsigned int)v39 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpijzeuohq/update_neigh.c:107:27: error: expected ')'\n  107 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v14.tv_sec), (int)*((long long *)&v15), &__func__.2,\n(unsigned int)v39); |                           ^\n/tmp/tmpijzeuohq/update_neigh.c:107:20: note: to match this '('\n  107 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send\n%s\\n\", (int)*((long long *)&v14.tv_sec), (int)*((long long *)&v15), &__func__.2,\n(unsigned int)v39); |                    ^\n/tmp/tmpijzeuohq/update_neigh.c:111:22: error: indirection requires pointer\noperand ('int' invalid) 111 |             strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpijzeuohq/update_neigh.c:123:17: error: indirection\nrequires pointer operand ('int' invalid) 123 |             if\n(*(__errno_location()) != 4 && *(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpijzeuohq/update_neigh.c:123:47: error: indirection\nrequires pointer operand ('int' invalid) 123 |             if\n(*(__errno_location()) != 4 && *(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpijzeuohq/update_neigh.c:128:50: error: indirection\nrequires pointer operand ('int' invalid) 128 |                     (unsigned\nint)v42 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpijzeuohq/update_neigh.c:129:35: error: expected ')'\n  129 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n&__func__.2, (unsigned int)v42); |                                   ^\n/tmp/tmpijzeuohq/update_neigh.c:129:28: note: to match this '('\n  129 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v12.tv_sec), (int)*((long long *)&v13),\n&__func__.2, (unsigned int)v42); |                            ^\n/tmp/tmpijzeuohq/update_neigh.c:133:30: error: indirection requires pointer\noperand ('int' invalid) 133 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpijzeuohq/update_neigh.c:148:31: error: expected\n')' 148 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv len == 0\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n&__func__.2); |                               ^\n/tmp/tmpijzeuohq/update_neigh.c:148:24: note: to match this '('\n  148 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v10.tv_sec), (int)*((long long *)&v11),\n&__func__.2); |                        ^ /tmp/tmpijzeuohq/update_neigh.c:160:35:\nerror: expected ')' 160 |                     fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid len %d\\n\", (int)*((long long *)&v8.tv_sec),\n(int)*((long long *)&v9), &__func__.2, v32); | ^\n/tmp/tmpijzeuohq/update_neigh.c:160:28: note: to match this '('\n  160 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid len %d\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.2, v32); |                            ^\n/tmp/tmpijzeuohq/update_neigh.c:177:35: error: expected ')'\n  177 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.2, v31->field_8); |                                   ^\n/tmp/tmpijzeuohq/update_neigh.c:177:28: note: to match this '('\n  177 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid seq %d\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n&__func__.2, v31->field_8); |                            ^\n/tmp/tmpijzeuohq/update_neigh.c:186:35: error: expected ')'\n  186 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.2, v31->field_4); |                                   ^\n/tmp/tmpijzeuohq/update_neigh.c:186:28: note: to match this '('\n  186 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n&__func__.2, v31->field_4); |                            ^\n/tmp/tmpijzeuohq/update_neigh.c:206:39: error: expected ')'\n  206 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr msg truncated\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.2); |                                       ^\n/tmp/tmpijzeuohq/update_neigh.c:206:32: note: to match this '('\n  206 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr msg truncated\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.2); |                                ^\n/tmp/tmpijzeuohq/update_neigh.c:220:39: error: expected ')'\n  220 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(-(*(v30)))); | ^\n/tmp/tmpijzeuohq/update_neigh.c:220:32: note: to match this '('\n  220 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(-(*(v30)))); | ^ 17 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(get_nhs)();\nvoid(syslog)(int, char *, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern void recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_nl_name_conflict() {\n  timeval v0;             // [bp-0x38]\n  char v1;                // [bp-0x30]\n  timeval v2;             // [bp-0x28]\n  char v3;                // [bp-0x20]\n  unsigned int v4;        // [bp-0x18]\n  sockaddr v5;            // [bp-0x14]\n  char v6;                // [bp-0x10]\n  unsigned long long v11; // rax\n\n  v4 = 12;\n  if (recvfrom(poll_sock, &recv_buf, 0x4000, 64, &v5, &v4) < 0) {\n    if (foreground) {\n      gettimeofday(&v2, NULL);\n      (unsigned int)v11 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n              (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n              &__func__ .1, (unsigned int)v11);\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    }\n    return 0;\n  } else if (v4 != 12) {\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\");\n    } else {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1);\n    }\n    return 0;\n  } else if (!*((int *)&v6)) {\n    get_nhs();\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:42:13: error: expected identifier or '('\n   42 | extern char __func__.1;\n      |             ^\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:46:22: error: expected ';' after top level declarator\n   46 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:65:42: error: indirection requires pointer operand\n('int' invalid) 65 |             (unsigned int)v11 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:66:27: error: expected ')'\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v11); |                           ^\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:66:20: note: to match this '('\n   66 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3), &__func__.1,\n(unsigned int)v11); |                    ^ /tmp/tmph5qj09wr/recv_nl_name_conflict.c:70:22:\nerror: indirection requires pointer operand ('int' invalid) 70 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph5qj09wr/recv_nl_name_conflict.c:84:27: error: expected ')'\n   84 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\naddr len\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                           ^ /tmp/tmph5qj09wr/recv_nl_name_conflict.c:84:20:\nnote: to match this '(' 84 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid addr len\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.1); |                    ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\nint(close)(int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(get_nhs)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long open_nl_name_conflict() {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  timeval v2;             // [bp-0x58]\n  char v3;                // [bp-0x50]\n  timeval v4;             // [bp-0x48]\n  char v5;                // [bp-0x40]\n  timeval v6;             // [bp-0x38]\n  char v7;                // [bp-0x30]\n  timeval v8;             // [bp-0x28]\n  char v9;                // [bp-0x20]\n  unsigned int v10;       // [bp-0x18]\n  unsigned short v11;     // [bp-0x14], Other Possible Types: char\n  unsigned int v12;       // [bp-0xc]\n  unsigned long long v16; // rax\n  unsigned long long v19; // rax\n  unsigned long long v22; // rax\n  unsigned long long v25; // rax\n  unsigned long long v29; // rax\n\n  v10 = 12;\n  memset(&v11, 0, 12);\n  v11 = 16;\n  talk_sock = socket(16, 3, 0);\n  if (talk_sock >= 0) {\n    if (connect(talk_sock, &v11, 12) < 0) {\n      if (foreground) {\n        gettimeofday(&v6, NULL);\n        (unsigned int)v19 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: connect talk_sock %s\\n\",\n                (int)*((long long *)&v6.tv_sec), (int)*((long long *)&v7),\n                &__func__ .0, (unsigned int)v19);\n      } else {\n        strerror(*(__errno_location()));\n        syslog(\n            3,\n            \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\");\n      }\n    } else {\n      if (getsockname(talk_sock, &v11, &v10) < 0) {\n        if (foreground) {\n          gettimeofday(&v4, NULL);\n          (unsigned int)v22 = strerror(*(__errno_location()));\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\",\n                  (int)*((long long *)&v4.tv_sec), (int)*((long long *)&v5),\n                  &__func__ .0, (unsigned int)v22);\n        } else {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname \"\n                    \"talk_sock %s\\\"}\");\n        }\n      } else {\n        talk_seq = random();\n        memset(&v11, 0, 12);\n        v11 = 16;\n        v12 = 64;\n        poll_sock = socket(16, 3, 0);\n        if (poll_sock < 0) {\n          if (foreground) {\n            gettimeofday(&v2, NULL);\n            (unsigned int)v25 = strerror(*(__errno_location()));\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: socket poll_sock %s\\n\",\n                    (int)*((long long *)&v2.tv_sec), (int)*((long long *)&v3),\n                    &__func__ .0, (unsigned int)v25);\n          } else {\n            strerror(*(__errno_location()));\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock \"\n                      \"%s\\\"}\");\n          }\n        } else {\n          if (bind(poll_sock, &v11, 12) < 0) {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              (unsigned int)v29 = strerror(*(__errno_location()));\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: bind poll_sock %s\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .0, (unsigned int)v29);\n            } else {\n              strerror(*(__errno_location()));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock \"\n                        \"%s\\\"}\");\n            }\n          } else {\n            if ((int)get_nhs() >= 0)\n              return poll_sock;\n          }\n          close(poll_sock);\n        }\n      }\n    }\n    close(talk_sock);\n  } else if (foreground) {\n    gettimeofday(&v8, NULL);\n    (unsigned int)v16 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\",\n            (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n            &__func__ .0, (unsigned int)v16);\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\");\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:48:13: error: expected identifier or '('\n   48 | extern char __func__.0;\n      |             ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:51:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:51:22: error: expected ';' after top level declarator\n   51 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:87:46: error: indirection requires pointer operand\n('int' invalid) 87 |                 (unsigned int)v19 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:88:31: error: expected ')'\n   88 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nconnect talk_sock %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long\n*)&v7), &__func__.0, (unsigned int)v19); |                               ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:88:24: note: to match this '('\n   88 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nconnect talk_sock %s\\n\", (int)*((long long *)&v6.tv_sec), (int)*((long long\n*)&v7), &__func__.0, (unsigned int)v19); |                        ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:92:26: error: indirection requires pointer operand\n('int' invalid) 92 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp7c99fg3e/open_nl_name_conflict.c:103:50: error: indirection\nrequires pointer operand ('int' invalid) 103 |                     (unsigned\nint)v22 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:104:35: error: expected ')'\n  104 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ngetsockname talk_sock %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.0, (unsigned int)v22); |                                   ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:104:28: note: to match this '('\n  104 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ngetsockname talk_sock %s\\n\", (int)*((long long *)&v4.tv_sec), (int)*((long long\n*)&v5), &__func__.0, (unsigned int)v22); |                            ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:108:30: error: indirection requires pointer operand\n('int' invalid) 108 |                     strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp7c99fg3e/open_nl_name_conflict.c:124:54: error: indirection\nrequires pointer operand ('int' invalid) 124 |                         (unsigned\nint)v25 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:125:39: error: expected ')'\n  125 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: socket poll_sock %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v25); | ^ /tmp/tmp7c99fg3e/open_nl_name_conflict.c:125:32:\nnote: to match this '(' 125 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsocket poll_sock %s\\n\", (int)*((long long *)&v2.tv_sec), (int)*((long long\n*)&v3), &__func__.0, (unsigned int)v25); |                                ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:129:34: error: indirection requires pointer operand\n('int' invalid) 129 |                         strerror(*(__errno_location()));\n      |                                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:140:58: error: indirection requires pointer operand\n('int' invalid) 140 |                             (unsigned int)v29 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:141:43: error: expected ')'\n  141 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)v29); | ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:141:36: note: to match this '('\n  141 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)v29); | ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:145:38: error: indirection requires pointer operand\n('int' invalid) 145 | strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:163:38: error: indirection requires pointer operand\n('int' invalid) 163 |         (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:164:23: error: expected ')'\n  164 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.0, (unsigned int)v16); |                       ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:164:16: note: to match this '('\n  164 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v8.tv_sec), (int)*((long long *)&v9),\n&__func__.0, (unsigned int)v16); |                ^\n/tmp/tmp7c99fg3e/open_nl_name_conflict.c:168:18: error: indirection requires pointer operand\n('int' invalid) 168 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 18 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_device(char *devname, long sig) {\n    struct sigaction sa = {.__sigaction_handler.sa_handler = sigio};\n    int fd;\n    printf(\"device file = %s\\n\", devname);\n    fd = open(devname, 0);\n    if (fd < 0) {\n        perror(\"open\");\n        return fd;\n    }\n    sigaction(sig, &sa, ((void *)0));\n    if (fcntl(fd, 8, getpid()) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 10, sig) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 4, 8192) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sigio; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nchar *(sigaction)(char *, char *, char *);\nint(fcntl)(int, int, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long open_device_name_conflict(unsigned long a0, char *a1) {\n  char *v0;         // [bp-0xb0]\n  char v1;          // [bp-0xa8]\n  unsigned int v2;  // [bp-0xc]\n  unsigned long v4; // rcx, Other Possible Types: unsigned long long\n  struct_0 *v5;     // rdi, Other Possible Types: unsigned long\n  unsigned long v6; // d\n  unsigned long v7; // rax\n\n  v0 = a0;\n  v4 = 19;\n  for (v5 = &v1; v4; v5 += v6 * 8) {\n    v4 -= 1;\n    *((long long *)v5) = 0;\n  }\n  *((void **)&v1) = sigio;\n  printf(\"device file = %s\\n\", (unsigned int)v0);\n  v2 = open(v0, 0, (unsigned short)&v1);\n  if (v2 < 0) {\n    perror(\"open\");\n    return v2;\n  }\n  sigaction(a1, &v1, NULL);\n  getpid();\n  if (fcntl(v2, 8) < 0) {\n    perror(\"fcntl\");\n    exit(1); /* do not return */\n  } else if (fcntl(v2, 10) < 0) {\n    perror(\"fcntl\");\n    exit(1); /* do not return */\n  } else {\n    (unsigned int)v7 = fcntl(v2, 4);\n    if ((unsigned int)v7 < 0) {\n      perror(\"fcntl\");\n      exit(1); /* do not return */\n    }\n    return v7;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaxd99ubk/open_device_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpaxd99ubk/open_device_name_conflict.c:65:9: error: assignment to cast is illegal,\nlvalue casts are not supported 65 |         (unsigned int)v7 = fcntl(v2, 4); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/NeoCat_YUREX-driver-for-Linux/sample/timing-game.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long parson_strndup_name_conflict(char *a0, char *a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = parson_malloc(a1 + 1);\n  if (!v0)\n    return 0;\n  a1[v0] = 0;\n  strncpy(v0, a0, a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parson_strndup)(long long, long long);\n\nlong long parson_strdup_name_conflict(char *a0) { return parson_strndup(a0, strlen(a0)); }\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_char_to_int_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57)\n    return (char)a0 - 48;\n  if ((char)a0 > 96 && (char)a0 <= 102)\n    return (char)a0 - 87;\n  if ((char)a0 > 64 && (char)a0 <= 70)\n    return (char)a0 - 55;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(hex_char_to_int)(long long);\n\nlong long parse_utf16_hex_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  if (a0[0] && a0[1] && a0[2] && a0[3]) {\n    v3 = hex_char_to_int(a0[0]);\n    v2 = hex_char_to_int(a0[1]);\n    v1 = hex_char_to_int(a0[2]);\n    v0 = hex_char_to_int(a0[3]);\n    if (!(v3 != -1 && v2 != -1 && v1 != -1 && v0 != -1))\n      return 0;\n    *(a1) = v1 * 16 | v3 * 0x1000 | v2 * 0x100 | v0;\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long num_bytes_in_utf8_sequence_name_conflict(unsigned long a0) {\n  if ((char)a0 != 192 && (char)a0 != 193 && (char)a0 <= 244 &&\n      ((char)a0 & 192) != 128)\n    return ((char)a0 < 0 ? 1\n                         : (((char)a0 & 224) == 192\n                                ? (((char)a0 & 240) == 224\n                                       ? (((char)a0 & 248) == 240 ? 0 : 4)\n                                       : 3)\n                                : 2));\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(num_bytes_in_utf8_sequence)(long long);\n\nlong long verify_utf8_sequence_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  *(a1) = num_bytes_in_utf8_sequence(a0[0]);\n  if (*(a1) == 1) {\n    v0 = a0[0];\n  } else if (!(*(a1) != 2 || (a0[1] & 192) != 128)) {\n    v0 = a0[0] & 31;\n    v0 = a0[1] & 63 | v0 * 64;\n  } else if (*(a1) != 3 || (a0[1] & 192) != 128 || (a0[2] & 192) != 128) {\n    if (!(*(a1) == 4) || !((a0[1] & 192) == 128) || !((a0[2] & 192) == 128) ||\n        !((a0[3] & 192) == 128))\n      return 0;\n    v0 = a0[0] & 7;\n    v0 = a0[1] & 63 | v0 * 64;\n    v0 = a0[2] & 63 | v0 * 64;\n    v0 = a0[3] & 63 | v0 * 64;\n  } else {\n    v0 = a0[0] & 15;\n    v0 = a0[1] & 63 | v0 * 64;\n    v0 = a0[2] & 63 | v0 * 64;\n  }\n  if ((v0 > 127 || *(a1) <= 1) && (v0 > 2047 || *(a1) <= 2) &&\n      (!(v0 <= 65535) || !(*(a1) > 3))) {\n    if (v0 > 1114111)\n      return 0;\n    if (!(v0 > 55295 && v0 <= 57343))\n      return 1;\n    return 0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(verify_utf8_sequence)(long long, long long);\n\nlong long is_valid_utf8_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x20], Other Possible Types: unsigned long long\n  unsigned int v1;  // [bp-0x14]\n  unsigned long v2; // [bp-0x10]\n\n  v0 = a0;\n  v1 = 0;\n  for (v2 = a1 + v0; v0 < v2; v0 += v1) {\n    if (!(int)verify_utf8_sequence(v0, &v1))\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_decimal_name_conflict(unsigned long a0, char a1[3]) {\n  char v0[3]; // [bp-0x18], Other Possible Types: unsigned long\n  char v3[3]; // rax\n\n  *(&v0) = a1;\n  if (v0 > 1 && *((char *)a0) == 48 && *((char *)(a0 + 1)) != 46)\n    return 0;\n  if (v0 > 2 && !strncmp(a0, \"-0\", 2) && *((char *)(a0 + 2)) != 46)\n    return 0;\n  while (true) {\n    v3 = v0;\n    v0 = &v3[1];\n    if (!v3) {\n      return 1;\n    } else if (strchr(\"xX\", *((char *)(v0 + a0)))) {\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1nvnehl4/is_decimal_name_conflict.c:22:12: error: array type 'char[3]' is not\nassignable 22 |     *(&v0) = a1; |     ~~~~~~ ^\n/tmp/tmp1nvnehl4/is_decimal_name_conflict.c:29:12: error: array type 'char[3]' is not\nassignable 29 |         v3 = v0; |         ~~ ^\n/tmp/tmp1nvnehl4/is_decimal_name_conflict.c:30:12: error: array type 'char[3]' is not\nassignable 30 |         v0 = &v3[1]; |         ~~ ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nvoid(rewind)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_file(char *a0) {\n  char *v0;         // [bp-0x30]\n  unsigned long v1; // [bp-0x28]\n  char *v2;         // [bp-0x20], Other Possible Types: unsigned long\n  void *v3;         // [bp-0x18], Other Possible Types: unsigned int\n  FILE_t *v4;       // [bp-0x10]\n\n  v4 = &fopen(a0, \"r\")->_flags;\n  v3 = 0;\n  v2 = 0;\n  if (!v4)\n    return 0;\n  fseek(v4, 0, 2);\n  v1 = ftell(v4);\n  if ((char)(v1 - 0 >> 63)) {\n    fclose(v4);\n    return 0;\n  }\n  *((unsigned long *)&v3) = v1;\n  rewind(v4);\n  v0 = parson_malloc(*((long long *)&v3) + 1);\n  if (!v0) {\n    fclose(v4);\n    return 0;\n  }\n  v2 = fread(v0, 1, *((long long *)&v3), v4);\n  if (v2 && !ferror(v4)) {\n    fclose(v4);\n    v0[v2] = 0;\n    return v0;\n  }\n  fclose(v4);\n  parson_free(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpte02oeni/read_file.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpte02oeni/read_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpte02oeni/read_file.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpte02oeni/read_file.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmpte02oeni/read_file.c:251:13: error: declaration of anonymous union must\nbe a definition 251 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:254:22: error: type name requires a specifier or\nqualifier 254 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:258:13: error: declaration of anonymous union must\nbe a definition 258 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:261:22: error: type name requires a specifier or\nqualifier 261 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:194:7: error: conflicting types for 'rewind'\n  194 | void (rewind)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:723:13: note: previous declaration is here\n  723 | extern void rewind (FILE *__stream);\n      |             ^\n/tmp/tmpte02oeni/read_file.c:340:13: error: declaration of anonymous union must\nbe a definition 340 |             union <anon> { |             ^\n/tmp/tmpte02oeni/read_file.c:343:22: error: type name requires a specifier or\nqualifier 343 |             } __value; |                      ^\n/tmp/tmpte02oeni/read_file.c:347:13: error: declaration of anonymous union must\nbe a definition 347 |             union <anon> { |             ^ fatal error:\ntoo many errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long skip_quotes_name_conflict(struct struct_0 **a0) {\n  if (*(a0)->field_0 != 34)\n    return 4294967295;\n  *(a0) = *(a0) + 1;\n  while (*(a0)->field_0 == 34) {\n  LABEL_4026e0:\n    *(a0) = *(a0) + 1;\n    return 0;\n  }\n  if (!*(a0)->field_0)\n    return 4294967295;\n  if (*(a0)->field_0 == 92) {\n    *(a0) = *(a0) + 1;\n    if (!*(a0)->field_0)\n      return 4294967295;\n  }\n  *(a0) = *(a0) + 1;\n  goto LABEL_4026e0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:19:14: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 19 |     if (*(a0)->field_0 != 34) |\n~~~~^ ~~~~~~~ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:21:19: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 21 |     *(a0) = *(a0) + 1; |\n~~~~~ ^ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:17:30: note: forward declaration of\n'struct struct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:22:17: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 22 |     while (*(a0)->field_0 == 34) |\n~~~~^ ~~~~~~~ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:25:23: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 25 |         *(a0) = *(a0) + 1;\n      |                 ~~~~~ ^\n/tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:28:15: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 28 |     if (!*(a0)->field_0) | ~~~~^\n~~~~~~~ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:30:14: error: member reference base type\n'struct struct_0 *' is not a structure or union 30 |     if (*(a0)->field_0 ==\n92) |          ~~~~^ ~~~~~~~ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:32:23: error:\narithmetic on a pointer to an incomplete type 'struct struct_0' 32 | *(a0) =\n*(a0) + 1; |                 ~~~~~ ^ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:17:30: note:\nforward declaration of 'struct struct_0' 17 | long long skip_quotes_name_conflict(struct\nstruct_0 **a0) |                              ^\n/tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:33:19: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |         if (!*(a0)->field_0) |\n~~~~^ ~~~~~~~ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:36:19: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 36 |     *(a0) = *(a0) + 1; |\n~~~~~ ^ /tmp/tmpdpxxo58n/skip_quotes_name_conflict.c:17:30: note: forward declaration of\n'struct struct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^ 9 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16_name_conflict_hex)(long long, long long);\n\nlong long parse_utf16_name_conflict(struct struct_0 **a0, struct struct_1 **a1) {\n  char v0;         // [bp-0x28]\n  unsigned int v1; // [bp-0x24], Other Possible Types: char\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x1c]\n  char *v4;        // [bp-0x18], Other Possible Types: unsigned long\n  char v5[4];      // [bp-0x10], Other Possible Types: unsigned long\n  char *v8;        // rax\n  char *v9;        // rax\n\n  v3 = 0;\n  *((struct struct_1 **)&v5) = *(a1);\n  v4 = &*(a0)->field_0;\n  v4 += 1;\n  v3 = parse_utf16_name_conflict_hex(v4, &v1);\n  if (!v3)\n    return 4294967295;\n  if (*((int *)&v1) <= 127) {\n    v5[0] = *((int *)&v1);\n  } else if (*((int *)&v1) <= 2047) {\n    v5[0] = (unsigned int)(*((int *)&v1) >> 6) & 31 | -64;\n    v5[1] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[1];\n  } else if (*((int *)&v1) <= 55295 || *((int *)&v1) > 57343) {\n    v5[0] = (unsigned int)(*((int *)&v1) >> 12) & 15 | -32;\n    v5[1] = (unsigned int)(*((int *)&v1) >> 6) & 63 | -128;\n    v5[2] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[2];\n  } else {\n    if (!(*((int *)&v1) > 55295) || !(*((int *)&v1) <= 56319))\n      return 4294967295;\n    v2 = *((int *)&v1);\n    v4 += 4;\n    v8 = v4;\n    v4 = v8 + 1;\n    if (!(*(v8) == 92) ||\n        !((v9 = v4, v4 = (unsigned long)(v9 + 1), *(v9) == 117)))\n      return 4294967295;\n    v3 = parse_utf16_name_conflict_hex(v4, &v0);\n    if (!(v3) || !(*((int *)&v0) > 56319) || !(*((int *)&v0) <= 57343))\n      return 4294967295;\n    v1 = (*((int *)&v0) & 1023 | v2 * 0x400 & 0xffc00) + 0x10000;\n    v5[0] = (unsigned int)(*((int *)&v1) >> 18) & 7 | -0x10;\n    v5[1] = (unsigned int)(*((int *)&v1) >> 12) & 63 | -128;\n    v5[2] = (unsigned int)(*((int *)&v1) >> 6) & 63 | -128;\n    v5[3] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[3];\n  }\n  v4 += 3;\n  *(a1) = v5;\n  *(a0) = v4;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpko4h4adl/parse_utf16_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v4 = &*(a0)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpko4h4adl/parse_utf16_name_conflict.c:44:12: error: array type 'char[4]' is not\nassignable 44 |         v5 = &v5[1]; |         ~~ ^\n/tmp/tmpko4h4adl/parse_utf16_name_conflict.c:51:12: error: array type 'char[4]' is not\nassignable 51 |         v5 = &v5[2]; |         ~~ ^\n/tmp/tmpko4h4adl/parse_utf16_name_conflict.c:71:12: error: array type 'char[4]' is not\nassignable 71 |         v5 = &v5[3]; |         ~~ ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16)(long long, long long);\n\ntypedef struct struct_1 {\n  char padding_0[4268136];\n  unsigned int field_412068;\n} struct_1;\n\nextern char g_412068;\n\nlong long process_string_name_conflict(char *a0, unsigned long a1) {\n  char *v0;              // [bp-0x38], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x30], Other Possible Types: unsigned long\n  void *v2;              // [bp-0x28]\n  char *v3;              // [bp-0x20]\n  void *v4;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long long v5; // [bp-0x10]\n  unsigned int v7;       // eax\n\n  v1 = a0;\n  v5 = a1 + 1;\n  v4 = 0;\n  v3 = 0;\n  v0 = 0;\n  v2 = 0;\n  v3 = parson_malloc(v5);\n  if (!v3) {\n    goto LABEL_402b47;\n  } else {\n    v0 = v3;\n    while (true) {\n      if (!*(v1) || v1 - a0 >= a1) {\n        *((char *)v0) = 0;\n        v4 = 1 + v0 - v3;\n        v2 = parson_malloc(v4);\n        if (v2) {\n          memcpy(v2, v3, v4);\n          parson_free(v3);\n          return v2;\n        }\n        break;\n      } else {\n        if (*(v1) == 92) {\n          v1 += 1;\n          v7 = *((char *)v1);\n          switch (v7) {\n          case 92:\n            *(v0) = 92;\n            break;\n          case 93:\n          case 94:\n          case 95:\n          case 96:\n          case 97:\n          case 99:\n          case 100:\n          case 101:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 111:\n          case 112:\n          case 113:\n          case 115:\n          LABEL_402b47:\n            parson_free(v3);\n            return 0;\n          case 98:\n            *(v0) = 8;\n            break;\n          case 102:\n            *(v0) = 12;\n            break;\n          case 110:\n            *(v0) = 10;\n            break;\n          case 114:\n            *(v0) = 13;\n            break;\n          case 116:\n            *(v0) = 9;\n            break;\n          case 117:\n            if ((int)parse_utf16(&v1, &v0) == -1) {\n              parson_free(v3);\n              return 0;\n            }\n          default:\n          LABEL_402b47:\n            parson_free(v3);\n            return 0;\n          }\n        } else if (*(v1) > 31) {\n          *(v0) = *(v1);\n        } else {\n          break;\n        }\n        v0 += 1;\n        v1 += 1;\n      }\n    }\n  }\n  parson_free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0nc_oe3y/process_string_name_conflict.c:101:1: error: redefinition of label\n'LABEL_402b47' 101 | LABEL_402b47: | ^ /tmp/tmp0nc_oe3y/process_string_name_conflict.c:76:1:\nnote: previous definition is here 76 | LABEL_402b47: | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(skip_quotes)(long long);\nlong long(process_string)(long long, long long);\n\nlong long get_quoted_string_name_conflict(unsigned long long *a0) {\n  unsigned int v0;  // [bp-0x1c]\n  void *v1;         // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned long v2; // [bp-0x10]\n\n  v2 = *(a0);\n  v1 = 0;\n  v0 = skip_quotes(a0);\n  if (!v0) {\n    v1 = *(a0)-v2 - 2;\n    return process_string(v2 + 1, v1);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[4268660];\n  unsigned int field_412274;\n} struct_0;\n\nextern char g_412274;\n\nlong long json_serialize_string_name_conflict(char *a0, char *a1) {\n  char *v0;         // [bp-0x38], Other Possible Types: unsigned long\n  unsigned int v1;  // [bp-0x28]\n  char v2;          // [bp-0x21]\n  unsigned long v3; // [bp-0x20]\n  unsigned int v4;  // [bp-0x14]\n  char *v5;         // [bp-0x10], Other Possible Types: unsigned long\n  struct_0 *v8;     // rax\n\n  v0 = a1;\n  v5 = 0;\n  v3 = strlen(a0);\n  v2 = 0;\n  v1 = -1;\n  v4 = 0;\n  v1 = append_string(v0, \"\\\"\");\n  if (v1 < 0)\n    return 4294967295;\n  if (v0)\n    v0 = &v0[v1];\n  v4 += v1;\n  for (v5 = 0; v5 < v3; v5 += 1) {\n    v2 = a0[v5];\n    v8 = v2;\n    switch ((unsigned int)v8) {\n    case 0:\n      v1 = append_string(v0, \"\\\\u0000\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 1:\n      v1 = append_string(v0, \"\\\\u0001\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 2:\n      v1 = append_string(v0, \"\\\\u0002\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 3:\n      v1 = append_string(v0, \"\\\\u0003\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 4:\n      v1 = append_string(v0, \"\\\\u0004\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 5:\n      v1 = append_string(v0, \"\\\\u0005\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 6:\n      v1 = append_string(v0, \"\\\\u0006\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 7:\n      v1 = append_string(v0, \"\\\\u0007\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 8:\n      v1 = append_string(v0, \"\\\\b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 9:\n      v1 = append_string(v0, \"\\\\t\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 10:\n      v1 = append_string(v0, \"\\\\n\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 11:\n      v1 = append_string(v0, \"\\\\u000b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 12:\n      v1 = append_string(v0, \"\\\\f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 13:\n      v1 = append_string(v0, \"\\\\r\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 14:\n      v1 = append_string(v0, \"\\\\u000e\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 15:\n      v1 = append_string(v0, \"\\\\u000f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 16:\n      v1 = append_string(v0, \"\\\\u0010\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 17:\n      v1 = append_string(v0, \"\\\\u0011\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 18:\n      v1 = append_string(v0, \"\\\\u0012\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 19:\n      v1 = append_string(v0, \"\\\\u0013\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 20:\n      v1 = append_string(v0, \"\\\\u0014\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 21:\n      v1 = append_string(v0, \"\\\\u0015\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 22:\n      v1 = append_string(v0, \"\\\\u0016\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 23:\n      v1 = append_string(v0, \"\\\\u0017\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 24:\n      v1 = append_string(v0, \"\\\\u0018\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 25:\n      v1 = append_string(v0, \"\\\\u0019\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 26:\n      v1 = append_string(v0, \"\\\\u001a\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 27:\n      v1 = append_string(v0, \"\\\\u001b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 28:\n      v1 = append_string(v0, \"\\\\u001c\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 29:\n      v1 = append_string(v0, \"\\\\u001d\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 30:\n      v1 = append_string(v0, \"\\\\u001e\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 31:\n      v1 = append_string(v0, \"\\\\u001f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 34:\n      v1 = append_string(v0, \"\\\\\\\"\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 47:\n      v1 = append_string(v0, \"\\\\/\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 92:\n      v1 = append_string(v0, \"\\\\\\\\\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    default:\n      if (v0) {\n        *((char *)v0) = v2;\n        v0 += 1;\n      }\n      v4 += 1;\n      break;\n    }\n  }\n  v1 = append_string(v0, \"\\\"\");\n  if (v1 < 0)\n    return 4294967295;\n  if (v0)\n    v0 = &v0[v1];\n  v4 += v1;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_tv0ss1b/json_serialize_string_name_conflict.c:49:16: error: array subscript is not an\ninteger 49 |         v2 = a0[v5]; |                ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long append_indent_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v0; // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n\n  v0 = a0;\n  v1 = -1;\n  v2 = 0;\n  for (v3 = 0; v3 < (unsigned int)a1; v3 += 1) {\n    v1 = append_string(v0, \"    \");\n    if (v1 < 0)\n      return 4294967295;\n    if (v0)\n      v0 += v1;\n    v2 += v1;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long append_string_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0) {\n    (unsigned int)v1 = sprintf(a0, \"%s\", (unsigned int)a1);\n    return v1;\n  }\n  v1 = strlen(a1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp06pbwkk8/append_string_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = sprintf(a0, \"%s\",\n(unsigned int)a1); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long parson_strndup_name_conflict(char *a0, char *a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = parson_malloc(a1 + 1);\n  if (!v0)\n    return 0;\n  a1[v0] = 0;\n  strncpy(v0, a0, a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parson_strndup)(long long, long long);\n\nlong long parson_strdup_name_conflict(char *a0) { return parson_strndup(a0, strlen(a0)); }\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_char_to_int_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57)\n    return (char)a0 - 48;\n  if ((char)a0 > 96 && (char)a0 <= 102)\n    return (char)a0 - 87;\n  if ((char)a0 > 64 && (char)a0 <= 70)\n    return (char)a0 - 55;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(hex_char_to_int)(long long);\n\nlong long parse_utf16_hex_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  if (a0[0] && a0[1] && a0[2] && a0[3]) {\n    v3 = hex_char_to_int(a0[0]);\n    v2 = hex_char_to_int(a0[1]);\n    v1 = hex_char_to_int(a0[2]);\n    v0 = hex_char_to_int(a0[3]);\n    if (!(v3 != -1 && v2 != -1 && v1 != -1 && v0 != -1))\n      return 0;\n    *(a1) = v1 * 16 | v3 * 0x1000 | v2 * 0x100 | v0;\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long num_bytes_in_utf8_sequence_name_conflict(unsigned long a0) {\n  if ((char)a0 != 192 && (char)a0 != 193 && (char)a0 <= 244 &&\n      ((char)a0 & 192) != 128)\n    return ((char)a0 < 0 ? 1\n                         : (((char)a0 & 224) == 192\n                                ? (((char)a0 & 240) == 224\n                                       ? (((char)a0 & 248) == 240 ? 0 : 4)\n                                       : 3)\n                                : 2));\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(num_bytes_in_utf8_sequence)(long long);\n\nlong long verify_utf8_sequence_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  *(a1) = num_bytes_in_utf8_sequence(a0[0]);\n  if (*(a1) == 1) {\n    v0 = a0[0];\n  } else if (!(*(a1) != 2 || (a0[1] & 192) != 128)) {\n    v0 = a0[0] & 31;\n    v0 = a0[1] & 63 | v0 * 64;\n  } else if (*(a1) != 3 || (a0[1] & 192) != 128 || (a0[2] & 192) != 128) {\n    if (!(*(a1) == 4) || !((a0[1] & 192) == 128) || !((a0[2] & 192) == 128) ||\n        !((a0[3] & 192) == 128))\n      return 0;\n    v0 = a0[0] & 7;\n    v0 = a0[1] & 63 | v0 * 64;\n    v0 = a0[2] & 63 | v0 * 64;\n    v0 = a0[3] & 63 | v0 * 64;\n  } else {\n    v0 = a0[0] & 15;\n    v0 = a0[1] & 63 | v0 * 64;\n    v0 = a0[2] & 63 | v0 * 64;\n  }\n  if ((v0 > 127 || *(a1) <= 1) && (v0 > 2047 || *(a1) <= 2) &&\n      (!(v0 <= 65535) || !(*(a1) > 3))) {\n    if (v0 > 1114111)\n      return 0;\n    if (!(v0 > 55295 && v0 <= 57343))\n      return 1;\n    return 0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(verify_utf8_sequence)(long long, long long);\n\nlong long is_valid_utf8_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x20], Other Possible Types: unsigned long long\n  unsigned int v1;  // [bp-0x14]\n  unsigned long v2; // [bp-0x10]\n\n  v0 = a0;\n  v1 = 0;\n  for (v2 = a1 + v0; v0 < v2; v0 += v1) {\n    if (!(int)verify_utf8_sequence(v0, &v1))\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_decimal_name_conflict(unsigned long a0, char a1[3]) {\n  char v0[3]; // [bp-0x18], Other Possible Types: unsigned long\n  char v3[3]; // rax\n\n  *(&v0) = a1;\n  if (v0 > 1 && *((char *)a0) == 48 && *((char *)(a0 + 1)) != 46)\n    return 0;\n  if (v0 > 2 && !strncmp(a0, \"-0\", 2) && *((char *)(a0 + 2)) != 46)\n    return 0;\n  while (v3) {\n    v3 = v0;\n    v0 = &v3[1];\n    if (strchr(\"xX\", *((char *)(v0 + a0))))\n      return 0;\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprrya_n3q/is_decimal_name_conflict.c:22:12: error: array type 'char[3]' is not\nassignable 22 |     *(&v0) = a1; |     ~~~~~~ ^\n/tmp/tmprrya_n3q/is_decimal_name_conflict.c:29:12: error: array type 'char[3]' is not\nassignable 29 |         v3 = v0; |         ~~ ^\n/tmp/tmprrya_n3q/is_decimal_name_conflict.c:30:12: error: array type 'char[3]' is not\nassignable 30 |         v0 = &v3[1]; |         ~~ ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nvoid(rewind)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_file(char *a0) {\n  char *v0;         // [bp-0x30]\n  unsigned long v1; // [bp-0x28]\n  char *v2;         // [bp-0x20], Other Possible Types: unsigned long\n  void *v3;         // [bp-0x18], Other Possible Types: unsigned int\n  FILE_t *v4;       // [bp-0x10]\n\n  v4 = &fopen(a0, \"r\")->_flags;\n  v3 = 0;\n  v2 = 0;\n  if (!v4)\n    return 0;\n  fseek(v4, 0, 2);\n  v1 = ftell(v4);\n  if ((char)(v1 - 0 >> 63)) {\n    fclose(v4);\n    return 0;\n  }\n  *((unsigned long *)&v3) = v1;\n  rewind(v4);\n  v0 = parson_malloc(*((long long *)&v3) + 1);\n  if (!v0) {\n    fclose(v4);\n    return 0;\n  }\n  v2 = fread(v0, 1, *((long long *)&v3), v4);\n  if (v2 && !ferror(v4)) {\n    fclose(v4);\n    v0[v2] = 0;\n    return v0;\n  }\n  fclose(v4);\n  parson_free(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8igqy89d/read_file.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp8igqy89d/read_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp8igqy89d/read_file.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp8igqy89d/read_file.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp8igqy89d/read_file.c:251:13: error: declaration of anonymous union must\nbe a definition 251 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:254:22: error: type name requires a specifier or\nqualifier 254 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:258:13: error: declaration of anonymous union must\nbe a definition 258 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:261:22: error: type name requires a specifier or\nqualifier 261 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:194:7: error: conflicting types for 'rewind'\n  194 | void (rewind)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:723:13: note: previous declaration is here\n  723 | extern void rewind (FILE *__stream);\n      |             ^\n/tmp/tmp8igqy89d/read_file.c:340:13: error: declaration of anonymous union must\nbe a definition 340 |             union <anon> { |             ^\n/tmp/tmp8igqy89d/read_file.c:343:22: error: type name requires a specifier or\nqualifier 343 |             } __value; |                      ^\n/tmp/tmp8igqy89d/read_file.c:347:13: error: declaration of anonymous union must\nbe a definition 347 |             union <anon> { |             ^ fatal error:\ntoo many errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long skip_quotes_name_conflict(struct struct_0 **a0) {\n  if (*(a0)->field_0 != 34)\n    return 4294967295;\n  for (*(a0) = *(a0) + 1; *(a0)->field_0 != 34; *(a0) = *(a0) + 1) {\n    if (!*(a0)->field_0) {\n      return 4294967295;\n    } else if (*(a0)->field_0 == 92) {\n      *(a0) = *(a0) + 1;\n      if (!*(a0)->field_0)\n        return 4294967295;\n    }\n  }\n  *(a0) = *(a0) + 1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:19:14: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 19 |     if (*(a0)->field_0 != 34) |\n~~~~^ ~~~~~~~ /tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:21:24: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 21 |     for (*(a0) = *(a0) + 1;\n*(a0)->field_0 != 34; *(a0) = *(a0) + 1) |                  ~~~~~ ^\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:21:34: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 21 |     for (*(a0) = *(a0) + 1;\n*(a0)->field_0 != 34; *(a0) = *(a0) + 1) |                              ~~~~^\n~~~~~~~ /tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:21:65: error: arithmetic on a pointer to\nan incomplete type 'struct struct_0' 21 |     for (*(a0) = *(a0) + 1;\n*(a0)->field_0 != 34; *(a0) = *(a0) + 1) | ~~~~~ ^\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:23:19: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 23 |         if (!*(a0)->field_0) |\n~~~~^ ~~~~~~~ /tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:27:23: error: member reference base\ntype 'struct struct_0 *' is not a structure or union 27 |         else if\n(*(a0)->field_0 == 92) |                   ~~~~^ ~~~~~~~\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:29:27: error: arithmetic on a pointer to an\nincomplete type 'struct struct_0' 29 |             *(a0) = *(a0) + 1; | ~~~~~ ^\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:30:23: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 30 |             if (!*(a0)->field_0) |\n~~~~^ ~~~~~~~ /tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:34:19: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 34 |     *(a0) = *(a0) + 1; |\n~~~~~ ^ /tmp/tmpjtu3ekdv/skip_quotes_name_conflict.c:17:30: note: forward declaration of\n'struct struct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^ 9 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16_name_conflict_hex)(long long, long long);\n\nlong long parse_utf16_name_conflict(struct struct_0 **a0, struct struct_1 **a1) {\n  char v0;         // [bp-0x28]\n  char v1;         // [bp-0x24], Other Possible Types: unsigned int\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x1c]\n  char *v4;        // [bp-0x18], Other Possible Types: unsigned long\n  char v5[4];      // [bp-0x10], Other Possible Types: unsigned long\n  char *v8;        // rax\n  char *v9;        // rax\n\n  v3 = 0;\n  *((struct struct_1 **)&v5) = *(a1);\n  v4 = &*(a0)->field_0;\n  v4 += 1;\n  v3 = parse_utf16_name_conflict_hex(v4, &v1);\n  if (!v3)\n    return 4294967295;\n  if (*((int *)&v1) <= 127) {\n    v5[0] = *((int *)&v1);\n  } else if (*((int *)&v1) <= 2047) {\n    v5[0] = (unsigned int)(*((int *)&v1) >> 6) & 31 | -64;\n    v5[1] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[1];\n  } else if (*((int *)&v1) <= 55295 || *((int *)&v1) > 57343) {\n    v5[0] = (unsigned int)(*((int *)&v1) >> 12) & 15 | -32;\n    v5[1] = (unsigned int)(*((int *)&v1) >> 6) & 63 | -128;\n    v5[2] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[2];\n  } else {\n    if (!(*((int *)&v1) > 55295) || !(*((int *)&v1) <= 56319))\n      return 4294967295;\n    v2 = *((int *)&v1);\n    v4 += 4;\n    v8 = v4;\n    v4 = v8 + 1;\n    if (!(*(v8) == 92) ||\n        !((v9 = v4, v4 = (unsigned long)(v9 + 1), *(v9) == 117)))\n      return 4294967295;\n    v3 = parse_utf16_name_conflict_hex(v4, &v0);\n    if (!(v3) || !(*((int *)&v0) > 56319) || !(*((int *)&v0) <= 57343))\n      return 4294967295;\n    v1 = (*((int *)&v0) & 1023 | v2 * 0x400 & 0xffc00) + 0x10000;\n    v5[0] = (unsigned int)(*((int *)&v1) >> 18) & 7 | -0x10;\n    v5[1] = (unsigned int)(*((int *)&v1) >> 12) & 63 | -128;\n    v5[2] = (unsigned int)(*((int *)&v1) >> 6) & 63 | -128;\n    v5[3] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[3];\n  }\n  v4 += 3;\n  *(a1) = v5;\n  *(a0) = v4;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcgsni3bz/parse_utf16_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 31 |     v4 = &*(a0)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpcgsni3bz/parse_utf16_name_conflict.c:44:12: error: array type 'char[4]' is not\nassignable 44 |         v5 = &v5[1]; |         ~~ ^\n/tmp/tmpcgsni3bz/parse_utf16_name_conflict.c:51:12: error: array type 'char[4]' is not\nassignable 51 |         v5 = &v5[2]; |         ~~ ^\n/tmp/tmpcgsni3bz/parse_utf16_name_conflict.c:71:12: error: array type 'char[4]' is not\nassignable 71 |         v5 = &v5[3]; |         ~~ ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16)(long long, long long);\n\ntypedef struct struct_1 {\n  char padding_0[4268152];\n  unsigned int field_412078;\n} struct_1;\n\nextern char g_412078;\n\nlong long process_string_name_conflict(char *a0, unsigned long a1) {\n  char *v0;              // [bp-0x38], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x30], Other Possible Types: unsigned long\n  void *v2;              // [bp-0x28]\n  char *v3;              // [bp-0x20]\n  void *v4;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long long v5; // [bp-0x10]\n  unsigned int v7;       // eax\n\n  v1 = a0;\n  v5 = a1 + 1;\n  v4 = 0;\n  v3 = 0;\n  v0 = 0;\n  v2 = 0;\n  v3 = parson_malloc(v5);\n  if (!v3) {\n    goto LABEL_402e8d;\n  } else {\n    v0 = v3;\n    while (true) {\n      if (!*(v1) || v1 - a0 >= a1) {\n        *((char *)v0) = 0;\n        v4 = 1 + v0 - v3;\n        v2 = parson_malloc(v4);\n        if (v2) {\n          memcpy(v2, v3, v4);\n          parson_free(v3);\n          return v2;\n        }\n        break;\n      } else {\n        if (*(v1) == 92) {\n          v1 += 1;\n          v7 = *((char *)v1);\n          switch (v7) {\n          case 92:\n            *(v0) = 92;\n            break;\n          case 93:\n          case 94:\n          case 95:\n          case 96:\n          case 97:\n          case 99:\n          case 100:\n          case 101:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 111:\n          case 112:\n          case 113:\n          case 115:\n          LABEL_402e8d:\n            parson_free(v3);\n            return 0;\n          case 98:\n            *(v0) = 8;\n            break;\n          case 102:\n            *(v0) = 12;\n            break;\n          case 110:\n            *(v0) = 10;\n            break;\n          case 114:\n            *(v0) = 13;\n            break;\n          case 116:\n            *(v0) = 9;\n            break;\n          case 117:\n            if ((int)parse_utf16(&v1, &v0) == -1) {\n              parson_free(v3);\n              return 0;\n            }\n          default:\n          LABEL_402e8d:\n            parson_free(v3);\n            return 0;\n          }\n        } else if (*(v1) > 31) {\n          *(v0) = *(v1);\n        } else {\n          break;\n        }\n        v0 += 1;\n        v1 += 1;\n      }\n    }\n  }\n  parson_free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgpxd7m7w/process_string_name_conflict.c:101:1: error: redefinition of label\n'LABEL_402e8d' 101 | LABEL_402e8d: | ^ /tmp/tmpgpxd7m7w/process_string_name_conflict.c:76:1:\nnote: previous definition is here 76 | LABEL_402e8d: | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(skip_quotes)(long long);\nlong long(process_string)(long long, long long);\n\nlong long get_quoted_string_name_conflict(unsigned long long *a0) {\n  unsigned int v0;  // [bp-0x1c]\n  void *v1;         // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned long v2; // [bp-0x10]\n\n  v2 = *(a0);\n  v1 = 0;\n  v0 = skip_quotes(a0);\n  if (!v0) {\n    v1 = *(a0)-v2 - 2;\n    return process_string(v2 + 1, v1);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[4268676];\n  unsigned int field_412284;\n} struct_0;\n\nextern char g_412284;\n\nlong long json_serialize_string_name_conflict(char *a0, char *a1) {\n  char *v0;         // [bp-0x38], Other Possible Types: unsigned long\n  unsigned int v1;  // [bp-0x28]\n  char v2;          // [bp-0x21]\n  unsigned long v3; // [bp-0x20]\n  unsigned int v4;  // [bp-0x14]\n  char *v5;         // [bp-0x10], Other Possible Types: unsigned long\n  struct_0 *v8;     // rax\n\n  v0 = a1;\n  v5 = 0;\n  v3 = strlen(a0);\n  v2 = 0;\n  v1 = -1;\n  v4 = 0;\n  v1 = append_string(v0, \"\\\"\");\n  if (v1 < 0)\n    return 4294967295;\n  if (v0)\n    v0 = &v0[v1];\n  v4 += v1;\n  for (v5 = 0; v5 < v3; v5 += 1) {\n    v2 = a0[v5];\n    v8 = v2;\n    switch ((unsigned int)v8) {\n    case 0:\n      v1 = append_string(v0, \"\\\\u0000\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 1:\n      v1 = append_string(v0, \"\\\\u0001\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 2:\n      v1 = append_string(v0, \"\\\\u0002\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 3:\n      v1 = append_string(v0, \"\\\\u0003\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 4:\n      v1 = append_string(v0, \"\\\\u0004\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 5:\n      v1 = append_string(v0, \"\\\\u0005\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 6:\n      v1 = append_string(v0, \"\\\\u0006\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 7:\n      v1 = append_string(v0, \"\\\\u0007\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 8:\n      v1 = append_string(v0, \"\\\\b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 9:\n      v1 = append_string(v0, \"\\\\t\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 10:\n      v1 = append_string(v0, \"\\\\n\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 11:\n      v1 = append_string(v0, \"\\\\u000b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 12:\n      v1 = append_string(v0, \"\\\\f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 13:\n      v1 = append_string(v0, \"\\\\r\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 14:\n      v1 = append_string(v0, \"\\\\u000e\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 15:\n      v1 = append_string(v0, \"\\\\u000f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 16:\n      v1 = append_string(v0, \"\\\\u0010\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 17:\n      v1 = append_string(v0, \"\\\\u0011\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 18:\n      v1 = append_string(v0, \"\\\\u0012\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 19:\n      v1 = append_string(v0, \"\\\\u0013\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 20:\n      v1 = append_string(v0, \"\\\\u0014\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 21:\n      v1 = append_string(v0, \"\\\\u0015\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 22:\n      v1 = append_string(v0, \"\\\\u0016\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 23:\n      v1 = append_string(v0, \"\\\\u0017\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 24:\n      v1 = append_string(v0, \"\\\\u0018\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 25:\n      v1 = append_string(v0, \"\\\\u0019\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 26:\n      v1 = append_string(v0, \"\\\\u001a\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 27:\n      v1 = append_string(v0, \"\\\\u001b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 28:\n      v1 = append_string(v0, \"\\\\u001c\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 29:\n      v1 = append_string(v0, \"\\\\u001d\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 30:\n      v1 = append_string(v0, \"\\\\u001e\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 31:\n      v1 = append_string(v0, \"\\\\u001f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 34:\n      v1 = append_string(v0, \"\\\\\\\"\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 47:\n      v1 = append_string(v0, \"\\\\/\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 92:\n      v1 = append_string(v0, \"\\\\\\\\\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    default:\n      if (v0) {\n        *((char *)v0) = v2;\n        v0 += 1;\n      }\n      v4 += 1;\n      break;\n    }\n  }\n  v1 = append_string(v0, \"\\\"\");\n  if (v1 < 0)\n    return 4294967295;\n  if (v0)\n    v0 = &v0[v1];\n  v4 += v1;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxhea2__9/json_serialize_string_name_conflict.c:49:16: error: array subscript is not an\ninteger 49 |         v2 = a0[v5]; |                ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long append_indent_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v0; // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0x14]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n\n  v0 = a0;\n  v1 = -1;\n  v2 = 0;\n  for (v3 = 0; v3 < (unsigned int)a1; v3 += 1) {\n    v1 = append_string(v0, \"    \");\n    if (v1 < 0)\n      return 4294967295;\n    if (v0)\n      v0 += v1;\n    v2 += v1;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long append_string_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0) {\n    (unsigned int)v1 = sprintf(a0, \"%s\", (unsigned int)a1);\n    return v1;\n  }\n  v1 = strlen(a1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu1h8r_m3/append_string_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = sprintf(a0, \"%s\",\n(unsigned int)a1); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long parson_strndup_name_conflict(char *a0, char *a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = parson_malloc(a1 + 1);\n  if (!v0)\n    return 0;\n  a1[v0] = 0;\n  strncpy(v0, a0, a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parson_strndup)(long long, long long);\n\nlong long parson_strdup_name_conflict(char *a0) { return parson_strndup(a0, strlen(a0)); }\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_char_to_int_name_conflict(unsigned long a0) {\n  if ((char)a0 > 47 && (char)a0 <= 57)\n    return (char)a0 - 48;\n  if ((char)a0 > 96 && (char)a0 <= 102)\n    return (char)a0 - 87;\n  if ((char)a0 > 64 && (char)a0 <= 70)\n    return (char)a0 - 55;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(hex_char_to_int)(long long);\n\nlong long parse_utf16_hex_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  if (a0[0] && a0[1] && a0[2] && a0[3]) {\n    v3 = hex_char_to_int(a0[0]);\n    v2 = hex_char_to_int(a0[1]);\n    v1 = hex_char_to_int(a0[2]);\n    v0 = hex_char_to_int(a0[3]);\n    if (!(v3 != -1 && v2 != -1 && v1 != -1 && v0 != -1))\n      return 0;\n    *(a1) = v1 * 16 | v3 * 0x1000 | v2 * 0x100 | v0;\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long num_bytes_in_utf8_sequence_name_conflict(unsigned long a0) {\n  if ((char)a0 != 192 && (char)a0 != 193 && (char)a0 <= 244 &&\n      ((char)a0 & 192) != 128)\n    return ((char)a0 < 0 ? 1\n                         : (((char)a0 & 224) == 192\n                                ? (((char)a0 & 240) == 224\n                                       ? (((char)a0 & 248) == 240 ? 0 : 4)\n                                       : 3)\n                                : 2));\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(num_bytes_in_utf8_sequence)(long long);\n\nlong long verify_utf8_sequence_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  *(a1) = num_bytes_in_utf8_sequence(a0[0]);\n  if (*(a1) == 1) {\n    v0 = a0[0];\n  } else if (!(*(a1) != 2 || (a0[1] & 192) != 128)) {\n    v0 = a0[0] & 31;\n    v0 = a0[1] & 63 | v0 * 64;\n  } else if (*(a1) != 3 || (a0[1] & 192) != 128 || (a0[2] & 192) != 128) {\n    if (!(*(a1) == 4) || !((a0[1] & 192) == 128) || !((a0[2] & 192) == 128) ||\n        !((a0[3] & 192) == 128))\n      return 0;\n    v0 = a0[0] & 7;\n    v0 = a0[1] & 63 | v0 * 64;\n    v0 = a0[2] & 63 | v0 * 64;\n    v0 = a0[3] & 63 | v0 * 64;\n  } else {\n    v0 = a0[0] & 15;\n    v0 = a0[1] & 63 | v0 * 64;\n    v0 = a0[2] & 63 | v0 * 64;\n  }\n  if ((v0 > 127 || *(a1) <= 1) && (v0 > 2047 || *(a1) <= 2) &&\n      (!(v0 <= 65535) || !(*(a1) > 3))) {\n    if (v0 > 1114111)\n      return 0;\n    if (!(v0 > 55295 && v0 <= 57343))\n      return 1;\n    return 0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(verify_utf8_sequence)(long long, long long);\n\nlong long is_valid_utf8_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x20], Other Possible Types: unsigned long long\n  unsigned int v1;  // [bp-0x14]\n  unsigned long v2; // [bp-0x10]\n\n  v0 = a0;\n  v1 = 0;\n  for (v2 = a1 + v0; v0 < v2; v0 += v1) {\n    if (!(int)verify_utf8_sequence(v0, &v1))\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_decimal_name_conflict(unsigned long a0, char a1[3]) {\n  char v0[3]; // [bp-0x18], Other Possible Types: unsigned long\n  char v3[3]; // rax\n\n  *(&v0) = a1;\n  if (v0 > 1 && *((char *)a0) == 48 && *((char *)(a0 + 1)) != 46)\n    return 0;\n  if (v0 > 2 && !strncmp(a0, \"-0\", 2) && *((char *)(a0 + 2)) != 46)\n    return 0;\n  while (v3) {\n    v3 = v0;\n    v0 = &v3[1];\n    if (strchr(\"xX\", *((char *)(v0 + a0))))\n      return 0;\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpryv2_jqx/is_decimal_name_conflict.c:22:12: error: array type 'char[3]' is not\nassignable 22 |     *(&v0) = a1; |     ~~~~~~ ^\n/tmp/tmpryv2_jqx/is_decimal_name_conflict.c:29:12: error: array type 'char[3]' is not\nassignable 29 |         v3 = v0; |         ~~ ^\n/tmp/tmpryv2_jqx/is_decimal_name_conflict.c:30:12: error: array type 'char[3]' is not\nassignable 30 |         v0 = &v3[1]; |         ~~ ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nvoid(rewind)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_file(char *a0) {\n  char *v0;         // [bp-0x30]\n  unsigned long v1; // [bp-0x28]\n  char *v2;         // [bp-0x20], Other Possible Types: unsigned long\n  void *v3;         // [bp-0x18], Other Possible Types: unsigned int\n  FILE_t *v4;       // [bp-0x10]\n\n  v4 = &fopen(a0, \"r\")->_flags;\n  v3 = 0;\n  v2 = 0;\n  if (!v4)\n    return 0;\n  fseek(v4, 0, 2);\n  v1 = ftell(v4);\n  if ((char)(v1 - 0 >> 63)) {\n    fclose(v4);\n    return 0;\n  }\n  *((unsigned long *)&v3) = v1;\n  rewind(v4);\n  v0 = parson_malloc(*((long long *)&v3) + 1);\n  if (!v0) {\n    fclose(v4);\n    return 0;\n  }\n  v2 = fread(v0, 1, *((long long *)&v3), v4);\n  if (v2 && !ferror(v4)) {\n    fclose(v4);\n    v0[v2] = 0;\n    return v0;\n  }\n  fclose(v4);\n  parson_free(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpalv_au32/read_file.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpalv_au32/read_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpalv_au32/read_file.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpalv_au32/read_file.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmpalv_au32/read_file.c:251:13: error: declaration of anonymous union must\nbe a definition 251 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:254:22: error: type name requires a specifier or\nqualifier 254 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:258:13: error: declaration of anonymous union must\nbe a definition 258 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:261:22: error: type name requires a specifier or\nqualifier 261 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:194:7: error: conflicting types for 'rewind'\n  194 | void (rewind)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:723:13: note: previous declaration is here\n  723 | extern void rewind (FILE *__stream);\n      |             ^\n/tmp/tmpalv_au32/read_file.c:340:13: error: declaration of anonymous union must\nbe a definition 340 |             union <anon> { |             ^\n/tmp/tmpalv_au32/read_file.c:343:22: error: type name requires a specifier or\nqualifier 343 |             } __value; |                      ^\n/tmp/tmpalv_au32/read_file.c:347:13: error: declaration of anonymous union must\nbe a definition 347 |             union <anon> { |             ^ fatal error:\ntoo many errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long skip_quotes_name_conflict(struct struct_0 **a0) {\n  if (*(a0)->field_0 != 34)\n    return 4294967295;\n  for (*(a0) = *(a0) + 1; *(a0)->field_0 != 34; *(a0) = *(a0) + 1) {\n    if (!*(a0)->field_0) {\n      return 4294967295;\n    } else if (*(a0)->field_0 == 92) {\n      *(a0) = *(a0) + 1;\n      if (!*(a0)->field_0)\n        return 4294967295;\n    }\n  }\n  *(a0) = *(a0) + 1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:19:14: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 19 |     if (*(a0)->field_0 != 34) |\n~~~~^ ~~~~~~~ /tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:21:24: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 21 |     for (*(a0) = *(a0) + 1;\n*(a0)->field_0 != 34; *(a0) = *(a0) + 1) |                  ~~~~~ ^\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:21:34: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 21 |     for (*(a0) = *(a0) + 1;\n*(a0)->field_0 != 34; *(a0) = *(a0) + 1) |                              ~~~~^\n~~~~~~~ /tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:21:65: error: arithmetic on a pointer to\nan incomplete type 'struct struct_0' 21 |     for (*(a0) = *(a0) + 1;\n*(a0)->field_0 != 34; *(a0) = *(a0) + 1) | ~~~~~ ^\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:23:19: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 23 |         if (!*(a0)->field_0) |\n~~~~^ ~~~~~~~ /tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:27:23: error: member reference base\ntype 'struct struct_0 *' is not a structure or union 27 |         else if\n(*(a0)->field_0 == 92) |                   ~~~~^ ~~~~~~~\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:29:27: error: arithmetic on a pointer to an\nincomplete type 'struct struct_0' 29 |             *(a0) = *(a0) + 1; | ~~~~~ ^\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:17:30: note: forward declaration of 'struct\nstruct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^\n/tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:30:23: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 30 |             if (!*(a0)->field_0) |\n~~~~^ ~~~~~~~ /tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:34:19: error: arithmetic on a\npointer to an incomplete type 'struct struct_0' 34 |     *(a0) = *(a0) + 1; |\n~~~~~ ^ /tmp/tmpncmnf2p5/skip_quotes_name_conflict.c:17:30: note: forward declaration of\n'struct struct_0' 17 | long long skip_quotes_name_conflict(struct struct_0 **a0) | ^ 9 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16_name_conflict_hex)(long long, long long);\n\nlong long parse_utf16_name_conflict(struct struct_1 **a0, struct struct_0 **a1) {\n  char v0;         // [bp-0x28]\n  unsigned int v1; // [bp-0x24], Other Possible Types: char\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x1c]\n  char *v4;        // [bp-0x18], Other Possible Types: unsigned long\n  char v5[4];      // [bp-0x10], Other Possible Types: unsigned long\n  char *v8;        // rax\n  char *v9;        // rax\n\n  v3 = 0;\n  *((struct struct_0 **)&v5) = *(a1);\n  v4 = &*(a0)->field_0;\n  v4 += 1;\n  v3 = parse_utf16_name_conflict_hex(v4, &v1);\n  if (!v3)\n    return 4294967295;\n  if (*((int *)&v1) <= 127) {\n    v5[0] = *((int *)&v1);\n  } else if (*((int *)&v1) <= 2047) {\n    v5[0] = (unsigned int)(*((int *)&v1) >> 6) & 31 | -64;\n    v5[1] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[1];\n  } else if (*((int *)&v1) <= 55295 || *((int *)&v1) > 57343) {\n    v5[0] = (unsigned int)(*((int *)&v1) >> 12) & 15 | -32;\n    v5[1] = (unsigned int)(*((int *)&v1) >> 6) & 63 | -128;\n    v5[2] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[2];\n  } else {\n    if (!(*((int *)&v1) > 55295) || !(*((int *)&v1) <= 56319))\n      return 4294967295;\n    v2 = *((int *)&v1);\n    v4 += 4;\n    v8 = v4;\n    v4 = v8 + 1;\n    if (!(*(v8) == 92) ||\n        !((v9 = v4, v4 = (unsigned long)(v9 + 1), *(v9) == 117)))\n      return 4294967295;\n    v3 = parse_utf16_name_conflict_hex(v4, &v0);\n    if (!(v3) || !(*((int *)&v0) > 56319) || !(*((int *)&v0) <= 57343))\n      return 4294967295;\n    v1 = (*((int *)&v0) & 1023 | v2 * 0x400 & 0xffc00) + 0x10000;\n    v5[0] = (unsigned int)(*((int *)&v1) >> 18) & 7 | -0x10;\n    v5[1] = (unsigned int)(*((int *)&v1) >> 12) & 63 | -128;\n    v5[2] = (unsigned int)(*((int *)&v1) >> 6) & 63 | -128;\n    v5[3] = *((int *)&v1) & 63 | -128;\n    v5 = &v5[3];\n  }\n  v4 += 3;\n  *(a1) = v5;\n  *(a0) = v4;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpeki8u79e/parse_utf16_name_conflict.c:31:16: error: member reference base type 'struct\nstruct_1 *' is not a structure or union 31 |     v4 = &*(a0)->field_0; | ~~~~^\n~~~~~~~ /tmp/tmpeki8u79e/parse_utf16_name_conflict.c:44:12: error: array type 'char[4]' is not\nassignable 44 |         v5 = &v5[1]; |         ~~ ^\n/tmp/tmpeki8u79e/parse_utf16_name_conflict.c:51:12: error: array type 'char[4]' is not\nassignable 51 |         v5 = &v5[2]; |         ~~ ^\n/tmp/tmpeki8u79e/parse_utf16_name_conflict.c:71:12: error: array type 'char[4]' is not\nassignable 71 |         v5 = &v5[3]; |         ~~ ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[4268104];\n  unsigned int field_412048;\n} struct_0;\n\nextern char g_412048;\n\nlong long process_string_name_conflict(char *a0, unsigned long a1) {\n  char *v0;              // [bp-0x38], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x30], Other Possible Types: unsigned long\n  void *v2;              // [bp-0x28]\n  char *v3;              // [bp-0x20]\n  void *v4;              // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long long v5; // [bp-0x10]\n  unsigned int v7;       // eax\n\n  v1 = a0;\n  v5 = a1 + 1;\n  v4 = 0;\n  v3 = 0;\n  v0 = 0;\n  v2 = 0;\n  v3 = parson_malloc(v5);\n  if (!v3) {\n    goto LABEL_402b84;\n  } else {\n    v0 = v3;\n    while (true) {\n      if (!*(v1) || v1 - a0 >= a1) {\n        *((char *)v0) = 0;\n        v4 = 1 + v0 - v3;\n        v2 = parson_malloc(v4);\n        if (v2) {\n          memcpy(v2, v3, v4);\n          parson_free(v3);\n          return v2;\n        }\n        break;\n      } else {\n        if (*(v1) == 92) {\n          v1 += 1;\n          v7 = *((char *)v1);\n          switch (v7) {\n          case 92:\n            *(v0) = 92;\n            break;\n          case 93:\n          case 94:\n          case 95:\n          case 96:\n          case 97:\n          case 99:\n          case 100:\n          case 101:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 111:\n          case 112:\n          case 113:\n          case 115:\n          LABEL_402b84:\n            parson_free(v3);\n            return 0;\n          case 98:\n            *(v0) = 8;\n            break;\n          case 102:\n            *(v0) = 12;\n            break;\n          case 110:\n            *(v0) = 10;\n            break;\n          case 114:\n            *(v0) = 13;\n            break;\n          case 116:\n            *(v0) = 9;\n            break;\n          case 117:\n            if ((int)parse_utf16(&v1, &v0) == -1) {\n              parson_free(v3);\n              return 0;\n            }\n          default:\n          LABEL_402b84:\n            parson_free(v3);\n            return 0;\n          }\n        } else if (*(v1) > 31) {\n          *(v0) = *(v1);\n        } else {\n          break;\n        }\n        v0 += 1;\n        v1 += 1;\n      }\n    }\n  }\n  parson_free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_jn4ke8d/process_string_name_conflict.c:101:1: error: redefinition of label\n'LABEL_402b84' 101 | LABEL_402b84: | ^ /tmp/tmp_jn4ke8d/process_string_name_conflict.c:76:1:\nnote: previous definition is here 76 | LABEL_402b84: | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(skip_quotes)(long long);\nlong long(process_string)(long long, long long);\n\nlong long get_quoted_string_name_conflict(unsigned long long *a0) {\n  unsigned int v0;  // [bp-0x1c]\n  void *v1;         // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned long v2; // [bp-0x10]\n\n  v2 = *(a0);\n  v1 = 0;\n  v0 = skip_quotes(a0);\n  if (!v0) {\n    v1 = *(a0)-v2 - 2;\n    return process_string(v2 + 1, v1);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[4268628];\n  unsigned int field_412254;\n} struct_0;\n\nextern char g_412254;\n\nlong long json_serialize_string_name_conflict(char *a0, char *a1) {\n  char *v0;         // [bp-0x38], Other Possible Types: unsigned long\n  unsigned int v1;  // [bp-0x28]\n  char v2;          // [bp-0x21]\n  unsigned long v3; // [bp-0x20]\n  unsigned int v4;  // [bp-0x14]\n  char *v5;         // [bp-0x10], Other Possible Types: unsigned long\n  struct_0 *v8;     // rax\n\n  v0 = a1;\n  v5 = 0;\n  v3 = strlen(a0);\n  v2 = 0;\n  v1 = -1;\n  v4 = 0;\n  v1 = append_string(v0, \"\\\"\");\n  if (v1 < 0)\n    return 4294967295;\n  if (v0)\n    v0 = &v0[v1];\n  v4 += v1;\n  for (v5 = 0; v5 < v3; v5 += 1) {\n    v2 = a0[v5];\n    v8 = v2;\n    switch ((unsigned int)v8) {\n    case 0:\n      v1 = append_string(v0, \"\\\\u0000\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 1:\n      v1 = append_string(v0, \"\\\\u0001\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 2:\n      v1 = append_string(v0, \"\\\\u0002\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 3:\n      v1 = append_string(v0, \"\\\\u0003\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 4:\n      v1 = append_string(v0, \"\\\\u0004\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 5:\n      v1 = append_string(v0, \"\\\\u0005\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 6:\n      v1 = append_string(v0, \"\\\\u0006\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 7:\n      v1 = append_string(v0, \"\\\\u0007\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 8:\n      v1 = append_string(v0, \"\\\\b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 9:\n      v1 = append_string(v0, \"\\\\t\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 10:\n      v1 = append_string(v0, \"\\\\n\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 11:\n      v1 = append_string(v0, \"\\\\u000b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 12:\n      v1 = append_string(v0, \"\\\\f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 13:\n      v1 = append_string(v0, \"\\\\r\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 14:\n      v1 = append_string(v0, \"\\\\u000e\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 15:\n      v1 = append_string(v0, \"\\\\u000f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 16:\n      v1 = append_string(v0, \"\\\\u0010\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 17:\n      v1 = append_string(v0, \"\\\\u0011\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 18:\n      v1 = append_string(v0, \"\\\\u0012\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 19:\n      v1 = append_string(v0, \"\\\\u0013\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 20:\n      v1 = append_string(v0, \"\\\\u0014\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 21:\n      v1 = append_string(v0, \"\\\\u0015\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 22:\n      v1 = append_string(v0, \"\\\\u0016\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 23:\n      v1 = append_string(v0, \"\\\\u0017\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 24:\n      v1 = append_string(v0, \"\\\\u0018\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 25:\n      v1 = append_string(v0, \"\\\\u0019\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 26:\n      v1 = append_string(v0, \"\\\\u001a\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 27:\n      v1 = append_string(v0, \"\\\\u001b\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 28:\n      v1 = append_string(v0, \"\\\\u001c\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 29:\n      v1 = append_string(v0, \"\\\\u001d\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 30:\n      v1 = append_string(v0, \"\\\\u001e\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 31:\n      v1 = append_string(v0, \"\\\\u001f\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 34:\n      v1 = append_string(v0, \"\\\\\\\"\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 47:\n      v1 = append_string(v0, \"\\\\/\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    case 92:\n      v1 = append_string(v0, \"\\\\\\\\\");\n      if (v1 < 0)\n        return 4294967295;\n      if (v0)\n        v0 = &v0[v1];\n      v4 += v1;\n      break;\n    default:\n      if (v0) {\n        *((char *)v0) = v2;\n        v0 += 1;\n      }\n      v4 += 1;\n      break;\n    }\n  }\n  v1 = append_string(v0, \"\\\"\");\n  if (v1 < 0)\n    return 4294967295;\n  if (v0)\n    v0 = &v0[v1];\n  v4 += v1;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpje3c69pz/json_serialize_string_name_conflict.c:49:16: error: array subscript is not an\ninteger 49 |         v2 = a0[v5]; |                ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long append_indent_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x20], Other Possible Types: unsigned long long\n  unsigned int v1;  // [bp-0x14]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n\n  v0 = a0;\n  v1 = -1;\n  v2 = 0;\n  for (v3 = 0; v3 < (unsigned int)a1; v3 += 1) {\n    v1 = append_string(v0, \"    \");\n    if (v1 < 0)\n      return 4294967295;\n    if (v0)\n      v0 += v1;\n    v2 += v1;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long append_string_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0) {\n    (unsigned int)v1 = sprintf(a0, \"%s\", (unsigned int)a1);\n    return v1;\n  }\n  v1 = strlen(a1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbbedu9qy/append_string_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = sprintf(a0, \"%s\",\n(unsigned int)a1); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"int io_signal(int fd, int sig) {\n    int flags;\n    if (fcntl(fd, 10, sig) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set signal %d on fd %d: %s\\n\", __func__, 11, sig, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 8, getpid()) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set process as owner of fd %d: %s\\n\", __func__, 15, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    flags = fcntl(fd, 3);\n    if (flags == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to get flags of fd %d: %s\\n\", __func__, 20, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 4, flags | 8192 | 2048) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to enable I/O signaling for fd %d: %s\\n\", __func__, 24, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\nchar *(strerror)(int);\n\nextern char __func__ .1;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long io_signal_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                // [bp-0x1c]\n  unsigned int v1;        // [bp-0xc]\n  unsigned long long v4;  // rax\n  unsigned long long v6;  // rax\n  unsigned long long v8;  // rax\n  unsigned long long v10; // rax\n\n  if (fcntl(a0, 10) == -1) {\n    (unsigned int)v4 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to set signal %d on fd %d: %s\\n\", &__func__ .1,\n            10, (unsigned int)a1, *((int *)&v0), (unsigned int)v4);\n    return 1;\n  }\n  getpid();\n  if (fcntl(*((int *)&v0), 8) == -1) {\n    (unsigned int)v6 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to set process as owner of fd %d: %s\\n\",\n            &__func__ .1, 14, *((int *)&v0), (unsigned int)v6);\n    return 1;\n  }\n  v1 = fcntl(*((int *)&v0), 3);\n  if (v1 == -1) {\n    (unsigned int)v8 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to get flags of fd %d: %s\\n\", &__func__ .1, 19,\n            *((int *)&v0), (unsigned int)v8);\n    return 1;\n  } else if (fcntl(*((int *)&v0), 4) == -1) {\n    (unsigned int)v10 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to enable I/O signaling for fd %d: %s\\n\",\n            &__func__ .1, 23, *((int *)&v0), (unsigned int)v10);\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:19:13: error: expected identifier or '('\n   19 | extern char __func__.1;\n      |             ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 20 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:20:22: error: expected ';' after top level\ndeclarator 20 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:33:37: error: indirection requires pointer operand\n('int' invalid) 33 |         (unsigned int)v4 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:34:23: error: expected ')'\n   34 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set signal\n%d on fd %d: %s\\n\", &__func__.1, 10, (unsigned int)a1, *((int *)&v0), (unsigned\nint)v4); |                       ^ /tmp/tmp_4v09a58/io_signal_name_conflict.c:34:16: note: to\nmatch this '(' 34 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to\nset signal %d on fd %d: %s\\n\", &__func__.1, 10, (unsigned int)a1, *((int *)&v0),\n(unsigned int)v4); |                ^ /tmp/tmp_4v09a58/io_signal_name_conflict.c:40:37: error:\nindirection requires pointer operand ('int' invalid) 40 |         (unsigned\nint)v6 = strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:41:23: error: expected ')'\n   41 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set process\nas owner of fd %d: %s\\n\", &__func__.1, 14, *((int *)&v0), (unsigned int)v6); | ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:41:16: note: to match this '('\n   41 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set process\nas owner of fd %d: %s\\n\", &__func__.1, 14, *((int *)&v0), (unsigned int)v6); | ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:47:37: error: indirection requires pointer operand\n('int' invalid) 47 |         (unsigned int)v8 = strerror(*(__errno_location()));\n      |                                     ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:48:23: error: expected ')'\n   48 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to get flags of\nfd %d: %s\\n\", &__func__.1, 19, *((int *)&v0), (unsigned int)v8); | ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:48:16: note: to match this '('\n   48 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to get flags of\nfd %d: %s\\n\", &__func__.1, 19, *((int *)&v0), (unsigned int)v8); | ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:53:38: error: indirection requires pointer operand\n('int' invalid) 53 |         (unsigned int)v10 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:54:23: error: expected ')'\n   54 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to enable I/O\nsignaling for fd %d: %s\\n\", &__func__.1, 23, *((int *)&v0), (unsigned int)v10);\n      |                       ^\n/tmp/tmp_4v09a58/io_signal_name_conflict.c:54:16: note: to match this '('\n   54 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to enable I/O\nsignaling for fd %d: %s\\n\", &__func__.1, 23, *((int *)&v0), (unsigned int)v10);\n      |                ^\n11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static ssize_t read_nonblock(int fd, char *buf, size_t size) {\n    ssize_t nr;\n    nr = read(fd, buf, size);\n    if (nr == -1) {\n        if ((*__errno_location()) == 11) {\n            return 0;\n        }\n        fprintf(stderr, \"ERROR %s:%d: read from %d: %s\\n\", __func__, 38, fd, strerror((*__errno_location())));\n        return -1;\n    }\n    return nr;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nchar *(strerror)(int);\n\nextern char __func__ .0;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_nonblock_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  char v0;               // [bp-0x1c]\n  unsigned long v1;      // [bp-0x10]\n  unsigned long long v6; // rax\n\n  v1 = read(a0, a1, a2);\n  if (v1 != -1) {\n    return v1;\n  } else if (*(__errno_location()) != 11) {\n    (unsigned int)v6 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: read from %d: %s\\n\",\n            &__func__ .0, 37, *((int *)&v0), (unsigned int)v6);\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:19:13: error: expected identifier or '('\n   19 | extern char __func__.0;\n      |             ^\n/tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 20 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:20:22: error: expected ';' after top level\ndeclarator 20 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:33:14: error: indirection requires pointer\noperand ('int' invalid) 33 |     else if (*(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:35:37: error: indirection\nrequires pointer operand ('int' invalid) 35 |         (unsigned int)v6 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:36:23: error: expected ')'\n   36 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: read from %d: %s\\n\",\n&__func__.0, 37, *((int *)&v0), (unsigned int)v6); |                       ^\n/tmp/tmp4njd8nxs/read_nonblock_name_conflict.c:36:16: note: to match this '('\n   36 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: read from %d: %s\\n\",\n&__func__.0, 37, *((int *)&v0), (unsigned int)v6); |                ^ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"int io_readline(int fd, char *buffer, size_t size) {\n    int nr = 0;\n    char c;\n    while (nr < size && read_nonblock(fd, &c, 1) > 0 && c != '\\n')\n        buffer[nr++] = c;\n    return nr;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(read_nonblock)(long long, long long, long long);\n\nlong long io_readline_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n  char *v3;        // rax\n\n  for (v1 = 0; v1 < a2; v3[a1] = v0) {\n    if (read_nonblock((unsigned int)a0, &v0, 1) <= 0)\n      return v1;\n    if (v0 == 10)\n      return v1;\n    v3 = v1;\n    v1 = (unsigned int)v3 + 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static inline bool is_number(const char *str) {\n    char *end;\n    strtoul(str, &end, 10);\n    return !(*str == 0 || *end != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtoul)(char *, char *, char *);\n\nlong long is_number_name_conflict(char *a0) {\n  char v0;               // [bp-0x10]\n  unsigned int v2;       // eax\n  unsigned long long v3; // rax\n\n  strtoul(a0, &v0, 0xa);\n  if (!*(a0) || *((char *)*((long long *)&v0)))\n    v2 = 0;\n  else\n    v2 = 1;\n  v3 = v2 & 1;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/json.c"}
{"compilable":0,"function":"static int parse_section(const char *line, char *name, unsigned int size) {\n    char *closing = strchr(line, ']');\n    const int len = strlen(line);\n    if (!closing || line + len - 1 != closing) {\n        fprintf(stderr, \"ERROR %s:%d: malformated section \\\"%s\\\"\\n\", __func__, 33, line);\n        return 1;\n    }\n    if (size - 1 < len - 2) {\n        fprintf(stderr, \"ERROR %s:%d: section name too long \\\"%s\\\"\\n\", __func__, 37, line);\n        return 1;\n    }\n    memcpy(name, line + 1, len - 2);\n    name[len - 2] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char __func__ .3;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long parse_section_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned long v1; // [bp-0x10]\n\n  v1 = strchr(a0, 93);\n  v0 = strlen(a0);\n  if (v1 && v1 == &a0[1 + v0]) {\n    if ((unsigned int)a2 - 1 < v0 - 2) {\n      fprintf(stderr @GLIBC_2.2.5,\n              \"ERROR %s:%d: section name too long \\\"%s\\\"\\n\", &__func__ .3, 36,\n              (unsigned int)a0);\n      return 1;\n    }\n    memcpy(a1, a0 + 1, v0 - 2);\n    a1[2 + v0] = 0;\n    return 0;\n  }\n  fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: malformated section \\\"%s\\\"\\n\",\n          &__func__ .3, 32, (unsigned int)a0);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:17:13: error: expected identifier or '('\n   17 | extern char __func__.3;\n      |             ^\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:31:27: error: expected ')'\n   31 |             fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: section name too\nlong \\\"%s\\\"\\n\", &__func__.3, 36, (unsigned int)a0); | ^\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:31:20: note: to match this '('\n   31 |             fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: section name too\nlong \\\"%s\\\"\\n\", &__func__.3, 36, (unsigned int)a0); |                    ^\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:38:19: error: expected ')'\n   38 |     fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: malformated section\n\\\"%s\\\"\\n\", &__func__.3, 32, (unsigned int)a0); |                   ^\n/tmp/tmpfo_a5825/parse_section_name_conflict.c:38:12: note: to match this '('\n   38 |     fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: malformated section\n\\\"%s\\\"\\n\", &__func__.3, 32, (unsigned int)a0); |            ^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int parse_property(const char *line, struct properties *props, bool strict) {\n    char *equal = strchr(line, '=');\n    const char *key, *value;\n    if (!equal) {\n        fprintf(stderr, \"ERROR %s:%d: malformated property, should be a key=value pair\\n\", __func__, 50);\n        return 1;\n    }\n    *equal = '\\x00';\n    key = line;\n    value = equal + 1;\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"full_text\") == 0) {\n        strncpy(props->full_text, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"short_text\") == 0) {\n        strncpy(props->short_text, value, 512 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"color\") == 0) {\n        strncpy(props->color, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2 | 4) & 1) && strcmp(key, \"min_width\") == 0) {\n        strncpy(props->min_width, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"align\") == 0) {\n        strncpy(props->align, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"name\") == 0) {\n        strncpy(props->name, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"instance\") == 0) {\n        strncpy(props->instance, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"urgent\") == 0) {\n        strncpy(props->urgent, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"separator\") == 0) {\n        strncpy(props->separator, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 4) & 1) && strcmp(key, \"separator_block_width\") == 0) {\n        strncpy(props->separator_block_width, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"markup\") == 0) {\n        strncpy(props->markup, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"command\") == 0) {\n        strncpy(props->command, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"interval\") == 0) {\n        strncpy(props->interval, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (4) & 1) && strcmp(key, \"signal\") == 0) {\n        strncpy(props->signal, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"label\") == 0) {\n        strncpy(props->label, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"format\") == 0) {\n        strncpy(props->format, value, 8 - 1);\n        return 0;\n    }\n    ;\n    fprintf(stderr, \"ERROR %s:%d: unknown key: \\\"%s\\\"\\n\", __func__, 63, key);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nextern char __func__ .2;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long parse_property_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char *v0; // [bp-0x20]\n  char *v1; // [bp-0x10]\n\n  v1 = strchr(a0, 61);\n  if (!v1) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: malformated property, should be a key=value pair\\n\",\n            &__func__ .2, 49);\n    return 1;\n  }\n  *(v1) = 0;\n  v0 = v1 + 1;\n  if (!strcmp(a0, \"full_text\")) {\n    strncpy(a1, v0, 1023);\n    return 0;\n  } else if (!strcmp(a0, \"short_text\")) {\n    strncpy(a1 + 0x400, v0, 511);\n    return 0;\n  } else if (!strcmp(a0, \"color\")) {\n    strncpy(a1 + 0x600, v0, 7);\n    return 0;\n  } else if (!strcmp(a0, \"min_width\")) {\n    strncpy(a1 + 1544, v0, 1023);\n    return 0;\n  } else if (!strcmp(a0, \"align\")) {\n    strncpy(a1 + 2568, v0, 7);\n    return 0;\n  } else if (!strcmp(a0, \"name\")) {\n    strncpy(a1 + 2576, v0, 31);\n    return 0;\n  } else if (!strcmp(a0, \"instance\")) {\n    strncpy(a1 + 2608, v0, 31);\n    return 0;\n  } else if (!strcmp(a0, \"urgent\")) {\n    strncpy(a1 + 2640, v0, 7);\n    return 0;\n  } else if (!strcmp(a0, \"separator\")) {\n    strncpy(a1 + 2648, v0, 7);\n    return 0;\n  } else if (!strcmp(a0, \"separator_block_width\")) {\n    strncpy(a1 + 2656, v0, 7);\n    return 0;\n  } else if (!strcmp(a0, \"markup\")) {\n    strncpy(a1 + 2664, v0, 7);\n    return 0;\n  } else {\n    if ((char)((unsigned int)a2 ^ 1) && !strcmp(a0, \"command\")) {\n      strncpy(a1 + 2672, v0, 1023);\n      return 0;\n    }\n    if ((char)((unsigned int)a2 ^ 1) && !strcmp(a0, \"interval\")) {\n      strncpy(a1 + 3696, v0, 7);\n      return 0;\n    }\n    if ((char)((unsigned int)a2 ^ 1) && !strcmp(a0, \"signal\")) {\n      strncpy(a1 + 3704, v0, 7);\n      return 0;\n    }\n    if ((char)((unsigned int)a2 ^ 1) && !strcmp(a0, \"label\")) {\n      strncpy(a1 + 3712, v0, 31);\n      return 0;\n    }\n    if ((char)((unsigned int)a2 ^ 1) && !strcmp(a0, \"format\")) {\n      strncpy(a1 + 3744, v0, 7);\n      return 0;\n    }\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: unknown key: \\\"%s\\\"\\n\",\n            &__func__ .2, 62, (unsigned int)a0);\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpob4xv864/parse_property_name_conflict.c:18:13: error: expected identifier or '('\n   18 | extern char __func__.2;\n      |             ^\n/tmp/tmpob4xv864/parse_property_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpob4xv864/parse_property_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpob4xv864/parse_property_name_conflict.c:29:23: error: expected ')'\n   29 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: malformated property,\nshould be a key=value pair\\n\", &__func__.2, 49); |                       ^\n/tmp/tmpob4xv864/parse_property_name_conflict.c:29:16: note: to match this '('\n   29 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: malformated property,\nshould be a key=value pair\\n\", &__func__.2, 49); |                ^\n/tmp/tmpob4xv864/parse_property_name_conflict.c:116:23: error: expected ')'\n  116 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: unknown key:\n\\\"%s\\\"\\n\", &__func__.2, 62, (unsigned int)a0); |                       ^\n/tmp/tmpob4xv864/parse_property_name_conflict.c:116:16: note: to match this '('\n  116 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: unknown key:\n\\\"%s\\\"\\n\", &__func__.2, 62, (unsigned int)a0); |                ^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int gcd(int a, int b) {\n    while (b != 0)\n        a %= b , a ^= b , b ^= a , a ^= b;\n    return a;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long gcd_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = a0;\n  for (v0 = a1; v0; v1 ^= v0) {\n    v1 = (v1 >> 31 CONCAT v1) / m v0 >> 32;\n    v1 ^= v0;\n    v0 ^= v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpc53hw4pg/gcd_name_conflict.c:26:24: error: expected ')'\n   26 |         v1 = (v1 >> 31 CONCAT v1) /m v0 >> 32;\n      |                        ^\n/tmp/tmpc53hw4pg/gcd_name_conflict.c:26:14: note: to match this '('\n   26 |         v1 = (v1 >> 31 CONCAT v1) /m v0 >> 32;\n      |              ^\n/tmp/tmpc53hw4pg/gcd_name_conflict.c:26:37: error: expected ';' after expression\n   26 |         v1 = (v1 >> 31 CONCAT v1) /m v0 >> 32;\n      |                                     ^\n      |                                     ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":0,"function":"static int setup_signals(void) {\n    if (sigemptyset(&sigset) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigemptyset: %s\\n\", __func__, 59, strerror((*__errno_location())));\n        return 1;\n    }\n    if (sigaddset(&sigset, 15) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 64, 15, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 2) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 65, 2, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 14) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 66, 14, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 17) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 67, 17, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 10) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 68, 10, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 12) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 69, 12, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 29) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 70, 29, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, (__libc_current_sigrtmin())) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 71, (__libc_current_sigrtmin()), strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    for (int sig = (__libc_current_sigrtmin()) + 1; sig <= (__libc_current_sigrtmax()); ++sig) {\n        if (log_level >= LOG_DEBUG) {\n            fprintf(stderr, \"DEBUG %s:%d: provide signal %d (%s)\\n\", __func__, 73, sig, strsignal(sig));\n        }\n        ;\n        if (sigaddset(&sigset, sig) == -1) {\n            fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 74, sig, strerror((*__errno_location())));\n            return 1;\n        }\n        ;\n    }\n    if (sigprocmask(2, &sigset, ((void *)0)) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigprocmask: %s\\n\", __func__, 78, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(strerror)(int);\nint(sigprocmask)(int, int *, int *);\n\nextern char __func__ .1;\nextern unsigned int log_level;\nextern unsigned int sigset;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long setup_signals_name_conflict() {\n  unsigned int v0;        // [bp-0x1c]\n  unsigned long v1;       // [bp-0x10]\n  char v2;                // [bp-0x8]\n  unsigned long long v4;  // rbp\n  unsigned long v5;       // rbx\n  unsigned long long v7;  // rax\n  unsigned long long v9;  // rax\n  unsigned long long v11; // rax\n  unsigned long long v14; // rax\n  unsigned long long v16; // rax\n  unsigned long long v18; // rax\n  unsigned long long v20; // rax\n  unsigned long long v22; // rax\n  unsigned int v23;       // esi\n  unsigned int v24;       // eax\n  unsigned long long v26; // rdx\n  unsigned long long v27; // rcx\n  unsigned long long v28; // r8\n  unsigned long long v29; // r9\n  unsigned long long v31; // rax\n  unsigned long long v33; // rax\n\n  v4 = &v2;\n  v1 = v5;\n  if (sigemptyset(&sigset) == -1) {\n    (unsigned int)v7 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigemptyset: %s\\n\", &__func__ .1,\n            58, (unsigned int)v7);\n    return 1;\n  } else if (sigaddset(&sigset, 15) == -1) {\n    (unsigned int)v9 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 63, 15, (unsigned int)v9);\n    return 1;\n  } else if (sigaddset(&sigset, 2) == -1) {\n    (unsigned int)v11 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 64, 2, (unsigned int)v11);\n    return 1;\n  } else if (sigaddset(&sigset, 14) == -1) {\n    (unsigned int)v14 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 65, 14, (unsigned int)v14);\n    return 1;\n  } else if (sigaddset(&sigset, 17) == -1) {\n    (unsigned int)v16 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 66, 17, (unsigned int)v16);\n    return 1;\n  } else if (sigaddset(&sigset, 10) == -1) {\n    (unsigned int)v18 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 67, 10, (unsigned int)v18);\n    return 1;\n  } else if (sigaddset(&sigset, 12) == -1) {\n    (unsigned int)v20 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 68, 12, (unsigned int)v20);\n    return 1;\n  } else if (sigaddset(&sigset, 29) != -1) {\n    v23 = __libc_current_sigrtmin();\n    if (sigaddset(&sigset, v23) == -1) {\n      v24 = *(__errno_location());\n      fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n              &__func__ .1, 70,\n              __libc_current_sigrtmin(v24, *((unsigned long long *)&v23), v26,\n                                      v27, v28, v29),\n              (unsigned int)strerror(v24));\n      return 1;\n    }\n    for (v0 = __libc_current_sigrtmin() + 1; v0 <= __libc_current_sigrtmax();\n         v0 += 1) {\n      if (log_level > 1)\n        fprintf(stderr @GLIBC_2.2.5, \"DEBUG %s:%d: provide signal %d (%s)\\n\",\n                &__func__ .1, 72, v0, (unsigned int)strsignal(v0));\n      if (sigaddset(&sigset, v0) == -1) {\n        (unsigned int)v31 = strerror(*(__errno_location()));\n        fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n                &__func__ .1, 73, v0, (unsigned int)v31);\n        return 1;\n      }\n    }\n    if (sigprocmask(2, &sigset, NULL) != -1)\n      return 0;\n    (unsigned int)v33 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigprocmask: %s\\n\", &__func__ .1,\n            77, (unsigned int)v33);\n    return 1;\n  } else {\n    (unsigned int)v22 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n            &__func__ .1, 69, 29, (unsigned int)v22);\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:20:13: error: expected identifier or '('\n   20 | extern char __func__.1;\n      |             ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:23:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 23 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:23:22: error: expected ';' after top level\ndeclarator 23 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:53:37: error: indirection requires pointer\noperand ('int' invalid) 53 |         (unsigned int)v7 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:54:23: error: expected ')'\n   54 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigemptyset: %s\\n\",\n&__func__.1, 58, (unsigned int)v7); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:54:16: note: to match this '('\n   54 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigemptyset: %s\\n\",\n&__func__.1, 58, (unsigned int)v7); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:59:37: error: indirection requires pointer\noperand ('int' invalid) 59 |         (unsigned int)v9 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:60:23: error: expected ')'\n   60 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 63, 15, (unsigned int)v9); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:60:16: note: to match this '('\n   60 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 63, 15, (unsigned int)v9); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:65:38: error: indirection requires pointer\noperand ('int' invalid) 65 |         (unsigned int)v11 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:66:23: error: expected ')'\n   66 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 64, 2, (unsigned int)v11); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:66:16: note: to match this '('\n   66 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 64, 2, (unsigned int)v11); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:71:38: error: indirection requires pointer\noperand ('int' invalid) 71 |         (unsigned int)v14 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:72:23: error: expected ')'\n   72 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 65, 14, (unsigned int)v14); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:72:16: note: to match this '('\n   72 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 65, 14, (unsigned int)v14); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:77:38: error: indirection requires pointer\noperand ('int' invalid) 77 |         (unsigned int)v16 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:78:23: error: expected ')'\n   78 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 66, 17, (unsigned int)v16); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:78:16: note: to match this '('\n   78 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 66, 17, (unsigned int)v16); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:83:38: error: indirection requires pointer\noperand ('int' invalid) 83 |         (unsigned int)v18 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:84:23: error: expected ')'\n   84 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 67, 10, (unsigned int)v18); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:84:16: note: to match this '('\n   84 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 67, 10, (unsigned int)v18); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:89:38: error: indirection requires pointer\noperand ('int' invalid) 89 |         (unsigned int)v20 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:90:23: error: expected ')'\n   90 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 68, 12, (unsigned int)v20); |                       ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:90:16: note: to match this '('\n   90 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d): %s\\n\",\n&__func__.1, 68, 12, (unsigned int)v20); |                ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:98:19: error: indirection requires pointer\noperand ('int' invalid) 98 |             v24 = *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpsxtpsi04/setup_signals_name_conflict.c:99:27: error: expected\n')' 99 |             fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d):\n%s\\n\", &__func__.1, 70, __libc_current_sigrtmin(v24, *((unsigned long long\n*)&v23), v26, v27, v28, v29), (unsigned int)strerror(v24)); | ^\n/tmp/tmpsxtpsi04/setup_signals_name_conflict.c:99:20: note: to match this '('\n   99 |             fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: sigaddset(%d):\n%s\\n\", &__func__.1, 70, __libc_current_sigrtmin(v24, *((unsigned long long\n*)&v23), v26, v27, v28, v29), (unsigned int)strerror(v24)); | ^ fatal error: too\nmany errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":1,"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    while (low < high)\n        {\n            mid = (low + high) / 2;\n            if (x <= v[mid])\n                high = mid;\n            else\n                low = mid + 1;\n        }\n    return x == v[low] ? low : -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long binsearch_name_conflict(unsigned long a0, unsigned int *a1, unsigned long a2) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = (unsigned int)a2 - 1;\n  while (v2 < v1) {\n    v0 = v1 + v2 + (v1 + v2 >> 31) >> 1;\n    if ((unsigned int)a0 <= a1[v0])\n      v1 = v0;\n    else\n      v2 = v0 + 1;\n  }\n  return ((unsigned int)a0 == a1[v2] ? 4294967295 : v2);\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch3/bsearch.c"}
{"compilable":0,"function":"static int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(getch)();\nlong long(ungetch)(long long);\n\nlong long getword_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x34], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x30], Other Possible Types: unsigned long\n  unsigned int v2;       // [bp-0x1c]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rbx\n  unsigned short *v8;    // rbx\n  char *v9;              // rax\n  unsigned int v11;      // eax\n  unsigned short *v12;   // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v1 = a0;\n  v0 = a1;\n  do {\n    v8 = *((long long *)&__ctype_b_loc());\n    v2 = getch();\n  } while ((v8[v2] & 0x2000));\n  if (v2 != -1) {\n    v9 = v1;\n    v1 = v9 + 1;\n    *(v9) = v2;\n  }\n  v11 = *((short *)(*((long long *)&__ctype_b_loc()) + v2 * 2)) & 0x400;\n  if (!v11) {\n    *((char *)v1) = 0;\n    return v2;\n  }\n  while (true) {\n    v0 = (int)v0 - 1;\n    if (v0 <= 0)\n      break;\n    v12 = *((long long *)&__ctype_b_loc());\n    *((char *)v1) = getch();\n    if (((char)v12[*((char *)v1)] & 8)) {\n      v1 += 1;\n    } else {\n      ungetch(*((char *)v1));\n      break;\n    }\n  }\n  *((char *)v1) = 0;\n  return *((char *)v1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu75ako1i/getword_name_conflict.c:39:29: error: cannot take the address of an rvalue of\ntype 'int' 39 |         v8 = *((long long *)&__ctype_b_loc()); |\n^~~~~~~~~~~~~~~~ /tmp/tmpu75ako1i/getword_name_conflict.c:48:38: error: cannot take the\naddress of an rvalue of type 'int' 48 |     v11 = *((short *)(*((long long\n*)&__ctype_b_loc()) + v2 * 2)) & 0x400; | ^~~~~~~~~~~~~~~~\n/tmp/tmpu75ako1i/getword_name_conflict.c:59:30: error: cannot take the address of an rvalue of\ntype 'int' 59 |         v12 = *((long long *)&__ctype_b_loc()); |\n^~~~~~~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":0,"function":"static int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getch_name_conflictar)();\n\nextern char buffer;\nextern unsigned int bufp;\n\nlong long getch_name_conflict() {\n  if (bufp <= 0)\n    return getch_name_conflictar();\n  bufp = bufp - 1;\n  return *((int *)&(&buffer)[4 * bufp]);\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":0,"function":"int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getch_name_conflictar)();\n\nextern char buffer;\nextern unsigned int bufp;\n\nlong long getch_name_conflict() {\n  if (bufp <= 0)\n    return getch_name_conflictar();\n  bufp = bufp - 1;\n  return *((int *)&(&buffer)[4 * bufp]);\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(getch)();\nlong long(ungetch)(long long);\n\nlong long getword_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x34], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x30], Other Possible Types: unsigned long\n  unsigned int v2;       // [bp-0x1c]\n  unsigned long v3;      // [bp-0x10]\n  char v4;               // [bp-0x8]\n  unsigned long long v6; // rbp\n  unsigned long v7;      // rbx\n  unsigned short *v8;    // rbx\n  char *v9;              // rax\n  unsigned int v11;      // eax\n  unsigned short *v12;   // rbx\n\n  v6 = &v4;\n  v3 = v7;\n  v1 = a0;\n  v0 = a1;\n  do {\n    v8 = *((long long *)&__ctype_b_loc());\n    v2 = getch();\n  } while ((v8[v2] & 0x2000));\n  if (v2 != -1) {\n    v9 = v1;\n    v1 = v9 + 1;\n    *(v9) = v2;\n  }\n  v11 = *((short *)(*((long long *)&__ctype_b_loc()) + v2 * 2)) & 0x400;\n  if (!v11) {\n    *((char *)v1) = 0;\n    return v2;\n  }\n  while (true) {\n    v0 = (int)v0 - 1;\n    if (v0 <= 0)\n      break;\n    v12 = *((long long *)&__ctype_b_loc());\n    *((char *)v1) = getch();\n    if (((char)v12[*((char *)v1)] & 8)) {\n      v1 += 1;\n    } else {\n      ungetch(*((char *)v1));\n      break;\n    }\n  }\n  *((char *)v1) = 0;\n  return *((char *)v1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6l_chbr_/getword_name_conflict.c:39:29: error: cannot take the address of an rvalue of\ntype 'int' 39 |         v8 = *((long long *)&__ctype_b_loc()); |\n^~~~~~~~~~~~~~~~ /tmp/tmp6l_chbr_/getword_name_conflict.c:48:38: error: cannot take the\naddress of an rvalue of type 'int' 48 |     v11 = *((short *)(*((long long\n*)&__ctype_b_loc()) + v2 * 2)) & 0x400; | ^~~~~~~~~~~~~~~~\n/tmp/tmp6l_chbr_/getword_name_conflict.c:59:30: error: cannot take the address of an rvalue of\ntype 'int' 59 |         v12 = *((long long *)&__ctype_b_loc()); |\n^~~~~~~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"char *_strdup(char *word) {\n    char *p = (char *)malloc(strlen(word) + 1);\n    p = strcpy(p, word);\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _strdup_name_conflict(char *a0) {\n  char *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = malloc(strlen(a0) + 1);\n  v0 = strcpy(v0, a0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getchar)();\n\nlong long get_line_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rax\n\n  v4 = &v2;\n  for (v0 = 0; v0 < (unsigned int)a1 - 1 && v1 != -1 && v1 != 10; v0 += 1) {\n    a0[v0] = v1;\n  }\n  if (v1 == 10) {\n    v5 = v0;\n    v0 = (unsigned int)v5 + 1;\n    a0[v5] = v1;\n  }\n  a0[v0] = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/116.c"}
{"compilable":0,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getchar)();\n\nlong long get_line_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rax\n\n  v4 = &v2;\n  for (v0 = 0; v0 < (unsigned int)a1 - 1 && v1 != -1 && v1 != 10; v0 += 1) {\n    a0[v0] = v1;\n  }\n  if (v1 == 10) {\n    v5 = v0;\n    v0 = (unsigned int)v5 + 1;\n    a0[v5] = v1;\n  }\n  a0[v0] = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/get_line.c"}
{"compilable":0,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getchar)();\n\nlong long get_line_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rax\n\n  v4 = &v2;\n  for (v0 = 0; v0 < (unsigned int)a1 - 1 && v1 != -1 && v1 != 10; v0 += 1) {\n    a0[v0] = v1;\n  }\n  if (v1 == 10) {\n    v5 = v0;\n    v0 = (unsigned int)v5 + 1;\n    a0[v5] = v1;\n  }\n  a0[v0] = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/117.c"}
{"compilable":0,"function":"static int test(int argc, char **argv, int t) {\n    static struct iovec iov[1024];\n    const int bs = 4 << 10;\n    const ssize_t s = bs * 1024;\n    char *p = (char *)mmap(0, bs * 1024, 1 | 2, 2 | 32, -1, 0);\n    int i;\n    for (i = 1024 - 1; i >= 0; i--) {\n        iov[i].iov_base = p;\n        iov[i].iov_len = bs;\n        *p = i;\n        p += bs;\n    }\n    for (i = 1; i < argc; i++) {\n        const char *nm = \"none\";\n        const double cs = (double)sysconf(_SC_CLK_TCK);\n        struct tms ptms, ctms;\n        clock_t pt, ct;\n        int l = 1 << 8;\n        int k = l;\n        const int fd = open(argv[i], 2 | 64 | 16384 | 262144, 438);\n        if (fd < 0) {\n            perror(argv[i]);\n            return 1;\n        }\n        pt = times(&ptms);\n        while (k-- > 0)\n            {\n                ssize_t n;\n                switch (t) {\n                  case 0:\n                    nm = \"write\";\n                    n = write(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 1:\n                    nm = \"writev\";\n                    n = writev(fd, iov, 1024);\n                    break;\n                  case 2:\n                    nm = \"read\";\n                    n = read(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 3:\n                    nm = \"readv\";\n                    n = readv(fd, iov, 1024);\n                    break;\n                  default:\n                    n = 0;\n                    break;\n                }\n                if (n != s) {\n                    perror(argv[i]);\n                    return 1;\n                }\n                if ((k & 63) == 0) {\n                    lseek(fd, 0, 0);\n                }\n            }\n        ct = times(&ctms);\n        {\n            const double d = (ct != pt) ? ct - pt : 1.0000000000000001E-9;\n            printf(\"u: %6.2f%% s: %6.2f%% w: %6.2f s %6.2f MB/s %s\\n\", (ctms.tms_utime - ptms.tms_utime) / d * 100, (ctms.tms_stime - ptms.tms_stime) / d * 100, d / cs, cs * l * s / ((1 << 20) * d), nm);\n        }\n        close(fd);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sysconf)(int);\nint(open64)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(times)(struct tms {\n  uint32_t tms_utime;\n  uint32_t tms_stime;\n  uint32_t tms_cutime;\n  uint32_t tms_cstime;\n} *);\nlong(readv)(\n    int,\n    struct<anon> {\n      void *iov_base;\n      unsigned long iov_len;\n    } *,\n    int);\nlong(read)(int, void *, unsigned long);\nint(close)(int);\nlong(write)(int, void *, unsigned long);\nlong(writev)(\n    int,\n    struct<anon> {\n      void *iov_base;\n      unsigned long iov_len;\n    } *,\n    int);\n\nextern char g_4040a8;\nextern char g_408090;\nextern char iov.0;\n\nlong long test(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;           // [bp-0xa8]\n  char v1;           // [bp-0x88]\n  unsigned long v2;  // [bp-0x68]\n  unsigned long v3;  // [bp-0x60]\n  unsigned long v4;  // [bp-0x58]\n  unsigned int v5;   // [bp-0x50]\n  unsigned int v6;   // [bp-0x4c]\n  unsigned long v7;  // [bp-0x48]\n  unsigned long v8;  // [bp-0x40]\n  unsigned int v9;   // [bp-0x34]\n  unsigned long v10; // [bp-0x30]\n  unsigned int v11;  // [bp-0x24]\n  unsigned long v12; // [bp-0x20]\n  unsigned int v13;  // [bp-0x14]\n  unsigned long v14; // [bp-0x10]\n  unsigned int v16;  // eax\n\n  v9 = 0x1000;\n  v8 = v9 * 0x400;\n  v14 = mmap64(0, v9 * 0x400, 3, 34, 4294967295, 0, a1);\n  for (v13 = 1023; v13 >= 0; v13 -= 1) {\n    (&iov.0)[2 * v13] = v14;\n    (&g_4040a8)[2 * v13] = v9;\n    *((char *)v14) = v13;\n    v14 += v9;\n  }\n  v13 = 1;\n  while (v13 >= (unsigned int)a0) {\n    return 0;\n  }\n  v12 = \"none\";\n  v7 = sysconf(2);\n  v6 = 0x100;\n  v11 = v6;\n  v5 = open64(*((long long *)(a1 + v13 * 8)), 278594, 438);\n  if (v5 < 0) {\n    perror(*((long long *)(a1 + v13 * 8)));\n    return 1;\n  }\n  v4 = times(&v0);\n  while (true) {\n    v16 = v11;\n    v11 = v16 - 1;\n    if (v16 <= 0) {\n      v3 = times(&v1);\n      *((int *)&v2) = (v3 == v4 ? v3 - v4 : 4472406533629990549);\n      printf(\"u: %6.2f%% s: %6.2f%% w: %6.2f s %6.2f MB/s %s\\n\",\n             (unsigned int)v12);\n      close(v5);\n      v13 += 1;\n      break;\n    }\n    if ((unsigned int)a2 == 3) {\n      v12 = \"readv\";\n      v10 = readv(v5, &iov.0, 0x400);\n    } else {\n      if ((unsigned int)a2 <= 3) {\n        if ((unsigned int)a2 == 2) {\n          v12 = \"read\";\n          v10 = read(v5, g_408090, v8);\n          goto LABEL_40145b;\n        } else if ((unsigned int)a2 <= 2) {\n          if (!(unsigned int)a2) {\n            v12 = \"write\";\n            v10 = write(v5, g_408090, v8);\n            goto LABEL_40145b;\n          }\n          if ((unsigned int)a2 == 1) {\n            v12 = \"writev\";\n            v10 = writev(v5, &iov.0, 0x400);\n            goto LABEL_40145b;\n          }\n        }\n      }\n      v10 = 0;\n    }\n  LABEL_40145b:\n    if (v10 != v8) {\n      perror(*((long long *)(a1 + v13 * 8)));\n      return 1;\n    } else if (!((char)v11 & 63)) {\n      lseek64(v5, 0, 0);\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr7tnmtrt/test.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpr7tnmtrt/test.c:25:19: error: declaration of anonymous struct must be a\ndefinition 25 | long (readv)(int, struct <anon> { |                   ^\n/tmp/tmpr7tnmtrt/test.c:32:20: error: declaration of anonymous struct must be a\ndefinition 32 | long (writev)(int, struct <anon> { |                    ^\n/tmp/tmpr7tnmtrt/test.c:39:16: error: expected ';' after top level declarator\n   39 | extern char iov.0;\n      |                ^\n      |                ;\n/tmp/tmpr7tnmtrt/test.c:65:14: error: expected ')'\n   65 |         (&iov.0)[2 * v13] = v14;\n      |              ^\n/tmp/tmpr7tnmtrt/test.c:65:9: note: to match this '('\n   65 |         (&iov.0)[2 * v13] = v14;\n      |         ^\n/tmp/tmpr7tnmtrt/test.c:102:33: error: expected ')'\n  102 |             v10 = readv(v5, &iov.0, 0x400);\n      |                                 ^\n/tmp/tmpr7tnmtrt/test.c:102:24: note: to match this '('\n  102 |             v10 = readv(v5, &iov.0, 0x400);\n      |                        ^\n/tmp/tmpr7tnmtrt/test.c:125:46: error: expected ')'\n  125 |                         v10 = writev(v5, &iov.0, 0x400);\n      |                                              ^\n/tmp/tmpr7tnmtrt/test.c:125:37: note: to match this '('\n  125 |                         v10 = writev(v5, &iov.0, 0x400);\n      |                                     ^\n7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sumedhsakdeo_zynx/src/cc/qcdio/iovperf.c"}
{"compilable":0,"function":"static int print_dirlist(char *filename) {\n    struct dirent *de;\n    char c;\n    DIR *d;\n    fprintf(stdout, \"<br><br>--------<pre>Directory listing for %s:\\n\\n\", filename);\n    d = opendir(filename);\n    if (!d) {\n        fprintf(stdout, \"No such directory\\n</pre>\");\n        return -1;\n    }\n    while (de = readdir(d))\n        {\n            if (de->d_type == DT_DIR)\n                fprintf(stdout, \"%s/\\n\", de->d_name);\n            else\n                fprintf(stdout, \"%s\\n\", de->d_name);\n        }\n    closedir(d);\n    fprintf(stdout, \"</pre>\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[18];\n  char field_12;\n} struct_0;\n\nextern FILE_t *__TMC_END__;\n\nlong long print_dirlist_name_conflict(char *a0) {\n  struct_0 *v0; // [bp-0x18]\n  char *v1;     // [bp-0x10]\n\n  fprintf(__TMC_END__, \"<br><br>--------<pre>Directory listing for %s:\\n\\n\",\n          (unsigned int)a0);\n  v1 = opendir(a0);\n  if (!v1) {\n    fwrite(\"No such directory\\n</pre>\", 1, 24, __TMC_END__);\n    return 4294967295;\n  }\n  while (true) {\n    v0 = &readdir(v1);\n    if (!v0)\n      break;\n    if (v0->field_12 != 4)\n      fprintf(__TMC_END__, \"%s\\n\", (unsigned int)(v0 + 1));\n    else\n      fprintf(__TMC_END__, \"%s/\\n\", (unsigned int)(v0 + 1));\n  }\n  closedir(v1);\n  fwrite(\"</pre>\", 1, 6, __TMC_END__);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2su9koim/print_dirlist_name_conflict.c:25:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 25 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp2su9koim/print_dirlist_name_conflict.c:41:14: error: cannot take the address of an\nrvalue of type 'char *' 41 |         v0 = &readdir(v1); | ^~~~~~~~~~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int write_to_file(char *filename, char *writeval) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"w\");\n    if (!fp)\n        return -1;\n    fprintf(stdout, \"<br><br>--------<pre>Writing %s to file %s:\\n\\n\", writeval, filename);\n    if (fwrite(writeval, strlen(writeval), 1, fp) < strlen(writeval))\n        fprintf(stdout, \"Write failed\\n\");\n    else\n        fprintf(stdout, \"Write succeeded\\n\");\n    fprintf(stdout, \"</pre>\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *__TMC_END__;\n\nlong long write_to_file_name_conflict(char *a0, char *a1) {\n  FILE_t *v0; // [bp-0x28]\n  void *v1;   // [bp-0x20]\n\n  v1 = 0;\n  v0 = &fopen(a0, \"w\")->_flags;\n  if (!v0)\n    return 4294967295;\n  fprintf(__TMC_END__, \"<br><br>--------<pre>Writing %s to file %s:\\n\\n\",\n          (unsigned int)a1, (unsigned int)a0);\n  if (fwrite(a1, strlen(a1), 1, v0) >= strlen(a1))\n    fwrite(\"Write succeeded\\n\", 1, 16, __TMC_END__);\n  else\n    fwrite(\"Write failed\\n\", 1, 13, __TMC_END__);\n  fwrite(\"</pre>\", 1, 6, __TMC_END__);\n  fclose(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu4cguknj/write_to_file_name_conflict.c:85:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 85 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int cat_file(char *filename) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"r\");\n    if (!fp) {\n        fprintf(stdout, \"No such file or directory\\n</pre>\");\n        return -1;\n    }\n    fprintf(stdout, \"<br><br>--------<pre>Contents of file %s:\\n\\n\", filename);\n    while (getline(&line, &len, fp) != -1)\n        fprintf(stdout, \"%s\", line);\n    fprintf(stdout, \"</pre>\");\n    free(line);\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(getline)(\n    char **, unsigned long *, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(fputs)(\n    char *, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *__TMC_END__;\n\nlong long cat_file_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x20]\n  void *v1;        // [bp-0x18]\n  FILE_t *v2;      // [bp-0x10]\n\n  v1 = 0;\n  v2 = &fopen(a0, \"r\")->_flags;\n  if (!v2) {\n    fwrite(\"No such file or directory\\n</pre>\", 1, 32, __TMC_END__);\n    return 4294967295;\n  }\n  fprintf(__TMC_END__, \"<br><br>--------<pre>Contents of file %s:\\n\\n\",\n          (unsigned int)a0);\n  while (getline(&v1, &v0, v2) != -1) {\n    fputs(v1, __TMC_END__);\n  }\n  fwrite(\"</pre>\", 1, 6, __TMC_END__);\n  free(v1);\n  fclose(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:16:7: error: conflicting types for 'getline'\n   16 | long (getline)(char **, unsigned long *, struct FILE_t {\n      |       ^\n/usr/include/stdio.h:645:18: note: previous declaration is here\n  645 | extern __ssize_t getline (char **__restrict __lineptr,\n      |                  ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:105:6: error: conflicting types for 'fputs'\n  105 | int (fputs)(char *, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:655:12: note: previous declaration is here\n  655 | extern int fputs (const char *__restrict __s, FILE *__restrict\n__stream); |            ^ /tmp/tmp5r9xv81y/cat_file_name_conflict.c:230:16: error:\nredefinition of '_IO_marker' 230 | typedef struct _IO_marker { | ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:236:16: error: redefinition of '_IO_codecvt'\n  236 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:240:16: error: redefinition of '_IO_wide_data'\n  240 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp5r9xv81y/cat_file_name_conflict.c:263:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 263 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int test(int do_exit) {\n    pthread_t t;\n    pthread_create(&t, ((void *)0), thread1_func, (void *)do_exit);\n    pthread_join(t, ((void *)0));\n    if (g_ok1 != +1) {\n        if (g_ok1 == 0) {\n            fprintf(stderr, \"cleanup1 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup1 called with wrong argument\\n\");\n        }\n        exit(1);\n    } else if (g_ok2 != +1) {\n        if (g_ok2 == 0)\n            fprintf(stderr, \"cleanup2 not called !!\\n\");\n        else\n            fprintf(stderr, \"cleanup2 called with wrong argument\\n\");\n        exit(2);\n    } else if (do_exit && g_ok3 != +1) {\n        if (g_ok3 == 0) {\n            fprintf(stderr, \"cleanup3 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 called with bad argument !!\\n\");\n        }\n        exit(3);\n    } else if (!do_exit && g_ok3 != 0) {\n        if (g_ok3 == 1) {\n            fprintf(stderr, \"cleanup3 wrongly called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 wrongly called with bad argument !!\\n\");\n        }\n        exit(3);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint thread1_func; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(pthread_create)(char *, char *, char *, char *);\n\nextern unsigned int g_ok1;\nextern unsigned int g_ok2;\nextern unsigned int g_ok3;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long test_name_conflict(unsigned long a0) {\n  char v0; // [bp-0x10]\n\n  pthread_create(&v0, NULL, thread1_func, (unsigned int)a0);\n  pthread_join(*((long long *)&v0), 0);\n  if (g_ok1 != 1) {\n    if (g_ok1)\n      fwrite(\"cleanup1 called with wrong argument\\n\", 1, 36,\n             stderr @GLIBC_2.2.5);\n    else\n      fwrite(\"cleanup1 not called !!\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  } else if (g_ok2 != 1) {\n    if (g_ok2)\n      fwrite(\"cleanup2 called with wrong argument\\n\", 1, 36,\n             stderr @GLIBC_2.2.5);\n    else\n      fwrite(\"cleanup2 not called !!\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    exit(2); /* do not return */\n  } else {\n    if ((unsigned int)a0 && g_ok3 != 1) {\n      if (g_ok3)\n        fwrite(\"cleanup3 called with bad argument !!\\n\", 1, 37,\n               stderr @GLIBC_2.2.5);\n      else\n        fwrite(\"cleanup3 not called !!\\n\", 1, 23, stderr @GLIBC_2.2.5);\n      exit(3); /* do not return */\n    }\n    if ((unsigned int)a0) {\n      return 0;\n    } else if (!g_ok3) {\n      return 0;\n    } else {\n      if (g_ok3 != 1)\n        fwrite(\"cleanup3 wrongly called with bad argument !!\\n\", 1, 45,\n               stderr @GLIBC_2.2.5);\n      else\n        fwrite(\"cleanup3 wrongly called !!\\n\", 1, 27, stderr @GLIBC_2.2.5);\n      exit(3); /* do not return */\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuafop1e3/test_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpuafop1e3/test_name_conflict.c:22:22: error: expected ';' after top level declarator\n   22 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpuafop1e3/test_name_conflict.c:33:74: error: expected ')'\n   33 |             fwrite(\"cleanup1 called with wrong argument\\n\", 1, 36,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:33:19: note: to match this '('\n   33 |             fwrite(\"cleanup1 called with wrong argument\\n\", 1, 36,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmpuafop1e3/test_name_conflict.c:35:61: error:\nexpected ')' 35 |             fwrite(\"cleanup1 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:35:19: note: to match this '('\n   35 |             fwrite(\"cleanup1 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmpuafop1e3/test_name_conflict.c:41:74: error:\nexpected ')' 41 |             fwrite(\"cleanup2 called with wrong argument\\n\", 1,\n36, stderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:41:19: note: to match this\n'(' 41 |             fwrite(\"cleanup2 called with wrong argument\\n\", 1, 36,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmpuafop1e3/test_name_conflict.c:43:61: error:\nexpected ')' 43 |             fwrite(\"cleanup2 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:43:19: note: to match this '('\n   43 |             fwrite(\"cleanup2 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmpuafop1e3/test_name_conflict.c:51:79: error:\nexpected ')' 51 |                 fwrite(\"cleanup3 called with bad argument\n!!\\n\", 1, 37, stderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:51:23: note: to\nmatch this '(' 51 |                 fwrite(\"cleanup3 called with bad argument\n!!\\n\", 1, 37, stderr@GLIBC_2.2.5); |                       ^\n/tmp/tmpuafop1e3/test_name_conflict.c:53:65: error: expected ')'\n   53 |                 fwrite(\"cleanup3 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:53:23: note: to match this '('\n   53 |                 fwrite(\"cleanup3 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); |                       ^ /tmp/tmpuafop1e3/test_name_conflict.c:67:87:\nerror: expected ')' 67 |                 fwrite(\"cleanup3 wrongly called with\nbad argument !!\\n\", 1, 45, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpuafop1e3/test_name_conflict.c:67:23: note: to match this '('\n   67 |                 fwrite(\"cleanup3 wrongly called with bad argument !!\\n\",\n1, 45, stderr@GLIBC_2.2.5); |                       ^\n/tmp/tmpuafop1e3/test_name_conflict.c:69:69: error: expected ')'\n   69 |                 fwrite(\"cleanup3 wrongly called !!\\n\", 1, 27,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpuafop1e3/test_name_conflict.c:69:23: note: to match this '('\n   69 |                 fwrite(\"cleanup3 wrongly called !!\\n\", 1, 27,\nstderr@GLIBC_2.2.5); |                       ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/common/test_pthread_cleanup_push.c"}
{"compilable":0,"function":"static int check_library(const char *libname) {\n    void *lib = dlopen(libname, 2);\n    int *to_x;\n    void (*set_y)(int *);\n    int y = 0;\n    if (lib == ((void *)0)) {\n        fprintf(stderr, \"Could not load shared library %s: %s\\n\", libname, dlerror());\n        return 1;\n    }\n    fprintf(stderr, \"%s loaded.\\n\", libname);\n    to_x = dlsym(lib, \"x\");\n    if (to_x == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL variable (x) in %s: %s\\n\", libname, dlerror());\n        return 10;\n    }\n    if (*to_x != 1) {\n        fprintf(stderr, \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", libname);\n        return 11;\n    }\n    set_y = dlsym(lib, \"set_y\");\n    if (set_y == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL function (set_y) in %s: %s\\n\", libname, dlerror());\n        return 12;\n    }\n    y = 0;\n    (*set_y)(&y);\n    if (dlclose(lib) < 0) {\n        fprintf(stderr, \"Could not unload shared library %s: %s\\n\", libname, dlerror());\n        return 2;\n    }\n    fprintf(stderr, \"%s unloaded.\\n\", libname);\n    if (y != 2) {\n        fprintf(stderr, \"Static destructors was not called on dlclose()!\\n\");\n        return 2;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long check_library_name_conflict(unsigned long long a0) {\n  unsigned int v0;       // [bp-0x24]\n  struct struct_0 **v1;  // [bp-0x20]\n  unsigned int *v2;      // [bp-0x18]\n  unsigned long long v3; // [bp-0x10]\n\n  v3 = dlopen(a0, 2);\n  v0 = 0;\n  if (!v3) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not load shared library %s: %s\\n\",\n            (unsigned int)a0, dlerror());\n    return 1;\n  }\n  fprintf(stderr @GLIBC_2.2.5, \"%s loaded.\\n\", (unsigned int)a0);\n  v2 = dlsym(v3, \"x\", \"x\");\n  if (!v2) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not access global DLL variable (x) in %s: %s\\n\",\n            (unsigned int)a0, dlerror());\n    return 10;\n  } else if (*(v2) == 1) {\n    v1 = dlsym(v3, \"set_y\", \"set_y\");\n    if (!v1) {\n      fprintf(stderr @GLIBC_2.2.5,\n              \"Could not access global DLL function (set_y) in %s: %s\\n\",\n              (unsigned int)a0, dlerror());\n      return 12;\n    }\n    v0 = 0;\n    v1(&v0);\n    if (dlclose(v3) < 0) {\n      fprintf(stderr @GLIBC_2.2.5, \"Could not unload shared library %s: %s\\n\",\n              (unsigned int)a0, dlerror());\n      return 2;\n    }\n    fprintf(stderr @GLIBC_2.2.5, \"%s unloaded.\\n\", (unsigned int)a0);\n    if (v0 == 2)\n      return 0;\n    fwrite(\"Static destructors was not called on dlclose()!\\n\", 1, 48,\n           stderr @GLIBC_2.2.5);\n    return 2;\n  } else {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", (unsigned int)a0);\n    return 11;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnf081faw/check_library_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpnf081faw/check_library_name_conflict.c:30:23: error: expected ')'\n   30 |         fprintf(stderr@GLIBC_2.2.5, \"Could not load shared library %s:\n%s\\n\", (unsigned int)a0, dlerror()); |                       ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:30:16: note: to match this '('\n   30 |         fprintf(stderr@GLIBC_2.2.5, \"Could not load shared library %s:\n%s\\n\", (unsigned int)a0, dlerror()); |                ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:33:19: error: expected ')'\n   33 |     fprintf(stderr@GLIBC_2.2.5, \"%s loaded.\\n\", (unsigned int)a0);\n      |                   ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:33:12: note: to match this '('\n   33 |     fprintf(stderr@GLIBC_2.2.5, \"%s loaded.\\n\", (unsigned int)a0);\n      |            ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:37:23: error: expected ')'\n   37 |         fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nvariable (x) in %s: %s\\n\", (unsigned int)a0, dlerror()); | ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:37:16: note: to match this '('\n   37 |         fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nvariable (x) in %s: %s\\n\", (unsigned int)a0, dlerror()); |                ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:45:27: error: expected ')'\n   45 |             fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nfunction (set_y) in %s: %s\\n\", (unsigned int)a0, dlerror()); | ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:45:20: note: to match this '('\n   45 |             fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nfunction (set_y) in %s: %s\\n\", (unsigned int)a0, dlerror()); | ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:49:11: error: called object type 'struct\nstruct_0 **' is not a function or function pointer 49 |         v1(&v0); | ~~^\n/tmp/tmpnf081faw/check_library_name_conflict.c:52:27: error: expected ')'\n   52 |             fprintf(stderr@GLIBC_2.2.5, \"Could not unload shared library\n%s: %s\\n\", (unsigned int)a0, dlerror()); |                           ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:52:20: note: to match this '('\n   52 |             fprintf(stderr@GLIBC_2.2.5, \"Could not unload shared library\n%s: %s\\n\", (unsigned int)a0, dlerror()); |                    ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:55:23: error: expected ')'\n   55 |         fprintf(stderr@GLIBC_2.2.5, \"%s unloaded.\\n\", (unsigned int)a0);\n      |                       ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:55:16: note: to match this '('\n   55 |         fprintf(stderr@GLIBC_2.2.5, \"%s unloaded.\\n\", (unsigned int)a0);\n      |                ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:58:82: error: expected ')'\n   58 |         fwrite(\"Static destructors was not called on dlclose()!\\n\", 1,\n48, stderr@GLIBC_2.2.5); | ^ /tmp/tmpnf081faw/check_library_name_conflict.c:58:15: note: to\nmatch this '(' 58 |         fwrite(\"Static destructors was not called on\ndlclose()!\\n\", 1, 48, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:63:23: error: expected ')'\n   63 |         fprintf(stderr@GLIBC_2.2.5, \"Constructor was not run on\ndlopen(\\\"%s\\\") !\\n\", (unsigned int)a0); |                       ^\n/tmp/tmpnf081faw/check_library_name_conflict.c:63:16: note: to match this '('\n   63 |         fprintf(stderr@GLIBC_2.2.5, \"Constructor was not run on\ndlopen(\\\"%s\\\") !\\n\", (unsigned int)a0); |                ^ 11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/bionic/test_dlclose_destruction.c"}
{"compilable":0,"function":"static unsigned long long stop_watch() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return t.tv_sec * 1000000000ULL + t.tv_nsec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long stop_watch_name_conflict() {\n  char v0;  // [bp-0x18]\n  void *v1; // [bp-0x10]\n\n  v1 = 0;\n  *((void **)&v0) = v1;\n  clock_gettime(0x1, &v0);\n  return *((long long *)&v0) * 0x3b9aca00 + v1;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/pftest/pftest.c"}
{"compilable":0,"function":"int64_t systemTime() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return (int64_t)(t.tv_sec) * 1000000000LL + t.tv_nsec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long systemTime_name_conflict() {\n  char v0;  // [bp-0x18]\n  void *v1; // [bp-0x10]\n\n  v1 = 0;\n  *((void **)&v0) = v1;\n  clock_gettime(0x1, &v0);\n  return v1 + *((long long *)&v0) * 0x3b9aca00;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/framebuffer/refresh.c"}
{"compilable":1,"function":"static u64 get_block_device_size(int fd) {\n    u64 size = 0;\n    int ret;\n    ret = ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((114)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &size);\n    if (ret)\n        return 0;\n    return size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long get_block_device_size_name_conflict(unsigned long a0) {\n  void *v0;        // [bp-0x18]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = 0;\n  v1 = ioctl(a0, 2148012658);\n  return (!v1 ? 0 : v0);\n}\n","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static int wipe_block_device(int fd, u64 len, int secure) {\n    u64 range[2];\n    int ret;\n    int req;\n    range[0] = 0;\n    range[1] = len;\n    if (secure) {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((125)) << 0) | ((0) << ((0 + 8) + 8)));\n    } else {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((119)) << 0) | ((0) << ((0 + 8) + 8)));\n    }\n    ret = ioctl(fd, req, &range);\n    if (ret < 0) {\n        fprintf(stderr, \"%s discard failed, errno = %d\\n\", secure ? \"Secure\" : \"Nonsecure\", (*__errno_location()));\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_402008;\nextern char g_40200f;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long wipe_block_device(unsigned long a0, unsigned long a1,\n                            unsigned long a2) {\n  void *v0;         // [bp-0x28]\n  unsigned long v1; // [bp-0x20]\n  unsigned int v2;  // [bp-0x10]\n  unsigned int v3;  // [bp-0xc]\n  unsigned int v5;  // edx\n  unsigned int v6;  // eax\n\n  v0 = 0;\n  v1 = a1;\n  if (!(unsigned int)a2)\n    v3 = 4727;\n  else\n    v3 = 4733;\n  v2 = ioctl(a0, v3);\n  if (v2 >= 0)\n    return v2;\n  v5 = *(__errno_location());\n  if (!(unsigned int)a2)\n    v6 = &g_40200f;\n  else\n    v6 = &g_402008;\n  fprintf(stderr @GLIBC_2.2.5, \"%s discard failed, errno = %d\\n\", v6, v5);\n  return v2;\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphoul8bdp/wipe_block_device.c:19:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmphoul8bdp/wipe_block_device.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmphoul8bdp/wipe_block_device.c:39:10: error: indirection requires pointer\noperand ('int' invalid) 39 |     v5 = *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmphoul8bdp/wipe_block_device.c:44:19: error:\nexpected ')' 44 |     fprintf(stderr@GLIBC_2.2.5, \"%s discard failed, errno =\n%d\\n\", v6, v5); |                   ^\n/tmp/tmphoul8bdp/wipe_block_device.c:44:12: note: to match this '('\n   44 |     fprintf(stderr@GLIBC_2.2.5, \"%s discard failed, errno = %d\\n\", v6,\nv5); |            ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static uid_t str2uid(char *str, int line_num) {\n    struct passwd *pw;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(pw = getpwnam(str))) {\n        printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return pw->pw_uid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct passwd *(getpwnam)(char *);\nlong(atol)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long str2uid_name_conflict(char *a0, unsigned long a1) {\n  struct_0 *v0; // [bp-0x10]\n\n  if ((*((short *)((*(a0) << 1) + *((long long *)&__ctype_b_loc()))) & 0x800))\n    return atol(a0);\n  v0 = &getpwnam(a0)->pw_name;\n  if (v0)\n    return v0->field_10;\n  printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", (unsigned int)a0,\n         (unsigned int)a1);\n  exit(255); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjkp343xv/str2uid_name_conflict.c:28:52: error: cannot take the address of an rvalue of\ntype 'int' 28 |     if ((*((short *)((*(a0) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x800)) | ^~~~~~~~~~~~~~~~\n/tmp/tmpjkp343xv/str2uid_name_conflict.c:30:23: error: incomplete definition of type 'struct\npasswd' 30 |     v0 = &getpwnam(a0)->pw_name; |           ~~~~~~~~~~~~^\n/tmp/tmpjkp343xv/str2uid_name_conflict.c:16:8: note: forward declaration of 'struct passwd'\n   16 | struct passwd *(getpwnam)(char *);\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static gid_t str2gid(char *str, int line_num) {\n    struct group *gr;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(gr = getgrnam(str))) {\n        printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return gr->gr_gid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct group *(getgrnam)(char *);\nlong(atol)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long str2gid_name_conflict(char *a0, unsigned long a1) {\n  struct_0 *v0; // [bp-0x10]\n\n  if ((*((short *)((*(a0) << 1) + *((long long *)&__ctype_b_loc()))) & 0x800))\n    return atol(a0);\n  v0 = &getgrnam(a0)->gr_name;\n  if (v0)\n    return v0->field_10;\n  printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", (unsigned int)a0,\n         (unsigned int)a1);\n  exit(255); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqsn065v4/str2gid_name_conflict.c:28:52: error: cannot take the address of an rvalue of\ntype 'int' 28 |     if ((*((short *)((*(a0) << 1) + *((long long\n*)&__ctype_b_loc()))) & 0x800)) | ^~~~~~~~~~~~~~~~\n/tmp/tmpqsn065v4/str2gid_name_conflict.c:30:23: error: incomplete definition of type 'struct\ngroup' 30 |     v0 = &getgrnam(a0)->gr_name; |           ~~~~~~~~~~~~^\n/tmp/tmpqsn065v4/str2gid_name_conflict.c:16:8: note: forward declaration of 'struct group'\n   16 | struct group *(getgrnam)(char *);\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_file(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for file: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[WILDCARD];\n    while (pr != ((void *)0))\n        {\n            if ((strstr(name, pr->spec) == name) && (!strchr(name + strlen(pr->spec), '/'))) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(print_new_rule)(long long, long long, long long, long long);\nlong long(pass_rule)(long long, long long, long long, long long);\n\ntypedef struct struct_1 {\n  char padding_0[16];\n  char *field_10;\n  char padding_18[32];\n  struct struct_1 *field_38;\n} struct_1;\n\nextern struct_0 *g_405150;\nextern struct_0 *g_405158;\nextern struct_0 *rules;\n\nlong long validate_file(char *a0, unsigned long a1, unsigned long a2,\n                        unsigned long a3) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  struct_1 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = 0;\n  v0 = 0;\n  for (v2 = &rules->padding_0; v2; v2 = *((long long *)(v2 + 56))) {\n    if (!strcmp(a0, *((long long *)(v2 + 16)))) {\n      if (!(int)pass_rule(v2, (unsigned int)a1, (unsigned int)a2,\n                          (unsigned int)a3))\n        v0 += 1;\n      else\n        v1 += 1;\n    }\n  }\n  if (v1 + v0 > 1)\n    printf(\"# WARNING # Multiple exact rules for file: %s\\n\", (unsigned int)a0);\n  if (v0)\n    print_new_rule(a0, (unsigned int)a1, (unsigned int)a2, (unsigned int)a3);\n  if (!v1 && !v0) {\n    for (v2 = &g_405150->padding_0; v2; v2 = v2->field_38) {\n      if (a0 == strstr(a0, v2->field_10) &&\n          !strchr(&a0[strlen(v2->field_10)], 47)) {\n        if (!(int)pass_rule(v2, (unsigned int)a1, (unsigned int)a2,\n                            (unsigned int)a3))\n          v0 += 1;\n        else\n          v1 += 1;\n      }\n    }\n    for (v2 = &g_405158->padding_0; v2; v2 = *((long long *)(v2 + 56))) {\n      if (a0 == strstr(a0, *((long long *)(v2 + 16)))) {\n        if (!(int)pass_rule(v2, (unsigned int)a1, (unsigned int)a2,\n                            (unsigned int)a3))\n          v0 += 1;\n        else\n          v1 += 1;\n      }\n    }\n    if (!v1)\n      v0 += 1;\n    if (!v0)\n      return v0;\n    print_new_rule(a0, (unsigned int)a1, (unsigned int)a2, (unsigned int)a3);\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkw88hlvm/validate_file.c:26:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 26 | extern struct_0 *g_405150; |        ^~~~~~~~ |\nstruct_1 /tmp/tmpkw88hlvm/validate_file.c:24:3: note: 'struct_1' declared here\n   24 | } struct_1;\n      |   ^\n/tmp/tmpkw88hlvm/validate_file.c:27:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 27 | extern struct_0 *g_405158; |        ^~~~~~~~ |\nstruct_1 /tmp/tmpkw88hlvm/validate_file.c:24:3: note: 'struct_1' declared here\n   24 | } struct_1;\n      |   ^\n/tmp/tmpkw88hlvm/validate_file.c:28:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 28 | extern struct_0 *rules; |        ^~~~~~~~ | struct_1\n/tmp/tmpkw88hlvm/validate_file.c:24:3: note: 'struct_1' declared here\n   24 | } struct_1;\n      |   ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_link(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for link: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(print_new_rule)(long long, long long, long long, long long);\nlong long(pass_rule)(long long, long long, long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  char *field_10;\n  char padding_18[32];\n  struct struct_0 *field_38;\n} struct_0;\n\nextern struct_1 *rules;\n\nlong long validate_link(char *a0, unsigned long a1, unsigned long a2,\n                        unsigned long a3) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  struct_0 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = 0;\n  v0 = 0;\n  for (v2 = &rules->padding_0; v2; v2 = *((long long *)(v2 + 56))) {\n    if (!strcmp(a0, *((long long *)(v2 + 16)))) {\n      if (!(int)pass_rule(v2, (unsigned int)a1, (unsigned int)a2,\n                          (unsigned int)a3))\n        v0 += 1;\n      else\n        v1 += 1;\n    }\n  }\n  if (v1 + v0 > 1)\n    printf(\"# WARNING # Multiple exact rules for link: %s\\n\", (unsigned int)a0);\n  if (v0)\n    print_new_rule(a0, (unsigned int)a1, (unsigned int)a2, (unsigned int)a3);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpepi2rqid/validate_link.c:26:8: error: unknown type name 'struct_1'; did\nyou mean 'struct_0'? 26 | extern struct_1 *rules; |        ^~~~~~~~ | struct_0\n/tmp/tmpepi2rqid/validate_link.c:24:3: note: 'struct_0' declared here\n   24 | } struct_0;\n      |   ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_dir(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_DIR];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for directory: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(print_new_rule)(long long, long long, long long, long long);\nlong long(pass_rule)(long long, long long, long long, long long);\n\ntypedef struct struct_1 {\n  char padding_0[16];\n  char *field_10;\n  char padding_18[32];\n  struct struct_1 *field_38;\n} struct_1;\n\nextern struct_0 *g_405148;\nextern struct_0 *g_405158;\n\nlong long validate_dir(char *a0, unsigned long a1, unsigned long a2,\n                       unsigned long a3) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  struct_1 *v2;    // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = 0;\n  v0 = 0;\n  for (v2 = &g_405148->padding_0; v2; v2 = *((long long *)(v2 + 56))) {\n    if (!strcmp(a0, *((long long *)(v2 + 16)))) {\n      if (!(int)pass_rule(v2, (unsigned int)a1, (unsigned int)a2,\n                          (unsigned int)a3))\n        v0 += 1;\n      else\n        v1 += 1;\n    }\n  }\n  if (v1 + v0 > 1)\n    printf(\"# WARNING # Multiple exact rules for directory: %s\\n\",\n           (unsigned int)a0);\n  if (v0)\n    print_new_rule(a0, (unsigned int)a1, (unsigned int)a2, (unsigned int)a3);\n  if (!v1 && !v0) {\n    for (v2 = &g_405158->padding_0; v2; v2 = v2->field_38) {\n      if (a0 == strstr(a0, v2->field_10)) {\n        if ((int)pass_rule(v2, (unsigned int)a1, (unsigned int)a2,\n                           (unsigned int)a3))\n          v1 += 1;\n        else\n          v0 += 1;\n      }\n    }\n    if (!v1)\n      v0 += 1;\n    if (!v0)\n      return v0;\n    print_new_rule(a0, (unsigned int)a1, (unsigned int)a2, (unsigned int)a3);\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp99ej1ujw/validate_dir.c:26:8: error: unknown type name 'struct_0'; did\nyou mean 'struct_1'? 26 | extern struct_0 *g_405148; |        ^~~~~~~~ |\nstruct_1 /tmp/tmp99ej1ujw/validate_dir.c:24:3: note: 'struct_1' declared here 24\n| } struct_1; |   ^ /tmp/tmp99ej1ujw/validate_dir.c:27:8: error: unknown type\nname 'struct_0'; did you mean 'struct_1'? 27 | extern struct_0 *g_405158; |\n^~~~~~~~ |        struct_1 /tmp/tmp99ej1ujw/validate_dir.c:24:3: note:\n'struct_1' declared here 24 | } struct_1; |   ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int check_path(const char *name) {\n    char namebuf[4097];\n    char tmp[4097];\n    DIR *d;\n    struct dirent *de;\n    struct stat s;\n    int err;\n    int retval = 0;\n    err = lstat(name, &s);\n    if (err < 0) {\n        if ((*__errno_location()) != 2) {\n            perror(name);\n            return 1;\n        }\n        return 0;\n    }\n    if (((((s.st_mode)) & 61440) == (16384))) {\n        if (name[strlen(name) - 1] != '/')\n            snprintf(namebuf, sizeof (namebuf), \"%s/\", name);\n        else\n            snprintf(namebuf, sizeof (namebuf), \"%s\", name);\n        retval |= validate_dir(namebuf, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n        d = opendir(namebuf);\n        if (d == 0) {\n            printf(\"%s : opendir failed: %s\\n\", namebuf, strerror((*__errno_location())));\n            return 1;\n        }\n        while ((de = readdir(d)) != 0)\n            {\n                if (!strcmp(de->d_name, \".\") || !strcmp(de->d_name, \"..\"))\n                    continue;\n                snprintf(tmp, sizeof (tmp), \"%s%s\", namebuf, de->d_name);\n                retval |= check_path(tmp);\n            }\n        closedir(d);\n        return retval;\n    } else if (((((s.st_mode)) & 61440) == (40960))) {\n        return validate_link(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    } else {\n        return validate_file(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(lstat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nvoid(perror)(char *);\nlong long(validate_link)(long long, long long, long long, long long);\nlong long(validate_file)(long long, long long, long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(validate_dir)(long long, long long, long long, long long);\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(strerror)(int);\nchar *(closedir)(char *);\nlong long(check_path_name_conflict)(char *);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long check_path_name_conflict(char *a0) {\n  stat v0;                // [bp-0x20c8]\n  int tmp_24;             // tmp #24\n  char v1;                // [bp-0x20b0]\n  char v2;                // [bp-0x20ac]\n  char v3;                // [bp-0x20a8]\n  char v4;                // [bp-0x2038]\n  char v5;                // [bp-0x1028]\n  unsigned long v6;       // [bp-0x20]\n  char *v7;               // [bp-0x18]\n  unsigned int v8;        // [bp-0x10]\n  unsigned int v9;        // [bp-0xc]\n  unsigned long v12;      // rax\n  unsigned long long v14; // rax\n  unsigned long long v16; // rax\n  unsigned long long v18; // rax\n  unsigned long long v21; // rax\n\n  v9 = 0;\n  v8 = lstat(a0, &v0);\n  if (v8 < 0) {\n    if (*(__errno_location()) != 2) {\n      perror(a0);\n      return 1;\n    }\n    return 0;\n  }\n  if (((short)*((int *)&v1) & 0xf000) == 0x4000) {\n    if (a0[1 + strlen(a0)] == 47)\n      snprintf(&v5, 4097, \"%s\", (unsigned int)a0);\n    else\n      snprintf(&v5, 4097, \"%s/\", (unsigned int)a0);\n    v18 = *((int *)&v1);\n    *((char *)&v18) = (char)v18 & 15;\n    tmp_24 = v18;\n    v9 |= (int)validate_dir(&v5, tmp_24, *((int *)&v2), *((int *)&v3));\n    v7 = opendir(&v5);\n    if (!v7) {\n      (unsigned int)v21 = strerror(*(__errno_location()));\n      printf(\"%s : opendir failed: %s\\n\", (unsigned int)&v5, (unsigned int)v21);\n      return 1;\n    }\n    while (true) {\n      do {\n        do {\n          v6 = readdir(v7);\n          if (!v6) {\n            closedir(v7);\n            return v9;\n          }\n        } while (!strcmp(v6 + 19, \".\"));\n      } while (!strcmp(v6 + 19, \"..\"));\n      snprintf(&v4, 4097, \"%s%s\", (unsigned int)&v5, (unsigned int)(v6 + 19));\n      v9 |= (int)check_path_name_conflict(&v4);\n    }\n  } else if (((short)*((int *)&v1) & 0xf000) == 0xa000) {\n    v14 = *((int *)&v1);\n    *((char *)&v14) = (char)v14 & 15;\n    tmp_24 = v14;\n    v12 = validate_link(a0, tmp_24, *((int *)&v2), *((int *)&v3));\n    return v12;\n  } else {\n    v16 = *((int *)&v1);\n    *((char *)&v16) = (char)v16 & 15;\n    tmp_24 = v16;\n    v12 = validate_file(a0, tmp_24, *((int *)&v2), *((int *)&v3));\n    return v12;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcojbwkee/check_path_name_conflict.c:28:7: error: conflicting types for 'perror'\n   28 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpcojbwkee/check_path_name_conflict.c:31:6: error: conflicting types for 'snprintf'\n   31 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpcojbwkee/check_path_name_conflict.c:82:13: error: indirection requires pointer operand\n('int' invalid) 82 |         if (*(__errno_location()) != 2) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpcojbwkee/check_path_name_conflict.c:102:42: error: indirection\nrequires pointer operand ('int' invalid) 102 |             (unsigned int)v21 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int get_cpu_count() {\n    int cpu_count = get_cpu_count_from_file(\"/sys/devices/system/cpu/present\");\n    if (cpu_count != get_cpu_count_from_file(\"/sys/devices/system/cpu/online\")) {\n        {\n            fprintf(stderr, \"present cpus != online cpus\\n\");\n            exit(1);\n        }\n        ;\n    }\n    return cpu_count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_cpu_count_name_conflict_from_file)(long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_cpu_count_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = get_cpu_count_name_conflict_from_file(\"/sys/devices/system/cpu/present\");\n  if (v0 != (int)get_cpu_count_name_conflict_from_file(\"/sys/devices/system/cpu/online\")) {\n    fwrite(\"present cpus != online cpus\\n\", 1, 28, stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuu4lfgg6/get_cpu_count_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpuu4lfgg6/get_cpu_count_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpuu4lfgg6/get_cpu_count_name_conflict.c:27:62: error: expected ')'\n   27 |         fwrite(\"present cpus != online cpus\\n\", 1, 28,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpuu4lfgg6/get_cpu_count_name_conflict.c:27:15: note: to match\nthis '(' 27 |         fwrite(\"present cpus != online cpus\\n\", 1, 28,\nstderr@GLIBC_2.2.5); |               ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static int get_cpu_count_from_file(char *filename) {\n    FILE *file;\n    char line[64];\n    int cpu_count;\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    if (!fgets(line, 64, file)) {\n        fprintf(stderr, \"Could not get %s contents\\n\", filename);\n        exit(1);\n    }\n    ;\n    fclose(file);\n    if (strcmp(line, \"0\\n\") == 0) {\n        return 1;\n    }\n    if (1 == sscanf(line, \"0-%d\\n\", &cpu_count)) {\n        return cpu_count + 1;\n    }\n    {\n        fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", filename, line);\n        exit(1);\n    }\n    ;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_cpu_count_from_file(char *a0) {\n  char v0;    // [bp-0x5c]\n  char v1;    // [bp-0x58]\n  FILE_t *v2; // [bp-0x10]\n\n  v2 = &fopen(a0, \"r\")->_flags;\n  if (!v2) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  } else if (!fgets(&v1, 64, v2)) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not get %s contents\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  } else {\n    fclose(v2);\n    if (!strcmp(&v1, \"0\\n\")) {\n      return 1;\n    } else if (__isoc99_sscanf(&v1, \"0-%d\\n\", (unsigned int)&v0) != 1) {\n      fprintf(stderr @GLIBC_2.2.5, \"Unexpected input in file %s (%s).\\n\",\n              (unsigned int)a0, (unsigned int)&v1);\n      exit(1); /* do not return */\n    } else {\n      return *((int *)&v0) + 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:16:8: error: conflicting types for\n'fgets' 16 | char *(fgets)(char *, int, struct FILE_t { |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpcn45jo_3/get_cpu_count_from_file.c:142:16:\nerror: redefinition of '_IO_marker' 142 | typedef struct _IO_marker { | ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:148:16: error: redefinition of\n'_IO_codecvt' 148 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:152:16: error: redefinition of\n'_IO_wide_data' 152 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:175:3: error: typedef redefinition\nwith different types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 175 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpcn45jo_3/get_cpu_count_from_file.c:177:16: error: redeclaration of\n'stderr' with a different type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *'\n(aka 'struct _IO_FILE *') 177 | extern FILE_t *stderr@GLIBC_2.2.5; | ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 177 : 22 : error\n    : expected ';' after top level declarator 177 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 188 : 23 : error : expected ')' 188 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", (unsigned int)a0);\n|\n    ^/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 188 : 16 : note : to match this '(' 188 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", (unsigned int)a0);\n|\n    ^/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 193 : 23 : error : expected ')' 193 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not get %s contents\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 193 : 16 : note : to match this '(' 193 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not get %s contents\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 205 : 27 : error : expected ')' 205 |\n    fprintf(stderr @GLIBC_2.2.5, \"Unexpected input in file %s (%s).\\n\",\n            (unsigned int)a0, (unsigned int)&v1);\n|\n    ^/ tmp / tmpcn45jo_3 /\n        get_cpu_count_from_file.c : 205 : 20 : note : to match this '(' 205 |\n    fprintf(stderr @GLIBC_2.2.5, \"Unexpected input in file %s (%s).\\n\",\n            (unsigned int)a0, (unsigned int)&v1);\n| ^15 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static int get_freq_scales_count(int cpu) {\n    FILE *file;\n    char filename[64];\n    unsigned long freq;\n    int count = 0;\n    sprintf(filename, \"/sys/devices/system/cpu/cpu%d/cpufreq/stats/time_in_state\", cpu);\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    do {\n        freq = 0;\n        fscanf(file, \"%lu %*d\\n\", &freq);\n        if (freq)\n            count++;\n    } while (freq);\n    fclose(file);\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_fscanf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, ...);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_freq_scales_count_name_conflict(unsigned long a0) {\n  void *v0;        // [bp-0x60]\n  char v1;         // [bp-0x58]\n  FILE_t *v2;      // [bp-0x18]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = 0;\n  sprintf(&v1, \"/sys/devices/system/cpu/cpu%d/cpufreq/stats/time_in_state\",\n          (unsigned int)a0);\n  v2 = &fopen(&v1, \"r\")->_flags;\n  if (!v2) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", (unsigned int)&v1);\n    exit(1); /* do not return */\n  }\n  do {\n    v0 = 0;\n    __isoc99_fscanf(v2, \"%lu %*d\\n\", (unsigned int)&v0);\n    if (v0)\n      v3 += 1;\n  } while (v0);\n  fclose(v2);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:141:16: error: redefinition of\n'_IO_marker' 141 | typedef struct _IO_marker { |                ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:147:16: error: redefinition of\n'_IO_codecvt' 147 | typedef struct _IO_codecvt { |                ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:151:16: error: redefinition of\n'_IO_wide_data' 151 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:174:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 174 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmp598nf429/get_freq_scales_count_name_conflict.c:176:16: error: redeclaration of\n'stderr' with a different type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *'\n(aka 'struct _IO_FILE *') 176 | extern FILE_t *stderr@GLIBC_2.2.5; | ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmp598nf429 /\n        get_freq_scales_count_name_conflict.c : 176 : 22 : error\n    : expected ';' after top level declarator 176 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmp598nf429 /\n        get_freq_scales_count_name_conflict.c : 190 : 23 : error : expected ')' 190 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", (unsigned int)&v1);\n|\n    ^/ tmp / tmp598nf429 /\n        get_freq_scales_count_name_conflict.c : 190 : 16 : note : to match this '(' 190 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", (unsigned int)&v1);\n| ^12 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_print_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].time - old_cpus[i].freqs[j].time != new_cpus[0].freqs[j].time - old_cpus[0].freqs[j].time) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint new_cpus; // add global variable by heuristics\nint new_cpus; // add global variable by heuristics\nint old_cpus; // add global variable by heuristics\nint new_cpus; // add global variable by heuristics\nint old_cpus; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int cpu_count;\nextern struct_0 *new_cpus;\nextern struct_0 *old_cpus;\n\nlong long should_print_freq_stats_name_conflict() {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v6; // rax\n\n  for (v1 = 1; v1 < cpu_count; v1 += 1) {\n    for (v0 = 0; v0 < *((int *)&new_cpus->padding_0[72 * v1 + 64]); v0 += 1) {\n      v6 = v1;\n      if (*((long long *)(*((long long *)&new_cpus->padding_0[72 * v1 + 56]) +\n                          v0 * 16 + 8)) -\n              *((long long *)((&old_cpus[v6].field_38)[v6] + (v0 << 4) + 8)) !=\n          *((long long *)(new_cpus->field_38 + (v0 << 4) + 8)) -\n              *((long long *)(old_cpus->field_38 + (v0 << 4) + 8)))\n        return 1;\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:23:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 23 | extern struct_0 *new_cpus; | ^~~~~~~~ |\nstruct /tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:23:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:24:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 24 | extern struct_0 *old_cpus; | ^~~~~~~~ |\nstruct /tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:24:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:34:47: error: member reference type\n'int' is not a pointer 34 |         for (v0 = 0; v0 < *((int\n*)&new_cpus->padding_0[72 * v1 + 64]); v0 += 1) | ~~~~~~~~  ^\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:37:59: error: member reference type\n'int' is not a pointer 37 |             if (*((long long *)(*((long long\n*)&new_cpus->padding_0[72 * v1 + 56]) + v0 * 16 + 8)) - *((long long\n*)((&old_cpus[v6].field_38)[v6] + (v0 << 4) + 8)) != *((long long\n*)(new_cpus->field_38 + (v0 << 4) + 8)) - *((long long *)(old_cpus->field_38 +\n(v0 << 4) + 8))) |                                                 ~~~~~~~~  ^\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:37:128: error: subscripted value is\nnot an array, pointer, or vector 37 |             if (*((long long *)(*((long\nlong *)&new_cpus->padding_0[72 * v1 + 56]) + v0 * 16 + 8)) - *((long long\n*)((&old_cpus[v6].field_38)[v6] + (v0 << 4) + 8)) != *((long long\n*)(new_cpus->field_38 + (v0 << 4) + 8)) - *((long long *)(old_cpus->field_38 +\n(v0 << 4) + 8))) | ~~~~~~~~^~~\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:37:194: error: member reference type\n'int' is not a pointer 37 |             if (*((long long *)(*((long long\n*)&new_cpus->padding_0[72 * v1 + 56]) + v0 * 16 + 8)) - *((long long\n*)((&old_cpus[v6].field_38)[v6] + (v0 << 4) + 8)) != *((long long\n*)(new_cpus->field_38 + (v0 << 4) + 8)) - *((long long *)(old_cpus->field_38 +\n(v0 << 4) + 8))) | ~~~~~~~~  ^\n/tmp/tmpqs4yuk91/should_print_freq_stats_name_conflict.c:37:249: error: member reference type\n'int' is not a pointer 37 |             if (*((long long *)(*((long long\n*)&new_cpus->padding_0[72 * v1 + 56]) + v0 * 16 + 8)) - *((long long\n*)((&old_cpus[v6].field_38)[v6] + (v0 << 4) + 8)) != *((long long\n*)(new_cpus->field_38 + (v0 << 4) + 8)) - *((long long *)(old_cpus->field_38 +\n(v0 << 4) + 8))) | ~~~~~~~~  ^ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_aggregate_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        if (new_cpus[i].freq_count != new_cpus[0].freq_count) {\n            return 0;\n        }\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].freq != new_cpus[0].freqs[j].freq) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint new_cpus; // add global variable by heuristics\nint new_cpus; // add global variable by heuristics\nint new_cpus; // add global variable by heuristics\nint new_cpus; // add global variable by heuristics\nint new_cpus; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int cpu_count;\nextern struct_0 *new_cpus;\n\nlong long should_aggregate_freq_stats_name_conflict() {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  unsigned long long v3; // rax\n  unsigned long long v5; // rax\n\n  v1 = 1;\n  while (v1 >= cpu_count) {\n  LABEL_4027a2:\n    return 1;\n  }\n  v3 = v1;\n  if ((&new_cpus->field_40)[16 * v3 + 2 * v3] != new_cpus->field_40)\n    return 0;\n  for (v0 = 0; v0 < *((int *)&new_cpus->padding_0[72 * v1 + 64]); v0 += 1) {\n    v5 = v1;\n    if (*((int *)((&new_cpus->field_38)[8 * v5 + v5] + (v0 << 4))) !=\n        *((int *)(new_cpus->field_38 + (v0 << 4))))\n      return 0;\n  }\n  v1 += 1;\n  goto LABEL_4027a2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:23:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 23 | extern struct_0 *new_cpus; | ^~~~~~~~ |\nstruct /tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:23:8: error: declaration\nof anonymous struct must be a definition\n/tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:39:21: error: member reference\ntype 'int' is not a pointer 39 |     if ((&new_cpus->field_40)[16 * v3 + 2 * v3]\n!= new_cpus->field_40) |           ~~~~~~~~  ^\n/tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:39:62: error: member reference\ntype 'int' is not a pointer 39 |     if ((&new_cpus->field_40)[16 * v3 + 2 * v3]\n!= new_cpus->field_40) | ~~~~~~~~  ^\n/tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:41:43: error: member reference\ntype 'int' is not a pointer 41 |     for (v0 = 0; v0 < *((int\n*)&new_cpus->padding_0[72 * v1 + 64]); v0 += 1) | ~~~~~~~~  ^\n/tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:44:35: error: member reference\ntype 'int' is not a pointer 44 |         if (*((int *)((&new_cpus->field_38)[8 *\nv5 + v5] + (v0 << 4))) != *((int *)(new_cpus->field_38 + (v0 << 4)))) | ~~~~~~~~\n^ /tmp/tmpfc108l7o/should_aggregate_freq_stats_name_conflict.c:44:95: error: member reference\ntype 'int' is not a pointer 44 |         if (*((int *)((&new_cpus->field_38)[8 *\nv5 + v5] + (v0 << 4))) != *((int *)(new_cpus->field_38 + (v0 << 4)))) | ~~~~~~~~\n^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static struct slab_info *get_slabinfo(struct slab_stat *stats) {\n    struct slab_info *head = ((void *)0), *p = ((void *)0), *prev = ((void *)0);\n    FILE *slabfile;\n    char line[512];\n    unsigned int major, minor;\n    slabfile = fopen(\"/proc/slabinfo\", \"r\");\n    if (!slabfile) {\n        perror(\"fopen\");\n        return ((void *)0);\n    }\n    if (!fgets(line, 512, slabfile)) {\n        fprintf(stderr, \"cannot read from /proc/slabinfo\\n\");\n        return ((void *)0);\n    }\n    if (sscanf(line, \"slabinfo - version: %u.%u\", &major, &minor) != 2) {\n        fprintf(stderr, \"unable to parse slabinfo version!\\n\");\n        return ((void *)0);\n    }\n    if (major != 2 || minor > 1) {\n        fprintf(stderr, \"we only support slabinfo 2.0 and 2.1!\\n\");\n        return ((void *)0);\n    }\n    stats->min_obj_size = 2147483647;\n    while (fgets(line, 512, slabfile))\n        {\n            unsigned long nr_active_slabs, pages_per_slab;\n            int ret;\n            if (line[0] == '#')\n                continue;\n            p = malloc(sizeof(struct slab_info));\n            if (!p) {\n                perror(\"malloc\");\n                head = ((void *)0);\n                break;\n            }\n            if (stats->nr_caches++ == 0)\n                head = prev = p;\n            ret = sscanf(line, \"%32s %lu %lu %lu %lu %lu : tunables %*d %*d %*d :         slabdata %lu %lu %*d\", p->name, &p->nr_active_objs, &p->nr_objs, &p->obj_size, &p->objs_per_slab, &pages_per_slab, &nr_active_slabs, &p->nr_slabs);\n            if (ret != 8) {\n                fprintf(stderr, \"unrecognizable data in slabinfo!\\n\");\n                head = ((void *)0);\n                break;\n            }\n            if (p->obj_size < stats->min_obj_size)\n                stats->min_obj_size = p->obj_size;\n            if (p->obj_size > stats->max_obj_size)\n                stats->max_obj_size = p->obj_size;\n            p->nr_pages = p->nr_slabs * pages_per_slab;\n            if (p->nr_objs) {\n                p->use = 100 * p->nr_active_objs / p->nr_objs;\n                stats->nr_active_caches++;\n            } else\n                p->use = 0;\n            stats->nr_objs += p->nr_objs;\n            stats->nr_active_objs += p->nr_active_objs;\n            stats->total_size += p->nr_objs * p->obj_size;\n            stats->active_size += p->nr_active_objs * p->obj_size;\n            stats->nr_slabs += p->nr_slabs;\n            stats->nr_active_slabs += nr_active_slabs;\n            prev->next = p;\n            prev = p;\n        }\n    if (fclose(slabfile))\n        perror(\"fclose\");\n    if (p)\n        p->next = ((void *)0);\n    if (stats->nr_objs)\n        stats->avg_obj_size = stats->total_size / stats->nr_objs;\n    return head;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(perror)(char *);\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_slabinfo(unsigned long long a0[11]) {\n  char v0;                   // [bp-0x250]\n  char v1;                   // [bp-0x248]\n  char v2;                   // [bp-0x240]\n  char v3;                   // [bp-0x23c]\n  char v4;                   // [bp-0x238]\n  unsigned int v5;           // [bp-0x2c]\n  FILE_t *v6;                // [bp-0x28]\n  unsigned long long v7[12]; // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long long v8[12]; // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long long v9[12]; // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long v12;    // rax\n  unsigned long long v14;    // rax\n\n  v9[0] = 0;\n  v8[0] = 0;\n  v7[0] = 0;\n  v6 = &fopen(\"/proc/slabinfo\", \"r\")->_flags;\n  if (!v6) {\n    perror(\"fopen\");\n    return 0;\n  } else if (!fgets(&v4, 0x200, v6)) {\n    fwrite(\"cannot read from /proc/slabinfo\\n\", 1, 32, stderr @GLIBC_2.2.5);\n    return 0;\n  } else if (__isoc99_sscanf(&v4, \"slabinfo - version: %u.%u\",\n                             (unsigned int)&v3, (unsigned int)&v2) != 2) {\n    fwrite(\"unable to parse slabinfo version!\\n\", 1, 34, stderr @GLIBC_2.2.5);\n    return 0;\n  } else {\n    if (*((int *)&v3) == 2 && *((int *)&v2) <= 1) {\n      a0[9] = 2147483647;\n      while (true) {\n        do {\n          if (!fgets(&v4, 0x200, v6)) {\n            if (fclose(v6))\n              perror(\"fclose\");\n            if (v8)\n              *((long long *)(v8 + 32)) = 0;\n            if (!a0[2])\n              return v9;\n            a0[8] = (0 CONCAT a0[0]) / m a0[2];\n          }\n        } while (v4 == 35);\n        v8 = malloc(96);\n        if (v8) {\n          v12 = a0[6];\n          a0[6] = v12 + 1;\n          if (!v12) {\n            v7 = v8;\n            v9[0] = v7;\n          }\n          v5 = __isoc99_sscanf(&v4,\n                               \"%32s %lu %lu %lu %lu %lu : tunables %*d %*d \"\n                               \"%*d :         slabdata %lu %lu %*d\",\n                               (unsigned int)v8, (unsigned int)(v8 + 56),\n                               (unsigned int)(v8 + 48), (unsigned int)(v8 + 64),\n                               (unsigned int)(v8 + 72), (unsigned int)&v0,\n                               (unsigned int)&v1, (unsigned int)(v8 + 80));\n          if (v5 == 8) {\n            if (*((long long *)(v8 + 64)) < a0[9])\n              a0[9] = *((long long *)(v8 + 64));\n            if (a0[10] < *((long long *)(v8 + 64)))\n              a0[10] = *((long long *)(v8 + 64));\n          } else {\n            fwrite(\"unrecognizable data in slabinfo!\\n\", 1, 33,\n                   stderr @GLIBC_2.2.5);\n            v9 = 0;\n          }\n        } else {\n          perror(\"malloc\");\n          v9 = 0;\n        }\n        *((long long *)(v8 + 40)) =\n            *((long long *)&v0) * *((long long *)(v8 + 80));\n        if (!*((long long *)(v8 + 48))) {\n          *((long long *)(v8 + 88)) = 0;\n        } else {\n          v14 = 5 * *((long long *)(v8 + 56));\n          *((unsigned long long *)(v8 + 88)) =\n              (0 CONCAT(v14 + v14 * 4) * 4) / m * ((long long *)(v8 + 48));\n          a0[7] = a0[7] + 1;\n        }\n        a0[2] = a0[2] + *((long long *)(v8 + 48));\n        a0[3] = a0[3] + *((long long *)(v8 + 56));\n        a0[0] = a0[0] + *((long long *)(v8 + 48)) * *((long long *)(v8 + 64));\n        a0[1] = a0[1] + *((long long *)(v8 + 56)) * *((long long *)(v8 + 64));\n        a0[4] = a0[4] + *((long long *)(v8 + 80));\n        a0[5] = a0[5] + *((long long *)&v1);\n        *((unsigned long *)(v7 + 32)) = v8;\n        v7[0] = v8;\n      }\n    }\n    fwrite(\"we only support slabinfo 2.0 and 2.1!\\n\", 1, 38,\n           stderr @GLIBC_2.2.5);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk54r8f14/get_slabinfo.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpk54r8f14/get_slabinfo.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpk54r8f14/get_slabinfo.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk54r8f14/get_slabinfo.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpk54r8f14/get_slabinfo.c:78:22: error: type name requires a specifier or\nqualifier 78 |             } __value; |                      ^\n/tmp/tmpk54r8f14/get_slabinfo.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpk54r8f14/get_slabinfo.c:85:22: error: type name requires a specifier or\nqualifier 85 |             } __value; |                      ^\n/tmp/tmpk54r8f14/get_slabinfo.c:18:8: error: conflicting types for 'fgets'\n   18 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpk54r8f14/get_slabinfo.c:144:16: error:\nredefinition of '_IO_marker' 144 | typedef struct _IO_marker { | ^\n/tmp/tmpk54r8f14/get_slabinfo.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk54r8f14/get_slabinfo.c:150:16: error: redefinition of '_IO_codecvt'\n  150 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpk54r8f14/get_slabinfo.c:53:12: note: previous definition is here\n   53 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpk54r8f14/get_slabinfo.c:154:16: error: redefinition of '_IO_wide_data'\n  154 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpk54r8f14/get_slabinfo.c:61:12: note: previous definition is here\n   61 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpk54r8f14/get_slabinfo.c:177:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 177 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpk54r8f14/get_slabinfo.c:179:16: error: redeclaration of 'stderr' with a\ndifferent type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka 'struct\n_IO_FILE *') 179 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 179 : 22 : error\n    : expected ';' after top level declarator 179 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpk54r8f14 / get_slabinfo.c : 207 : 66 : error : expected ')' 207 |\n    fwrite(\"cannot read from /proc/slabinfo\\n\", 1, 32, stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 207 : 15 : note : to match this '(' 207 |\n    fwrite(\"cannot read from /proc/slabinfo\\n\", 1, 32, stderr @GLIBC_2.2.5);\n| ^/ tmp / tmpk54r8f14 / get_slabinfo.c : 212 : 68 : error : expected ')' 212 |\n    fwrite(\"unable to parse slabinfo version!\\n\", 1, 34, stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 212 : 15 : note : to match this '(' 212 |\n    fwrite(\"unable to parse slabinfo version!\\n\", 1, 34, stderr @GLIBC_2.2.5);\n| ^/ tmp / tmpk54r8f14 / get_slabinfo.c : 232 : 36 : error : expected ')' 232 |\n    a0[8] = (0 CONCAT a0[0]) / m a0[2];\n|\n    ^/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 232 : 33 : note : to match this '(' 232 |\n    a0[8] = (0 CONCAT a0[0]) / m a0[2];\n|\n    ^/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 232 : 52 : error : expected ';' after expression 232 |\n    a0[8] = (0 CONCAT a0[0]) / m a0[2];\n| ^| ;\n/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 235 : 20 : error\n    : array type 'unsigned long long[12]' is not assignable 235 |\n    v8 = malloc(96);\n|\n    ~~^/ tmp / tmpk54r8f14 /\n        get_slabinfo.c : 242 : 28 : error\n    : array type 'unsigned long long[12]' is not assignable 242 |\n    v7 = v8;\n| ~~^fatal error : too many errors emitted,\n    stopping now[-ferror - limit = ] 20 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *merge_objs(struct slab_info *a, struct slab_info *b) {\n    struct slab_info list;\n    struct slab_info *p = &list;\n    while (a && b)\n        {\n            if (sort_func(a, b)) {\n                p->next = a;\n                p = a;\n                a = a->next;\n            } else {\n                p->next = b;\n                p = b;\n                b = b->next;\n            }\n        }\n    p->next = (a == ((void *)0)) ? b : a;\n    return list.next;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[32];\n  struct struct_0 *field_20;\n} struct_0;\n\nextern struct_1 *sort_func;\n\nlong long merge_objs_name_conflict(struct_0 *a0, struct_0 *a1) {\n  struct_0 *v0; // [bp-0x88], Other Possible Types: unsigned long\n  struct_0 *v1; // [bp-0x80], Other Possible Types: unsigned long\n  char v2;      // [bp-0x78]\n  char v3;      // [bp-0x58]\n  struct_0 *v4; // [bp-0x10], Other Possible Types: unsigned long\n  struct_0 *v6; // rdx\n\n  v1 = a0;\n  v0 = a1;\n  v4 = &v2;\n  while (v1 && v0) {\n    v6 = v0;\n    if (!sort_func(v1, v6, v6, sort_func)) {\n      v4->field_20 = v0;\n      v4 = v0;\n      v0 = *((long long *)(v0 + 32));\n    } else {\n      v4->field_20 = v1;\n      v4 = v1;\n      v1 = *((long long *)(v1 + 32));\n    }\n  }\n  *((int *)&v4->field_20) = (!v1 ? v1 : v0);\n  return *((long long *)&v3);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqw6cpa_9/merge_objs_name_conflict.c:22:8: error: unknown type name 'struct_1'; did you\nmean 'struct_0'? 22 | extern struct_1 *sort_func; |        ^~~~~~~~ | struct_0\n/tmp/tmpqw6cpa_9/merge_objs_name_conflict.c:20:3: note: 'struct_0' declared here\n   20 | } struct_0;\n      |   ^\n/tmp/tmpqw6cpa_9/merge_objs_name_conflict.c:39:23: error: called object type 'struct_0 *' (aka\n'struct struct_0 *') is not a function or function pointer 39 |         if\n(!sort_func(v1, v6, v6, sort_func)) |              ~~~~~~~~~^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *slabsort(struct slab_info *list) {\n    struct slab_info *a, *b;\n    if (!list || !list->next)\n        return list;\n    a = list;\n    b = list->next;\n    while (b && b->next)\n        {\n            list = list->next;\n            b = b->next->next;\n        }\n    b = list->next;\n    list->next = ((void *)0);\n    return merge_objs(slabsort(a), slabsort(b));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(slabsort_name_conflict)(unsigned long);\nlong long(merge_objs)(long long, long long);\n\nlong long slabsort_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x30]\n  unsigned long v1; // [bp-0x28]\n  unsigned long v2; // [bp-0x20]\n  unsigned long v3; // [bp-0x10]\n  unsigned long v5; // rbx\n\n  v3 = v5;\n  v0 = a0;\n  if (v0 && *((long long *)(v0 + 32))) {\n    v1 = v0;\n    for (v2 = *((long long *)(v0 + 32)); v2 && *((long long *)(v2 + 32));\n         v2 = *((long long *)(*((long long *)(v2 + 32)) + 32))) {\n      v0 = *((long long *)(v0 + 32));\n    }\n    v2 = *((long long *)(v0 + 32));\n    *((long long *)(v0 + 32)) = 0;\n    return merge_objs(slabsort_name_conflict(v1), slabsort_name_conflict(v2));\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"int wav_play(const char *fn) {\n    struct wav_header hdr;\n    unsigned int rate, channels;\n    int fd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        fprintf(stderr, \"playwav: cannot open '%s'\\n\", fn);\n        return -1;\n    }\n    if (read(fd, &hdr, sizeof (hdr)) != sizeof (hdr)) {\n        fprintf(stderr, \"playwav: cannot read header\\n\");\n        return -1;\n    }\n    fprintf(stderr, \"playwav: %d ch, %d hz, %d bit, %s\\n\", hdr.num_channels, hdr.sample_rate, hdr.bits_per_sample, hdr.audio_format == 1 ? \"PCM\" : \"unknown\");\n    if ((hdr.riff_id != 1179011410) || (hdr.riff_fmt != 1163280727) || (hdr.fmt_id != 544501094)) {\n        fprintf(stderr, \"playwav: '%s' is not a riff/wave file\\n\", fn);\n        return -1;\n    }\n    if ((hdr.audio_format != 1) || (hdr.fmt_sz != 16)) {\n        fprintf(stderr, \"playwav: '%s' is not pcm format\\n\", fn);\n        return -1;\n    }\n    if (hdr.bits_per_sample != 16) {\n        fprintf(stderr, \"playwav: '%s' is not 16bit per sample\\n\", fn);\n        return -1;\n    }\n    play_file(hdr.sample_rate, hdr.num_channels, fd, hdr.data_sz);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nlong(read)(int, void *, unsigned long);\nlong long(play_file)(long long, long long, long long, long long);\n\nextern char g_4020f4;\nextern char g_4020f8;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long wav_play_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;          // [bp-0x38]\n  char v1;          // [bp-0x30]\n  char v2;          // [bp-0x2c]\n  char v3;          // [bp-0x28]\n  char v4;          // [bp-0x24]\n  char v5;          // [bp-0x22]\n  char v6;          // [bp-0x20]\n  char v7;          // [bp-0x16]\n  char v8;          // [bp-0x10]\n  unsigned int v9;  // [bp-0xc]\n  unsigned int v12; // eax\n\n  v9 = open(a0, 0, a2);\n  if (v9 < 0) {\n    fprintf(stderr @GLIBC_2.2.5, \"playwav: cannot open '%s'\\n\",\n            (unsigned int)a0);\n    return 4294967295;\n  } else if ((int)read(v9, &v0, 44) == 44) {\n    if (*((short *)&v4) != 1)\n      v12 = &g_4020f8;\n    else\n      v12 = &g_4020f4;\n    fprintf(stderr @GLIBC_2.2.5, \"playwav: %d ch, %d hz, %d bit, %s\\n\",\n            *((short *)&v5), *((int *)&v6), *((short *)&v7), v12);\n    if (*((int *)&v0) == 1179011410 && *((int *)&v1) == 1163280727 &&\n        *((int *)&v2) == 544501094) {\n      if (*((short *)&v4) == 1 && *((int *)&v3) == 16) {\n        if (*((short *)&v7) != 16) {\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"playwav: '%s' is not 16bit per sample\\n\", (unsigned int)a0);\n          return 4294967295;\n        }\n        play_file(*((int *)&v6), *((short *)&v5), v9, *((int *)&v8));\n        return 0;\n      }\n      fprintf(stderr @GLIBC_2.2.5, \"playwav: '%s' is not pcm format\\n\",\n              (unsigned int)a0);\n      return 4294967295;\n    }\n    fprintf(stderr @GLIBC_2.2.5, \"playwav: '%s' is not a riff/wave file\\n\",\n            (unsigned int)a0);\n    return 4294967295;\n  } else {\n    fwrite(\"playwav: cannot read header\\n\", 1, 28, stderr @GLIBC_2.2.5);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:41:23: error: expected ')'\n   41 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: cannot open '%s'\\n\",\n(unsigned int)a0); |                       ^ /tmp/tmpa9h809hj/wav_play_name_conflict.c:41:16:\nnote: to match this '(' 41 |         fprintf(stderr@GLIBC_2.2.5, \"playwav:\ncannot open '%s'\\n\", (unsigned int)a0); |                ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:50:23: error: expected ')'\n   50 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: %d ch, %d hz, %d bit,\n%s\\n\", *((short *)&v5), *((int *)&v6), *((short *)&v7), v12); | ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:50:16: note: to match this '('\n   50 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: %d ch, %d hz, %d bit,\n%s\\n\", *((short *)&v5), *((int *)&v6), *((short *)&v7), v12); |                ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:57:35: error: expected ')'\n   57 |                     fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not\n16bit per sample\\n\", (unsigned int)a0); |                                   ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:57:28: note: to match this '('\n   57 |                     fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not\n16bit per sample\\n\", (unsigned int)a0); |                            ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:63:27: error: expected ')'\n   63 |             fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not pcm\nformat\\n\", (unsigned int)a0); |                           ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:63:20: note: to match this '('\n   63 |             fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not pcm\nformat\\n\", (unsigned int)a0); |                    ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:66:23: error: expected ')'\n   66 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not a riff/wave\nfile\\n\", (unsigned int)a0); |                       ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:66:16: note: to match this '('\n   66 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not a riff/wave\nfile\\n\", (unsigned int)a0); |                ^\n/tmp/tmpa9h809hj/wav_play_name_conflict.c:71:62: error: expected ')'\n   71 |         fwrite(\"playwav: cannot read header\\n\", 1, 28,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpa9h809hj/wav_play_name_conflict.c:71:15: note: to match this\n'(' 71 |         fwrite(\"playwav: cannot read header\\n\", 1, 28,\nstderr@GLIBC_2.2.5); |               ^ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"int wav_rec(const char *fn, unsigned int channels, unsigned int rate) {\n    struct wav_header hdr;\n    unsigned char buf[8192];\n    struct msm_audio_config cfg;\n    unsigned int sz, n;\n    int fd, afd;\n    unsigned int total = 0;\n    unsigned char tmp;\n    hdr.riff_id = 1179011410;\n    hdr.riff_sz = 0;\n    hdr.riff_fmt = 1163280727;\n    hdr.fmt_id = 544501094;\n    hdr.fmt_sz = 16;\n    hdr.audio_format = 1;\n    hdr.num_channels = channels;\n    hdr.sample_rate = rate;\n    hdr.byte_rate = hdr.sample_rate * hdr.num_channels * 2;\n    hdr.block_align = hdr.num_channels * 2;\n    hdr.bits_per_sample = 16;\n    hdr.data_id = 1635017060;\n    hdr.data_sz = 0;\n    fd = open(fn, 64 | 2, 438);\n    if (fd < 0) {\n        perror(\"cannot open output file\");\n        return -1;\n    }\n    write(fd, &hdr, sizeof (hdr));\n    afd = open(\"/dev/msm_pcm_in\", 2);\n    if (afd < 0) {\n        perror(\"cannot open msm_pcm_in\");\n        close(fd);\n        return -1;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    cfg.channel_count = hdr.num_channels;\n    cfg.sample_rate = hdr.sample_rate;\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot write audio config\");\n        goto fail;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    sz = cfg.buffer_size;\n    fprintf(stderr, \"buffer size %d x %d\\n\", sz, cfg.buffer_count);\n    if (sz > sizeof (buf)) {\n        fprintf(stderr, \"buffer size %d too large\\n\", sz);\n        goto fail;\n    }\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0)) {\n        perror(\"cannot start audio\");\n        goto fail;\n    }\n    fcntl(0, 4, 2048);\n    fprintf(stderr, \"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\");\n    for (;;) {\n        while (read(0, &tmp, 1) == 1)\n            {\n                if ((tmp == 13) || (tmp == 10))\n                    goto done;\n            }\n        if (read(afd, buf, sz) != sz) {\n            perror(\"cannot read buffer\");\n            goto fail;\n        }\n        if (write(fd, buf, sz) != sz) {\n            perror(\"cannot write buffer\");\n            goto fail;\n        }\n        total += sz;\n    }\n  done:\n    close(afd);\n    hdr.data_sz = total;\n    hdr.riff_sz = total + 8 + 16 + 8;\n    lseek(fd, 0, 0);\n    write(fd, &hdr, sizeof (hdr));\n    close(fd);\n    return 0;\n  fail:\n    close(afd);\n    close(fd);\n    unlink(fn);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\nint(unlink)(char *);\nint(fcntl)(int, int, ...);\nlong(read)(int, void *, unsigned long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long wav_rec_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;    // [bp-0x2088]\n  char v1;            // [bp-0x2069]\n  char v2;            // [bp-0x2068]\n  char v3;            // [bp-0x2064]\n  unsigned int v4;    // [bp-0x2060]\n  unsigned int v5;    // [bp-0x205c]\n  char v6;            // [bp-0x2048]\n  char v7;            // [bp-0x48]\n  unsigned int v8;    // [bp-0x44]\n  char v9;            // [bp-0x40]\n  unsigned int v10;   // [bp-0x38]\n  unsigned short v11; // [bp-0x34]\n  unsigned int v12;   // [bp-0x30]\n  unsigned int v13;   // [bp-0x2c]\n  unsigned short v14; // [bp-0x28]\n  unsigned short v15; // [bp-0x26]\n  char v16;           // [bp-0x24]\n  unsigned int v17;   // [bp-0x20]\n  unsigned int v18;   // [bp-0x18]\n  unsigned int v19;   // [bp-0x14]\n  unsigned int v20;   // [bp-0x10]\n  unsigned int v21;   // [bp-0xc]\n\n  v0 = a2;\n  v21 = 0;\n  strncpy(&v7, \"RIFF\", 4);\n  v8 = 0;\n  strncpy(&v9, \"WAVEfmt \", 8);\n  v10 = 16;\n  v11 = 1;\n  v12 = v0;\n  v13 = v12 * (unsigned int)a1 * 2;\n  v14 = (unsigned int)a1 * 2;\n  v15 = 16;\n  strncpy(&v16, \"data\", 4);\n  v17 = 0;\n  v20 = open(a0, 66, 438);\n  if (v20 < 0) {\n    perror(\"cannot open output file\");\n    return 4294967295;\n  }\n  write(v20, &v7, 44);\n  v19 = open(\"/dev/msm_pcm_in\", 2, 44);\n  if (v19 < 0) {\n    perror(\"cannot open msm_pcm_in\");\n    close(v20);\n    return 4294967295;\n  }\n  if (ioctl(v19, 2147770627)) {\n    perror(\"cannot read audio config\");\n  } else {\n    v4 = a1;\n    v5 = v12;\n    if (ioctl(v19, 1074028804)) {\n      perror(\"cannot write audio config\");\n    } else if (ioctl(v19, 2147770627)) {\n      perror(\"cannot read audio config\");\n    } else {\n      v18 = *((int *)&v2);\n      fprintf(stderr @GLIBC_2.2.5, \"buffer size %d x %d\\n\", v18, *((int *)&v3));\n      if (v18 > 0x2000) {\n        fprintf(stderr @GLIBC_2.2.5, \"buffer size %d too large\\n\", v18);\n      } else if (ioctl(v19, 0x40046100)) {\n        perror(\"cannot start audio\");\n      } else {\n        fcntl(0, 4);\n        fwrite(\"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\", 1, 39,\n               stderr @GLIBC_2.2.5);\n        while (true) {\n          while ((int)read(0, &v1, 1) == 1) {\n            if (!(v1 != 13) || !(v1 != 10)) {\n              close(v19);\n              v17 = v21;\n              v8 = v21 + 32;\n              lseek(v20, 0, 0);\n              write(v20, &v7, 44);\n              close(v20);\n              return 0;\n            }\n          }\n          if (v18 != (int)read(v19, &v6, v18)) {\n            perror(\"cannot read buffer\");\n            close(v19);\n          }\n          if (v18 != (int)write(v20, &v6, v18))\n            break;\n          v21 += v18;\n        }\n        perror(\"cannot write buffer\");\n      }\n    }\n  }\n  close(v19);\n  close(v20);\n  unlink(a0);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:24:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 24 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:24:22: error: expected ';' after top level declarator\n   24 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:97:27: error: expected ')'\n   97 |             fprintf(stderr@GLIBC_2.2.5, \"buffer size %d x %d\\n\", v18,\n*((int *)&v3)); |                           ^ /tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:97:20:\nnote: to match this '(' 97 |             fprintf(stderr@GLIBC_2.2.5, \"buffer\nsize %d x %d\\n\", v18, *((int *)&v3)); |                    ^\n/tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:100:31: error: expected ')'\n  100 |                 fprintf(stderr@GLIBC_2.2.5, \"buffer size %d too\nlarge\\n\", v18); |                               ^\n/tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:100:24: note: to match this '('\n  100 |                 fprintf(stderr@GLIBC_2.2.5, \"buffer size %d too\nlarge\\n\", v18); |                        ^ /tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:109:82:\nerror: expected ')' 109 |                 fwrite(\"\\n*** RECORDING * HIT ENTER TO\nSTOP ***\\n\", 1, 39, stderr@GLIBC_2.2.5); | ^ /tmp/tmpjpk_ydn7/wav_rec_name_conflict.c:109:23:\nnote: to match this '(' 109 |                 fwrite(\"\\n*** RECORDING * HIT\nENTER TO STOP ***\\n\", 1, 39, stderr@GLIBC_2.2.5); |                       ^ 6\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"int mp3_play(const char *fn) {\n    char buf[65536];\n    int r;\n    int fd, afd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        perror(\"cannot open mp3 file\");\n        return -1;\n    }\n    afd = open(\"/dev/msm_mp3\", 2);\n    if (afd < 0) {\n        close(fd);\n        perror(\"cannot open mp3 output device\");\n        return -1;\n    }\n    fprintf(stderr, \"MP3 PLAY\\n\");\n    ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0);\n    for (;;) {\n        r = read(fd, buf, 64 * 1024);\n        if (r <= 0)\n            break;\n        r = write(afd, buf, r);\n        if (r < 0)\n            break;\n    }\n    close(fd);\n    close(afd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nint(close)(int);\nlong(read)(int, void *, unsigned long);\nlong(write)(int, void *, unsigned long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long mp3_play_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x10018]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = open(a0, 0, a2);\n  if (v3 < 0) {\n    perror(\"cannot open mp3 file\");\n    return 4294967295;\n  }\n  v2 = open(\"/dev/msm_mp3\", 2, a2);\n  if (v2 < 0) {\n    close(v3);\n    perror(\"cannot open mp3 output device\");\n    return 4294967295;\n  }\n  fwrite(\"MP3 PLAY\\n\", 1, 9, stderr @GLIBC_2.2.5);\n  ioctl(v2, 0x40046100);\n  do {\n    v1 = read(v3, &v0, 0x10000);\n    if (v1 <= 0)\n      break;\n  } while ((v1 = (unsigned int)(int)write(v2, &v0, (unsigned long long)v1),\n            v1 >= 0));\n  close(v3);\n  close(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpogav0vb5/mp3_play_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpogav0vb5/mp3_play_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpogav0vb5/mp3_play_name_conflict.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpogav0vb5/mp3_play_name_conflict.c:44:38: error: expected ')'\n   44 |     fwrite(\"MP3 PLAY\\n\", 1, 9, stderr@GLIBC_2.2.5);\n      |                                      ^\n/tmp/tmpogav0vb5/mp3_play_name_conflict.c:44:11: note: to match this '('\n   44 |     fwrite(\"MP3 PLAY\\n\", 1, 9, stderr@GLIBC_2.2.5);\n      |           ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"static struct latency_entry *read_global_stats(struct latency_entry *list, int erase) {\n    FILE *f;\n    struct latency_entry *e;\n    if (erase) {\n        f = fopen(GLOBAL_STATS_FILE, \"w\");\n        if (!f) {\n            fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n        exit(1);\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(read_latency_file)(long long, long long);\nchar *(strerror)(int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern char *GLOBAL_STATS_FILE;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_global_stats_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long v0;      // [bp-0x18]\n  FILE_t *v1;            // [bp-0x10]\n  unsigned long long v4; // rax\n  unsigned long long v6; // rax\n\n  if ((unsigned int)a1) {\n    v1 = &fopen(GLOBAL_STATS_FILE, \"w\")->_flags;\n    if (!v1) {\n      (unsigned int)v4 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5,\n              \"Could not open global latency stats file: %s\\n\",\n              (unsigned int)v4);\n      exit(1); /* do not return */\n    }\n    fwrite(\"erase\\n\", 1, 6, v1);\n    fclose(v1);\n  }\n  v1 = &fopen(GLOBAL_STATS_FILE, \"r\")->_flags;\n  if (!v1) {\n    (unsigned int)v6 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not open global latency stats file: %s\\n\", (unsigned int)v6);\n    exit(1); /* do not return */\n  }\n  v0 = read_latency_file(v1, a0);\n  fclose(v1);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd40hd2dl/read_global_stats_name_conflict.c:87:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 87 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpd40hd2dl/read_global_stats_name_conflict.c:90:16: error: redeclaration of 'stderr'\nwith a different type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka\n'struct _IO_FILE *') 90 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpd40hd2dl /\n        read_global_stats_name_conflict.c : 90 : 22 : error\n    : expected ';' after top level declarator 90 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpd40hd2dl /\n    read_global_stats_name_conflict.c : 104 : 41 : error\n    : indirection\n        requires pointer\n      operand('int' invalid) 104 |\n      (unsigned int)v4 = strerror(*(__errno_location()));\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpd40hd2dl /\n        read_global_stats_name_conflict.c : 105 : 27 : error : expected ')' 105 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not open global latency stats file: %s\\n\", (unsigned int)v4);\n|\n    ^/ tmp / tmpd40hd2dl /\n        read_global_stats_name_conflict.c : 105 : 20 : note : to match this '(' 105 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not open global latency stats file: %s\\n\", (unsigned int)v4);\n| ^/ tmp / tmpd40hd2dl /\n        read_global_stats_name_conflict.c : 114 : 37 : error\n    : indirection\n        requires pointer\n      operand('int' invalid) 114 |\n      (unsigned int)v6 = strerror(*(__errno_location()));\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpd40hd2dl /\n        read_global_stats_name_conflict.c : 115 : 23 : error : expected ')' 115 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not open global latency stats file: %s\\n\", (unsigned int)v6);\n|\n    ^/ tmp / tmpd40hd2dl /\n        read_global_stats_name_conflict.c : 115 : 16 : note : to match this '(' 115 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not open global latency stats file: %s\\n\", (unsigned int)v6);\n| ^7 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_process_stats(struct latency_entry *list, int erase, int pid) {\n    char dirname[64];\n    DIR *dir;\n    struct dirent *ent;\n    struct latency_entry *e;\n    int tid;\n    sprintf(dirname, \"/proc/%d/task\", pid);\n    dir = opendir(dirname);\n    if (!dir) {\n        fprintf(stderr, \"Could not open task dir for process %d.\\n\", pid);\n        fprintf(stderr, \"Perhaps the process has terminated?\\n\");\n        exit(1);\n    }\n    e = list;\n    while ((ent = readdir(dir)))\n        {\n            if (!((*__ctype_b_loc())[(int)((ent->d_name[0]))] & (unsigned short)_ISdigit))\n                continue;\n            tid = atoi(ent->d_name);\n            e = read_thread_stats(e, erase, pid, tid, 0);\n        }\n    closedir(dir);\n    return e;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nint(atoi)(char *);\nlong long(read_thread_stats)(long long, long long, long long, long long,\n                             long long);\n\ntypedef struct struct_0 {\n  char padding_0[19];\n  char field_13;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_process_stats(unsigned long a0, unsigned long a1,\n                             unsigned long a2) {\n  char v0;          // [bp-0x78]\n  char v1;          // [bp-0x68]\n  unsigned int v2;  // [bp-0x24]\n  struct_0 *v3;     // [bp-0x20]\n  char *v4;         // [bp-0x18]\n  unsigned long v5; // [bp-0x10], Other Possible Types: unsigned long long\n\n  sprintf(&v1, \"/proc/%d/task\", (unsigned int)a2);\n  v4 = opendir(&v1);\n  if (!v4) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open task dir for process %d.\\n\",\n            *((int *)&v0));\n    fwrite(\"Perhaps the process has terminated?\\n\", 1, 36, stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n  for (v5 = a0; v3;\n       v5 = read_thread_stats(v5, (unsigned int)a1, *((int *)&v0), v2, 0)) {\n    v3 = &readdir(v4);\n    if ((*((short *)((v3->field_13 << 1) + *((long long *)&__ctype_b_loc()))) &\n         0x800))\n      v2 = atoi(&v3->field_13);\n  }\n  closedir(v4);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_ugszkgr/read_process_stats.c:27:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 27 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp_ugszkgr/read_process_stats.c:27:22: error: expected ';' after top level\ndeclarator 27 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp_ugszkgr/read_process_stats.c:42:23: error: expected ')'\n   42 |         fprintf(stderr@GLIBC_2.2.5, \"Could not open task dir for process\n%d.\\n\", *((int *)&v0)); |                       ^\n/tmp/tmp_ugszkgr/read_process_stats.c:42:16: note: to match this '('\n   42 |         fprintf(stderr@GLIBC_2.2.5, \"Could not open task dir for process\n%d.\\n\", *((int *)&v0)); |                ^\n/tmp/tmp_ugszkgr/read_process_stats.c:43:70: error: expected ')'\n   43 |         fwrite(\"Perhaps the process has terminated?\\n\", 1, 36,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp_ugszkgr/read_process_stats.c:43:15: note: to\nmatch this '(' 43 |         fwrite(\"Perhaps the process has terminated?\\n\", 1,\n36, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp_ugszkgr/read_process_stats.c:48:14: error: cannot take the address of\nan rvalue of type 'char *' 48 |         v3 = &readdir(v4); | ^~~~~~~~~~~~\n/tmp/tmp_ugszkgr/read_process_stats.c:49:63: error: cannot take the address of\nan rvalue of type 'int' 49 |         if ((*((short *)((v3->field_13 << 1) +\n*((long long *)&__ctype_b_loc()))) & 0x800)) | ^~~~~~~~~~~~~~~~ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_thread_stats(struct latency_entry *list, int erase, int pid, int tid, int fatal) {\n    char filename[64];\n    FILE *f;\n    struct latency_entry *e;\n    sprintf(filename, THREAD_STATS_FILE_FORMAT, pid, tid);\n    if (erase) {\n        f = fopen(filename, \"w\");\n        if (!f) {\n            if (fatal) {\n                fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n                fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n                exit(1);\n            } else {\n                return list;\n            }\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        if (fatal) {\n            fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n            fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n            exit(1);\n        } else {\n            return list;\n        }\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(read_latency_file)(long long, long long);\nchar *(strerror)(int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern char *GLOBAL_STATS_FILE;\nextern char *THREAD_STATS_FILE_FORMAT;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_thread_stats(unsigned long long a0, unsigned long a1,\n                            unsigned long a2, unsigned long a3,\n                            unsigned long a4) {\n  unsigned int v0;        // [bp-0x6c]\n  unsigned int v1;        // [bp-0x68]\n  char v2;                // [bp-0x58]\n  unsigned long v3;       // [bp-0x18]\n  FILE_t *v4;             // [bp-0x10]\n  unsigned long long v8;  // rax\n  unsigned long long v10; // rax\n\n  v1 = a2;\n  v0 = a3;\n  sprintf(&v2, THREAD_STATS_FILE_FORMAT);\n  if ((unsigned int)a1) {\n    v4 = &fopen(&v2, \"w\")->_flags;\n    if (v4) {\n      fwrite(\"erase\\n\", 1, 6, v4);\n      fclose(v4);\n    } else if ((unsigned int)a4) {\n      (unsigned int)v8 = strerror(*(__errno_location()));\n      fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v2,\n              (unsigned int)v8);\n      fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n             stderr @GLIBC_2.2.5);\n      exit(1); /* do not return */\n    } else {\n      return a0;\n    }\n  }\n  v4 = &fopen(GLOBAL_STATS_FILE, \"r\")->_flags;\n  if (v4) {\n    v3 = read_latency_file(v4, a0);\n    fclose(v4);\n    return v3;\n  } else if ((unsigned int)a4) {\n    (unsigned int)v10 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v2,\n            (unsigned int)v10);\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  } else {\n    return a0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcr492gqs/read_thread_stats.c:87:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 87 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpcr492gqs/read_thread_stats.c:91:16: error: redeclaration of 'stderr'\nwith a different type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka\n'struct _IO_FILE *') 91 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 91 : 22 : error\n    : expected ';' after top level declarator 91 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpcr492gqs /\n    read_thread_stats.c : 116 : 41 : error\n    : indirection\n        requires pointer\n      operand('int' invalid) 116 |\n      (unsigned int)v8 = strerror(*(__errno_location()));\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 117 : 27 : error : expected ')' 117 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v2,\n            (unsigned int)v8);\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 117 : 20 : note : to match this '(' 117 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v2,\n            (unsigned int)v8);\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 118 : 84 : error : expected ')' 118 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 118 : 19 : note : to match this '(' 118 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n| ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 135 : 38 : error\n    : indirection\n        requires pointer\n      operand('int' invalid) 135 |\n      (unsigned int)v10 = strerror(*(__errno_location()));\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 136 : 23 : error : expected ')' 136 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v2,\n            (unsigned int)v10);\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 136 : 16 : note : to match this '(' 136 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v2,\n            (unsigned int)v10);\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 137 : 80 : error : expected ')' 137 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpcr492gqs /\n        read_thread_stats.c : 137 : 15 : note : to match this '(' 137 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n| ^9 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *alloc_latency_entry(void) {\n    struct latency_entry *e;\n    if (free_entries) {\n        e = free_entries;\n        free_entries = free_entries->next;\n    } else {\n        e = calloc(1, sizeof(struct latency_entry));\n        if (!e) {\n            fprintf(stderr, \"Could not allocate latency entry: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n    }\n    return e;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint free_entries; // add global variable by heuristics\nint free_entries; // add global variable by heuristics\nint free_entries; // add global variable by heuristics\nint free_entries; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nextern struct_0 *free_entries;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long alloc_latency_entry_name_conflict() {\n  struct struct_0 **v0;  // [bp-0x10], Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  if (free_entries) {\n    v0 = &free_entries->field_0;\n    free_entries = free_entries->field_0;\n    return v0;\n  }\n  v0 = calloc(1, 544);\n  if (!v0) {\n    (unsigned int)v3 = strerror(*(__errno_location()));\n    fprintf(stderr @GLIBC_2.2.5, \"Could not allocate latency entry: %s\\n\",\n            (unsigned int)v3);\n    exit(1); /* do not return */\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:22:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 22 | extern struct_0 *free_entries; |\n^~~~~~~~ |        struct /tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:22:8: error:\ndeclaration of anonymous struct must be a definition\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:23:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 23 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:23:22: error: expected ';' after top\nlevel declarator 23 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:32:29: error: member reference type 'int'\nis not a pointer 32 |         v0 = &free_entries->field_0; | ~~~~~~~~~~~~  ^\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:33:38: error: member reference type 'int'\nis not a pointer 33 |         free_entries = free_entries->field_0; |\n~~~~~~~~~~~~  ^ /tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:39:37: error: indirection\nrequires pointer operand ('int' invalid) 39 |         (unsigned int)v3 =\nstrerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:40:23: error: expected ')'\n   40 |         fprintf(stderr@GLIBC_2.2.5, \"Could not allocate latency entry:\n%s\\n\", (unsigned int)v3); |                       ^\n/tmp/tmp9v87tx78/alloc_latency_entry_name_conflict.c:40:16: note: to match this '('\n   40 |         fprintf(stderr@GLIBC_2.2.5, \"Could not allocate latency entry:\n%s\\n\", (unsigned int)v3); |                ^ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *find_latency_entry(struct latency_entry *head, char *reason) {\n    struct latency_entry *e;\n    e = head;\n    while (e)\n        {\n            if (!strcmp(e->reason, reason))\n                return e;\n            e = e->next;\n        }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long find_latency_entry_name_conflict(struct struct_0 **a0, char *a1) {\n  struct struct_0 **v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  for (v0 = a0; v0; v0 = *((long long *)v0)) {\n    if (!strcmp(v0 + 32, a1))\n      return v0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static int numcmp(const long long a, const long long b) {\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long numcmp_name_conflict(unsigned long a0, unsigned long a1) {\n  return (a0 < a1 ? (a0 <= a1 ? 1 : 0) : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":1,"function":"static const char *next_line(const char *b) {\n    while (1)\n        {\n            switch (*b) {\n              case '\\n':\n                return b + 1;\n              case '\\x00':\n                return ((void *)0);\n            }\n            b++;\n        }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long next_line_name_conflict(char *a0) {\n  char *v0;        // [bp-0x10], Other Possible Types: unsigned long\n  unsigned int v2; // eax\n\n  for (v0 = a0; v2; v0 += 1) {\n    v2 = *((char *)v0);\n    if (v2 == 10)\n      return v0 + 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int print() {\n    int i;\n    printf(\"CPU  yield() schedule() switch idle   ttwu() local  cpu_time wait_time timeslices\\n\");\n    for (i = 0; i < 2; i++) {\n        printf(\" %2d  %7u %10u %6u %4u %8u %5u %9llu %9llu %10lu\\n\", i, cpu_delta[i].yld_count, cpu_delta[i].sched_count, cpu_delta[i].sched_switch, cpu_delta[i].sched_goidle, cpu_delta[i].ttwu_count, cpu_delta[i].ttwu_local, cpu_delta[i].cpu_time / 1000000, cpu_delta[i].run_delay / 1000000, cpu_delta[i].pcount);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char cpu_delta;\nextern char g_4040e4;\nextern char g_4040e8;\nextern char g_4040ec;\nextern char g_4040f0;\nextern char g_4040f4;\nextern char g_4040f8;\nextern char g_404100;\nextern char g_404108;\n\nlong long print_name_conflict() {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned long v1;      // [bp-0x10]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long v5;      // rbx\n  unsigned long long v6; // rbx\n\n  v4 = &v2;\n  v1 = v5;\n  puts(\"CPU  yield() schedule() switch idle   ttwu() local  cpu_time wait_time \"\n       \"timeslices\");\n  for (v0 = 0; v0 <= 1; v0 += 1) {\n    print_name_conflictf(\" %2d  %7u %10u %6u %4u %8u %5u %9llu %9llu %10lu\\n\", v0,\n           *((int *)&(&cpu_delta)[48 * v0]), *((int *)&(&g_4040e8)[48 * v0]),\n           *((int *)&(&g_4040e4)[48 * v0]), *((int *)&(&g_4040ec)[48 * v0]),\n           *((int *)&(&g_4040f0)[48 * v0]), *((int *)&(&g_4040f4)[48 * v0]),\n           (int)(*((long long *)&(&g_4040f8)[48 * v0]) * 4835703278458516699 >>\n                 64 >> 18),\n           (int)(*((long long *)&(&g_404100)[48 * v0]) * 4835703278458516699 >>\n                 64 >> 18),\n           (int)*((long long *)&(&g_404108)[48 * v0]));\n  }\n  v6 = v1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse_cpu_v15(const char *b) {\n    int cpu;\n    if (sscanf(b, \"cpu%d %u %u %u %u %u %u %llu %llu %lu\\n\", &cpu, &tmp.yld_count, &tmp.sched_switch, &tmp.sched_count, &tmp.sched_goidle, &tmp.ttwu_count, &tmp.ttwu_local, &tmp.cpu_time, &tmp.run_delay, &tmp.pcount) != 10) {\n        printf(\"Could not parse %s\\n\", b);\n        return -1;\n    }\n    cpu_delta[cpu].yld_count = tmp.yld_count - cpu_prev[cpu].yld_count;\n    cpu_delta[cpu].sched_switch = tmp.sched_switch - cpu_prev[cpu].sched_switch;\n    cpu_delta[cpu].sched_count = tmp.sched_count - cpu_prev[cpu].sched_count;\n    cpu_delta[cpu].sched_goidle = tmp.sched_goidle - cpu_prev[cpu].sched_goidle;\n    cpu_delta[cpu].ttwu_count = tmp.ttwu_count - cpu_prev[cpu].ttwu_count;\n    cpu_delta[cpu].ttwu_local = tmp.ttwu_local - cpu_prev[cpu].ttwu_local;\n    cpu_delta[cpu].cpu_time = tmp.cpu_time - cpu_prev[cpu].cpu_time;\n    cpu_delta[cpu].run_delay = tmp.run_delay - cpu_prev[cpu].run_delay;\n    cpu_delta[cpu].pcount = tmp.pcount - cpu_prev[cpu].pcount;\n    cpu_prev[cpu] = tmp;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char padding_0[4210928];\n  unsigned int field_4040f0;\n} struct_0;\n\nextern char cpu_delta;\nextern char cpu_prev;\nextern char g_404084;\nextern char g_404088;\nextern char g_40408c;\nextern char g_404090;\nextern char g_404094;\nextern char g_404098;\nextern char g_4040a0;\nextern char g_4040a8;\nextern char g_4040e4;\nextern char g_4040e8;\nextern char g_4040ec;\nextern char g_4040f0;\nextern char g_4040f4;\nextern char g_4040f8;\nextern char g_404100;\nextern char g_404108;\nextern unsigned int g_404144;\nextern unsigned int g_404148;\nextern unsigned int g_40414c;\nextern unsigned int g_404150;\nextern unsigned int g_404154;\nextern unsigned long long g_404158;\nextern unsigned long long g_404160;\nextern unsigned long long g_404168;\nextern unsigned int tmp;\n\nlong long parse_cpu_v15_name_conflict(char *a0) {\n  char v0;                        // [bp-0x1c]\n  unsigned long long v32[526358]; // rdx\n\n  if (__isoc99_sscanf(a0, \"cpu%d %u %u %u %u %u %u %llu %llu %lu\\n\",\n                      (unsigned int)&v0, &tmp, &g_404144, &g_404148, &g_40414c,\n                      &g_404150, &g_404154, &g_404158, &g_404160,\n                      &g_404168) == 10) {\n    *((unsigned int *)&(&cpu_delta)[48 * *((int *)&v0)]) =\n        tmp - *((int *)&(&cpu_prev)[48 * *((int *)&v0)]);\n    *((unsigned int *)&(&g_4040e4)[48 * *((int *)&v0)]) =\n        g_404144 - *((int *)&(&g_404084)[48 * *((int *)&v0)]);\n    *((unsigned int *)&(&g_4040e8)[48 * *((int *)&v0)]) =\n        g_404148 - *((int *)&(&g_404088)[48 * *((int *)&v0)]);\n    *((unsigned int *)&(&g_4040ec)[48 * *((int *)&v0)]) =\n        g_40414c - *((int *)&(&g_40408c)[48 * *((int *)&v0)]);\n    *((unsigned int *)&(&g_4040f0)[48 * *((int *)&v0)]) =\n        g_404150 - *((int *)&(&g_404090)[48 * *((int *)&v0)]);\n    *((unsigned int *)&(&g_4040f4)[48 * *((int *)&v0)]) =\n        g_404154 - *((int *)&(&g_404094)[48 * *((int *)&v0)]);\n    *((unsigned long long *)&(&g_4040f8)[48 * *((int *)&v0)]) =\n        g_404158 - *((long long *)&(&g_404098)[48 * *((int *)&v0)]);\n    *((unsigned long long *)&(&g_404100)[48 * *((int *)&v0)]) =\n        g_404160 - *((long long *)&(&g_4040a0)[48 * *((int *)&v0)]);\n    *((unsigned long long *)&(&g_404108)[48 * *((int *)&v0)]) =\n        g_404168 - *((long long *)&(&g_4040a8)[48 * *((int *)&v0)]);\n    v32 = 3 * *((int *)&v0) * 16;\n    *((long long *)(v32 + &cpu_prev)) = *((long long *)&tmp);\n    *((long long *)(v32 + &g_404088)) = *((long long *)&g_404148);\n    *((long long *)(v32 + &g_404090)) = *((long long *)&g_404150);\n    *((unsigned long long *)(v32 + &g_404098)) = g_404158;\n    *((unsigned long long *)(v32 + &g_4040a0)) = g_404160;\n    *((unsigned long long *)(v32 + &g_4040a8)) = g_404168;\n    return 0;\n  }\n  printf(\"Could not parse %s\\n\", (unsigned int)a0);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:67:13: error: array type 'unsigned long\nlong[526358]' is not assignable 67 |         v32 = 3 * *((int *)&v0) * 16; | ~~~\n^ /tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:68:29: error: invalid operands to binary\nexpression ('unsigned long long[526358]' and 'char *') 68 |         *((long long\n*)(v32 + &cpu_prev)) = *((long long *)&tmp); |                         ~~~ ^\n~~~~~~~~~ /tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:69:29: error: invalid operands to\nbinary expression ('unsigned long long[526358]' and 'char *') 69 | *((long long\n*)(v32 + &g_404088)) = *((long long *)&g_404148); |                         ~~~\n^ ~~~~~~~~~ /tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:70:29: error: invalid operands to\nbinary expression ('unsigned long long[526358]' and 'char *') 70 | *((long long\n*)(v32 + &g_404090)) = *((long long *)&g_404150); |                         ~~~\n^ ~~~~~~~~~ /tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:71:38: error: invalid operands to\nbinary expression ('unsigned long long[526358]' and 'char *') 71 | *((unsigned\nlong long *)(v32 + &g_404098)) = g_404158; | ~~~ ^ ~~~~~~~~~\n/tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:72:38: error: invalid operands to binary\nexpression ('unsigned long long[526358]' and 'char *') 72 |         *((unsigned\nlong long *)(v32 + &g_4040a0)) = g_404160; | ~~~ ^ ~~~~~~~~~\n/tmp/tmp8saa7mi_/parse_cpu_v15_name_conflict.c:73:38: error: invalid operands to binary\nexpression ('unsigned long long[526358]' and 'char *') 73 |         *((unsigned\nlong long *)(v32 + &g_4040a8)) = g_404168; | ~~~ ^ ~~~~~~~~~ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse(const char *b) {\n    unsigned int version;\n    unsigned long long ts;\n    if (sscanf(b, \"version %u\\n\", &version) != 1) {\n        printf(\"Could not parse version\\n\");\n        return -1;\n    }\n    switch (version) {\n      case 15:\n        b = next_line(b);\n        if (!b || sscanf(b, \"timestamp %llu\\n\", &ts) != 1) {\n            printf(\"Could not parse timestamp\\n\");\n            return -1;\n        }\n        while (1)\n            {\n                b = next_line(b);\n                if (!b)\n                    break;\n                if (b[0] == 'c') {\n                    if (parse_cpu_v15(b))\n                        return -1;\n                }\n            }\n        break;\n      default:\n        printf(\"Can not handle version %u\\n\", version);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\nlong long(next_line)(long long);\nlong long(parse_name_conflict_cpu_v15)(long long);\n\nlong long parse_name_conflict(char *a0) {\n  char *v0; // [bp-0x20], Other Possible Types: unsigned long\n  char v1;  // [bp-0x18]\n  char v2;  // [bp-0xc]\n\n  v0 = a0;\n  if (__isoc99_sscanf(v0, \"version %u\\n\", (unsigned int)&v2) != 1) {\n    puts(\"Could not parse_name_conflict version\");\n    return 4294967295;\n  } else if (*((int *)&v2) == 15) {\n    v0 = next_line(v0);\n    if (v0 && __isoc99_sscanf(v0, \"timestamp %llu\\n\", (unsigned int)&v1) == 1) {\n      do {\n        do {\n          v0 = next_line(v0);\n          if (!v0)\n            return 0;\n        } while (*((char *)v0) != 99);\n      } while (!(int)parse_name_conflict_cpu_v15(v0));\n      return 4294967295;\n    }\n    puts(\"Could not parse_name_conflict timestamp\");\n    return 4294967295;\n  } else {\n    printf(\"Can not handle version %u\\n\", *((int *)&v2));\n    return 4294967295;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"char *path_filename_ext(const char *path) {\n    char *fname = __xpg_basename((char *)path);\n    char *dot = strrchr(fname, '.');\n    if (!dot || dot == fname)\n        return (\"\");\n    return (dot);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_403033;\n\nlong long path_filename_ext_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x18]\n  char *v1;         // [bp-0x10]\n\n  v1 = __xpg_basename(a0);\n  v0 = strrchr(v1, 46);\n  if (v0 && v0 != v1)\n    return v0;\n  return &g_403033;\n}\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_filename_ext.c"}
{"compilable":0,"function":"int path_isdir(const char *path) {\n    struct stat *sb = calloc(1, sizeof(struct stat));\n    int s = stat(path, sb);\n    if (s == -1) {\n        log_perror(\"stat error\");\n        free(sb);\n        return (-1);\n    }\n    mode_t m = sb->st_mode;\n    free(sb);\n    return (((((m)) & 61440) == (16384)));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(log_perror)(...);\n\ntypedef struct struct_0 {\n  char padding_0[24];\n  unsigned int field_18;\n} struct_0;\n\nlong long path_isdir_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x18]\n  unsigned int v1; // [bp-0x14]\n  struct_0 *v2;    // [bp-0x10]\n\n  v2 = calloc(1, 144);\n  v1 = stat(a0, v2);\n  if (v1 != -1) {\n    v0 = v2->field_18;\n    free(v2);\n    return (v0 & 0xf000) == 0x4000;\n  }\n  log_perror();\n  free(v2);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0a89884o/path_isdir_name_conflict.c:28:24: error: ISO C requires a named parameter\nbefore '...' 28 | long long (log_perror)(...); |                        ^ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_isdir.c"}
{"compilable":0,"function":"int path_exists(const char *path) {\n    int ret = access(path, 0);\n    if (ret == 0)\n        return (1);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long path_exists_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = access(a0, 0);\n  return (!v0 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_exists.c"}
{"compilable":0,"function":"int log_perror(char *fmt, ...) {\n    perror(\"\");\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"ERR\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(perror)(char *);\nlong long(_logfp)(long long, long long, long long, long long);\n\nextern char g_403034;\nextern unsigned long long stderr @GLIBC_2.2.5;\n\nlong long log_perror_name_conflict() {\n  unsigned int v0;        // [bp-0xd8]\n  unsigned int v1;        // [bp-0xd4]\n  unsigned long v2;       // [bp-0xd0]\n  unsigned long v3;       // [bp-0xc8]\n  unsigned int v4;        // [bp-0xbc]\n  char v5;                // [bp-0xb8]\n  unsigned long v6;       // [bp-0xb0]\n  unsigned long v7;       // [bp-0xa8]\n  unsigned long v8;       // [bp-0xa0]\n  unsigned long v9;       // [bp-0x98]\n  unsigned long v10;      // [bp-0x90]\n  int v11;                // [bp-0x88]\n  int v12;                // [bp-0x78]\n  int v13;                // [bp-0x68]\n  int v14;                // [bp-0x58]\n  int v15;                // [bp-0x48]\n  int v16;                // [bp-0x38]\n  int v17;                // [bp-0x28]\n  int v18;                // [bp-0x18]\n  unsigned long v19;      // [bp+0x8]\n  unsigned long v20;      // rsi\n  unsigned long v21;      // rdx\n  unsigned long v22;      // rcx\n  unsigned long v23;      // r8\n  unsigned long v24;      // r9\n  char v25;               // al\n  int v26;                // xmm0\n  int v27;                // xmm1\n  int v28;                // xmm2\n  int v29;                // xmm3\n  int v30;                // xmm4\n  int v31;                // xmm5\n  int v32;                // xmm6\n  int v33;                // xmm7\n  unsigned long long v34; // rdi\n\n  v6 = v20;\n  v7 = v21;\n  v8 = v22;\n  v9 = v23;\n  v10 = v24;\n  if (v25) {\n    v11 = v26;\n    v12 = v27;\n    v13 = v28;\n    v14 = v29;\n    v15 = v30;\n    v16 = v31;\n    v17 = v32;\n    v18 = v33;\n  }\n  perror(&g_403034);\n  v0 = 8;\n  v1 = 48;\n  v2 = &v19;\n  v3 = &v5;\n  v4 = _logfp(stderr @GLIBC_2.2.5, \"ERR\", v34, &v0);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo0gu237v/log_perror_name_conflict.c:16:7: error: conflicting types for 'perror'\n   16 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpo0gu237v/log_perror_name_conflict.c:20:27: error: redeclaration of 'stderr' with a\ndifferent type: 'unsigned long long' vs 'FILE *' (aka 'struct _IO_FILE *') 20 |\nextern unsigned long long stderr@GLIBC_2.2.5; |                           ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpo0gu237v /\n        log_perror_name_conflict.c : 20 : 33 : error\n    : expected ';' after top level declarator 20 |\n    extern unsigned long long stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpo0gu237v / log_perror_name_conflict.c : 81 : 23 : error : expected ')' 81 | v4 =\n    _logfp(stderr @GLIBC_2.2.5, \"ERR\", v34, &v0);\n| ^/ tmp / tmpo0gu237v / log_perror_name_conflict.c : 81 : 16 : note : to match this '(' 81 |\n    v4 = _logfp(stderr @GLIBC_2.2.5, \"ERR\", v34, &v0);\n| ^4 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_perror.c"}
{"compilable":0,"function":"int log_warn(char *fmt, ...) {\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"WARN\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_logfp)(long long, long long, long long, long long);\n\nextern unsigned long long stderr @GLIBC_2.2.5;\n\nlong long log_warn_name_conflict() {\n  unsigned int v0;        // [bp-0xd8]\n  unsigned int v1;        // [bp-0xd4]\n  unsigned long v2;       // [bp-0xd0]\n  unsigned long v3;       // [bp-0xc8]\n  unsigned int v4;        // [bp-0xbc]\n  char v5;                // [bp-0xb8]\n  unsigned long v6;       // [bp-0xb0]\n  unsigned long v7;       // [bp-0xa8]\n  unsigned long v8;       // [bp-0xa0]\n  unsigned long v9;       // [bp-0x98]\n  unsigned long v10;      // [bp-0x90]\n  int v11;                // [bp-0x88]\n  int v12;                // [bp-0x78]\n  int v13;                // [bp-0x68]\n  int v14;                // [bp-0x58]\n  int v15;                // [bp-0x48]\n  int v16;                // [bp-0x38]\n  int v17;                // [bp-0x28]\n  int v18;                // [bp-0x18]\n  unsigned long v19;      // [bp+0x8]\n  unsigned long v20;      // rsi\n  unsigned long v21;      // rdx\n  unsigned long v22;      // rcx\n  unsigned long v23;      // r8\n  unsigned long v24;      // r9\n  char v25;               // al\n  int v26;                // xmm0\n  int v27;                // xmm1\n  int v28;                // xmm2\n  int v29;                // xmm3\n  int v30;                // xmm4\n  int v31;                // xmm5\n  int v32;                // xmm6\n  int v33;                // xmm7\n  unsigned long long v34; // rdi\n\n  v6 = v20;\n  v7 = v21;\n  v8 = v22;\n  v9 = v23;\n  v10 = v24;\n  if (v25) {\n    v11 = v26;\n    v12 = v27;\n    v13 = v28;\n    v14 = v29;\n    v15 = v30;\n    v16 = v31;\n    v17 = v32;\n    v18 = v33;\n  }\n  v0 = 8;\n  v1 = 48;\n  v2 = &v19;\n  v3 = &v5;\n  v4 = _logfp(stderr @GLIBC_2.2.5, \"WARN\", v34, &v0);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp51i8u4wh/log_warn_name_conflict.c:18:27: error: redeclaration of 'stderr' with a\ndifferent type: 'unsigned long long' vs 'FILE *' (aka 'struct _IO_FILE *') 18 |\nextern unsigned long long stderr@GLIBC_2.2.5; |                           ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmp51i8u4wh /\n        log_warn_name_conflict.c : 18 : 33 : error\n    : expected ';' after top level declarator 18 |\n    extern unsigned long long stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmp51i8u4wh / log_warn_name_conflict.c : 78 : 23 : error : expected ')' 78 | v4 =\n    _logfp(stderr @GLIBC_2.2.5, \"WARN\", v34, &v0);\n| ^/ tmp / tmp51i8u4wh / log_warn_name_conflict.c : 78 : 16 : note : to match this '(' 78 |\n    v4 = _logfp(stderr @GLIBC_2.2.5, \"WARN\", v34, &v0);\n| ^3 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_warn.c"}
{"compilable":0,"function":"char *currTime(const char *format) {\n    static char buf[1000];\n    time_t t;\n    size_t s;\n    struct tm *tm;\n    t = time(((void *)0));\n    tm = localtime(&t);\n    if (tm == ((void *)0))\n        return ((void *)0);\n    s = strftime(buf, 1000, (format != ((void *)0)) ? format : \"%c\", tm);\n    return (s == 0) ? ((void *)0) : buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(localtime)(long *);\n\ntypedef struct tm {\n  unsigned int tm_sec;\n  unsigned int tm_min;\n  unsigned int tm_hour;\n  unsigned int tm_mday;\n  unsigned int tm_mon;\n  unsigned int tm_year;\n  unsigned int tm_wday;\n  unsigned int tm_yday;\n  unsigned int tm_isdst;\n  char padding_24[4];\n  unsigned int tm_gmtoff;\n  char padding_2c[4];\n  char *tm_zone;\n} tm;\n\nextern char buf.0;\n\nlong long currTime_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  tm *v2;           // [bp-0x10]\n\n  *((long *)&v0) = time(NULL);\n  v2 = &localtime(&v0)->tm_sec;\n  if (v2) {\n    v1 = strftime(&buf.0, 1000, (!a0 ? a0 : \"%c\"), v2);\n    return (!v1 ? &buf.0 : 0);\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpifhobo22/currTime_name_conflict.c:35:16: error: expected ';' after top level\ndeclarator 35 | extern char buf.0; |                ^ |                ;\n/tmp/tmpifhobo22/currTime_name_conflict.c:47:27: error: expected ')'\n   47 |         v1 = strftime(&buf.0, 1000, (!a0 ? a0 : \"%c\"), v2);\n      |                           ^\n/tmp/tmpifhobo22/currTime_name_conflict.c:47:22: note: to match this '('\n   47 |         v1 = strftime(&buf.0, 1000, (!a0 ? a0 : \"%c\"), v2);\n      |                      ^\n/tmp/tmpifhobo22/currTime_name_conflict.c:48:27: error: expected ':'\n   48 |         return (!v1 ? &buf.0 : 0);\n      |                           ^\n      |                           :\n/tmp/tmpifhobo22/currTime_name_conflict.c:48:21: note: to match this '?'\n   48 |         return (!v1 ? &buf.0 : 0);\n      |                     ^\n/tmp/tmpifhobo22/currTime_name_conflict.c:48:21: error: incompatible operand types ('char *'\nand 'double') 48 |         return (!v1 ? &buf.0 : 0); |                     ^\n~~~~~~ /tmp/tmpifhobo22/currTime_name_conflict.c:48:30: error: expected ')' 48 | return (!v1 ?\n&buf.0 : 0); |                              ^ /tmp/tmpifhobo22/currTime_name_conflict.c:48:16:\nnote: to match this '(' 48 |         return (!v1 ? &buf.0 : 0); | ^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":1,"function":"bool isValidMacAddrStr(char *str) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isValidMacAddrStr_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return 1;\n}\n","pass":1,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":0,"function":"size_t addst(size_t x, size_t y) {\n    if ((18446744073709551615UL) - x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x + y;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fatal)(...);\n\nlong long addst_name_conflict(unsigned long a0, unsigned long a1) {\n  if (~(a0) >= a1)\n    return a1 + a0;\n  fatal(); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4gl0_b1c/addst_name_conflict.c:16:19: error: ISO C requires a named parameter before\n'...' 16 | long long (fatal)(...); |                   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"size_t mulst(size_t x, size_t y) {\n    if (x == 0 || y == 0) {\n        return 0;\n    }\n    if ((18446744073709551615UL) / x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x * y;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fatal)(...);\n\nlong long mulst_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n\n  if (a0 && a1) {\n    v2 = 0;\n    if ((char)[D] amd64g_calculate_condition(0x0 < 64 >, 0x30 < 64 >, rsi, rdi,\n                                             cc_ndep))\n      v2 = 1;\n    if (!v2)\n      return a1 * a0;\n    fatal(); /* do not return */\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9c9ivwh_/mulst_name_conflict.c:16:19: error: ISO C requires a named parameter before\n'...' 16 | long long (fatal)(...); |                   ^\n/tmp/tmp9c9ivwh_/mulst_name_conflict.c:25:19: error: expected expression\n   25 |         if ((char)[D] amd64g_calculate_condition(0x0<64>, 0x30<64>, rsi,\nrdi, cc_ndep)) |                   ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *result = strdup(s);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(fatal)(...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strdup(a0);\n  if (!v0)\n    fatal(); /* do not return */\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpifediz0p/xstrdup_name_conflict.c:17:19: error: ISO C requires a named parameter before\n'...' 17 | long long (fatal)(...); |                   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrndup(const char *s, size_t size) {\n    char *result = strndup(s, size);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strndup)(char *, unsigned long);\nlong long(fatal)(...);\n\nlong long xstrndup_name_conflict(char *a0, unsigned int a1) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = strndup(a0, a1);\n  if (!v0)\n    fatal(); /* do not return */\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa5_c0y63/xstrndup_name_conflict.c:17:19: error: ISO C requires a named parameter\nbefore '...' 17 | long long (fatal)(...); |                   ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int xasprintf(char **s, const char *template, ...) {\n    va_list a;\n    __builtin_va_start(a, template);\n    int result = vasprintf(s, template, a);\n    __builtin_va_end(a);\n    if (result < 0) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vasprintf)(char **, char *, struct va_list[1]);\nlong long(fatal)(...);\n\nlong long xasprintf_name_conflict() {\n  unsigned int v0;   // [bp-0xd8]\n  unsigned int v1;   // [bp-0xd4]\n  unsigned long v2;  // [bp-0xd0]\n  unsigned long v3;  // [bp-0xc8]\n  unsigned int v4;   // [bp-0xbc]\n  char v5;           // [bp-0xb8]\n  unsigned long v6;  // [bp-0xa8]\n  unsigned long v7;  // [bp-0xa0]\n  unsigned long v8;  // [bp-0x98]\n  unsigned long v9;  // [bp-0x90]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  int v16;           // [bp-0x28]\n  int v17;           // [bp-0x18]\n  unsigned long v18; // [bp+0x8]\n  unsigned long v19; // rdx\n  unsigned long v20; // rcx\n  unsigned long v21; // r8\n  unsigned long v22; // r9\n  char v23;          // al\n  int v24;           // xmm0\n  int v25;           // xmm1\n  int v26;           // xmm2\n  int v27;           // xmm3\n  int v28;           // xmm4\n  int v29;           // xmm5\n  int v30;           // xmm6\n  int v31;           // xmm7\n  char **v32;        // rdi\n  char *v33;         // rsi\n\n  v6 = v19;\n  v7 = v20;\n  v8 = v21;\n  v9 = v22;\n  if (v23) {\n    v10 = v24;\n    v11 = v25;\n    v12 = v26;\n    v13 = v27;\n    v14 = v28;\n    v15 = v29;\n    v16 = v30;\n    v17 = v31;\n  }\n  v0 = 16;\n  v1 = 48;\n  v2 = &v18;\n  v3 = &v5;\n  v4 = vasprintf(v32, v33, &v0);\n  if (v4 < 0)\n    fatal(); /* do not return */\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpak1cagii/xasprintf_name_conflict.c:16:48: error: array has incomplete element type\n'struct va_list' 16 | int (vasprintf)(char **, char *, struct va_list[1]); | ^\n/tmp/tmpak1cagii/xasprintf_name_conflict.c:16:41: note: forward declaration of 'struct\nva_list' 16 | int (vasprintf)(char **, char *, struct va_list[1]); | ^\n/tmp/tmpak1cagii/xasprintf_name_conflict.c:17:19: error: ISO C requires a named parameter\nbefore '...' 17 | long long (fatal)(...); |                   ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xgetcwd(void) {\n    char *result = getcwd(((void *)0), 0);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getcwd)(char *, unsigned long);\nlong long(fatal)(...);\n\nlong long xgetcwd_name_conflict() {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = getcwd(NULL, 0);\n  if (!v0)\n    fatal(); /* do not return */\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3qogfh_f/xgetcwd_name_conflict.c:17:19: error: ISO C requires a named parameter before\n'...' 17 | long long (fatal)(...); |                   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_starts_with(const char *string, const char *prefix) {\n    const char *string_ptr = string;\n    const char *prefix_ptr = prefix;\n    while (*string_ptr != '\\x00' && *prefix_ptr != '\\x00')\n        {\n            if (*string_ptr != *prefix_ptr) {\n                return 0;\n            }\n            string_ptr++;\n            prefix_ptr++;\n        }\n    if (*string_ptr == '\\x00' && *prefix_ptr != '\\x00') {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long str_starts_with_name_conflict(char *a0, char *a1) {\n  char *v0; // [bp-0x18], Other Possible Types: unsigned long\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = a0;\n  for (v0 = a1; *((char *)v1) && *((char *)v0); v0 += 1) {\n    if (*((char *)v1) == *((char *)v0))\n      v1 += 1;\n    else\n      return 0;\n  }\n  if (!*((char *)v1) && *((char *)v0))\n    return 0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_ends_with(const char *string, const char *suffix) {\n    size_t string_length = strlen(string);\n    size_t suffix_length = strlen(suffix);\n    if (string_length < suffix_length) {\n        return 0;\n    }\n    return strcmp(string + string_length - suffix_length, suffix) == 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long str_ends_with_name_conflict(char *a0, char *a1) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n  unsigned long v3; // rax\n\n  v1 = strlen(a0);\n  v0 = strlen(a1);\n  if (v1 < v0)\n    return 0;\n  (unsigned int)v3 = strcmp(&a0[v1 + -1 * v0], a1);\n  *((char *)&v3) = !(unsigned int)v3;\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpeww3ptfg/str_ends_with_name_conflict.c:27:5: error: assignment to cast is illegal,\nlvalue casts are not supported 27 |     (unsigned int)v3 = strcmp(&a0[v1 + -1 *\nv0], a1); |     ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_path(const char *parent, const char *relative_path) {\n    size_t parent_length = strlen(parent);\n    size_t relative_path_length = strlen(relative_path);\n    size_t result_length = addst(parent_length, relative_path_length);\n    result_length = addst(result_length, 2);\n    char *result = xmalloc(result_length);\n    strcpy(result, parent);\n    result[parent_length] = '/';\n    strcpy(result + parent_length + 1, relative_path);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(addst)(long long, long long);\nlong long(xmalloc)(long long);\n\nlong long make_path_name_conflict(char *a0, char *a1) {\n  unsigned long v0;      // [bp-0x28]\n  unsigned long long v1; // [bp-0x20]\n  unsigned long long v2; // [bp-0x18]\n  char *v3;              // [bp-0x10]\n\n  v3 = strlen(a0);\n  v2 = strlen(a1);\n  v1 = addst(v3, v2);\n  v1 = addst(v1, 2);\n  v0 = xmalloc(v1);\n  strcpy(v0, a0);\n  v3[v0] = 47;\n  strcpy(&v3[1 + v0], a1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_canonical_path(const char *relative_path) {\n    char *original_directory = xgetcwd();\n    char *base = make_basename(relative_path);\n    char *dir = make_dirname(relative_path);\n    xchdir(dir);\n    char *canonical_dir = xgetcwd();\n    char *result = make_path(canonical_dir, base);\n    free(canonical_dir);\n    free(base);\n    free(dir);\n    xchdir(original_directory);\n    free(original_directory);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xgetcwd)();\nlong long(make_basename)(long long);\nlong long(make_dirname)(long long);\nlong long(xchdir)(long long);\nlong long(make_path)(long long, long long);\n\nlong long make_canonical_path_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x30]\n  void *v1;         // [bp-0x28]\n  void *v2;         // [bp-0x20]\n  void *v3;         // [bp-0x18]\n  void *v4;         // [bp-0x10]\n\n  v4 = xgetcwd();\n  v3 = make_basename(a0);\n  v2 = make_dirname(a0);\n  xchdir(v2);\n  v1 = xgetcwd();\n  v0 = make_path(v1, v3);\n  free(v1);\n  free(v3);\n  free(v2);\n  xchdir(v4);\n  free(v4);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_basename(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(__xpg_basename(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\n\nlong long make_basename_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x18]\n  void *v1;         // [bp-0x10]\n\n  v1 = xstrdup(a0);\n  v0 = xstrdup(__xpg_basename(v1));\n  free(v1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_dirname(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(dirname(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\nchar *(dirname)(char *);\n\nlong long make_dirname_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x18]\n  char *v1;         // [bp-0x10]\n\n  v1 = xstrdup(a0);\n  v0 = xstrdup(dirname(v1));\n  free(v1);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int is_same_file(const char *file1, const char *file2) {\n    if (strcmp(file1, file2) == 0) {\n        return 1;\n    }\n    char *canonical1 = make_canonical_path(file1);\n    char *canonical2 = make_canonical_path(file2);\n    int cmp = strcmp(canonical1, canonical2);\n    free(canonical1);\n    free(canonical2);\n    if (cmp == 0) {\n        return 1;\n    }\n    struct stat buf1;\n    if (stat(file1, &buf1) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file1);\n        }\n    }\n    struct stat buf2;\n    if (stat(file2, &buf2) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file2);\n        }\n    }\n    if (buf1.st_dev == buf2.st_dev && buf1.st_ino == buf2.st_ino) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(make_canonical_path)(long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(fatal)(...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long is_same_file_name_conflict(char *a0, char *a1) {\n  stat v0;         // [bp-0x148]\n  char v1;         // [bp-0x140]\n  stat v2;         // [bp-0xb8]\n  char v3;         // [bp-0xb0]\n  unsigned int v4; // [bp-0x1c]\n  char *v5;        // [bp-0x18]\n  void *v6;        // [bp-0x10]\n\n  if (!strcmp(a0, a1))\n    return 1;\n  v6 = make_canonical_path(a0);\n  v5 = make_canonical_path(a1);\n  v4 = strcmp(v6, v5);\n  free(v6);\n  free(v5);\n  if (!v4) {\n    return 1;\n  } else if (stat(a0, &v2) != -1) {\n    if (stat(a1, &v0) != -1) {\n      if (!(*((long long *)&v2.st_mode) == *((long long *)&v0.st_mode) &&\n            *((long long *)&v3) == *((long long *)&v1)))\n        return 0;\n      return 1;\n    } else if (*(__errno_location()) != 2) {\n      fatal(); /* do not return */\n    } else {\n      return 0;\n    }\n  } else {\n    if (*(__errno_location()) != 2)\n      fatal(); /* do not return */\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:29:19: error: ISO C requires a named parameter\nbefore '...' 29 | long long (fatal)(...); |                   ^\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpphsc7llw/is_same_file_name_conflict.c:17:6: note:\nprevious definition is here 17 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:53:5: error: must use 'struct' tag to refer to\ntype 'stat' 53 |     stat v0;  // [bp-0x148] |     ^ |     struct\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:17:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v2;  // [bp-0xb8] |     ^ |     struct\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:17:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmpphsc7llw/is_same_file_name_conflict.c:80:18: error: indirection requires pointer\noperand ('int' invalid) 80 |         else if (*(__errno_location()) != 2) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpphsc7llw/is_same_file_name_conflict.c:91:13: error: indirection\nrequires pointer operand ('int' invalid) 91 |         if (*(__errno_location())\n!= 2) |             ^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int contains_file(const char *file1, const char *file2) {\n    int result = 0;\n    char *ancestor = make_canonical_path(file1);\n    char *d = make_canonical_path(file2);\n    char *parent = make_dirname(d);\n    while (strcmp(d, parent) != 0)\n        {\n            if (is_same_file(ancestor, parent)) {\n                result = 1;\n                break;\n            }\n            free(d);\n            d = parent;\n            parent = make_dirname(d);\n        }\n    free(d);\n    free(parent);\n    free(ancestor);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(make_canonical_path)(long long);\nlong long(make_dirname)(long long);\nlong long(is_same_file)(long long, long long);\n\nlong long contains_file_name_conflict(unsigned long long a0, unsigned long long a1) {\n  void *v0;        // [bp-0x28]\n  char *v1;        // [bp-0x20]\n  char *v2;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v3; // [bp-0xc]\n\n  v3 = 0;\n  v0 = make_canonical_path(a0);\n  v2 = make_canonical_path(a1);\n  while (true) {\n    v1 = make_dirname(v2);\n    if (!strcmp(v2, v1))\n      break;\n    if (!(int)is_same_file(v0, v1)) {\n      free(v2);\n      v2 = v1;\n    } else {\n      v3 = 1;\n      break;\n    }\n  }\n  free(v2);\n  free(v1);\n  free(v0);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool directory_is_empty(const char *directory) {\n    bool result = 1;\n    DIR *dir = xopendir(directory);\n    struct dirent *e;\n    while ((e = readdir(dir)) != ((void *)0))\n        {\n            if (strcmp(e->d_name, \".\") != 0 && strcmp(e->d_name, \"..\") != 0) {\n                result = 0;\n                break;\n            }\n        }\n    closedir(dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xopendir)(long long);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\n\nlong long directory_is_empty_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x20]\n  char *v1;         // [bp-0x18]\n  char v2;          // [bp-0x9]\n\n  v2 = 1;\n  v1 = xopendir(a0);\n  while (true) {\n    v0 = readdir(v1);\n    if (!v0)\n      break;\n    if (!strcmp(v0 + 19, \".\"))\n      continue;\n    if (strcmp(v0 + 19, \"..\")) {\n      v2 = 0;\n      break;\n    }\n  }\n  closedir(v1);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":1,"function":"int verify_values(char **values, char **expected, int n) {\n    int i = 0;\n    while (i < n)\n        {\n            if (0 != strcmp(values[i], expected[i])) {\n                return -1;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long verify_values_name_conflict(char **a0, char **a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  for (v0 = 0; v0 < (unsigned int)a2; v0 += 1) {\n    if (strcmp(a0[v0], a1[v0]))\n      return 4294967295;\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_split_string_by_comma_ok() {\n    int rv;\n    char *test_str;\n    char *values[24];\n    test_str = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(4 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values\", \"\\033[0m\");\n            return \"should return the correct number of values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values\", \"\\033[0m\");\n    } while (0);\n    char *expected[] = {\"JACK\", \"ENGQVIST\", \"JOHANSSON\", \"89\"};\n    do {\n        if (!(0 == verify_values(values, expected, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n            return \"should be able to split a comma seperated string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\",SOME,EMPTY,VALUES,,\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(6 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n            return \"should return the correct number of values even when there is empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    char *expected2[] = {\"\", \"SOME\", \"EMPTY\", \"VALUES\", \"\", \"\"};\n    do {\n        if (!(0 == verify_values(values, expected2, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n            return \"should be able to split empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_403028; // add global variable by heuristics\nint g_403028; // add global variable by heuristics\nint g_403098; // add global variable by heuristics\nint g_403098; // add global variable by heuristics\nint g_4030e0; // add global variable by heuristics\nint g_4030e0; // add global variable by heuristics\nint g_403148; // add global variable by heuristics\nint g_403148; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(_split_string_by_comma)(long long, long long, long long);\nlong long(verify_values)(long long, long long, long long);\n\nextern char g_403023;\nextern char g_403053;\nextern char g_40305e;\nextern char g_40306a;\nextern char g_403070;\nextern char g_403130;\n\nlong long test_split_string_by_comma_ok_name_conflict() {\n  unsigned long v0; // [bp-0x128]\n  unsigned long v1; // [bp-0x120]\n  unsigned long v2; // [bp-0x118]\n  unsigned long v3; // [bp-0x110]\n  unsigned long v4; // [bp-0x108]\n  unsigned long v5; // [bp-0x100]\n  unsigned long v6; // [bp-0xf8]\n  unsigned long v7; // [bp-0xf0]\n  unsigned long v8; // [bp-0xe8]\n  unsigned long v9; // [bp-0xe0]\n  char v10;         // [bp-0xd8]\n  unsigned int v11; // [bp-0x14]\n  void *v12;        // [bp-0x10]\n\n  v12 = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n  v11 = _split_string_by_comma(v12, &v10, 24);\n  if (v11 != 4) {\n    printf(&g_40305e, &g_403053, &g_403028, &g_403023);\n    return \"should return the correct number of values\";\n  }\n  printf(&g_403070, &g_40306a, &g_403028, &g_403023);\n  v6 = \"JACK\";\n  v7 = \"ENGQVIST\";\n  v8 = \"JOHANSSON\";\n  v9 = \"89\";\n  if ((int)verify_values(&v10, &v6, v11)) {\n    printf(&g_40305e, &g_403053, &g_403098, &g_403023);\n    return \"should be able to split a comma seperated string\";\n  }\n  printf(&g_403070, &g_40306a, &g_403098, &g_403023);\n  free(v12);\n  v12 = strdup(\",SOME,EMPTY,VALUES,,\");\n  v11 = _split_string_by_comma(v12, &v10, 24);\n  if (v11 != 6) {\n    printf(&g_40305e, &g_403053, &g_4030e0, &g_403023);\n    return \"should return the correct number of values even when there is \"\n           \"empty values (,,)\";\n  }\n  printf(&g_403070, &g_40306a, &g_4030e0, &g_403023);\n  v0 = &g_403130;\n  v1 = \"SOME\";\n  v2 = \"EMPTY\";\n  v3 = \"VALUES\";\n  v4 = &g_403130;\n  v5 = &g_403130;\n  if (!(int)verify_values(&v10, &v0, v11)) {\n    printf(&g_403070, &g_40306a, &g_403148, &g_403023);\n    free(v12);\n    return 0;\n  }\n  printf(&g_40305e, &g_403053, &g_403148, &g_403023);\n  return \"should be able to split empty values (,,)\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_crop_sentence_ok() {\n    char *rv;\n    char *test_str;\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89*D1\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string\", \"\\033[0m\");\n            return \"should return a cropped string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n            return \"should return a cropped string without checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values\", \"\\033[0m\");\n            return \"should work with empty values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,*1D\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values and checksum\", \"\\033[0m\");\n            return \"should work with empty values and checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values and checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4031b0; // add global variable by heuristics\nint g_4031b0; // add global variable by heuristics\nint g_4031f0; // add global variable by heuristics\nint g_4031f0; // add global variable by heuristics\nint g_40325f; // add global variable by heuristics\nint g_40325f; // add global variable by heuristics\nint g_4032a8; // add global variable by heuristics\nint g_4032a8; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(_crop_sentence)(long long, long long);\n\nextern char g_403023;\nextern char g_403053;\nextern char g_40305e;\nextern char g_40306a;\nextern char g_403070;\n\nlong long test_crop_sentence_ok_name_conflict() {\n  char *v0; // [bp-0x18]\n  void *v1; // [bp-0x10]\n\n  v1 = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89*D1\\r\\n\");\n  v0 = _crop_sentence(v1, strlen(v1));\n  if (strcmp(v0, \"ENGQVIST,JOHANSSON,89\")) {\n    printf(&g_40305e, &g_403053, &g_4031b0, &g_403023);\n    return \"should return a cropped string\";\n  }\n  printf(&g_403070, &g_40306a, &g_4031b0, &g_403023);\n  free(v1);\n  v1 = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89\\r\\n\");\n  v0 = _crop_sentence(v1, strlen(v1));\n  if (strcmp(v0, \"ENGQVIST,JOHANSSON,89\")) {\n    printf(&g_40305e, &g_403053, &g_4031f0, &g_403023);\n    return \"should return a cropped string without checksum\";\n  }\n  printf(&g_403070, &g_40306a, &g_4031f0, &g_403023);\n  free(v1);\n  v1 = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,\\r\\n\");\n  v0 = _crop_sentence(v1, strlen(v1));\n  if (strcmp(v0, \",ENGQVIST,,JOHANSSON,,89,,\")) {\n    printf(&g_40305e, &g_403053, &g_40325f, &g_403023);\n    return \"should work with empty values\";\n  }\n  printf(&g_403070, &g_40306a, &g_40325f, &g_403023);\n  free(v1);\n  v1 = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,*1D\\r\\n\");\n  v0 = _crop_sentence(v1, strlen(v1));\n  if (!strcmp(v0, \",ENGQVIST,,JOHANSSON,,89,,\")) {\n    printf(&g_403070, &g_40306a, &g_4032a8, &g_403023);\n    free(v1);\n    return 0;\n  }\n  printf(&g_40305e, &g_403053, &g_4032a8, &g_403023);\n  return \"should work with empty values and checksum\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_is_value_set() {\n    int rv;\n    rv = _is_value_set(\"JACK\");\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when there is a value\", \"\\033[0m\");\n            return \"should return 0 when there is a value\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when there is a value\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(\"\");\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n            return \"should return -1 when the string is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(((void *)0));\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4032d8; // add global variable by heuristics\nint g_4032d8; // add global variable by heuristics\nint g_403300; // add global variable by heuristics\nint g_403300; // add global variable by heuristics\nint g_40332a; // add global variable by heuristics\nint g_40332a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_is_value_set)(long long);\n\nextern char g_403023;\nextern char g_403053;\nextern char g_40305e;\nextern char g_40306a;\nextern char g_403070;\nextern unsigned long long g_403130;\n\nlong long test_is_value_set_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = _is_value_set(\"JACK\");\n  if (v0) {\n    printf(&g_40305e, &g_403053, &g_4032d8, &g_403023);\n    return \"should return 0 when there is a value\";\n  }\n  printf(&g_403070, &g_40306a, &g_4032d8, &g_403023);\n  v0 = _is_value_set(&g_403130);\n  if (v0 != -1) {\n    printf(&g_40305e, &g_403053, &g_403300, &g_403023);\n    return \"should return -1 when the string is empty\";\n  }\n  printf(&g_403070, &g_40306a, &g_403300, &g_403023);\n  v0 = _is_value_set(0);\n  if (v0 == -1) {\n    printf(&g_403070, &g_40306a, &g_40332a, &g_403023);\n    return 0;\n  }\n  printf(&g_40305e, &g_403053, &g_40332a, &g_403023);\n  return \"should return -1 on NULL\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_split_string_by_comma()\", \"\\033[0m\");\n    do {\n        char *message = test_split_string_by_comma_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_crop_sentence()\", \"\\033[0m\");\n    do {\n        char *message = test_crop_sentence_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_is_value_set()\", \"\\033[0m\");\n    do {\n        char *message = test_is_value_set();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_split_string_by_comma_ok)();\nlong long(test_crop_sentence_ok)();\nlong long(test_is_value_set)();\n\nextern char g_403023;\nextern char g_403343;\nextern char g_40335c;\nextern char g_403362;\nextern char g_40336f;\nextern char g_403380;\nextern unsigned int tests_run;\n\nlong long all_tests_name_conflict() {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned long v2; // [bp-0x10]\n\n  printf(&g_403362, &g_40335c, &g_403343, &g_403023);\n  v2 = test_split_string_by_comma_ok();\n  tests_run = tests_run + 1;\n  if (v2)\n    return v2;\n  printf(&g_403362, &g_40335c, &g_40336f, &g_403023);\n  v1 = test_crop_sentence_ok();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(&g_403362, &g_40335c, &g_403380, &g_403023);\n  v0 = test_is_value_set();\n  tests_run = tests_run + 1;\n  return (!v0 ? v0 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nchar *(strcat)(char *, char *);\n\ntypedef struct struct_0 {\n  char padding_0[19];\n  char field_13;\n} struct_0;\n\nlong long _get_so_files_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;  // [bp-0x34]\n  char *v1;         // [bp-0x30]\n  unsigned long v2; // [bp-0x28]\n  struct_0 *v3;     // [bp-0x20]\n  void *v4;         // [bp-0x18], Other Possible Types: char *\n  unsigned int v5;  // [bp-0xc]\n  void **v8;        // rax\n\n  v5 = 0;\n  v4 = 0;\n  v4 = opendir(a0);\n  if (!v4)\n    return 4294967295;\n  while (true) {\n    do {\n      do {\n        v3 = &readdir(v4);\n        if (!v3) {\n          if (!v4)\n            return v5;\n          closedir(v4);\n        }\n      } while (v3->field_13 == 46);\n    } while ((v2 = strlen(v3 + 19),\n              !(v2 > 2) || !(!strncmp(v2 - 3 + v3 + 19, \".so\", 3))));\n    v1 = malloc(255);\n    if (!v1)\n      break;\n    strcpy(v1, a0);\n    strcat(v1, &v3->field_13);\n    v8 = v5;\n    v5 = (unsigned int)v8 + 1;\n    *((char **)(v8 * 8 + a1)) = v1;\n  }\n  for (v0 = 0; v0 < v5; v5 += 1) {\n    free(*((long long *)(a1 + v0 * 8)));\n  }\n  if (!v4)\n    return 4294967295;\n  closedir(v4);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3bhvi_l2/_get_so_files_name_conflict.c:47:22: error: cannot take the address of an\nrvalue of type 'char *' 47 |                 v3 = &readdir(v4); | ^~~~~~~~~~~~\n/tmp/tmp3bhvi_l2/_get_so_files_name_conflict.c:63:24: error: invalid operands to binary\nexpression ('void **' and 'int') 63 |         *((char **)(v8 * 8 + a1)) = v1; |\n~~ ^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nlong long(_get_so_files)(long long, long long);\nlong long(nmea_init_parser)(long long);\n\nextern unsigned int n_parsers;\nextern void *parsers;\n\nlong long nmea_load_parsers_name_conflict() {\n  void *v0;         // [bp-0x818]\n  unsigned long v1; // [bp-0x20]\n  unsigned long v2; // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned int v3;  // [bp-0xc]\n  unsigned int v6;  // eax\n\n  v2 = getenv(\"NMEA_PARSER_PATH\");\n  if (!v2)\n    v2 = \"/usr/lib/nmea/\";\n  n_parsers = _get_so_files(v2, &v0);\n  if (n_parsers <= 0)\n    return 4294967295;\n  parsers = malloc(n_parsers * 8);\n  if (!parsers)\n    return 4294967295;\n  memset(parsers, 0, n_parsers * 8);\n  v3 = n_parsers;\n  while (true) {\n    v6 = v3;\n    v3 = v6 - 1;\n    if (v6 <= 0)\n      return n_parsers;\n    v1 = nmea_init_parser((&v0)[v3]);\n    free((&v0)[v3]);\n    if (!v1)\n      return 4294967295;\n    *((unsigned long *)(8 * v3 + (char *)parsers)) = v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"static char *test_position_parse_ok() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"12311.12\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(123 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(11.119999999999999 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"2621.44\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(26 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21.440000000000001 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.01\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1.01 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1. == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    free(pos);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_403018; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_403085; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_403085; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_403085; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_403018; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\nint g_40306a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_position_parse)(long long, long long);\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n  unsigned int field_8;\n} struct_0;\n\nextern char g_403011;\nextern char g_403040;\nextern char g_40304b;\nextern char g_403057;\nextern char g_40305d;\n\nlong long test_position_parse_ok_name_conflict() {\n  unsigned int v0;       // [bp-0x1c]\n  void *v1;              // [bp-0x18]\n  struct_0 *v2;          // [bp-0x10]\n  unsigned long long v5; // xmm0lq\n  unsigned long long v6; // xmm0lq\n  unsigned long long v7; // xmm0lq\n  unsigned long long v8; // xmm0lq\n\n  v2 = malloc(16);\n  v1 = strdup(\"12311.12\");\n  v0 = nmea_position_parse(v1, v2);\n  if (v0) {\n    printf(&g_40304b, &g_403040, &g_403018, &g_403011);\n    return \"should return return 0 when successfull\";\n  }\n  printf(&g_40305d, &g_403057, &g_403018, &g_403011);\n  if (v2->field_8 != 123) {\n    printf(&g_40304b, &g_403040, &g_40306a, &g_403011);\n    return \"pos->degrees should be 123\";\n  }\n  printf(&g_40305d, &g_403057, &g_40306a, &g_403011);\n  v5 = v2->field_0;\n  if (!((char)((CmpF(v5, 4622449621536803389) & 69) >> 2) & 1) &&\n      ((char)((CmpF(v5, 4622449621536803389) & 69) >> 6) & 1) == 1) {\n    printf(&g_40305d, &g_403057, &g_403085, &g_403011);\n    free(v1);\n    v1 = strdup(\"2621.44\");\n    v0 = nmea_position_parse(v1, v2);\n    if (v0) {\n      printf(&g_40304b, &g_403040, &g_403018, &g_403011);\n      return \"should return return 0 when successfull\";\n    }\n    printf(&g_40305d, &g_403057, &g_403018, &g_403011);\n    if (v2->field_8 != 26) {\n      printf(&g_40304b, &g_403040, &g_40306a, &g_403011);\n      return \"pos->degrees should be 123\";\n    }\n    printf(&g_40305d, &g_403057, &g_40306a, &g_403011);\n    v6 = v2->field_0;\n    if (!((char)((CmpF(v6, 4626728041182805361) & 69) >> 2) & 1) &&\n        ((char)((CmpF(v6, 4626728041182805361) & 69) >> 6) & 1) == 1) {\n      printf(&g_40305d, &g_403057, &g_403085, &g_403011);\n      free(v1);\n      v1 = strdup(\"901.01\");\n      v0 = nmea_position_parse(v1, v2);\n      if (v0) {\n        printf(&g_40304b, &g_403040, &g_403018, &g_403011);\n        return \"should return return 0 when successfull\";\n      }\n      printf(&g_40305d, &g_403057, &g_403018, &g_403011);\n      if (v2->field_8 != 9) {\n        printf(&g_40304b, &g_403040, &g_40306a, &g_403011);\n        return \"pos->degrees should be 123\";\n      }\n      printf(&g_40305d, &g_403057, &g_40306a, &g_403011);\n      v7 = v2->field_0;\n      if (!((char)((CmpF(v7, 4607227454796291113) & 69) >> 2) & 1) &&\n          ((char)((CmpF(v7, 4607227454796291113) & 69) >> 6) & 1) == 1) {\n        printf(&g_40305d, &g_403057, &g_403085, &g_403011);\n        free(v1);\n        v1 = strdup(\"901.\");\n        v0 = nmea_position_parse(v1, v2);\n        if (v0) {\n          printf(&g_40304b, &g_403040, &g_403018, &g_403011);\n          return \"should return return 0 when successfull\";\n        }\n        printf(&g_40305d, &g_403057, &g_403018, &g_403011);\n        if (v2->field_8 != 9) {\n          printf(&g_40304b, &g_403040, &g_40306a, &g_403011);\n          return \"pos->degrees should be 123\";\n        }\n        printf(&g_40305d, &g_403057, &g_40306a, &g_403011);\n        v8 = v2->field_0;\n        if (!((char)((CmpF(v8, 0x3ff0000000000000) & 69) >> 2) & 1) &&\n            ((char)((CmpF(v8, 0x3ff0000000000000) & 69) >> 6) & 1) == 1) {\n          printf(&g_40305d, &g_403057, &g_403085, &g_403011);\n          free(v1);\n          free(v2);\n          return 0;\n        }\n        printf(&g_40304b, &g_403040, &g_403085, &g_403011);\n        return \"pos->minutes should be 11.12\";\n      }\n      printf(&g_40304b, &g_403040, &g_403085, &g_403011);\n      return \"pos->minutes should be 11.12\";\n    }\n    printf(&g_40304b, &g_403040, &g_403085, &g_403011);\n    return \"pos->minutes should be 11.12\";\n  }\n  printf(&g_40304b, &g_403040, &g_403085, &g_403011);\n  return \"pos->minutes should be 11.12\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_position_parse_fail() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"123\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on failure\", \"\\033[0m\");\n            return \"should return return -1 on failure\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on failure\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on empty string\", \"\\033[0m\");\n            return \"should return return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    res = nmea_position_parse(((void *)0), pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on NULL\", \"\\033[0m\");\n            return \"should return return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    free(pos);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4030c0; // add global variable by heuristics\nint g_4030c0; // add global variable by heuristics\nint g_4030e8; // add global variable by heuristics\nint g_4030e8; // add global variable by heuristics\nint g_403110; // add global variable by heuristics\nint g_403110; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_position_parse)(long long, long long);\n\nextern char g_403011;\nextern char g_403040;\nextern char g_40304b;\nextern char g_403057;\nextern char g_40305d;\nextern char g_4030e3;\n\nlong long test_position_parse_fail_name_conflict() {\n  unsigned int v0; // [bp-0x1c]\n  void *v1;        // [bp-0x18]\n  void *v2;        // [bp-0x10]\n\n  v2 = malloc(16);\n  v1 = strdup(\"123\");\n  v0 = nmea_position_parse(v1, v2);\n  if (v0 != -1) {\n    printf(&g_40304b, &g_403040, &g_4030c0, &g_403011);\n    return \"should return return -1 on failure\";\n  }\n  printf(&g_40305d, &g_403057, &g_4030c0, &g_403011);\n  free(v1);\n  v1 = strdup(&g_4030e3);\n  v0 = nmea_position_parse(v1, v2);\n  if (v0 != -1) {\n    printf(&g_40304b, &g_403040, &g_4030e8, &g_403011);\n    return \"should return return -1 on empty string\";\n  }\n  printf(&g_40305d, &g_403057, &g_4030e8, &g_403011);\n  free(v1);\n  v0 = nmea_position_parse(0, v2);\n  if (v0 == -1) {\n    printf(&g_40305d, &g_403057, &g_403110, &g_403011);\n    free(v2);\n    return 0;\n  }\n  printf(&g_40304b, &g_403040, &g_403110, &g_403011);\n  return \"should return return -1 on NULL\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_ok() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"N\");\n    do {\n        if (!((nmea_cardinal_t)'N' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"E\");\n    do {\n        if (!((nmea_cardinal_t)'E' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"S\");\n    do {\n        if (!((nmea_cardinal_t)'S' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"W\");\n    do {\n        if (!((nmea_cardinal_t)'W' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_403138; // add global variable by heuristics\nint g_403138; // add global variable by heuristics\nint g_403168; // add global variable by heuristics\nint g_403168; // add global variable by heuristics\nint g_403198; // add global variable by heuristics\nint g_403198; // add global variable by heuristics\nint g_4031c8; // add global variable by heuristics\nint g_4031c8; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_cardinal_direction_parse)(long long);\n\nextern char g_403011;\nextern char g_403040;\nextern char g_40304b;\nextern char g_403057;\nextern char g_40305d;\n\nlong long test_cardinal_dir_parse_ok_name_conflict() {\n  char v0; // [bp-0x9]\n\n  v0 = nmea_cardinal_direction_parse(\"N\");\n  if (v0 != 78) {\n    printf(&g_40304b, &g_403040, &g_403138, &g_403011);\n    return \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\";\n  }\n  printf(&g_40305d, &g_403057, &g_403138, &g_403011);\n  v0 = nmea_cardinal_direction_parse(\"E\");\n  if (v0 != 69) {\n    printf(&g_40304b, &g_403040, &g_403168, &g_403011);\n    return \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\";\n  }\n  printf(&g_40305d, &g_403057, &g_403168, &g_403011);\n  v0 = nmea_cardinal_direction_parse(\"S\");\n  if (v0 != 83) {\n    printf(&g_40304b, &g_403040, &g_403198, &g_403011);\n    return \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\";\n  }\n  printf(&g_40305d, &g_403057, &g_403198, &g_403011);\n  v0 = nmea_cardinal_direction_parse(\"W\");\n  if (v0 == 87) {\n    printf(&g_40305d, &g_403057, &g_4031c8, &g_403011);\n    return 0;\n  }\n  printf(&g_40304b, &g_403040, &g_4031c8, &g_403011);\n  return \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_fail() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(((void *)0));\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"J\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"n\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4031f0; // add global variable by heuristics\nint g_4031f0; // add global variable by heuristics\nint g_403228; // add global variable by heuristics\nint g_403228; // add global variable by heuristics\nint g_403258; // add global variable by heuristics\nint g_403258; // add global variable by heuristics\nint g_403288; // add global variable by heuristics\nint g_403288; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_cardinal_direction_parse)(long long);\n\nextern char g_403011;\nextern char g_403040;\nextern char g_40304b;\nextern char g_403057;\nextern char g_40305d;\nextern unsigned long long g_4030e3;\n\nlong long test_cardinal_dir_parse_fail_name_conflict() {\n  char v0; // [bp-0x9]\n\n  v0 = nmea_cardinal_direction_parse(&g_4030e3);\n  if (v0) {\n    printf(&g_40304b, &g_403040, &g_4031f0, &g_403011);\n    return \"should return NMEA_CARDINAL_UNKNOWN on empty string\";\n  }\n  printf(&g_40305d, &g_403057, &g_4031f0, &g_403011);\n  v0 = nmea_cardinal_direction_parse(0);\n  if (v0) {\n    printf(&g_40304b, &g_403040, &g_403228, &g_403011);\n    return \"should return NMEA_CARDINAL_UNKNOWN on NULL\";\n  }\n  printf(&g_40305d, &g_403057, &g_403228, &g_403011);\n  v0 = nmea_cardinal_direction_parse(\"J\");\n  if (v0) {\n    printf(&g_40304b, &g_403040, &g_403258, &g_403011);\n    return \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\";\n  }\n  printf(&g_40305d, &g_403057, &g_403258, &g_403011);\n  v0 = nmea_cardinal_direction_parse(\"n\");\n  if (!v0) {\n    printf(&g_40305d, &g_403057, &g_403288, &g_403011);\n    return 0;\n  }\n  printf(&g_40304b, &g_403040, &g_403288, &g_403011);\n  return \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_ok() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"171521\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n            return \"t.tm_sec should be 21\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(15 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 15\", \"\\033[0m\");\n            return \"t.tm_min should be 15\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 15\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(17 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n            return \"t.tm_hour should be 17\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"090801\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n            return \"t.tm_sec should be 1\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(8 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 8\", \"\\033[0m\");\n            return \"t.tm_min should be 8\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 8\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n            return \"t.tm_hour should be 9\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4032ba; // add global variable by heuristics\nint g_4032ba; // add global variable by heuristics\nint g_4032d5; // add global variable by heuristics\nint g_4032d5; // add global variable by heuristics\nint g_4032eb; // add global variable by heuristics\nint g_4032eb; // add global variable by heuristics\nint g_403301; // add global variable by heuristics\nint g_403301; // add global variable by heuristics\nint g_4032ba; // add global variable by heuristics\nint g_4032ba; // add global variable by heuristics\nint g_40331f; // add global variable by heuristics\nint g_40331f; // add global variable by heuristics\nint g_403334; // add global variable by heuristics\nint g_403334; // add global variable by heuristics\nint g_403349; // add global variable by heuristics\nint g_403349; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_time_parse)(long long, long long);\n\nextern char g_403011;\nextern char g_403040;\nextern char g_40304b;\nextern char g_403057;\nextern char g_40305d;\n\nlong long test_time_parse_ok_name_conflict() {\n  char v0;         // [bp-0x48]\n  char v1;         // [bp-0x44]\n  char v2;         // [bp-0x40]\n  unsigned int v3; // [bp-0xc]\n\n  v3 = nmea_time_parse(\"171521\", &v0);\n  if (v3) {\n    printf(&g_40304b, &g_403040, &g_4032ba, &g_403011);\n    return \"should return 0 on success\";\n  }\n  printf(&g_40305d, &g_403057, &g_4032ba, &g_403011);\n  if (*((int *)&v0) != 21) {\n    printf(&g_40304b, &g_403040, &g_4032d5, &g_403011);\n    return \"t.tm_sec should be 21\";\n  }\n  printf(&g_40305d, &g_403057, &g_4032d5, &g_403011);\n  if (*((int *)&v1) != 15) {\n    printf(&g_40304b, &g_403040, &g_4032eb, &g_403011);\n    return \"t.tm_min should be 15\";\n  }\n  printf(&g_40305d, &g_403057, &g_4032eb, &g_403011);\n  if (*((int *)&v2) != 17) {\n    printf(&g_40304b, &g_403040, &g_403301, &g_403011);\n    return \"t.tm_hour should be 17\";\n  }\n  printf(&g_40305d, &g_403057, &g_403301, &g_403011);\n  v3 = nmea_time_parse(\"090801\", &v0);\n  if (v3) {\n    printf(&g_40304b, &g_403040, &g_4032ba, &g_403011);\n    return \"should return 0 on success\";\n  }\n  printf(&g_40305d, &g_403057, &g_4032ba, &g_403011);\n  if (*((int *)&v0) != 1) {\n    printf(&g_40304b, &g_403040, &g_40331f, &g_403011);\n    return \"t.tm_sec should be 1\";\n  }\n  printf(&g_40305d, &g_403057, &g_40331f, &g_403011);\n  if (*((int *)&v1) != 8) {\n    printf(&g_40304b, &g_403040, &g_403334, &g_403011);\n    return \"t.tm_min should be 8\";\n  }\n  printf(&g_40305d, &g_403057, &g_403334, &g_403011);\n  if (*((int *)&v2) == 9) {\n    printf(&g_40305d, &g_403057, &g_403349, &g_403011);\n    return 0;\n  }\n  printf(&g_40304b, &g_403040, &g_403349, &g_403011);\n  return \"t.tm_hour should be 9\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_fail() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"240000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n            return \"should return -1 when hours is over 23\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"006000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n            return \"should return -1 when minutes is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"000062\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n            return \"should return -1 when seconds is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on too short string\", \"\\033[0m\");\n            return \"should return -1 on too short string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on too short string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345XX\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n            return \"should return -1 on invalid characters\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on empty string\", \"\\033[0m\");\n            return \"should return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(((void *)0), &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_403368; // add global variable by heuristics\nint g_403368; // add global variable by heuristics\nint g_403398; // add global variable by heuristics\nint g_403398; // add global variable by heuristics\nint g_4033c8; // add global variable by heuristics\nint g_4033c8; // add global variable by heuristics\nint g_4033f8; // add global variable by heuristics\nint g_4033f8; // add global variable by heuristics\nint g_403428; // add global variable by heuristics\nint g_403428; // add global variable by heuristics\nint g_403450; // add global variable by heuristics\nint g_403450; // add global variable by heuristics\nint g_403471; // add global variable by heuristics\nint g_403471; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_time_parse)(long long, long long);\n\nextern char g_403011;\nextern char g_403040;\nextern char g_40304b;\nextern char g_403057;\nextern char g_40305d;\nextern unsigned long long g_4030e3;\n\nlong long test_time_parse_fail_name_conflict() {\n  char v0;         // [bp-0x48]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = nmea_time_parse(\"240000\", &v0);\n  if (v1 != -1) {\n    printf(&g_40304b, &g_403040, &g_403368, &g_403011);\n    return \"should return -1 when hours is over 23\";\n  }\n  printf(&g_40305d, &g_403057, &g_403368, &g_403011);\n  v1 = nmea_time_parse(\"006000\", &v0);\n  if (v1 != -1) {\n    printf(&g_40304b, &g_403040, &g_403398, &g_403011);\n    return \"should return -1 when minutes is over 59\";\n  }\n  printf(&g_40305d, &g_403057, &g_403398, &g_403011);\n  v1 = nmea_time_parse(\"000062\", &v0);\n  if (v1 != -1) {\n    printf(&g_40304b, &g_403040, &g_4033c8, &g_403011);\n    return \"should return -1 when seconds is over 59\";\n  }\n  printf(&g_40305d, &g_403057, &g_4033c8, &g_403011);\n  v1 = nmea_time_parse(\"2345\", &v0);\n  if (v1 != -1) {\n    printf(&g_40304b, &g_403040, &g_4033f8, &g_403011);\n    return \"should return -1 on too short string\";\n  }\n  printf(&g_40305d, &g_403057, &g_4033f8, &g_403011);\n  v1 = nmea_time_parse(\"2345XX\", &v0);\n  if (v1 != -1) {\n    printf(&g_40304b, &g_403040, &g_403428, &g_403011);\n    return \"should return -1 on invalid characters\";\n  }\n  printf(&g_40305d, &g_403057, &g_403428, &g_403011);\n  v1 = nmea_time_parse(&g_4030e3, &v0);\n  if (v1 != -1) {\n    printf(&g_40304b, &g_403040, &g_403450, &g_403011);\n    return \"should return -1 on empty string\";\n  }\n  printf(&g_40305d, &g_403057, &g_403450, &g_403011);\n  v1 = nmea_time_parse(0, &v0);\n  if (v1 == -1) {\n    printf(&g_40305d, &g_403057, &g_403471, &g_403011);\n    return 0;\n  }\n  printf(&g_40304b, &g_403040, &g_403471, &g_403011);\n  return \"should return -1 on NULL\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_position_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_position_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_position_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_cardinal_dir_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_cardinal_dir_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_cardinal_dir_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_time_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_time_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_time_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_position_parse_ok)();\nlong long(test_position_parse_fail)();\nlong long(test_cardinal_dir_parse_ok)();\nlong long(test_cardinal_dir_parse_fail)();\nlong long(test_time_parse_ok)();\nlong long(test_time_parse_fail)();\n\nextern char g_403011;\nextern char g_40348a;\nextern char g_4034a0;\nextern char g_4034a6;\nextern char g_4034b3;\nextern char g_4034cd;\nextern unsigned int tests_run;\n\nlong long all_tests_name_conflict() {\n  unsigned long v0; // [bp-0x38]\n  unsigned long v1; // [bp-0x30]\n  unsigned long v2; // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  unsigned long v4; // [bp-0x18]\n  unsigned long v5; // [bp-0x10]\n\n  printf(&g_4034a6, &g_4034a0, &g_40348a, &g_403011);\n  v5 = test_position_parse_ok();\n  tests_run = tests_run + 1;\n  if (v5)\n    return v5;\n  v4 = test_position_parse_fail();\n  tests_run = tests_run + 1;\n  if (v4)\n    return v4;\n  printf(&g_4034a6, &g_4034a0, &g_4034b3, &g_403011);\n  v3 = test_cardinal_dir_parse_ok();\n  tests_run = tests_run + 1;\n  if (v3)\n    return v3;\n  v2 = test_cardinal_dir_parse_fail();\n  tests_run = tests_run + 1;\n  if (v2)\n    return v2;\n  printf(&g_4034a6, &g_4034a0, &g_4034cd, &g_403011);\n  v1 = test_time_parse_ok();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  v0 = test_time_parse_fail();\n  tests_run = tests_run + 1;\n  return (!v0 ? v0 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":1,"function":"nmea_cardinal_t nmea_cardinal_direction_parse(char *s) {\n    if (((void *)0) == s || '\\x00' == *s) {\n        return (nmea_cardinal_t)'\\x00';\n    }\n    switch (*s) {\n      case (nmea_cardinal_t)'N':\n        return (nmea_cardinal_t)'N';\n      case (nmea_cardinal_t)'E':\n        return (nmea_cardinal_t)'E';\n      case (nmea_cardinal_t)'S':\n        return (nmea_cardinal_t)'S';\n      case (nmea_cardinal_t)'W':\n        return (nmea_cardinal_t)'W';\n      default:\n        break;\n    }\n    return (nmea_cardinal_t)'\\x00';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nmea_cardinal_direction_parse_name_conflict(char *a0) {\n  unsigned int v2; // eax\n\n  if (a0 && *(a0)) {\n    v2 = *(a0);\n    if (v2 == 87)\n      return 87;\n    if (v2 > 87)\n      return 0;\n    if (v2 == 83) {\n      return 83;\n    } else if (v2 <= 83) {\n      if (v2 == 69) {\n        return 69;\n      } else if (v2 == 78) {\n        return 78;\n      }\n    }\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/src/parsers/parse.c"}
{"compilable":0,"function":"static char *test_get_type_ok() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGLL == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n            return \"should return correct type (GPGLL)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGGA,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGGA == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n            return \"should return correct type (GPGGA)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404038; // add global variable by heuristics\nint g_404038; // add global variable by heuristics\nint g_4040b0; // add global variable by heuristics\nint g_4040b0; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_get_type)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_get_type_ok_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n  v0 = nmea_get_type(v1);\n  if (v0 != 2) {\n    printf(&g_404066, &g_40405b, &g_404038, &g_404033);\n    return \"should return correct type (GPGLL)\";\n  }\n  printf(&g_404078, &g_404072, &g_404038, &g_404033);\n  free(v1);\n  v1 = strdup(\"$GPGGA,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  v0 = nmea_get_type(v1);\n  if (v0 == 1) {\n    printf(&g_404078, &g_404072, &g_4040b0, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_4040b0, &g_404033);\n  return \"should return correct type (GPGGA)\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_type_unknown() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"THISISWRONG\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$UNKNOWN\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n            return \"should return nmea_unknown on empty sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4040e0; // add global variable by heuristics\nint g_4040e0; // add global variable by heuristics\nint g_4040e0; // add global variable by heuristics\nint g_4040e0; // add global variable by heuristics\nint g_404120; // add global variable by heuristics\nint g_404120; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_get_type)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\nextern char g_40411d;\n\nlong long test_get_type_unknown_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10]\n\n  v1 = strdup(\"THISISWRONG\");\n  v0 = nmea_get_type(v1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_4040e0, &g_404033);\n    return \"should return NMEA_UNKNOWN on unknown sentence type\";\n  }\n  printf(&g_404078, &g_404072, &g_4040e0, &g_404033);\n  free(v1);\n  v1 = strdup(\"$UNKNOWN\");\n  v0 = nmea_get_type(v1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_4040e0, &g_404033);\n    return \"should return NMEA_UNKNOWN on unknown sentence type\";\n  }\n  printf(&g_404078, &g_404072, &g_4040e0, &g_404033);\n  free(v1);\n  v1 = strdup(&g_40411d);\n  v0 = nmea_get_type(v1);\n  if (!v0) {\n    printf(&g_404078, &g_404072, &g_404120, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404120, &g_404033);\n  return \"should return nmea_unknown on empty sentence\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404150; // add global variable by heuristics\nint g_404150; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_get_checksum)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_get_checksum_with_crc_name_conflict() {\n  char v0;  // [bp-0x11]\n  void *v1; // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n  v0 = nmea_get_checksum(v1);\n  if (v0 == 29) {\n    printf(&g_404078, &g_404072, &g_404150, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404150, &g_404033);\n  return \"should return correct checksum\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_without_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404150; // add global variable by heuristics\nint g_404150; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_get_checksum)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_get_checksum_without_crc_name_conflict() {\n  char v0;  // [bp-0x11]\n  void *v1; // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,\\r\\n\");\n  v0 = nmea_get_checksum(v1);\n  if (v0 == 29) {\n    printf(&g_404078, &g_404072, &g_404150, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404150, &g_404033);\n  return \"should return correct checksum\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_yes() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*1D\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n            return \"should return 0 when sentence has a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4041c8; // add global variable by heuristics\nint g_4041c8; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_has_checksum)(long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_has_checksum_yes_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  char *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*1D\\r\\n\");\n  v0 = nmea_has_checksum(v1, strlen(v1));\n  if (!v0) {\n    printf(&g_404078, &g_404072, &g_4041c8, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_4041c8, &g_404033);\n  return \"should return 0 when sentence has a checksum\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_no() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n            return \"should return -1 when sentence does not have a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404220; // add global variable by heuristics\nint g_404220; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_has_checksum)(long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_has_checksum_no_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  char *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  v0 = nmea_has_checksum(v1, strlen(v1));\n  if (v0 == -1) {\n    printf(&g_404078, &g_404072, &g_404220, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404220, &g_404033);\n  return \"should return -1 when sentence does not have a checksum\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404258; // add global variable by heuristics\nint g_404258; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_validate)(long long, long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_validate_ok_with_crc_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (!v0) {\n    printf(&g_404078, &g_404072, &g_404258, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404258, &g_404033);\n  return \"should return 0 when sentence is valid\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_without_crc() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*FF\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 0);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n            return \"should return 0 when check_checksum is 0 and crc is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404258; // add global variable by heuristics\nint g_404258; // add global variable by heuristics\nint g_4042b0; // add global variable by heuristics\nint g_4042b0; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_validate)(long long, long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_validate_ok_without_crc_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  char *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_404258, &g_404033);\n    return \"should return 0 when sentence is valid\";\n  }\n  printf(&g_404078, &g_404072, &g_404258, &g_404033);\n  free(v1);\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*FF\\r\\n\");\n  v0 = nmea_validate(v1, strlen(v1), 0);\n  if (!v0) {\n    printf(&g_404078, &g_404072, &g_4042b0, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_4042b0, &g_404033);\n  return \"should return 0 when check_checksum is 0 and crc is invalid\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_type() {\n    char *sentence = strdup(\"$GPgll,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence type is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404318; // add global variable by heuristics\nint g_404318; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_validate)(long long, long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_validate_fail_type_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPgll,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (v0 == -1) {\n    printf(&g_404078, &g_404072, &g_404318, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404318, &g_404033);\n  return \"should return -1 when sentence type is invalid\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_start() {\n    char *sentence = strdup(\"\\302\\243GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence start is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404370; // add global variable by heuristics\nint g_404370; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_validate)(long long, long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\nextern char g_404348;\n\nlong long test_validate_fail_start_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  char *v1;        // [bp-0x10]\n\n  v1 = strdup(&g_404348);\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (v0 == -1) {\n    printf(&g_404078, &g_404072, &g_404370, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404370, &g_404033);\n  return \"should return -1 when sentence start is invalid\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_end() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence ending is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GP\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n            return \"should return -1 when sentence is too short\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4043c8; // add global variable by heuristics\nint g_4043c8; // add global variable by heuristics\nint g_404400; // add global variable by heuristics\nint g_404400; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_validate)(long long, long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_validate_fail_end_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  char *v1;        // [bp-0x10]\n\n  v1 = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\");\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (v0 != -1) {\n    printf(&g_404066, &g_40405b, &g_4043c8, &g_404033);\n    return \"should return -1 when sentence ending is invalid\";\n  }\n  printf(&g_404078, &g_404072, &g_4043c8, &g_404033);\n  free(v1);\n  v1 = strdup(\"$GP\");\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (v0 == -1) {\n    printf(&g_404078, &g_404072, &g_404400, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404400, &g_404033);\n  return \"should return -1 when sentence is too short\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_empty() {\n    char *sentence = strdup(\"\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n            return \"should return -1 when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404430; // add global variable by heuristics\nint g_404430; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_validate)(long long, long long, long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\nextern char g_40411d;\n\nlong long test_validate_fail_empty_name_conflict() {\n  unsigned int v0; // [bp-0x14]\n  void *v1;        // [bp-0x10]\n\n  v1 = strdup(&g_40411d);\n  v0 = nmea_validate(v1, strlen(v1), 1);\n  if (v0 == -1) {\n    printf(&g_404078, &g_404072, &g_404430, &g_404033);\n    free(v1);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404430, &g_404033);\n  return \"should return -1 when sentence is empty\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_ok() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 0);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4044a0; // add global variable by heuristics\nint g_4044a0; // add global variable by heuristics\nint g_4044a0; // add global variable by heuristics\nint g_4044a0; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_parse)(long long, long long, long long);\nlong long(nmea_free)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_parse_ok_name_conflict() {\n  unsigned long long v0; // [bp-0x18]\n  void *v1;              // [bp-0x10]\n\n  v1 = strdup(\n      \"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n  v0 = nmea_parse(v1, strlen(v1), 1);\n  if (!v0) {\n    printf(&g_404066, &g_40405b, &g_4044a0, &g_404033);\n    return \"should be able to parse a GPGGA sentence\";\n  }\n  printf(&g_404078, &g_404072, &g_4044a0, &g_404033);\n  free(v1);\n  nmea_free(v0);\n  v1 = strdup(\n      \"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n  v0 = nmea_parse(v1, strlen(v1), 0);\n  if (!v0) {\n    printf(&g_404066, &g_40405b, &g_4044a0, &g_404033);\n    return \"should be able to parse a GPGGA sentence\";\n  }\n  printf(&g_404078, &g_404072, &g_4044a0, &g_404033);\n  free(v1);\n  nmea_free(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_unknown() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$JACK1,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n            return \"should return NULL when sentence type is unknown\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404560; // add global variable by heuristics\nint g_404560; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_parse)(long long, long long, long long);\nlong long(nmea_free)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\n\nlong long test_parse_unknown_name_conflict() {\n  unsigned long long v0; // [bp-0x18]\n  char *v1;              // [bp-0x10]\n\n  v1 = strdup(\n      \"$JACK1,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n  v0 = nmea_parse(v1, strlen(v1), 1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_404560, &g_404033);\n    return \"should return NULL when sentence type is unknown\";\n  }\n  printf(&g_404078, &g_404072, &g_404560, &g_404033);\n  free(v1);\n  nmea_free(v0);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_invalid() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n            return \"should return NULL when checksum is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n            return \"should return NULL when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"invalid\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n            return \"should return NULL when sentence is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    res = nmea_parse(((void *)0), 0, 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n            return \"should return NULL when sentence is NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n    } while (0);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404598; // add global variable by heuristics\nint g_404598; // add global variable by heuristics\nint g_4045c8; // add global variable by heuristics\nint g_4045c8; // add global variable by heuristics\nint g_404600; // add global variable by heuristics\nint g_404600; // add global variable by heuristics\nint g_404630; // add global variable by heuristics\nint g_404630; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(nmea_parse)(long long, long long, long long);\nlong long(nmea_free)(long long);\n\nextern char g_404033;\nextern char g_40405b;\nextern char g_404066;\nextern char g_404072;\nextern char g_404078;\nextern char g_40411d;\n\nlong long test_parse_invalid_name_conflict() {\n  unsigned long long v0; // [bp-0x18]\n  void *v1;              // [bp-0x10], Other Possible Types: char *\n\n  v1 = strdup(\n      \"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n  v0 = nmea_parse(v1, strlen(v1), 1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_404598, &g_404033);\n    return \"should return NULL when checksum is invalid\";\n  }\n  printf(&g_404078, &g_404072, &g_404598, &g_404033);\n  free(v1);\n  nmea_free(v0);\n  v1 = strdup(&g_40411d);\n  v0 = nmea_parse(v1, strlen(v1), 1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_4045c8, &g_404033);\n    return \"should return NULL when sentence is empty\";\n  }\n  printf(&g_404078, &g_404072, &g_4045c8, &g_404033);\n  free(v1);\n  nmea_free(v0);\n  v1 = strdup(\"invalid\");\n  v0 = nmea_parse(v1, strlen(v1), 1);\n  if (v0) {\n    printf(&g_404066, &g_40405b, &g_404600, &g_404033);\n    return \"should return NULL when sentence is invalid\";\n  }\n  printf(&g_404078, &g_404072, &g_404600, &g_404033);\n  free(v1);\n  nmea_free(v0);\n  v0 = nmea_parse(0, 0, 1);\n  if (!v0) {\n    printf(&g_404078, &g_404072, &g_404630, &g_404033);\n    nmea_free(v0);\n    return 0;\n  }\n  printf(&g_404066, &g_40405b, &g_404630, &g_404033);\n  return \"should return NULL when sentence is NULL\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_type()\", \"\\033[0m\");\n    do {\n        char *message = test_get_type_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_type_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_get_checksum_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_checksum_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_has_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_has_checksum_yes();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_has_checksum_no();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_validate()\", \"\\033[0m\");\n    do {\n        char *message = test_validate_ok_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_ok_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_type();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_start();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_end();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_empty();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_invalid();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_get_type_ok)();\nlong long(test_get_type_unknown)();\nlong long(test_get_checksum_with_crc)();\nlong long(test_get_checksum_without_crc)();\nlong long(test_has_checksum_yes)();\nlong long(test_has_checksum_no)();\nlong long(test_validate_ok_with_crc)();\nlong long(test_validate_ok_without_crc)();\nlong long(test_validate_fail_type)();\nlong long(test_validate_fail_start)();\nlong long(test_validate_fail_end)();\nlong long(test_validate_fail_empty)();\nlong long(test_parse_ok)();\nlong long(test_parse_unknown)();\nlong long(test_parse_invalid)();\n\nextern char g_404033;\nextern char g_404659;\nextern char g_404669;\nextern char g_40466f;\nextern char g_40467c;\nextern char g_404690;\nextern char g_4046a4;\nextern char g_4046b4;\nextern unsigned int tests_run;\n\nlong long all_tests_name_conflict() {\n  unsigned long v0;  // [bp-0x80]\n  unsigned long v1;  // [bp-0x78]\n  unsigned long v2;  // [bp-0x70]\n  unsigned long v3;  // [bp-0x68]\n  unsigned long v4;  // [bp-0x60]\n  unsigned long v5;  // [bp-0x58]\n  unsigned long v6;  // [bp-0x50]\n  unsigned long v7;  // [bp-0x48]\n  unsigned long v8;  // [bp-0x40]\n  unsigned long v9;  // [bp-0x38]\n  unsigned long v10; // [bp-0x30]\n  unsigned long v11; // [bp-0x28]\n  unsigned long v12; // [bp-0x20]\n  unsigned long v13; // [bp-0x18]\n  unsigned long v14; // [bp-0x10]\n\n  printf(&g_40466f, &g_404669, &g_404659, &g_404033);\n  v14 = test_get_type_ok();\n  tests_run = tests_run + 1;\n  if (v14)\n    return v14;\n  v13 = test_get_type_unknown();\n  tests_run = tests_run + 1;\n  if (v13)\n    return v13;\n  printf(&g_40466f, &g_404669, &g_40467c, &g_404033);\n  v12 = test_get_checksum_with_crc();\n  tests_run = tests_run + 1;\n  if (v12)\n    return v12;\n  v11 = test_get_checksum_without_crc();\n  tests_run = tests_run + 1;\n  if (v11)\n    return v11;\n  printf(&g_40466f, &g_404669, &g_404690, &g_404033);\n  v10 = test_has_checksum_yes();\n  tests_run = tests_run + 1;\n  if (v10)\n    return v10;\n  v9 = test_has_checksum_no();\n  tests_run = tests_run + 1;\n  if (v9)\n    return v9;\n  printf(&g_40466f, &g_404669, &g_4046a4, &g_404033);\n  v8 = test_validate_ok_with_crc();\n  tests_run = tests_run + 1;\n  if (v8)\n    return v8;\n  v7 = test_validate_ok_without_crc();\n  tests_run = tests_run + 1;\n  if (v7)\n    return v7;\n  v6 = test_validate_fail_type();\n  tests_run = tests_run + 1;\n  if (v6)\n    return v6;\n  v5 = test_validate_fail_start();\n  tests_run = tests_run + 1;\n  if (v5)\n    return v5;\n  v4 = test_validate_fail_end();\n  tests_run = tests_run + 1;\n  if (v4)\n    return v4;\n  v3 = test_validate_fail_empty();\n  tests_run = tests_run + 1;\n  if (v3)\n    return v3;\n  printf(&g_40466f, &g_404669, &g_4046b4, &g_404033);\n  v2 = test_parse_ok();\n  tests_run = tests_run + 1;\n  if (v2)\n    return v2;\n  v1 = test_parse_unknown();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  v0 = test_parse_invalid();\n  tests_run = tests_run + 1;\n  return (!v0 ? v0 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static int _is_value_set(const char *value) {\n    if (((void *)0) == value || '\\x00' == *value) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _is_value_set_name_conflict(char *a0) {\n  if (a0 && *(a0))\n    return 0;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static char *_crop_sentence(char *sentence, size_t length) {\n    sentence += 5 + 2;\n    sentence[length - 9] = '\\x00';\n    if ('*' == sentence[length - 12]) {\n        sentence[length - 12] = '\\x00';\n    }\n    return sentence;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _crop_sentence_name_conflict(char *a0, unsigned long a1) {\n  char *v0; // [bp-0x10]\n\n  v0 = a0;\n  v0 += 7;\n  v0[9 + a1] = 0;\n  if (v0[12 + a1] == 42)\n    v0[12 + a1] = 0;\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _split_string_by_comma(char *string, char **values, int max_values) {\n    int i = 0;\n    values[i++] = string;\n    while (i < max_values && ((void *)0) != (string = strchr(string, ',')))\n        {\n            *string = '\\x00';\n            values[i++] = ++string;\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _split_string_by_comma_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char *v0;               // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1;        // [bp-0xc]\n  unsigned long long *v3; // rax\n\n  v0 = a0;\n  for (v1 = 0; v1 < (unsigned int)a2; v0 += 1) {\n    v3 = v1;\n    v1 = (unsigned int)v3 + 1;\n    *((unsigned long *)(v3 * 8 + a1)) = v0;\n    v0 = strchr(v0, 44);\n    if (!v0)\n      return v1;\n    *(v0) = 0;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpc7sj30vd/_split_string_by_comma_name_conflict.c:28:32: error: invalid operands to\nbinary expression ('unsigned long long *' and 'int') 28 |         *((unsigned\nlong *)(v3 * 8 + a1)) = v0; |                             ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_t nmea_get_type(const char *sentence) {\n    if (((void *)0) == sentence) {\n        return NMEA_UNKNOWN;\n    }\n    nmea_parser_module_s *parser = nmea_get_parser_by_sentence(sentence);\n    if (((void *)0) == parser) {\n        return NMEA_UNKNOWN;\n    }\n    return parser->parser.type;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_get_parser_by_sentence)(long long);\n\nlong long nmea_get_type_name_conflict(unsigned long long a0) {\n  unsigned int *v0; // [bp-0x10]\n\n  if (!a0)\n    return 0;\n  v0 = nmea_get_parser_by_sentence(a0);\n  return (!v0 ? *(v0) : 0);\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"uint8_t nmea_get_checksum(const char *sentence) {\n    const char *n = sentence + 1;\n    uint8_t chk = 0;\n    while ('*' != *n && '\\r' != *n && '\\x00' != *n)\n        {\n            chk ^= (uint8_t)*n;\n            n++;\n        }\n    return chk;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nmea_get_checksum_name_conflict(unsigned long a0) {\n  char v0;  // [bp-0x11]\n  char *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = a0 + 1;\n  for (v0 = 0; *((char *)v1) != 42; v1 += 1) {\n    if (*((char *)v1) == 13)\n      return v0;\n    if (!*((char *)v1))\n      return v0;\n    v0 ^= *((char *)v1);\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_has_checksum(const char *sentence, size_t length) {\n    if ('*' == sentence[length - 5]) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nmea_has_checksum_name_conflict(char *a0, unsigned long a1) {\n  return (a0[5 + a1] == 42 ? 4294967295 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_validate(const char *sentence, size_t length, int check_checksum) {\n    const char *n;\n    if (9 > length) {\n        return -1;\n    }\n    if (82 < length) {\n        return -1;\n    }\n    if ('$' != *sentence) {\n        return -1;\n    }\n    if ('\\n' != sentence[length - 1] || '\\r' != sentence[length - 2]) {\n        return -1;\n    }\n    n = sentence;\n    while (++n < sentence + 6)\n        {\n            if (*n < 'A' || *n > 'Z') {\n                return -1;\n            }\n        }\n    if (',' != sentence[6]) {\n        return -1;\n    }\n    if (1 == check_checksum && 0 == nmea_has_checksum(sentence, length)) {\n        uint8_t actual_chk;\n        uint8_t expected_chk;\n        char checksum[3];\n        checksum[0] = sentence[length - 4];\n        checksum[1] = sentence[length - 3];\n        checksum[2] = '\\x00';\n        actual_chk = nmea_get_checksum(sentence);\n        expected_chk = (uint8_t)strtol(checksum, ((void *)0), 16);\n        if (expected_chk != actual_chk) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_has_checksum)(long long, long long);\nlong long(nmea_get_checksum)(long long);\n\nlong long nmea_validate_name_conflict(char a0[7], unsigned long long a1, unsigned long a2) {\n  char v0;               // [bp-0x15]\n  char v1;               // [bp-0x14]\n  char v2;               // [bp-0x13]\n  char v3;               // [bp-0x12]\n  char v4;               // [bp-0x11]\n  char v5[7];            // [bp-0x10], Other Possible Types: unsigned long\n  char v6;               // [bp-0x8]\n  unsigned long long v8; // rbp\n\n  v8 = &v6;\n  if (a1 <= 8) {\n    return 4294967295;\n  } else if (a1 > 82) {\n    return 4294967295;\n  } else if (a0[0] != 36) {\n    return 4294967295;\n  } else {\n    if (!(a0[1 + a1] == 10 && a0[2 + a1] == 13))\n      return 4294967295;\n    *(&v5) = a0;\n    while (true) {\n      v5 += 1;\n      if (v5 >= &a0[6])\n        break;\n      if (!(*((char *)v5) > 64) || !(*((char *)v5) <= 90))\n        return 4294967295;\n    }\n    if (a0[6] != 44)\n      return 4294967295;\n    if (!((unsigned int)a2 == 1 && !(int)nmea_has_checksum(a0, a1)))\n      return 0;\n    v0 = a0[4 + a1];\n    v1 = a0[3 + a1];\n    v2 = 0;\n    v4 = nmea_get_checksum(a0);\n    v3 = strtol(&v0, NULL, 16);\n    if (v3 != v4)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3y6ityqw/nmea_validate_name_conflict.c:47:16: error: array type 'char[7]' is not\nassignable 47 |         *(&v5) = a0; |         ~~~~~~ ^\n/tmp/tmp3y6ityqw/nmea_validate_name_conflict.c:50:16: error: invalid operands to binary\nexpression ('char[7]' and 'int') 50 |             v5 += 1; |             ~~ ^  ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_s *nmea_parse(char *sentence, size_t length, int check_checksum) {\n    unsigned int n_vals, val_index;\n    char *value, *val_string;\n    char *values[255];\n    nmea_parser_module_s *parser;\n    nmea_t type;\n    if (-1 == nmea_validate(sentence, length, check_checksum)) {\n        return (nmea_s *)((void *)0);\n    }\n    type = nmea_get_type(sentence);\n    if (NMEA_UNKNOWN == type) {\n        return (nmea_s *)((void *)0);\n    }\n    val_string = _crop_sentence(sentence, length);\n    if (((void *)0) == val_string) {\n        return (nmea_s *)((void *)0);\n    }\n    n_vals = _split_string_by_comma(val_string, values, (sizeof values / sizeof (values[0])));\n    if (0 == n_vals) {\n        return (nmea_s *)((void *)0);\n    }\n    parser = nmea_get_parser_by_type(type);\n    if (((void *)0) == parser) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->allocate_data((nmea_parser_s *)parser);\n    if (((void *)0) == parser->parser.data) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->set_default((nmea_parser_s *)parser);\n    parser->errors = 0;\n    for (val_index = 0; val_index < n_vals; val_index++) {\n        value = values[val_index];\n        if (-1 == _is_value_set(value)) {\n            continue;\n        }\n        if (-1 == parser->parse((nmea_parser_s *)parser, value, val_index)) {\n            parser->errors++;\n        }\n    }\n    parser->parser.data->type = type;\n    parser->parser.data->errors = parser->errors;\n    return parser->parser.data;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_validate)(long long, long long, long long);\nlong long(nmea_get_type)(long long);\nlong long(_crop_sentence)(long long, long long);\nlong long(_split_string_by_comma)(long long, long long, long long);\nlong long(nmea_get_parser_by_type)(long long);\nlong long(_is_value_set)(long long);\n\ntypedef struct struct_1 {\n  char padding_0[16];\n  struct struct_2 *field_10;\n  unsigned int field_18;\n  char padding_1c[12];\n  struct struct_0 *field_28;\n  struct struct_0 *field_30;\n  char padding_38[8];\n  struct struct_0 *field_40;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned int field_4;\n} struct_2;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n} struct_0;\n\nlong long nmea_parse(unsigned long long a0, unsigned long long a1,\n                     unsigned long a2) {\n  char v0;               // [bp-0x828]\n  unsigned long long v1; // [bp-0x30]\n  struct_1 *v2;          // [bp-0x28]\n  unsigned int v3;       // [bp-0x1c]\n  unsigned long long v4; // [bp-0x18]\n  unsigned int v5;       // [bp-0x10]\n  unsigned int v6;       // [bp-0xc]\n  unsigned long long v9; // rcx\n\n  if ((int)nmea_validate(a0, a1, (unsigned int)a2) == -1)\n    return 0;\n  v5 = nmea_get_type(a0);\n  if (!v5)\n    return 0;\n  v4 = _crop_sentence(a0, a1);\n  if (!v4)\n    return 0;\n  v3 = _split_string_by_comma(v4, &v0, 255);\n  if (!v3)\n    return 0;\n  v2 = nmea_get_parser_by_type(v5);\n  if (!v2)\n    return 0;\n  v2->field_28(v2);\n  if (!v2->field_10)\n    return 0;\n  v2->field_30(v2);\n  v2->field_18 = 0;\n  for (v6 = 0; v6 < v3; v6 += 1) {\n    v1 = *((long long *)&(&v0)[8 * v6]);\n    if ((int)_is_value_set(v1) != -1) {\n      v9 = v1;\n      if (v2->field_40(v2, v9, v6, v9, v2->field_40) == -1)\n        v2->field_18 = v2->field_18 + 1;\n    }\n  }\n  v2->field_10->field_0 = v5;\n  v2->field_10->field_4 = v2->field_18;\n  return v2->field_10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi97ygiea/nmea_parse.c:68:17: error: called object type 'struct struct_0\n*' is not a function or function pointer 68 |     v2->field_28(v2); |\n~~~~~~~~~~~~^ /tmp/tmpi97ygiea/nmea_parse.c:71:17: error: called object type\n'struct struct_0 *' is not a function or function pointer 71 | v2->field_30(v2);\n      |     ~~~~~~~~~~~~^\n/tmp/tmpi97ygiea/nmea_parse.c:79:29: error: called object type 'struct struct_0\n*' is not a function or function pointer 79 |             if (v2->field_40(v2,\nv9, v6, v9, v2->field_40) == -1) |                 ~~~~~~~~~~~~^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nchar *(strcat)(char *, char *);\n\ntypedef struct struct_0 {\n  char padding_0[19];\n  char field_13;\n} struct_0;\n\nlong long _get_so_files_name_conflict(char *a0, unsigned long a1) {\n  unsigned int v0;  // [bp-0x34]\n  char *v1;         // [bp-0x30]\n  unsigned long v2; // [bp-0x28]\n  struct_0 *v3;     // [bp-0x20]\n  char *v4;         // [bp-0x18], Other Possible Types: void*\n  unsigned int v5;  // [bp-0xc]\n  void **v8;        // rax\n\n  v5 = 0;\n  v4 = 0;\n  v4 = opendir(a0);\n  if (!v4)\n    return 4294967295;\n  while (true) {\n    do {\n      do {\n        v3 = &readdir(v4);\n        if (!v3) {\n          if (!v4)\n            return v5;\n          closedir(v4);\n        }\n      } while (v3->field_13 == 46);\n    } while ((v2 = strlen(v3 + 19),\n              !(v2 > 2) || !(!strncmp(v2 - 3 + v3 + 19, \".so\", 3))));\n    v1 = malloc(255);\n    if (!v1)\n      break;\n    strcpy(v1, a0);\n    strcat(v1, &v3->field_13);\n    v8 = v5;\n    v5 = (unsigned int)v8 + 1;\n    *((char **)(v8 * 8 + a1)) = v1;\n  }\n  for (v0 = 0; v0 < v5; v5 += 1) {\n    free(*((long long *)(a1 + v0 * 8)));\n  }\n  if (!v4)\n    return 4294967295;\n  closedir(v4);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn6zsa90f/_get_so_files_name_conflict.c:47:22: error: cannot take the address of an\nrvalue of type 'char *' 47 |                 v3 = &readdir(v4); | ^~~~~~~~~~~~\n/tmp/tmpn6zsa90f/_get_so_files_name_conflict.c:63:24: error: invalid operands to binary\nexpression ('void **' and 'int') 63 |         *((char **)(v8 * 8 + a1)) = v1; |\n~~ ^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nlong long(_get_so_files)(long long, long long);\nlong long(nmea_init_parser)(long long);\n\nextern unsigned int n_parsers;\nextern void *parsers;\n\nlong long nmea_load_parsers_name_conflict() {\n  void *v0;         // [bp-0x818]\n  unsigned long v1; // [bp-0x20]\n  unsigned long v2; // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned int v3;  // [bp-0xc]\n  unsigned int v6;  // eax\n\n  v2 = getenv(\"NMEA_PARSER_PATH\");\n  if (!v2)\n    v2 = \"/usr/lib/nmea/\";\n  n_parsers = _get_so_files(v2, &v0);\n  if (n_parsers <= 0)\n    return 4294967295;\n  parsers = malloc(n_parsers * 8);\n  if (!parsers)\n    return 4294967295;\n  memset(parsers, 0, n_parsers * 8);\n  v3 = n_parsers;\n  while (true) {\n    v6 = v3;\n    v3 = v6 - 1;\n    if (v6 <= 0)\n      return n_parsers;\n    v1 = nmea_init_parser((&v0)[v3]);\n    free((&v0)[v3]);\n    if (!v1)\n      return 4294967295;\n    *((unsigned long *)(8 * v3 + (char *)parsers)) = v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long usart_recv_name_conflict(unsigned long a0) {\n  return *((char *)((unsigned short)a0 + 1));\n}\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(usart_wait_recv_ready)(long long);\nlong long(usart_recv)(long long);\n\nlong long usart_recv_blocking_name_conflict(unsigned long a0) {\n  usart_wait_recv_ready((unsigned short)a0);\n  return usart_recv((unsigned short)a0);\n}\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long usart_recv_name_conflict(unsigned long a0) {\n  return *((char *)((unsigned short)a0 + 1));\n}\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(usart_wait_recv_ready)(long long);\nlong long(usart_recv)(long long);\n\nlong long usart_recv_blocking_name_conflict(unsigned long a0) {\n  usart_wait_recv_ready((unsigned short)a0);\n  return usart_recv((unsigned short)a0);\n}\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"char *replace_str(char *str, char *orig, char *rep) {\n    static char buffer[4096];\n    char *p;\n    int i = 0;\n    while (str[i])\n        {\n            if (!(p = strstr(str + i, orig)))\n                return str;\n            strncpy(buffer + strlen(buffer), str + i, (p - str) - i);\n            buffer[p - str] = '\\x00';\n            strcat(buffer, rep);\n            printf(\"STR:%s\\n\", buffer);\n            i = (p - str) + strlen(orig);\n        }\n    return buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nchar *(strcat)(char *, char *);\n\nextern char buffer.0;\n\nlong long replace_str_name_conflict(char *a0, char *a1, char *a2) {\n  char *v0;         // [bp-0x30]\n  unsigned long v1; // [bp-0x28]\n  unsigned int v2;  // [bp-0x1c]\n\n  v0 = a0;\n  v2 = 0;\n  while (true) {\n    if (a0[v2]) {\n      v1 = strstr(&a0[v2], a1);\n      if (!v1)\n        return a0;\n      strncpy(&(&buffer.0)[strlen(&buffer.0)], &v0[v2], v1 - a0 - v2);\n      *((char *)(v1 - a0 + &buffer.0)) = 0;\n      strcat(&buffer.0, a2);\n      printf(\"STR:%s\\n\", &buffer.0);\n      v2 = (unsigned int)strlen(a1) + (unsigned int)(v1 - a0);\n    } else {\n      return &buffer.0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:19:19: error: expected ';' after top level\ndeclarator 19 | extern char buffer.0; |                   ^ | ;\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:36:30: error: expected ')'\n   36 |             strncpy(&(&buffer.0)[strlen(&buffer.0)], &v0[v2], v1 - a0 -\nv2); |                              ^ /tmp/tmpo80f7gfh/replace_str_name_conflict.c:36:22:\nnote: to match this '(' 36 | strncpy(&(&buffer.0)[strlen(&buffer.0)], &v0[v2],\nv1 - a0 - v2); |                      ^ /tmp/tmpo80f7gfh/replace_str_name_conflict.c:36:48:\nerror: expected ')' 36 |             strncpy(&(&buffer.0)[strlen(&buffer.0)],\n&v0[v2], v1 - a0 - v2); |                                                ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:36:40: note: to match this '('\n   36 |             strncpy(&(&buffer.0)[strlen(&buffer.0)], &v0[v2], v1 - a0 -\nv2); |                                        ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:36:66: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 36 |\nstrncpy(&(&buffer.0)[strlen(&buffer.0)], &v0[v2], v1 - a0 - v2); | ~~ ^ ~~\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:37:27: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 37 |             *((char *)(v1 - a0 +\n&buffer.0)) = 0; |                        ~~ ^ ~~\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:37:41: error: expected ')'\n   37 |             *((char *)(v1 - a0 + &buffer.0)) = 0;\n      |                                         ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:37:23: note: to match this '('\n   37 |             *((char *)(v1 - a0 + &buffer.0)) = 0;\n      |                       ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:38:27: error: expected ')'\n   38 |             strcat(&buffer.0, a2);\n      |                           ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:38:19: note: to match this '('\n   38 |             strcat(&buffer.0, a2);\n      |                   ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:39:39: error: expected ')'\n   39 |             printf(\"STR:%s\\n\", &buffer.0);\n      |                                       ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:39:19: note: to match this '('\n   39 |             printf(\"STR:%s\\n\", &buffer.0);\n      |                   ^\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:40:63: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 40 |             v2 = (unsigned\nint)strlen(a1) + (unsigned int)(v1 - a0); | ~~ ^ ~~\n/tmp/tmpo80f7gfh/replace_str_name_conflict.c:44:27: error: expected ';' after return statement\n   44 |             return &buffer.0;\n      |                           ^\n      |                           ;\n10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cwkx_cgim/prc/cg_prc.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x18], Other Possible Types: unsigned long long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 1;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 0x1dcd6500 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy_cytexg/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |             ^\n/tmp/tmpy_cytexg/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |          ^\n/tmp/tmpy_cytexg/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |                          ^\n      |                          ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) == -1) {\n      return 4294967295;\n    } else if (strcmp(a0, *((long long *)(vocab +\n                                          (*((int *)(vocab_hash + (v0 << 2)))\n                                           << 4) +\n                                          8)))) {\n      v0 = (0 CONCAT v0 + 1) / m 0x1dcd6500 >> 32;\n    } else {\n      return *((int *)(vocab_hash + v0 * 4));\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcgwp4veh/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                     ^\n/tmp/tmpcgwp4veh/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                  ^\n/tmp/tmpcgwp4veh/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 60)\n    v0 = 60;\n  *((void **)(8 + (char *)vocab + 16 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(8 + (char *)vocab + 16 * vocab_size)), a0);\n  *((long long *)((char *)vocab + 16 * vocab_size)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 0x1dcd6500 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1tru7dm0/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmp1tru7dm0/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmp1tru7dm0/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmp1tru7dm0/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 30000000 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk6q_tfxm/GetWordHash_name_conflict.c:29:27: error: invalid operands to binary\nexpression ('int' and 'void *') 29 |         v0 = v1[a0] + 257 * v0; | ~~~ ^ ~~\n/tmp/tmpk6q_tfxm/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |             ^\n/tmp/tmpk6q_tfxm/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |          ^\n/tmp/tmpk6q_tfxm/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |                          ^\n      |                          ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) != -1) {\n      v2 = *((int *)(vocab_hash + v0 * 4));\n      if (!strcmp(a0, *((long long *)(((v2 << 2) + v2 << 3) + vocab + 16))))\n        return *((int *)(vocab_hash + v0 * 4));\n      v0 = (0 CONCAT v0 + 1) / m 30000000 >> 32;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_bv95q_t/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                     ^\n/tmp/tmp_bv95q_t/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                  ^\n/tmp/tmp_bv95q_t/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 100)\n    v0 = 100;\n  *((void **)(16 + (char *)vocab + 40 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(16 + 40 * vocab_size + (char *)vocab)), a0);\n  *((long long *)(40 * vocab_size + (char *)vocab)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 30000000 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_m4e3ton/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmp_m4e3ton/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmp_m4e3ton/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmp_m4e3ton/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int read_pid(char *pidfile) {\n    FILE *f;\n    int pid;\n    if (!(f = fopen(pidfile, \"r\")))\n        return 0;\n    fscanf(f, \"%d\", &pid);\n    fclose(f);\n    return pid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_fscanf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, ...);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_pid_name_conflict(char *a0) {\n  char v0;    // [bp-0x14]\n  FILE_t *v1; // [bp-0x10]\n\n  v1 = &fopen(a0, \"r\")->_flags;\n  if (!v1)\n    return 0;\n  __isoc99_fscanf(v1, \"%d\", (unsigned int)&v0);\n  fclose(v1);\n  return *((int *)&v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:141:16: error: redefinition of '_IO_marker'\n  141 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:147:16: error: redefinition of '_IO_codecvt'\n  147 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:151:16: error: redefinition of '_IO_wide_data'\n  151 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp8tqjgc87/read_pid_name_conflict.c:174:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 174 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"int get_usage(const pid_t pid, struct pstat *result) {\n    char pid_s[20];\n    snprintf(pid_s, sizeof (pid_s), \"%d\", pid);\n    char stat_filepath[30] = \"/proc/\";\n    strncat(stat_filepath, pid_s, sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    strncat(stat_filepath, \"/stat\", sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    FILE *fpstat = fopen(stat_filepath, \"r\");\n    if (fpstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        return -1;\n    }\n    FILE *fstat = fopen(\"/proc/stat\", \"r\");\n    if (fstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        fclose(fstat);\n        return -1;\n    }\n    memset(result, 0, sizeof(struct pstat));\n    long rss;\n    if (fscanf(fpstat, \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\", &result->utime_ticks, &result->stime_ticks, &result->cutime_ticks, &result->cstime_ticks, &result->vsize, &rss) == (-1)) {\n        fclose(fpstat);\n        return -1;\n    }\n    fclose(fpstat);\n    result->rss = rss * sysconf(_SC_PAGESIZE);\n    unsigned long cpu_time[10];\n    memset(cpu_time, 0, sizeof (cpu_time));\n    if (fscanf(fstat, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &cpu_time[0], &cpu_time[1], &cpu_time[2], &cpu_time[3], &cpu_time[4], &cpu_time[5], &cpu_time[6], &cpu_time[7], &cpu_time[8], &cpu_time[9]) == (-1)) {\n        fclose(fstat);\n        return -1;\n    }\n    fclose(fstat);\n    for (int i = 0; i < 10; i++)\n        result->cpu_total_time += cpu_time[i];\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nchar *(strncat)(char *, char *, unsigned long);\nvoid(perror)(char *);\nint(__isoc99_fscanf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, ...);\nlong(sysconf)(int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long get_usage_name_conflict(unsigned long a0, unsigned long long a1[7]) {\n  char v0;          // [bp-0xb8]\n  char v1;          // [bp-0xb0]\n  char v2;          // [bp-0xa8]\n  char v3;          // [bp-0xa0]\n  char v4;          // [bp-0x98]\n  char v5;          // [bp-0x90]\n  char v6;          // [bp-0x88]\n  char v7;          // [bp-0x80]\n  char v8;          // [bp-0x78]\n  char v9;          // [bp-0x70]\n  char v10;         // [bp-0x60]\n  char v11;         // [bp-0x58]\n  void *v12;        // [bp-0x50]\n  void *v13;        // [bp-0x4a]\n  void *v14;        // [bp-0x42]\n  char v15;         // [bp-0x38]\n  FILE_t *v16;      // [bp-0x20]\n  FILE_t *v17;      // [bp-0x18]\n  unsigned int v18; // [bp-0xc]\n  unsigned int v20; // ecx\n\n  v20 = a0;\n  snprintf(&v15, 20, \"%d\", (unsigned int)a0);\n  strncpy(&v11, \"/proc/\", 6);\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  strncat(&v11, &v15, 29 - strlen(&v11));\n  strncat(&v11, \"/stat\", 29 - strlen(&v11));\n  v17 = &fopen(&v11, \"r\")->_flags;\n  if (!v17) {\n    perror(\"FOPEN ERROR \");\n    return 4294967295;\n  }\n  v16 = &fopen(\"/proc/stat\", \"r\")->_flags;\n  if (!v16) {\n    perror(\"FOPEN ERROR \");\n    fclose(v16);\n    return 4294967295;\n  }\n  memset(a1, 0, 56);\n  if (__isoc99_fscanf(v17,\n                      \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \"\n                      \"%lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\",\n                      (unsigned int)a1,\n                      (unsigned int)(unsigned long long[7]) & a1[2],\n                      (unsigned int)(unsigned long long[7]) & a1[1],\n                      (unsigned int)(unsigned long long[7]) & a1[3],\n                      (unsigned int)(unsigned long long[7]) & a1[4],\n                      (unsigned int)&v10) == -1) {\n    fclose(v17);\n    return 4294967295;\n  }\n  fclose(v17);\n  a1[5] = *((long long *)&v10) * sysconf(30);\n  memset(&v0, 0, 80);\n  if (__isoc99_fscanf(v16, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\",\n                      (unsigned int)&v0, (unsigned int)&v1, (unsigned int)&v2,\n                      (unsigned int)&v3, (unsigned int)&v4, (unsigned int)&v5,\n                      (unsigned int)&v6, (unsigned int)&v7, (unsigned int)&v8,\n                      (unsigned int)&v9) == -1) {\n    fclose(v16);\n    return 4294967295;\n  }\n  fclose(v16);\n  for (v18 = 0; v18 <= 9; v18 += 1) {\n    a1[6] = a1[6] + *((long long *)&(&v0)[8 * v18]);\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:33:16: error: nested redefinition of '_IO_marker'\n   33 |         struct _IO_marker {\n      |                ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:76:13: error: declaration of anonymous union must\nbe a definition 76 |             union <anon> { |             ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:79:22: error: type name requires a specifier or\nqualifier 79 |             } __value; |                      ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:83:13: error: declaration of anonymous union must\nbe a definition 83 |             union <anon> { |             ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:86:22: error: type name requires a specifier or\nqualifier 86 |             } __value; |                      ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:145:16: error: redefinition of '_IO_marker'\n  145 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:151:16: error: redefinition of '_IO_codecvt'\n  151 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:54:12: note: previous definition is here\n   54 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:155:16: error: redefinition of '_IO_wide_data'\n  155 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:62:12: note: previous definition is here\n   62 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:178:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 178 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:225:160: error: used type 'unsigned long long[7]'\nwhere arithmetic or pointer type is required 225 |     if (__isoc99_fscanf(v17,\n\"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d\n%*d %*u %lu %ld\", (unsigned int)a1, (unsigned int)(unsigned long long\n[7])&a1[2], (unsigned int)(unsigned long long [7])&a1[1], (unsigned\nint)(unsigned long long [7])&a1[3], (unsigned int)(unsigned long long\n[7])&a1[4], (unsigned int)&v10) == -1) | ^                       ~~~~~~\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:225:206: error: used type 'unsigned long long[7]'\nwhere arithmetic or pointer type is required 225 |     if (__isoc99_fscanf(v17,\n\"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d\n%*d %*u %lu %ld\", (unsigned int)a1, (unsigned int)(unsigned long long\n[7])&a1[2], (unsigned int)(unsigned long long [7])&a1[1], (unsigned\nint)(unsigned long long [7])&a1[3], (unsigned int)(unsigned long long\n[7])&a1[4], (unsigned int)&v10) == -1) | ^                       ~~~~~~\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:225:252: error: used type 'unsigned long long[7]'\nwhere arithmetic or pointer type is required 225 |     if (__isoc99_fscanf(v17,\n\"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d\n%*d %*u %lu %ld\", (unsigned int)a1, (unsigned int)(unsigned long long\n[7])&a1[2], (unsigned int)(unsigned long long [7])&a1[1], (unsigned\nint)(unsigned long long [7])&a1[3], (unsigned int)(unsigned long long\n[7])&a1[4], (unsigned int)&v10) == -1) | ^                       ~~~~~~\n/tmp/tmp4uo1rfa0/get_usage_name_conflict.c:225:298: error: used type 'unsigned long long[7]'\nwhere arithmetic or pointer type is required 225 |     if (__isoc99_fscanf(v17,\n\"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d\n%*d %*u %lu %ld\", (unsigned int)a1, (unsigned int)(unsigned long long\n[7])&a1[2], (unsigned int)(unsigned long long [7])&a1[1], (unsigned\nint)(unsigned long long [7])&a1[3], (unsigned int)(unsigned long long\n[7])&a1[4], (unsigned int)&v10) == -1) | ^                       ~~~~~~ 15\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"pid_t launch(int argc, char **argv) {\n    int pid = fork();\n    if (pid != 0) {\n        if (pid < 0) {\n            die(\"fork\");\n        }\n        return pid;\n    }\n    sigset_t set;\n    sigfillset(&set);\n    sigprocmask(1, &set, 0);\n    setsid();\n    setpgid(0, 0);\n    char **argvn = __builtin_alloca(sizeof (argv[0]) * (argc + 1));\n    memcpy(argvn, argv, sizeof (argv[0]) * argc);\n    argvn[argc] = ((void *)0);\n    if (putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\")) {\n        die(\"putenv\");\n    }\n    execvpe(argvn[0], argvn, (char **)default_envp);\n    die2(\"execvpe\", argvn[0]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(sigfillset)(int *);\nint(sigprocmask)(int, int *, int *);\nlong long(die)();\nint(setsid)();\nint(setpgid)(int, int);\nint(putenv)(char *);\nint(execvpe)(char *, char *[0], char *[0]);\nlong long(die2)();\n\nextern char *default_envp[0];\nextern char g_402a42;\n\nlong long launch_name_conflict(unsigned long a0, void *a1) {\n  char v0;          // [bp-0xb0]\n  char v1;          // [bp-0x99]\n  unsigned int v2;  // [bp-0x98]\n  char **v3;        // [bp-0x18]\n  unsigned int v4;  // [bp-0xc]\n  unsigned long v6; // rax\n\n  v4 = fork();\n  if (!v4) {\n    sigfillset(&v2);\n    sigprocmask(1, &v2, NULL);\n    setsid();\n    setpgid(0, 0);\n    v6 = (0 CONCAT 15 + ((unsigned int)a0 + 1) * 8 + 8) / m 16 * 16;\n    v3 = (&(&v1)[-1 * v6] >> 4) * 16;\n    *((char **)&(&v0)[-1 * v6]) = &g_402a42;\n    memcpy(v3, a1, (unsigned int)a0 * 8);\n    v3[(unsigned int)a0] = 0;\n    if (!putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\")) {\n      execvpe(*(v3), v3, default_envp);\n      die2(); /* do not return */\n    }\n    die(); /* do not return */\n  } else if (v4 < 0) {\n    die(); /* do not return */\n  } else {\n    return v4;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm1sn1gj7/launch_name_conflict.c:46:17: error: expected ')'\n   46 |         v6 = (0 CONCAT 15 + ((unsigned int)a0 + 1) * 8 + 8) /m 16 * 16;\n      |                 ^\n/tmp/tmpm1sn1gj7/launch_name_conflict.c:46:14: note: to match this '('\n   46 |         v6 = (0 CONCAT 15 + ((unsigned int)a0 + 1) * 8 + 8) /m 16 * 16;\n      |              ^\n/tmp/tmpm1sn1gj7/launch_name_conflict.c:46:63: error: expected ';' after expression\n   46 |         v6 = (0 CONCAT 15 + ((unsigned int)a0 + 1) * 8 + 8) /m 16 * 16;\n      |                                                               ^\n      |                                                               ;\n/tmp/tmpm1sn1gj7/launch_name_conflict.c:47:31: error: invalid operands to binary expression\n('char *' and 'int') 47 |         v3 = (&(&v1)[-1 * v6] >> 4) * 16; |\n~~~~~~~~~~~~~~~ ^  ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":0,"function":"int reap_until(pid_t until_pid) {\n    for (;;) {\n        int status;\n        pid_t pid = wait(&status);\n        if (pid < 0) {\n            die(\"wait\");\n        }\n        if (pid == until_pid) {\n            if ((((status) & 127) == 0)) {\n                if ((((status) & 65280) >> 8) != 0) {\n                    fputs(\"child exited with error\\n\", stderr);\n                }\n                return (((status) & 65280) >> 8);\n            }\n            fputs(\"child exited by signal\\n\", stderr);\n            return 128 + ((status) & 127);\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(wait)(int *);\nlong long(die)();\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long reap_until_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0x10]\n  unsigned int v1;  // [bp-0xc]\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  do {\n    v1 = wait(&v0);\n    if (v1 < 0)\n      die(); /* do not return */\n  } while (v1 != (unsigned int)a0);\n  if (((char)v0 & 127)) {\n    fwrite(\"child exited by signal\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    v3 = (v0 & 127) - -128;\n    return v3;\n  }\n  if ((unsigned int)(v0 >> 8))\n    fwrite(\"child exited with error\\n\", 1, 24, stderr @GLIBC_2.2.5);\n  v3 = v0 >> 8;\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmg03d9g3/reap_until_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpmg03d9g3/reap_until_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpmg03d9g3/reap_until_name_conflict.c:35:57: error: expected ')'\n   35 |         fwrite(\"child exited by signal\\n\", 1, 23, stderr@GLIBC_2.2.5);\n      |                                                         ^\n/tmp/tmpmg03d9g3/reap_until_name_conflict.c:35:15: note: to match this '('\n   35 |         fwrite(\"child exited by signal\\n\", 1, 23, stderr@GLIBC_2.2.5);\n      |               ^\n/tmp/tmpmg03d9g3/reap_until_name_conflict.c:40:58: error: expected ')'\n   40 |         fwrite(\"child exited with error\\n\", 1, 24, stderr@GLIBC_2.2.5);\n      |                                                          ^\n/tmp/tmpmg03d9g3/reap_until_name_conflict.c:40:15: note: to match this '('\n   40 |         fwrite(\"child exited with error\\n\", 1, 24, stderr@GLIBC_2.2.5);\n      |               ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":0,"function":"static int openvsock(unsigned int cid, unsigned int port) {\n    int s = socket(40, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_VSOCK\");\n        return -1;\n    }\n    struct sockaddr_vm addr = {0};\n    addr.svm_family = 40;\n    addr.svm_port = port;\n    addr.svm_cid = cid;\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nvoid(perror)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nchar *(strerror)(int);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long openvsock_name_conflict(unsigned long a0, unsigned long a1) {\n  sockaddr v0;           // [bp-0x28], Other Possible Types: unsigned short\n  unsigned int v1;       // [bp-0x24]\n  unsigned int v2;       // [bp-0x20]\n  unsigned int v3;       // [bp-0xc]\n  unsigned long long v7; // rax\n\n  v3 = socket(40, 1, 0);\n  if (v3 < 0) {\n    perror(\"socket: AF_VSOCK\");\n    return 4294967295;\n  }\n  *((int128_t *)&v0.sin_family) = 0;\n  v0 = 40;\n  v1 = a1;\n  v2 = a0;\n  if (connect(v3, &v0, 16) >= 0)\n    return v3;\n  (unsigned int)v7 = strerror(*(__errno_location()));\n  fprintf(stderr @GLIBC_2.2.5, \"connect: port %u: %s\", (unsigned int)a1,\n          (unsigned int)v7);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgd1_sh77/openvsock_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpgd1_sh77/openvsock_name_conflict.c:30:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 30 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpgd1_sh77/openvsock_name_conflict.c:30:22: error: expected ';' after top level\ndeclarator 30 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpgd1_sh77/openvsock_name_conflict.c:46:18: error: expected expression\n   46 |     *((int128_t *)&v0.sin_family) = 0;\n      |                  ^\n/tmp/tmpgd1_sh77/openvsock_name_conflict.c:47:8: error: assigning to 'sockaddr' (aka 'struct\nsockaddr') from incompatible type 'int' 47 |     v0 = 40; |        ^ ~~\n/tmp/tmpgd1_sh77/openvsock_name_conflict.c:52:33: error: indirection requires pointer operand\n('int' invalid) 52 |     (unsigned int)v7 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpgd1_sh77/openvsock_name_conflict.c:53:19: error: expected ')' 53\n|     fprintf(stderr@GLIBC_2.2.5, \"connect: port %u: %s\", (unsigned int)a1,\n(unsigned int)v7); |                   ^ /tmp/tmpgd1_sh77/openvsock_name_conflict.c:53:12:\nnote: to match this '(' 53 |     fprintf(stderr@GLIBC_2.2.5, \"connect: port %u:\n%s\", (unsigned int)a1, (unsigned int)v7); |            ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":0,"function":"static int opentcp(unsigned short port) {\n    int s = socket(2, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_INET\");\n        return -1;\n    }\n    struct sockaddr_in addr = {0};\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = htonl(((in_addr_t)2130706433));\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\\n\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nvoid(perror)(char *);\nunsigned short(htons)(unsigned short);\nunsigned int(htonl)(unsigned int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nchar *(strerror)(int);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long opentcp_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x28], Other Possible Types: unsigned short\n  unsigned short v1;     // [bp-0x26]\n  unsigned int v2;       // [bp-0x24]\n  void *v3;              // [bp-0x20]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v8; // rax\n\n  v4 = socket(2, 1, 0);\n  if (v4 < 0) {\n    perror(\"socket: AF_INET\");\n    return 4294967295;\n  }\n  v0 = 0;\n  v3 = 0;\n  v0 = 2;\n  v1 = htons(a0);\n  v2 = htonl(2130706433);\n  if (connect(v4, &v0, 16) >= 0)\n    return v4;\n  (unsigned int)v8 = strerror(*(__errno_location()));\n  fprintf(stderr @GLIBC_2.2.5, \"connect: port %u: %s\\n\", (unsigned short)a0,\n          (unsigned int)v8);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp96t7qyb2/opentcp_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp96t7qyb2/opentcp_name_conflict.c:26:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 26 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp96t7qyb2/opentcp_name_conflict.c:26:22: error: expected ';' after top level declarator\n   26 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp96t7qyb2/opentcp_name_conflict.c:50:33: error: indirection requires pointer operand\n('int' invalid) 50 |     (unsigned int)v8 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp96t7qyb2/opentcp_name_conflict.c:51:19: error: expected ')' 51 |\nfprintf(stderr@GLIBC_2.2.5, \"connect: port %u: %s\\n\", (unsigned short)a0,\n(unsigned int)v8); |                   ^ /tmp/tmp96t7qyb2/opentcp_name_conflict.c:51:12: note:\nto match this '(' 51 |     fprintf(stderr@GLIBC_2.2.5, \"connect: port %u: %s\\n\",\n(unsigned short)a0, (unsigned int)v8); |            ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":1,"function":"int fib_rec(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        result = fib_rec(n - 1) + fib_rec(n - 2);\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fib_rec_name_conflict)(unsigned long);\n\nlong long fib_rec_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0x1c]\n  unsigned long v1; // [bp-0x10]\n  unsigned long v3; // rbx\n\n  v1 = v3;\n  if ((unsigned int)a0 && (unsigned int)a0 != 1) {\n    v0 =\n        (int)fib_rec_name_conflict((unsigned int)a0 - 2) + (int)fib_rec_name_conflict((unsigned int)a0 - 1);\n    return v0;\n  }\n  v0 = 1;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":1,"function":"int fib_it(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        int a = 1, b = 1, c = 1;\n        for (int i = 1; i < n; i++) {\n            a = b;\n            b = c;\n            c = a + b;\n        }\n        result = c;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fib_it_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0x18]\n  unsigned int v2; // [bp-0x14]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  if ((unsigned int)a0 && (unsigned int)a0 != 1) {\n    v0 = 1;\n    v3 = 1;\n    v2 = 1;\n    for (v1 = 1; v1 < (unsigned int)a0; v1 += 1) {\n      v0 = v3;\n      v3 = v2;\n      v2 = v3 + v0;\n    }\n    v4 = v2;\n    return v4;\n  }\n  v4 = 1;\n  return v4;\n}\n","pass":1,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x18], Other Possible Types: unsigned long long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 1;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 0x1dcd6500 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyf8ol2rq/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |             ^\n/tmp/tmpyf8ol2rq/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |          ^\n/tmp/tmpyf8ol2rq/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |                          ^\n      |                          ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) == -1) {\n      return 4294967295;\n    } else if (strcmp(a0, *((long long *)(vocab +\n                                          (*((int *)(vocab_hash + (v0 << 2)))\n                                           << 4) +\n                                          8)))) {\n      v0 = (0 CONCAT v0 + 1) / m 0x1dcd6500 >> 32;\n    } else {\n      return *((int *)(vocab_hash + v0 * 4));\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_1tb3hms/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                     ^\n/tmp/tmp_1tb3hms/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                  ^\n/tmp/tmp_1tb3hms/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 60)\n    v0 = 60;\n  *((void **)(8 + (char *)vocab + 16 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(8 + (char *)vocab + 16 * vocab_size)), a0);\n  *((long long *)((char *)vocab + 16 * vocab_size)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 0x1dcd6500 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvxwwivuf/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpvxwwivuf/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpvxwwivuf/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmpvxwwivuf/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 30000000 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp79ekbfc7/GetWordHash_name_conflict.c:29:27: error: invalid operands to binary\nexpression ('int' and 'void *') 29 |         v0 = v1[a0] + 257 * v0; | ~~~ ^ ~~\n/tmp/tmp79ekbfc7/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |             ^\n/tmp/tmp79ekbfc7/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |          ^\n/tmp/tmp79ekbfc7/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |                          ^\n      |                          ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) != -1) {\n      v2 = *((int *)(vocab_hash + v0 * 4));\n      if (!strcmp(a0, *((long long *)(((v2 << 2) + v2 << 3) + vocab + 16))))\n        return *((int *)(vocab_hash + v0 * 4));\n      v0 = (0 CONCAT v0 + 1) / m 30000000 >> 32;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn2hx_mrr/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                     ^\n/tmp/tmpn2hx_mrr/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                  ^\n/tmp/tmpn2hx_mrr/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 100)\n    v0 = 100;\n  *((void **)(16 + (char *)vocab + 40 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(16 + 40 * vocab_size + (char *)vocab)), a0);\n  *((long long *)(40 * vocab_size + (char *)vocab)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 30000000 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj3fyhqrl/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpj3fyhqrl/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpj3fyhqrl/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmpj3fyhqrl/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"static char *xstrdup(const char *s) {\n    char *p = xmalloc(strlen(s) + 1);\n    strcpy(p, s);\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\n\nlong long xstrdup_name_conflict(char *a0) {\n  char *v0; // [bp-0x10]\n\n  v0 = xmalloc(strlen(a0) + 1);\n  strcpy(v0, a0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int writen(int fd, const char *buffer, size_t length) {\n    while (length)\n        {\n            int nwritten = write(fd, buffer, length);\n            if (nwritten < 0) {\n                if ((*__errno_location()) == 4)\n                    continue;\n                return -1;\n            }\n            length -= nwritten;\n            buffer += nwritten;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\n\nlong long writen_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0;      // [bp-0x30], Other Possible Types: unsigned int\n  void *v1;              // [bp-0x28], Other Possible Types: unsigned long\n  unsigned int v2;       // [bp-0xc]\n  char v3;               // [bp-0x8]\n  unsigned long long v5; // rbp\n\n  v5 = &v3;\n  v1 = a1;\n  *((unsigned long *)&v0) = a2;\n  while (true) {\n    if (*((long long *)&v0)) {\n      v2 = write(a0, v1, *((long long *)&v0));\n      if (v2 >= 0) {\n        v0 = *((long long *)&v0) - v2;\n        v1 += v2;\n      } else if (*(__errno_location()) != 4) {\n        return 4294967295;\n      }\n    } else {\n      return 0;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8iu2qxv9/writen_name_conflict.c:39:22: error: indirection requires pointer operand\n('int' invalid) 39 |             else if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *read_assuan(int fd) {\n    static char pending[2048];\n    static size_t pending_len;\n    size_t nleft = sizeof recv_line;\n    char *buf = recv_line;\n    char *p;\n    while (nleft > 0)\n        {\n            int n;\n            if (pending_len) {\n                if (pending_len >= nleft)\n                    (die)(\"%s: received line too large\", __func__);\n                memcpy(buf, pending, pending_len);\n                n = pending_len;\n                pending_len = 0;\n            } else {\n                do {\n                    n = read(fd, buf, nleft);\n                } while (n < 0 && (*__errno_location()) == 4);\n            }\n            if (opt_verbose && n >= 0) {\n                int i;\n                printf(\"%s: read \\\"\", __func__);\n                for (i = 0; i < n; i++)\n                    putc(buf[i], stdout);\n                printf(\"\\\"\\n\");\n            }\n            if (n < 0)\n                (die)(\"%s: reading fd %d failed: %s\", __func__, (fd), (strerror((*__errno_location()))));\n            else if (!n)\n                (die)(\"%s: received incomplete line on fd %d\", __func__, (fd));\n            p = buf;\n            nleft -= n;\n            buf += n;\n            for (; n && *p != '\\n'; n-- , p++)\n                ;\n            if (n) {\n                if (n > 1) {\n                    n--;\n                    memcpy(pending, p + 1, n);\n                    pending_len = n;\n                }\n                *p = '\\x00';\n                break;\n            }\n        }\n    if (!nleft)\n        (die)(\"%s: received line too large\", __func__);\n    p = recv_line;\n    if (p[0] == 'O' && p[1] == 'K' && (p[2] == ' ' || !p[2])) {\n        recv_type = LINE_OK;\n        p += 3;\n    } else if (p[0] == 'E' && p[1] == 'R' && p[2] == 'R' && (p[3] == ' ' || !p[3])) {\n        recv_type = LINE_ERR;\n        p += 4;\n    } else if (p[0] == 'S' && (p[1] == ' ' || !p[1])) {\n        recv_type = LINE_STAT;\n        p += 2;\n    } else if (p[0] == 'D' && p[1] == ' ') {\n        recv_type = LINE_DATA;\n        p += 2;\n    } else if (p[0] == 'E' && p[1] == 'N' && p[2] == 'D' && !p[3]) {\n        recv_type = LINE_END;\n        p += 3;\n    } else\n        (die)(\"%s: invalid line type (%.5s)\", __func__, (p));\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(die)(...);\nlong(read)(int, void *, unsigned long);\nchar *(strerror)(int);\nint(putc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char __func__ .13;\nextern unsigned int opt_verbose;\nextern void pending.12;\nextern void *pending_len.14;\nextern char recv_line[4];\nextern unsigned int recv_type;\nextern FILE_t *stdout @GLIBC_2.2.5;\n\nlong long read_assuan_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0x28]\n  unsigned int v1;  // [bp-0x24]\n  char v2[4];       // [bp-0x20], Other Possible Types: unsigned long\n  char v3[4];       // [bp-0x18], Other Possible Types: unsigned long\n  unsigned long v4; // [bp-0x10], Other Possible Types: unsigned long long\n\n  v4 = 0x800;\n  *((char **)&v3) = &recv_line[0];\n  while (v4) {\n    if (!pending_len.14) {\n      do {\n        v1 = read(a0, v3, v4);\n      } while (v1 < 0 && *(__errno_location()) == 4);\n    } else {\n      if (pending_len.14 >= v4)\n        die(); /* do not return */\n      memcpy(v3, &pending.12, pending_len.14);\n      v1 = (unsigned int)pending_len.14;\n      pending_len.14 = 0;\n    }\n    if (opt_verbose && v1 >= 0) {\n      printf(\"%s: read \\\"\", &__func__ .13);\n      for (v0 = 0; v0 < v1; v0 += 1) {\n        putc(v3[v0], stdout @GLIBC_2.2.5);\n      }\n      puts(\"\\\"\");\n    }\n    if (v1 < 0) {\n      strerror(*(__errno_location()));\n      die(); /* do not return */\n    }\n    if (!v1)\n      die(); /* do not return */\n    *((unsigned long *)&v2) = v3;\n    v4 -= v1;\n    for (v3 += v1; v1 && *((char *)v2) != 10; v2 += 1) {\n      v1 -= 1;\n    }\n    if (v1) {\n      if (v1 > 1) {\n        v1 -= 1;\n        memcpy(&pending.12, v2 + 1, v1);\n        pending_len.14 = v1;\n      }\n      *((char *)v2) = 0;\n      break;\n    }\n  }\n  if (!v4)\n    die(); /* do not return */\n  *((char **)&v2) = &recv_line[0];\n  if (v2[0] == 79 && v2[1] == 75 && (!(v2[2] != 32) || !(v2[2]))) {\n    recv_type = 0;\n    *(&v2) = &v2[3];\n    return v2;\n  }\n  if (v2[0] == 69 && v2[1] == 82 && v2[2] == 82 &&\n      (!(v2[3] != 32) || !(v2[3]))) {\n    recv_type = 1;\n    v2 += 1;\n    return v2;\n  }\n  if (v2[0] == 83 && (!(v2[1] != 32) || !(v2[1]))) {\n    recv_type = 2;\n    v2 = &v2[2];\n    return v2;\n  }\n  if (v2[0] == 68 && v2[1] == 32) {\n    recv_type = 3;\n    v2 = &v2[2];\n    return v2;\n  }\n  if (!(v2[0] == 69 && v2[1] == 78 && v2[2] == 68 && !v2[3]))\n    die(); /* do not return */\n  recv_type = 4;\n  *(&v2) = &v2[3];\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:16:17: error: ISO C requires a named parameter\nbefore '...' 16 | long long (die)(...); |                 ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:33:16: error: nested redefinition of '_IO_marker'\n   33 |         struct _IO_marker {\n      |                ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:76:13: error: declaration of anonymous union must\nbe a definition 76 |             union <anon> { |             ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:79:22: error: type name requires a specifier or\nqualifier 79 |             } __value; |                      ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:83:13: error: declaration of anonymous union must\nbe a definition 83 |             union <anon> { |             ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:86:22: error: type name requires a specifier or\nqualifier 86 |             } __value; |                      ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:19:6: error: conflicting types for 'putc'\n   19 | int (putc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:550:12: note: previous declaration is here\n  550 | extern int putc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:109:13: error: expected identifier or '('\n  109 | extern char __func__.13;\n      |             ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:111:20: error: expected ';' after top level\ndeclarator 111 | extern void pending.12; |                    ^ | ;\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:112:25: error: expected ';' after top level\ndeclarator 112 | extern void* pending_len.14; |                         ^ | ;\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:115:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 115 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:115:22: error: expected ';' after top level\ndeclarator 115 | extern FILE_t *stdout@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:129:25: error: expected ')'\n  129 |         if (!pending_len.14)\n      |                         ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:129:12: note: to match this '('\n  129 |         if (!pending_len.14)\n      |            ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:134:32: error: indirection requires pointer\noperand ('int' invalid) 134 |             } while (v1 < 0 &&\n*(__errno_location()) == 4); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:138:28: error: expected ')'\n  138 |             if (pending_len.14 >= v4)\n      |                            ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:138:16: note: to match this '('\n  138 |             if (pending_len.14 >= v4)\n      |                ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:140:32: error: expected ')'\n  140 |             memcpy(v3, &pending.12, pending_len.14);\n      |                                ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:140:19: note: to match this '('\n  140 |             memcpy(v3, &pending.12, pending_len.14);\n      |                   ^\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:141:43: error: expected ';' after expression\n  141 |             v1 = (unsigned int)pending_len.14;\n      |                                           ^\n      |                                           ;\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:142:24: error: expected ';' after expression\n  142 |             pending_len.14 = 0;\n      |                        ^\n      |                        ;\n/tmp/tmp5i63r820/read_assuan_name_conflict.c:142:28: error: expression is not assignable\n  142 |             pending_len.14 = 0;\n      |                        ~~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static const char *get_var(const char *name) {\n    VARIABLE var;\n    for (var = variable_list; var && strcmp(var->name, name); var = var->next)\n        ;\n    if (!var)\n        return ((void *)0);\n    if (var->type == VARTYPE_COUNTER && var->value) {\n        char *p = var->value + strlen(var->value) + 1;\n        sprintf(p, \"%u\", var->count);\n        return p;\n    } else\n        return var->value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  unsigned int field_8;\n  unsigned int field_c;\n  char *field_10;\n} struct_0;\n\nextern struct_1 *variable_list;\n\nlong long get_var_name_conflict(char *a0) {\n  char *v0;         // [bp-0x28]\n  struct_0 *v1;     // [bp-0x20], Other Possible Types: unsigned long\n  unsigned long v2; // [bp-0x10]\n  unsigned long v4; // rbx\n\n  v2 = v4;\n  for (v1 = &variable_list->field_0; v1 && strcmp(v1 + 24, a0);\n       v1 = *((long long *)v1))\n    ;\n  if (!v1)\n    return 0;\n  if (!(*((int *)(v1 + 8)) == 2 && *((long long *)(v1 + 16))))\n    return *((long long *)(v1 + 16));\n  v0 = strlen(*((long long *)(v1 + 16))) + 1 + *((long long *)(v1 + 16));\n  sprintf(v0, \"%u\", *((int *)(v1 + 12)));\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp101vztal/get_var_name_conflict.c:24:8: error: unknown type name 'struct_1'; did you\nmean 'struct_0'? 24 | extern struct_1 *variable_list; |        ^~~~~~~~ |\nstruct_0 /tmp/tmp101vztal/get_var_name_conflict.c:22:3: note: 'struct_0' declared here 22 | }\nstruct_0; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *expand_line(char *buffer) {\n    char *line = buffer;\n    char *p, *pend;\n    const char *value;\n    size_t valuelen, n;\n    char *result = ((void *)0);\n    while (*line)\n        {\n            p = strchr(line, '$');\n            if (!p)\n                return result;\n            if (p[1] == '$') {\n                memmove(p, p + 1, strlen(p + 1) + 1);\n                line = p + 1;\n                continue;\n            }\n            for (pend = p + 1; *pend && !(*(pend) == ' ' || *(pend) == '\\t') && *pend != '$' && *pend != '/'; pend++)\n                ;\n            if (*pend) {\n                int save = *pend;\n                *pend = 0;\n                value = get_var(p + 1);\n                *pend = save;\n            } else\n                value = get_var(p + 1);\n            if (!value)\n                value = \"\";\n            valuelen = strlen(value);\n            if (valuelen <= pend - p) {\n                memcpy(p, value, valuelen);\n                p += valuelen;\n                n = pend - p;\n                if (n)\n                    memmove(p, p + n, strlen(p + n) + 1);\n                line = p;\n            } else {\n                char *src = result ? result : buffer;\n                char *dst;\n                dst = xmalloc(strlen(src) + valuelen + 1);\n                n = p - src;\n                memcpy(dst, src, n);\n                memcpy(dst + n, value, valuelen);\n                n += valuelen;\n                strcpy(dst + n, pend);\n                line = dst + n;\n                free(result);\n                result = dst;\n            }\n        }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(get_var)(long long);\nlong long(xmalloc)(long long);\n\nextern char g_4051ba;\n\nlong long expand_line_name_conflict(char a0[2]) {\n  unsigned long v0; // [bp-0x58], Other Possible Types: unsigned int\n  void *v1;         // [bp-0x50]\n  char *v2;         // [bp-0x48]\n  unsigned int v3;  // [bp-0x40]\n  unsigned int v4;  // [bp-0x34]\n  char v5[2];       // [bp-0x30]\n  void *v6;         // [bp-0x28], Other Possible Types: unsigned long\n  void *v7;         // [bp-0x20], Other Possible Types: unsigned long\n  char v8[2];       // [bp-0x18], Other Possible Types: unsigned long\n  char v9[2];       // [bp-0x10], Other Possible Types: unsigned long\n\n  *(&v9) = a0;\n  v6 = 0;\n  while (!*((char *)v9)) {\n  LABEL_403506:\n    return v6;\n  }\n  *((char **)&v5) = strchr(v9, 36);\n  if (!v5)\n    return v6;\n  if (v5[1] == 36) {\n    memmove(v5, &v5[1], strlen(&v5[1]) + 1);\n    v9 = &v5[1];\n    goto LABEL_403506;\n  } else {\n    for (*(&v8) = &v5[1];\n         *((char *)v8) && *((char *)v8) != 32 && *((char *)v8) != 9 &&\n         *((char *)v8) != 36 && *((char *)v8) != 47;\n         v8 += 1)\n      ;\n    if (!*((char *)v8)) {\n      v7 = get_var(&v5[1]);\n    } else {\n      v4 = *((char *)v8);\n      *((char *)v8) = 0;\n      v7 = get_var(&v5[1]);\n      *((char *)v8) = v4;\n    }\n    if (!v7)\n      v7 = &g_4051ba;\n    *((unsigned long *)&v3) = strlen(v7);\n    if (v8 - (char *)v5 >= *((long long *)&v3)) {\n      memcpy(v5, v7, *((long long *)&v3));\n      *(&v5) = &v5[*((long long *)&v3)];\n      v0 = v8 - (char *)v5;\n      if (v0)\n        memmove(v5, &v5[v0], strlen(&v5[v0]) + 1);\n      v9 = v5;\n      goto LABEL_403506;\n    } else {\n      *((int *)&v2) = (!v6 ? v6 : a0);\n      v1 = xmalloc(strlen(v2) + *((long long *)&v3) + 1);\n      *((unsigned long *)&v0) = v5 - v2;\n      memcpy(v1, v2, *((long long *)&v0));\n      memcpy(v1 + *((long long *)&v0), v7, *((long long *)&v3));\n      v0 = *((long long *)&v0) + *((long long *)&v3);\n      strcpy(v1 + v0, v8);\n      v9 = v0 + v1;\n      free(v6);\n      v6 = v1;\n      goto LABEL_403506;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnxsc6lhw/expand_line_name_conflict.c:35:12: error: array type 'char[2]' is not\nassignable 35 |     *(&v9) = a0; |     ~~~~~~ ^\n/tmp/tmpnxsc6lhw/expand_line_name_conflict.c:48:12: error: array type 'char[2]' is not\nassignable 48 |         v9 = &v5[1]; |         ~~ ^\n/tmp/tmpnxsc6lhw/expand_line_name_conflict.c:53:21: error: array type 'char[2]' is not\nassignable 53 |         for (*(&v8) = &v5[1]; *((char *)v8) && *((char *)v8) !=\n32 && *((char *)v8) != 9 && *((char *)v8) != 36 && *((char *)v8) != 47; v8 +=\n1); |              ~~~~~~ ^ /tmp/tmpnxsc6lhw/expand_line_name_conflict.c:53:140: error:\ninvalid operands to binary expression ('char[2]' and 'int') 53 |         for\n(*(&v8) = &v5[1]; *((char *)v8) && *((char *)v8) != 32 && *((char *)v8) != 9 &&\n*((char *)v8) != 36 && *((char *)v8) != 47; v8 += 1); | ~~ ^  ~\n/tmp/tmpnxsc6lhw/expand_line_name_conflict.c:71:20: error: array type 'char[2]' is not\nassignable 71 |             *(&v5) = &v5[*((long long *)&v3)]; | ~~~~~~ ^\n/tmp/tmpnxsc6lhw/expand_line_name_conflict.c:75:16: error: array type 'char[2]' is not\nassignable 75 |             v9 = v5; |             ~~ ^\n/tmp/tmpnxsc6lhw/expand_line_name_conflict.c:87:16: error: array type 'char[2]' is not\nassignable 87 |             v9 = v0 + v1; |             ~~ ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int eval_boolean(const char *cond) {\n    int true = 1;\n    for (; *cond == '!'; cond++)\n        true = !true;\n    if (!*cond || (*cond == '0' && !cond[1]))\n        return !true;\n    return true;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long eval_boolean_name_conflict(char a0[2]) {\n  char v0[2];      // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n\n  *(&v0) = a0;\n  for (v1 = 1; v0[0] == 33; v0 = &v0[1]) {\n    v1 = !v1;\n  }\n  if (*((char *)v0) && (!(*((char *)v0) == 48) || !(!*((char *)(v0 + 1)))))\n    return v1;\n  return !v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpulphr_8v/eval_boolean_name_conflict.c:22:12: error: array type 'char[2]' is not\nassignable 22 |     *(&v0) = a0; |     ~~~~~~ ^\n/tmp/tmpulphr_8v/eval_boolean_name_conflict.c:23:34: error: array type 'char[2]' is not\nassignable 23 |     for (v1 = 1; v0[0] == 33; v0 = &v0[1]) | ~~ ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int interpreter(char *line) {\n    static struct {\n        const char *name;\n        void (*fnc)(const char *, char *);\n    } cmdtbl[] = {{\"let\", cmd_let}, {\"echo\", cmd_echo}, {\"send\", cmd_send}, {\"expect-ok\", cmd_expect_ok}, {\"expect-err\", cmd_expect_err}, {\"count-status\", cmd_count_status}, {\"openfile\", cmd_openfile}, {\"createfile\", cmd_createfile}, {\"pipeserver\", cmd_pipeserver}, {\"quit\", ((void *)0)}, {\"quit-if\", cmd_quit_if}, {\"fail-if\", cmd_fail_if}, {\"cmpfiles\", cmd_cmpfiles}, {\"getenv\", cmd_getenv}, {((void *)0)}};\n    char *p, *save_p;\n    int i, save_c;\n    char *stmt = ((void *)0);\n    char *assign_to = ((void *)0);\n    char *must_free = ((void *)0);\n    for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n        ;\n    if (!*line || *line == '#')\n        return 0;\n    p = expand_line(line);\n    if (p) {\n        must_free = p;\n        line = p;\n        for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n            ;\n        if (!*line || *line == '#') {\n            free(must_free);\n            return 0;\n        }\n    }\n    for (p = line; *p && !(*(p) == ' ' || *(p) == '\\t') && *p != '='; p++)\n        ;\n    if (*p == '=') {\n        *p = 0;\n        assign_to = line;\n    } else if (*p) {\n        for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p == '=')\n            assign_to = line;\n    }\n    if (!*line)\n        (die)(\"%s: syntax error\", __func__);\n    stmt = line;\n    save_c = 0;\n    save_p = ((void *)0);\n    if (assign_to) {\n        for (p++; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (!*p) {\n            unset_var(assign_to);\n            free(must_free);\n            return 0;\n        }\n        stmt = p;\n        for (; *p && !(*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p) {\n            save_p = p;\n            save_c = *p;\n            for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n                ;\n        }\n    }\n    for (i = 0; cmdtbl[i].name && strcmp(stmt, cmdtbl[i].name); i++)\n        ;\n    if (!cmdtbl[i].name) {\n        if (!assign_to)\n            (die)(\"%s: invalid statement '%s'\\n\", __func__, (stmt));\n        if (save_p)\n            *save_p = save_c;\n        set_var(assign_to, stmt);\n        free(must_free);\n        return 0;\n    }\n    if (cmdtbl[i].fnc)\n        cmdtbl[i].fnc(assign_to, p);\n    free(must_free);\n    return cmdtbl[i].fnc ? 0 : 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(expand_line)(long long);\nlong long(die)(...);\nlong long(unset_var)(long long);\nlong long(set_var)(long long, long long);\n\nextern unsigned long long cmdtbl.1 [4];\nextern unsigned long long g_407168[4];\n\nlong long interpreter_name_conflict(char *a0) {\n  char *v0;        // [bp-0x40], Other Possible Types: unsigned long\n  char *v1;        // [bp-0x38], Other Possible Types: unsigned long\n  char *v2;        // [bp-0x30], Other Possible Types: unsigned long\n  char *v3;        // [bp-0x28], Other Possible Types: unsigned long\n  unsigned int v4; // [bp-0x20]\n  unsigned int v5; // [bp-0x1c]\n  char *v6;        // [bp-0x18], Other Possible Types: unsigned long\n  char *v7;        // [bp-0x10], Other Possible Types: unsigned long\n  char *v10;       // rax\n  char *v11;       // rax\n  char *v12;       // rdx\n\n  v0 = a0;\n  v3 = 0;\n  v2 = 0;\n  for (v1 = 0; *(v0) == 32 || *(v0) == 9; v0 += 1)\n    ;\n  if (!(*((char *)v0) && *((char *)v0) != 35))\n    return 0;\n  v7 = expand_line(v0);\n  if (v7) {\n    v1 = v7;\n    for (v0 = v7; *(v0) == 32 || *(v0) == 9; v0 += 1)\n      ;\n    if (!(*((char *)v0)) || !(*((char *)v0) != 35)) {\n      free(v1);\n      return 0;\n    }\n  }\n  for (v7 = v0; *((char *)v7) && *((char *)v7) != 32 && *((char *)v7) != 9 &&\n                *((char *)v7) != 61;\n       v7 += 1)\n    ;\n  if (*((char *)v7) == 61) {\n    *((char *)v7) = 0;\n    v2 = v0;\n  } else if (*((char *)v7)) {\n    v10 = v7;\n    v7 = v10 + 1;\n    for (*(v10) = 0; *((char *)v7) == 32 || *((char *)v7) == 9; v7 += 1)\n      ;\n    if (*((char *)v7) == 61)\n      v2 = v0;\n  }\n  if (!*((char *)v0))\n    die(); /* do not return */\n  v3 = v0;\n  v4 = 0;\n  v6 = 0;\n  if (v2) {\n    for (v7 += 1; *((char *)v7) == 32 || *((char *)v7) == 9; v7 += 1)\n      ;\n    if (!*((char *)v7)) {\n      unset_var(v2);\n      free(v1);\n      return 0;\n    }\n    for (v3 = v7; *((char *)v7) && *((char *)v7) != 32 && *((char *)v7) != 9;\n         v7 += 1)\n      ;\n    if (*((char *)v7)) {\n      v6 = v7;\n      v4 = *((char *)v7);\n      v11 = v7;\n      v7 = v11 + 1;\n      for (*(v11) = 0; *((char *)v7) == 32 || *((char *)v7) == 9; v7 += 1)\n        ;\n    }\n  }\n  for (v5 = 0; cmdtbl.1 [2 * v5] && strcmp(v3, cmdtbl.1 [2 * v5]); v5 += 1)\n    ;\n  if (cmdtbl.1 [2 * v5]) {\n    if (g_407168[2 * v5]) {\n      v12 = v7;\n      g_407168[2 * v5](v2, v12, v12, g_407168[2 * v5]);\n    }\n    free(v1);\n    return !g_407168[2 * v5];\n  } else if (!v2) {\n    die(); /* do not return */\n  } else {\n    if (v6)\n      *((char *)v6) = v4;\n    set_var(v2, v3);\n    free(v1);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8g_u6phf/interpreter_name_conflict.c:17:17: error: ISO C requires a named parameter\nbefore '...' 17 | long long (die)(...); |                 ^\n/tmp/tmp8g_u6phf/interpreter_name_conflict.c:21:33: error: expected ';' after top level\ndeclarator 21 | extern unsigned long long cmdtbl.1[4]; | ^ | ;\n/tmp/tmp8g_u6phf/interpreter_name_conflict.c:93:24: error: expected ';' in 'for' statement\nspecifier 93 |     for (v5 = 0; cmdtbl.1[2 * v5] && strcmp(v3, cmdtbl.1[2 *\nv5]); v5 += 1); |                        ^ /tmp/tmp8g_u6phf/interpreter_name_conflict.c:94:15:\nerror: expected ')' 94 |     if (cmdtbl.1[2 * v5]) |               ^\n/tmp/tmp8g_u6phf/interpreter_name_conflict.c:94:8: note: to match this '('\n   94 |     if (cmdtbl.1[2 * v5])\n      |        ^\n/tmp/tmp8g_u6phf/interpreter_name_conflict.c:99:29: error: called object type 'unsigned long\nlong' is not a function or function pointer 99 |             g_407168[2 *\nv5](v2, v12, v12, g_407168[2 * v5]); |             ~~~~~~~~~~~~~~~~^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *xstrdup(const char *string) {\n    void *p = malloc(strlen(string) + 1);\n    if (!p)\n        die(\"out of core: %s\", strerror((*__errno_location())));\n    strcpy(p, string);\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\nlong long(die)(...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  char *v0; // [bp-0x10]\n\n  v0 = malloc(strlen(a0) + 1);\n  if (!v0) {\n    strerror(*(__errno_location()));\n    die(); /* do not return */\n  }\n  strcpy(v0, a0);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy_6ey7u1/xstrdup_name_conflict.c:17:17: error: ISO C requires a named parameter before\n'...' 17 | long long (die)(...); |                 ^\n/tmp/tmpy_6ey7u1/xstrdup_name_conflict.c:26:18: error: indirection requires pointer operand\n('int' invalid) 26 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static char *ascii_strupr(char *string) {\n    char *p;\n    for (p = string; *p; p++)\n        if (!(*p & 128))\n            *p = toupper(*p);\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(toupper)(int);\n\nlong long ascii_strupr_name_conflict(char *a0) {\n  char *v0;              // [bp-0x10], Other Possible Types: unsigned long\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  for (v0 = a0; *((char *)v0); v0 += 1) {\n    if (*((char *)v0) >= 0)\n      *((char *)v0) = toupper(*((char *)v0));\n  }\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"const char *isodatestring(void) {\n    static char buffer[16];\n    struct tm *tp;\n    time_t atime = time(((void *)0));\n    if (atime < 0)\n        strcpy(buffer, \"????-??-??\");\n    else {\n        tp = gmtime(&atime);\n        sprintf(buffer, \"%04d-%02d-%02d\", 1900 + tp->tm_year, tp->tm_mon + 1, tp->tm_mday);\n    }\n    return buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(gmtime)(long *);\n\nextern char buffer.4;\nextern unsigned int g_4096a7;\n\nlong long isodatestring_name_conflict() {\n  unsigned int v0;    // [bp-0x18]\n  unsigned int v1[6]; // [bp-0x10]\n\n  *((long *)&v0) = time(NULL);\n  if (*((long long *)&v0) < 0) {\n    strncpy(&buffer.4, \"????-??-\", 8);\n    g_4096a7 = 4144941;\n    return &buffer.4;\n  }\n  *((struct tm **)&v1[0]) = gmtime(&v0);\n  sprintf(&buffer.4, \"%04d-%02d-%02d\", v1[5] + 1900, v1[4] + 1, v1[3]);\n  return &buffer.4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzkd8erln/isodatestring_name_conflict.c:19:19: error: expected ';' after top level\ndeclarator 19 | extern char buffer.4; |                   ^ | ;\n/tmp/tmpzkd8erln/isodatestring_name_conflict.c:30:24: error: expected ')'\n   30 |         strncpy(&buffer.4, \"????-??-\", 8);\n      |                        ^\n/tmp/tmpzkd8erln/isodatestring_name_conflict.c:30:16: note: to match this '('\n   30 |         strncpy(&buffer.4, \"????-??-\", 8);\n      |                ^\n/tmp/tmpzkd8erln/isodatestring_name_conflict.c:32:23: error: expected ';' after return\nstatement 32 |         return &buffer.4; |                       ^ | ;\n/tmp/tmpzkd8erln/isodatestring_name_conflict.c:35:20: error: expected ')'\n   35 |     sprintf(&buffer.4, \"%04d-%02d-%02d\", v1[5] + 1900, v1[4] + 1,\nv1[3]); |                    ^ /tmp/tmpzkd8erln/isodatestring_name_conflict.c:35:12: note: to\nmatch this '(' 35 |     sprintf(&buffer.4, \"%04d-%02d-%02d\", v1[5] + 1900, v1[4]\n+ 1, v1[3]); |            ^ /tmp/tmpzkd8erln/isodatestring_name_conflict.c:36:19: error:\nexpected ';' after return statement 36 |     return &buffer.4; | ^ | ; 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static int is_standard_section(const char *name) {\n    int i;\n    const char *s;\n    for (i = 0; (s = standard_sections[i]); i++)\n        if (!strcmp(s, name))\n            return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char standard_sections;\n\nlong long is_standard_section_name_conflict(char *a0) {\n  char *v0;              // [bp-0x18]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = 0;\n  while (true) {\n    v0 = *((long long *)&(&standard_sections)[8 * v1]);\n    if (!v0) {\n      return 0;\n    } else if (strcmp(v0, a0)) {\n      v1 += 1;\n    } else {\n      return 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":1,"function":"static const char *pcsc_error_string(long err) {\n    const char *s;\n    if (!err)\n        return \"okay\";\n    if ((err & 2148532224U) != 2148532224U)\n        return \"invalid PC/SC error code\";\n    err &= 65535;\n    switch (err) {\n      case 2:\n        s = \"cancelled\";\n        break;\n      case 14:\n        s = \"can't dispose\";\n        break;\n      case 8:\n        s = \"insufficient buffer\";\n        break;\n      case 21:\n        s = \"invalid ATR\";\n        break;\n      case 3:\n        s = \"invalid handle\";\n        break;\n      case 4:\n        s = \"invalid parameter\";\n        break;\n      case 5:\n        s = \"invalid target\";\n        break;\n      case 17:\n        s = \"invalid value\";\n        break;\n      case 6:\n        s = \"no memory\";\n        break;\n      case 19:\n        s = \"comm error\";\n        break;\n      case 1:\n        s = \"internal error\";\n        break;\n      case 20:\n        s = \"unknown error\";\n        break;\n      case 7:\n        s = \"waited too long\";\n        break;\n      case 9:\n        s = \"unknown reader\";\n        break;\n      case 10:\n        s = \"timeout\";\n        break;\n      case 11:\n        s = \"sharing violation\";\n        break;\n      case 12:\n        s = \"no smartcard\";\n        break;\n      case 13:\n        s = \"unknown card\";\n        break;\n      case 15:\n        s = \"proto mismatch\";\n        break;\n      case 16:\n        s = \"not ready\";\n        break;\n      case 18:\n        s = \"system cancelled\";\n        break;\n      case 22:\n        s = \"not transacted\";\n        break;\n      case 23:\n        s = \"reader unavailable\";\n        break;\n      case 101:\n        s = \"unsupported card\";\n        break;\n      case 102:\n        s = \"unresponsive card\";\n        break;\n      case 103:\n        s = \"unpowered card\";\n        break;\n      case 104:\n        s = \"reset card\";\n        break;\n      case 105:\n        s = \"removed card\";\n        break;\n      case 106:\n        s = \"inserted card\";\n        break;\n      case 31:\n        s = \"unsupported feature\";\n        break;\n      case 25:\n        s = \"PCI too small\";\n        break;\n      case 26:\n        s = \"reader unsupported\";\n        break;\n      case 27:\n        s = \"duplicate reader\";\n        break;\n      case 28:\n        s = \"card unsupported\";\n        break;\n      case 29:\n        s = \"no service\";\n        break;\n      case 30:\n        s = \"service stopped\";\n        break;\n      default:\n        s = \"unknown PC/SC error code\";\n        break;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pcsc_error_string_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x10]\n\n  v0 = a0;\n  if (!v0) {\n    return \"okay\";\n  } else if (((unsigned int)v0 & 0x80100000) == 0x80100000) {\n    v0 &= 65535;\n    switch (v0) {\n    case 1:\n      v1 = \"internal error\";\n      break;\n    case 2:\n      v1 = \"cancelled\";\n      break;\n    case 3:\n      v1 = \"invalid handle\";\n      break;\n    case 4:\n      v1 = \"invalid parameter\";\n      break;\n    case 5:\n      v1 = \"invalid target\";\n      break;\n    case 6:\n      v1 = \"no memory\";\n      break;\n    case 7:\n      v1 = \"waited too long\";\n      break;\n    case 8:\n      v1 = \"insufficient buffer\";\n      break;\n    case 9:\n      v1 = \"unknown reader\";\n      break;\n    case 10:\n      v1 = \"timeout\";\n      break;\n    case 11:\n      v1 = \"sharing violation\";\n      break;\n    case 12:\n      v1 = \"no smartcard\";\n      break;\n    case 13:\n      v1 = \"unknown card\";\n      break;\n    case 14:\n      v1 = \"can't dispose\";\n      break;\n    case 15:\n      v1 = \"proto mismatch\";\n      break;\n    case 16:\n      v1 = \"not ready\";\n      break;\n    case 17:\n      v1 = \"invalid value\";\n      break;\n    case 18:\n      v1 = \"system cancelled\";\n      break;\n    case 19:\n      v1 = \"comm error\";\n      break;\n    case 20:\n      v1 = \"unknown error\";\n      break;\n    case 21:\n      v1 = \"invalid ATR\";\n      break;\n    case 22:\n      v1 = \"not transacted\";\n      break;\n    case 23:\n      v1 = \"reader unavailable\";\n      break;\n    case 25:\n      v1 = \"PCI too small\";\n      break;\n    case 26:\n      v1 = \"reader unsupported\";\n      break;\n    case 27:\n      v1 = \"duplicate reader\";\n      break;\n    case 28:\n      v1 = \"card unsupported\";\n      break;\n    case 29:\n      v1 = \"no service\";\n      break;\n    case 30:\n      v1 = \"service stopped\";\n      break;\n    case 31:\n      v1 = \"unsupported feature\";\n      break;\n    case 101:\n      v1 = \"unsupported card\";\n      break;\n    case 102:\n      v1 = \"unresponsive card\";\n      break;\n    case 103:\n      v1 = \"unpowered card\";\n      break;\n    case 104:\n      v1 = \"reset card\";\n      break;\n    case 105:\n      v1 = \"removed card\";\n      break;\n    case 106:\n      v1 = \"inserted card\";\n      break;\n    default:\n      v1 = \"unknown PC/SC error code\";\n      break;\n    }\n    return v1;\n  } else {\n    return \"invalid PC/SC error code\";\n  }\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/scd/pcsc-wrapper.c"}
{"compilable":1,"function":"static unsigned int convert_le_u32(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long convert_le_u32_name_conflict(char a0[4]) {\n  return a0[3] * 0x1000000 | a0[1] * 0x100 | a0[0] | a0[2] * 0x10000;\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":1,"function":"static unsigned int convert_le_u16(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long convert_le_u16_name_conflict(char a0[2]) { return a0[0] | a0[1] * 0x100; }\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_version_name_conflict() { return 131074; }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_wrapper_enabled_name_conflict(unsigned long a0) {\n  return ((unsigned int)a0 == 4 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pl_supported_resources_dummy)(long long);\n\nlong long libplayer_wrapper_supported_res_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 != 4)\n    return 0;\n  return pl_supported_resources_dummy((unsigned int)a1);\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pl_supported_resources_dummy_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mrl_metadata_dvd_title_new_name_conflict() {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = calloc(1, 24);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    if (!n)\n        return 0;\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nlong(read)(int, void *, unsigned long);\nint(putchar)(int);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nlong long getch_name_conflict() {\n  unsigned int v0;       // [bp-0x9c]\n  unsigned long long v1; // [bp-0x98]\n  unsigned long long v2; // [bp-0x90]\n  unsigned int v3;       // [bp-0x8c]\n  unsigned long long v4; // [bp-0x88]\n  unsigned long long v5; // [bp-0x80]\n  unsigned long long v6; // [bp-0x78]\n  unsigned long long v7; // [bp-0x70]\n  unsigned long v8;      // [bp-0x6c]\n  unsigned long long v9; // [bp-0x64]\n  termios v10;           // [bp-0x58]\n  char v11;              // [bp-0x50]\n  char v12;              // [bp-0x48]\n  char v13;              // [bp-0x40]\n  char v14;              // [bp-0x38]\n  char v15;              // [bp-0x30]\n  unsigned long v16;     // [bp-0x2c]\n  char v17;              // [bp-0x24]\n  unsigned int v18;      // [bp-0x10]\n  unsigned int v19;      // [bp-0xc]\n\n  v0 = 0;\n  v19 = 0;\n  tcgetattr(0, &v10);\n  v1 = *((long long *)&v10.c_iflag);\n  v2 = *((long long *)&v11);\n  v4 = *((long long *)&v12);\n  v5 = *((long long *)&v13);\n  v6 = *((long long *)&v14);\n  v7 = *((long long *)&v15);\n  v8 = v16;\n  v9 = *((long long *)&v17);\n  v3 = *((int *)((char *)&v2 + 4)) & -11;\n  tcsetattr(0, 0, &v1);\n  v18 = read(0, &v0, 4);\n  if (!v18)\n    return 0;\n  putchar(10);\n  for (; v0; v0 >>= 8) {\n    v19 *= 0x100;\n    v19 += v0;\n  }\n  tcsetattr(0, 0, &v10);\n  return v19;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-test.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_version_name_conflict() { return 131074; }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_wrapper_enabled_name_conflict(unsigned long a0) {\n  return ((unsigned int)a0 == 4 ? 0 : 1);\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pl_supported_resources_dummy)(long long);\n\nlong long libplayer_wrapper_supported_res_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 != 4)\n    return 0;\n  return pl_supported_resources_dummy((unsigned int)a1);\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pl_supported_resources_dummy_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a0;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mrl_metadata_dvd_title_new_name_conflict() {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = calloc(1, 24);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nlong(read)(int, void *, unsigned long);\nint(putchar)(int);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nlong long getch_name_conflict() {\n  unsigned int v0;       // [bp-0x9c]\n  unsigned long long v1; // [bp-0x98]\n  unsigned long long v2; // [bp-0x90]\n  unsigned int v3;       // [bp-0x8c]\n  unsigned long long v4; // [bp-0x88]\n  unsigned long long v5; // [bp-0x80]\n  unsigned long long v6; // [bp-0x78]\n  unsigned long long v7; // [bp-0x70]\n  unsigned long v8;      // [bp-0x6c]\n  unsigned long long v9; // [bp-0x64]\n  termios v10;           // [bp-0x58]\n  char v11;              // [bp-0x50]\n  char v12;              // [bp-0x48]\n  char v13;              // [bp-0x40]\n  char v14;              // [bp-0x38]\n  char v15;              // [bp-0x30]\n  unsigned long v16;     // [bp-0x2c]\n  char v17;              // [bp-0x24]\n  unsigned int v18;      // [bp-0x10]\n  unsigned int v19;      // [bp-0xc]\n\n  v0 = 0;\n  v19 = 0;\n  tcgetattr(0, &v10);\n  v1 = *((long long *)&v10.c_iflag);\n  v2 = *((long long *)&v11);\n  v4 = *((long long *)&v12);\n  v5 = *((long long *)&v13);\n  v6 = *((long long *)&v14);\n  v7 = *((long long *)&v15);\n  v8 = v16;\n  v9 = *((long long *)&v17);\n  v3 = *((int *)((char *)&v2 + 4)) & -11;\n  tcsetattr(0, 0, &v1);\n  v18 = read(0, &v0, 4);\n  putchar(10);\n  for (; v0; v0 >>= 8) {\n    v19 *= 0x100;\n    v19 += v0;\n  }\n  tcsetattr(0, 0, &v10);\n  return v19;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-testvdr.c"}
{"compilable":0,"function":"int f(int u, int v) {\n    if (v > 0)\n        return 5 * u + 3 * v;\n    return u;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n\nlong long f_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v3; // rdx\n\n  if_name_conflict ((unsigned int)a1 <= 0)\n    return (unsigned int)a0;\n  v3 = (unsigned int)a1;\n  return (unsigned int)v3 * 2 + v3 + 5 * (unsigned int)a0;\n}\n","pass":0,"source_file":"C_COMPILE/andrewburger_c-and-c-plus-plus/hw9f02.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x18], Other Possible Types: unsigned long long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 1;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 0x1dcd6500 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnj0mhcub/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |             ^\n/tmp/tmpnj0mhcub/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |          ^\n/tmp/tmpnj0mhcub/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 0x1dcd6500 >> 64;\n      |                          ^\n      |                          ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) == -1) {\n      return 4294967295;\n    } else if (strcmp(a0, *((long long *)(vocab +\n                                          (*((int *)(vocab_hash + (v0 << 2)))\n                                           << 4) +\n                                          8)))) {\n      v0 = (0 CONCAT v0 + 1) / m 0x1dcd6500 >> 32;\n    } else {\n      return *((int *)(vocab_hash + v0 * 4));\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa9zjx8gh/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                     ^\n/tmp/tmpa9zjx8gh/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                  ^\n/tmp/tmpa9zjx8gh/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 0x1dcd6500 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 60)\n    v0 = 60;\n  *((void **)(8 + (char *)vocab + 16 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(8 + (char *)vocab + 16 * vocab_size)), a0);\n  *((long long *)((char *)vocab + 16 * vocab_size)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 0x1dcd6500 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplicn0_a2/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmplicn0_a2/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmplicn0_a2/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); | ^\n/tmp/tmplicn0_a2/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 0x1dcd6500 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(unsigned long a0) {\n  void *v0;              // [bp-0x18], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x10], Other Possible Types: unsigned long\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 < strlen(a0); v1 += 1) {\n    v0 = v1[a0] + 257 * v0;\n  }\n  v0 = (0 CONCAT v0) / m 30000000 >> 64;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx02elcsv/GetWordHash_name_conflict.c:29:27: error: invalid operands to binary\nexpression ('int' and 'void *') 29 |         v0 = v1[a0] + 257 * v0; | ~~~ ^ ~~\n/tmp/tmpx02elcsv/GetWordHash_name_conflict.c:31:13: error: expected ')'\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |             ^\n/tmp/tmpx02elcsv/GetWordHash_name_conflict.c:31:10: note: to match this '('\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |          ^\n/tmp/tmpx02elcsv/GetWordHash_name_conflict.c:31:26: error: expected ';' after expression\n   31 |     v0 = (0 CONCAT v0) /m 30000000 >> 64;\n      |                          ^\n      |                          ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0xc]\n  unsigned long long v2; // rax\n\n  v0 = GetWordHash(a0);\n  while (true) {\n    if (*((int *)(vocab_hash + (v0 << 2))) != -1) {\n      v2 = *((int *)(vocab_hash + v0 * 4));\n      if (!strcmp(a0, *((long long *)(((v2 << 2) + v2 << 3) + vocab + 16))))\n        return *((int *)(vocab_hash + v0 * 4));\n      v0 = (0 CONCAT v0 + 1) / m 30000000 >> 32;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5e0g6sh_/SearchVocab_name_conflict.c:35:21: error: expected ')'\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                     ^\n/tmp/tmp5e0g6sh_/SearchVocab_name_conflict.c:35:18: note: to match this '('\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                  ^\n/tmp/tmp5e0g6sh_/SearchVocab_name_conflict.c:35:38: error: expected ';' after expression\n   35 |             v0 = (0 CONCAT v0 + 1) /m 30000000 >> 32;\n      |                                      ^\n      |                                      ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned long long vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned long v2;      // [bp-0x10]\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rbx\n\n  v2 = v4;\n  v0 = (unsigned int)strlen(a0) + 1;\n  if (v0 > 100)\n    v0 = 100;\n  *((void **)(16 + (char *)vocab + 40 * vocab_size)) = calloc(v0, 1);\n  strcpy(*((long long *)(16 + 40 * vocab_size + (char *)vocab)), a0);\n  *((long long *)(40 * vocab_size + (char *)vocab)) = 0;\n  vocab_size = vocab_size + 1;\n  if (vocab_size + 2 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\n       v1 = (0 CONCAT v1 + 1) / m 30000000 >> 32)\n    ;\n  *((unsigned int *)(vocab_hash + v1 * 4)) = vocab_size - 1;\n  v5 = v2;\n  return (unsigned int)vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprsl1z70d/AddWordToVocab_name_conflict.c:46:82: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmprsl1z70d/AddWordToVocab_name_conflict.c:46:79: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmprsl1z70d/AddWordToVocab_name_conflict.c:46:100: error: expected ')'\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); | ^\n/tmp/tmprsl1z70d/AddWordToVocab_name_conflict.c:46:9: note: to match this '('\n   46 |     for (v1 = GetWordHash(a0); *((int *)(vocab_hash + (v1 << 2))) != -1;\nv1 = (0 CONCAT v1 + 1) /m 30000000 >> 32); |         ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char **a2) {\n  unsigned int v0;       // [bp-0xc]\n  char v1;               // [bp-0x8]\n  unsigned long long v3; // rbp\n\n  v3 = &v1;\n  v0 = 1;\n  while (true) {\n    if (v0 >= (unsigned int)a1)\n      return 4294967295;\n    if (!strcmp(a0, a2[v0]))\n      break;\n    v0 += 1;\n  }\n  if (v0 != (unsigned int)a1 - 1)\n    return v0;\n  printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n  exit(1); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"WinMsgTokState *wmtok_init(WinMsgTokState *st) {\n    if (st == ((void *)0)) {\n        st = malloc(sizeof(WinMsgTokState));\n        st->_dofree = 1;\n    }\n    return st;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long wmtok_init_name_conflict(struct_0 *a0) {\n  struct_0 *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  if (!v0) {\n    v0 = malloc(2);\n    *((char *)(v0 + 1)) = 1;\n    return v0;\n  }\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/swegener_screen/src/winmsgtok.c"}
{"compilable":0,"function":"int parsemac(char *str, unsigned char *mac) {\n    char *s;\n    while ((s = strsep(&str, \":\")) != ((void *)0))\n        {\n            unsigned int byte;\n            if (sscanf(s, \"%x\", &byte) != 1 || byte > 255)\n                return -1;\n            *mac++ = byte;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strsep)(char **, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\nlong long parsemac_name_conflict(unsigned long a0, char *a1) {\n  char *v0; // [bp-0x28], Other Possible Types: unsigned long\n  char *v1; // [bp-0x20]\n  char v2;  // [bp-0x14]\n  char *v3; // [bp-0x10]\n  char *v5; // rax\n\n  v1 = a0;\n  v0 = a1;\n  while (true) {\n    v3 = strsep(&v1, \":\");\n    if (!v3)\n      return 0;\n    if (!(__isoc99_sscanf(v3, \"%x\", (unsigned int)&v2) == 1) ||\n        !(*((int *)&v2) <= 255))\n      break;\n    v5 = v0;\n    v0 = v5 + 1;\n    *(v5) = *((int *)&v2);\n  }\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int setname(char *oldname, char *newname) {\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, oldname);\n    strcpy(ifr.ifr_ifru.ifru_newname, newname);\n    return ioctl(ctl_sk, 35107, &ifr);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(opensock)();\n\nextern unsigned int ctl_sk;\n\nlong long setname_name_conflict(char *a0, char *a1) {\n  char v0; // [bp-0x38]\n  char v1; // [bp-0x28]\n\n  opensock();\n  memset(&v0, 0, 40);\n  strcpy(&v0, a0);\n  strcpy(&v1, a1);\n  return ioctl(ctl_sk, 35107);\n}\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int getmac(char *name, unsigned char *mac) {\n    int r;\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, name);\n    r = ioctl(ctl_sk, 35111, &ifr);\n    memcpy(mac, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(opensock)();\n\nextern unsigned int ctl_sk;\n\nlong long getmac_name_conflict(char *a0, void *a1) {\n  char v0;         // [bp-0x38]\n  char v1;         // [bp-0x26]\n  unsigned int v2; // [bp-0xc]\n\n  opensock();\n  memset(&v0, 0, 40);\n  strcpy(&v0, a0);\n  v2 = ioctl(ctl_sk, 35111);\n  memcpy(a1, &v1, 6);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"char *MakeCRC(char *BitString) {\n    static char Res[6];\n    char CRC[5];\n    int i;\n    char DoInvert;\n    for (i = 0; i < 5; ++i)\n        CRC[i] = 0;\n    for (i = 0; i < strlen(BitString); ++i) {\n        DoInvert = ('1' == BitString[i]) ^ CRC[4];\n        printf(\"%i %i %i\\t\", i, ('1' == BitString[i]), DoInvert);\n        CRC[4] = CRC[3];\n        CRC[3] = CRC[2];\n        CRC[2] = CRC[1] ^ DoInvert;\n        CRC[1] = CRC[0];\n        CRC[0] = DoInvert;\n        printf(\"%i %i %i %i %i\\n\", CRC[0], CRC[1], CRC[2], CRC[3], CRC[4]);\n    }\n    for (i = 0; i < 5; ++i)\n        Res[4 - i] = CRC[i] ? '1' : '0';\n    Res[5] = 0;\n    return (Res);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char Res.0;\nextern char g_404026;\n\nlong long MakeCRC_name_conflict(char *a0) {\n  char v0;                // [bp-0x22]\n  char v1;                // [bp-0x21]\n  char v2;                // [bp-0x20]\n  char v3;                // [bp-0x1f]\n  char v4;                // [bp-0x1e]\n  char v5;                // [bp-0x1d]\n  unsigned int v6;        // [bp-0x1c]\n  unsigned long v7;       // [bp-0x10]\n  char v8;                // [bp-0x8]\n  unsigned long long v10; // rbp\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rax\n  unsigned long long v14; // rbx\n\n  v10 = &v8;\n  v7 = v11;\n  for (v6 = 0; v6 <= 4; v6 += 1) {\n    (&v0)[v6] = 0;\n  }\n  for (v6 = 0; v6 < strlen(a0); v6 += 1) {\n    v12 = a0[v6];\n    *((char *)&v12) = (char)v12 == 49;\n    v5 = v4 ^ (unsigned int)v12;\n    printf(\"%i %i %i\\t\", v6, a0[v6] == 49, v5);\n    v4 = v3;\n    v3 = v2;\n    v2 = v1 ^ v5;\n    v1 = v0;\n    v0 = v5;\n    printf(\"%i %i %i %i %i\\n\", v0, v1, v2, v3, v4);\n  }\n  for (v6 = 0; v6 <= 4; v6 += 1) {\n    *((int *)&(&Res.0)[4 + -1 * v6]) = (!(&v0)[v6] ? 49 : 48);\n  }\n  g_404026 = 0;\n  v14 = v7;\n  return &Res.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqbs6hjrk/MakeCRC_name_conflict.c:17:16: error: expected ';' after top level declarator\n   17 | extern char Res.0;\n      |                ^\n      |                ;\n/tmp/tmpqbs6hjrk/MakeCRC_name_conflict.c:57:24: error: expected ')'\n   57 |         *((int *)&(&Res.0)[4 + -1 * v6]) = (!(&v0)[v6] ? 49 : 48);\n      |                        ^\n/tmp/tmpqbs6hjrk/MakeCRC_name_conflict.c:57:19: note: to match this '('\n   57 |         *((int *)&(&Res.0)[4 + -1 * v6]) = (!(&v0)[v6] ? 49 : 48);\n      |                   ^\n/tmp/tmpqbs6hjrk/MakeCRC_name_conflict.c:61:16: error: expected ';' after return statement\n   61 |     return &Res.0;\n      |                ^\n      |                ;\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aeburriel_tetrapol-kit/misc/crc.c"}
{"compilable":0,"function":"uint8_t ReadUint8(void) {\n    uint8_t temp;\n    int data_read = read(0, &temp, 1);\n    if (data_read != 1) {\n        exit(-1);\n    }\n    return temp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long ReadUint8_name_conflict() {\n  char v0;         // [bp-0xd]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = read(0, &v0, 1);\n  if (v1 != 1)\n    exit(-1); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint8_t IntToHexChar(uint8_t val) {\n    if (val < 10)\n        return '0' + val;\n    else\n        return 'a' + (val - 10);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long IntToHexChar_name_conflict(unsigned long a0) {\n  return ((char)a0 <= 9 ? (char)a0 + 87 : (char)a0 + 48);\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"char *ConvertDataBytes(char *pszData, uint8_t foodTotal, uint8_t maxConvert) {\n    uint32_t outIdx = 0;\n    uint32_t i;\n    int bTruncated = 0;\n    if (foodTotal > maxConvert) {\n        bTruncated = 1;\n        foodTotal = maxConvert;\n    }\n    for (i = 0; i < maxConvert; i++) {\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i] >> 4) & 15);\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i]) & 15);\n    }\n    g_displayFoodString[outIdx] = '\\x00';\n    if (bTruncated)\n        strcpy(g_displayFoodString + outIdx, \"...\");\n    return g_displayFoodString;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(IntToHexChar)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[4210880];\n  char field_4040c0;\n} struct_0;\n\nextern char g_displayFoodString;\n\nlong long ConvertDataBytes_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x24]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  struct_0 *v5;    // rax\n  struct_0 *v6;    // rax\n\n  v0 = a1;\n  v3 = 0;\n  v1 = 0;\n  if ((char)a2 < v0) {\n    v1 = 1;\n    v0 = a2;\n  }\n  for (v2 = 0; v2 < (char)a2; v2 += 1) {\n    v5 = v3;\n    v3 = (unsigned int)v5 + 1;\n    *((char *)(v5 + &g_displayFoodString)) = IntToHexChar(a0[v2] >> 4);\n    v6 = v3;\n    v3 = (unsigned int)v6 + 1;\n    *((char *)(v6 + &g_displayFoodString)) = IntToHexChar(a0[v2] & 15);\n  }\n  *(&(&g_displayFoodString)[v3]) = 0;\n  if (v1)\n    *((int *)&(&g_displayFoodString)[v3]) = 3026478;\n  return &g_displayFoodString;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnvab29oe/ConvertDataBytes_name_conflict.c:46:23: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'char *') 46 | *((char\n*)(v5 + &g_displayFoodString)) = IntToHexChar(a0[v2] >> 4); | ~~ ^\n~~~~~~~~~~~~~~~~~~~~ /tmp/tmpnvab29oe/ConvertDataBytes_name_conflict.c:49:23: error: invalid\noperands to binary expression ('struct_0 *' (aka 'struct struct_0 *') and 'char\n*') 49 |         *((char *)(v6 + &g_displayFoodString)) = IntToHexChar(a0[v2] &\n15); |                    ~~ ^ ~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"uint8_t GetFood(void) {\n    char szEchoData[32];\n    uint8_t foodTotal;\n    printf(\"FEED ME!\\n\");\n    foodTotal = ReadUint8();\n    ReadData(szEchoData, foodTotal);\n    printf(\"ATE %s\\n\", ConvertDataBytes(szEchoData, foodTotal, 16));\n    return foodTotal;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ReadUint8)();\nlong long(ReadData)(long long, long long);\nlong long(ConvertDataBytes)(long long, long long, long long);\n\nlong long GetFood_name_conflict() {\n  char v0; // [bp-0x38]\n  char v1; // [bp-0x9]\n\n  puts(\"FEED ME!\");\n  v1 = ReadUint8();\n  ReadData(&v0, v1);\n  printf(\"ATE %s\\n\", (int)ConvertDataBytes(&v0, v1, 16));\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint64_t exp_l(uint64_t base, uint64_t power) {\n    int i = 0;\n    uint64_t j = base;\n    if (power == 0) {\n        return 1;\n    }\n    for (i = 0; i < power - 1; i++) {\n        j *= base;\n    }\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long exp_l_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x18]\n  unsigned int v1;  // [bp-0xc]\n\n  v1 = 0;\n  v0 = a0;\n  if (!a1)\n    return 1;\n  for (v1 = 0; v1 < a1 - 1; v1 += 1) {\n    v0 = a0 * v0;\n  }\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t xor(uint64_t a, uint64_t b) {\n    return a ^ b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long xor_name_conflict (unsigned long a0, unsigned long a1) { return a0 ^ a1; }\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t shla(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    high = a << dabits;\n    low = a >> (64 - dabits);\n    return high | low;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shla_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x28]\n  void *v1;         // [bp-0x18], Other Possible Types: unsigned long\n  void *v2;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a1;\n  v2 = 0;\n  v1 = 0;\n  v0 &= 63;\n  if (!v0)\n    return a0;\n  v2 = a0 << ((char)v0 & 63);\n  v1 = a0 >> ((char)(64 - (unsigned int)v0) & 63);\n  return v2 | v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7_6xhi78/shla_name_conflict.c:31:15: error: invalid operands to binary expression\n('void *' and 'void *') 31 |     return v2 | v1; |            ~~ ^ ~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t shra(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    low = a >> dabits;\n    high = a << (64 - dabits);\n    return high | low;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shra_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x28]\n  void *v1;         // [bp-0x18], Other Possible Types: unsigned long\n  void *v2;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a1;\n  v2 = 0;\n  v1 = 0;\n  v0 &= 63;\n  if (!v0)\n    return a0;\n  v1 = a0 >> ((char)v0 & 63);\n  v2 = a0 << ((char)(64 - (unsigned int)v0) & 63);\n  return v2 | v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb_j_qm4m/shra_name_conflict.c:31:15: error: invalid operands to binary expression\n('void *' and 'void *') 31 |     return v2 | v1; |            ~~ ^ ~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t swap_bytes(uint64_t value) {\n    uint64_t final = 0;\n    final |= ((value & 255) << 24);\n    final |= ((value & 65280) << 24);\n    final |= ((value & 16711680) << 40);\n    final |= ((value & 4278190080U) << 16);\n    final |= ((value & 1095216660480L) >> 16);\n    final |= ((value & 280375465082880L) >> 40);\n    final |= ((value & 71776119061217280L) >> 40);\n    final |= ((value & 18374686479671623680UL) >> 8);\n    return final;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long swap_bytes_name_conflict(unsigned long a0) {\n  void *v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = 0;\n  v0 |= a0 * 0x1000000;\n  v0 |= 0xff00000000 & a0 * 0x1000000;\n  v0 |= -0x100000000000000 & a0 * 0x10000000000;\n  v0 |= 0xff0000000000 & a0 * 0x10000;\n  v0 |= (unsigned int)a0 / 0x10000 & 0xff0000;\n  v0 |= a0 / 0x10000000000;\n  v0 |= (unsigned int)a0 / 0x10000000000 & 0xff00;\n  v0 |= 0xff000000000000 & a0 / 0x100;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplwhfusfv/swap_bytes_name_conflict.c:22:8: error: invalid operands to binary expression\n('void *' and 'unsigned long') 22 |     v0 |= a0 * 0x1000000; |     ~~ ^\n~~~~~~~~~~~~~~ /tmp/tmplwhfusfv/swap_bytes_name_conflict.c:23:8: error: invalid operands to\nbinary expression ('void *' and 'unsigned long') 23 |     v0 |= 0xff00000000 &\na0 * 0x1000000; |     ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplwhfusfv/swap_bytes_name_conflict.c:24:8: error: invalid operands to binary expression\n('void *' and 'unsigned long') 24 |     v0 |= -0x100000000000000 & a0 *\n0x10000000000; |     ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplwhfusfv/swap_bytes_name_conflict.c:25:8: error: invalid operands to binary expression\n('void *' and 'unsigned long') 25 |     v0 |= 0xff0000000000 & a0 * 0x10000; |\n~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /tmp/tmplwhfusfv/swap_bytes_name_conflict.c:26:8: error:\ninvalid operands to binary expression ('void *' and 'unsigned int') 26 |     v0\n|= (unsigned int)a0 / 0x10000 & 0xff0000; |     ~~ ^\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /tmp/tmplwhfusfv/swap_bytes_name_conflict.c:27:8: error:\ninvalid operands to binary expression ('void *' and 'unsigned long') 27 |     v0\n|= a0 / 0x10000000000; |     ~~ ^  ~~~~~~~~~~~~~~~~~~\n/tmp/tmplwhfusfv/swap_bytes_name_conflict.c:28:8: error: invalid operands to binary expression\n('void *' and 'long') 28 |     v0 |= (unsigned int)a0 / 0x10000000000 & 0xff00;\n      |     ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplwhfusfv/swap_bytes_name_conflict.c:29:8: error: invalid operands to binary expression\n('void *' and 'unsigned long') 29 |     v0 |= 0xff000000000000 & a0 / 0x100; |\n~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t swap_two(uint64_t value, uint64_t one, uint64_t two) {\n    uint64_t t_one = 0;\n    uint64_t t_two = 0;\n    uint64_t mask_one = 255;\n    uint64_t mask_two = 255;\n    mask_one <<= one * 8;\n    mask_two <<= two * 8;\n    mask_one ^= 18446744073709551615UL;\n    mask_two ^= 18446744073709551615UL;\n    t_one = (value >> (one * 8)) & 255;\n    t_two = (value >> (two * 8)) & 255;\n    value &= (mask_one & mask_two);\n    value |= (t_two << (one * 8));\n    value |= (t_one << (two * 8));\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long swap_two_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x30]\n  unsigned long v1; // [bp-0x28], Other Possible Types: unsigned long long\n  unsigned long v2; // [bp-0x20], Other Possible Types: unsigned long long\n  void *v3;         // [bp-0x18], Other Possible Types: unsigned long\n  void *v4;         // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v4 = 0;\n  v3 = 0;\n  v2 = 255;\n  v1 = 255;\n  v2 <<= (char)a1 * 8 & 63;\n  v1 <<= (char)a2 * 8 & 63;\n  v2 = ~(v2);\n  v1 = ~(v1);\n  v4 = (unsigned int)(v0 >> ((char)a1 * 8 & 63)) & 255;\n  v3 = (unsigned int)(v0 >> ((char)a2 * 8 & 63)) & 255;\n  v0 &= v2 & v1;\n  v0 |= v3 << ((char)a1 * 8 & 63);\n  v0 |= v4 << ((char)a2 * 8 & 63);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5eso8w6e/swap_two_name_conflict.c:37:14: error: invalid operands to binary expression\n('void *' and 'int') 37 |     v0 |= v3 << ((char)a1 * 8 & 63); |           ~~ ^\n~~~~~~~~~~~~~~~~~~~ /tmp/tmp5eso8w6e/swap_two_name_conflict.c:38:14: error: invalid operands\nto binary expression ('void *' and 'int') 38 |     v0 |= v4 << ((char)a2 * 8 &\n63); |           ~~ ^  ~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t xor_neighbor(uint64_t value) {\n    int i = 0;\n    uint64_t t = 0;\n    t |= ((value & 18374686479671623680UL) >> 8) ^ (value & 71776119061217280L);\n    t |= ((value & 71776119061217280L) >> 8) ^ (value & 280375465082880L);\n    t |= ((value & 280375465082880L) >> 8) ^ (value & 1095216660480L);\n    t |= ((value & 1095216660480L) >> 8) ^ (value & 4278190080U);\n    t |= ((value & 4278190080U) >> 8) ^ (value & 16711680);\n    t |= ((value & 16711680) >> 8) ^ (value & 65280);\n    t |= ((value & 65280) >> 8) ^ (value & 255);\n    t |= ((value & 255) << 56) ^ (value & 18374686479671623680UL);\n    return t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long xor_neighbor_name_conflict(unsigned long a0) {\n  void *v0;        // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 0;\n  v0 = 0;\n  v0 |= (a0 / 0x100 ^ a0) & 0xff000000000000;\n  v0 |= (a0 / 0x100 ^ a0) & 0xff0000000000;\n  v0 |= (a0 / 0x100 ^ a0) & 0xff00000000;\n  v0 |= ((unsigned int)a0 / 0x100 ^ (unsigned int)a0) & -0x1000000;\n  v0 |= ((unsigned int)a0 / 0x100 ^ (unsigned int)a0) & 0xff0000;\n  v0 |= ((unsigned int)a0 / 0x100 ^ (unsigned int)a0) & 0xff00;\n  v0 |= a0 / 0x100 ^ a0;\n  v0 |= -0x100000000000000 & a0 ^ a0 * 0x100000000000000;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:24:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned long') 24 |     v0 |= (a0 / 0x100 ^ a0) &\n0xff000000000000; |     ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:25:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned long') 25 |     v0 |= (a0 / 0x100 ^ a0) &\n0xff0000000000; |     ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:26:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned long') 26 |     v0 |= (a0 / 0x100 ^ a0) &\n0xff00000000; |     ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:27:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned int') 27 |     v0 |= ((unsigned int)a0 /\n0x100 ^ (unsigned int)a0) & -0x1000000; |     ~~ ^\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:28:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned int') 28 |     v0 |= ((unsigned int)a0 /\n0x100 ^ (unsigned int)a0) & 0xff0000; |     ~~ ^\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:29:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned int') 29 |     v0 |= ((unsigned int)a0 /\n0x100 ^ (unsigned int)a0) & 0xff00; |     ~~ ^\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:30:8: error: invalid operands to binary\nexpression ('void *' and 'unsigned long') 30 |     v0 |= a0 / 0x100 ^ a0; | ~~ ^\n~~~~~~~~~~~~~~~ /tmp/tmpkd_fsep9/xor_neighbor_name_conflict.c:31:8: error: invalid operands to\nbinary expression ('void *' and 'unsigned long') 31 |     v0 |=\n-0x100000000000000 & a0 ^ a0 * 0x100000000000000; |     ~~ ^\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_one(uint64_t value) {\n    value = xor(value, 3861390726976975706L);\n    value = swap_two(value, 2, 0);\n    value = xor(value, 9943296405002333681UL);\n    value = xor(value, 16857834378267756394UL);\n    value = swap_two(value, 2, 3);\n    value = xor(value, 13674338511762446054UL);\n    value = shla(value, 16);\n    value = shla(value, 35);\n    value = shra(value, 19);\n    value = xor_neighbor(value);\n    value = shla(value, 36);\n    value = shra(value, 40);\n    value = swap_two(value, 1, 0);\n    value = xor(value, 6765015749217278743L);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 1);\n    value = xor(value, 7686949068708848117L);\n    value = swap_two(value, 3, 0);\n    value = swap_bytes(value);\n    value = xor(value, 6401935715922169987L);\n    value = shra(value, 22);\n    value = xor_neighbor(value);\n    value = xor(value, 5166993816397978483L);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 5);\n    value = shla(value, 59);\n    value = swap_two(value, 5, 2);\n    value = swap_two(value, 2, 3);\n    value = shla(value, 12);\n    value = xor(value, 12476431667104729879UL);\n    value = xor(value, 5234710379464860866L);\n    value = shla(value, 6);\n    value = swap_two(value, 6, 5);\n    value = shra(value, 11);\n    value = swap_bytes(value);\n    value = xor(value, 9697206415216557238UL);\n    value = swap_bytes(value);\n    value = shra(value, 2);\n    value = xor(value, 4649309708712362587L);\n    value = shla(value, 35);\n    value = shla(value, 9);\n    value = xor_neighbor(value);\n    value = shla(value, 7);\n    value = shla(value, 38);\n    value = xor_neighbor(value);\n    value = xor(value, 16065139371609640475UL);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 7);\n    value = shra(value, 51);\n    value = swap_bytes(value);\n    value = shra(value, 19);\n    value = xor(value, 10799149603522670113UL);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 16);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long (xor)(long long, long long);\nlong long(swap_two)(long long, long long, long long);\nlong long(shla)(long long, long long);\nlong long(shra)(long long, long long);\nlong long(xor_neighbor)(long long);\nlong long(swap_bytes)(long long);\n\nlong long munge_one_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v0 = xor(v0, 3861390726976975706);\n  v0 = swap_two(v0, 2, 0);\n  v0 = xor(v0, 9943296405002333681);\n  v0 = xor(v0, 16857834378267756394);\n  v0 = swap_two(v0, 2, 3);\n  v0 = xor(v0, 13674338511762446054);\n  v0 = shla(v0, 16);\n  v0 = shla(v0, 35);\n  v0 = shra(v0, 19);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 36);\n  v0 = shra(v0, 40);\n  v0 = swap_two(v0, 1, 0);\n  v0 = xor(v0, 6765015749217278743);\n  v0 = swap_bytes(v0);\n  v0 = swap_bytes(v0);\n  v0 = swap_two(v0, 2, 1);\n  v0 = xor(v0, 7686949068708848117);\n  v0 = swap_two(v0, 3, 0);\n  v0 = swap_bytes(v0);\n  v0 = xor(v0, 6401935715922169987);\n  v0 = shra(v0, 22);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 5166993816397978483);\n  v0 = xor_neighbor(v0);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 6, 5);\n  v0 = shla(v0, 59);\n  v0 = swap_two(v0, 5, 2);\n  v0 = swap_two(v0, 2, 3);\n  v0 = shla(v0, 12);\n  v0 = xor(v0, 12476431667104729879);\n  v0 = xor(v0, 5234710379464860866);\n  v0 = shla(v0, 6);\n  v0 = swap_two(v0, 6, 5);\n  v0 = shra(v0, 11);\n  v0 = swap_bytes(v0);\n  v0 = xor(v0, 9697206415216557238);\n  v0 = swap_bytes(v0);\n  v0 = shra(v0, 2);\n  v0 = xor(v0, 4649309708712362587);\n  v0 = shla(v0, 35);\n  v0 = shla(v0, 9);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 7);\n  v0 = shla(v0, 38);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 16065139371609640475);\n  v0 = swap_bytes(v0);\n  v0 = swap_bytes(v0);\n  v0 = swap_two(v0, 2, 7);\n  v0 = shra(v0, 51);\n  v0 = swap_bytes(v0);\n  v0 = shra(v0, 19);\n  v0 = xor(v0, 10799149603522670113);\n  v0 = xor_neighbor(v0);\n  v0 = swap_bytes(v0);\n  v0 = shra(v0, 16);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_two(uint64_t value) {\n    value = shla(value, 22);\n    value = swap_bytes(value);\n    value = swap_two(value, 4, 1);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 2, 6);\n    value = xor(value, 9271198935367831530UL);\n    value = shla(value, 3);\n    value = swap_two(value, 0, 1);\n    value = swap_two(value, 1, 2);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 1);\n    value = shra(value, 24);\n    value = shla(value, 39);\n    value = swap_two(value, 2, 4);\n    value = xor(value, 7462025471038891063L);\n    value = swap_two(value, 4, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 62);\n    value = swap_bytes(value);\n    value = swap_two(value, 7, 6);\n    value = swap_two(value, 2, 6);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 2);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 7);\n    value = xor(value, 4749710960471120103L);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 4);\n    value = shla(value, 10);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = shra(value, 24);\n    value = swap_two(value, 0, 4);\n    value = shra(value, 61);\n    value = swap_two(value, 3, 4);\n    value = shra(value, 35);\n    value = shla(value, 55);\n    value = shla(value, 34);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = shra(value, 23);\n    value = shla(value, 59);\n    value = shra(value, 20);\n    value = shla(value, 28);\n    value = xor(value, 14007489205149181901UL);\n    value = xor_neighbor(value);\n    value = shra(value, 13);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(shla)(long long, long long);\nlong long(swap_bytes)(long long);\nlong long(swap_two)(long long, long long, long long);\nlong long(xor_neighbor)(long long);\nlong long (xor)(long long, long long);\nlong long(shra)(long long, long long);\n\nlong long munge_two_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v0 = shla(v0, 22);\n  v0 = swap_bytes(v0);\n  v0 = swap_two(v0, 4, 1);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 35);\n  v0 = swap_two(v0, 2, 6);\n  v0 = xor(v0, 9271198935367831530);\n  v0 = shla(v0, 3);\n  v0 = swap_two(v0, 0, 1);\n  v0 = swap_two(v0, 1, 2);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 5, 1);\n  v0 = shra(v0, 24);\n  v0 = shla(v0, 39);\n  v0 = swap_two(v0, 2, 4);\n  v0 = xor(v0, 7462025471038891063);\n  v0 = swap_two(v0, 4, 3);\n  v0 = swap_two(v0, 0, 7);\n  v0 = shla(v0, 62);\n  v0 = swap_bytes(v0);\n  v0 = swap_two(v0, 7, 6);\n  v0 = swap_two(v0, 2, 6);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 5, 2);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 1, 7);\n  v0 = xor(v0, 4749710960471120103);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 1, 4);\n  v0 = shla(v0, 10);\n  v0 = swap_bytes(v0);\n  v0 = swap_bytes(v0);\n  v0 = shra(v0, 24);\n  v0 = swap_two(v0, 0, 4);\n  v0 = shra(v0, 61);\n  v0 = swap_two(v0, 3, 4);\n  v0 = shra(v0, 35);\n  v0 = shla(v0, 55);\n  v0 = shla(v0, 34);\n  v0 = xor_neighbor(v0);\n  v0 = xor_neighbor(v0);\n  v0 = shra(v0, 23);\n  v0 = shla(v0, 59);\n  v0 = shra(v0, 20);\n  v0 = shla(v0, 28);\n  v0 = xor(v0, 14007489205149181901);\n  v0 = xor_neighbor(v0);\n  v0 = shra(v0, 13);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_three(uint64_t value) {\n    value = shla(value, 18);\n    value = shla(value, 29);\n    value = swap_two(value, 5, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 18);\n    value = xor(value, 14531814500985747629UL);\n    value = shra(value, 33);\n    value = swap_two(value, 0, 4);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 2);\n    value = shra(value, 13);\n    value = shra(value, 20);\n    value = xor(value, 6368261268581873766L);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 46);\n    value = swap_two(value, 2, 3);\n    value = shra(value, 44);\n    value = shra(value, 3);\n    value = swap_two(value, 4, 3);\n    value = xor_neighbor(value);\n    value = swap_two(value, 7, 6);\n    value = shra(value, 59);\n    value = shra(value, 38);\n    value = swap_bytes(value);\n    value = swap_two(value, 1, 5);\n    value = swap_bytes(value);\n    value = shla(value, 27);\n    value = xor(value, 13751028607104816751UL);\n    value = shra(value, 14);\n    value = shla(value, 7);\n    value = shla(value, 18);\n    value = shla(value, 57);\n    value = xor(value, 12989550924262916891UL);\n    value = xor(value, 929788566303591270L);\n    value = xor(value, 10714451137995436577UL);\n    value = xor(value, 9637405481907436618UL);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 20);\n    value = shla(value, 24);\n    value = shra(value, 46);\n    value = shra(value, 13);\n    value = xor(value, 14510136432192624501UL);\n    value = shla(value, 7);\n    value = xor(value, 641209893495219690L);\n    value = xor(value, 6473287570272602621L);\n    value = xor_neighbor(value);\n    value = swap_two(value, 4, 7);\n    value = xor_neighbor(value);\n    value = shra(value, 22);\n    value = shra(value, 50);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(shla)(long long, long long);\nlong long(swap_two)(long long, long long, long long);\nlong long (xor)(long long, long long);\nlong long(shra)(long long, long long);\nlong long(xor_neighbor)(long long);\nlong long(swap_bytes)(long long);\n\nlong long munge_three_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v0 = shla(v0, 18);\n  v0 = shla(v0, 29);\n  v0 = swap_two(v0, 5, 3);\n  v0 = swap_two(v0, 0, 7);\n  v0 = shla(v0, 18);\n  v0 = xor(v0, 14531814500985747629);\n  v0 = shra(v0, 33);\n  v0 = swap_two(v0, 0, 4);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 6, 2);\n  v0 = shra(v0, 13);\n  v0 = shra(v0, 20);\n  v0 = xor(v0, 6368261268581873766);\n  v0 = xor_neighbor(v0);\n  v0 = swap_bytes(v0);\n  v0 = shra(v0, 46);\n  v0 = swap_two(v0, 2, 3);\n  v0 = shra(v0, 44);\n  v0 = shra(v0, 3);\n  v0 = swap_two(v0, 4, 3);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 7, 6);\n  v0 = shra(v0, 59);\n  v0 = shra(v0, 38);\n  v0 = swap_bytes(v0);\n  v0 = swap_two(v0, 1, 5);\n  v0 = swap_bytes(v0);\n  v0 = shla(v0, 27);\n  v0 = xor(v0, 13751028607104816751);\n  v0 = shra(v0, 14);\n  v0 = shla(v0, 7);\n  v0 = shla(v0, 18);\n  v0 = shla(v0, 57);\n  v0 = xor(v0, 12989550924262916891);\n  v0 = xor(v0, 929788566303591270);\n  v0 = xor(v0, 10714451137995436577);\n  v0 = xor(v0, 9637405481907436618);\n  v0 = swap_two(v0, 5, 1);\n  v0 = shla(v0, 20);\n  v0 = shla(v0, 24);\n  v0 = shra(v0, 46);\n  v0 = shra(v0, 13);\n  v0 = xor(v0, 14510136432192624501);\n  v0 = shla(v0, 7);\n  v0 = xor(v0, 641209893495219690);\n  v0 = xor(v0, 6473287570272602621);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 4, 7);\n  v0 = xor_neighbor(v0);\n  v0 = shra(v0, 22);\n  v0 = shra(v0, 50);\n  v0 = xor_neighbor(v0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_four(uint64_t value) {\n    value = swap_two(value, 1, 7);\n    value = shla(value, 6);\n    value = swap_two(value, 2, 5);\n    value = shra(value, 57);\n    value = xor(value, 902179681853661902L);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 1);\n    value = xor_neighbor(value);\n    value = xor(value, 6764338754798371998L);\n    value = xor_neighbor(value);\n    value = shla(value, 6);\n    value = xor_neighbor(value);\n    value = shla(value, 33);\n    value = shra(value, 25);\n    value = xor_neighbor(value);\n    value = xor(value, 762415417889401952L);\n    value = swap_two(value, 6, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 14722425112553694635UL);\n    value = xor(value, 9800422926138268860UL);\n    value = xor_neighbor(value);\n    value = xor(value, 9644430456772077073UL);\n    value = shra(value, 8);\n    value = shra(value, 43);\n    value = xor(value, 7150187182015826299L);\n    value = swap_two(value, 3, 1);\n    value = swap_two(value, 5, 7);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shra(value, 59);\n    value = shra(value, 10);\n    value = xor_neighbor(value);\n    value = swap_two(value, 2, 1);\n    value = swap_two(value, 7, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 7246290916701591349L);\n    value = xor(value, 18203423676804128435UL);\n    value = xor(value, 18403139030640123059UL);\n    value = swap_two(value, 2, 4);\n    value = swap_two(value, 5, 4);\n    value = shra(value, 11);\n    value = xor_neighbor(value);\n    value = shla(value, 39);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = xor(value, 14382479493256805148UL);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 3, 5);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(swap_two)(long long, long long, long long);\nlong long(shla)(long long, long long);\nlong long(shra)(long long, long long);\nlong long (xor)(long long, long long);\nlong long(xor_neighbor)(long long);\nlong long(swap_bytes)(long long);\n\nlong long munge_four_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x10], Other Possible Types: unsigned long\n\n  v0 = a0;\n  v0 = swap_two(v0, 1, 7);\n  v0 = shla(v0, 6);\n  v0 = swap_two(v0, 2, 5);\n  v0 = shra(v0, 57);\n  v0 = xor(v0, 902179681853661902);\n  v0 = swap_two(v0, 5, 1);\n  v0 = shla(v0, 1);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 6764338754798371998);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 6);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 33);\n  v0 = shra(v0, 25);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 762415417889401952);\n  v0 = swap_two(v0, 6, 2);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 14722425112553694635);\n  v0 = xor(v0, 9800422926138268860);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 9644430456772077073);\n  v0 = shra(v0, 8);\n  v0 = shra(v0, 43);\n  v0 = xor(v0, 7150187182015826299);\n  v0 = swap_two(v0, 3, 1);\n  v0 = swap_two(v0, 5, 7);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = shra(v0, 59);\n  v0 = shra(v0, 10);\n  v0 = xor_neighbor(v0);\n  v0 = swap_two(v0, 2, 1);\n  v0 = swap_two(v0, 7, 2);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 7246290916701591349);\n  v0 = xor(v0, -243320396905423181);\n  v0 = xor(v0, -43605043069428557);\n  v0 = swap_two(v0, 2, 4);\n  v0 = swap_two(v0, 5, 4);\n  v0 = shra(v0, 11);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 39);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = xor(v0, 14382479493256805148);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  v0 = shla(v0, 35);\n  v0 = swap_two(v0, 3, 5);\n  v0 = xor_neighbor(v0);\n  v0 = swap_bytes(v0);\n  v0 = xor_neighbor(v0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"int munge_all(unsigned char *data) {\n    int i = 0;\n    uint64_t *base = ((void *)0);\n    uint64_t one;\n    uint64_t two;\n    uint64_t thr;\n    uint64_t fou;\n    read(0, data, 32);\n    for (i = 0; i < 32; i++) {\n        if (((data[i] < 65) || (122 < data[i])) && (data[i] != 32)) {\n            return 0;\n        } else if (data[i] == ']') {\n            return 0;\n        } else if (data[i] == '\\\\') {\n            return 0;\n        } else if (data[i] == '^') {\n            return 0;\n        } else if (data[i] == '`') {\n            return 0;\n        } else if (data[i] == '[') {\n            return 0;\n        }\n    }\n    base = (uint64_t *)data;\n    one = munge_one(base[0]);\n    two = munge_two(base[1]);\n    thr = munge_three(base[2]);\n    fou = munge_four(base[3]);\n    one = one ^ two ^ thr ^ fou;\n    if (one == 12754495720971571466UL) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(munge_one)(long long);\nlong long(munge_two)(long long);\nlong long(munge_three)(long long);\nlong long(munge_four)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[7];\n  unsigned long long field_8;\n  unsigned long long field_10;\n  unsigned long long field_18;\n} struct_0;\n\nlong long munge_all_name_conflict(struct_0 *a0) {\n  unsigned long v0; // [bp-0x38]\n  unsigned long v1; // [bp-0x30]\n  unsigned long v2; // [bp-0x28]\n  unsigned long v3; // [bp-0x20]\n  struct_0 *v4;     // [bp-0x18], Other Possible Types: unsigned long long [4]\n  unsigned int v5;  // [bp-0xc]\n\n  v5 = 0;\n  v4 = 0;\n  read(0, a0, 32);\n  for (v5 = 0; v5 <= 31; v5 += 1) {\n    if (((&a0->field_0)[v5] <= 64 || (&a0->field_0)[v5] > 122) &&\n        (&a0->field_0)[v5] != 32)\n      return 0;\n    if ((&a0->field_0)[v5] == 93)\n      return 0;\n    if ((&a0->field_0)[v5] == 92)\n      return 0;\n    if ((&a0->field_0)[v5] == 94)\n      return 0;\n    if ((&a0->field_0)[v5] == 96) {\n      return 0;\n    } else if ((&a0->field_0)[v5] == 91) {\n      return 0;\n    }\n  }\n  v4[0] = a0;\n  v3 = munge_one(v4[0]);\n  v2 = munge_two(v4[1]);\n  v1 = munge_three(v4[2]);\n  v0 = munge_four(v4[3]);\n  v3 = v3 ^ v2 ^ v1 ^ v0;\n  return (v3 == 12754495720971571466 ? 0 : 1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:61:11: error: assigning to 'struct_0' (aka 'struct\nstruct_0') from incompatible type 'struct_0 *' (aka 'struct struct_0 *');\ndereference with * 61 |     v4[0] = a0; |           ^ ~~ |             *\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:62:20: error: passing 'struct_0' (aka 'struct\nstruct_0') to parameter of incompatible type 'long long' 62 |     v3 =\nmunge_one(v4[0]); |                    ^~~~~ /tmp/tmpi42ugthi/munge_all_name_conflict.c:17:32:\nnote: passing argument to parameter here 17 | long long (munge_one)(long long);\n      |                                ^\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:63:20: error: passing 'struct_0' (aka 'struct\nstruct_0') to parameter of incompatible type 'long long' 63 |     v2 =\nmunge_two(v4[1]); |                    ^~~~~ /tmp/tmpi42ugthi/munge_all_name_conflict.c:18:32:\nnote: passing argument to parameter here 18 | long long (munge_two)(long long);\n      |                                ^\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:64:22: error: passing 'struct_0' (aka 'struct\nstruct_0') to parameter of incompatible type 'long long' 64 |     v1 =\nmunge_three(v4[2]); |                      ^~~~~\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:19:34: note: passing argument to parameter here\n   19 | long long (munge_three)(long long);\n      |                                  ^\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:65:21: error: passing 'struct_0' (aka 'struct\nstruct_0') to parameter of incompatible type 'long long' 65 |     v0 =\nmunge_four(v4[3]); |                     ^~~~~\n/tmp/tmpi42ugthi/munge_all_name_conflict.c:20:33: note: passing argument to parameter here\n   20 | long long (munge_four)(long long);\n      |                                 ^\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"int countLiveNeighbors(int x, int y) {\n    int ret = 0;\n    int bit = ((y * 110) + x);\n    if (y > 0) {\n        if ((bit_field[(bit - 110) / 8] & (1 << (7 - ((bit - 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit - 110) - 1) / 8] & (1 << (7 - (((bit - 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit - 110) + 1) / 8] & (1 << (7 - (((bit - 110) + 1) % 8)))))\n            ret++;\n    }\n    if ((x > 0) && (bit_field[(bit - 1) / 8] & (1 << (7 - ((bit - 1) % 8)))))\n        ret++;\n    if ((x < (110 - 1)) && (bit_field[(bit + 1) / 8] & (1 << (7 - ((bit + 1) % 8)))))\n        ret++;\n    if (y < (110 - 1)) {\n        if ((bit_field[(bit + 110) / 8] & (1 << (7 - ((bit + 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit + 110) - 1) / 8] & (1 << (7 - (((bit + 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit + 110) + 1) / 8] & (1 << (7 - (((bit + 110) + 1) % 8)))))\n            ret++;\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long bit_field;\n\nlong long countLiveNeighbors_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x10]\n  unsigned int v1;        // [bp-0xc]\n  unsigned int v3;        // eax\n  unsigned long long v5;  // rax\n  unsigned int v6;        // eax\n  unsigned long long v8;  // rax\n  unsigned int v9;        // eax\n  unsigned long long v11; // rax\n  unsigned int v12;       // eax\n  unsigned long long v14; // rax\n  unsigned int v15;       // eax\n  unsigned long long v17; // rax\n  unsigned int v18;       // eax\n  unsigned long long v20; // rax\n  unsigned int v21;       // eax\n  unsigned long long v23; // rax\n  unsigned int v24;       // eax\n  unsigned long long v26; // rax\n\n  v1 = 0;\n  v0 = (unsigned int)a0 + (unsigned int)a1 * 110;\n  if ((unsigned int)a1 > 0) {\n    v3 = v0 - 110;\n    v5 = *((char *)(((v3 < 0 ? v3 + 7 : v3) >> 3) + bit_field));\n    if (...)\n      v1 += 1;\n    if ((unsigned int)a0 > 0) {\n      v6 = v0 - 111;\n      v8 = *((char *)(((v6 < 0 ? v6 + 7 : v6) >> 3) + bit_field));\n      if (...)\n        v1 += 1;\n    }\n    if ((unsigned int)a0 <= 108) {\n      v9 = v0 - 109;\n      v11 = *((char *)(((v9 < 0 ? v9 + 7 : v9) >> 3) + bit_field));\n      if (...)\n        v1 += 1;\n    }\n  }\n  if ((unsigned int)a0 > 0) {\n    v12 = v0 - 1;\n    v14 = *((char *)(((v12 < 0 ? v12 + 7 : v12) >> 3) + bit_field));\n    if (...)\n      v1 += 1;\n  }\n  if ((unsigned int)a0 <= 108) {\n    v15 = v0 + 1;\n    v17 = *((char *)(((v15 < 0 ? v15 + 7 : v15) >> 3) + bit_field));\n    if (...)\n      v1 += 1;\n  }\n  if ((unsigned int)a1 > 108)\n    return v1;\n  v18 = v0 + 110;\n  v20 = *((char *)(((v18 < 0 ? v18 + 7 : v18) >> 3) + bit_field));\n  if (...)\n    v1 += 1;\n  if ((unsigned int)a0 > 0) {\n    v21 = v0 + 109;\n    v23 = *((char *)(((v21 < 0 ? v21 + 7 : v21) >> 3) + bit_field));\n    if (...)\n      v1 += 1;\n  }\n  if ((unsigned int)a0 > 108)\n    return v1;\n  v24 = v0 + 111;\n  v26 = *((char *)(((v24 < 0 ? v24 + 7 : v24) >> 3) + bit_field));\n  if (...)\n    v1 += 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:46:13: error: expected expression\n   46 |         if (...)\n      |             ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:52:17: error: expected expression\n   52 |             if (...)\n      |                 ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:59:17: error: expected expression\n   59 |             if (...)\n      |                 ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:67:13: error: expected expression\n   67 |         if (...)\n      |             ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:74:13: error: expected expression\n   74 |         if (...)\n      |             ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:81:9: error: expected expression\n   81 |     if (...)\n      |         ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:87:13: error: expected expression\n   87 |         if (...)\n      |             ^\n/tmp/tmpz9hputid/countLiveNeighbors_name_conflict.c:94:9: error: expected expression\n   94 |     if (...)\n      |         ^\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":0,"function":"int processCoord(int x, int y) {\n    int ret;\n    if (x < 0 || y < 0) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    if ((x >= 110) || (y >= 110)) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    ret = (y * 110) + x;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *__TMC_END__;\n\nlong long processCoord_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  if ((unsigned int)a0 >= 0 && (unsigned int)a1 >= 0) {\n    if (!((unsigned int)a0 <= 109 && (unsigned int)a1 <= 109)) {\n      puts(\"Illegal Coordinate!\");\n      fflush(__TMC_END__);\n      exit(-1); /* do not return */\n    }\n    v0 = (unsigned int)a0 + (unsigned int)a1 * 110;\n    return v0;\n  }\n  puts(\"Illegal Coordinate!\");\n  fflush(__TMC_END__);\n  exit(-1); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmez2uzmo/processCoord_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 17 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":1,"function":"unsigned int FindRoot(unsigned int *set, unsigned int node) {\n    if (set[node] == node)\n        return node;\n    else\n        return FindRoot(set, set[node]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(FindRoot_name_conflict)(unsigned int *, unsigned long);\n\nlong long FindRoot_name_conflict(unsigned int *a0, unsigned long a1) {\n  if ((unsigned int)a1 != a0[(unsigned int)a1])\n    return FindRoot_name_conflict(a0, a0[(unsigned int)a1]);\n  return (unsigned int)a1;\n}\n","pass":1,"source_file":"C_COMPILE/arnikz_netclust/src/netclust.c"}
{"compilable":0,"function":"int udp_epoll_add(int epollfd, int fd, U32 u32flag) {\n    int ret = -1;\n    int block_opt = 0;\n    struct epoll_event event;\n    if (epollfd == 0 || fd == 0) {\n        ;\n        return (-1);\n    }\n    event.data.fd = fd;\n    event.events = u32flag;\n    ret = epoll_ctl(epollfd, 1, fd, &event);\n    if (ret < 0) {\n        ;\n        return (-1);\n    }\n    block_opt = fcntl(fd, 3) | 2048;\n    fcntl(fd, 4, block_opt);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long udp_epoll_add_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned int v1;       // [bp-0x18]\n  unsigned int v2;       // [bp-0x10]\n  unsigned int v3;       // [bp-0xc]\n  unsigned long long v6; // rax\n\n  v3 = -1;\n  v2 = 0;\n  if ((unsigned int)a0 && (unsigned int)a1) {\n    v1 = a1;\n    v0 = a2;\n    v3 = epoll_ctl((unsigned int)a0, 1, (unsigned int)a1, &v0);\n    if (v3 < 0)\n      return 4294967295;\n    (unsigned int)v6 = fcntl(a1, 3);\n    *((char *)&v6) = (char)v6 | 8;\n    v2 = v6;\n    fcntl(a1, 4);\n    return 0;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpslyi_w2j/udp_epoll_add_name_conflict.c:35:9: error: assignment to cast is illegal,\nlvalue casts are not supported 35 |         (unsigned int)v6 = fcntl(a1, 3); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_setup(INSTANCE_T *pinst) {\n    int ret = -1;\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    pinst->epollfd = epoll_create(5);\n    if (pinst->epollfd == -1) {\n        ;\n        return (-1);\n    }\n    ret = socketpair(1, SOCK_STREAM, 0, pinst->pipefd);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    ret |= udp_epoll_add(pinst->epollfd, pinst->pipefd[0], EPOLLIN | EPOLLET);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    int block_opt = fcntl(pinst->pipefd[1], 3) | 2048;\n    fcntl(pinst->pipefd[1], 4, block_opt);\n    g_sig_fd = pinst->pipefd[1];\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socketpair)(int, int, int, int(32 bits)[2]);\nlong long(udp_epoll_add)(long long, long long, long long);\nint(fcntl)(int, int, ...);\n\nextern unsigned int g_sig_fd;\n\nlong long udp_epoll_setup_name_conflict(unsigned int a0[8]) {\n  unsigned int v0;       // [bp-0x10]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n  unsigned long long v6; // rax\n\n  v4 = &v2;\n  v1 = -1;\n  if (!a0)\n    return 4294967295;\n  a0[5] = epoll_create(5);\n  if (a0[5] == -1)\n    return 4294967295;\n  v1 = socketpair(1, 1, 0, (unsigned int[8]) & a0[6]);\n  if (v1)\n    return 4294967295;\n  v1 |= (int)udp_epoll_add(a0[5], a0[6], 2147483649);\n  if (v1)\n    return 4294967295;\n  (unsigned int)v6 = fcntl(a0[7], 3);\n  *((char *)&v6) = (char)v6 | 8;\n  v0 = v6;\n  fcntl(a0[7], 4);\n  g_sig_fd = a0[7];\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8hq725xy/udp_epoll_setup_name_conflict.c:16:38: error: expected ')'\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                      ^\n/tmp/tmp8hq725xy/udp_epoll_setup_name_conflict.c:16:37: note: to match this '('\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                     ^\n/tmp/tmp8hq725xy/udp_epoll_setup_name_conflict.c:37:30: error: used type 'unsigned int[8]'\nwhere arithmetic or pointer type is required 37 |     v1 = socketpair(1, 1, 0,\n(unsigned int [8])&a0[6]); |                              ^ ~~~~~~\n/tmp/tmp8hq725xy/udp_epoll_setup_name_conflict.c:43:5: error: assignment to cast is illegal,\nlvalue casts are not supported 43 |     (unsigned int)v6 = fcntl(a0[7], 3); |\n^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_shutdown(const INSTANCE_T *pinst) {\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    close(pinst->pipefd[0]);\n    close(pinst->pipefd[1]);\n    close(pinst->epollfd);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long udp_epoll_shutdown_name_conflict(unsigned int a0[8]) {\n  if (!a0)\n    return 4294967295;\n  close(a0[6]);\n  close(a0[7]);\n  close(a0[5]);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_listen(INSTANCE_T *pinst) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    struct sockaddr_in lsn_addr = {0};\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    pinst->lsn_fd = socket(2, SOCK_DGRAM, 0);\n    if (pinst->lsn_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = setsockopt(pinst->lsn_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    memset(&lsn_addr, 0, sizeof (lsn_addr));\n    lsn_addr.sin_family = 2;\n    lsn_addr.sin_port = pinst->task.nlsn_port;\n    lsn_addr.sin_addr.s_addr = pinst->task.u32lsn_ip;\n    ret = bind(pinst->lsn_fd, (struct sockaddr *)&lsn_addr, sizeof(struct sockaddr_in));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    goto _S0;\n  _E2:\n    close(pinst->lsn_fd);\n  _E1:\n    pinst->lsn_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(setsockopt)(int, int, int, void *, int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(close)(int);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n  char padding_8[8];\n  unsigned int field_10;\n} struct_0;\n\nlong long udp_core_listen_name_conflict(struct_0 *a0) {\n  void *v0;          // [bp-0x28], Other Possible Types: unsigned short\n  unsigned short v1; // [bp-0x26]\n  unsigned int v2;   // [bp-0x24]\n  void *v3;          // [bp-0x20]\n  unsigned int v4;   // [bp-0x18]\n  unsigned int v5;   // [bp-0x14]\n  unsigned int v6;   // [bp-0x10]\n  unsigned int v7;   // [bp-0xc]\n\n  v7 = 0;\n  v4 = 1;\n  v6 = 65535;\n  v5 = 65535;\n  v0 = 0;\n  v3 = 0;\n  if (a0) {\n    a0->field_10 = socket(2, 2, 0);\n    if (a0->field_10 >= 0) {\n      v7 = setsockopt(a0->field_10, 1, 2, &v4, 4);\n      if (v7 >= 0) {\n        memset(&v0, 0, 16);\n        v0 = 2;\n        v1 = a0->field_0;\n        v2 = a0->field_4;\n        v7 = bind(a0->field_10, &v0, 16);\n        if (v7 >= 0)\n          return 0;\n      }\n      close(a0->field_10);\n    }\n  }\n  a0->field_10 = 0;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_connect(struct sockaddr_in *psrv_addr, struct sockaddr_in *plcl_addr, int *psrv_fd) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    socklen_t socklen = sizeof(struct sockaddr_in);\n    if (!psrv_addr || !plcl_addr) {\n        ;\n        goto _E1;\n    }\n    *psrv_fd = socket(2, SOCK_DGRAM, 0);\n    if (*psrv_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = bind(*psrv_fd, (struct sockaddr *)plcl_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = setsockopt(*psrv_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = connect(*psrv_fd, (struct sockaddr *)psrv_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    int block_opt = fcntl(*psrv_fd, 3) | 2048;\n    fcntl(*psrv_fd, 4, block_opt);\n    goto _S0;\n  _E2:\n    close(*psrv_fd);\n  _E1:\n    *psrv_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(setsockopt)(int, int, int, void *, int);\nint(close)(int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(fcntl)(int, int, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long udp_core_connect_name_conflict(sockaddr *a0, sockaddr *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x20]\n  unsigned int v1;       // [bp-0x1c]\n  unsigned int v2;       // [bp-0x18]\n  unsigned int v3;       // [bp-0x14]\n  unsigned int v4;       // [bp-0x10]\n  unsigned int v5;       // [bp-0xc]\n  unsigned long long v7; // rax\n\n  v5 = 0;\n  v0 = 1;\n  v4 = 65535;\n  v3 = 65535;\n  v2 = 16;\n  if (!(!a0 || !a1)) {\n    *(a2) = socket(2, 2, 0);\n    if (*(a2) >= 0) {\n      v5 = bind(*(a2), a1, v2);\n      if (v5 >= 0) {\n        v5 = setsockopt(*(a2), 1, 2, &v0, 4);\n        if (v5 >= 0) {\n          v5 = connect(*(a2), a0, v2);\n          if (v5 >= 0) {\n            (unsigned int)v7 = fcntl(*(a2), 3);\n            *((char *)&v7) = (char)v7 | 8;\n            v1 = v7;\n            fcntl(*(a2), 4);\n            return 0;\n          }\n        }\n      }\n      close(*(a2));\n    }\n  }\n  *(a2) = 0;\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkye36f7m/udp_core_connect_name_conflict.c:63:25: error: assignment to cast is illegal,\nlvalue casts are not supported 63 |                         (unsigned int)v7 =\nfcntl(*(a2), 3); |                         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_send_nonblock(int fd, const char *pbuf, size_t bufsize) {\n    int ret = (-1);\n    if (!pbuf) {\n        ;\n        return (-1);\n    }\n    while (ret < 0)\n        {\n            ret = send(fd, pbuf, bufsize, 0);\n            if (ret < 0) {\n                if ((*__errno_location()) == 11) {\n                    ;\n                    usleep(10);\n                    continue;\n                } else {\n                    return (-1);\n                }\n            }\n        }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\nchar *(usleep)(char *);\n\nlong long udp_send_nonblock_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = -1;\n  if (!a1)\n    return 4294967295;\n  while (true) {\n    do {\n      if (v0 >= 0)\n        return v0;\n    } while (\n        (v0 = (unsigned int)(int)send((unsigned int)a0, a1, a2, 0), v0 >= 0));\n    if (*(__errno_location()) != 11)\n      break;\n    usleep(0xa);\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp109gjqgm/udp_send_nonblock_name_conflict.c:33:13: error: indirection requires pointer\noperand ('int' invalid) 33 |         if (*(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_add(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    snprintf(cmd, sizeof (cmd), \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n    ;\n    system(cmd);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(ntohs)(unsigned short);\nlong long(ip_ntoa)(long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\nint(system)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[2];\n  unsigned short field_2;\n  unsigned short field_4;\n  char padding_6[10];\n  unsigned int field_10;\n  unsigned int field_14;\n} struct_0;\n\nlong long udp_snat_add_name_conflict(struct_0 *a0) {\n  struct_0 *v0;            // [bp-0x250]\n  void *v1;                // [bp-0x248]\n  void *v2;                // [bp-0x240]\n  void *v3;                // [bp-0x238]\n  void *v4;                // [bp-0x230]\n  void *v5;                // [bp-0x228]\n  void *v6;                // [bp-0x220]\n  char v7;                 // [bp-0x218]\n  unsigned long v9;        // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v10; // rdi, Other Possible Types: unsigned long\n  unsigned long v11;       // d\n\n  v0 = a0;\n  v5 = 0;\n  v6 = 0;\n  v9 = 62;\n  for (v10 = &v7; v9; v10 += v11 * 8) {\n    v9 -= 1;\n    *((long long *)v10) = 0;\n  }\n  v3 = 0;\n  v4 = 0;\n  v1 = 0;\n  v2 = 0;\n  if (!v0)\n    return 4294967295;\n  snprintf(&v5, 0x200,\n           \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n           \"--to %s:%u\",\n           (int)ip_ntoa(v0->field_14, &v3), ntohs(v0->field_2),\n           (int)ip_ntoa(v0->field_10, &v1), ntohs(v0->field_4));\n  system(&v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp35bcivn4/udp_snat_add_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_del(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    if (proxy_app->udp_type & UDP_TYPE_CLIENT) {\n        snprintf(cmd, sizeof (cmd), \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n        ;\n    }\n    system(cmd);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(system)(char *);\nunsigned short(ntohs)(unsigned short);\nlong long(ip_ntoa)(long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned short field_4;\n  char padding_6[10];\n  unsigned int field_10;\n  unsigned int field_14;\n} struct_0;\n\nlong long udp_snat_del_name_conflict(struct_0 *a0) {\n  struct_0 *v0;            // [bp-0x250]\n  void *v1;                // [bp-0x248]\n  void *v2;                // [bp-0x240]\n  void *v3;                // [bp-0x238]\n  void *v4;                // [bp-0x230]\n  void *v5;                // [bp-0x228]\n  void *v6;                // [bp-0x220]\n  char v7;                 // [bp-0x218]\n  unsigned long v9;        // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v10; // rdi, Other Possible Types: unsigned long\n  unsigned long v11;       // d\n\n  v0 = a0;\n  v5 = 0;\n  v6 = 0;\n  v9 = 62;\n  for (v10 = &v7; v9; v10 += v11 * 8) {\n    v9 -= 1;\n    *((long long *)v10) = 0;\n  }\n  v3 = 0;\n  v4 = 0;\n  v1 = 0;\n  v2 = 0;\n  if (!v0)\n    return 4294967295;\n  if (((char)v0->field_0 & 8))\n    snprintf(&v5, 0x200,\n             \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n             \"--to %s:%u\",\n             (int)ip_ntoa(v0->field_14, &v3), ntohs(v0->field_2),\n             (int)ip_ntoa(v0->field_10, &v1), ntohs(v0->field_4));\n  system(&v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk74nxiwu/udp_snat_del_name_conflict.c:19:6: error: conflicting types for 'snprintf'\n   19 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_request(const INSTANCE_T *pinst, char *pbuf) {\n    int ret = 0;\n    int srv_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    char debug[16] = {0};\n    char *pdata = ((void *)0);\n    UDP_HEAD *phead = ((void *)0);\n    TIMER_T *ptimer = ((void *)0);\n    struct sockaddr_in clt_addr = {0};\n    socklen_t clt_len = sizeof (clt_addr);\n    dsp_time(385, \"\");\n    if (!pbuf) {\n        ;\n        goto _E1;\n    }\n    phead = (UDP_HEAD *)pbuf;\n    pdata = pbuf + sizeof(UDP_HEAD);\n    memset(phead, 0, sizeof(UDP_HEAD));\n    if (recv_byte < 0) {\n        ;\n        goto _E1;\n    }\n    ;\n    ptimer = time_wheel_search_by_addr(clt_addr);\n    if (!ptimer) {\n        ptimer = udp_connection_setup(pinst, phead, &clt_addr, &srv_fd);\n        if (!ptimer) {\n            ;\n            goto _E1;\n        }\n        dsp_time(417, \"udp_connection_setup\");\n    } else {\n        srv_fd = ptimer->proxy_app.srv_fd;\n        ret = time_wheel_refresh(ptimer, 2);\n        if (!ptimer) {\n            ;\n            goto _E2;\n        }\n        dsp_time(426, \"time_wheel_refresh\");\n    }\n    if (send_byte < 0) {\n        ;\n        goto _E2;\n    }\n    dsp_time(443, \"udp_epoll_handler_request\");\n    goto _S0;\n  _E2:\n    time_wheel_del(&ptimer);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(dsp_time)(long long, long long);\nlong long(time_wheel_search_by_addr)(long long, long long);\nlong long(udp_connection_setup)(long long, long long, long long, long long);\nlong long(time_wheel_refresh)(long long, long long);\nlong long(time_wheel_del)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  unsigned int field_8;\n} struct_0;\n\nextern unsigned long long g_4030a2;\n\nlong long udp_epoll_handler_request_name_conflict(unsigned long long a0, unsigned long a1) {\n  void *v0;         // [bp-0x68]\n  void *v1;         // [bp-0x60]\n  struct_0 *v2;     // [bp-0x50]\n  void *v3;         // [bp-0x48]\n  void *v4;         // [bp-0x40]\n  unsigned int v5;  // [bp-0x30]\n  unsigned int v6;  // [bp-0x2c]\n  void *v7;         // [bp-0x28]\n  void *v8;         // [bp-0x20], Other Possible Types: unsigned long\n  unsigned int v9;  // [bp-0x14]\n  unsigned int v10; // [bp-0x10]\n  unsigned int v11; // [bp-0xc]\n\n  v11 = 0;\n  v5 = 0;\n  v10 = 0;\n  v9 = 0;\n  v3 = 0;\n  v4 = 0;\n  v8 = 0;\n  v7 = 0;\n  v2 = 0;\n  v0 = 0;\n  v1 = 0;\n  v6 = 16;\n  dsp_time(384, &g_4030a2);\n  if (!a1) {\n    goto LABEL_401eb7;\n  } else {\n    v7 = a1;\n    v8 = a1 + 16;\n    memset(v7, 0, 16);\n    if (v10 < 0) {\n      goto LABEL_401eb7;\n    } else {\n      v2 = time_wheel_search_by_addr(v0, v1);\n      if (v2) {\n        v5 = v2->field_8;\n        v11 = time_wheel_refresh(v2, 2);\n        if (!v2) {\n          time_wheel_del(&v2);\n        LABEL_401eb7:\n          return 4294967295;\n        }\n        dsp_time(425, \"time_wheel_refresh\");\n      } else {\n        v2 = udp_connection_setup(a0, v7, &v0, &v5);\n        if (!v2)\n          return 4294967295;\n        dsp_time(416, \"udp_connection_setup\");\n      }\n      if (v9 < 0) {\n        time_wheel_del(&v2);\n      LABEL_401eb7:\n        return 4294967295;\n      }\n      dsp_time(442, \"udp_epoll_handler_request_name_conflict\");\n      return 0;\n    }\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnaace8nu/udp_epoll_handler_request_name_conflict.c:95:1: error: redefinition of label\n'LABEL_401eb7' 95 | LABEL_401eb7: | ^\n/tmp/tmpnaace8nu/udp_epoll_handler_request_name_conflict.c:80:1: note: previous definition is\nhere 80 | LABEL_401eb7: | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_respone(const INSTANCE_T *pinst, int srv_fd, char *pbuf) {\n    int ret = 0;\n    int clt_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    struct sockaddr_in srv_addr = {0};\n    socklen_t clt_len = sizeof(struct sockaddr_in);\n    TIMER_T *ptimer = ((void *)0);\n    recv_byte = recv(srv_fd, pbuf, 65535, 0);\n    if (recv_byte <= 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    ptimer = time_wheel_search_by_fd(srv_fd);\n    if (!ptimer) {\n        ;\n        goto _E2;\n    }\n    ret = time_wheel_refresh(ptimer, 2);\n    if (!ptimer) {\n        ;\n        goto _E3;\n    }\n    clt_fd = ptimer->proxy_app.clt_fd;\n    send_byte = sendto(clt_fd, pbuf, recv_byte, 0, (struct sockaddr *)&ptimer->proxy_app.clt_addr, clt_len);\n    if (send_byte <= 0) {\n        ;\n        goto _E3;\n    }\n    goto _S0;\n  _E3:\n    time_wheel_del(&ptimer);\n  _E2:\n    close(srv_fd);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\nlong long(time_wheel_search_by_fd)(long long);\nint(close)(int);\nlong long(time_wheel_refresh)(long long, long long);\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(time_wheel_del)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[12];\n  unsigned int field_c;\n} struct_0;\n\nlong long udp_epoll_handler_respone(unsigned long a0, unsigned long a1,\n                                    void *a2) {\n  char v0;          // [bp-0x54]\n  unsigned long v1; // [bp-0x50]\n  struct_0 *v2;     // [bp-0x40]\n  void *v3;         // [bp-0x38]\n  void *v4;         // [bp-0x30]\n  unsigned int v5;  // [bp-0x1c]\n  unsigned int v6;  // [bp-0x18]\n  unsigned int v7;  // [bp-0x14]\n  unsigned int v8;  // [bp-0x10]\n  unsigned int v9;  // [bp-0xc]\n\n  v1 = a0;\n  v9 = 0;\n  v8 = 0;\n  v7 = 0;\n  v6 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 16;\n  v2 = 0;\n  v7 = recv(a1, a2, 65535, 0);\n  if (v7 > 0) {\n    v2 = time_wheel_search_by_fd(*((int *)&v0));\n    if (v2) {\n      v9 = time_wheel_refresh(v2, 2);\n      if (v2) {\n        v8 = v2->field_c;\n        v6 = sendto(v8, a2, v7, 0, &v2[1].padding_0[8], v5);\n        if (v6 > 0)\n          return 0;\n      }\n      time_wheel_del(&v2);\n    }\n  }\n  close(*((int *)&v0));\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_signal(int pipefd) {\n    int ret = 0;\n    int sig = 0;\n    int jx = 0;\n    char signals[1024];\n    ret = recv(pipefd, signals, sizeof (signals), 0);\n    if (ret <= 0) {\n        ;\n        return (-1);\n    } else {\n        for (jx = 0; jx < ret; jx++) {\n            switch (signals[jx]) {\n              case 14:\n                g_timeout = 1;\n                break;\n              case 2:\n              case 15:\n                ;\n                g_enable = 0;\n                break;\n              default:\n                break;\n            }\n        }\n    }\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\n\nextern unsigned int g_enable;\nextern unsigned int g_timeout;\n\nlong long udp_epoll_handler_signal_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x418]\n  unsigned int v1; // [bp-0x14]\n  unsigned int v2; // [bp-0x10]\n  unsigned int v3; // [bp-0xc]\n  unsigned int v6; // eax\n\n  v2 = 0;\n  v1 = 0;\n  v3 = 0;\n  v2 = recv(a0, &v0, 0x400, 0);\n  if (v2 <= 0)\n    return 4294967295;\n  v3 = 0;\n  while (v3 < v2) {\n    v6 = (&v0)[v3];\n    if (v6 == 15) {\n      g_enable = 0;\n      goto LABEL_402072;\n    } else if (v6 > 15) {\n    LABEL_402072:\n      v3 += 1;\n    } else if (v6 != 2 && v6 == 14) {\n      g_timeout = 1;\n      goto LABEL_402072;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler(const INSTANCE_T *pinst) {\n    char *buffer = ((void *)0);\n    int ret = 0;\n    int ix = 0;\n    int sockfd = 0;\n    int timeout = 0;\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    buffer = (char *)malloc(sizeof(char) * 65535);\n    if (!buffer) {\n        ;\n        goto _E1;\n    }\n    int epoll_num = 0;\n    struct epoll_event events[65535] = {0};\n    while (g_enable)\n        {\n            epoll_num = epoll_wait(pinst->epollfd, events, 65535, -1);\n            if (epoll_num < 0 && (*__errno_location()) != 4) {\n                ;\n                goto _E2;\n            }\n            for (ix = 0; ix < epoll_num; ix++) {\n                sockfd = events[ix].data.fd;\n                if (sockfd == pinst->lsn_fd) {\n                    ret = udp_epoll_handler_request(pinst, buffer);\n                    if (ret != (0)) {\n                        ;\n                    }\n                } else if (sockfd == pinst->pipefd[0]) {\n                    ret = udp_epoll_handler_signal(pinst->pipefd[0]);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else if (events[ix].events & EPOLLIN) {\n                    ret = udp_epoll_handler_respone(pinst, sockfd, buffer);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else {\n                }\n                if (g_timeout) {\n                    time_wheel_tick();\n                    alarm(10);\n                    g_timeout = 0;\n                    continue;\n                }\n            }\n        }\n    goto _S0;\n  _E2:\n    free(buffer);\n    buffer = ((void *)0);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(udp_epoll_handler_name_conflict_request)(long long, long long);\nlong long(udp_epoll_handler_name_conflict_signal)(long long);\nlong long(udp_epoll_handler_name_conflict_respone)(long long, long long, long long);\nlong long(time_wheel_tick)();\nunsigned int(alarm)(unsigned int);\n\nextern unsigned int g_enable;\nextern unsigned int g_timeout;\n\nlong long udp_epoll_handler_name_conflict(unsigned int a0[7]) {\n  char v0;         // [bp-0xc0028]\n  char v1;         // [bp-0xc0024]\n  unsigned int v2; // [bp-0x28]\n  unsigned int v3; // [bp-0x24]\n  unsigned int v4; // [bp-0x20]\n  unsigned int v5; // [bp-0x1c]\n  void *v6;        // [bp-0x18]\n  unsigned int v7; // [bp-0xc]\n\n  v6 = 0;\n  v5 = 0;\n  v7 = 0;\n  v4 = 0;\n  v3 = 0;\n  if (!a0)\n    return 4294967295;\n  v6 = malloc(65535);\n  if (v6) {\n    v2 = 0;\n    memset(&v0, 0, 786420);\n    while (true) {\n      if (!g_enable)\n        return 0;\n      v2 = epoll_wait(a0[5], &v0, 65535, 4294967295);\n      if (!(v2 < 0) || !(*(__errno_location()) != 4)) {\n        for (v7 = 0; v7 < v2; v7 += 1) {\n          v4 = *((int *)&(&v1)[12 * v7]);\n          if (v4 == a0[4]) {\n            v5 = udp_epoll_handler_name_conflict_request(a0, v6);\n          } else if (v4 == a0[6]) {\n            v5 = udp_epoll_handler_name_conflict_signal(a0[6]);\n            if (!v5)\n              goto LABEL_40220e;\n            else\n              goto LABEL_40225b;\n          } else if (!(!((char)*((int *)&(&v0)[12 * v7]) & 1)) &&\n                     !((v5 = (unsigned int)(int)udp_epoll_handler_name_conflict_respone(\n                            a0, (unsigned long long)v4, v6),\n                        !v5))) {\n            goto LABEL_40225b;\n          }\n        LABEL_40220e:\n          if (g_timeout) {\n            time_wheel_tick();\n            alarm(10);\n            g_timeout = 0;\n          }\n        }\n      } else {\n        break;\n      }\n    }\n  LABEL_40225b:\n    free(v6);\n    v6 = 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqhwrgzi3/udp_epoll_handler_name_conflict.c:53:32: error: indirection requires pointer\noperand ('int' invalid) 53 |             if (!(v2 < 0) ||\n!(*(__errno_location()) != 4)) | ^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int ip_aton(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[3], &val[2], &val[1], &val[0]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\nlong long ip_aton_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  v0 = 0;\n  if (!a0)\n    return 0;\n  __isoc99_sscanf(a0, \"%hhu.%hhu.%hhu.%hhu\", (unsigned int)&v0,\n                  (unsigned int)&v0, (unsigned int)&v0, (unsigned int)&v0);\n  do {\n    v1 *= 0x100;\n    v1 |= *((char *)&v0 + v2);\n    v2 += 1;\n  } while (v2 <= 3);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":0,"function":"int ip_atoh(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[0], &val[1], &val[2], &val[3]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\nlong long ip_atoh_name_conflict(char *a0) {\n  unsigned int v0; // [bp-0x14]\n  unsigned int v1; // [bp-0x10]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 0;\n  v1 = 0;\n  v0 = 0;\n  if (!a0)\n    return 0;\n  __isoc99_sscanf(a0, \"%hhu.%hhu.%hhu.%hhu\", (unsigned int)&v0,\n                  (unsigned int)&v0, (unsigned int)&v0, (unsigned int)&v0);\n  do {\n    v1 *= 0x100;\n    v1 |= *((char *)&v0 + v2);\n    v2 += 1;\n  } while (v2 <= 3);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_htoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip >> 24 & 255, sip >> 16 & 255, sip >> 8 & 255, sip & 255);\n    return rvip;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ip_htoa_name_conflict(unsigned long a0, char *a1) {\n  if (!a1)\n    return a1;\n  sprintf(a1, \"%d.%d.%d.%d\", (unsigned int)((unsigned int)a0 >> 24),\n          (unsigned int)((unsigned int)a0 >> 16),\n          (unsigned int)((unsigned int)a0 >> 8), (unsigned int)a0);\n  return a1;\n}\n","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_ntoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip & 255, sip >> 8 & 255, sip >> 16 & 255, sip >> 24 & 255);\n    return rvip;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ip_ntoa_name_conflict(unsigned long a0, char *a1) {\n  if (!a1)\n    return a1;\n  sprintf(a1, \"%d.%d.%d.%d\", (unsigned int)a0,\n          (unsigned int)((unsigned int)a0 >> 8),\n          (unsigned int)((unsigned int)a0 >> 16),\n          (unsigned int)((unsigned int)a0 >> 24));\n  return a1;\n}\n","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":0,"function":"int time_wheel_create() {\n    int i;\n    g_cur_slot = 0;\n    for (i = 0; i < 4; i++) {\n        gp_slots[i] = ((void *)0);\n    }\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int g_cur_slot;\nextern char gp_slots;\n\nlong long time_wheel_create_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  g_cur_slot = 0;\n  for (v0 = 0; v0 <= 3; v0 += 1) {\n    *((long long *)&(&gp_slots)[8 * v0]) = 0;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_destroy() {\n    int i;\n    TIMER_T *pt = ((void *)0);\n    for (i = 0; i < 4; i++) {\n        pt = gp_slots[i];\n        while (pt)\n            {\n                gp_slots[i] = pt->next;\n                free(pt);\n                pt = gp_slots[i];\n            }\n    }\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned long long field_38;\n} struct_0;\n\nextern char gp_slots;\n\nlong long time_wheel_destroy_name_conflict() {\n  struct_0 *v0;          // [bp-0x18], Other Possible Types: unsigned long\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v0 = 0;\n  for (v1 = 0; v1 <= 3; v1 += 1) {\n    for (v0 = *((long long *)&(&gp_slots)[8 * v1]); v0;\n         v0 = *((long long *)&(&gp_slots)[8 * v1])) {\n      *((unsigned long long *)&(&gp_slots)[8 * v1]) = v0->field_38;\n      free(v0);\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_tick() {\n    TIMER_T *pt = gp_slots[g_cur_slot];\n    TIMER_T *pn = ((void *)0);\n    ;\n    while (pt)\n        {\n            ;\n            if (pt->rotation > 0) {\n                pt->rotation--;\n                pt = pt->next;\n            } else {\n                ;\n                pt->cb_func(&pt->proxy_app);\n                if (pt == gp_slots[g_cur_slot]) {\n                    gp_slots[g_cur_slot] = pt->next;\n                    free(pt);\n                    if (gp_slots[g_cur_slot]) {\n                        gp_slots[g_cur_slot]->prev = ((void *)0);\n                    }\n                    pt = gp_slots[g_cur_slot];\n                } else {\n                    pt->prev->next = pt->next;\n                    if (pt->next) {\n                        pt->next->prev = pt->prev;\n                    }\n                    pn = pt->next;\n                    free(pt);\n                    pt = pn;\n                }\n            }\n        }\n    g_cur_slot = ++g_cur_slot % 4;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_2 {\n  char padding_0[40];\n  unsigned int field_28;\n  char padding_2c[4];\n  struct struct_1 *field_30;\n  struct struct_2 *field_38;\n  struct struct_0 *field_40;\n} struct_2;\n\ntypedef struct struct_1 {\n  struct struct_1 *field_0;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned long long field_38;\n} struct_0;\n\nextern unsigned int g_cur_slot;\nextern unsigned long long gp_slots[4];\n\nlong long time_wheel_tick_name_conflict() {\n  struct_2 *v0; // [bp-0x18]\n  struct_2 *v1; // [bp-0x10], Other Possible Types: unsigned long\n\n  v1 = gp_slots[g_cur_slot];\n  v0 = 0;\n  while (v1) {\n    if (*((int *)(v1 + 40)) > 0) {\n      *((int *)(v1 + 40)) = *((int *)(v1 + 40)) - 1;\n      v1 = *((long long *)(v1 + 56));\n    } else {\n      *((long long *)(v1 + 48))(v1);\n      if (v1 != gp_slots[g_cur_slot]) {\n        *((long long *)(*((long long *)(v1 + 64)) + 56)) =\n            *((long long *)(v1 + 56));\n        if (*((long long *)(v1 + 56)))\n          *((long long *)(*((long long *)(v1 + 56)) + 64)) =\n              *((long long *)(v1 + 64));\n        v0 = v1->field_38;\n        free(v1);\n        v1 = v0;\n      } else {\n        gp_slots[g_cur_slot] = *((long long *)(v1 + 56));\n        free(v1);\n        if (gp_slots[g_cur_slot])\n          *((long long *)(gp_slots[g_cur_slot] + 64)) = 0;\n        v1 = gp_slots[g_cur_slot];\n      }\n    }\n  }\n  g_cur_slot = g_cur_slot + 1;\n  g_cur_slot = ((unsigned int)(g_cur_slot + (g_cur_slot >> 31 >> 30)) & 3) -\n               (g_cur_slot >> 31 >> 30);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmz1gjdko/time_wheel_tick_name_conflict.c:54:38: error: called object type 'long long\n*' is not a function or function pointer 54 |             *((long long *)(v1 +\n48))(v1); |              ~~~~~~~~~~~~~~~~~~~~~~~~^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":1,"function":"int *make(int rows, int cols) {\n    return (int *)malloc(rows * cols * sizeof(int));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long make_name_conflict(unsigned long a0, unsigned long a1) {\n  return malloc((unsigned int)a1 * (unsigned int)a0 * 4);\n}\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"int penalty(int *lhs, int *rhs, int mwidth, int *individuum) {\n    int *l = make(mwidth, mwidth);\n    eval(lhs, mwidth, individuum, l);\n    int *r = make(mwidth, mwidth);\n    eval(rhs, mwidth, individuum, r);\n    int s = 0;\n    for (int row = 0; row < mwidth; row++) {\n        for (int col = 0; col < mwidth; col++) {\n            int x = l[row * mwidth + col];\n            int y = r[row * mwidth + col];\n            int p = 0;\n            if ((row == 0) && (col == mwidth - 1)) {\n                p = (x > y) ? 0 : 10000 * (y - x + 1);\n            } else {\n                p = (x >= y) ? 0 : y * y - x * x;\n            }\n            if (p > 1000000)\n                p = 1000000;\n            s += p;\n        }\n    }\n    free(l);\n    free(r);\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(make)(long long, long long);\nlong long(eval)(long long, long long, long long, long long);\n\nlong long penalty(unsigned long long a0, unsigned long long a1,\n                  unsigned long a2, unsigned long long a3) {\n  unsigned int v0; // [bp-0x30]\n  unsigned int v1; // [bp-0x2c]\n  void *v2;        // [bp-0x28]\n  void *v3;        // [bp-0x20]\n  unsigned int v4; // [bp-0x18]\n  unsigned int v5; // [bp-0x14]\n  unsigned int v6; // [bp-0x10]\n  unsigned int v7; // [bp-0xc]\n\n  v3 = make((unsigned int)a2, (unsigned int)a2);\n  eval(a0, (unsigned int)a2, a3, v3);\n  v2 = make((unsigned int)a2, (unsigned int)a2);\n  eval(a1, (unsigned int)a2, a3, v2);\n  v7 = 0;\n  for (v6 = 0; v6 < (unsigned int)a2; v6 += 1) {\n    for (v5 = 0; v5 < (unsigned int)a2; v5 += 1) {\n      v1 = *((int *)((char *)v3 + 4 * v5 + 4 * (unsigned int)a2 * v6));\n      v0 = *((int *)((char *)v2 + 4 * v5 + 4 * (unsigned int)a2 * v6));\n      v4 = 0;\n      if (v6 || v5 != (unsigned int)a2 - 1)\n        v4 = (v1 < v0 ? 0 : v0 * v0 - v1 * v1);\n      else\n        v4 = (v1 <= v0 ? 0 : (v0 - v1 + 1) * 10000);\n      if (v4 > 1000000)\n        v4 = 1000000;\n      v7 += v4;\n    }\n  }\n  free(v3);\n  free(v2);\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"int anneal(int total, int *lhs, int *rhs, int mcount, int mwidth, int *individuum) {\n    int best = penalty(lhs, rhs, mwidth, individuum);\n    if (0 == best)\n        return 0;\n    size_t s = mcount * mwidth * mwidth * sizeof(int);\n    int *candidate = malloc(s);\n    for (int steps = 0; steps < total; steps++) {\n        memcpy(candidate, individuum, s);\n        mutate(mcount, mwidth, candidate);\n        int p = penalty(lhs, rhs, mwidth, candidate);\n        int luck = 0 == random() % total;\n        if (p <= best || luck) {\n            memcpy(individuum, candidate, s);\n            best = p;\n        }\n    }\n    free(candidate);\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(penalty)(long long, long long, long long, long long);\nlong long(mutate)(long long, long long, long long);\nlong(random)();\n\nlong long anneal(unsigned long a0, unsigned long long a1, unsigned long long a2,\n                 unsigned long a3, unsigned long a4, void *a5) {\n  unsigned int v0;       // [bp-0x28]\n  unsigned int v1;       // [bp-0x24]\n  void *v2;              // [bp-0x20]\n  unsigned int v3;       // [bp-0x18]\n  unsigned int v4;       // [bp-0x10]\n  unsigned int v5;       // [bp-0xc]\n  unsigned long long v8; // rax\n\n  v5 = penalty(a1, a2, (unsigned int)a4, a5);\n  if (!v5)\n    return 0;\n  *((unsigned long long *)&v3) =\n      (unsigned int)a4 * (unsigned int)a4 * (unsigned int)a3 * 4;\n  v2 = malloc(*((long long *)&v3));\n  for (v4 = 0; v4 < (unsigned int)a0; v4 += 1) {\n    memcpy(v2, a5, *((long long *)&v3));\n    mutate((unsigned int)a3, (unsigned int)a4, v2);\n    v1 = penalty(a1, a2, (unsigned int)a4, v2);\n    v8 = random();\n    v0 = !(v8 >> 63 CONCAT v8) / m(unsigned int) a0 >> 64;\n    if (v1 <= v5 || v0) {\n      memcpy(a5, v2, *((long long *)&v3));\n      v5 = v1;\n    }\n  }\n  free(v2);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppkwwmlu_/anneal.c:41:25: error: expected ')'\n   41 |         v0 = !(v8 >> 63 CONCAT v8) /m (unsigned int)a0 >> 64;\n      |                         ^\n/tmp/tmppkwwmlu_/anneal.c:41:15: note: to match this '('\n   41 |         v0 = !(v8 >> 63 CONCAT v8) /m (unsigned int)a0 >> 64;\n      |               ^\n/tmp/tmppkwwmlu_/anneal.c:41:40: error: expected expression\n   41 |         v0 = !(v8 >> 63 CONCAT v8) /m (unsigned int)a0 >> 64;\n      |                                        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int bits(int x) {\n    int c = 0;\n    while (x > 0)\n        {\n            x >>= 1;\n            c++;\n        }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long bits_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v0 = a0;\n  for (v1 = 0; v0 > 0; v1 += 1) {\n    v0 >>= 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"static inline int timespec_subtract(struct timespec *result, struct timespec *after, struct timespec *before) {\n    result->tv_nsec = after->tv_nsec - before->tv_nsec;\n    if (result->tv_nsec < 0) {\n        result->tv_nsec += 1000000000;\n        result->tv_sec = after->tv_sec - before->tv_sec - 1;\n        return 1;\n    } else {\n        result->tv_sec = after->tv_sec - before->tv_sec;\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long timespec_subtract(unsigned long long a0[2], unsigned long long a1[2],\n                            unsigned long long a2[2]) {\n  a0[1] = a1[1] - a2[1];\n  if (a0[1] >= 0) {\n    a0[0] = a1[0] - a2[0];\n    return 0;\n  }\n  a0[1] = a0[1] + 0x3b9aca00;\n  a0[0] = a1[0] - a2[0] - 1;\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"char control_letter(size_t rest) {\n    const char sequence[] = \"TRWAGMYFPDXBNJZSQVHLCKE\";\n    if (rest >= sizeof (sequence)) {\n        return '.';\n    } else {\n        return sequence[rest];\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long control_letter_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x28]\n  unsigned long long v2; // rdx\n\n  v2 = 6006194753032963152;\n  strncpy(&v0, \"TRWAGMYFPDXBNJZSQVHLCKE\", 23);\n  return (a0 <= 23 ? 46 : (&v0)[a0]);\n}\n","pass":1,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"int nif_detect_type(const char *nif) {\n    char pos_zero = nif[0];\n    if (((*__ctype_b_loc())[(int)((pos_zero))] & (unsigned short)_ISdigit)) {\n        return 10;\n    } else if (pos_zero == 'X' || pos_zero == 'Y' || pos_zero == 'Z') {\n        return 20;\n    } else {\n        return -20;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nif_detect_type_name_conflict(char *a0) {\n  char v0;         // [bp-0x9]\n  unsigned int v3; // eax\n\n  v0 = *(a0);\n  v3 = *((short *)(*((long long *)&__ctype_b_loc()) + v0 * 2)) & 0x800;\n  if (v3)\n    return 10;\n  if (!(v0 != 88 && v0 != 89 && v0 != 90))\n    return 20;\n  return 4294967276;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptx56l8du/nif_detect_type_name_conflict.c:23:37: error: cannot take the address of an\nrvalue of type 'int' 23 |     v3 = *((short *)(*((long long *)&__ctype_b_loc())\n+ v0 * 2)) & 0x800; |                                     ^~~~~~~~~~~~~~~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"char nie_convert_init_letter(const char *nie) {\n    char ret_val = -1;\n    switch (nie[0]) {\n      case 'X':\n        ret_val = '0';\n        break;\n      case 'Y':\n        ret_val = '1';\n        break;\n      case 'Z':\n        ret_val = '2';\n        break;\n      default:\n        break;\n    }\n    return ret_val;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nie_convert_init_letter_name_conflict(char *a0) {\n  char v0;         // [bp-0x9]\n  unsigned int v2; // eax\n\n  v0 = 255;\n  v2 = *(a0);\n  if (v2 == 90) {\n    v0 = 50;\n    return v0;\n  }\n  if (v2 > 90)\n    return v0;\n  if (v2 == 88) {\n    v0 = 48;\n    return v0;\n  } else if (v2 == 89) {\n    v0 = 49;\n    return v0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"long prepare_nif(const char *nif) {\n    char buf_nif_no_letter[9];\n    memset(buf_nif_no_letter, 0, sizeof (buf_nif_no_letter));\n    for (size_t i = 0; i < sizeof (buf_nif_no_letter) - 1; ++i) {\n        buf_nif_no_letter[i] = nif[i];\n    }\n    int nif_type = nif_detect_type(nif);\n    if (nif_type == 20) {\n        buf_nif_no_letter[0] = nie_convert_init_letter(nif);\n    }\n    char *error_str;\n    long result = strtol(buf_nif_no_letter, &error_str, 10);\n    if (error_str[0]) {\n        result = -20;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nif_detect_type)(long long);\nlong long(nie_convert_init_letter)(long long);\n\nlong long prepare_nif_name_conflict(unsigned long a0) {\n  char *v0;         // [bp-0x30]\n  char v1;          // [bp-0x25]\n  unsigned int v2;  // [bp-0x1c]\n  unsigned long v3; // [bp-0x18], Other Possible Types: unsigned long long\n  unsigned long v4; // [bp-0x10]\n\n  memset(&v1, 0, 9);\n  for (v4 = 0; v4 <= 7; v4 += 1) {\n    (&v1)[v4] = *((char *)(v4 + a0));\n  }\n  v2 = nif_detect_type(a0);\n  if (v2 == 20)\n    v1 = nie_convert_init_letter(a0);\n  v3 = strtol(&v1, &v0, 10);\n  if (*(v0)) {\n    v3 = -20;\n    return v3;\n  }\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"int nif_check_integrity(const char *nif) {\n    size_t nif_size = strlen(nif);\n    if (nif_size != 9) {\n        return -10;\n    }\n    long num_nif = prepare_nif(nif);\n    if (num_nif == -20) {\n        return -20;\n    }\n    int rest = num_nif % 23;\n    return nif[8] == control_letter(rest) ? 1 : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(prepare_nif)(long long);\nlong long(control_letter)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  char field_8;\n} struct_0;\n\nlong long nif_check_integrity_name_conflict(struct_0 *a0) {\n  unsigned int v0;       // [bp-0x2c]\n  unsigned long v1;      // [bp-0x28]\n  unsigned long v2;      // [bp-0x20]\n  unsigned long v3;      // [bp-0x10]\n  unsigned long v5;      // rbx\n  unsigned long long v7; // rcx\n\n  v3 = v5;\n  v2 = strlen(a0);\n  if (v2 != 9)\n    return 4294967286;\n  v1 = prepare_nif(a0);\n  if (v1 == -20)\n    return 4294967276;\n  v7 = v1;\n  v0 = (unsigned int)v7 -\n       (3 *\n            (unsigned int)(((v1 * 12832517616493601125 >> 64) + v1 >> 4) -\n                           (v7 >> 63)) *\n            8 -\n        (unsigned int)(((v1 * 12832517616493601125 >> 64) + v1 >> 4) -\n                       (v7 >> 63)));\n  return a0->field_8 == (char)control_letter(v0);\n}\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"struct Node *newNode(struct Node *sentinel) {\n    struct Node *p;\n    p = (struct Node *)malloc(sizeof(struct Node));\n    if (p == ((void *)0)) {\n        fprintf(stderr, \"Memory allocation error...\\n\");\n        exit(1);\n    }\n    p->label = 0;\n    p->data = 0;\n    p->leftSon = sentinel;\n    p->rightSon = sentinel;\n    p->father = sentinel;\n    p->colour = 0;\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n  char padding_c[4];\n  unsigned long long field_10;\n  unsigned long long field_18;\n  unsigned long long field_20;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long newNode_name_conflict(unsigned long a0) {\n  struct_0 *v0; // [bp-0x10]\n\n  v0 = malloc(40);\n  if (!v0) {\n    fwrite(\"Memory allocation error...\\n\", 1, 27, stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n  v0->field_0 = 0;\n  v0->field_4 = 0;\n  v0->field_18 = a0;\n  v0->field_20 = a0;\n  v0->field_10 = a0;\n  v0->field_8 = 0;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1_ylstre/newNode_name_conflict.c:27:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 27 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp1_ylstre/newNode_name_conflict.c:27:22: error: expected ';' after top level declarator\n   27 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp1_ylstre/newNode_name_conflict.c:36:61: error: expected ')'\n   36 |         fwrite(\"Memory allocation error...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp1_ylstre/newNode_name_conflict.c:36:15: note: to match this\n'(' 36 |         fwrite(\"Memory allocation error...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); |               ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/akrzemi1_Mach7/code/msvc/RedBlackTree/AnotherRBTree.c"}
{"compilable":0,"function":"cpu_t init_cpu(uint8_t *opcodes, uint16_t size, uint16_t start_address) {\n    cpu_t cpu = {};\n    int i = 0;\n    cpu.memory_pointer = start_address;\n    while (cpu.memory_pointer < start_address + size && cpu.memory_pointer < 65535)\n        {\n            cpu.memory[cpu.memory_pointer++] = opcodes[i++];\n        }\n    cpu.memory_pointer = start_address;\n    return cpu;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_cpu(void *a0, unsigned long a1, unsigned long a2,\n                   unsigned long a3) {\n  unsigned short v0;     // [bp-0x20040]\n  char v1;               // [bp-0x20028]\n  char v2;               // [bp-0x2001b]\n  unsigned short v3;     // [bp-0x14]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v6; // rax\n  char *v8;              // rax\n\n  v0 = a3;\n  memset(&v1, 0, 131096);\n  v4 = 0;\n  for (v3 = v0; v3 < (unsigned short)a2 + v0 && v3 != 65535;\n       *((char *)(&v2 + v8)) = *((char *)(v6 + a1))) {\n    v6 = v4;\n    v4 = (unsigned int)v6 + 1;\n    v8 = v3;\n    v3 = (unsigned short)v8 + 1;\n  }\n  v3 = v0;\n  memcpy(a0, &v1, 131096);\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq407z95x/init_cpu.c:30:79: error: invalid operands to binary expression\n('char *' and 'char *') 30 |     for (v3 = v0; v3 < (unsigned short)a2 + v0 &&\nv3 != 65535; *((char *)(&v2 + v8)) = *((char *)(v6 + a1))) | ~~~ ^ ~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint16_t concat_numbers(uint8_t arg1, uint8_t arg2) {\n    return (arg1 << 8) + arg2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long concat_numbers_name_conflict(unsigned long a0, unsigned long a1) {\n  return (char)a1 + (char)a0 * 0x100;\n}\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"uint16_t get_address_from_registers(cpu_t *cpu, register_t r1, register_t r2) {\n    return concat_numbers(cpu->registers[r1], cpu->registers[r2]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concat_numbers)(long long, long long);\n\nlong long get_address_from_registers(unsigned long a0, unsigned long a1,\n                                     unsigned long a2) {\n  return concat_numbers(*((char *)(a0 + (unsigned int)a1)),\n                        *((char *)(a0 + (unsigned int)a2)));\n}\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint8_t pop_stack(cpu_t *cpu) {\n    return cpu->stack[cpu->stack_pointer--];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[131086];\n  unsigned short field_2000e;\n} struct_0;\n\nlong long pop_stack_name_conflict(struct_0 *a0) {\n  unsigned long long v1; // rax\n\n  v1 = a0->field_2000e;\n  a0->field_2000e = (unsigned short)v1 - 1;\n  return a0->padding_0[65548 + v1];\n}\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int execute_command(cpu_t *cpu, code_t command) {\n    uint16_t b_address = get_address_from_registers(cpu, REG_C, REG_B);\n    uint16_t d_address = get_address_from_registers(cpu, REG_E, REG_D);\n    uint16_t h_address = get_address_from_registers(cpu, REG_L, REG_H);\n    uint8_t next_byte = cpu->memory[cpu->memory_pointer + 1];\n    switch (command) {\n      case ADD_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A];\n        break;\n      case ADD_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B];\n        break;\n      case ADD_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C];\n        break;\n      case ADD_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D];\n        break;\n      case ADD_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E];\n        break;\n      case ADD_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H];\n        break;\n      case ADD_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L];\n        break;\n      case ADD_M:\n        cpu->registers[REG_A] += cpu->memory[h_address];\n        break;\n      case ADI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer];\n        break;\n      case ADC_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_M:\n        cpu->registers[REG_A] += cpu->memory[h_address] + cpu->flags[CARRY_FLAG];\n        break;\n      case ACI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer] + cpu->flags[CARRY_FLAG];\n        break;\n      case ANA_A:\n        cpu->registers[REG_A] &= cpu->registers[REG_A];\n        break;\n      case ANA_B:\n        cpu->registers[REG_A] &= cpu->registers[REG_B];\n        break;\n      case ANA_C:\n        cpu->registers[REG_A] &= cpu->registers[REG_C];\n        break;\n      case ANA_D:\n        cpu->registers[REG_A] &= cpu->registers[REG_D];\n        break;\n      case ANA_E:\n        cpu->registers[REG_A] &= cpu->registers[REG_E];\n        break;\n      case ANA_H:\n        cpu->registers[REG_A] &= cpu->registers[REG_H];\n        break;\n      case ANA_L:\n        cpu->registers[REG_A] &= cpu->registers[REG_L];\n        break;\n      case ANA_M:\n        cpu->registers[REG_A] &= cpu->memory[h_address];\n        break;\n      case ANI_D8:\n        cpu->registers[REG_A] &= cpu->memory[++cpu->memory_pointer];\n        break;\n      case CALL_A16:\n        break;\n      case CZ_A16:\n        break;\n      case CNZ_A16:\n        break;\n      case CP_A16:\n        break;\n      case CM_A16:\n        break;\n      case CC_A16:\n        break;\n      case CNC_A16:\n        break;\n      case CPE_A16:\n        break;\n      case CPO_A16:\n        break;\n      case CMA:\n        cpu->registers[REG_A] = ~cpu->registers[REG_A];\n        break;\n      case CMC:\n        cpu->flags[CARRY_FLAG] = ~cpu->flags[CARRY_FLAG];\n        break;\n      case CMP_A:\n        set_flag(cpu, ZERO_FLAG, 1);\n        break;\n      case CMP_B:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_B] - cpu->registers[REG_A]));\n        break;\n      case CMP_C:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_D:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_D] - cpu->registers[REG_A]));\n        break;\n      case CMP_E:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_H:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_H] - cpu->registers[REG_A]));\n        break;\n      case CMP_L:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_L] - cpu->registers[REG_A]));\n        break;\n      case CMP_M:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[h_address] - cpu->registers[REG_A]));\n        break;\n      case CPI_D8:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[++cpu->memory_pointer] - cpu->registers[REG_A]));\n        break;\n      case DAA:\n        break;\n      case DAD_B:\n        b_address += h_address;\n        break;\n      case DAD_D:\n        d_address += h_address;\n        break;\n      case DAD_H:\n        h_address += h_address;\n        break;\n      case DAD_SP:\n        cpu->stack_pointer += h_address;\n        break;\n      case DCR_A:\n        cpu->registers[REG_A]--;\n        break;\n      case DCR_B:\n        cpu->registers[REG_B]--;\n        break;\n      case DCR_C:\n        cpu->registers[REG_C]--;\n        break;\n      case DCR_D:\n        cpu->registers[REG_D]--;\n        break;\n      case DCR_E:\n        cpu->registers[REG_E]--;\n        break;\n      case DCR_H:\n        cpu->registers[REG_H]--;\n        break;\n      case DCR_L:\n        cpu->registers[REG_L]--;\n        break;\n      case DCR_M:\n        cpu->memory[h_address]--;\n        break;\n      case DCX_B:\n        b_address--;\n        break;\n      case DCX_D:\n        d_address--;\n        break;\n      case DCX_H:\n        h_address--;\n        break;\n      case DCX_SP:\n        cpu->stack_pointer--;\n        break;\n      case DI:\n        cpu->interrupts_enabled = 0;\n        break;\n      case EI:\n        cpu->interrupts_enabled = 1;\n        break;\n      case IN_PP:\n        break;\n      case INR_A:\n        cpu->registers[REG_A]++;\n        break;\n      case INR_B:\n        cpu->registers[REG_B]++;\n        break;\n      case INR_C:\n        cpu->registers[REG_C]++;\n        break;\n      case INR_D:\n        cpu->registers[REG_D]++;\n        break;\n      case INR_E:\n        cpu->registers[REG_E]++;\n        break;\n      case INR_H:\n        cpu->registers[REG_H]++;\n        break;\n      case INR_L:\n        cpu->registers[REG_L]++;\n        break;\n      case INR_M:\n        cpu->memory[h_address]++;\n        break;\n      case INX_B:\n        b_address++;\n        break;\n      case INX_D:\n        d_address++;\n        break;\n      case INX_H:\n        h_address++;\n        break;\n      case INX_SP:\n        cpu->stack_pointer++;\n        break;\n      case JMP_A16:\n        cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JZ_A16:\n        if (cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNZ_A16:\n        if (!cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JP_A16:\n        break;\n      case JM_A16:\n        break;\n      case JC_A16:\n        if (cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNC_A16:\n        if (!cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPE_A16:\n        if (cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPO_A16:\n        if (!cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case LDA_A16:\n        cpu->registers[REG_A] = cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])];\n        break;\n      case LDAX_B:\n        cpu->registers[REG_A] = cpu->memory[b_address];\n        break;\n      case LDAX_D:\n        cpu->registers[REG_A] = cpu->memory[d_address];\n        break;\n      case LHLD_A16:\n        cpu->registers[REG_L] = (uint8_t)(cpu->memory[h_address] & 255);\n        cpu->registers[REG_H] = (uint8_t)(cpu->memory[h_address] >> 8);\n        break;\n      case LXI_B_D16:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_H_D16:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_SP_D16:\n        cpu->stack_pointer = concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer]);\n        break;\n      case MOV_A_A:\n        cpu->registers[REG_A] = cpu->registers[REG_A];\n        break;\n      case MOV_A_B:\n        cpu->registers[REG_A] = cpu->registers[REG_B];\n        break;\n      case MOV_A_C:\n        cpu->registers[REG_A] = cpu->registers[REG_C];\n        break;\n      case MOV_A_D:\n        cpu->registers[REG_A] = cpu->registers[REG_D];\n        break;\n      case MOV_A_E:\n        cpu->registers[REG_A] = cpu->registers[REG_E];\n        break;\n      case MOV_A_H:\n        cpu->registers[REG_A] = cpu->registers[REG_H];\n        break;\n      case MOV_A_L:\n        cpu->registers[REG_A] = cpu->registers[REG_L];\n        break;\n      case MOV_A_M:\n        cpu->registers[REG_A] = cpu->memory[h_address];\n        break;\n      case MOV_B_A:\n        cpu->registers[REG_B] = cpu->registers[REG_A];\n        break;\n      case MOV_B_B:\n        cpu->registers[REG_B] = cpu->registers[REG_B];\n        break;\n      case MOV_B_C:\n        cpu->registers[REG_B] = cpu->registers[REG_C];\n        break;\n      case MOV_B_D:\n        cpu->registers[REG_B] = cpu->registers[REG_D];\n        break;\n      case MOV_B_E:\n        cpu->registers[REG_B] = cpu->registers[REG_E];\n        break;\n      case MOV_B_H:\n        cpu->registers[REG_B] = cpu->registers[REG_H];\n        break;\n      case MOV_B_L:\n        cpu->registers[REG_B] = cpu->registers[REG_L];\n        break;\n      case MOV_B_M:\n        cpu->registers[REG_B] = cpu->memory[h_address];\n        break;\n      case MOV_C_A:\n        cpu->registers[REG_C] = cpu->registers[REG_A];\n        break;\n      case MOV_C_B:\n        cpu->registers[REG_C] = cpu->registers[REG_B];\n        break;\n      case MOV_C_C:\n        cpu->registers[REG_C] = cpu->registers[REG_C];\n        break;\n      case MOV_C_D:\n        cpu->registers[REG_C] = cpu->registers[REG_D];\n        break;\n      case MOV_C_E:\n        cpu->registers[REG_C] = cpu->registers[REG_E];\n        break;\n      case MOV_C_H:\n        cpu->registers[REG_C] = cpu->registers[REG_H];\n        break;\n      case MOV_C_L:\n        cpu->registers[REG_C] = cpu->registers[REG_L];\n        break;\n      case MOV_C_M:\n        cpu->registers[REG_C] = cpu->memory[h_address];\n        break;\n      case MOV_D_A:\n        cpu->registers[REG_D] = cpu->registers[REG_A];\n        break;\n      case MOV_D_B:\n        cpu->registers[REG_D] = cpu->registers[REG_B];\n        break;\n      case MOV_D_C:\n        cpu->registers[REG_D] = cpu->registers[REG_C];\n        break;\n      case MOV_D_D:\n        cpu->registers[REG_D] = cpu->registers[REG_D];\n        break;\n      case MOV_D_E:\n        cpu->registers[REG_D] = cpu->registers[REG_E];\n        break;\n      case MOV_D_H:\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        break;\n      case MOV_D_L:\n        cpu->registers[REG_D] = cpu->registers[REG_L];\n        break;\n      case MOV_D_M:\n        cpu->registers[REG_D] = cpu->memory[h_address];\n        break;\n      case MOV_E_A:\n        cpu->registers[REG_E] = cpu->registers[REG_A];\n        break;\n      case MOV_E_B:\n        cpu->registers[REG_E] = cpu->registers[REG_B];\n        break;\n      case MOV_E_C:\n        cpu->registers[REG_E] = cpu->registers[REG_C];\n        break;\n      case MOV_E_D:\n        cpu->registers[REG_E] = cpu->registers[REG_D];\n        break;\n      case MOV_E_E:\n        cpu->registers[REG_E] = cpu->registers[REG_E];\n        break;\n      case MOV_E_H:\n        cpu->registers[REG_E] = cpu->registers[REG_H];\n        break;\n      case MOV_E_L:\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        break;\n      case MOV_E_M:\n        cpu->registers[REG_E] = cpu->memory[h_address];\n        break;\n      case MOV_H_A:\n        cpu->registers[REG_H] = cpu->registers[REG_A];\n        break;\n      case MOV_H_B:\n        cpu->registers[REG_H] = cpu->registers[REG_B];\n        break;\n      case MOV_H_C:\n        cpu->registers[REG_H] = cpu->registers[REG_C];\n        break;\n      case MOV_H_D:\n        cpu->registers[REG_H] = cpu->registers[REG_D];\n        break;\n      case MOV_H_E:\n        cpu->registers[REG_H] = cpu->registers[REG_E];\n        break;\n      case MOV_H_H:\n        cpu->registers[REG_H] = cpu->registers[REG_H];\n        break;\n      case MOV_H_L:\n        cpu->registers[REG_H] = cpu->registers[REG_L];\n        break;\n      case MOV_H_M:\n        cpu->registers[REG_H] = cpu->memory[h_address];\n        break;\n      case MOV_L_A:\n        cpu->registers[REG_L] = cpu->registers[REG_A];\n        break;\n      case MOV_L_B:\n        cpu->registers[REG_L] = cpu->registers[REG_B];\n        break;\n      case MOV_L_C:\n        cpu->registers[REG_L] = cpu->registers[REG_C];\n        break;\n      case MOV_L_D:\n        cpu->registers[REG_L] = cpu->registers[REG_D];\n        break;\n      case MOV_L_E:\n        cpu->registers[REG_L] = cpu->registers[REG_E];\n        break;\n      case MOV_L_H:\n        cpu->registers[REG_L] = cpu->registers[REG_H];\n        break;\n      case MOV_L_L:\n        cpu->registers[REG_L] = cpu->registers[REG_L];\n        break;\n      case MOV_L_M:\n        cpu->registers[REG_L] = cpu->memory[h_address];\n        break;\n      case MOV_M_A:\n        cpu->memory[h_address] = cpu->registers[REG_A];\n        break;\n      case MOV_M_B:\n        cpu->memory[h_address] = cpu->registers[REG_B];\n        break;\n      case MOV_M_C:\n        cpu->memory[h_address] = cpu->registers[REG_C];\n        break;\n      case MOV_M_D:\n        cpu->memory[h_address] = cpu->registers[REG_D];\n        break;\n      case MOV_M_E:\n        cpu->memory[h_address] = cpu->registers[REG_E];\n        break;\n      case MOV_M_H:\n        cpu->memory[h_address] = cpu->registers[REG_H];\n        break;\n      case MOV_M_L:\n        cpu->memory[h_address] = cpu->registers[REG_L];\n        break;\n      case MVI_A_D8:\n        cpu->registers[REG_A] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_B_D8:\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_C_D8:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_D_D8:\n        cpu->registers[REG_D] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_E_D8:\n        cpu->registers[REG_E] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_H_D8:\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_L_D8:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_M_D8:\n        cpu->memory[h_address] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case ORA_A:\n        cpu->registers[REG_A] |= cpu->registers[REG_A];\n        break;\n      case ORA_B:\n        cpu->registers[REG_A] |= cpu->registers[REG_B];\n        break;\n      case ORA_C:\n        cpu->registers[REG_A] |= cpu->registers[REG_C];\n        break;\n      case ORA_D:\n        cpu->registers[REG_A] |= cpu->registers[REG_D];\n        break;\n      case ORA_E:\n        cpu->registers[REG_A] |= cpu->registers[REG_E];\n        break;\n      case ORA_H:\n        cpu->registers[REG_A] |= cpu->registers[REG_H];\n        break;\n      case ORA_L:\n        cpu->registers[REG_A] |= cpu->registers[REG_L];\n        break;\n      case ORA_M:\n        cpu->registers[REG_A] |= cpu->memory[h_address];\n        break;\n      case ORI_D8:\n        cpu->registers[REG_A] |= cpu->memory[++cpu->memory_pointer];\n        break;\n      case OUT_PP:\n        break;\n      case PCHL:\n        break;\n      case POP_B:\n        break;\n      case POP_D:\n        break;\n      case POP_H:\n        break;\n      case POP_PSW:\n        break;\n      case PUSH_B:\n        break;\n      case PUSH_D:\n        break;\n      case PUSH_H:\n        break;\n      case PUSH_PSW:\n        break;\n      case RAL:\n        break;\n      case RAR:\n        break;\n      case RLC:\n        break;\n      case RRC:\n        break;\n      case RIM:\n        break;\n      case RET:\n        break;\n      case RZ:\n        break;\n      case RNZ:\n        break;\n      case RP:\n        break;\n      case RM:\n        break;\n      case RC:\n        break;\n      case RNC:\n        break;\n      case RPE:\n        break;\n      case RPO:\n        break;\n      case RST_0:\n        break;\n      case RST_1:\n        break;\n      case RST_2:\n        break;\n      case RST_3:\n        break;\n      case RST_4:\n        break;\n      case RST_5:\n        break;\n      case RST_6:\n        break;\n      case RST_7:\n        break;\n      case SIM:\n        break;\n      case SPHL:\n        cpu->stack_pointer = h_address;\n        break;\n      case SHLD_A16:\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_L];\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_H];\n        break;\n      case STA_A16:\n        cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])] = cpu->registers[REG_A];\n        break;\n      case STAX_B:\n        cpu->memory[b_address] = cpu->registers[REG_A];\n        break;\n      case STAX_D:\n        cpu->memory[d_address] = cpu->registers[REG_A];\n        break;\n      case STC:\n        set_flag(cpu, CARRY_FLAG, 1);\n        break;\n      case SUB_A:\n        cpu->registers[REG_A] -= cpu->registers[REG_A];\n        break;\n      case SUB_B:\n        cpu->registers[REG_A] -= cpu->registers[REG_B];\n        break;\n      case SUB_C:\n        cpu->registers[REG_A] -= cpu->registers[REG_C];\n        break;\n      case SUB_D:\n        cpu->registers[REG_A] -= cpu->registers[REG_D];\n        break;\n      case SUB_E:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_H:\n        cpu->registers[REG_A] -= cpu->registers[REG_H];\n        break;\n      case SUB_L:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_M:\n        cpu->registers[REG_A] -= cpu->memory[h_address];\n        break;\n      case SUI_D8:\n        cpu->registers[REG_A] -= cpu->memory[++cpu->memory_pointer];\n        break;\n      case SBB_A:\n        break;\n      case SBB_B:\n        break;\n      case SBB_C:\n        break;\n      case SBB_D:\n        break;\n      case SBB_E:\n        break;\n      case SBB_H:\n        break;\n      case SBB_L:\n        break;\n      case SBB_M:\n        break;\n      case SBI_D8:\n        break;\n      case XCHG:\n        push_stack(cpu, cpu->registers[REG_E]);\n        push_stack(cpu, cpu->registers[REG_D]);\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        cpu->registers[REG_L] = pop_stack(cpu);\n        cpu->registers[REG_H] = pop_stack(cpu);\n        break;\n      case XTHL:\n        break;\n      case XRA_A:\n        cpu->registers[REG_A] ^= cpu->registers[REG_A];\n        break;\n      case XRA_B:\n        cpu->registers[REG_A] ^= cpu->registers[REG_B];\n        break;\n      case XRA_C:\n        cpu->registers[REG_A] ^= cpu->registers[REG_C];\n        break;\n      case XRA_D:\n        cpu->registers[REG_A] ^= cpu->registers[REG_D];\n        break;\n      case XRA_E:\n        cpu->registers[REG_A] ^= cpu->registers[REG_E];\n        break;\n      case XRA_H:\n        cpu->registers[REG_A] ^= cpu->registers[REG_H];\n        break;\n      case XRA_L:\n        cpu->registers[REG_A] ^= cpu->registers[REG_L];\n        break;\n      case XRA_M:\n        cpu->registers[REG_A] ^= cpu->memory[h_address];\n        break;\n      case XRI_D8:\n        cpu->registers[REG_A] ^= cpu->memory[++cpu->memory_pointer];\n        break;\n      case NOP:\n      case HLT:\n        return 0;\n    }\n    cpu->program_counter = cpu->memory_pointer++;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_address_from_registers)(long long, long long, long long);\nlong long(set_flag)(long long, long long, long long);\nlong long(concat_numbers)(long long, long long);\nlong long(push_stack)(long long, long long);\nlong long(pop_stack)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  char field_2;\n  char field_3;\n  char field_4;\n  char field_5;\n  char field_6;\n  char padding_7[1];\n  char field_8;\n  char field_9;\n  char padding_a[1];\n  char field_b;\n  char padding_c[131072];\n  unsigned short field_2000c;\n  unsigned short field_2000e;\n  char padding_20010[4];\n  unsigned short field_20014;\n  char field_20016;\n} struct_0;\n\nlong long execute_command_name_conflict(struct_0 *a0, unsigned long a1) {\n  char v0;               // [bp-0xf]\n  unsigned short v1;     // [bp-0xe]\n  unsigned short v2;     // [bp-0xc]\n  unsigned short v3;     // [bp-0xa]\n  unsigned long long v5; // rax\n  unsigned long long v6; // rax\n  unsigned short v7;     // ax\n\n  v3 = get_address_from_registers(a0, 2, 1);\n  v2 = get_address_from_registers(a0, 4, 3);\n  v1 = get_address_from_registers(a0, 6, 5);\n  v0 = a0->padding_c[2 + a0->field_20014];\n  switch ((unsigned int)a1) {\n  case 0:\n  case 118:\n    return 0;\n  case 1:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_2 = a0->padding_c[1 + a0->field_20014];\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_1 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 2:\n    a0->padding_c[1 + v3] = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 3:\n    v3 += 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 4:\n    a0->field_1 = a0->field_1 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 5:\n    a0->field_1 = a0->field_1 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 6:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_1 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 9:\n    v3 += v1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 10:\n    a0->field_0 = a0->padding_c[1 + v3];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 11:\n    v3 -= 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 12:\n    a0->field_2 = a0->field_2 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 13:\n    a0->field_2 = a0->field_2 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 14:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_2 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 18:\n    a0->padding_c[1 + v2] = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 19:\n    v2 += 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 20:\n    a0->field_3 = a0->field_3 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 21:\n    a0->field_3 = a0->field_3 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 22:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_3 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 25:\n    v2 += v1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 26:\n    a0->field_0 = a0->padding_c[1 + v2];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 27:\n    v2 -= 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 28:\n    a0->field_4 = a0->field_4 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 29:\n    a0->field_4 = a0->field_4 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 30:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_4 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 33:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_6 = a0->padding_c[1 + a0->field_20014];\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_5 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 34:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->padding_c[1 + a0->field_20014] = a0->field_6;\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->padding_c[1 + a0->field_20014] = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 35:\n    v1 += 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 36:\n    a0->field_5 = a0->field_5 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 37:\n    a0->field_5 = a0->field_5 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 38:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_5 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 41:\n    v1 *= 2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 42:\n    a0->field_6 = a0->padding_c[1 + v1];\n    a0->field_5 = a0->padding_c[1 + v1] >> 8;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 43:\n    v1 -= 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 44:\n    a0->field_6 = a0->field_6 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 45:\n    a0->field_6 = a0->field_6 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 46:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_6 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 47:\n    a0->field_0 = ~(a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 49:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_2000e = concat_numbers(a0->padding_c[1 + a0->field_20014],\n                                     a0->padding_c[1 + a0->field_20014]);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 50:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->padding_c[1 + concat_numbers(a0->padding_c[1 + a0->field_20014],\n                                     a0->padding_c[1 + a0->field_20014])] =\n        a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 51:\n    a0->field_2000e = a0->field_2000e + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 52:\n    v6 = v1;\n    a0->padding_c[1 + v6] = a0->padding_c[1 + v6] + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 53:\n    v5 = v1;\n    a0->padding_c[1 + v5] = a0->padding_c[1 + v5] - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 54:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->padding_c[1 + v1] = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 55:\n    set_flag(a0, 0, 1);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 57:\n    a0->field_2000e = a0->field_2000e + v1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 58:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 =\n        a0->padding_c[1 + concat_numbers(a0->padding_c[1 + a0->field_20014],\n                                         a0->padding_c[1 + a0->field_20014])];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 59:\n    a0->field_2000e = a0->field_2000e - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 60:\n    a0->field_0 = a0->field_0 + 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 61:\n    a0->field_0 = a0->field_0 - 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 62:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 = a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 63:\n    a0->field_8 = ~(a0->field_8);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 64:\n    a0->field_1 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 65:\n    a0->field_1 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 66:\n    a0->field_1 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 67:\n    a0->field_1 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 68:\n    a0->field_1 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 69:\n    a0->field_1 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 70:\n    a0->field_1 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 71:\n    a0->field_1 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 72:\n    a0->field_2 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 73:\n    a0->field_2 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 74:\n    a0->field_2 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 75:\n    a0->field_2 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 76:\n    a0->field_2 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 77:\n    a0->field_2 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 78:\n    a0->field_2 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 79:\n    a0->field_2 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 80:\n    a0->field_3 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 81:\n    a0->field_3 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 82:\n    a0->field_3 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 83:\n    a0->field_3 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 84:\n    a0->field_3 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 85:\n    a0->field_3 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 86:\n    a0->field_3 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 87:\n    a0->field_3 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 88:\n    a0->field_4 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 89:\n    a0->field_4 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 90:\n    a0->field_4 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 91:\n    a0->field_4 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 92:\n    a0->field_4 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 93:\n    a0->field_4 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 94:\n    a0->field_4 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 95:\n    a0->field_4 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 96:\n    a0->field_5 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 97:\n    a0->field_5 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 98:\n    a0->field_5 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 99:\n    a0->field_5 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 100:\n    a0->field_5 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 101:\n    a0->field_5 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 102:\n    a0->field_5 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 103:\n    a0->field_5 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 104:\n    a0->field_6 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 105:\n    a0->field_6 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 106:\n    a0->field_6 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 107:\n    a0->field_6 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 108:\n    a0->field_6 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 109:\n    a0->field_6 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 110:\n    a0->field_6 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 111:\n    a0->field_6 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 112:\n    a0->padding_c[1 + v1] = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 113:\n    a0->padding_c[1 + v1] = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 114:\n    a0->padding_c[1 + v1] = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 115:\n    a0->padding_c[1 + v1] = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 116:\n    a0->padding_c[1 + v1] = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 117:\n    a0->padding_c[1 + v1] = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 119:\n    a0->padding_c[1 + v1] = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 120:\n    a0->field_0 = a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 121:\n    a0->field_0 = a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 122:\n    a0->field_0 = a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 123:\n    a0->field_0 = a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 124:\n    a0->field_0 = a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 125:\n    a0->field_0 = a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 126:\n    a0->field_0 = a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 127:\n    a0->field_0 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 128:\n    a0->field_0 = a0->field_0 + a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 129:\n    a0->field_0 = a0->field_0 + a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 130:\n    a0->field_0 = a0->field_0 + a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 131:\n    a0->field_0 = a0->field_0 + a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 132:\n    a0->field_0 = a0->field_0 + a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 133:\n    a0->field_0 = a0->field_0 + a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 134:\n    a0->field_0 = a0->field_0 + a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 135:\n    a0->field_0 = a0->field_0 * 2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 136:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 137:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 138:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 139:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 140:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 141:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 142:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 143:\n    a0->field_0 = a0->field_0 + a0->field_8 + a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 144:\n    a0->field_0 = a0->field_0 - a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 145:\n    a0->field_0 = a0->field_0 - a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 146:\n    a0->field_0 = a0->field_0 - a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 147:\n    a0->field_0 = a0->field_0 - a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 148:\n    a0->field_0 = a0->field_0 - a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 149:\n    a0->field_0 = a0->field_0 - a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 150:\n    a0->field_0 = a0->field_0 - a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 151:\n    a0->field_0 = 0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 160:\n    a0->field_0 = a0->field_0 & a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 161:\n    a0->field_0 = a0->field_0 & a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 162:\n    a0->field_0 = a0->field_0 & a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 163:\n    a0->field_0 = a0->field_0 & a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 164:\n    a0->field_0 = a0->field_0 & a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 165:\n    a0->field_0 = a0->field_0 & a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 166:\n    a0->field_0 = a0->field_0 & a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 167:\n    a0->field_0 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 168:\n    a0->field_0 = a0->field_0 ^ a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 169:\n    a0->field_0 = a0->field_0 ^ a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 170:\n    a0->field_0 = a0->field_0 ^ a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 171:\n    a0->field_0 = a0->field_0 ^ a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 172:\n    a0->field_0 = a0->field_0 ^ a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 173:\n    a0->field_0 = a0->field_0 ^ a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 174:\n    a0->field_0 = a0->field_0 ^ a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 175:\n    a0->field_0 = 0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 176:\n    a0->field_0 = a0->field_0 | a0->field_1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 177:\n    a0->field_0 = a0->field_0 | a0->field_2;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 178:\n    a0->field_0 = a0->field_0 | a0->field_3;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 179:\n    a0->field_0 = a0->field_0 | a0->field_4;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 180:\n    a0->field_0 = a0->field_0 | a0->field_5;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 181:\n    a0->field_0 = a0->field_0 | a0->field_6;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 182:\n    a0->field_0 = a0->field_0 | a0->padding_c[1 + v1];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 183:\n    a0->field_0 = a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 184:\n    set_flag(a0, 3, a0->field_1 != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 185:\n    set_flag(a0, 3, a0->field_2 != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 186:\n    set_flag(a0, 3, a0->field_3 != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 187:\n    set_flag(a0, 3, a0->field_2 != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 188:\n    set_flag(a0, 3, a0->field_5 != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 189:\n    set_flag(a0, 3, a0->field_6 != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 190:\n    set_flag(a0, 3, a0->padding_c[1 + v1] != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 191:\n    set_flag(a0, 3, 1);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 194:\n    if ((char)(a0->field_b ^ 1))\n      a0->field_20014 =\n          (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                                a0->padding_c[2 + a0->field_20014]) -\n          1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 195:\n    a0->field_20014 =\n        (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                              a0->padding_c[2 + a0->field_20014]) -\n        1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 198:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 = a0->padding_c[1 + a0->field_20014] + a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 202:\n    if (a0->field_b)\n      a0->field_20014 =\n          (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                                a0->padding_c[2 + a0->field_20014]) -\n          1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 206:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 =\n        a0->padding_c[1 + a0->field_20014] + a0->field_8 + a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 210:\n    if ((char)(a0->field_8 ^ 1))\n      a0->field_20014 =\n          (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                                a0->padding_c[2 + a0->field_20014]) -\n          1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 214:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 = a0->field_0 - a0->padding_c[1 + a0->field_20014];\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 218:\n    if (a0->field_8)\n      a0->field_20014 =\n          (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                                a0->padding_c[2 + a0->field_20014]) -\n          1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 226:\n    if ((char)(a0->field_9 ^ 1))\n      a0->field_20014 =\n          (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                                a0->padding_c[2 + a0->field_20014]) -\n          1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 230:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 = a0->padding_c[1 + a0->field_20014] & a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 234:\n    if (a0->field_9)\n      a0->field_20014 =\n          (short)concat_numbers(a0->padding_c[3 + a0->field_20014],\n                                a0->padding_c[2 + a0->field_20014]) -\n          1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 235:\n    push_stack(a0, a0->field_4);\n    push_stack(a0, a0->field_3);\n    a0->field_4 = a0->field_6;\n    a0->field_3 = a0->field_5;\n    a0->field_6 = pop_stack(a0);\n    a0->field_5 = pop_stack(a0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 238:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 = a0->padding_c[1 + a0->field_20014] ^ a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 243:\n    a0->field_20016 = 0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 246:\n    a0->field_20014 = a0->field_20014 + 1;\n    a0->field_0 = a0->padding_c[1 + a0->field_20014] | a0->field_0;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 249:\n    a0->field_2000e = v1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 251:\n    a0->field_20016 = 1;\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  case 254:\n    a0->field_20014 = a0->field_20014 + 1;\n    set_flag(a0, 3, a0->padding_c[1 + a0->field_20014] != a0->field_0);\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    break;\n  default:\n    v7 = a0->field_20014;\n    a0->field_20014 = v7 + 1;\n    a0->field_2000c = v7;\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"int execute(cpu_t *cpu) {\n    while (cpu->memory[cpu->memory_pointer] != HLT && cpu->memory_pointer < 65535)\n        {\n            execute_command(cpu, (code_t)cpu->memory[cpu->memory_pointer]);\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(execute_name_conflict_command)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[131092];\n  unsigned short field_20014;\n} struct_0;\n\nlong long execute_name_conflict(struct_0 *a0) {\n  while (a0->padding_0[13 + a0->field_20014] != 118) {\n    if (a0->field_20014 == 65535)\n      return 0;\n    execute_name_conflict_command(a0, a0->padding_0[13 + a0->field_20014]);\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpefvx5yfo/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() {\n  unsigned long long v2; // rax\n\n  v2 = strerror(*(__errno_location()));\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjqnhbwm0/k_strerr_name_conflict.c:22:19: error: indirection requires pointer operand\n('int' invalid) 22 |     v2 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\nlong long k_chbindir_name_conflict() {\n  void *v0;          // [bp-0x118]\n  void *v1;          // [bp-0x110]\n  void *v2;          // [bp-0x108]\n  void *v3;          // [bp-0x100]\n  void *v4;          // [bp-0xf8]\n  void *v5;          // [bp-0xf0]\n  void *v6;          // [bp-0xe8]\n  void *v7;          // [bp-0xe0]\n  void *v8;          // [bp-0xd8]\n  void *v9;          // [bp-0xd0]\n  void *v10;         // [bp-0xc8]\n  void *v11;         // [bp-0xc0]\n  void *v12;         // [bp-0xb8]\n  void *v13;         // [bp-0xb0]\n  void *v14;         // [bp-0xa8]\n  void *v15;         // [bp-0xa0]\n  void *v16;         // [bp-0x98]\n  void *v17;         // [bp-0x90]\n  void *v18;         // [bp-0x88]\n  void *v19;         // [bp-0x80]\n  void *v20;         // [bp-0x78]\n  void *v21;         // [bp-0x70]\n  void *v22;         // [bp-0x68]\n  void *v23;         // [bp-0x60]\n  void *v24;         // [bp-0x58]\n  void *v25;         // [bp-0x50]\n  void *v26;         // [bp-0x48]\n  void *v27;         // [bp-0x40]\n  void *v28;         // [bp-0x38]\n  void *v29;         // [bp-0x30]\n  void *v30;         // [bp-0x28]\n  void *v31;         // [bp-0x20]\n  unsigned int v32;  // [bp-0x10]\n  unsigned int v33;  // [bp-0xc]\n  unsigned long v36; // rax\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v32 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if (v32 <= 0)\n    return 1;\n  for (v33 = v32 - 1; *((char *)&v0 + v33) != 47 && v33;\n       *((char *)&v0 + v36) = 0) {\n    v36 = v33;\n    v33 = (unsigned int)v36 - 1;\n  }\n  if (*((char *)&v0 + v33) != 47)\n    return 1;\n  if (!v33)\n    return chdir(&v0);\n  *((char *)&v0 + v33) = 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xc8]\n  unsigned int v1;       // [bp-0xc0]\n  unsigned int v2;       // [bp-0x40]\n  unsigned int v3[3];    // [bp-0x28]\n  unsigned long long v4; // [bp-0x20]\n  char *v5;              // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  *((unsigned long long *)v3) = v4;\n  setrlimit(4, v3);\n  getrlimit(6, v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  v5 = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n  system(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;         // [bp-0xa8]\n  unsigned int v1; // [bp-0xa0]\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  v4 = 0;\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  v3 = fork();\n  if (v3 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if (v3 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    v4 = setsid();\n    if (v4 >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8qj4pcvh/k_demon_name_conflict.c:40:29: error: indirection requires pointer operand\n('int' invalid) 40 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp8qj4pcvh/k_demon_name_conflict.c:57:31: error: indirection\nrequires pointer operand ('int' invalid) 57 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned int v0[3];    // [bp-0xb8]\n  unsigned long long v1; // [bp-0xb0]\n  char v2;               // [bp-0xa8], Other Possible Types: unsigned long long\n\n  memset(&v2, 0, 152);\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  *((unsigned long long *)v0) = v1;\n  setrlimit(7, v0);\n  getrlimit(7, v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 0x800;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 1;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return (!shutdown(a0, a1) ? 1 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (v0 == -1) {\n    v0 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz9dgkcze/ksock_close_name_conflict.c:26:13: error: indirection requires pointer\noperand ('int' invalid) 26 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a2;\n  if (!ioctl(a0, a1))\n    return 0;\n  printf(\"ioctl :%s\\n\", (int)k_strerr());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  v0 = a0;\n  v1 = a1;\n  strcpy(a2, inet_ntoa());\n  *(a3) = ntohs(*((short *)((char *)&v0 + 2)));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuk9kc81n/ksock_from_addr.c:28:26: error: too few arguments to function\ncall, expected 1, have 0 28 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpuk9kc81n/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = htons(a2);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 1;\n  if (setsockopt(a0, 1, 2, &v1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  char v1;         // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &v0, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v1));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x28]\n  unsigned int v1; // [bp-0x24]\n  unsigned int v2; // [bp-0x20]\n  char v3;         // [bp-0x1c]\n  unsigned int v4; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v4 = 1;\n  if (setsockopt(a0, 1, 9, &v4, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 4, &a1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 5, &v1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 6, &v0, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = socket(2, 1, 0);\n  if (v0 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return 4294967295;\n  }\n  return (!(int)ksock_set_reuse(v0) ? 4294967295 : v0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"bind :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) == -1) {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x3c]\n  unsigned int v1; // [bp-0x2c]\n  sockaddr v2;     // [bp-0x28]\n  char v3;         // [bp-0x26]\n  unsigned int v4; // [bp-0xc]\n\n  v1 = 16;\n  v4 = accept(a0, &v2, &v1);\n  if (v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n    return 4294967295;\n  }\n  strcpy(a1, inet_ntoa());\n  *(a2) = ntohs(*((short *)&v3));\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0zg4plt6/ksock_accept.c:46:26: error: too few arguments to function\ncall, expected 1, have 0 46 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp0zg4plt6/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a2);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"connect :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hash_str_name_conflict(char a0[12], unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x28]\n  unsigned long v2; // rbx\n  char v3[12];      // rax, Other Possible Types: unsigned long\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n  unsigned int v5;  // r13d\n  unsigned int v6;  // r12d\n  unsigned int v7;  // ebx\n  unsigned int v8;  // r13d\n  unsigned int v9;  // r12d\n  unsigned int v10; // ebx\n  unsigned int v11; // r13d\n  unsigned int v12; // r12d\n  unsigned int v13; // ebx\n  unsigned int\n      v14; // r13d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      v15; // r12d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int v16;  // ebx\n  unsigned long v17; // rbx, Other Possible Types: unsigned long long\n  unsigned long v18; // rbx, Other Possible Types: unsigned int\n  unsigned int v19;  // eax\n  unsigned int v20;  // r13d\n  unsigned int v21;  // r12d\n  unsigned int v22;  // ebx\n  unsigned int v23;  // r13d\n  unsigned int v24;  // r12d\n  unsigned int v25;  // ebx\n  unsigned int v26;  // r13d\n  unsigned int v27;  // r12d\n\n  v0 = v2;\n  v3 = a0;\n  v4 = a1;\n  v15 = 2654435769;\n  v14 = 2654435769;\n  for (v17 = a2; (unsigned int)v4 > 11; v4 = (unsigned int)v4 - 12) {\n    v5 = (unsigned int)v14 + *((char *)(v3 + 3)) * 0x1000000 + *((char *)v3) +\n         *((char *)(v3 + 1)) * 0x100 + *((char *)(v3 + 2)) * 0x10000;\n    v6 = (unsigned int)v15 + *((char *)(v3 + 7)) * 0x1000000 +\n         *((char *)(v3 + 4)) + *((char *)(v3 + 5)) * 0x100 +\n         *((char *)(v3 + 6)) * 0x10000;\n    v7 = v17 + *((char *)(v3 + 11)) * 0x1000000 + *((char *)(v3 + 8)) +\n         *((char *)(v3 + 9)) * 0x100 + *((char *)(v3 + 10)) * 0x10000;\n    v8 = (unsigned int)v14 - v6 - v7 ^ v7 / 0x2000;\n    v9 = v6 - v7 - (unsigned int)v14 ^ v8 * 0x100;\n    v10 = v7 - v8 - (unsigned int)v15 ^ v9 / 0x2000;\n    v11 = v8 - (unsigned int)v15 - v7 ^ v10 / 0x1000;\n    v12 = (unsigned int)v15 - v10 - (unsigned int)v14 ^ v11 * 0x10000;\n    v13 = v7 - v11 - (unsigned int)v15 ^ v12 / 32;\n    v14 = v11 - (unsigned int)v15 - v7 ^ v13 / 8;\n    v15 = (unsigned int)v15 - v13 - v14 ^ v14 * 0x400;\n    v16 = v7 - v14 - v15;\n    v17 = v16 ^ v15 / 0x8000;\n    v3 += 12;\n  }\n  v18 = v17 + a1;\n  switch ((unsigned int)v4) {\n  case 7:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 6)) * 0x10000);\n  LABEL_40ae89:\n    break;\n  case 5:\n    goto LABEL_40aeb6;\n  case 3:\n  LABEL_40aeb6:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 2)) * 0x10000);\n  LABEL_40aec6:\n    goto LABEL_40aed6;\n  case 1:\n  LABEL_40aed6:\n    v19 = *((char *)v3);\n    v14 = (unsigned int)v14 + v19;\n    goto LABEL_40aedf;\n  case 11:\n    v18 += *((char *)(v3 + 10)) * 0x1000000;\n  case 10:\n    v18 = (unsigned int)v18 + (unsigned int)(*((char *)(v3 + 9)) * 0x10000);\n    goto LABEL_0x40ae5a;\n  case 8:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 7)) * 0x1000000);\n    goto LABEL_40ae89;\n  case 6:\n  LABEL_40ae89:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 5)) * 0x100);\n    goto LABEL_0x40ae99;\n  case 4:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 3)) * 0x1000000);\n  LABEL_40aeb6:\n    goto LABEL_40aec6;\n  case 2:\n  LABEL_40aec6:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 1)) * 0x100);\n  LABEL_40aed6:\n    v19 = *((char *)v3);\n    goto LABEL_40aedf;\n  default:\n  LABEL_40aedf:\n    v20 =\n        (unsigned int)v14 - (unsigned int)v15 - v7 ^ (unsigned int)v18 / 0x2000;\n    v21 = (unsigned int)v15 - v7 - (unsigned int)v14 ^ v20 * 0x100;\n    v22 = v7 - v20 - (unsigned int)v15 ^ v21 / 0x2000;\n    v23 = v20 - (unsigned int)v15 - v7 ^ v22 / 0x1000;\n    v24 = (unsigned int)v15 - v22 - (unsigned int)v14 ^ v23 * 0x10000;\n    v25 = v7 - v23 - (unsigned int)v15 ^ v24 / 32;\n    v26 = v23 - (unsigned int)v15 - v7 ^ v25 / 8;\n    v27 = (unsigned int)v15 - v25 - (unsigned int)v14 ^ v26 * 0x400;\n    return v7 - v26 - (unsigned int)v15 ^ v27 / 0x8000;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:48:8: error: array type 'char[12]' is not assignable\n   48 |     v3 = a0;\n      |     ~~ ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:67:12: error: invalid operands to binary expression\n('char[12]' and 'int') 67 |         v3 += 12; |         ~~ ^  ~~\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:97:1: error: redefinition of label 'LABEL_40ae89'\n   97 | LABEL_40ae89:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:74:1: note: previous definition is here\n   74 | LABEL_40ae89:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:102:1: error: redefinition of label 'LABEL_40aeb6'\n  102 | LABEL_40aeb6:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:79:1: note: previous definition is here\n   79 | LABEL_40aeb6:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:105:1: error: redefinition of label 'LABEL_40aec6'\n  105 | LABEL_40aec6:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:81:1: note: previous definition is here\n   81 | LABEL_40aec6:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:107:1: error: redefinition of label 'LABEL_40aed6'\n  107 | LABEL_40aed6:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:84:1: note: previous definition is here\n   84 | LABEL_40aed6:\n      | ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:92:14: error: use of undeclared label\n'LABEL_0x40ae5a' 92 |         goto LABEL_0x40ae5a; |              ^\n/tmp/tmphryrb2k3/hash_str_name_conflict.c:99:14: error: use of undeclared label\n'LABEL_0x40ae99' 99 |         goto LABEL_0x40ae99; |              ^ 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long khash_fit_capacity_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a0; v0 *= 2)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_quicksort_cmp_name_conflict(unsigned long a0, unsigned long a1) {\n  return (unsigned int)a0 - (unsigned int)a1;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnprfucj1/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() {\n  unsigned long long v2; // rax\n\n  v2 = strerror(*(__errno_location()));\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmporbulscf/k_strerr_name_conflict.c:22:19: error: indirection requires pointer operand\n('int' invalid) 22 |     v2 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\nlong long k_chbindir_name_conflict() {\n  void *v0;          // [bp-0x118]\n  void *v1;          // [bp-0x110]\n  void *v2;          // [bp-0x108]\n  void *v3;          // [bp-0x100]\n  void *v4;          // [bp-0xf8]\n  void *v5;          // [bp-0xf0]\n  void *v6;          // [bp-0xe8]\n  void *v7;          // [bp-0xe0]\n  void *v8;          // [bp-0xd8]\n  void *v9;          // [bp-0xd0]\n  void *v10;         // [bp-0xc8]\n  void *v11;         // [bp-0xc0]\n  void *v12;         // [bp-0xb8]\n  void *v13;         // [bp-0xb0]\n  void *v14;         // [bp-0xa8]\n  void *v15;         // [bp-0xa0]\n  void *v16;         // [bp-0x98]\n  void *v17;         // [bp-0x90]\n  void *v18;         // [bp-0x88]\n  void *v19;         // [bp-0x80]\n  void *v20;         // [bp-0x78]\n  void *v21;         // [bp-0x70]\n  void *v22;         // [bp-0x68]\n  void *v23;         // [bp-0x60]\n  void *v24;         // [bp-0x58]\n  void *v25;         // [bp-0x50]\n  void *v26;         // [bp-0x48]\n  void *v27;         // [bp-0x40]\n  void *v28;         // [bp-0x38]\n  void *v29;         // [bp-0x30]\n  void *v30;         // [bp-0x28]\n  void *v31;         // [bp-0x20]\n  unsigned int v32;  // [bp-0x10]\n  unsigned int v33;  // [bp-0xc]\n  unsigned long v36; // rax\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v32 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if (v32 <= 0)\n    return 1;\n  for (v33 = v32 - 1; *((char *)&v0 + v33) != 47 && v33;\n       *((char *)&v0 + v36) = 0) {\n    v36 = v33;\n    v33 = (unsigned int)v36 - 1;\n  }\n  if (*((char *)&v0 + v33) != 47)\n    return 1;\n  if (!v33)\n    return chdir(&v0);\n  *((char *)&v0 + v33) = 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xc8]\n  unsigned int v1;       // [bp-0xc0]\n  unsigned int v2;       // [bp-0x40]\n  unsigned int v3[3];    // [bp-0x28]\n  unsigned long long v4; // [bp-0x20]\n  char *v5;              // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  *((unsigned long long *)v3) = v4;\n  setrlimit(4, v3);\n  getrlimit(6, v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  v5 = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n  system(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;         // [bp-0xa8]\n  unsigned int v1; // [bp-0xa0]\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  v4 = 0;\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  v3 = fork();\n  if (v3 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if (v3 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    v4 = setsid();\n    if (v4 >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ybt4zev/k_demon_name_conflict.c:40:29: error: indirection requires pointer operand\n('int' invalid) 40 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp2ybt4zev/k_demon_name_conflict.c:57:31: error: indirection\nrequires pointer operand ('int' invalid) 57 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned int v0[3];    // [bp-0xb8]\n  unsigned long long v1; // [bp-0xb0]\n  unsigned long long v2; // [bp-0xa8], Other Possible Types: char\n\n  memset(&v2, 0, 152);\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  *((unsigned long long *)v0) = v1;\n  setrlimit(7, v0);\n  getrlimit(7, v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 0x800;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 1;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return (!shutdown(a0, a1) ? 1 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (v0 == -1) {\n    v0 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnsszp8ld/ksock_close_name_conflict.c:26:13: error: indirection requires pointer\noperand ('int' invalid) 26 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a2;\n  if (!ioctl(a0, a1))\n    return 0;\n  printf(\"ioctl :%s\\n\", (int)k_strerr());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  v0 = a0;\n  v1 = a1;\n  strcpy(a2, inet_ntoa());\n  *(a3) = ntohs(*((short *)((char *)&v0 + 2)));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp93vx782d/ksock_from_addr.c:28:26: error: too few arguments to function\ncall, expected 1, have 0 28 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp93vx782d/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = htons(a2);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 1;\n  if (setsockopt(a0, 1, 2, &v1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  char v1;         // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &a1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v1));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x28]\n  unsigned int v1; // [bp-0x24]\n  unsigned int v2; // [bp-0x20]\n  char v3;         // [bp-0x1c]\n  unsigned int v4; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v4 = 1;\n  if (setsockopt(a0, 1, 9, &v4, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 4, &a1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 5, &a2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 6, &a3, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = socket(2, 1, 0);\n  if (v0 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return 4294967295;\n  }\n  return (!(int)ksock_set_reuse(v0) ? 4294967295 : v0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"bind :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) == -1) {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x3c]\n  unsigned int v1; // [bp-0x2c]\n  sockaddr v2;     // [bp-0x28]\n  char v3;         // [bp-0x26]\n  unsigned int v4; // [bp-0xc]\n\n  v1 = 16;\n  v4 = accept(a0, &v2, &v1);\n  if (v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n    return 4294967295;\n  }\n  strcpy(a1, inet_ntoa());\n  *(a2) = ntohs(*((short *)&v3));\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd5_sr92z/ksock_accept.c:46:26: error: too few arguments to function\ncall, expected 1, have 0 46 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpd5_sr92z/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a2);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"connect :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hash_str_name_conflict(char a0[12], unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x28]\n  unsigned long v2; // rbx\n  char v3[12];      // rax, Other Possible Types: unsigned long\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n  unsigned int v5;  // r13d\n  unsigned int v6;  // r12d\n  unsigned int v7;  // ebx\n  unsigned int v8;  // r13d\n  unsigned int v9;  // r12d\n  unsigned int v10; // ebx\n  unsigned int v11; // r13d\n  unsigned int v12; // r12d\n  unsigned int v13; // ebx\n  unsigned int\n      v14; // r13d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      v15; // r12d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int v16;  // ebx\n  unsigned long v17; // rbx, Other Possible Types: unsigned long long\n  unsigned long v18; // rbx, Other Possible Types: unsigned int\n  unsigned int v19;  // eax\n  unsigned int v20;  // r13d\n  unsigned int v21;  // r12d\n  unsigned int v22;  // ebx\n  unsigned int v23;  // r13d\n  unsigned int v24;  // r12d\n  unsigned int v25;  // ebx\n  unsigned int v26;  // r13d\n  unsigned int v27;  // r12d\n\n  v0 = v2;\n  v3 = a0;\n  v4 = a1;\n  v15 = 2654435769;\n  v14 = 2654435769;\n  for (v17 = a2; (unsigned int)v4 > 11; v4 = (unsigned int)v4 - 12) {\n    v5 = (unsigned int)v14 + *((char *)(v3 + 3)) * 0x1000000 + *((char *)v3) +\n         *((char *)(v3 + 1)) * 0x100 + *((char *)(v3 + 2)) * 0x10000;\n    v6 = (unsigned int)v15 + *((char *)(v3 + 7)) * 0x1000000 +\n         *((char *)(v3 + 4)) + *((char *)(v3 + 5)) * 0x100 +\n         *((char *)(v3 + 6)) * 0x10000;\n    v7 = v17 + *((char *)(v3 + 11)) * 0x1000000 + *((char *)(v3 + 8)) +\n         *((char *)(v3 + 9)) * 0x100 + *((char *)(v3 + 10)) * 0x10000;\n    v8 = (unsigned int)v14 - v6 - v7 ^ v7 / 0x2000;\n    v9 = v6 - v7 - (unsigned int)v14 ^ v8 * 0x100;\n    v10 = v7 - v8 - (unsigned int)v15 ^ v9 / 0x2000;\n    v11 = v8 - (unsigned int)v15 - v7 ^ v10 / 0x1000;\n    v12 = (unsigned int)v15 - v10 - (unsigned int)v14 ^ v11 * 0x10000;\n    v13 = v7 - v11 - (unsigned int)v15 ^ v12 / 32;\n    v14 = v11 - (unsigned int)v15 - v7 ^ v13 / 8;\n    v15 = (unsigned int)v15 - v13 - v14 ^ v14 * 0x400;\n    v16 = v7 - v14 - v15;\n    v17 = v16 ^ v15 / 0x8000;\n    v3 += 12;\n  }\n  v18 = v17 + a1;\n  switch ((unsigned int)v4) {\n  case 7:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 6)) * 0x10000);\n  LABEL_40aed9:\n    break;\n  case 5:\n    goto LABEL_40af06;\n  case 3:\n  LABEL_40af06:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 2)) * 0x10000);\n  LABEL_40af16:\n    goto LABEL_40af26;\n  case 1:\n  LABEL_40af26:\n    v19 = *((char *)v3);\n    v14 = (unsigned int)v14 + v19;\n    goto LABEL_40af2f;\n  case 11:\n    v18 += *((char *)(v3 + 10)) * 0x1000000;\n  case 10:\n    v18 = (unsigned int)v18 + (unsigned int)(*((char *)(v3 + 9)) * 0x10000);\n    goto LABEL_0x40aeaa;\n  case 8:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 7)) * 0x1000000);\n    goto LABEL_40aed9;\n  case 6:\n  LABEL_40aed9:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 5)) * 0x100);\n    goto LABEL_0x40aee9;\n  case 4:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 3)) * 0x1000000);\n  LABEL_40af06:\n    goto LABEL_40af16;\n  case 2:\n  LABEL_40af16:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 1)) * 0x100);\n  LABEL_40af26:\n    v19 = *((char *)v3);\n    goto LABEL_40af2f;\n  default:\n  LABEL_40af2f:\n    v20 =\n        (unsigned int)v14 - (unsigned int)v15 - v7 ^ (unsigned int)v18 / 0x2000;\n    v21 = (unsigned int)v15 - v7 - (unsigned int)v14 ^ v20 * 0x100;\n    v22 = v7 - v20 - (unsigned int)v15 ^ v21 / 0x2000;\n    v23 = v20 - (unsigned int)v15 - v7 ^ v22 / 0x1000;\n    v24 = (unsigned int)v15 - v22 - (unsigned int)v14 ^ v23 * 0x10000;\n    v25 = v7 - v23 - (unsigned int)v15 ^ v24 / 32;\n    v26 = v23 - (unsigned int)v15 - v7 ^ v25 / 8;\n    v27 = (unsigned int)v15 - v25 - (unsigned int)v14 ^ v26 * 0x400;\n    return v7 - v26 - (unsigned int)v15 ^ v27 / 0x8000;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:48:8: error: array type 'char[12]' is not assignable\n   48 |     v3 = a0;\n      |     ~~ ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:67:12: error: invalid operands to binary expression\n('char[12]' and 'int') 67 |         v3 += 12; |         ~~ ^  ~~\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:97:1: error: redefinition of label 'LABEL_40aed9'\n   97 | LABEL_40aed9:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:74:1: note: previous definition is here\n   74 | LABEL_40aed9:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:102:1: error: redefinition of label 'LABEL_40af06'\n  102 | LABEL_40af06:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:79:1: note: previous definition is here\n   79 | LABEL_40af06:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:105:1: error: redefinition of label 'LABEL_40af16'\n  105 | LABEL_40af16:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:81:1: note: previous definition is here\n   81 | LABEL_40af16:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:107:1: error: redefinition of label 'LABEL_40af26'\n  107 | LABEL_40af26:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:84:1: note: previous definition is here\n   84 | LABEL_40af26:\n      | ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:92:14: error: use of undeclared label\n'LABEL_0x40aeaa' 92 |         goto LABEL_0x40aeaa; |              ^\n/tmp/tmpa9ap1pvx/hash_str_name_conflict.c:99:14: error: use of undeclared label\n'LABEL_0x40aee9' 99 |         goto LABEL_0x40aee9; |              ^ 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long khash_fit_capacity_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a0; v0 *= 2)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_quicksort_cmp_name_conflict(unsigned long a0, unsigned long a1) {\n  return (unsigned int)a0 - (unsigned int)a1;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int ksock_set_non_blocking(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n\n  return fcntl(fd, 4, flags);\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() {\n  unsigned long long v2; // rax\n\n  v2 = strerror(*(__errno_location()));\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplg5go4o5/k_strerr_name_conflict.c:22:19: error: indirection requires pointer operand\n('int' invalid) 22 |     v2 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\nlong long k_chbindir_name_conflict() {\n  void *v0;          // [bp-0x118]\n  void *v1;          // [bp-0x110]\n  void *v2;          // [bp-0x108]\n  void *v3;          // [bp-0x100]\n  void *v4;          // [bp-0xf8]\n  void *v5;          // [bp-0xf0]\n  void *v6;          // [bp-0xe8]\n  void *v7;          // [bp-0xe0]\n  void *v8;          // [bp-0xd8]\n  void *v9;          // [bp-0xd0]\n  void *v10;         // [bp-0xc8]\n  void *v11;         // [bp-0xc0]\n  void *v12;         // [bp-0xb8]\n  void *v13;         // [bp-0xb0]\n  void *v14;         // [bp-0xa8]\n  void *v15;         // [bp-0xa0]\n  void *v16;         // [bp-0x98]\n  void *v17;         // [bp-0x90]\n  void *v18;         // [bp-0x88]\n  void *v19;         // [bp-0x80]\n  void *v20;         // [bp-0x78]\n  void *v21;         // [bp-0x70]\n  void *v22;         // [bp-0x68]\n  void *v23;         // [bp-0x60]\n  void *v24;         // [bp-0x58]\n  void *v25;         // [bp-0x50]\n  void *v26;         // [bp-0x48]\n  void *v27;         // [bp-0x40]\n  void *v28;         // [bp-0x38]\n  void *v29;         // [bp-0x30]\n  void *v30;         // [bp-0x28]\n  void *v31;         // [bp-0x20]\n  unsigned int v32;  // [bp-0x10]\n  unsigned int v33;  // [bp-0xc]\n  unsigned long v36; // rax\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v32 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if (v32 <= 0)\n    return 1;\n  for (v33 = v32 - 1; *((char *)&v0 + v33) != 47 && v33;\n       *((char *)&v0 + v36) = 0) {\n    v36 = v33;\n    v33 = (unsigned int)v36 - 1;\n  }\n  if (*((char *)&v0 + v33) != 47)\n    return 1;\n  if (!v33)\n    return chdir(&v0);\n  *((char *)&v0 + v33) = 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xc8]\n  unsigned int v1;       // [bp-0xc0]\n  unsigned int v2;       // [bp-0x40]\n  unsigned int v3[3];    // [bp-0x28]\n  unsigned long long v4; // [bp-0x20]\n  char *v5;              // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  *((unsigned long long *)v3) = v4;\n  setrlimit(4, v3);\n  getrlimit(6, v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  v5 = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n  system(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;         // [bp-0xa8]\n  unsigned int v1; // [bp-0xa0]\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  v4 = 0;\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  v3 = fork();\n  if (v3 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if (v3 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    v4 = setsid();\n    if (v4 >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu4qofmfm/k_demon_name_conflict.c:40:29: error: indirection requires pointer operand\n('int' invalid) 40 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpu4qofmfm/k_demon_name_conflict.c:57:31: error: indirection\nrequires pointer operand ('int' invalid) 57 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned int v0[3];    // [bp-0xb8]\n  unsigned long long v1; // [bp-0xb0]\n  unsigned long long v2; // [bp-0xa8], Other Possible Types: char\n\n  memset(&v2, 0, 152);\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  *((unsigned long long *)v0) = v1;\n  setrlimit(7, v0);\n  getrlimit(7, v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 0x800;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 1;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return (!shutdown(a0, a1) ? 1 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (v0 == -1) {\n    v0 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm2kmhg8j/ksock_close_name_conflict.c:26:13: error: indirection requires pointer\noperand ('int' invalid) 26 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a2;\n  if (!ioctl(a0, a1))\n    return 0;\n  printf(\"ioctl :%s\\n\", (int)k_strerr());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  v0 = a0;\n  v1 = a1;\n  strcpy(a2, inet_ntoa());\n  *(a3) = ntohs(*((short *)((char *)&v0 + 2)));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbvo_4szr/ksock_from_addr.c:28:26: error: too few arguments to function\ncall, expected 1, have 0 28 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpbvo_4szr/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = htons(a2);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 1;\n  if (setsockopt(a0, 1, 2, &v1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  char v1;         // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &a1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v1));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x28]\n  unsigned int v1; // [bp-0x24]\n  unsigned int v2; // [bp-0x20]\n  char v3;         // [bp-0x1c]\n  unsigned int v4; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v4 = 1;\n  if (setsockopt(a0, 1, 9, &v4, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 4, &a1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 5, &a2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 6, &a3, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = socket(2, 1, 0);\n  if (v0 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return 4294967295;\n  }\n  return (!(int)ksock_set_reuse(v0) ? 4294967295 : v0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"bind :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) == -1) {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x3c]\n  unsigned int v1; // [bp-0x2c]\n  sockaddr v2;     // [bp-0x28]\n  char v3;         // [bp-0x26]\n  unsigned int v4; // [bp-0xc]\n\n  v1 = 16;\n  v4 = accept(a0, &v2, &v1);\n  if (v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n    return 4294967295;\n  }\n  strcpy(a1, inet_ntoa());\n  *(a2) = ntohs(*((short *)&v3));\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpph2pyavi/ksock_accept.c:46:26: error: too few arguments to function\ncall, expected 1, have 0 46 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpph2pyavi/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a2);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"connect :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hash_str_name_conflict(char a0[12], unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x28]\n  unsigned long v2; // rbx\n  char v3[12];      // rax, Other Possible Types: unsigned long\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n  unsigned int v5;  // r13d\n  unsigned int v6;  // r12d\n  unsigned int v7;  // ebx\n  unsigned int v8;  // r13d\n  unsigned int v9;  // r12d\n  unsigned int v10; // ebx\n  unsigned int v11; // r13d\n  unsigned int v12; // r12d\n  unsigned int v13; // ebx\n  unsigned int\n      v14; // r13d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      v15; // r12d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int v16;  // ebx\n  unsigned long v17; // rbx, Other Possible Types: unsigned long long\n  unsigned long v18; // rbx, Other Possible Types: unsigned int\n  unsigned int v19;  // eax\n  unsigned int v20;  // r13d\n  unsigned int v21;  // r12d\n  unsigned int v22;  // ebx\n  unsigned int v23;  // r13d\n  unsigned int v24;  // r12d\n  unsigned int v25;  // ebx\n  unsigned int v26;  // r13d\n  unsigned int v27;  // r12d\n\n  v0 = v2;\n  v3 = a0;\n  v4 = a1;\n  v15 = 2654435769;\n  v14 = 2654435769;\n  for (v17 = a2; (unsigned int)v4 > 11; v4 = (unsigned int)v4 - 12) {\n    v5 = (unsigned int)v14 + *((char *)(v3 + 3)) * 0x1000000 + *((char *)v3) +\n         *((char *)(v3 + 1)) * 0x100 + *((char *)(v3 + 2)) * 0x10000;\n    v6 = (unsigned int)v15 + *((char *)(v3 + 7)) * 0x1000000 +\n         *((char *)(v3 + 4)) + *((char *)(v3 + 5)) * 0x100 +\n         *((char *)(v3 + 6)) * 0x10000;\n    v7 = v17 + *((char *)(v3 + 11)) * 0x1000000 + *((char *)(v3 + 8)) +\n         *((char *)(v3 + 9)) * 0x100 + *((char *)(v3 + 10)) * 0x10000;\n    v8 = (unsigned int)v14 - v6 - v7 ^ v7 / 0x2000;\n    v9 = v6 - v7 - (unsigned int)v14 ^ v8 * 0x100;\n    v10 = v7 - v8 - (unsigned int)v15 ^ v9 / 0x2000;\n    v11 = v8 - (unsigned int)v15 - v7 ^ v10 / 0x1000;\n    v12 = (unsigned int)v15 - v10 - (unsigned int)v14 ^ v11 * 0x10000;\n    v13 = v7 - v11 - (unsigned int)v15 ^ v12 / 32;\n    v14 = v11 - (unsigned int)v15 - v7 ^ v13 / 8;\n    v15 = (unsigned int)v15 - v13 - v14 ^ v14 * 0x400;\n    v16 = v7 - v14 - v15;\n    v17 = v16 ^ v15 / 0x8000;\n    v3 += 12;\n  }\n  v18 = v17 + a1;\n  switch ((unsigned int)v4) {\n  case 7:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 6)) * 0x10000);\n  LABEL_40add2:\n    break;\n  case 5:\n    goto LABEL_40adff;\n  case 3:\n  LABEL_40adff:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 2)) * 0x10000);\n  LABEL_40ae0f:\n    goto LABEL_40ae1f;\n  case 1:\n  LABEL_40ae1f:\n    v19 = *((char *)v3);\n    v14 = (unsigned int)v14 + v19;\n    goto LABEL_40ae28;\n  case 11:\n    v18 += *((char *)(v3 + 10)) * 0x1000000;\n  case 10:\n    v18 = (unsigned int)v18 + (unsigned int)(*((char *)(v3 + 9)) * 0x10000);\n    goto LABEL_0x40ada3;\n  case 8:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 7)) * 0x1000000);\n    goto LABEL_40add2;\n  case 6:\n  LABEL_40add2:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 5)) * 0x100);\n    goto LABEL_0x40ade2;\n  case 4:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 3)) * 0x1000000);\n  LABEL_40adff:\n    goto LABEL_40ae0f;\n  case 2:\n  LABEL_40ae0f:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 1)) * 0x100);\n  LABEL_40ae1f:\n    v19 = *((char *)v3);\n    goto LABEL_40ae28;\n  default:\n  LABEL_40ae28:\n    v20 =\n        (unsigned int)v14 - (unsigned int)v15 - v7 ^ (unsigned int)v18 / 0x2000;\n    v21 = (unsigned int)v15 - v7 - (unsigned int)v14 ^ v20 * 0x100;\n    v22 = v7 - v20 - (unsigned int)v15 ^ v21 / 0x2000;\n    v23 = v20 - (unsigned int)v15 - v7 ^ v22 / 0x1000;\n    v24 = (unsigned int)v15 - v22 - (unsigned int)v14 ^ v23 * 0x10000;\n    v25 = v7 - v23 - (unsigned int)v15 ^ v24 / 32;\n    v26 = v23 - (unsigned int)v15 - v7 ^ v25 / 8;\n    v27 = (unsigned int)v15 - v25 - (unsigned int)v14 ^ v26 * 0x400;\n    return v7 - v26 - (unsigned int)v15 ^ v27 / 0x8000;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:48:8: error: array type 'char[12]' is not assignable\n   48 |     v3 = a0;\n      |     ~~ ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:67:12: error: invalid operands to binary expression\n('char[12]' and 'int') 67 |         v3 += 12; |         ~~ ^  ~~\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:97:1: error: redefinition of label 'LABEL_40add2'\n   97 | LABEL_40add2:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:74:1: note: previous definition is here\n   74 | LABEL_40add2:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:102:1: error: redefinition of label 'LABEL_40adff'\n  102 | LABEL_40adff:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:79:1: note: previous definition is here\n   79 | LABEL_40adff:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:105:1: error: redefinition of label 'LABEL_40ae0f'\n  105 | LABEL_40ae0f:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:81:1: note: previous definition is here\n   81 | LABEL_40ae0f:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:107:1: error: redefinition of label 'LABEL_40ae1f'\n  107 | LABEL_40ae1f:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:84:1: note: previous definition is here\n   84 | LABEL_40ae1f:\n      | ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:92:14: error: use of undeclared label\n'LABEL_0x40ada3' 92 |         goto LABEL_0x40ada3; |              ^\n/tmp/tmp7ir8z295/hash_str_name_conflict.c:99:14: error: use of undeclared label\n'LABEL_0x40ade2' 99 |         goto LABEL_0x40ade2; |              ^ 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long khash_fit_capacity_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a0; v0 *= 2)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_quicksort_cmp_name_conflict(unsigned long a0, unsigned long a1) {\n  return (unsigned int)a0 - (unsigned int)a1;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpotgr7oo7/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() {\n  unsigned long long v2; // rax\n\n  v2 = strerror(*(__errno_location()));\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0ab6c9mp/k_strerr_name_conflict.c:22:19: error: indirection requires pointer operand\n('int' invalid) 22 |     v2 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\nlong long k_chbindir_name_conflict() {\n  void *v0;          // [bp-0x118]\n  void *v1;          // [bp-0x110]\n  void *v2;          // [bp-0x108]\n  void *v3;          // [bp-0x100]\n  void *v4;          // [bp-0xf8]\n  void *v5;          // [bp-0xf0]\n  void *v6;          // [bp-0xe8]\n  void *v7;          // [bp-0xe0]\n  void *v8;          // [bp-0xd8]\n  void *v9;          // [bp-0xd0]\n  void *v10;         // [bp-0xc8]\n  void *v11;         // [bp-0xc0]\n  void *v12;         // [bp-0xb8]\n  void *v13;         // [bp-0xb0]\n  void *v14;         // [bp-0xa8]\n  void *v15;         // [bp-0xa0]\n  void *v16;         // [bp-0x98]\n  void *v17;         // [bp-0x90]\n  void *v18;         // [bp-0x88]\n  void *v19;         // [bp-0x80]\n  void *v20;         // [bp-0x78]\n  void *v21;         // [bp-0x70]\n  void *v22;         // [bp-0x68]\n  void *v23;         // [bp-0x60]\n  void *v24;         // [bp-0x58]\n  void *v25;         // [bp-0x50]\n  void *v26;         // [bp-0x48]\n  void *v27;         // [bp-0x40]\n  void *v28;         // [bp-0x38]\n  void *v29;         // [bp-0x30]\n  void *v30;         // [bp-0x28]\n  void *v31;         // [bp-0x20]\n  unsigned int v32;  // [bp-0x10]\n  unsigned int v33;  // [bp-0xc]\n  unsigned long v36; // rax\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v32 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if (v32 <= 0)\n    return 1;\n  for (v33 = v32 - 1; *((char *)&v0 + v33) != 47 && v33;\n       *((char *)&v0 + v36) = 0) {\n    v36 = v33;\n    v33 = (unsigned int)v36 - 1;\n  }\n  if (*((char *)&v0 + v33) != 47)\n    return 1;\n  if (!v33)\n    return chdir(&v0);\n  *((char *)&v0 + v33) = 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xc8]\n  unsigned int v1;       // [bp-0xc0]\n  unsigned int v2;       // [bp-0x40]\n  unsigned int v3[3];    // [bp-0x28]\n  unsigned long long v4; // [bp-0x20]\n  char *v5;              // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  *((unsigned long long *)v3) = v4;\n  setrlimit(4, v3);\n  getrlimit(6, v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  v5 = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n  system(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;         // [bp-0xa8]\n  unsigned int v1; // [bp-0xa0]\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  v4 = 0;\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  v3 = fork();\n  if (v3 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if (v3 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    v4 = setsid();\n    if (v4 >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaldap4m7/k_demon_name_conflict.c:40:29: error: indirection requires pointer operand\n('int' invalid) 40 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpaldap4m7/k_demon_name_conflict.c:57:31: error: indirection\nrequires pointer operand ('int' invalid) 57 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned int v0[3];    // [bp-0xb8]\n  unsigned long long v1; // [bp-0xb0]\n  char v2;               // [bp-0xa8], Other Possible Types: unsigned long long\n\n  memset(&v2, 0, 152);\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  *((unsigned long long *)v0) = v1;\n  setrlimit(7, v0);\n  getrlimit(7, v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 0x800;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 1;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return (!shutdown(a0, a1) ? 1 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (v0 == -1) {\n    v0 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuc29pcw9/ksock_close_name_conflict.c:26:13: error: indirection requires pointer\noperand ('int' invalid) 26 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a2;\n  if (!ioctl(a0, a1))\n    return 0;\n  printf(\"ioctl :%s\\n\", (int)k_strerr());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  v0 = a0;\n  v1 = a1;\n  strcpy(a2, inet_ntoa());\n  *(a3) = ntohs(*((short *)((char *)&v0 + 2)));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpee06e9a0/ksock_from_addr.c:28:26: error: too few arguments to function\ncall, expected 1, have 0 28 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpee06e9a0/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = htons(a2);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 1;\n  if (setsockopt(a0, 1, 2, &v1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  char v1;         // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &a1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v1));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x28]\n  unsigned int v1; // [bp-0x24]\n  unsigned int v2; // [bp-0x20]\n  char v3;         // [bp-0x1c]\n  unsigned int v4; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v4 = 1;\n  if (setsockopt(a0, 1, 9, &v4, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 4, &a1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 5, &a2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 6, &a3, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = socket(2, 1, 0);\n  if (v0 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return 4294967295;\n  }\n  return (!(int)ksock_set_reuse(v0) ? 4294967295 : v0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"bind :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) == -1) {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x3c]\n  unsigned int v1; // [bp-0x2c]\n  sockaddr v2;     // [bp-0x28]\n  char v3;         // [bp-0x26]\n  unsigned int v4; // [bp-0xc]\n\n  v1 = 16;\n  v4 = accept(a0, &v2, &v1);\n  if (v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n    return 4294967295;\n  }\n  strcpy(a1, inet_ntoa());\n  *(a2) = ntohs(*((short *)&v3));\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpitnwzy1q/ksock_accept.c:46:26: error: too few arguments to function\ncall, expected 1, have 0 46 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpitnwzy1q/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a2);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"connect :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hash_str_name_conflict(char a0[12], unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x28]\n  unsigned long v2; // rbx\n  char v3[12];      // rax, Other Possible Types: unsigned long\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n  unsigned int v5;  // r13d\n  unsigned int v6;  // r12d\n  unsigned int v7;  // ebx\n  unsigned int v8;  // r13d\n  unsigned int v9;  // r12d\n  unsigned int v10; // ebx\n  unsigned int v11; // r13d\n  unsigned int v12; // r12d\n  unsigned int v13; // ebx\n  unsigned int\n      v14; // r13d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      v15; // r12d, Other Possible Types: unsigned long, unsigned long long\n  unsigned int v16;  // ebx\n  unsigned long v17; // rbx, Other Possible Types: unsigned long long\n  unsigned long v18; // rbx, Other Possible Types: unsigned int\n  unsigned int v19;  // eax\n  unsigned int v20;  // r13d\n  unsigned int v21;  // r12d\n  unsigned int v22;  // ebx\n  unsigned int v23;  // r13d\n  unsigned int v24;  // r12d\n  unsigned int v25;  // ebx\n  unsigned int v26;  // r13d\n  unsigned int v27;  // r12d\n\n  v0 = v2;\n  v3 = a0;\n  v4 = a1;\n  v15 = 2654435769;\n  v14 = 2654435769;\n  for (v17 = a2; (unsigned int)v4 > 11; v4 = (unsigned int)v4 - 12) {\n    v5 = (unsigned int)v14 + *((char *)(v3 + 3)) * 0x1000000 + *((char *)v3) +\n         *((char *)(v3 + 1)) * 0x100 + *((char *)(v3 + 2)) * 0x10000;\n    v6 = (unsigned int)v15 + *((char *)(v3 + 7)) * 0x1000000 +\n         *((char *)(v3 + 4)) + *((char *)(v3 + 5)) * 0x100 +\n         *((char *)(v3 + 6)) * 0x10000;\n    v7 = v17 + *((char *)(v3 + 11)) * 0x1000000 + *((char *)(v3 + 8)) +\n         *((char *)(v3 + 9)) * 0x100 + *((char *)(v3 + 10)) * 0x10000;\n    v8 = (unsigned int)v14 - v6 - v7 ^ v7 / 0x2000;\n    v9 = v6 - v7 - (unsigned int)v14 ^ v8 * 0x100;\n    v10 = v7 - v8 - (unsigned int)v15 ^ v9 / 0x2000;\n    v11 = v8 - (unsigned int)v15 - v7 ^ v10 / 0x1000;\n    v12 = (unsigned int)v15 - v10 - (unsigned int)v14 ^ v11 * 0x10000;\n    v13 = v7 - v11 - (unsigned int)v15 ^ v12 / 32;\n    v14 = v11 - (unsigned int)v15 - v7 ^ v13 / 8;\n    v15 = (unsigned int)v15 - v13 - v14 ^ v14 * 0x400;\n    v16 = v7 - v14 - v15;\n    v17 = v16 ^ v15 / 0x8000;\n    v3 += 12;\n  }\n  v18 = v17 + a1;\n  switch ((unsigned int)v4) {\n  case 7:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 6)) * 0x10000);\n  LABEL_40adff:\n    break;\n  case 5:\n    goto LABEL_40ae2c;\n  case 3:\n  LABEL_40ae2c:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 2)) * 0x10000);\n  LABEL_40ae3c:\n    goto LABEL_40ae4c;\n  case 1:\n  LABEL_40ae4c:\n    v19 = *((char *)v3);\n    v14 = (unsigned int)v14 + v19;\n    goto LABEL_40ae55;\n  case 11:\n    v18 += *((char *)(v3 + 10)) * 0x1000000;\n  case 10:\n    v18 = (unsigned int)v18 + (unsigned int)(*((char *)(v3 + 9)) * 0x10000);\n    goto LABEL_0x40add0;\n  case 8:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 7)) * 0x1000000);\n    goto LABEL_40adff;\n  case 6:\n  LABEL_40adff:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 5)) * 0x100);\n    goto LABEL_0x40ae0f;\n  case 4:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 3)) * 0x1000000);\n  LABEL_40ae2c:\n    goto LABEL_40ae3c;\n  case 2:\n  LABEL_40ae3c:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 1)) * 0x100);\n  LABEL_40ae4c:\n    v19 = *((char *)v3);\n    goto LABEL_40ae55;\n  default:\n  LABEL_40ae55:\n    v20 =\n        (unsigned int)v14 - (unsigned int)v15 - v7 ^ (unsigned int)v18 / 0x2000;\n    v21 = (unsigned int)v15 - v7 - (unsigned int)v14 ^ v20 * 0x100;\n    v22 = v7 - v20 - (unsigned int)v15 ^ v21 / 0x2000;\n    v23 = v20 - (unsigned int)v15 - v7 ^ v22 / 0x1000;\n    v24 = (unsigned int)v15 - v22 - (unsigned int)v14 ^ v23 * 0x10000;\n    v25 = v7 - v23 - (unsigned int)v15 ^ v24 / 32;\n    v26 = v23 - (unsigned int)v15 - v7 ^ v25 / 8;\n    v27 = (unsigned int)v15 - v25 - (unsigned int)v14 ^ v26 * 0x400;\n    return v7 - v26 - (unsigned int)v15 ^ v27 / 0x8000;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:48:8: error: array type 'char[12]' is not assignable\n   48 |     v3 = a0;\n      |     ~~ ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:67:12: error: invalid operands to binary expression\n('char[12]' and 'int') 67 |         v3 += 12; |         ~~ ^  ~~\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:97:1: error: redefinition of label 'LABEL_40adff'\n   97 | LABEL_40adff:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:74:1: note: previous definition is here\n   74 | LABEL_40adff:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:102:1: error: redefinition of label 'LABEL_40ae2c'\n  102 | LABEL_40ae2c:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:79:1: note: previous definition is here\n   79 | LABEL_40ae2c:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:105:1: error: redefinition of label 'LABEL_40ae3c'\n  105 | LABEL_40ae3c:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:81:1: note: previous definition is here\n   81 | LABEL_40ae3c:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:107:1: error: redefinition of label 'LABEL_40ae4c'\n  107 | LABEL_40ae4c:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:84:1: note: previous definition is here\n   84 | LABEL_40ae4c:\n      | ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:92:14: error: use of undeclared label\n'LABEL_0x40add0' 92 |         goto LABEL_0x40add0; |              ^\n/tmp/tmpgf53asmo/hash_str_name_conflict.c:99:14: error: use of undeclared label\n'LABEL_0x40ae0f' 99 |         goto LABEL_0x40ae0f; |              ^ 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long khash_fit_capacity_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a0; v0 *= 2)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_quicksort_cmp_name_conflict(unsigned long a0, unsigned long a1) {\n  return (unsigned int)a0 - (unsigned int)a1;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmsje6_p6/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() {\n  unsigned long long v2; // rax\n\n  v2 = strerror(*(__errno_location()));\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvs1bdrld/k_strerr_name_conflict.c:22:19: error: indirection requires pointer operand\n('int' invalid) 22 |     v2 = strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\nlong long k_chbindir_name_conflict() {\n  void *v0;          // [bp-0x118]\n  void *v1;          // [bp-0x110]\n  void *v2;          // [bp-0x108]\n  void *v3;          // [bp-0x100]\n  void *v4;          // [bp-0xf8]\n  void *v5;          // [bp-0xf0]\n  void *v6;          // [bp-0xe8]\n  void *v7;          // [bp-0xe0]\n  void *v8;          // [bp-0xd8]\n  void *v9;          // [bp-0xd0]\n  void *v10;         // [bp-0xc8]\n  void *v11;         // [bp-0xc0]\n  void *v12;         // [bp-0xb8]\n  void *v13;         // [bp-0xb0]\n  void *v14;         // [bp-0xa8]\n  void *v15;         // [bp-0xa0]\n  void *v16;         // [bp-0x98]\n  void *v17;         // [bp-0x90]\n  void *v18;         // [bp-0x88]\n  void *v19;         // [bp-0x80]\n  void *v20;         // [bp-0x78]\n  void *v21;         // [bp-0x70]\n  void *v22;         // [bp-0x68]\n  void *v23;         // [bp-0x60]\n  void *v24;         // [bp-0x58]\n  void *v25;         // [bp-0x50]\n  void *v26;         // [bp-0x48]\n  void *v27;         // [bp-0x40]\n  void *v28;         // [bp-0x38]\n  void *v29;         // [bp-0x30]\n  void *v30;         // [bp-0x28]\n  void *v31;         // [bp-0x20]\n  unsigned int v32;  // [bp-0x10]\n  unsigned int v33;  // [bp-0xc]\n  unsigned long v36; // rax\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v32 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if (v32 <= 0)\n    return 1;\n  for (v33 = v32 - 1; *((char *)&v0 + v33) != 47 && v33;\n       *((char *)&v0 + v36) = 0) {\n    v36 = v33;\n    v33 = (unsigned int)v36 - 1;\n  }\n  if (*((char *)&v0 + v33) != 47)\n    return 1;\n  if (!v33)\n    return chdir(&v0);\n  *((char *)&v0 + v33) = 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xc8]\n  unsigned int v1;       // [bp-0xc0]\n  unsigned int v2;       // [bp-0x40]\n  unsigned int v3[3];    // [bp-0x28]\n  unsigned long long v4; // [bp-0x20]\n  char *v5;              // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  *((unsigned long long *)v3) = v4;\n  setrlimit(4, v3);\n  getrlimit(6, v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  v5 = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n  system(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;         // [bp-0xa8]\n  unsigned int v1; // [bp-0xa0]\n  unsigned int v2; // [bp-0x20]\n  unsigned int v3; // [bp-0x10]\n  unsigned int v4; // [bp-0xc]\n\n  v4 = 0;\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  v3 = fork();\n  if (v3 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if (v3 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    v4 = setsid();\n    if (v4 >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbtf0r7ts/k_demon_name_conflict.c:40:29: error: indirection requires pointer operand\n('int' invalid) 40 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpbtf0r7ts/k_demon_name_conflict.c:57:31: error: indirection\nrequires pointer operand ('int' invalid) 57 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned int v0[3];    // [bp-0xb8]\n  unsigned long long v1; // [bp-0xb0]\n  char v2;               // [bp-0xa8], Other Possible Types: unsigned long long\n\n  memset(&v2, 0, 152);\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  *((unsigned long long *)v0) = v1;\n  setrlimit(7, v0);\n  getrlimit(7, v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 0x800;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x1c]\n  unsigned int v1;       // [bp-0xc]\n  char v2;               // [bp-0x8]\n  unsigned long long v4; // rbp\n\n  v4 = &v2;\n  v1 = fcntl(a0, 3);\n  if (v1 == -1)\n    return 1;\n  v1 |= 1;\n  v1 = fcntl(*((int *)&v0), 4);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return (!shutdown(a0, a1) ? 1 : 0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  while (v0 == -1) {\n    v0 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6qtxajf_/ksock_close_name_conflict.c:26:13: error: indirection requires pointer\noperand ('int' invalid) 26 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a2;\n  if (!ioctl(a0, a1))\n    return 0;\n  printf(\"ioctl :%s\\n\", (int)k_strerr());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n\n  v0 = a0;\n  v1 = a1;\n  strcpy(a2, inet_ntoa());\n  *(a3) = ntohs(*((short *)((char *)&v0 + 2)));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpanf7u0or/ksock_from_addr.c:28:26: error: too few arguments to function\ncall, expected 1, have 0 28 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpanf7u0or/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = htons(a2);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  char v0;         // [bp-0x1c]\n  unsigned int v1; // [bp-0xc]\n\n  v1 = 1;\n  if (setsockopt(a0, 1, 2, &v1, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0x10]\n  char v1;         // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &v0, 4) != -1)\n    return 0;\n  printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v1));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x28]\n  unsigned int v1; // [bp-0x24]\n  unsigned int v2; // [bp-0x20]\n  char v3;         // [bp-0x1c]\n  unsigned int v4; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v4 = 1;\n  if (setsockopt(a0, 1, 9, &v4, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 4, &a1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 5, &a2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else if (setsockopt(*((int *)&v3), 6, 6, &v0, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           *((int *)&v3));\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = socket(2, 1, 0);\n  if (v0 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return 4294967295;\n  }\n  return (!(int)ksock_set_reuse(v0) ? 4294967295 : v0);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"bind :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a1);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) == -1) {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nunsigned short(ntohs)(unsigned short);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  char v0;         // [bp-0x3c]\n  unsigned int v1; // [bp-0x2c]\n  sockaddr v2;     // [bp-0x28]\n  char v3;         // [bp-0x26]\n  unsigned int v4; // [bp-0xc]\n\n  v1 = 16;\n  v4 = accept(a0, &v2, &v1);\n  if (v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), *((int *)&v0));\n    return 4294967295;\n  }\n  strcpy(a1, inet_ntoa());\n  *(a2) = ntohs(*((short *)&v3));\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9fugosou/ksock_accept.c:46:26: error: too few arguments to function\ncall, expected 1, have 0 46 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp9fugosou/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(htons)(unsigned short);\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = htons(a2);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) != -1)\n    return 0;\n  printf(\"connect :%d\\n\", (int)k_errno());\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hash_str_name_conflict(char a0[12], unsigned long a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x28]\n  unsigned long v2; // rbx\n  char v3[12];      // rax, Other Possible Types: unsigned long\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n  unsigned int v5;  // r13d\n  unsigned int v6;  // r12d\n  unsigned int v7;  // ebx\n  unsigned int v8;  // r13d\n  unsigned int v9;  // r12d\n  unsigned int v10; // ebx\n  unsigned int v11; // r13d\n  unsigned int v12; // r12d\n  unsigned int v13; // ebx\n  unsigned int\n      v14; // r13d, Other Possible Types: unsigned long, unsigned long long\n  unsigned long\n      v15; // r12d, Other Possible Types: unsigned int, unsigned long long\n  unsigned int v16;  // ebx\n  unsigned long v17; // rbx, Other Possible Types: unsigned long long\n  unsigned long v18; // rbx, Other Possible Types: unsigned int\n  unsigned int v19;  // eax\n  unsigned int v20;  // r13d\n  unsigned int v21;  // r12d\n  unsigned int v22;  // ebx\n  unsigned int v23;  // r13d\n  unsigned int v24;  // r12d\n  unsigned int v25;  // ebx\n  unsigned int v26;  // r13d\n  unsigned int v27;  // r12d\n\n  v0 = v2;\n  v3 = a0;\n  v4 = a1;\n  v15 = 2654435769;\n  v14 = 2654435769;\n  for (v17 = a2; (unsigned int)v4 > 11; v4 = (unsigned int)v4 - 12) {\n    v5 = (unsigned int)v14 + *((char *)(v3 + 3)) * 0x1000000 + *((char *)v3) +\n         *((char *)(v3 + 1)) * 0x100 + *((char *)(v3 + 2)) * 0x10000;\n    v6 = (unsigned int)v15 + *((char *)(v3 + 7)) * 0x1000000 +\n         *((char *)(v3 + 4)) + *((char *)(v3 + 5)) * 0x100 +\n         *((char *)(v3 + 6)) * 0x10000;\n    v7 = v17 + *((char *)(v3 + 11)) * 0x1000000 + *((char *)(v3 + 8)) +\n         *((char *)(v3 + 9)) * 0x100 + *((char *)(v3 + 10)) * 0x10000;\n    v8 = (unsigned int)v14 - v6 - v7 ^ v7 / 0x2000;\n    v9 = v6 - v7 - (unsigned int)v14 ^ v8 * 0x100;\n    v10 = v7 - v8 - (unsigned int)v15 ^ v9 / 0x2000;\n    v11 = v8 - (unsigned int)v15 - v7 ^ v10 / 0x1000;\n    v12 = (unsigned int)v15 - v10 - (unsigned int)v14 ^ v11 * 0x10000;\n    v13 = v7 - v11 - (unsigned int)v15 ^ v12 / 32;\n    v14 = v11 - (unsigned int)v15 - v7 ^ v13 / 8;\n    v15 = (unsigned int)v15 - v13 - v14 ^ v14 * 0x400;\n    v16 = v7 - v14 - v15;\n    v17 = v16 ^ v15 / 0x8000;\n    v3 += 12;\n  }\n  v18 = v17 + a1;\n  switch ((unsigned int)v4) {\n  case 7:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 6)) * 0x10000);\n  LABEL_40aed3:\n    break;\n  case 5:\n    goto LABEL_40af00;\n  case 3:\n  LABEL_40af00:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 2)) * 0x10000);\n  LABEL_40af10:\n    goto LABEL_40af20;\n  case 1:\n  LABEL_40af20:\n    v19 = *((char *)v3);\n    v14 = (unsigned int)v14 + v19;\n    goto LABEL_40af29;\n  case 11:\n    v18 += *((char *)(v3 + 10)) * 0x1000000;\n  case 10:\n    v18 = (unsigned int)v18 + (unsigned int)(*((char *)(v3 + 9)) * 0x10000);\n    goto LABEL_0x40aea4;\n  case 8:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 7)) * 0x1000000);\n    goto LABEL_40aed3;\n  case 6:\n  LABEL_40aed3:\n    v15 = (unsigned int)v15 + (unsigned int)(*((char *)(v3 + 5)) * 0x100);\n    goto LABEL_0x40aee3;\n  case 4:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 3)) * 0x1000000);\n  LABEL_40af00:\n    goto LABEL_40af10;\n  case 2:\n  LABEL_40af10:\n    v14 = (unsigned int)v14 + (unsigned int)(*((char *)(v3 + 1)) * 0x100);\n  LABEL_40af20:\n    v19 = *((char *)v3);\n    goto LABEL_40af29;\n  default:\n  LABEL_40af29:\n    v20 =\n        (unsigned int)v14 - (unsigned int)v15 - v7 ^ (unsigned int)v18 / 0x2000;\n    v21 = (unsigned int)v15 - v7 - (unsigned int)v14 ^ v20 * 0x100;\n    v22 = v7 - v20 - (unsigned int)v15 ^ v21 / 0x2000;\n    v23 = v20 - (unsigned int)v15 - v7 ^ v22 / 0x1000;\n    v24 = (unsigned int)v15 - v22 - (unsigned int)v14 ^ v23 * 0x10000;\n    v25 = v7 - v23 - (unsigned int)v15 ^ v24 / 32;\n    v26 = v23 - (unsigned int)v15 - v7 ^ v25 / 8;\n    v27 = (unsigned int)v15 - v25 - (unsigned int)v14 ^ v26 * 0x400;\n    return v7 - v26 - (unsigned int)v15 ^ v27 / 0x8000;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:48:8: error: array type 'char[12]' is not assignable\n   48 |     v3 = a0;\n      |     ~~ ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:67:12: error: invalid operands to binary expression\n('char[12]' and 'int') 67 |         v3 += 12; |         ~~ ^  ~~\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:97:1: error: redefinition of label 'LABEL_40aed3'\n   97 | LABEL_40aed3:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:74:1: note: previous definition is here\n   74 | LABEL_40aed3:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:102:1: error: redefinition of label 'LABEL_40af00'\n  102 | LABEL_40af00:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:79:1: note: previous definition is here\n   79 | LABEL_40af00:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:105:1: error: redefinition of label 'LABEL_40af10'\n  105 | LABEL_40af10:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:81:1: note: previous definition is here\n   81 | LABEL_40af10:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:107:1: error: redefinition of label 'LABEL_40af20'\n  107 | LABEL_40af20:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:84:1: note: previous definition is here\n   84 | LABEL_40af20:\n      | ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:92:14: error: use of undeclared label\n'LABEL_0x40aea4' 92 |         goto LABEL_0x40aea4; |              ^\n/tmp/tmp4ts7dhqp/hash_str_name_conflict.c:99:14: error: use of undeclared label\n'LABEL_0x40aee3' 99 |         goto LABEL_0x40aee3; |              ^ 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long khash_fit_capacity_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  for (v0 = 1; v0 < (unsigned int)a0; v0 *= 2)\n    ;\n  return v0;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_quicksort_cmp_name_conflict(unsigned long a0, unsigned long a1) {\n  return (unsigned int)a0 - (unsigned int)a1;\n}\n","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
