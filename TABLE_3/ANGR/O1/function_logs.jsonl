{"compilable":0,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long strlcpy_name_conflict(char a0[1], struct_0 *a1, unsigned long long a2) {\n  int tmp_2;    // tmp #2\n  struct_0 *v1; // rax, Other Possible Types: unsigned long\n  char v2;      // cl\n\n  v1 = a1;\n  if (a2) {\n    while (true) {\n      tmp_2 = a2;\n      a2 -= 1;\n      if (tmp_2 == 1)\n        break;\n      v1 += 1;\n      a0 += 1;\n      v2 = *((char *)(v1 - 1));\n      *((char *)(a0 - 1)) = v2;\n      if (!v2)\n        return -1 + v1 - (char *)a1;\n    }\n    *((char *)a0) = 0;\n  }\n  do {\n    v1 += 1;\n  } while (*((char *)(v1 - 1)));\n  return -1 + v1 - (char *)a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl4zpfosu/strlcpy_name_conflict.c:18:16: error: expected ';' at end of declaration list\n   18 |     char field_-1;\n      |                ^\n      |                ;\n/tmp/tmpl4zpfosu/strlcpy_name_conflict.c:41:32: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 41 |                 return -1\n+ v1 - (char *)a1; |                        ~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpl4zpfosu/strlcpy_name_conflict.c:49:20: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 49 |     return -1 + v1 -\n(char *)a1; |            ~~~~~~~ ^ ~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":0,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long strlcpy_name_conflict(char a0[1], struct_0 *a1, unsigned long long a2) {\n  int tmp_2;    // tmp #2\n  struct_0 *v1; // rax, Other Possible Types: unsigned long\n  char v2;      // cl\n\n  v1 = a1;\n  if (a2) {\n    while (true) {\n      tmp_2 = a2;\n      a2 -= 1;\n      if (tmp_2 == 1)\n        break;\n      v1 += 1;\n      a0 += 1;\n      v2 = *((char *)(v1 - 1));\n      *((char *)(a0 - 1)) = v2;\n      if (!v2)\n        return -1 + v1 - (char *)a1;\n    }\n    *((char *)a0) = 0;\n  }\n  do {\n    v1 += 1;\n  } while (*((char *)(v1 - 1)));\n  return -1 + v1 - (char *)a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkmypxyg7/strlcpy_name_conflict.c:18:16: error: expected ';' at end of declaration list\n   18 |     char field_-1;\n      |                ^\n      |                ;\n/tmp/tmpkmypxyg7/strlcpy_name_conflict.c:41:32: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 41 |                 return -1\n+ v1 - (char *)a1; |                        ~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpkmypxyg7/strlcpy_name_conflict.c:49:20: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 49 |     return -1 + v1 -\n(char *)a1; |            ~~~~~~~ ^ ~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":0,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long strlcpy_name_conflict(char a0[1], struct_0 *a1, unsigned long long a2) {\n  int tmp_2;    // tmp #2\n  struct_0 *v1; // rax, Other Possible Types: unsigned long\n  char v2;      // cl\n\n  v1 = a1;\n  if (a2) {\n    while (true) {\n      tmp_2 = a2;\n      a2 -= 1;\n      if (tmp_2 == 1)\n        break;\n      v1 += 1;\n      a0 += 1;\n      v2 = *((char *)(v1 - 1));\n      *((char *)(a0 - 1)) = v2;\n      if (!v2)\n        return -1 + v1 - (char *)a1;\n    }\n    *((char *)a0) = 0;\n  }\n  do {\n    v1 += 1;\n  } while (*((char *)(v1 - 1)));\n  return -1 + v1 - (char *)a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpignrv19o/strlcpy_name_conflict.c:18:16: error: expected ';' at end of declaration list\n   18 |     char field_-1;\n      |                ^\n      |                ;\n/tmp/tmpignrv19o/strlcpy_name_conflict.c:41:32: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 41 |                 return -1\n+ v1 - (char *)a1; |                        ~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpignrv19o/strlcpy_name_conflict.c:49:20: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 49 |     return -1 + v1 -\n(char *)a1; |            ~~~~~~~ ^ ~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"int bb_make_directory(char *path, long mode, int flags) {\n    mode_t mask;\n    const char *fail_msg;\n    char *s = path;\n    char c;\n    struct stat st;\n    mask = umask(0);\n    if (mode == -1) {\n        umask(mask);\n        mode = (64 | (64 >> 3) | ((64 >> 3) >> 3) | 128 | (128 >> 3) | ((128 >> 3) >> 3) | 256 | (256 >> 3) | ((256 >> 3) >> 3)) & ~mask;\n    } else {\n        umask(mask & ~192);\n    }\n    do {\n        c = 0;\n        if (flags & FILEUTILS_RECUR) {\n            while (*s)\n                {\n                    if (*s == '/') {\n                        do {\n                            ++s;\n                        } while (*s == '/');\n                        c = *s;\n                        *s = 0;\n                        break;\n                    }\n                    ++s;\n                }\n        }\n        if (mkdir(path, 511) < 0) {\n            if (((*__errno_location()) != 17 && (*__errno_location()) != 21) || !(flags & FILEUTILS_RECUR) || (stat(path, &st) < 0 || !((((st.st_mode)) & 61440) == (16384)))) {\n                fail_msg = \"create\";\n                umask(mask);\n                break;\n            }\n            if (!c) {\n                umask(mask);\n                return 0;\n            }\n        }\n        if (!c) {\n            umask(mask);\n            if ((mode != -1) && (chmod(path, mode) < 0)) {\n                fail_msg = \"set permissions of\";\n                break;\n            }\n            return 0;\n        }\n        *s = c;\n    } while (1);\n    bb_perror_msg(\"Cannot %s directory `%s'\", fail_msg, path);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned short(umask)(unsigned short);\nlong long(bb_perror_msg)(long long, ...);\nint(chmod)(char *, unsigned short);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long bb_make_directory(unsigned long a0, unsigned long a1,\n                            unsigned long a2) {\n  stat v0;           // [bp-0xc8]\n  char v1;           // [bp-0xb0]\n  unsigned long v3;  // r13, Other Possible Types: unsigned long long\n  char *v4;          // rax\n  unsigned short v5; // r14w\n  char v6;           // al\n  char *v7;          // rbx, Other Possible Types: unsigned long\n  char v8;           // r15b\n\n  v3 = a1;\n  (unsigned short)v4 = umask(0);\n  v5 = (unsigned short)v4;\n  if (a1 != -1) {\n    a0 = v4;\n    *((char *)&a0) = (char)a0 & 63;\n    umask((unsigned short)a0);\n  } else {\n    umask((unsigned short)v4);\n    v3 = ~((unsigned int)v4) & 511;\n  }\n  v7 = a0;\n  while (((char)a2 & 4)) {\n    v6 = *((char *)v7);\n    if (v6) {\n      do {\n        if (v6 == 47) {\n          do {\n            v7 += 1;\n            v8 = *((char *)v7);\n          } while (v8 == 47);\n          *((char *)v7) = 0;\n          if (mkdir(a0, 511) >= 0) {\n            if (v8)\n              *((char *)v7) = v8;\n            umask(v5);\n          }\n        }\n      } while ((v7 += 1, v6 = *((char *)v7), v6));\n    }\n    if (mkdir(a0, 511) >= 0)\n      umask(v5);\n    if (!((*(__errno_location()) & -5) == 17) || !(stat(a0, &v0) >= 0) ||\n        !(((short)*((int *)&v1) & 0xf000) == 0x4000)) {\n      umask(v5);\n      bb_perror_msg(\"Cannot %s directory `%s'\");\n      return 4294967295;\n    }\n    if (false) {\n      *((char *)v7) = 0;\n    } else {\n      umask(v5);\n      return 0;\n    }\n  }\n  if (mkdir(a0, 511) < 0) {\n    umask(v5);\n    bb_perror_msg(\"Cannot %s directory `%s'\");\n    return 4294967295;\n  }\n  umask(v5);\n  if (v3 == -1) {\n    return 0;\n  } else if (chmod(a0, v3) >= 0) {\n    return 0;\n  } else {\n    bb_perror_msg(\"Cannot %s directory `%s'\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcvtio7ym/bb_make_directory.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpcvtio7ym/bb_make_directory.c:19:6: note: previous definition is here\n   19 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpcvtio7ym/bb_make_directory.c:54:5: error: must use 'struct' tag to refer\nto type 'stat' 54 |     stat v0;  // [bp-0xc8] |     ^ |     struct\n/tmp/tmpcvtio7ym/bb_make_directory.c:19:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 19 | int (stat)(char *, struct stat { | ^\n/tmp/tmpcvtio7ym/bb_make_directory.c:64:5: error: assignment to cast is illegal,\nlvalue casts are not supported 64 |     (unsigned short)v4 = umask(0); |\n^~~~~~~~~~~~~~~~~~ ~ /tmp/tmpcvtio7ym/bb_make_directory.c:104:16: error:\nindirection requires pointer operand ('int' invalid) 104 |         if\n(!((*(__errno_location()) & -5) == 17) || !(stat(a0, &v0) >= 0) ||\n!(((short)*((int *)&v1) & 0xf000) == 0x4000)) | ^~~~~~~~~~~~~~~~~~~~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"long my_getpwnam(const char *name) {\n    struct passwd *myuser;\n    myuser = getpwnam(name);\n    if (myuser == ((void *)0))\n        bb_error_msg_and_die(\"unknown user name: %s\", name);\n    return myuser->pw_uid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct passwd *(getpwnam)(char *);\nlong long(bb_error_msg_and_die)(...);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long my_getpwnam_name_conflict(char *a0) {\n  struct_0 *v1; // rax\n\n  v1 = getpwnam(a0);\n  if (!v1)\n    bb_error_msg_and_die(); /* do not return */\n  return v1->field_10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphqscv3pw/my_getpwnam_name_conflict.c:17:34: error: ISO C requires a named parameter\nbefore '...' 17 | long long (bb_error_msg_and_die)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"long my_getgrnam(const char *name) {\n    struct group *mygroup;\n    mygroup = getgrnam(name);\n    if (mygroup == ((void *)0))\n        bb_error_msg_and_die(\"unknown group name: %s\", name);\n    return (mygroup->gr_gid);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct group *(getgrnam)(char *);\nlong long(bb_error_msg_and_die)(...);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long my_getgrnam_name_conflict(char *a0) {\n  struct_0 *v1; // rax\n\n  v1 = getgrnam(a0);\n  if (!v1)\n    bb_error_msg_and_die(); /* do not return */\n  return v1->field_10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzl9sf6g0/my_getgrnam_name_conflict.c:17:34: error: ISO C requires a named parameter\nbefore '...' 17 | long long (bb_error_msg_and_die)(...); | ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":1,"function":"char *last_char_is(const char *s, int c) {\n    char *sret = (char *)s;\n    if (sret) {\n        sret = strrchr(sret, c);\n        if (sret != ((void *)0) && *(sret + 1) != 0)\n            sret = ((void *)0);\n    }\n    return sret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long last_char_is_name_conflict(char *a0, unsigned long a1) {\n  struct_0 *v1; // rax, Other Possible Types: unsigned long\n\n  if (!a0)\n    return a0;\n  v1 = strrchr(a0, a1);\n  if (!v1) {\n    return v1;\n  } else if (!v1->field_1) {\n    return v1;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"char *concat_path_file(const char *path, const char *filename) {\n    char *outbuf;\n    char *lc;\n    if (!path)\n        path = \"\";\n    lc = last_char_is(path, '/');\n    while (*filename == '/')\n        filename++;\n    bb_xasprintf(&outbuf, \"%s%s%s\", path, (lc == ((void *)0) ? \"/\" : \"\"), filename);\n    return outbuf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(last_char_is)(long long, long long);\nlong long(bb_xasprintf)(long long, long long, ...);\n\nextern char g_403190;\n\nlong long concat_path_file_name_conflict(unsigned long a0, char *a1) {\n  char v0;               // [bp-0x20]\n  char *v2;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v4; // rax\n\n  v2 = a1;\n  v4 = last_char_is((!a0 ? a0 : &g_403190), 47);\n  if (*(a1) == 47) {\n    do {\n      v2 += 1;\n    } while (*((char *)v2) == 47);\n  }\n  bb_xasprintf(&v0, \"%s%s%s\");\n  return *((long long *)&v0);\n}\n","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"pid_t getppidof(const pid_t pid) {\n    int ppid;\n    char buffer[8192];\n    size_t size;\n    FILE *fp;\n    sprintf(buffer, \"/proc/%d/stat\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            strtok(buffer, \" \");\n            strtok(((void *)0), \" \");\n            strtok(((void *)0), \" \");\n            ppid = atoi(strtok(((void *)0), \" \"));\n        }\n        fclose(fp);\n    }\n    return ppid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nchar *(strtok)(char *, char *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long getppidof_name_conflict(unsigned long a0) {\n  char v0;    // [bp-0x2018]\n  FILE_t *v2; // rax\n\n  sprintf(&v0, \"/proc/%d/stat\", (unsigned int)a0);\n  v2 = fopen(&v0, \"r\");\n  if (!v2)\n    return 0;\n  if (fread(&v0, 1, 0x2000, v2)) {\n    strtok(&v0, \" \");\n    strtok(NULL, \" \");\n    strtok(NULL, \" \");\n  }\n  fclose(v2);\n  return strtol(strtok(NULL, \" \"), NULL, 10);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpxuo3c0kr/getppidof_name_conflict.c:175:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 175 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *getnameof(const pid_t pid) {\n    static char buffer[8192];\n    char *old_buffer, *new_buffer;\n    FILE *fp;\n    size_t size;\n    sprintf(buffer, \"/proc/%d/cmdline\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            new_buffer = strtok(buffer, \"/\");\n            while (new_buffer != ((void *)0))\n                {\n                    old_buffer = new_buffer;\n                    new_buffer = strtok(((void *)0), \"/\");\n                }\n        }\n        fclose(fp);\n    }\n    return old_buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nchar *(strtok)(char *, char *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern char buffer.5;\n\nlong long getnameof_name_conflict(unsigned long a0) {\n  FILE_t *v1;            // rax\n  unsigned long v4;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v5; // rbp\n\n  sprintf(&buffer.5, \"/proc/%d/cmdline\", (unsigned int)a0);\n  v1 = fopen(&buffer.5, \"r\");\n  if (!v1)\n    return 0;\n  if (fread(&buffer.5, 1, 0x2000, v1)) {\n    v4 = strtok(&buffer.5, \"/\");\n    if (v4) {\n      do {\n        v5 = v4;\n        v4 = strtok(NULL, \"/\");\n      } while (v4);\n    }\n  }\n  fclose(v1);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:175:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 175 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:177:19: error: expected ';' after top level\ndeclarator 177 | extern char buffer.5; |                   ^ | ;\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:185:20: error: expected ')'\n  185 |     sprintf(&buffer.5, \"/proc/%d/cmdline\", (unsigned int)a0);\n      |                    ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:185:12: note: to match this '('\n  185 |     sprintf(&buffer.5, \"/proc/%d/cmdline\", (unsigned int)a0);\n      |            ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:186:23: error: expected ')'\n  186 |     v1 = fopen(&buffer.5, \"r\");\n      |                       ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:186:15: note: to match this '('\n  186 |     v1 = fopen(&buffer.5, \"r\");\n      |               ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:189:22: error: expected ')'\n  189 |     if (fread(&buffer.5, 1, 0x2000, v1))\n      |                      ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:189:14: note: to match this '('\n  189 |     if (fread(&buffer.5, 1, 0x2000, v1))\n      |              ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:191:28: error: expected ')'\n  191 |         v4 = strtok(&buffer.5, \"/\");\n      |                            ^\n/tmp/tmp2ug31f3o/getnameof_name_conflict.c:191:20: note: to match this '('\n  191 |         v4 = strtok(&buffer.5, \"/\");\n      |                    ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *_prisma_trytogettermname() {\n    static char _prisma_termname[64];\n    char *tmp = getnameof(getppidof(getsid(getpid())));\n    if (tmp) {\n        strncpy(_prisma_termname, tmp, 64);\n        if (!strncmp(_prisma_termname, \"initdline\", 64) || !strncmp(_prisma_termname, \"konsole\", 64))\n            return _prisma_termname;\n    }\n    strncpy(_prisma_termname, getenv(\"TERM\"), 64);\n    return _prisma_termname;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getsid)(int);\nlong long(getppidof)(long long);\nlong long(getnameof)(long long);\nchar *(getenv)(char *);\nchar *(strncpy)(char *, char *, unsigned long);\n\nextern char _prisma_termname.4;\n\nlong long _prisma_trytogettermname_name_conflict() {\n  char *v1; // rax\n\n  v1 = getnameof(getppidof(getsid(getpid())));\n  if (v1) {\n    strncpy(&_prisma_termname.4, v1, 64);\n    if (!strcmp(&_prisma_termname.4, \"initdline\")) {\n      return &_prisma_termname.4;\n    } else if (!strcmp(&_prisma_termname.4, \"konsole\")) {\n      return &_prisma_termname.4;\n    }\n  }\n  strncpy(&_prisma_termname.4, getenv(\"TERM\"), 64);\n  return &_prisma_termname.4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:22:29: error: expected ';' after top\nlevel declarator 22 | extern char _prisma_termname.4; | ^ | ;\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:31:34: error: expected ')'\n   31 |         strncpy(&_prisma_termname.4, v1, 64);\n      |                                  ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:31:16: note: to match this '('\n   31 |         strncpy(&_prisma_termname.4, v1, 64);\n      |                ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:32:38: error: expected ')'\n   32 |         if (!strcmp(&_prisma_termname.4, \"initdline\"))\n      |                                      ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:32:20: note: to match this '('\n   32 |         if (!strcmp(&_prisma_termname.4, \"initdline\"))\n      |                    ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:34:37: error: expected ';' after\nreturn statement 34 |             return &_prisma_termname.4; | ^ | ;\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:36:43: error: expected ')'\n   36 |         else if (!strcmp(&_prisma_termname.4, \"konsole\"))\n      |                                           ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:36:25: note: to match this '('\n   36 |         else if (!strcmp(&_prisma_termname.4, \"konsole\"))\n      |                         ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:38:37: error: expected ';' after\nreturn statement 38 |             return &_prisma_termname.4; | ^ | ;\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:41:30: error: expected ')'\n   41 |     strncpy(&_prisma_termname.4, getenv(\"TERM\"), 64);\n      |                              ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:41:12: note: to match this '('\n   41 |     strncpy(&_prisma_termname.4, getenv(\"TERM\"), 64);\n      |            ^\n/tmp/tmpiahby3e2/_prisma_trytogettermname_name_conflict.c:42:29: error: expected ';' after\nreturn statement 42 |     return &_prisma_termname.4; | ^ | ; 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"int8_t prisma_adapt(int8_t adaptation) {\n    char *termname;\n    if (adaptation == -1) {\n        termname = _prisma_trytogettermname();\n        if (!strcmp(termname, \"xterm\"))\n            _prisma_adaptation = 2;\n        else if (!strcmp(termname, \"konsole\"))\n            _prisma_adaptation = 1;\n        else if (!strcmp(termname, \"linux\") || !strcmp(termname, \"initdline\"))\n            _prisma_adaptation = 3;\n        else if (!strncmp(termname, \"windows\", 7))\n            _prisma_adaptation = 4;\n        else\n            _prisma_adaptation = 0;\n    } else\n        _prisma_adaptation = adaptation;\n    return _prisma_adaptation;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_prisma_trytogettermname)();\n\nextern char _prisma_adapt_name_conflictation;\n\nlong long prisma_adapt_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x8]\n  unsigned long v2;      // rbx\n  char *v3;              // rbx\n  unsigned long v4;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v5; // rax\n\n  if ((char)a0 != 255) {\n    _prisma_adapt_name_conflictation = a0;\n    return a0;\n  }\n  v0 = v2;\n  v3 = _prisma_trytogettermname();\n  v4 = 2;\n  if (!strcmp(v3, \"xterm\")) {\n    _prisma_adapt_name_conflictation = v4;\n    return v4;\n  }\n  v4 = 1;\n  if (strcmp(v3, \"konsole\")) {\n    v4 = 3;\n    if (strcmp(v3, \"linux\")) {\n      v4 = 3;\n      if (strcmp(v3, \"initdline\")) {\n        (unsigned int)v5 = strncmp(v3, \"windows\", 7);\n        *((char *)&v5) = !(unsigned int)v5;\n        v4 = v5 * 4;\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8nfijnrt/prisma_adapt_name_conflict.c:50:17: error: assignment to cast is illegal,\nlvalue casts are not supported 50 |                 (unsigned int)v5 =\nstrncmp(v3, \"windows\", 7); |                 ^~~~~~~~~~~~~~~~ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbto8color(uint32_t argb) {\n    argb = ((argb & 16711680) >= 8323072 ? 16711680 : 0) | ((argb & 65280) >= 32512 ? 65280 : 0) | ((argb & 255) >= 127 ? 255 : 0);\n    switch (argb) {\n      case 0:\n        return 0;\n      case 16711680:\n        return 1;\n      case 65280:\n        return 2;\n      case 16776960:\n        return 3;\n      case 255:\n        return 4;\n      case 16711935:\n        return 5;\n      case 65535:\n        return 6;\n      case 16777215:\n        return 7;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long prisma_argbto8color_name_conflict(unsigned long a0) {\n  unsigned int v1;  // eax\n  unsigned long v2; // rdx\n\n  v1 = ~(-(((unsigned int)a0 & 0xff0000) < 0x7f0000)) & 0xff0000 |\n       ~(-(((unsigned int)a0 & 0xff00) < 0x7f00)) & 0xff00 |\n       ~(-((unsigned int)a0 < 127));\n  if (v1 == 0xff0000) {\n    return 1;\n  } else if (v1 > 0xff0000) {\n    v2 = 3;\n    if (v1 == 0xffff00)\n      return 3;\n    if (v1 != 16777215) {\n      if (v1 != 16711935)\n        return v2;\n      v2 = 5;\n    } else {\n      return 7;\n    }\n  } else if (v1 == 0xff00) {\n    return 2;\n  } else if (v1 <= 0xff00) {\n    v2 = 0;\n    if (!(v1 && v1 == 255))\n      return v2;\n    v2 = 4;\n  } else {\n    return 6;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_8colortoargb(uint8_t src) {\n    switch (src) {\n      case 0:\n        return 4278190080U;\n      case 1:\n        return 4294901760U;\n      case 2:\n        return 4278255360U;\n      case 3:\n        return 4294967040U;\n      case 4:\n        return 4278190335U;\n      case 5:\n        return 4294902015U;\n      case 6:\n        return 4278255615U;\n      case 7:\n        return 4294967295U;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long prisma_8colortoargb_name_conflict(unsigned long a0) {\n  switch ((char)a0) {\n  case 0:\n    return 0xff000000;\n  case 1:\n    return 0xffff0000;\n  case 2:\n    return 0xff00ff00;\n  case 3:\n    return 0xffffff00;\n  case 4:\n    return 4278190335;\n  case 5:\n    return 4294902015;\n  case 6:\n    return 4278255615;\n  case 7:\n    return 4294967295;\n  default:\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbtoxterm(uint32_t argb) {\n    uint8_t r, g, b;\n    prisma_argbtobytes(argb, ((void *)0), &r, &g, &b);\n    return ((r >= 4 && r <= 246 && r == g && g == b) ? (232 + ((r - 8) * 24 / 238)) : (16 + (36 * (r / 51)) + (6 * (g / 51)) + (b / 51)));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint cx;  // add global variable by heuristics\nint rcx; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long prisma_argbtoxterm_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rax\n  unsigned long long v4; // rdi\n  unsigned long long v5; // rax\n  unsigned long long v6; // rcx\n  unsigned long long v8; // rax\n\n  v1 = a0;\n  if (((char)v1 == (char)v1 & (char)v1 == (char)a0) && a0 - 4 <= 242)\n    return (unsigned int)(((a0 >> 16) * 3 - 24) * 4 / 119) - 24;\n  *((unsigned short *)&v1) = (char)v1 * 161 >> 13;\n  v4 = v1;\n  v1 = a0 / 0x10000;\n  *((unsigned short *)&v5) = (char)v5 * 161;\n  v6 = v5;\n  *((unsigned short *)&v5) = cx<2> >> 13;\n  v1 = a0 / 0x100;\n  *((unsigned short *)&v8) = (char)v8 * 161 >> 13;\n  return v4 + rcx * 36 + 16 + v8 * 6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_zf8xd4m/prisma_argbtoxterm_name_conflict.c:35:38: error: expected expression\n   35 |     *((unsigned short *)&v5) = cx<2> >> 13;\n      |                                      ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_xtermtoargb(uint8_t index) {\n    uint32_t argb;\n    if (index < 8) {\n        argb = prisma_8colortoargb(index);\n        if (argb == 4294967295U)\n            argb = 4290822336U;\n        else\n            argb = 4278190080U | ((argb & 16711680) != 0 ? 8388608 : 0) | ((argb & 65280) != 0 ? 32768 : 0) | ((argb & 255) != 0 ? 128 : 0);\n    } else if (index < 16) {\n        index -= 8;\n        argb = prisma_8colortoargb(index);\n        if (argb == 0)\n            argb = 4286611584U;\n    } else if (index < 232) {\n        index -= 16;\n        argb = 4278190080U | ((51 * (index / 36)) << 16) | ((51 * ((index % 36) / 6)) << 8) | (51 * (index % 6));\n    } else {\n        index -= 232;\n        argb = (8 + (10 * index));\n        argb |= 4278190080U | (argb << 16) | (argb << 8);\n    }\n    return argb;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint cx;  // add global variable by heuristics\nint rcx; // add global variable by heuristics\nint rcx; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(prisma_8colortoargb)(long long);\n\nextern char g_800000;\n\nlong long prisma_xtermtoargb_name_conflict(unsigned long long a0) {\n  unsigned long long v1;  // rdx\n  unsigned long long v4;  // rdi\n  unsigned long v5;       // rax\n  unsigned long long v6;  // rcx\n  unsigned long long v7;  // rax\n  unsigned int v8;        // edx\n  unsigned long long v10; // rax, Other Possible Types: unsigned long\n\n  if ((char)a0 <= 7) {\n    v1 = prisma_8colortoargb(a0);\n    if ((unsigned int)v1 == -1)\n      return 4290822336;\n    return (-(((unsigned int)v1 & 0xff0000) < 1) & -0x800000) - &g_800000 |\n           ((char)v1) * 0x8000 | ((char)v1) * 128;\n  } else if ((char)a0 <= 15) {\n    v10 = prisma_8colortoargb((unsigned int)a0 - 8);\n    if ((unsigned int)v10)\n      return v10;\n    return 4286611584;\n  } else if ((char)a0 <= 231) {\n    v4 = (unsigned int)a0 - 16;\n    v5 = 57;\n    *((unsigned short *)&v5) = 57 * (char)v4;\n    v6 = v5;\n    *((unsigned short *)&v5) = cx<2> >> 11;\n    v7 = v4 - rcx * 36;\n    *((unsigned short *)&v7) = (char)v7 * 171;\n    v8 = v7;\n    *((unsigned short *)&v8) = (unsigned short)v7 / 0x400;\n    return v8 * 0x3300 |\n           ((unsigned int)v4 -\n            (65535 CONCAT(unsigned short)(171 * (char)v4 >> 10)) * 6) *\n               51 |\n           rcx * 0x330000 | -0x1000000;\n  } else {\n    return (unsigned int)(((unsigned int)a0 + 24) * 10 + 8) * 65793 |\n           -0x1000000;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwo57c9ys/prisma_xtermtoargb_name_conflict.c:38:67: error: invalid operands to binary\nexpression ('int' and 'char *') 38 |         return (-(((unsigned int)v1 &\n0xff0000) < 1) & -0x800000) - &g_800000 | ((char)v1) * 0x8000 | ((char)v1) *\n128; |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\n~~~~~~~~~ /tmp/tmpwo57c9ys/prisma_xtermtoargb_name_conflict.c:53:42: error: expected\nexpression 53 |         *((unsigned short *)&v5) = cx<2> >> 11; | ^\n/tmp/tmpwo57c9ys/prisma_xtermtoargb_name_conflict.c:58:57: error: expected ')'\n   58 |         return v8 * 0x3300 | ((unsigned int)v4 - (65535 CONCAT (unsigned\nshort)(171 * (char)v4 >> 10)) * 6) * 51 | rcx * 0x330000 | -0x1000000; | ^\n/tmp/tmpwo57c9ys/prisma_xtermtoargb_name_conflict.c:58:50: note: to match this '('\n   58 |         return v8 * 0x3300 | ((unsigned int)v4 - (65535 CONCAT (unsigned\nshort)(171 * (char)v4 >> 10)) * 6) * 51 | rcx * 0x330000 | -0x1000000; | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"const uint32_t *prisma_gradient(uint8_t resolution, uint32_t argb_first, uint32_t argb_last) {\n    static uint32_t gradient[256];\n    float i, a, r, g, b, offset;\n    memset(gradient, 0, 256 * sizeof(uint32_t));\n    if (resolution == 0)\n        return gradient;\n    if (resolution == 1) {\n        gradient[0] = argb_first;\n        return gradient;\n    }\n    gradient[0] = argb_first;\n    i = 1.F;\n    do {\n        if ((((argb_first) & 4278190080U) >> 24) < (((argb_last) & 4278190080U) >> 24)) {\n            offset = ((float)((((argb_last) & 4278190080U) >> 24) - (((argb_first) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_first) & 4278190080U) >> 24) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 4278190080U) >> 24) - (((argb_last) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_last) & 4278190080U) >> 24) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 16711680) >> 16) < (((argb_last) & 16711680) >> 16)) {\n            offset = ((float)((((argb_last) & 16711680) >> 16) - (((argb_first) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_first) & 16711680) >> 16) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 16711680) >> 16) - (((argb_last) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_last) & 16711680) >> 16) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 65280) >> 8) < (((argb_last) & 65280) >> 8)) {\n            offset = ((float)((((argb_last) & 65280) >> 8) - (((argb_first) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_first) & 65280) >> 8) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 65280) >> 8) - (((argb_last) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_last) & 65280) >> 8) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if (((argb_first) & 255) < ((argb_last) & 255)) {\n            offset = ((float)(((argb_last) & 255) - ((argb_first) & 255))) / (float)resolution;\n            b = ((argb_first) & 255) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)(((argb_first) & 255) - ((argb_last) & 255))) / (float)resolution;\n            b = ((argb_last) & 255) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        gradient[(uint8_t)i] = (((((uint8_t)a) << 24) & 4278190080U) | ((((uint8_t)r) << 16) & 16711680) | ((((uint8_t)g) << 8) & 65280) | (((uint8_t)b) & 255));\n        i++;\n    } while (i <= resolution && i != 0.F);\n    gradient[((uint8_t)i) - 2] = argb_last;\n    return gradient;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern void *gradient.0;\n\nlong long prisma_gradient(unsigned long a0, unsigned long a1,\n                          unsigned long a2) {\n  unsigned int v0;       // [bp-0x3c]\n  int tmp_28;            // tmp #28\n  int tmp_30;            // tmp #30\n  int tmp_29;            // tmp #29\n  int tmp_45;            // tmp #45\n  int tmp_47;            // tmp #47\n  int tmp_46;            // tmp #46\n  int tmp_19;            // tmp #19\n  int tmp_21;            // tmp #21\n  int tmp_20;            // tmp #20\n  int tmp_13;            // tmp #13\n  int tmp_15;            // tmp #15\n  int tmp_14;            // tmp #14\n  int tmp_31;            // tmp #31\n  int tmp_49;            // tmp #49\n  int tmp_48;            // tmp #48\n  int tmp_32;            // tmp #32\n  int tmp_50;            // tmp #50\n  int tmp_34;            // tmp #34\n  int tmp_33;            // tmp #33\n  int tmp_53;            // tmp #53\n  int tmp_55;            // tmp #55\n  int tmp_54;            // tmp #54\n  unsigned int v1;       // [bp-0x38]\n  unsigned int v2;       // [bp-0x34]\n  char v4;               // r8b\n  unsigned int v5;       // ebx\n  unsigned long long v6; // rsi\n  unsigned long v8;      // rcx, Other Possible Types: unsigned long long\n  unsigned long v9;      // d\n  unsigned int *v10;     // rdi, Other Possible Types: unsigned long\n  unsigned int v11;      // r10d\n  unsigned int v12;      // edi\n  unsigned int v13;      // r8d\n  unsigned int v14;      // r9d\n  unsigned int v15;      // xmm7\n  int v17;               // xmm1\n  int v19;               // xmm2\n  int v21;               // xmm1\n  int v23;               // xmm1\n  int v24;               // xmm8\n  int v25;               // xmm2\n  int v27;               // xmm2\n  int v29;               // xmm1\n  int v31;               // xmm8\n  int v33;               // xmm1\n  int v35;               // xmm1\n  int v36;               // xmm9\n  int v37;               // xmm8\n  int v39;               // xmm8\n  int v41;               // xmm1\n  int v43;               // xmm9\n  int v45;               // xmm1\n  int v47;               // xmm1\n  int v48;               // xmm11\n  unsigned int v49;      // xmm10\n  int v50;               // xmm9\n  int v52;               // xmm9\n  int v54;               // xmm1\n  int v56;               // xmm1\n  int v57;               // xmm12\n  unsigned int v58;      // xmm11\n  int v59;               // xmm10\n  int v61;               // xmm1\n  int v63;               // xmm10\n  int v65;               // xmm1\n  char v66;              // al\n  int v67;               // xmm0, Other Possible Types: unsigned int\n\n  v4 = a0;\n  v5 = a1;\n  v6 = a2;\n  v8 = 128;\n  for (v10 = &gradient.0; v8; v10 += v9 * 8) {\n    v8 -= 1;\n    *((long long *)v10) = 0;\n  }\n  if (!v4) {\n    return &gradient.0;\n  } else if (v4 != 1) {\n    *((unsigned int *)&gradient.0) = v5;\n    v11 = v5 / 0x1000000;\n    v12 = v5 / 0x10000;\n    v13 = (unsigned int)v6 / 0x10000;\n    v0 = v13 - v12;\n    v14 = (unsigned int)v6 / 0x100;\n    v2 = v5 - v14;\n    v1 = v14 - v5;\n    v67 = 0;\n    v67 = 0x3f800000;\n    v15 = 0;\n    v15 = 2147483647;\n    while (true) {\n      if (v11 < (unsigned int)(v6 >> 24)) {\n        tmp_28 = DivV(tmp_30, tmp_29);\n        v21 = tmp_28 + v67;\n        tmp_45 = DivV(tmp_47, tmp_46);\n        v23 = v21 * tmp_45;\n        v24 = v23;\n        v25 = v23 & v15;\n        if ((((char)(CmpF(0x4b000000, (unsigned int)v19) & 69) |\n              (char)((CmpF(0x4b000000, (unsigned int)v19) & 69) >> 6)) &\n             1) != 1) {\n          tmp_19 = CmpLEV(tmp_21, tmp_20);\n          v24 =\n              ~(v15)&v23 | (0 CONCAT(unsigned int) v23) +\n                               ((tmp_19 ^ 4294967295) & (0 CONCAT 0x3f800000));\n        }\n        v27 = (0 CONCAT v11) + v24;\n      } else {\n        tmp_28 = DivV(tmp_30, tmp_29);\n        v17 = tmp_28 + v67;\n        tmp_45 = DivV(tmp_47, tmp_46);\n        v19 = v17 * tmp_45 & v15;\n        tmp_13 = SubV(tmp_15, tmp_14);\n        v27 = tmp_13;\n      }\n      if (v12 < v13) {\n        tmp_29 = DivV(tmp_31, tmp_30);\n        v33 = tmp_29 + v67;\n        tmp_47 = DivV(tmp_49, tmp_48);\n        v35 = v33 * tmp_47;\n        v36 = v35;\n        v37 = v35 & v15;\n        if ((((char)(CmpF(0x4b000000, (unsigned int)v31) & 69) |\n              (char)((CmpF(0x4b000000, (unsigned int)v31) & 69) >> 6)) &\n             1) != 1) {\n          tmp_19 = CmpLEV(tmp_21, tmp_20);\n          v36 =\n              ~(v15)&v35 | (0 CONCAT(unsigned int) v35) +\n                               ((tmp_19 ^ 4294967295) & (0 CONCAT 0x3f800000));\n        }\n        v39 = (0 CONCAT v12) + v36;\n      } else {\n        tmp_28 = DivV(tmp_30, tmp_29);\n        v29 = tmp_28 + v67;\n        tmp_45 = DivV(tmp_47, tmp_46);\n        v31 = v29 * tmp_45 & v15;\n        tmp_13 = SubV(tmp_15, tmp_14);\n        v39 = tmp_13;\n      }\n      if (v5 >= v14) {\n        tmp_29 = DivV(tmp_31, tmp_30);\n        v41 = tmp_29 + v67;\n        tmp_47 = DivV(tmp_49, tmp_48);\n        v43 = v41 * tmp_47 & v15;\n        tmp_13 = SubV(tmp_15, tmp_14);\n        v52 = tmp_13;\n      } else {\n        tmp_30 = DivV(tmp_32, tmp_31);\n        v45 = tmp_30 + v67;\n        tmp_48 = DivV(tmp_50, tmp_49);\n        v47 = v45 * tmp_48;\n        v48 = v47;\n        v49 = 0;\n        v49 = 2147483647;\n        v50 = v47 & v49;\n        if ((((char)(CmpF(0x4b000000, (unsigned int)v50) & 69) |\n              (char)((CmpF(0x4b000000, (unsigned int)v50) & 69) >> 6)) &\n             1) != 1) {\n          tmp_19 = CmpLEV(tmp_21, tmp_20);\n          v48 = ((tmp_19 ^ 4294967295) & (0 CONCAT 0x3f800000)) +\n                    (0 CONCAT(unsigned int) v47) |\n                ~(v49)&v47;\n        }\n        v52 = (0 CONCAT v5) + v48;\n      }\n      if (v5 >= (char)v6) {\n        tmp_32 = DivV(tmp_34, tmp_33);\n        v61 = tmp_32 + v67;\n        tmp_53 = DivV(tmp_55, tmp_54);\n        v63 = v61 * tmp_53 & (0 CONCAT 2147483647);\n        tmp_13 = SubV(tmp_15, tmp_14);\n        v65 = tmp_13;\n      } else {\n        tmp_32 = DivV(tmp_34, tmp_33);\n        v54 = tmp_32 + v67;\n        tmp_53 = DivV(tmp_55, tmp_54);\n        v56 = v54 * tmp_53;\n        v57 = v56;\n        v58 = 0;\n        v58 = 2147483647;\n        v59 = v56 & v58;\n        if ((((char)(CmpF(0x4b000000, (unsigned int)v59) & 69) |\n              (char)((CmpF(0x4b000000, (unsigned int)v59) & 69) >> 6)) &\n             1) != 1) {\n          tmp_19 = CmpLEV(tmp_21, tmp_20);\n          v57 = ((tmp_19 ^ 4294967295) & (0 CONCAT 0x3f800000)) +\n                    (0 CONCAT(unsigned int) v56) |\n                ~(v58)&v56;\n        }\n        v65 = (0 CONCAT v5) + v57;\n      }\n      *((unsigned int *)((char *)&gradient.0 + 4 * v67)) =\n          (unsigned int)((unsigned int)v52 * 0x100) |\n          (unsigned int)((unsigned int)v27 * 0x1000000) |\n          (unsigned int)((unsigned int)v39 * 0x10000) | (unsigned int)v65;\n      v67 += 0x3f800000;\n      if ((CmpF(a0, (unsigned int)v67) & 1))\n        break;\n      v66 = ((CmpF((unsigned int)v67, 0) & 69) >> 2 & 1);\n      if (!((char)((CmpF((unsigned int)v67, 0) & 69) >> 6) & 1))\n        v66 = 1;\n      if (!v66)\n        break;\n    }\n    *((unsigned int *)(-8 + (char *)&gradient.0 + 4 * v67)) = v6;\n    return &gradient.0;\n  } else {\n    *((unsigned int *)&gradient.0) = v5;\n    return &gradient.0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpboen85tc/prisma_gradient.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern void* gradient.0; |                      ^ | ;\n/tmp/tmpboen85tc/prisma_gradient.c:94:25: error: expected ';' in 'for' statement\nspecifier 94 |     for (v10 = &gradient.0; v8; v10 += v9 * 8) | ^\n/tmp/tmpboen85tc/prisma_gradient.c:94:31: error: expected ')'\n   94 |     for (v10 = &gradient.0; v8; v10 += v9 * 8)\n      |                               ^\n/tmp/tmpboen85tc/prisma_gradient.c:94:9: note: to match this '('\n   94 |     for (v10 = &gradient.0; v8; v10 += v9 * 8)\n      |         ^\n/tmp/tmpboen85tc/prisma_gradient.c:94:46: error: expected ';' after expression\n   94 |     for (v10 = &gradient.0; v8; v10 += v9 * 8)\n      |                                              ^\n      |                                              ;\n/tmp/tmpboen85tc/prisma_gradient.c:94:46: error: expected expression\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":1,"function":"static int main_ea_cycles(void) {\n    int l;\n    if (main_size == 4)\n        l = 4;\n    else\n        l = 0;\n    switch (main_eamode) {\n      case aind:\n        return (l + 4);\n      case ainc:\n        return (l + 4);\n      case adec:\n        return (l + 6);\n      case adsp:\n        return (l + 8);\n      case axdp:\n        return (l + 10);\n      case absw:\n        return (l + 8);\n      case absl:\n        return (l + 12);\n      case pcdp:\n        return (l + 8);\n      case pcxd:\n        return (l + 10);\n      case immd:\n        return (l + 4);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int main_eamode;\n\nlong long main_ea_cycles_name_conflict() {}\n","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static int main_ea_cycles_nofetch(void) {\n    switch (main_eamode) {\n      case aind:\n        return (2);\n      case ainc:\n        return (4);\n      case adec:\n        return (4);\n      case adsp:\n        return (4);\n      case axdp:\n        return (8);\n      case absw:\n        return (4);\n      case absl:\n        return (8);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int main_eamode;\n\nlong long main_ea_cycles_nofetch_name_conflict() {}\n","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"static int test(int n, int m, int op) {\n    int t;\n    if ((n & m) != op)\n        return 0;\n    for (t = op & 61440; t < n; t++) {\n        if ((!unique[t]) && ((t & m) == (n & m))) {\n            rproc[n] = t;\n            return 2;\n        }\n    }\n    unique[n] = (m >> 16) & 1;\n    rproc[n] = n;\n    t = (m ^ 65535) & 4095;\n    if (!t) {\n        emit(\"; Opcode %04X\\n\", n);\n    } else {\n        emit(\"; Opcodes %04X - %04X\\n\", n, op + t);\n    }\n    emit(\"%c%03X:\\n\", ((n >> 12) & 15) + 'K', n & 4095);\n    routine_counter++;\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"static char *getparameter(int *ip, int argc, char **argv) {\n    int i;\n    (*ip)++;\n    i = (*ip);\n    if (i >= argc) {\n        fprintf(stderr, \"Invalid use of %s option\\n\", argv[i - 1]);\n        return ((void *)0);\n    }\n    return argv[i];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long getparameter_name_conflict(unsigned int *a0, unsigned long a1, unsigned long a2) {\n  unsigned long long *v1; // rax\n\n  v1 = *(a0) + 1;\n  *(a0) = (unsigned int)v1;\n  if ((unsigned int)v1 >= (unsigned int)a1) {\n    fprintf(stderr @GLIBC_2.2.5, \"Invalid use of %s option\\n\",\n            (int)*((long long *)(a2 + v1 * 8 - 8)));\n    return 0;\n  }\n  return *((long long *)(a2 + v1 * 8));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdzadtc4g/getparameter_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdzadtc4g/getparameter_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpdzadtc4g/getparameter_name_conflict.c:27:23: error: expected ')'\n   27 |         fprintf(stderr@GLIBC_2.2.5, \"Invalid use of %s option\\n\",\n(int)*((long long *)(a2 + v1 * 8 - 8))); |                       ^\n/tmp/tmpdzadtc4g/getparameter_name_conflict.c:27:16: note: to match this '('\n   27 |         fprintf(stderr@GLIBC_2.2.5, \"Invalid use of %s option\\n\",\n(int)*((long long *)(a2 + v1 * 8 - 8))); |                ^\n/tmp/tmpdzadtc4g/getparameter_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned long long *' and 'int') 30 |     return *((long long *)(a2\n+ v1 * 8)); |                                 ~~ ^ ~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"int set_interface_attribs(int fd, int speed, int parity) {\n    struct termios tty;\n    memset(&tty, 0, sizeof tty);\n    if (tcgetattr(fd, &tty) != 0) {\n        printf(\"error %d from tcgetattr\", (*__errno_location()));\n        return -1;\n    }\n    cfsetospeed(&tty, speed);\n    cfsetispeed(&tty, speed);\n    tty.c_cflag = (tty.c_cflag & ~48) | 48;\n    tty.c_iflag &= ~1;\n    tty.c_lflag = 0;\n    tty.c_oflag = 0;\n    tty.c_cc[6] = 0;\n    tty.c_cc[5] = 5;\n    tty.c_iflag &= ~(1024 | 4096 | 2048);\n    tty.c_cflag |= (2048 | 128);\n    tty.c_cflag &= ~(256 | 512);\n    tty.c_cflag |= parity;\n    tty.c_cflag &= ~64;\n    tty.c_cflag &= ~2147483648U;\n    if (tcsetattr(fd, 0, &tty) != 0) {\n        printf(\"error %d from tcsetattr\", (*__errno_location()));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(cfsetospeed)(\n    struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *,\n    unsigned int);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nlong long set_interface_attribs(unsigned long a0, unsigned long a1,\n                                unsigned long a2) {\n  termios v0;             // [bp-0x68], Other Possible Types: unsigned int\n  int tmp_39;             // tmp #39\n  unsigned int v1;        // [bp-0x64]\n  unsigned int v2;        // [bp-0x60]\n  unsigned int v3;        // [bp-0x5c]\n  int v4;                 // [bp-0x58]\n  char v5;                // [bp-0x52]\n  char v6;                // [bp-0x51]\n  int v7;                 // [bp-0x48]\n  int v8;                 // [bp-0x3c]\n  unsigned long long v10; // rax\n  unsigned long v12;      // rax, Other Possible Types: unsigned long long\n\n  *((int128_t *)&v0.c_iflag) = 0;\n  *((int128_t *)&v4) = 0;\n  *((int128_t *)&v7) = 0;\n  *((int128_t *)&v8) = 0;\n  if (tcgetattr(a0, &v0)) {\n    printf(\"error %d from tcgetattr\", *(__errno_location()));\n    return 4294967295;\n  }\n  cfsetospeed(&v0, a1);\n  cfsetispeed(&v0, a1);\n  v3 = 0;\n  v1 = 0;\n  v6 = 0;\n  v5 = 5;\n  v0 = v0.c_iflag & -7170;\n  v10 = v0.c_oflag;\n  *((char *)&v10) = (char)v10 & 252;\n  tmp_39 = v10;\n  v2 = ((int)tmp_39 | (unsigned int)a2) & 2147483583 | 2224;\n  (unsigned int)v12 = tcsetattr(a0, 0, &v0);\n  if ((unsigned int)v12) {\n    printf(\"error %d from tcsetattr\", *(__errno_location()));\n    return 4294967295;\n  }\n  return v12;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmes24qrc/set_interface_attribs.c:79:18: error: expected expression\n   79 |     *((int128_t *)&v0.c_iflag) = 0;\n      |                  ^\n/tmp/tmpmes24qrc/set_interface_attribs.c:80:18: error: expected expression\n   80 |     *((int128_t *)&v4) = 0;\n      |                  ^\n/tmp/tmpmes24qrc/set_interface_attribs.c:81:18: error: expected expression\n   81 |     *((int128_t *)&v7) = 0;\n      |                  ^\n/tmp/tmpmes24qrc/set_interface_attribs.c:82:18: error: expected expression\n   82 |     *((int128_t *)&v8) = 0;\n      |                  ^\n/tmp/tmpmes24qrc/set_interface_attribs.c:85:43: error: indirection requires\npointer operand ('int' invalid) 85 |         printf(\"error %d from tcgetattr\",\n*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmes24qrc/set_interface_attribs.c:94:8: error: assigning to 'termios'\n(aka 'struct termios') from incompatible type 'unsigned int' 94 |     v0 =\nv0.c_iflag & -7170; |        ^ ~~~~~~~~~~~~~~~~~~\n/tmp/tmpmes24qrc/set_interface_attribs.c:99:5: error: assignment to cast is\nillegal, lvalue casts are not supported 99 |     (unsigned int)v12 =\ntcsetattr(a0, 0, &v0); |     ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpmes24qrc/set_interface_attribs.c:102:43: error: indirection requires\npointer operand ('int' invalid) 102 |         printf(\"error %d from tcsetattr\",\n*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/abradner_homely/ard/tools/stdin-to-serial/serial.c"}
{"compilable":0,"function":"int extractLineNum(char *input) {\n    int n = strlen(input);\n    char *p = input + n - 1;\n    while (*p != ' ')\n        p--;\n    p++;\n    int lno = atoi(p);\n    *p = '\\x00';\n    return lno;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/anantsubramanian_graphL-compiler/src/parsetree_generator.c"}
{"compilable":1,"function":"char rotate(char dir) {\n    return (dir + 2) % 12;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rotate_name_conflict(unsigned long a0) { return ((char)a0 + 2) % 12; }\n","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char flip(char dir) {\n    return (12 - dir) % 12;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long flip_name_conflict(unsigned long a0) { return (12 - (unsigned int)a0) % 12; }\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char shift(char cell, char dir) {\n    switch (dir) {\n      case 0:\n        return cell + 1;\n      case 1:\n        if ((cell / 5) % 2)\n            return cell + 7;\n        else\n            return cell + 6;\n      case 2:\n        if ((cell / 5) % 2)\n            return cell + 6;\n        else\n            return cell + 5;\n      case 3:\n        return cell + 10;\n      case 4:\n        if ((cell / 5) % 2)\n            return cell + 5;\n        else\n            return cell + 4;\n      case 5:\n        if ((cell / 5) % 2)\n            return cell + 4;\n        else\n            return cell + 3;\n      case 6:\n        return cell - 1;\n      case 7:\n        if ((cell / 5) % 2)\n            return cell - 6;\n        else\n            return cell - 7;\n      case 8:\n        if ((cell / 5) % 2)\n            return cell - 5;\n        else\n            return cell - 6;\n      case 9:\n        return cell - 10;\n      case 10:\n        if ((cell / 5) % 2)\n            return cell - 4;\n        else\n            return cell - 5;\n      case 11:\n        if ((cell / 5) % 2)\n            return cell - 3;\n        else\n            return cell - 4;\n      default:\n        return cell;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shift_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rcx\n  unsigned long long v2; // rcx\n  unsigned long long v3; // rcx\n  unsigned long long v4; // rcx\n  unsigned long long v5; // rcx\n  unsigned long long v6; // rcx\n  unsigned long long v7; // rcx\n  unsigned long long v8; // rcx\n\n  switch ((char)a1) {\n  case 0:\n    return a0 + 1;\n  case 1:\n    v1 = a0;\n    *((char *)&v1) = (char)v1 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v1) & 1) + a0 + 6;\n  case 2:\n    v2 = a0;\n    *((char *)&v2) = (char)v2 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v2) & 1) + a0 + 5;\n  case 3:\n    return a0 + 10;\n  case 4:\n    v3 = a0;\n    *((char *)&v3) = (char)v3 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v3) & 1) + a0 + 4;\n  case 5:\n    v4 = a0;\n    *((char *)&v4) = (char)v4 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v4) & 1) + a0 + 3;\n  case 6:\n    return a0 - 1;\n  case 7:\n    v5 = a0;\n    *((char *)&v5) = (char)v5 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v5) & 1) + a0 - 7;\n  case 8:\n    v6 = a0;\n    *((char *)&v6) = (char)v6 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v6) & 1) + a0 - 6;\n  case 9:\n    return a0 - 10;\n  case 10:\n    v7 = a0;\n    *((char *)&v7) = (char)v7 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v7) & 1) + a0 - 5;\n  case 11:\n    v8 = a0;\n    *((char *)&v8) = (char)v8 >> 7;\n    return ((unsigned int)((103 * (char)a0 >> 9) - v8) & 1) + a0 - 4;\n  default:\n    return a0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"char out_of_bounds(char cell, char dir) {\n    char i;\n    switch (dir) {\n      case 0:\n        return cell % 5 == 4;\n      case 1:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell >= 45;\n      case 2:\n        return cell % 10 == 9 || cell >= 45;\n      case 3:\n        return cell >= 40;\n      case 4:\n        return cell % 10 == 0 || cell >= 45;\n      case 5:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell >= 45;\n      case 6:\n        return cell % 5 == 0;\n      case 7:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell < 5;\n      case 8:\n        return cell % 10 == 0 || cell < 5;\n      case 9:\n        return cell < 10;\n      case 10:\n        return cell % 10 == 9 || cell < 5;\n      case 11:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell < 5;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_403034;\n\nlong long out_of_bounds_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned long long v0;  // [bp-0x120]\n  unsigned int v2;        // edx\n  unsigned long long v3;  // rax\n  unsigned long long v5;  // rcx\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rcx\n  unsigned long long v8;  // rcx\n  unsigned long long v9;  // rcx\n  unsigned long long v10; // rax\n  unsigned long long v11; // rax\n  unsigned long long v12; // rcx\n  unsigned long long v13; // rax\n  unsigned long long v14; // rax\n  unsigned long long v15; // rcx\n  unsigned long long v16; // rax\n  unsigned long long v17; // rax\n  unsigned long long v18; // rcx\n  unsigned long long v19; // rax\n  unsigned long long v20; // rcx\n  unsigned long long v21; // rax\n  unsigned long long v22; // rax\n  unsigned long long v23; // rcx\n  unsigned long long v24; // rax\n  unsigned long long v25; // rax\n  unsigned long long v26; // rcx\n  unsigned long long v27; // rax\n  unsigned long long v28; // rax\n  unsigned long long v29; // rcx\n  unsigned long long v30; // rcx\n\n  v2 = a0;\n  switch ((char)a1) {\n  case 0:\n    v5 = a0;\n    *((char *)&v5) = (char)v5 >> 7;\n    v6 = ((103 * (char)a0 >> 9) - v5) * 5;\n    *((char *)&v6) = (char)(a0 - v6) == 4;\n    return v6;\n  case 1:\n    v7 = a0;\n    *((char *)&v7) = (char)v7 >> 7;\n    v8 =\n        (unsigned int)a0 - (unsigned int)((103 * (char)a0 >> 10) - v7) * 10 + 9;\n    v0 = 0x62000;\n    if (((char)(*((char *)&v0 + ((v8 & 63) >> 3)) >> (char)(v8 & 63 & 7)) & 1))\n      return 1;\n    return (char)a0 > 44;\n  case 2:\n    v9 = a0;\n    *((char *)&v9) = (char)v9 >> 7;\n    v10 = (unsigned int)((103 * (char)a0 >> 10) - v9) * 10;\n    *((char *)&v10) = (char)(a0 - v10) == 9;\n    *((char *)&v2) = (char)a0 > 44;\n    v11 = (unsigned int)v10 | v2;\n    return v11;\n  case 3:\n    *((char *)&v3) = (char)a0 > 39;\n    return v3;\n  case 4:\n    v12 = a0;\n    *((char *)&v12) = (char)v12 >> 7;\n    v13 = (unsigned int)((103 * (char)a0 >> 10) - v12) * 10;\n    *((char *)&v13) = (char)v13 == (char)a0;\n    *((char *)&v2) = (char)a0 > 44;\n    v14 = (unsigned int)v13 | v2;\n    return v14;\n  case 5:\n    v15 = a0;\n    *((char *)&v15) = (char)v15 >> 7;\n    v16 = a0 - (unsigned int)((103 * (char)a0 >> 10) - v15) * 10 + 9;\n    v0 = 0x4600;\n    *((char *)&v16) = ...;\n    *((char *)&v2) = (char)a0 > 44;\n    v17 = (unsigned int)v16 | v2;\n    return v17;\n  case 6:\n    v18 = a0;\n    *((char *)&v18) = (char)v18 >> 7;\n    v19 = ((103 * (char)a0 >> 9) - v18) * 5;\n    *((char *)&v19) = (char)v19 == (char)a0;\n    return v19;\n  case 7:\n    v20 = a0;\n    *((char *)&v20) = (char)v20 >> 7;\n    v21 = a0 - (unsigned int)((103 * (char)a0 >> 10) - v20) * 10 + 9;\n    v0 = 0x4600;\n    *((char *)&v21) = ...;\n    *((char *)&v2) = (char)a0 <= 4;\n    v22 = (unsigned int)v21 | v2;\n    return v22;\n  case 8:\n    v23 = a0;\n    *((char *)&v23) = (char)v23 >> 7;\n    v24 = (unsigned int)((103 * (char)a0 >> 10) - v23) * 10;\n    *((char *)&v24) = (char)v24 == (char)a0;\n    *((char *)&v2) = (char)a0 <= 4;\n    v25 = (unsigned int)v24 | v2;\n    return v25;\n  case 9:\n    *((char *)&v3) = (char)a0 <= 9;\n    return v3;\n  case 10:\n    v26 = a0;\n    *((char *)&v26) = (char)v26 >> 7;\n    v27 = (unsigned int)((103 * (char)a0 >> 10) - v26) * 10;\n    *((char *)&v27) = (char)(a0 - v27) == 9;\n    *((char *)&v2) = (char)a0 <= 4;\n    v28 = (unsigned int)v27 | v2;\n    return v28;\n  case 11:\n    v29 = a0;\n    *((char *)&v29) = (char)v29 >> 7;\n    v30 = (unsigned int)a0 - (unsigned int)((103 * (char)a0 >> 10) - v29) * 10 +\n          9;\n    v0 = 0x62000;\n    if (((char)(*((char *)&v0 + ((v30 & 63) >> 3)) >> (char)(v30 & 63 & 7)) &\n         1))\n      return 1;\n    return (char)a0 <= 4;\n  default:\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk9gw3ah4/out_of_bounds_name_conflict.c:92:26: error: expected ';' after expression\n   92 |         *((char *)&v16) = ...;\n      |                          ^\n      |                          ;\n/tmp/tmpk9gw3ah4/out_of_bounds_name_conflict.c:92:25: error: expected expression\n   92 |         *((char *)&v16) = ...;\n      |                         ^\n/tmp/tmpk9gw3ah4/out_of_bounds_name_conflict.c:107:26: error: expected ';' after expression\n  107 |         *((char *)&v21) = ...;\n      |                          ^\n      |                          ;\n/tmp/tmpk9gw3ah4/out_of_bounds_name_conflict.c:107:25: error: expected expression\n  107 |         *((char *)&v21) = ...;\n      |                         ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int cells_fit_on_board(char *cell, int piece) {\n    return (!out_of_bounds(cell[0], piece_def[piece][0]) && !out_of_bounds(cell[1], piece_def[piece][1]) && !out_of_bounds(cell[2], piece_def[piece][2]) && !out_of_bounds(cell[3], piece_def[piece][3]));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(out_of_bounds)(long long, long long);\n\nextern char piece_def;\n\nlong long cells_fit_on_board_name_conflict(char a0[4], char *a1) {\n  char v1[4]; // rbp\n  char *v2;   // rbx\n\n  v1 = a0;\n  v2 = a1;\n  if ((char)out_of_bounds(a0[0], *(&piece_def + 0x4 * a1))) {\n    return 0;\n  } else if ((char)out_of_bounds(v1[1], *(1 + &piece_def + 0x4 * v2))) {\n    return 0;\n  } else if ((char)out_of_bounds(v1[2], *(2 + &piece_def + 0x4 * v2))) {\n    return 0;\n  } else {\n    return !(char)out_of_bounds(v1[3], *(3 + &piece_def + 0x4 * v2));\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgppznmsr/cells_fit_on_board_name_conflict.c:25:8: error: array type 'char[4]' is not\nassignable 25 |     v1 = a0; |     ~~ ^\n/tmp/tmpgppznmsr/cells_fit_on_board_name_conflict.c:27:55: error: invalid operands to binary\nexpression ('int' and 'char *') 27 |     if ((char)out_of_bounds(a0[0],\n*(&piece_def + 0x4 * a1))) | ~~~ ^ ~~\n/tmp/tmpgppznmsr/cells_fit_on_board_name_conflict.c:31:64: error: invalid operands to binary\nexpression ('int' and 'char *') 31 |     else if ((char)out_of_bounds(v1[1], *(1\n+ &piece_def + 0x4 * v2))) | ~~~ ^ ~~\n/tmp/tmpgppznmsr/cells_fit_on_board_name_conflict.c:35:64: error: invalid operands to binary\nexpression ('int' and 'char *') 35 |     else if ((char)out_of_bounds(v1[2], *(2\n+ &piece_def + 0x4 * v2))) | ~~~ ^ ~~\n/tmp/tmpgppznmsr/cells_fit_on_board_name_conflict.c:41:67: error: invalid operands to binary\nexpression ('int' and 'char *') 41 |         return !(char)out_of_bounds(v1[3],\n*(3 + &piece_def + 0x4 * v2)); | ~~~ ^ ~~ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char minimum_of_cells(char *cell) {\n    char minimum = cell[0];\n    minimum = cell[1] < minimum ? cell[1] : minimum;\n    minimum = cell[2] < minimum ? cell[2] : minimum;\n    minimum = cell[3] < minimum ? cell[3] : minimum;\n    minimum = cell[4] < minimum ? cell[4] : minimum;\n    return minimum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_of_cells_name_conflict(char a0[5]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0[0];\n  if ((char)v1 > (char)v1)\n    v1 = a0[1];\n  if ((char)v1 > (char)v1)\n    v1 = a0[2];\n  if ((char)v1 > (char)v1)\n    v1 = a0[3];\n  if ((char)v1 <= (char)v1)\n    return v1;\n  return a0[4];\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char first_empty_cell(char *cell, char minimum) {\n    char first_empty = minimum;\n    while (first_empty == cell[0] || first_empty == cell[1] || first_empty == cell[2] || first_empty == cell[3] || first_empty == cell[4])\n        first_empty++;\n    return first_empty;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long first_empty_cell_name_conflict(char a0[5], unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  for (v1 = a1; a0[0] == (char)v1 || a0[1] == (char)v1 || a0[2] == (char)v1 ||\n                a0[3] == (char)v1 || a0[4] == (char)v1;\n       v1 = (unsigned int)v1 + 1)\n    ;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"unsigned long long bitmask_from_cells(char *cell) {\n    unsigned long long piece_mask = 0ULL;\n    int i;\n    for (i = 0; i < 5; i++)\n        piece_mask |= 1ULL << cell[i];\n    return piece_mask;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long bitmask_from_cells_name_conflict(char *a0) {\n  void *v2; // rax, Other Possible Types: unsigned long\n\n  v2 = 0;\n  do {\n    v2 |= 1 << (*((char *)a0) & 63);\n    a0 += 1;\n  } while (a0 != a0 + 5);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8qwei22h/bitmask_from_cells_name_conflict.c:24:12: error: invalid operands to binary\nexpression ('void *' and 'int') 24 |         v2 |= 1 << (*((char *)a0) & 63); |\n~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int has_island(char *cell, int piece) {\n    char temp_board[50];\n    char c;\n    int i;\n    for (i = 0; i < 50; i++)\n        temp_board[i] = 0;\n    for (i = 0; i < 5; i++)\n        temp_board[((int)cell[i])] = 1;\n    i = 49;\n    while (temp_board[i] == 1)\n        i--;\n    fill_contiguous_space(temp_board, i);\n    c = 0;\n    for (i = 0; i < 50; i++)\n        if (temp_board[i] == 0)\n            c++;\n    if (c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) || (c % 5 == 0 && piece == 0))\n        return 0;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint cl;  // add global variable by heuristics\nint rcx; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fill_contiguous_space)(long long, long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long has_island_name_conflict(char *a0, unsigned long a1) {\n  char v0;                // [bp-0x58]\n  char v1;                // [bp-0x57]\n  char v3;                // [bp-0x27]\n  char v4;                // [bp-0x26]\n  unsigned int v6;        // r12d\n  struct_0 *v7;           // rbx, Other Possible Types: unsigned long\n  struct_0 *v8;           // rax, Other Possible Types: unsigned long\n  char *v9;               // rax, Other Possible Types: unsigned long\n  struct_0 *v10;          // rsi, Other Possible Types: unsigned long\n  struct_0 *v11;          // rax, Other Possible Types: unsigned long\n  void *v12;              // rdx\n  unsigned long v13;      // rax\n  unsigned long long v14; // rcx\n  unsigned long long v15; // rax\n\n  v6 = a1;\n  v7 = &v0;\n  v8 = &v0;\n  do {\n    *((char *)v8) = 0;\n    v8 = &v1;\n  } while (v8 != &v4);\n  v9 = a0;\n  do {\n    (&v0)[*((char *)v9)] = 1;\n    v9 += 1;\n  } while (v9 != a0 + 5);\n  if (v3 != 1) {\n    v10 = 49;\n  } else {\n    v11 = 48;\n    do {\n      v10 = v11;\n      v11 -= 1;\n    } while ((&v1)[v11] == 1);\n  }\n  fill_contiguous_space(&v0, v10);\n  v12 = 0;\n  do {\n    *((char *)&v12) = (char)v12 + (*((char *)v7) < 1);\n    v7 = &v1;\n  } while (v7 != &v4);\n  if (!(char)v12)\n    return 0;\n  if ((!((char)v12 != 5) || !((char)v12 != 40)) && v6 == 8)\n    return 0;\n  v14 = v12;\n  *((char *)&v12) = cl<1> >> 7;\n  v15 = ((103 * (char)v12 >> 9) - rcx) * 5;\n  *((char *)&v15) = (char)v12 == (char)v15;\n  v13 = (unsigned int)v15 & !v6 ^ 1;\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8a64x8wg/has_island_name_conflict.c:66:23: error: array subscript is not an integer\n   66 |         } while ((&v1)[v11] == 1);\n      |                       ^~~~\n/tmp/tmp8a64x8wg/has_island_name_conflict.c:80:29: error: expected expression\n   80 |     *((char *)&v12) = cl<1> >> 7;\n      |                             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int rows_bad(char row1, char row2, int even) {\n    int i, in_zeroes, group_okay;\n    char block, row2_shift;\n    if (even)\n        row2_shift = ((row2 << 1) & 31) | 1;\n    else\n        row2_shift = (row2 >> 1) | 16;\n    block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);\n    in_zeroes = 0;\n    group_okay = 0;\n    for (i = 0; i < 5; i++) {\n        if (row1 & (1 << i)) {\n            if (in_zeroes) {\n                if (!group_okay)\n                    return 1;\n                in_zeroes = 0;\n                group_okay = 0;\n            }\n        } else {\n            if (!in_zeroes)\n                in_zeroes = 1;\n            if (!(block & (1 << i)))\n                group_okay = 1;\n        }\n    }\n    if (in_zeroes)\n        return !group_okay;\n    else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rows_bad_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;       // [bp-0x120]\n  unsigned int v3;       // eax\n  unsigned long long v4; // rax\n  unsigned long long v5; // rdx\n  unsigned int v6;       // edi\n  unsigned long v7;      // rax, Other Possible Types: unsigned long long\n  void *v8;              // rcx, Other Possible Types: unsigned long\n  unsigned long long v9; // rdi\n\n  if (!(unsigned int)a2) {\n    v4 = a1;\n    *((char *)&v4) = (char)v4 >> 1;\n    v3 = (unsigned int)v4 | 16;\n  } else {\n    v3 = (unsigned int)a1 * 2 & 30 | 1;\n  }\n  v5 = ~((unsigned int)a0) & (unsigned int)a1 & v3;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  do {\n    v0 = a0;\n    if (!((char)(*((char *)&v0 + ((v8 & 31) >> 3)) >> (char)(v8 & 31 & 7)) &\n          1)) {\n      v7 = (unsigned int)(v5 >> ((char)v8 & 31)) & 1;\n      if (!(unsigned int)v7) {\n        v6 = 1;\n        v7 = 1;\n      }\n    } else if ((unsigned int)v7) {\n      if (v6) {\n        v6 = 0;\n        v7 = 0;\n      } else {\n        return v7;\n      }\n    }\n  } while (\n      (v8 = (unsigned long long)((unsigned int)v8 + 1), (unsigned int)v8 != 5));\n  v9 = v6 ^ 1;\n  if (!(unsigned int)v7)\n    return v7;\n  return v9;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8f_204d1/rows_bad_name_conflict.c:45:43: error: invalid operands to binary expression\n('void *' and 'int') 45 |         if (!((char)(*((char *)&v0 + ((v8 & 31) >> 3))\n>> (char)(v8 & 31 & 7)) & 1)) |                                        ~~ ^ ~~\n/tmp/tmp8f_204d1/rows_bad_name_conflict.c:45:69: error: invalid operands to binary expression\n('void *' and 'int') 45 |         if (!((char)(*((char *)&v0 + ((v8 & 31) >> 3))\n>> (char)(v8 & 31 & 7)) & 1)) | ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int triple_is_okay(char row1, char row2, char row3, int even) {\n    if (even) {\n        return ((row1 == 3) && (row2 == 11) && ((row3 & 28) == 12)) || ((row1 == 1) && (row2 == 5) && (row3 == 6)) || ((row1 == 25) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    } else {\n        return ((row1 == 19) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long triple_is_okay(unsigned long a0, unsigned long a1,\n                         unsigned long long a2, unsigned long a3) {\n  if (!(unsigned int)a3) {\n    *((char *)&a2) = !((char)((unsigned int)a0 - 19) & 253);\n    return (char)a1 == 17 & (unsigned int)a2;\n  }\n  if (!((char)a0 != 3 || (char)a1 != 11)) {\n    a2 = (unsigned int)a2 & 28;\n    if ((char)a2 == 12)\n      return 1;\n  } else if (((char)a2 == 6 & (char)a1 == 5) && (char)a0 == 1) {\n    return 1;\n  }\n  *((char *)&a2) = !((char)((unsigned int)a0 - 21) & 251);\n  return (char)a1 == 17 & (unsigned int)a2;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int boardHasIslands(char cell) {\n    if (cell >= 40)\n        return 0;\n    int current_triple = (board >> ((cell / 5) * 5)) & 32767;\n    if ((cell / 5) % 2)\n        return bad_odd_triple[current_triple];\n    else\n        return bad_even_triple[current_triple];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rdi; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int bad_even_triple;\nextern unsigned int bad_odd_triple;\nextern unsigned long long board;\n\nlong long boardHasIslands_name_conflict(unsigned long a0) {\n  char v3; // dil\n  char v4; // al\n\n  if ((char)a0 > 39)\n    return 0;\n  v3 = (char)a0 >> 7;\n  v4 = (char)(103 * (char)a0 >> 9) - (char)rdi;\n  if (!(v4 & 1))\n    return (&bad_even_triple)[(unsigned int)(board >> (v4 * 5 & 63)) & 32767];\n  return (&bad_odd_triple)[(unsigned int)(board >> (v4 * 5 & 63)) & 32767];\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"static long fannkuch(int n) {\n    int *perm;\n    int *perm1;\n    int *count;\n    long flips;\n    long flipsMax;\n    int r;\n    int i;\n    int k;\n    int didpr;\n    const int n1 = n - 1;\n    if (n < 1)\n        return 0;\n    perm = calloc(n, sizeof (*perm));\n    perm1 = calloc(n, sizeof (*perm1));\n    count = calloc(n, sizeof (*count));\n    for (i = 0; i < n; ++i)\n        perm1[i] = i;\n    r = n;\n    didpr = 0;\n    flipsMax = 0;\n    for (;;) {\n        if (didpr < 30) {\n            for (i = 0; i < n; ++i)\n                printf(\"%d\", (int)(1 + perm1[i]));\n            printf(\"\\n\");\n            ++didpr;\n        }\n        for (; r != 1; --r) {\n            count[r - 1] = r;\n        }\n        if (!(perm1[0] == 0 || perm1[n1] == n1)) {\n            flips = 0;\n            for (i = 1; i < n; ++i) {\n                perm[i] = perm1[i];\n            }\n            k = perm1[0];\n            do {\n                int j;\n                for (i = 1 , j = k - 1; i < j; ++i , --j) {\n                    {\n                        int t_mp;\n                        t_mp = (perm[i]);\n                        (perm[i]) = (perm[j]);\n                        (perm[j]) = t_mp;\n                    }\n                }\n                ++flips;\n                j = perm[k];\n                perm[k] = k;\n                k = j;\n            } while (k);\n            if (flipsMax < flips) {\n                flipsMax = flips;\n            }\n        }\n        for (;;) {\n            if (r == n) {\n                return flipsMax;\n            }\n            {\n                int perm0 = perm1[0];\n                i = 0;\n                while (i < r)\n                    {\n                        k = i + 1;\n                        perm1[i] = perm1[k];\n                        i = k;\n                    }\n                perm1[r] = perm0;\n            }\n            if ((count[r] -= 1) > 0) {\n                break;\n            }\n            ++r;\n        }\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/fannkuch.c"}
{"compilable":0,"function":"int errex(char *s, int n) {\n    fprintf(stderr, \"\\n*** Error: %s [%d]!\\n\", s, n);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long errex_name_conflict(unsigned long a0, unsigned long a1) {\n  fprintf(stderr @GLIBC_2.2.5, \"\\n*** Error: %s [%d]!\\n\", (unsigned int)a0,\n          (unsigned int)a1);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0g87vo5x/errex_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp0g87vo5x/errex_name_conflict.c:17:22: error: expected ';' after top level declarator\n   17 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp0g87vo5x/errex_name_conflict.c:21:19: error: expected ')'\n   21 |     fprintf(stderr@GLIBC_2.2.5, \"\\n*** Error: %s [%d]!\\n\", (unsigned\nint)a0, (unsigned int)a1); |                   ^ /tmp/tmp0g87vo5x/errex_name_conflict.c:21:12:\nnote: to match this '(' 21 |     fprintf(stderr@GLIBC_2.2.5, \"\\n*** Error: %s\n[%d]!\\n\", (unsigned int)a0, (unsigned int)a1); |            ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/reverse-complement.c"}
{"compilable":0,"function":"treeNode *NewTreeNode(treeNode *left, treeNode *right, long item) {\n    treeNode *new;\n    new = (treeNode *)malloc(sizeof(treeNode));\n    new->left = left;\n    new->right = right;\n    new->item = item;\n    return new;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long NewTreeNode_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v1[3]; // rax\n\n  v1 = malloc(24);\n  v1[0] = a0;\n  v1[1] = a1;\n  v1[2] = a2;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzwl_83k_/NewTreeNode_name_conflict.c:21:8: error: array type 'unsigned long long[3]'\nis not assignable 21 |     v1 = malloc(24); |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"long ItemCheck(treeNode *tree) {\n    if (tree->left == ((void *)0))\n        return tree->item;\n    else\n        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ItemCheck_name_conflict)(unsigned long long[3]);\n\nlong long ItemCheck_name_conflict(unsigned long long a0[3]) {\n  unsigned long long v1[3]; // rbx\n  unsigned long long v2;    // rdi\n  unsigned long v3;         // rax\n\n  v1 = a0;\n  v2 = a0[0];\n  if (!v2)\n    return v1[2];\n  v3 = v1[2] + ItemCheck_name_conflict(v2) - ItemCheck_name_conflict(v1[1]);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplb7g0hmf/ItemCheck_name_conflict.c:24:8: error: array type 'unsigned long long[3]' is\nnot assignable 24 |     v1 = a0; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"treeNode *BottomUpTree(long item, unsigned int depth) {\n    if (depth > 0)\n        return NewTreeNode(BottomUpTree(2 * item - 1, depth - 1), BottomUpTree(2 * item, depth - 1), item);\n    else\n        return NewTreeNode(((void *)0), ((void *)0), item);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(NewTreeNode)(long long, long long, long long);\nlong long(BottomUpTree_name_conflict)(unsigned long long, unsigned long);\n\nlong long BottomUpTree_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long long v1; // rbx\n  unsigned long long v2; // r12\n  unsigned long v3;      // rax, Other Possible Types: unsigned long long\n\n  if (!(unsigned int)a1) {\n    v3 = NewTreeNode(0, 0, a0);\n    return v3;\n  }\n  v1 = a1 - 1;\n  v2 = a0 * 2;\n  v3 = NewTreeNode(BottomUpTree_name_conflict(v2 - 1, v1), BottomUpTree_name_conflict(v2, v1), a0);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(HTTPClientWriteData)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long HTTPSendFile_name_conflict(unsigned long long a0, char *a1) {\n  void *v1;         // rbx\n  FILE_t *v2;       // rbp\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = malloc(0x10000);\n  v2 = fopen(a1, \"rb\");\n  if (!v2)\n    return 1;\n  while ((unsigned int)v3) {\n    v3 = fread(v1, 1, 0x10000, v2);\n    v3 = HTTPClientWriteData(a0, v1, v3, 5);\n    if ((unsigned int)v3)\n      return v3;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp5w8otaac/HTTPSendFile_name_conflict.c:175:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 175 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/R:\", 3) == 0) {\n            strcpy(pClientParams->ProxyHost, argv[nArg] + 3);\n            pClientParams->UseProxy = 1;\n            pSearchPtr = strstr(pClientParams->ProxyHost, \":\");\n            if (pSearchPtr) {\n                PortNum[0] = 0;\n                nResult = (int)(pSearchPtr - pClientParams->ProxyHost);\n                strcpy(PortNum, pClientParams->ProxyHost + nResult + 1);\n                pClientParams->ProxyHost[nResult] = 0;\n                pClientParams->ProxyPort = atol(PortNum);\n            } else {\n                pClientParams->ProxyPort = 8080;\n            }\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/C:\", 3) == 0) {\n            strcpy(pClientParams->UserName, argv[nArg] + 3);\n            pSearchPtr = strstr(pClientParams->UserName, \":\");\n            if (!pSearchPtr) {\n                HTTPDumpHelp(\"Error: /C argument must be in the form of user:password\");\n                return -1;\n            }\n            nResult = (int)(pSearchPtr - pClientParams->UserName);\n            strcpy(pClientParams->Password, pClientParams->UserName + nResult + 1);\n            pClientParams->UserName[nResult] = 0;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/A:\", 3) == 0) {\n            pSearchPtr = argv[nArg] + 3;\n            if (*pSearchPtr == 'b' || *pSearchPtr == 'B') {\n                pClientParams->AuthType = AuthSchemaBasic;\n                continue;\n            }\n            if (*pSearchPtr == 'd' || *pSearchPtr == 'D') {\n                pClientParams->AuthType = AuthSchemaDigest;\n                continue;\n            }\n            if (pClientParams->AuthType == AuthSchemaNone) {\n                HTTPDumpHelp(\"Error: /A argument must be 'b' (for basic) or 'd' (for digest)\");\n                return -1;\n            }\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0) {\n        HTTPDumpHelp(\"Error: /H argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPDumpHelp)(long long);\n\ntypedef struct struct_1 {\n  char padding_0[3];\n  char field_3;\n} struct_1;\n\ntypedef struct struct_2 {\n  char field_0;\n  char padding_1[2047];\n  unsigned int field_800;\n  unsigned int field_804;\n  unsigned int field_808;\n  char padding_80c[128];\n  unsigned int field_88c;\n} struct_2;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long HTTPParseCommandLineArgs_name_conflict(unsigned long a0, char *a1, struct_2 *a2) {\n  struct_0 *v0;           // [bp-0x80]\n  char v1;                // [bp-0x78]\n  struct struct_1 **v3;   // rbp, Other Possible Types: unsigned long\n  struct_1 *v4;           // rbx\n  char *v5;               // rbx\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rax\n  unsigned long long v8;  // rcx\n  char v9;                // al\n  struct_0 *v11;          // rax\n  unsigned long long v12; // rbx\n\n  if ((unsigned int)a0 <= 1) {\n    HTTPDumpHelp(\"Error: did not get key parameters.\");\n    return 4294967295;\n  }\n  v3 = a1 + 8;\n  do {\n    v4 = *((long long *)v3);\n    if (!strncasecmp(v4, \"/?\", 2)) {\n      HTTPDumpHelp(0);\n      return 4294967295;\n    }\n    if (!strncasecmp(v4, \"/V\", 2)) {\n      a2->field_808 = 1;\n    } else if (!strncasecmp(v4, \"/H:\", 3)) {\n      strcpy(a2, &v4->field_3);\n    } else if (!strncasecmp(v4, \"/R:\", 3)) {\n      a1 = &v4->field_3;\n      v5 = &a2->padding_1[1023];\n      strcpy(v5, a1);\n      a2->field_800 = 1;\n      v6 = strchr(v5, 58);\n      if (v6) {\n        v1 = 0;\n        v8 = v6 - v5;\n        v0 = &v1;\n        strcpy(&v1, &v5[v8 + 1]);\n        a2->padding_1[1023 + v8] = 0;\n        a2->field_804 = strtol(v0, NULL, 10);\n        continue;\n      } else {\n        a2->field_804 = 8080;\n      }\n    } else if (!strncasecmp(v4, \"/C:\", 3)) {\n      v0 = &a2->padding_80c[0];\n      strcpy(v0, &v4->field_3);\n      v7 = strchr(v0, 58);\n      if (!v7) {\n        HTTPDumpHelp(\"Error: /C argument must be in the form of user:password\");\n        return 4294967295;\n      }\n      v11 = v0;\n      v12 = v7 - (char *)v11;\n      strcpy(&a2->padding_80c[64], &v11[v12 + 1]);\n      a2->padding_80c[v12] = 0;\n    } else {\n      if (!strncasecmp(v4, \"/A:\", 3)) {\n        v9 = v4->field_3 & 4294967263;\n        if (v9 == 66) {\n          a2->field_88c = 1;\n          continue;\n        } else if (v9 == 68) {\n          a2->field_88c = 2;\n          continue;\n        } else if (!a2->field_88c) {\n          HTTPDumpHelp(\n              \"Error: /A argument must be 'b' (for basic) or 'd' (for digest)\");\n          return 4294967295;\n        }\n      }\n      if (!strncasecmp(v4, \"/D:\", 3)) {\n        strcpy(a2 + 1, &v4->field_3);\n      } else if (!strncasecmp(v4, \"/F:\", 3)) {\n        strcpy(&a2[1].padding_1[1023], &v4->field_3);\n      }\n    }\n  } while ((v3 += 8, v3 != a1 + (a0 - 2 << 3) + 16));\n  if (a2->field_0)\n    return 0;\n  HTTPDumpHelp(\"Error: /H argument is missing\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbjfwead2/HTTPParseCommandLineArgs_name_conflict.c:83:25: error: invalid operands to\nbinary expression ('unsigned long long' and 'char *') 83 |                 v8 =\nv6 - v5; |                      ~~ ^ ~~\n/tmp/tmpbjfwead2/HTTPParseCommandLineArgs_name_conflict.c:106:22: error: invalid operands to\nbinary expression ('unsigned long long' and 'char *') 106 |             v12 = v7\n- (char *)v11; |                   ~~ ^ ~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrInsensitiveCompare(unsigned long a0, char *a1,\n                                    unsigned long a2) {\n  unsigned int v1;  // ebx\n  unsigned long v3; // rdx, Other Possible Types: char\n  unsigned long v4; // al, Other Possible Types: char\n  unsigned long v5; // rcx\n\n  v1 = a2;\n  if (!(unsigned int)a2)\n    v1 = strlen(a0);\n  if (v1 != (unsigned int)strlen(a1))\n    return 0;\n  v5 = 0;\n  while (true) {\n    v3 = *((char *)(a0 + v5));\n    v4 = a1[v5];\n    if (v3 - 64 < 27)\n      v3 = (char)v3 + 32;\n    if (v4 - 64 < 27)\n      v4 = (char)v4 + 32;\n    if ((char)v3 != (char)v4)\n      return 0;\n    *((char *)&v4) = (unsigned int)v5 + 1 == v1;\n    v5 += 1;\n    if ((v1 & (char)v4))\n      return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrExtract_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char *v1;              // rdi\n  unsigned long long v2; // rax\n\n  if (!a0) {\n    return 0;\n  } else if (!(char)a2) {\n    v1 = &a0[a1];\n    v2 = *(v1);\n    *(v1) = 0;\n    return v2;\n  } else {\n    a0[a1] = a2;\n    return a2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_toupper_loc)();\nchar *(__ctype_tolower_loc)();\n\nlong long HTTPStrCaseStr_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  char *v2;              // rbx, Other Possible Types: unsigned long\n  unsigned long v3;      // rbx\n  unsigned int *v4;      // rbp\n  unsigned int v5;       // r15d\n  unsigned long long v6; // rbp\n\n  if (!(unsigned int)a1)\n    return 0;\n  v2 = a0;\n  v4 = *(a2);\n  v5 = *((int *)(*((long long *)&__ctype_toupper_loc()) + v4 * 4));\n  v0 = *((int *)(*((long long *)&__ctype_tolower_loc()) + v4 * 4));\n  while (true) {\n    v6 = strchr(v2, v5);\n    v3 = strchr(v2, v0);\n    if (v6) {\n      if (!v3 || v3 >= v6)\n        v3 = v6;\n    } else {\n      if (!v3)\n        return v3;\n    }\n    if (!strncasecmp(v3, a2, strlen(a2)))\n      return v3;\n    v2 = v3 + 1;\n    if ((unsigned int)a1 == 1)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzt0mtbbd/HTTPStrCaseStr_name_conflict.c:32:35: error: cannot take the address of an\nrvalue of type 'char *' 32 |     v5 = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + v4 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzt0mtbbd/HTTPStrCaseStr_name_conflict.c:32:64: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |     v5 = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + v4 * 4)); | ~~ ^ ~\n/tmp/tmpzt0mtbbd/HTTPStrCaseStr_name_conflict.c:33:35: error: cannot take the address of an\nrvalue of type 'char *' 33 |     v0 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + v4 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzt0mtbbd/HTTPStrCaseStr_name_conflict.c:33:64: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 33 |     v0 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + v4 * 4)); | ~~ ^ ~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long HTTPStrGetToken(char *a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long long v0; // [bp-0x138]\n  char *v3;              // rbp\n  unsigned int *v4;      // r12\n  struct_0 *v5;          // rax\n  unsigned long v6;      // edi, Other Possible Types: unsigned int\n  void *v7;              // rdx, Other Possible Types: unsigned long\n  unsigned long v8;      // rcx, Other Possible Types: char\n  unsigned long v10;     // rax\n  unsigned long v11;     // rdx, Other Possible Types: unsigned long long\n\n  v3 = a2;\n  v4 = a3;\n  v5 = strchr(a0, 58);\n  v8 = v5->field_1;\n  if (v8 > 13) {\n    v7 = 0;\n    v6 = 0;\n  } else {\n    v7 = (int)(9217 >> (v8 & 63)) & 1;\n    if (!(unsigned int)v7) {\n      v6 = 0;\n    } else {\n      v6 = 0;\n    LABEL_40726c:\n      *(v4) = v6;\n      v10 = v5->field_1;\n      if ((char)v10 > 13) {\n        v11 = 0;\n      } else {\n        v11 = 0;\n        v0 = 9217;\n        if (((char)(*((char *)&v0 + ((v10 & 63) >> 3)) >>\n                    (char)(v10 & 63 & 7)) &\n             1)) {\n          *(v3) = 0;\n          return v3;\n        }\n      }\n      do {\n        do {\n          if ((char)v10 != 32) {\n            v3[v11] = v10;\n            v11 += 1;\n          }\n        } while (\n            (v0 = (unsigned long long)9217,\n             !((char)((unsigned long long)(char)*(\n                          (char *)((char *)&v0 +\n                                   ((unsigned long long)(v5->field_1 & 63) >>\n                                    3))) >>\n                      (unsigned long long)(v5->field_1 & 63 & 7)) &\n               1)));\n      } while ((v0 = (unsigned long long)9217,\n                !((char)((unsigned long long)(char)*(\n                             (char *)((char *)&v0 +\n                                      ((unsigned long long)(v5->field_1 & 63) >>\n                                       3))) >>\n                         (unsigned long long)(v5->field_1 & 63 & 7)) &\n                  1)));\n      v3[v11] = 0;\n      return v3;\n    }\n  }\n  while (true) {\n    v6 += (char)v8 != 32;\n    if ((unsigned int)a1 && (unsigned int)a1 < (unsigned int)v7)\n      break;\n    v8 = (&v5[1].padding_0)[v7];\n    if ((char)v8 <= 13) {\n      v7 += 1;\n      v0 = 9217;\n      if (((char)(*((char *)&v0 + ((v8 & 63) >> 3)) >> (char)(v8 & 63 & 7)) &\n           1))\n        break;\n    } else {\n      v7 += 1;\n    }\n  }\n  if (*(v4) < (unsigned int)v6) {\n    *(v4) = v6;\n    return 0;\n  }\n  goto LABEL_40726c;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf6fnt7br/HTTPStrGetToken.c:90:32: error: array subscript is not an\ninteger 90 |         v8 = (&v5[1].padding_0)[v7]; | ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_toupper_loc)();\n\nlong long HTTPStrHToL_name_conflict(unsigned long a0) {\n  unsigned int v0;        // [bp-0x3c]\n  unsigned long long *v2; // r15\n  void *v3;               // r14, Other Possible Types: unsigned long\n  char *v4;               // rbx\n  unsigned int *v5;       // r12\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // r14\n  unsigned long v8;       // rax, Other Possible Types: unsigned long long\n  char *v9;               // rbp, Other Possible Types: unsigned long\n\n  v2 = __ctype_b_loc();\n  v3 = 0;\n  v0 = 0;\n  v9 = 0;\n  while (true) {\n    v4 = v9 + a0;\n    v5 = *(v4);\n    if ((*((char *)(*(v2) + (v5 << 1))) & 8)) {\n      v6 = *((int *)(*((long long *)&__ctype_toupper_loc()) + v5 * 4));\n      *(v4) = v6;\n      if ((char)v6 == 88) {\n        v3 = 0;\n        v0 = 0;\n      } else {\n        v8 = (!(*((char *)(*(v2) + ((char)v6 << 1) + 1)) & 4)\n                  ? (unsigned int)v6 - 55\n                  : (unsigned int)v6 - 48);\n        v7 = v3 * 16;\n        if (15 < (unsigned int)v8)\n          v8 = 15;\n        v3 = v7 + v8;\n        v0 = v0 - -1 - ((unsigned int)v3 < 1);\n        if (v0 == 8)\n          return v3;\n      }\n    }\n    v9 = (unsigned int)v9 + 1;\n    if (!*((char *)(a0 + v9)))\n      return v3;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt1t7945x/HTTPStrHToL_name_conflict.c:38:37: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 38 |         if ((*((char *)(*(v2) + (v5\n<< 1))) & 8)) |                                  ~~ ^  ~\n/tmp/tmpt1t7945x/HTTPStrHToL_name_conflict.c:40:43: error: cannot take the address of an\nrvalue of type 'char *' 40 |             v6 = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + v5 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt1t7945x/HTTPStrHToL_name_conflict.c:40:72: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 40 |             v6 = *((int *)(*((long\nlong *)&__ctype_toupper_loc()) + v5 * 4)); | ~~ ^ ~\n/tmp/tmpt1t7945x/HTTPStrHToL_name_conflict.c:50:25: error: invalid operands to binary\nexpression ('void *' and 'int') 50 |                 v7 = v3 * 16; | ~~ ^ ~~ 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrLToH_name_conflict(char a0[2], unsigned long a1) {\n  char v1[2];            // rax, Other Possible Types: unsigned long\n  unsigned long v2;      // rcx, Other Possible Types: unsigned long long\n  unsigned long long v3; // r9\n\n  v1 = a0;\n  if (!(unsigned int)a1) {\n    a0[0] = 48;\n    a0[1] = 0;\n    return a0;\n  }\n  v2 = 28;\n  if (!(unsigned int)(a1 >> 28)) {\n    do {\n      v2 = (unsigned int)v2 - 4;\n    } while (!(unsigned int)(a1 >> ((char)v2 & 31)));\n    if ((unsigned int)v2 < 0) {\n      a0[0] = 0;\n      return a0;\n    }\n  }\n  v3 = v2;\n  do {\n    *((char *)a0) =\n        *((char *)(4228481 + ((unsigned int)(a1 >> ((char)v2 & 31)) & 15)));\n    v2 = (unsigned int)v2 - 4;\n    a0 += 1;\n  } while ((unsigned int)v2 != -0x4);\n  v1 = &v1[1 + (v3 >> 2)];\n  *((char *)v1) = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmqw6vzrl/HTTPStrLToH_name_conflict.c:23:8: error: array type 'char[2]' is not\nassignable 23 |     v1 = a0; |     ~~ ^ /tmp/tmpmqw6vzrl/HTTPStrLToH_name_conflict.c:50:8:\nerror: array type 'char[2]' is not assignable 50 |     v1 = &v1[1 + (v3 >> 2)];\n      |     ~~ ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperIsAscii_name_conflict(unsigned long a0) {\n  return (unsigned int)a0 <= 127;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperToUpper_name_conflict(unsigned long a0) {\n  if (26 > (unsigned int)(a0 - 97))\n    return a0 - 32;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperToLower_name_conflict(unsigned long a0) {\n  if (26 > (unsigned int)(a0 - 65))\n    return a0 + 32;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperIsAlpha_name_conflict(unsigned long a0) {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if ((unsigned int)a0 <= 127)\n    v1 = (((unsigned int)a0 & -33) - 65 < 26 ? 0 : a0);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAlpha)(long long);\n\nlong long HTTPWrapperIsAlNum_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x8]\n  unsigned long v2; // rbx\n\n  if ((unsigned int)a0 > 127)\n    return 0;\n  v0 = v2;\n  if ((int)HTTPWrapperIsAlpha(a0) <= 0)\n    return ((unsigned int)(a0 - 48) < 10 ? 0 : a0);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperItoa_name_conflict(char *a0, unsigned long long a1) {\n  int tmp_54;            // tmp #54\n  unsigned long long v1; // rdx, Other Possible Types: unsigned long\n  unsigned long long v4; // rax\n  unsigned long long v5; // rsi\n  unsigned long long v6; // rax\n  unsigned long long v7; // rax\n  unsigned int v8;       // ecx\n\n  if ((unsigned int)a1 < 0) {\n    v1 = -((unsigned int)a1);\n    *(a0) = 45;\n    a0 += 1;\n  } else {\n    v1 = a1;\n    if (!(unsigned int)a1)\n      goto LABEL_4075aa;\n  }\n  do {\n    a0 += 1;\n    v4 = rax * 1717986919 >> 34;\n    v5 = a1 >> 31;\n    tmp_54 = v5;\n    v6 = v4 - v5;\n    a1 = v6;\n  } while ((unsigned int)v6 != (int)tmp_54);\nLABEL_4075aa:\n  *((char *)a0) = 0;\n  if (!(unsigned int)v1)\n    return a0;\n  do {\n    a0 -= 1;\n    v7 = 3435973837 * v1 >> 35;\n    *((char *)a0) = (unsigned int)v1 - (unsigned int)v7 * 10 + 48;\n    v8 = v1;\n    v1 = v7;\n  } while (v8 > 9);\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long HTTPWrapperShutDown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperGetSocketError_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3x36d05r/HTTPWrapperGetSocketError_name_conflict.c:19:12: error: indirection requires\npointer operand ('int' invalid) 19 |     return *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct struct_2 {\n  char padding_0[24];\n  struct struct_1 *field_18;\n} struct_2;\n\ntypedef struct struct_1 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_1;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long HTTPWrapperGetHostByName_name_conflict(char *a0, unsigned int *a1) {\n  struct_2 *v0;           // [bp-0x80]\n  int v1;                 // [bp-0x78]\n  unsigned int v2;        // [bp-0x74]\n  unsigned int v3;        // [bp-0x70]\n  int v4;                 // [bp-0x68]\n  int v5;                 // [bp-0x58]\n  char v6;                // [bp-0x3c]\n  char *v8;               // r12\n  unsigned long long v9;  // rax\n  unsigned long long v11; // rbx\n  void *v12;         // rax, Other Possible Types: unsigned long, struct_0 *\n  unsigned int v13;  // r14d\n  unsigned long v14; // rbp\n  unsigned long v15; // rbx\n  struct_2 *v16;     // rdi\n\n  v8 = a0;\n  (unsigned int)v9 = strlen(a0);\n  if ((unsigned int)v9 >= 0) {\n    v14 = 0;\n    v13 = 0;\n    v12 = 0;\n    while (true) {\n      v11 = v8[v14];\n      if (v11 - 48 > 9 && (char)v11 != 46) {\n      LABEL_40767f:\n        if (!(char)v11) {\n          if (v13 == 3) {\n            if (strtol(&v6, NULL, 10) <= 0x100) {\n              *(a1) = inet_addr(v8);\n              return 0;\n            }\n            return 4294967295;\n          }\n          break;\n        }\n      } else {\n        if ((char)v11 == 46) {\n          v13 += 1;\n          if (!(strtol(&v6, NULL, 10) <= 0x100) || !(v13 <= 3))\n            return 4294967295;\n          v12 = 0;\n        } else {\n          if ((unsigned int)v12 > 3)\n            break;\n          (&v6)[v12] = v11;\n          v12 = (unsigned int)v12 + 1;\n          (&v6)[v12] = 0;\n        }\n        v14 += 1;\n        if ((unsigned int)v9 < (unsigned int)v14)\n          goto LABEL_40767f;\n      }\n    }\n  }\n  v0 = 0;\n  *((int128_t *)&v1) = 0;\n  *((int128_t *)&v4) = 0;\n  *((int128_t *)&v5) = 0;\n  v2 = 2;\n  v3 = 1;\n  v15 = getaddrinfo(v8, 0, &v1, &v0);\n  if (!(unsigned int)v15) {\n    v16 = v0;\n    *(a1) = v16->field_18->field_4;\n    freeaddrinfo(v16);\n    return v15;\n  }\n  fprintf(stderr @GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v15));\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:35:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 35 | extern FILE_t *stderr@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:35:22: error: expected ';' after top\nlevel declarator 35 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:56:5: error: assignment to cast is\nillegal, lvalue casts are not supported 56 |     (unsigned int)v9 = strlen(a0);\n      |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:95:26: error: array subscript is not\nan integer 95 |                     (&v6)[v12] = v11; | ^~~~\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:97:26: error: array subscript is not\nan integer 97 |                     (&v6)[v12] = 0; | ^~~~\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:106:18: error: expected expression\n  106 |     *((int128_t *)&v1) = 0;\n      |                  ^\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:107:18: error: expected expression\n  107 |     *((int128_t *)&v4) = 0;\n      |                  ^\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:108:18: error: expected expression\n  108 |     *((int128_t *)&v5) = 0;\n      |                  ^\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:119:19: error: expected ')'\n  119 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v15));\n      |                   ^\n/tmp/tmppf0toktv/HTTPWrapperGetHostByName_name_conflict.c:119:12: note: to match this '('\n  119 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v15));\n      |            ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\ndouble HTTPWrapperGetRandomeNumber_name_conflict() {\n  return (long long)((0 CONCAT rand()) * 0xf8ba000000000000000000000000000);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe5d76lhk/HTTPWrapperGetRandomeNumber_name_conflict.c:20:27: error: expected ')'\n   20 |     return (long long)((0 CONCAT rand()) *\n0xf8ba000000000000000000000000000); |                           ^\n/tmp/tmpe5d76lhk/HTTPWrapperGetRandomeNumber_name_conflict.c:20:24: note: to match this '('\n   20 |     return (long long)((0 CONCAT rand()) *\n0xf8ba000000000000000000000000000); |                        ^\n/tmp/tmpe5d76lhk/HTTPWrapperGetRandomeNumber_name_conflict.c:20:44: error: integer literal is\ntoo large to be represented in any integer type 20 |     return (long long)((0\nCONCAT rand()) * 0xf8ba000000000000000000000000000); | ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long HTTPWrapperGetUpTime_name_conflict() {\n  char v0; // [bp-0x18]\n\n  clock_gettime(0x1, &v0);\n  return *((long long *)&v0);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLConnect_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLNegotiate_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLSend_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecv_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecvPending_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLClose_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long sktSetNonblocking_name_conflict(unsigned long a0, unsigned long a1) {\n  if (fcntl(a0, 3) < 0) {\n    return 4294967295;\n  } else if (fcntl(a0, 4) < 0) {\n    fcntl(a0, 4);\n    return 4294967295;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetLocalConnection_name_conflict() { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPClientSetVerb)(long long, long long);\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n  char padding_8[56];\n  unsigned short field_40;\n  char padding_42[518];\n  unsigned long long field_248;\n  unsigned int field_250;\n  char padding_254[4];\n  unsigned long long field_258;\n  char padding_260[1104];\n  unsigned int field_6b0;\n  char padding_6b4[620];\n  unsigned int field_920;\n  char padding_924[48];\n  unsigned int field_954;\n  unsigned int field_958;\n  char padding_95c[532];\n  unsigned short field_b70;\n} struct_0;\n\nlong long HTTPClientOpenRequest_name_conflict(unsigned long a0) {\n  struct_0 *v2;           // rax\n  struct_0 *v3;           // rbx\n  unsigned long v4;       // rcx, Other Possible Types: unsigned long long\n  unsigned long v5;       // d\n  struct_0 *v6;           // rdi, Other Possible Types: unsigned long\n  unsigned long long *v7; // rax\n  unsigned long v8;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v9; // rdi, Other Possible Types: unsigned long\n\n  v2 = malloc(2936);\n  if (!v2)\n    return 0;\n  v3 = v2;\n  v4 = 367;\n  for (v6 = v2; v4; v6 += v5 * 8) {\n    v4 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v7 = malloc(0x800);\n  v3->field_248 = v7;\n  if (!v7) {\n    free(v3);\n    return 0;\n  }\n  v8 = 0x100;\n  for (v9 = v7; v8; v9 += v5 * 8) {\n    v8 -= 1;\n    *((long long *)v9) = 0;\n  }\n  v3->field_250 = 0x800;\n  HTTPClientSetVerb(v3, 0);\n  v3->field_40 = 80;\n  v3->field_920 = -1;\n  v3->field_258 = v3->field_248;\n  v3->field_954 = 1;\n  v3->field_958 = a0;\n  v3->field_6b0 = 0;\n  v3->field_b70 = 80;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnSessionReset)(long long, long long);\n\nlong long HTTPClientReset_name_conflict(unsigned long long a0) {\n  if (a0)\n    return HTTPIntrnSessionReset(a0, 1);\n  return 2;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnConnectionClose)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[584];\n  unsigned long long field_248;\n} struct_0;\n\nlong long HTTPClientCloseRequest_name_conflict(struct struct_0 **a0) {\n  struct_0 *v1; // rbp\n  void *v4;     // rdi\n\n  v1 = *(a0);\n  if (!v1)\n    return 2;\n  v4 = v1->field_248;\n  if (v4)\n    free(v4);\n  HTTPIntrnConnectionClose(v1);\n  free(v1);\n  *(a0) = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1724];\n  unsigned int field_6bc;\n} struct_0;\n\nlong long HTTPClientSetConnection_name_conflict(struct_0 *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 2;\n  if (a0) {\n    a0->field_6bc = a1;\n    v1 = 0;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetVerb_name_conflict(unsigned int a0[421], unsigned long a1) {\n  if (!a0)\n    return 2;\n  a0[162] = a1;\n  if ((unsigned int)a1 == 2) {\n    strcpy(&a0[420], \"POST\");\n    return 0;\n  } else if ((unsigned int)a1 == 3) {\n    a0[420] = 5526864;\n    return 0;\n  } else if (!(unsigned int)a1) {\n    a0[420] = 5522759;\n    return a1;\n  } else {\n    return 18;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[1872];\n  unsigned short field_750;\n  char padding_752[18];\n  unsigned int field_764;\n  char padding_768[496];\n  unsigned int field_958;\n} struct_0;\n\nlong long HTTPClientSetProxy(struct_0 *a0, char *a1, unsigned long a2, char *a3,\n                             char *a4) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned long v2; // [bp-0x10]\n  unsigned long v3; // [bp-0x8]\n  unsigned long v5; // r13\n  unsigned long v6; // r12\n  unsigned long v7; // rbx\n\n  if (!a0)\n    return 2;\n  v3 = v5;\n  v2 = v6;\n  *((int *)&v1) = rbp;\n  v0 = v7;\n  strncpy(&a0->padding_0[1776], a1, 64);\n  if (a3) {\n    strncpy(&a0->padding_0[1840], a3, 16);\n    if (a4) {\n      strncpy(&a0->padding_0[1856], a4, 16);\n      a0->field_750 = a2;\n      a0->field_958 = a0->field_958 | 128;\n      a0->field_764 = 1;\n      return 0;\n    }\n  } else if (a4) {\n    strncpy(&a0->padding_0[1856], a4, 16);\n    a0->field_750 = a2;\n    a0->field_958 = a0->field_958 | 128;\n    return 0;\n  }\n  a0->field_750 = a2;\n  a0->field_958 = a0->field_958 | 128;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1732];\n  unsigned int field_6c4;\n} struct_0;\n\nlong long HTTPClientSetCredentials_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v4; // r12\n  unsigned long v5; // rbx\n  unsigned int v6;  // edx\n  unsigned long v7; // rax, Other Possible Types: unsigned long long\n  unsigned int v8;  // edx\n\n  if (!a0)\n    return 2;\n  v2 = v4;\n  *((int *)&v1) = rbp;\n  v0 = v5;\n  v6 = strlen(a1);\n  v7 = 19;\n  if (v6 > 16)\n    return v7;\n  v8 = strlen(*((unsigned long long *)&v6));\n  v7 = 19;\n  if (v8 <= 16) {\n    strcpy(&a0[1].padding_0[160], a1);\n    strcpy(&a0[1].padding_0[176], *((unsigned long long *)&v6));\n    a0->field_6c4 = 1;\n    v7 = 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersAdd)(long long, long long, long long, long long,\n                               long long);\n\nlong long HTTPClientAddRequestHeaders(unsigned long long a0, char *a1,\n                                      char *a2) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned long v1;       // [bp-0x18]\n  unsigned long v2;       // [bp-0x10]\n  unsigned long v3;       // [bp-0x8]\n  unsigned long v5;       // r13\n  unsigned long v6;       // r12\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n  unsigned long long v9;  // r12\n  unsigned long long v10; // r13\n\n  if (a0) {\n    v3 = v5;\n    v2 = v6;\n    *((int *)&v1) = rbp;\n    v0 = v7;\n    v8 = v0;\n    v9 = v2;\n    v10 = v3;\n    return HTTPIntrnHeadersAdd(a0, a1, strlen(a1), a2, strlen(a2));\n  }\n  return 2;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersReceive)(long long, long long);\n\nlong long HTTPClientRecvResponse_name_conflict(unsigned long long a0, unsigned long long a1) {\n  if (a0)\n    return HTTPIntrnHeadersReceive(a0, a1);\n  return 2;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientGetInfo_name_conflict(unsigned int a0[598], unsigned int a1[5]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 2;\n  if (a0) {\n    *((int128_t *)&a1[0]) = 0;\n    a1[4] = 0;\n    a1[0] = a0[428];\n    a1[1] = a0[595];\n    a1[2] = a0[589];\n    a1[3] = a0[429];\n    a1[4] = a0[597];\n    v1 = 0;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphroxug43/HTTPClientGetInfo_name_conflict.c:25:22: error: expected expression\n   25 |         *((int128_t *)&a1[0]) = 0;\n      |                      ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientFindFirstHeader_name_conflict(struct_0 *a0, char *a1) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v1; // [bp-0x8]\n  unsigned long v3; // rbx\n\n  if (!a0)\n    return 2;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  if ((unsigned int)strlen(a1) <= 1023) {\n    strcpy(&a0[1].padding_0[12], a1);\n    a0->field_280 = 0;\n    a0->field_278 = 0;\n    return 0;\n  }\n  return 13;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n  char padding_284[12];\n  char field_290;\n} struct_0;\n\nlong long HTTPClientFindCloseHeader_name_conflict(struct_0 *a0) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 2;\n  if (a0) {\n    a0->field_290 = 0;\n    a0->field_280 = 0;\n    a0->field_278 = 0;\n    v1 = 0;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersFind)(long long, long long, long long, long long,\n                                long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[616];\n  unsigned int field_268;\n  char padding_26c[12];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientGetNextHeader_name_conflict(struct_0 *a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x54]\n  unsigned long v1;      // [bp-0x50]\n  char v2;               // [bp-0x48]\n  char v3;               // [bp-0x40]\n  unsigned long v5;      // rbp\n  char *v6;              // r15\n  unsigned long v7;      // r8, Other Possible Types: unsigned long long\n  unsigned long long v8; // r13\n  char *v9;              // r14\n  char *v10;             // rsi, Other Possible Types: unsigned long\n  unsigned long\n      v11; // rax, Other Possible Types: unsigned int, unsigned long long\n\n  if (!a0)\n    return 2;\n  v6 = a1;\n  v7 = a0->field_280;\n  if ((unsigned int)v7)\n    v7 = (unsigned int)a0->field_278 - a0->field_268;\n  v11 = HTTPIntrnHeadersFind(a0, &a0[1].padding_0[12], &v2, 1, v7);\n  v5 = v11;\n  if ((unsigned int)v11)\n    return v11;\n  v8 = *((int *)&v3);\n  if (*(a2) < (unsigned int)v8) {\n    *(a2) = v8;\n    *(a1) = 0;\n    return 3;\n  }\n  v9 = *((long long *)&v2);\n  v10 = v9;\n  if (*(v9) == 13) {\n    v10 = v9 + 1;\n    v11 = 1;\n  }\n  if (*((char *)v10) == 10) {\n    v11 = (unsigned int)v11 + 1;\n    v10 += 1;\n  }\n  v0 = (unsigned int)v8 - (unsigned int)v11;\n  v1 = v0;\n  strncpy(v6, v10, v0);\n  v6[v1] = 0;\n  *(a2) = v0;\n  a0->field_278 = &v9[v8];\n  a0->field_280 = a0->field_280 + 1;\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperGetUpTime)();\n\nlong long HTTPIntrnSessionGetUpTime_name_conflict() { return HTTPWrapperGetUpTime(); }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char base64val;\n\nlong long HTTPBase64Decoder_name_conflict(char a0[3], char a1[2]) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned long v1;       // [bp-0x18]\n  unsigned long v2;       // [bp-0x10]\n  unsigned long v3;       // [bp-0x8]\n  char v5[1];             // rdx, Other Possible Types: unsigned long\n  char *v6;               // rax\n  unsigned long v7;       // rax\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  unsigned long v10;      // r13\n  unsigned long v11;      // r12\n  unsigned long v12;      // rbx\n  unsigned long v13;      // r12\n  char *v14;              // rbp, Other Possible Types: unsigned long, char\n  char *v15;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v16; // r8\n  char v17;               // r8b\n  char v18;               // al\n  char v19;               // al\n  char v20[1];            // rcx, Other Possible Types: unsigned long\n  unsigned long v21;      // rax\n  unsigned long v22;      // r8, Other Possible Types: unsigned long long\n  unsigned long v23;      // rax\n  unsigned long long v24; // r9, Other Possible Types: unsigned long\n\n  if (a1[0] == 43) {\n    if (a1[1] == 32) {\n      a1 += 1;\n    } else {\n    LABEL_405fca:\n      v5 = a1 + 4;\n      v20 = v5;\n      v6 = (unsigned long long)v5[4];\n      if ((char)v6 < 0)\n        return 4294967295;\n      v22 = *((char *)(&base64val + v6));\n      if ((char)v22 == 255)\n        return 4294967295;\n      v7 = (unsigned long long)v5[3];\n      if ((char)v7 < 0)\n        return 4294967295;\n      v9 = (&base64val)[v7];\n      if ((char)v9 == 255)\n        return 4294967295;\n      v3 = v10;\n      v2 = v11;\n      *((int *)&v1) = rbp;\n      v0 = v12;\n      while ((char)v13 != 61) {\n        v13 = *((char *)(v20 - 2));\n        if ((char)v13 < 0)\n          return 4294967295;\n        if ((&base64val)[(char)v13] == 255)\n          return 4294967295;\n        v14 = *((char *)(v20 - 1));\n        v15 = v14;\n        if ((char)v14 == 61) {\n          *((char *)a0) = (unsigned int)v22 * 4 | (unsigned int)(v9 >> 4);\n          v14 = 61;\n          goto LABEL_4060b0;\n        }\n        if ((char)v14 < 0)\n          return 4294967295;\n        if ((&base64val)[(char)v15] == 255)\n          return 4294967295;\n        *((char *)a0) = (unsigned int)v22 * 4 | (unsigned int)(v9 >> 4);\n        if ((char)v13 == 61) {\n          a0 += 1;\n          v24 = 1;\n          goto LABEL_4060f0;\n        }\n        if ((char)v13 >= 0) {\n        LABEL_4060b0:\n          v16 = (&base64val)[v13];\n          *((char *)(a0 + 1)) =\n              (unsigned int)v9 * 16 | (unsigned int)(v16 >> 2);\n          if ((char)v15 == 61)\n            return 2;\n          v17 = (unsigned int)v16 * 64;\n          goto LABEL_4060d2;\n        } else {\n          *((char *)(a0 + 1)) = 255;\n          if ((char)v15 == 61)\n            return 2;\n          v17 = 192;\n        LABEL_4060d2:\n          v18 = 255;\n          if ((char)v14 >= 0)\n            v18 = (&base64val)[(char)v15];\n          *((char *)(a0 + 2)) = v17 | v18;\n          v24 = 3;\n          a0 += 3;\n        LABEL_4060f0:\n          v19 = *((char *)v20);\n          v5 += 4;\n          if (!(v19 != 13 & v19)) {\n            return v24;\n          } else if ((char)v15 == 61) {\n            return v24;\n          } else {\n            v20 = v5;\n            v21 = (unsigned long long)v5[4];\n            if ((char)v21 < 0)\n              return 4294967295;\n            v22 = (&base64val)[v21];\n            if ((char)v22 == 255)\n              return 4294967295;\n            v23 = (unsigned long long)v5[3];\n            if ((char)v23 < 0)\n              return 4294967295;\n            v9 = (&base64val)[v23];\n            if ((char)v9 == 255)\n              return 4294967295;\n          }\n        }\n      }\n      v14 = *((char *)(v20 - 1));\n      v15 = v14;\n      if ((char)v14 == 61) {\n        *((char *)a0) = (unsigned int)v22 * 4 | (unsigned int)(v9 >> 4);\n        return 1;\n      }\n    }\n  }\n  if (*((char *)a1) == 13)\n    return 0;\n  goto LABEL_405fca;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjrc2vvmb/HTTPBase64Decoder_name_conflict.c:55:16: error: array type 'char[1]' is not\nassignable 55 |             v5 = a1 + 4; |             ~~ ^\n/tmp/tmpjrc2vvmb/HTTPBase64Decoder_name_conflict.c:56:17: error: array type 'char[1]' is not\nassignable 56 |             v20 = v5; |             ~~~ ^\n/tmp/tmpjrc2vvmb/HTTPBase64Decoder_name_conflict.c:60:41: error: invalid operands to binary\nexpression ('char *' and 'char *') 60 |             v22 = *((char *)(&base64val\n+ v6)); |                              ~~~~~~~~~~ ^ ~~\n/tmp/tmpjrc2vvmb/HTTPBase64Decoder_name_conflict.c:124:24: error: invalid operands to binary\nexpression ('char[1]' and 'int') 124 |                     v5 += 4; | ~~ ^  ~\n/tmp/tmpjrc2vvmb/HTTPBase64Decoder_name_conflict.c:135:29: error: array type 'char[1]' is not\nassignable 135 |                         v20 = v5; |                         ~~~\n^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(HTTPClientWriteData)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long HTTPSendFile_name_conflict(unsigned long long a0, char *a1) {\n  void *v1;         // rbx\n  FILE_t *v2;       // rbp\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = malloc(0x10000);\n  v2 = fopen(a1, \"rb\");\n  if (!v2)\n    return 1;\n  while ((unsigned int)v3) {\n    v3 = fread(v1, 1, 0x10000, v2);\n    v3 = HTTPClientWriteData(a0, v1, v3, 5);\n    if ((unsigned int)v3)\n      return v3;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:16:16: error: conflicting types for 'fread'\n   16 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:142:16: error: redefinition of '_IO_marker'\n  142 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpk8n89q18/HTTPSendFile_name_conflict.c:175:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 175 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H2:\", 3) == 0) {\n            strcpy(pClientParams->Uri2, argv[nArg] + 4);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0 || strlen(pClientParams->Uri2) == 0) {\n        HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPDumpHelp)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[1023];\n  char field_400;\n  char padding_401[1023];\n  unsigned int field_800;\n} struct_0;\n\nlong long HTTPParseCommandLineArgs(unsigned long a0, unsigned long a1,\n                                   struct_0 *a2) {\n  unsigned long long *v1; // rbp, Other Possible Types: unsigned long\n  char *v2;               // rbx\n\n  if ((unsigned int)a0 <= 1) {\n    HTTPDumpHelp(\"Error: did not get key parameters.\");\n    return 4294967295;\n  }\n  v1 = a1 + 8;\n  do {\n    v2 = *((long long *)v1);\n    if (!strncasecmp(v2, \"/?\", 2)) {\n      HTTPDumpHelp(0);\n      return 4294967295;\n    }\n    if (!strncasecmp(v2, \"/V\", 2)) {\n      a2->field_800 = 1;\n    } else if (!strncasecmp(v2, \"/H:\", 3)) {\n      strcpy(a2, v2 + 3);\n    } else if (!strncasecmp(v2, \"/H2:\", 3)) {\n      strcpy(&a2->field_400, v2 + 4);\n    } else if (!strncasecmp(v2, \"/D:\", 3)) {\n      strcpy(a2 + 1, v2 + 3);\n    } else if (!strncasecmp(v2, \"/F:\", 3)) {\n      strcpy(&a2[1].field_400, v2 + 3);\n    }\n    v1 += 8;\n  } while (v1 != a1 + (a0 - 2 << 3) + 16);\n  if (a2->field_0 && a2->field_400)\n    return 0;\n  HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"int handle_http_request(HTTP_SESSION_HANDLE pHTTP, CHAR *uri, HTTPParameters *ClientParams) {\n    CHAR Buffer[8193];\n    INT32 nRetCode;\n    UINT32 nSize, nTotal = 0;\n    INT32 status_code;\n    HTTP_CLIENT HTTPClient;\n    do {\n        memset(&HTTPClient, 0, sizeof(HTTP_CLIENT));\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPost)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPut)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbGet)) != 0) {\n                break;\n            }\n        }\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ClientParams->PostData, strlen(ClientParams->PostData), 1, 5, 0)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            int ret;\n            struct stat stat_buf;\n            char file_size_str[32];\n            memset(&stat_buf, 0, sizeof(struct stat));\n            memset(file_size_str, 0, 32);\n            ret = stat(ClientParams->PutFilePath, &stat_buf);\n            if (ret) {\n                nRetCode = 19;\n                break;\n            }\n            HTTPWrapperItoa(file_size_str, (int)stat_buf.st_size);\n            if ((nRetCode = HTTPClientAddRequestHeaders(pHTTP, \"Content-Length\", file_size_str, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPSendFile(pHTTP, ClientParams->PutFilePath)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n        }\n        if ((nRetCode = HTTPClientRecvResponse(pHTTP, 3)) != 0) {\n            break;\n        }\n        if ((nRetCode = HTTPClientGetInfo(pHTTP, &HTTPClient)) != 0) {\n            break;\n        }\n        while (nRetCode == 0 || nRetCode != 1000)\n            {\n                if (nTotal >= HTTPClient.TotalResponseBodyLength) {\n                    break;\n                }\n                nSize = 8192;\n                nRetCode = HTTPClientReadData(pHTTP, Buffer, nSize, 5, &nSize);\n                nTotal += nSize;\n                Buffer[nSize] = 0;\n                printf(\"%s\", Buffer);\n            }\n    } while (0);\n    printf(\"\\n\");\n    if (ClientParams->Verbose == 1) {\n        printf(\"\\n\\nHTTP Client terminated %d (got %d bytes, status_code %d)\\n\\n\", (int)nRetCode, (int)(nTotal), HTTPClient.HTTPStatusCode);\n    }\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPClientSetVerb)(long long, long long);\nint(putchar)(int);\nlong long(HTTPClientSendRequest)(long long, long long, long long, long long,\n                                 long long, long long, int);\nlong long(HTTPClientRecvResponse)(long long, long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(HTTPClientGetInfo)(long long, long long);\nlong long(HTTPWrapperItoa)(long long, long long);\nlong long(HTTPClientAddRequestHeaders)(long long, long long, long long);\nlong long(HTTPClientReadData)(long long, long long, long long, long long,\n                              long long);\nlong long(HTTPSendFile)(long long, long long);\n\ntypedef struct struct_1 {\n  char padding_0[2048];\n  unsigned int field_800;\n  char field_804;\n  char padding_805[1023];\n  char field_c04;\n} struct_1;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long handle_http_request(unsigned long long a0, unsigned long long a1,\n                              struct_1 *a2) {\n  int v0;                // [bp-0x2118]\n  int v1;                // [bp-0x2108]\n  char v2;               // [bp-0x20f8]\n  char v3;               // [bp-0x20c8]\n  int v4;                // [bp-0x2068]\n  unsigned int v5;       // [bp-0x2058]\n  unsigned int v6;       // [bp-0x204c]\n  char v7;               // [bp-0x2048]\n  unsigned long long v9; // r12\n  unsigned long v10;     // rbx, Other Possible Types: unsigned long long\n  char *v11;             // rbx\n  unsigned long v12;     // rcx, Other Possible Types: unsigned long long\n  struct_0 *v13;         // rdi, Other Possible Types: unsigned long\n  unsigned long v14;     // d\n  unsigned long v15;     // r14d\n  char *v16;             // r14\n  unsigned long v17;     // rax\n\n  v9 = a0;\n  *((int128_t *)&v4) = 0;\n  v5 = 0;\n  if (a2->field_804) {\n    v10 = HTTPClientSetVerb(a0, 2);\n    if ((unsigned int)v10)\n      putchar(10);\n  } else if (!a2->field_c04) {\n    v10 = HTTPClientSetVerb(a0, 0);\n    if ((unsigned int)v10)\n      putchar(10);\n  } else {\n    v10 = HTTPClientSetVerb(a0, 3);\n    if ((unsigned int)v10)\n      putchar(10);\n  }\n  if (a2->field_804) {\n    v11 = &a2->field_804;\n    v10 = HTTPClientSendRequest(a0, a1, v11, strlen(v11), 1, 5, 0);\n    if ((unsigned int)v10)\n      putchar(10);\n  } else if (!a2->field_c04) {\n    v10 = HTTPClientSendRequest(a0, a1, 0, 0, 0, 5, 0);\n    if ((unsigned int)v10)\n      putchar(10);\n  } else {\n    v12 = 18;\n    for (v13 = &v2; v12; v13 += v14 * 8) {\n      v12 -= 1;\n      *((long long *)v13) = 0;\n    }\n    *((int128_t *)&v0) = 0;\n    *((int128_t *)&v1) = 0;\n    v16 = &a2->field_c04;\n    if (stat(v16, &v2))\n      putchar(10);\n    HTTPWrapperItoa(&v0, *((int *)&v3));\n    v10 = HTTPClientAddRequestHeaders(v9, \"Content-Length\", &v0);\n    if (!(unsigned int)v10) {\n      v10 = HTTPClientSendRequest(v9, a1, 0, 0, 0, 5, 0);\n      if (!(unsigned int)v10 &&\n          (v10 = HTTPSendFile(v9, v16), !(unsigned int)v10))\n        goto LABEL_402950;\n    }\n  }\nLABEL_402950:\n  v10 = HTTPClientRecvResponse(v9, 3);\n  v15 = 0;\n  if (!(unsigned int)v10) {\n    v10 = HTTPClientGetInfo(v9, &v4);\n    if (!(unsigned int)v10) {\n      while ((unsigned int)v15 < (int)(&v4)[12]) {\n        v6 = 0x2000;\n        v10 = HTTPClientReadData(v9, &v7, 0x2000, 5, &v6);\n        v17 = v6;\n        v15 += v17;\n        (&v7)[v17] = 0;\n        printf(\"%s\", (unsigned int)&v7);\n        if ((unsigned int)v10 == 1000)\n          break;\n      }\n    }\n  }\n  putchar(10);\n  if (a2->field_800 == 1) {\n    printf(\"\\n\\nHTTP Client terminated %d (got %d bytes, status_code %d)\\n\\n\",\n           (unsigned int)v10, (unsigned int)v15, (int)v4);\n    return v10;\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8tswz3kn/handle_http_request.c:71:3: error: redefinition of 'stat' as\ndifferent kind of symbol 71 | } stat; |   ^\n/tmp/tmp8tswz3kn/handle_http_request.c:23:6: note: previous definition is here\n   23 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmp8tswz3kn/handle_http_request.c:94:18: error: expected expression\n   94 |     *((int128_t *)&v4) = 0;\n      |                  ^\n/tmp/tmp8tswz3kn/handle_http_request.c:135:22: error: expected expression\n  135 |         *((int128_t *)&v0) = 0;\n      |                      ^\n/tmp/tmp8tswz3kn/handle_http_request.c:136:22: error: expected expression\n  136 |         *((int128_t *)&v1) = 0;\n      |                      ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrInsensitiveCompare(unsigned long a0, char *a1,\n                                    unsigned long a2) {\n  unsigned int v1;  // ebx\n  unsigned long v3; // rdx, Other Possible Types: char\n  unsigned long v4; // al, Other Possible Types: char\n  unsigned long v5; // rcx\n\n  v1 = a2;\n  if (!(unsigned int)a2)\n    v1 = strlen(a0);\n  if (v1 != (unsigned int)strlen(a1))\n    return 0;\n  v5 = 0;\n  while (true) {\n    v3 = *((char *)(a0 + v5));\n    v4 = a1[v5];\n    if (v3 - 64 < 27)\n      v3 = (char)v3 + 32;\n    if (v4 - 64 < 27)\n      v4 = (char)v4 + 32;\n    if ((char)v3 != (char)v4)\n      return 0;\n    *((char *)&v4) = (unsigned int)v5 + 1 == v1;\n    v5 += 1;\n    if ((v1 & (char)v4))\n      return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrExtract_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char *v1;              // rdi\n  unsigned long long v2; // rax\n\n  if (!a0) {\n    return 0;\n  } else if (!(char)a2) {\n    v1 = &a0[a1];\n    v2 = *(v1);\n    *(v1) = 0;\n    return v2;\n  } else {\n    a0[a1] = a2;\n    return a2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_toupper_loc)();\nchar *(__ctype_tolower_loc)();\n\nlong long HTTPStrCaseStr_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  char *v2;              // rbx, Other Possible Types: unsigned long\n  unsigned long v3;      // rbx\n  unsigned int *v4;      // rbp\n  unsigned int v5;       // r15d\n  unsigned long long v6; // rbp\n\n  if (!(unsigned int)a1)\n    return 0;\n  v2 = a0;\n  v4 = *(a2);\n  v5 = *((int *)(*((long long *)&__ctype_toupper_loc()) + v4 * 4));\n  v0 = *((int *)(*((long long *)&__ctype_tolower_loc()) + v4 * 4));\n  while (true) {\n    v6 = strchr(v2, v5);\n    v3 = strchr(v2, v0);\n    if (v6) {\n      if (!v3 || v3 >= v6)\n        v3 = v6;\n    } else {\n      if (!v3)\n        return v3;\n    }\n    if (!strncasecmp(v3, a2, strlen(a2)))\n      return v3;\n    v2 = v3 + 1;\n    if ((unsigned int)a1 == 1)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphwxn22_4/HTTPStrCaseStr_name_conflict.c:32:35: error: cannot take the address of an\nrvalue of type 'char *' 32 |     v5 = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + v4 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphwxn22_4/HTTPStrCaseStr_name_conflict.c:32:64: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |     v5 = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + v4 * 4)); | ~~ ^ ~\n/tmp/tmphwxn22_4/HTTPStrCaseStr_name_conflict.c:33:35: error: cannot take the address of an\nrvalue of type 'char *' 33 |     v0 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + v4 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphwxn22_4/HTTPStrCaseStr_name_conflict.c:33:64: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 33 |     v0 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + v4 * 4)); | ~~ ^ ~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long HTTPStrGetToken(char *a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long long v0; // [bp-0x138]\n  char *v3;              // rbp\n  unsigned int *v4;      // r12\n  struct_0 *v5;          // rax\n  unsigned long v6;      // edi, Other Possible Types: unsigned int\n  void *v7;              // rdx, Other Possible Types: unsigned long\n  unsigned long v8;      // rcx, Other Possible Types: char\n  unsigned long v10;     // rax\n  unsigned long v11;     // rdx, Other Possible Types: unsigned long long\n\n  v3 = a2;\n  v4 = a3;\n  v5 = strchr(a0, 58);\n  v8 = v5->field_1;\n  if (v8 > 13) {\n    v7 = 0;\n    v6 = 0;\n  } else {\n    v7 = (int)(9217 >> (v8 & 63)) & 1;\n    if (!(unsigned int)v7) {\n      v6 = 0;\n    } else {\n      v6 = 0;\n    LABEL_4070a9:\n      *(v4) = v6;\n      v10 = v5->field_1;\n      if ((char)v10 > 13) {\n        v11 = 0;\n      } else {\n        v11 = 0;\n        v0 = 9217;\n        if (((char)(*((char *)&v0 + ((v10 & 63) >> 3)) >>\n                    (char)(v10 & 63 & 7)) &\n             1)) {\n          *(v3) = 0;\n          return v3;\n        }\n      }\n      do {\n        do {\n          if ((char)v10 != 32) {\n            v3[v11] = v10;\n            v11 += 1;\n          }\n        } while (\n            (v0 = (unsigned long long)9217,\n             !((char)((unsigned long long)(char)*(\n                          (char *)((char *)&v0 +\n                                   ((unsigned long long)(v5->field_1 & 63) >>\n                                    3))) >>\n                      (unsigned long long)(v5->field_1 & 63 & 7)) &\n               1)));\n      } while ((v0 = (unsigned long long)9217,\n                !((char)((unsigned long long)(char)*(\n                             (char *)((char *)&v0 +\n                                      ((unsigned long long)(v5->field_1 & 63) >>\n                                       3))) >>\n                         (unsigned long long)(v5->field_1 & 63 & 7)) &\n                  1)));\n      v3[v11] = 0;\n      return v3;\n    }\n  }\n  while (true) {\n    v6 += (char)v8 != 32;\n    if ((unsigned int)a1 && (unsigned int)a1 < (unsigned int)v7)\n      break;\n    v8 = (&v5[1].padding_0)[v7];\n    if ((char)v8 <= 13) {\n      v7 += 1;\n      v0 = 9217;\n      if (((char)(*((char *)&v0 + ((v8 & 63) >> 3)) >> (char)(v8 & 63 & 7)) &\n           1))\n        break;\n    } else {\n      v7 += 1;\n    }\n  }\n  if (*(v4) < (unsigned int)v6) {\n    *(v4) = v6;\n    return 0;\n  }\n  goto LABEL_4070a9;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9z__ytsg/HTTPStrGetToken.c:90:32: error: array subscript is not an\ninteger 90 |         v8 = (&v5[1].padding_0)[v7]; | ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_toupper_loc)();\n\nlong long HTTPStrHToL_name_conflict(unsigned long a0) {\n  unsigned int v0;        // [bp-0x3c]\n  unsigned long long *v2; // r15\n  void *v3;               // r14, Other Possible Types: unsigned long\n  char *v4;               // rbx\n  unsigned int *v5;       // r12\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // r14\n  unsigned long v8;       // rax, Other Possible Types: unsigned long long\n  char *v9;               // rbp, Other Possible Types: unsigned long\n\n  v2 = __ctype_b_loc();\n  v3 = 0;\n  v0 = 0;\n  v9 = 0;\n  while (true) {\n    v4 = v9 + a0;\n    v5 = *(v4);\n    if ((*((char *)(*(v2) + (v5 << 1))) & 8)) {\n      v6 = *((int *)(*((long long *)&__ctype_toupper_loc()) + v5 * 4));\n      *(v4) = v6;\n      if ((char)v6 == 88) {\n        v3 = 0;\n        v0 = 0;\n      } else {\n        v8 = (!(*((char *)(*(v2) + ((char)v6 << 1) + 1)) & 4)\n                  ? (unsigned int)v6 - 55\n                  : (unsigned int)v6 - 48);\n        v7 = v3 * 16;\n        if (15 < (unsigned int)v8)\n          v8 = 15;\n        v3 = v7 + v8;\n        v0 = v0 - -1 - ((unsigned int)v3 < 1);\n        if (v0 == 8)\n          return v3;\n      }\n    }\n    v9 = (unsigned int)v9 + 1;\n    if (!*((char *)(a0 + v9)))\n      return v3;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdechz3ub/HTTPStrHToL_name_conflict.c:38:37: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 38 |         if ((*((char *)(*(v2) + (v5\n<< 1))) & 8)) |                                  ~~ ^  ~\n/tmp/tmpdechz3ub/HTTPStrHToL_name_conflict.c:40:43: error: cannot take the address of an\nrvalue of type 'char *' 40 |             v6 = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + v5 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdechz3ub/HTTPStrHToL_name_conflict.c:40:72: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 40 |             v6 = *((int *)(*((long\nlong *)&__ctype_toupper_loc()) + v5 * 4)); | ~~ ^ ~\n/tmp/tmpdechz3ub/HTTPStrHToL_name_conflict.c:50:25: error: invalid operands to binary\nexpression ('void *' and 'int') 50 |                 v7 = v3 * 16; | ~~ ^ ~~ 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPStrLToH_name_conflict(char a0[2], unsigned long a1) {\n  char v1[2];            // rax, Other Possible Types: unsigned long\n  unsigned long v2;      // rcx, Other Possible Types: unsigned long long\n  unsigned long long v3; // r9\n\n  v1 = a0;\n  if (!(unsigned int)a1) {\n    a0[0] = 48;\n    a0[1] = 0;\n    return a0;\n  }\n  v2 = 28;\n  if (!(unsigned int)(a1 >> 28)) {\n    do {\n      v2 = (unsigned int)v2 - 4;\n    } while (!(unsigned int)(a1 >> ((char)v2 & 31)));\n    if ((unsigned int)v2 < 0) {\n      a0[0] = 0;\n      return a0;\n    }\n  }\n  v3 = v2;\n  do {\n    *((char *)a0) =\n        *((char *)(4228321 + ((unsigned int)(a1 >> ((char)v2 & 31)) & 15)));\n    v2 = (unsigned int)v2 - 4;\n    a0 += 1;\n  } while ((unsigned int)v2 != -0x4);\n  v1 = &v1[1 + (v3 >> 2)];\n  *((char *)v1) = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpihp26iro/HTTPStrLToH_name_conflict.c:23:8: error: array type 'char[2]' is not\nassignable 23 |     v1 = a0; |     ~~ ^ /tmp/tmpihp26iro/HTTPStrLToH_name_conflict.c:50:8:\nerror: array type 'char[2]' is not assignable 50 |     v1 = &v1[1 + (v3 >> 2)];\n      |     ~~ ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperIsAscii_name_conflict(unsigned long a0) {\n  return (unsigned int)a0 <= 127;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperToUpper_name_conflict(unsigned long a0) {\n  if (26 > (unsigned int)(a0 - 97))\n    return a0 - 32;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperToLower_name_conflict(unsigned long a0) {\n  if (26 > (unsigned int)(a0 - 65))\n    return a0 + 32;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperIsAlpha_name_conflict(unsigned long a0) {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if ((unsigned int)a0 <= 127)\n    v1 = (((unsigned int)a0 & -33) - 65 < 26 ? 0 : a0);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperIsAlpha)(long long);\n\nlong long HTTPWrapperIsAlNum_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x8]\n  unsigned long v2; // rbx\n\n  if ((unsigned int)a0 > 127)\n    return 0;\n  v0 = v2;\n  if ((int)HTTPWrapperIsAlpha(a0) <= 0)\n    return ((unsigned int)(a0 - 48) < 10 ? 0 : a0);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperItoa_name_conflict(char *a0, unsigned long long a1) {\n  int tmp_54;            // tmp #54\n  unsigned long long v1; // rdx, Other Possible Types: unsigned long\n  unsigned long long v4; // rax\n  unsigned long long v5; // rsi\n  unsigned long long v6; // rax\n  unsigned long long v7; // rax\n  unsigned int v8;       // ecx\n\n  if ((unsigned int)a1 < 0) {\n    v1 = -((unsigned int)a1);\n    *(a0) = 45;\n    a0 += 1;\n  } else {\n    v1 = a1;\n    if (!(unsigned int)a1)\n      goto LABEL_4073e7;\n  }\n  do {\n    a0 += 1;\n    v4 = rax * 1717986919 >> 34;\n    v5 = a1 >> 31;\n    tmp_54 = v5;\n    v6 = v4 - v5;\n    a1 = v6;\n  } while ((unsigned int)v6 != (int)tmp_54);\nLABEL_4073e7:\n  *((char *)a0) = 0;\n  if (!(unsigned int)v1)\n    return a0;\n  do {\n    a0 -= 1;\n    v7 = 3435973837 * v1 >> 35;\n    *((char *)a0) = (unsigned int)v1 - (unsigned int)v7 * 10 + 48;\n    v8 = v1;\n    v1 = v7;\n  } while (v8 > 9);\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long HTTPWrapperShutDown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperGetSocketError_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp25jr5hh5/HTTPWrapperGetSocketError_name_conflict.c:19:12: error: indirection requires\npointer operand ('int' invalid) 19 |     return *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_2 {\n  char field_0;\n} struct_2;\n\ntypedef struct struct_1 {\n  char padding_0[24];\n  struct struct_0 *field_18;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long HTTPWrapperGetHostByName_name_conflict(char *a0, unsigned int *a1) {\n  struct_1 *v0;           // [bp-0x80]\n  int v1;                 // [bp-0x78]\n  unsigned int v2;        // [bp-0x74]\n  unsigned int v3;        // [bp-0x70]\n  int v4;                 // [bp-0x68]\n  int v5;                 // [bp-0x58]\n  char v6;                // [bp-0x3c]\n  char *v8;               // r12\n  unsigned long long v9;  // rax\n  unsigned long long v11; // rbx\n  struct_2 *v12;          // rax, Other Possible Types: unsigned long, void*\n  unsigned int v13;       // r14d\n  unsigned long v14;      // rbp\n  unsigned long v15;      // rbx\n  struct_1 *v16;          // rdi\n\n  v8 = a0;\n  (unsigned int)v9 = strlen(a0);\n  if ((unsigned int)v9 >= 0) {\n    v14 = 0;\n    v13 = 0;\n    v12 = 0;\n    while (true) {\n      v11 = v8[v14];\n      if (v11 - 48 > 9 && (char)v11 != 46) {\n      LABEL_4074bc:\n        if (!(char)v11) {\n          if (v13 == 3) {\n            if (strtol(&v6, NULL, 10) <= 0x100) {\n              *(a1) = inet_addr(v8);\n              return 0;\n            }\n            return 4294967295;\n          }\n          break;\n        }\n      } else {\n        if ((char)v11 == 46) {\n          v13 += 1;\n          if (!(strtol(&v6, NULL, 10) <= 0x100) || !(v13 <= 3))\n            return 4294967295;\n          v12 = 0;\n        } else {\n          if ((unsigned int)v12 > 3)\n            break;\n          (&v6)[v12] = v11;\n          v12 = (unsigned int)v12 + 1;\n          (&v6)[v12] = 0;\n        }\n        v14 += 1;\n        if ((unsigned int)v9 < (unsigned int)v14)\n          goto LABEL_4074bc;\n      }\n    }\n  }\n  v0 = 0;\n  *((int128_t *)&v1) = 0;\n  *((int128_t *)&v4) = 0;\n  *((int128_t *)&v5) = 0;\n  v2 = 2;\n  v3 = 1;\n  v15 = getaddrinfo(v8, 0, &v1, &v0);\n  if (!(unsigned int)v15) {\n    v16 = v0;\n    *(a1) = v16->field_18->field_4;\n    freeaddrinfo(v16);\n    return v15;\n  }\n  fprintf(stderr @GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v15));\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:35:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 35 | extern FILE_t *stderr@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:35:22: error: expected ';' after top\nlevel declarator 35 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:56:5: error: assignment to cast is\nillegal, lvalue casts are not supported 56 |     (unsigned int)v9 = strlen(a0);\n      |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:95:26: error: array subscript is not\nan integer 95 |                     (&v6)[v12] = v11; | ^~~~\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:97:26: error: array subscript is not\nan integer 97 |                     (&v6)[v12] = 0; | ^~~~\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:106:18: error: expected expression\n  106 |     *((int128_t *)&v1) = 0;\n      |                  ^\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:107:18: error: expected expression\n  107 |     *((int128_t *)&v4) = 0;\n      |                  ^\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:108:18: error: expected expression\n  108 |     *((int128_t *)&v5) = 0;\n      |                  ^\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:119:19: error: expected ')'\n  119 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v15));\n      |                   ^\n/tmp/tmp6u79h1y6/HTTPWrapperGetHostByName_name_conflict.c:119:12: note: to match this '('\n  119 |     fprintf(stderr@GLIBC_2.2.5, \"getaddrinfo: %s\\n\", gai_strerror(v15));\n      |            ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\ndouble HTTPWrapperGetRandomeNumber_name_conflict() {\n  return (long long)((0 CONCAT rand()) * 0xf8ba000000000000000000000000000);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyxp7dzgo/HTTPWrapperGetRandomeNumber_name_conflict.c:20:27: error: expected ')'\n   20 |     return (long long)((0 CONCAT rand()) *\n0xf8ba000000000000000000000000000); |                           ^\n/tmp/tmpyxp7dzgo/HTTPWrapperGetRandomeNumber_name_conflict.c:20:24: note: to match this '('\n   20 |     return (long long)((0 CONCAT rand()) *\n0xf8ba000000000000000000000000000); |                        ^\n/tmp/tmpyxp7dzgo/HTTPWrapperGetRandomeNumber_name_conflict.c:20:44: error: integer literal is\ntoo large to be represented in any integer type 20 |     return (long long)((0\nCONCAT rand()) * 0xf8ba000000000000000000000000000); | ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long HTTPWrapperGetUpTime_name_conflict() {\n  char v0; // [bp-0x18]\n\n  clock_gettime(0x1, &v0);\n  return *((long long *)&v0);\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLConnect_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLNegotiate_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLSend_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecv_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLRecvPending_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPWrapperSSLClose_name_conflict() { return 4294967295; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long sktSetNonblocking_name_conflict(unsigned long a0, unsigned long a1) {\n  if (fcntl(a0, 3) < 0) {\n    return 4294967295;\n  } else if (fcntl(a0, 4) < 0) {\n    fcntl(a0, 4);\n    return 4294967295;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetLocalConnection_name_conflict() { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPClientSetVerb)(long long, long long);\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n  char padding_8[56];\n  unsigned short field_40;\n  char padding_42[518];\n  unsigned long long field_248;\n  unsigned int field_250;\n  char padding_254[4];\n  unsigned long long field_258;\n  char padding_260[1104];\n  unsigned int field_6b0;\n  char padding_6b4[620];\n  unsigned int field_920;\n  char padding_924[48];\n  unsigned int field_954;\n  unsigned int field_958;\n  char padding_95c[532];\n  unsigned short field_b70;\n} struct_0;\n\nlong long HTTPClientOpenRequest_name_conflict(unsigned long a0) {\n  struct_0 *v2;           // rax\n  struct_0 *v3;           // rbx\n  unsigned long v4;       // rcx, Other Possible Types: unsigned long long\n  unsigned long v5;       // d\n  struct_0 *v6;           // rdi, Other Possible Types: unsigned long\n  unsigned long long *v7; // rax\n  unsigned long v8;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v9; // rdi, Other Possible Types: unsigned long\n\n  v2 = malloc(2936);\n  if (!v2)\n    return 0;\n  v3 = v2;\n  v4 = 367;\n  for (v6 = v2; v4; v6 += v5 * 8) {\n    v4 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v7 = malloc(0x800);\n  v3->field_248 = v7;\n  if (!v7) {\n    free(v3);\n    return 0;\n  }\n  v8 = 0x100;\n  for (v9 = v7; v8; v9 += v5 * 8) {\n    v8 -= 1;\n    *((long long *)v9) = 0;\n  }\n  v3->field_250 = 0x800;\n  HTTPClientSetVerb(v3, 0);\n  v3->field_40 = 80;\n  v3->field_920 = -1;\n  v3->field_258 = v3->field_248;\n  v3->field_954 = 1;\n  v3->field_958 = a0;\n  v3->field_6b0 = 0;\n  v3->field_b70 = 80;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnSessionReset)(long long, long long);\n\nlong long HTTPClientReset_name_conflict(unsigned long long a0) {\n  if (a0)\n    return HTTPIntrnSessionReset(a0, 1);\n  return 2;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnConnectionClose)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[584];\n  unsigned long long field_248;\n} struct_0;\n\nlong long HTTPClientCloseRequest_name_conflict(struct struct_0 **a0) {\n  struct_0 *v1; // rbp\n  void *v4;     // rdi\n\n  v1 = *(a0);\n  if (!v1)\n    return 2;\n  v4 = v1->field_248;\n  if (v4)\n    free(v4);\n  HTTPIntrnConnectionClose(v1);\n  free(v1);\n  *(a0) = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1724];\n  unsigned int field_6bc;\n} struct_0;\n\nlong long HTTPClientSetConnection_name_conflict(struct_0 *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 2;\n  if (a0) {\n    a0->field_6bc = a1;\n    v1 = 0;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientSetVerb_name_conflict(unsigned int a0[421], unsigned long a1) {\n  if (!a0)\n    return 2;\n  a0[162] = a1;\n  if ((unsigned int)a1 == 2) {\n    strcpy(&a0[420], \"POST\");\n    return 0;\n  } else if ((unsigned int)a1 == 3) {\n    a0[420] = 5526864;\n    return 0;\n  } else if (!(unsigned int)a1) {\n    a0[420] = 5522759;\n    return a1;\n  } else {\n    return 18;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[1872];\n  unsigned short field_750;\n  char padding_752[18];\n  unsigned int field_764;\n  char padding_768[496];\n  unsigned int field_958;\n} struct_0;\n\nlong long HTTPClientSetProxy(struct_0 *a0, char *a1, unsigned long a2, char *a3,\n                             char *a4) {\n  unsigned long v0; // [bp-0x20]\n  unsigned long v1; // [bp-0x18]\n  unsigned long v2; // [bp-0x10]\n  unsigned long v3; // [bp-0x8]\n  unsigned long v5; // r13\n  unsigned long v6; // r12\n  unsigned long v7; // rbx\n\n  if (!a0)\n    return 2;\n  v3 = v5;\n  v2 = v6;\n  *((int *)&v1) = rbp;\n  v0 = v7;\n  strncpy(&a0->padding_0[1776], a1, 64);\n  if (a3) {\n    strncpy(&a0->padding_0[1840], a3, 16);\n    if (a4) {\n      strncpy(&a0->padding_0[1856], a4, 16);\n      a0->field_750 = a2;\n      a0->field_958 = a0->field_958 | 128;\n      a0->field_764 = 1;\n      return 0;\n    }\n  } else if (a4) {\n    strncpy(&a0->padding_0[1856], a4, 16);\n    a0->field_750 = a2;\n    a0->field_958 = a0->field_958 | 128;\n    return 0;\n  }\n  a0->field_750 = a2;\n  a0->field_958 = a0->field_958 | 128;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1732];\n  unsigned int field_6c4;\n} struct_0;\n\nlong long HTTPClientSetCredentials_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  unsigned long v0; // [bp-0x18]\n  unsigned long v1; // [bp-0x10]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v4; // r12\n  unsigned long v5; // rbx\n  unsigned int v6;  // edx\n  unsigned long v7; // rax, Other Possible Types: unsigned long long\n  unsigned int v8;  // edx\n\n  if (!a0)\n    return 2;\n  v2 = v4;\n  *((int *)&v1) = rbp;\n  v0 = v5;\n  v6 = strlen(a1);\n  v7 = 19;\n  if (v6 > 16)\n    return v7;\n  v8 = strlen(*((unsigned long long *)&v6));\n  v7 = 19;\n  if (v8 <= 16) {\n    strcpy(&a0[1].padding_0[160], a1);\n    strcpy(&a0[1].padding_0[176], *((unsigned long long *)&v6));\n    a0->field_6c4 = 1;\n    v7 = 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersAdd)(long long, long long, long long, long long,\n                               long long);\n\nlong long HTTPClientAddRequestHeaders(unsigned long long a0, char *a1,\n                                      char *a2) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned long v1;       // [bp-0x18]\n  unsigned long v2;       // [bp-0x10]\n  unsigned long v3;       // [bp-0x8]\n  unsigned long v5;       // r13\n  unsigned long v6;       // r12\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rbx\n  unsigned long long v9;  // r12\n  unsigned long long v10; // r13\n\n  if (a0) {\n    v3 = v5;\n    v2 = v6;\n    *((int *)&v1) = rbp;\n    v0 = v7;\n    v8 = v0;\n    v9 = v2;\n    v10 = v3;\n    return HTTPIntrnHeadersAdd(a0, a1, strlen(a1), a2, strlen(a2));\n  }\n  return 2;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersReceive)(long long, long long);\n\nlong long HTTPClientRecvResponse_name_conflict(unsigned long long a0, unsigned long long a1) {\n  if (a0)\n    return HTTPIntrnHeadersReceive(a0, a1);\n  return 2;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTTPClientGetInfo_name_conflict(unsigned int a0[598], unsigned int a1[5]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 2;\n  if (a0) {\n    *((int128_t *)&a1[0]) = 0;\n    a1[4] = 0;\n    a1[0] = a0[428];\n    a1[1] = a0[595];\n    a1[2] = a0[589];\n    a1[3] = a0[429];\n    a1[4] = a0[597];\n    v1 = 0;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvpqfnyok/HTTPClientGetInfo_name_conflict.c:25:22: error: expected expression\n   25 |         *((int128_t *)&a1[0]) = 0;\n      |                      ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientFindFirstHeader_name_conflict(struct_0 *a0, char *a1) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v1; // [bp-0x8]\n  unsigned long v3; // rbx\n\n  if (!a0)\n    return 2;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  if ((unsigned int)strlen(a1) <= 1023) {\n    strcpy(&a0[1].padding_0[12], a1);\n    a0->field_280 = 0;\n    a0->field_278 = 0;\n    return 0;\n  }\n  return 13;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[632];\n  unsigned long long field_278;\n  unsigned int field_280;\n  char padding_284[12];\n  char field_290;\n} struct_0;\n\nlong long HTTPClientFindCloseHeader_name_conflict(struct_0 *a0) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 2;\n  if (a0) {\n    a0->field_290 = 0;\n    a0->field_280 = 0;\n    a0->field_278 = 0;\n    v1 = 0;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPIntrnHeadersFind)(long long, long long, long long, long long,\n                                long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[616];\n  unsigned int field_268;\n  char padding_26c[12];\n  unsigned long long field_278;\n  unsigned int field_280;\n} struct_0;\n\nlong long HTTPClientGetNextHeader_name_conflict(struct_0 *a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x54]\n  unsigned long v1;      // [bp-0x50]\n  char v2;               // [bp-0x48]\n  char v3;               // [bp-0x40]\n  unsigned long v5;      // rbp\n  char *v6;              // r15\n  unsigned long v7;      // r8, Other Possible Types: unsigned long long\n  unsigned long long v8; // r13\n  char *v9;              // r14\n  char *v10;             // rsi, Other Possible Types: unsigned long\n  unsigned long\n      v11; // rax, Other Possible Types: unsigned long long, unsigned int\n\n  if (!a0)\n    return 2;\n  v6 = a1;\n  v7 = a0->field_280;\n  if ((unsigned int)v7)\n    v7 = (unsigned int)a0->field_278 - a0->field_268;\n  v11 = HTTPIntrnHeadersFind(a0, &a0[1].padding_0[12], &v2, 1, v7);\n  v5 = v11;\n  if ((unsigned int)v11)\n    return v11;\n  v8 = *((int *)&v3);\n  if (*(a2) < (unsigned int)v8) {\n    *(a2) = v8;\n    *(a1) = 0;\n    return 3;\n  }\n  v9 = *((long long *)&v2);\n  v10 = v9;\n  if (*(v9) == 13) {\n    v10 = v9 + 1;\n    v11 = 1;\n  }\n  if (*((char *)v10) == 10) {\n    v11 = (unsigned int)v11 + 1;\n    v10 += 1;\n  }\n  v0 = (unsigned int)v8 - (unsigned int)v11;\n  v1 = v0;\n  strncpy(v6, v10, v0);\n  v6[v1] = 0;\n  *(a2) = v0;\n  a0->field_278 = &v9[v8];\n  a0->field_280 = a0->field_280 + 1;\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(HTTPWrapperGetUpTime)();\n\nlong long HTTPIntrnSessionGetUpTime_name_conflict() { return HTTPWrapperGetUpTime(); }\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char base64val;\n\nlong long HTTPBase64Decoder_name_conflict(char a0[3], char a1[2]) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned long v1;       // [bp-0x18]\n  unsigned long v2;       // [bp-0x10]\n  unsigned long v3;       // [bp-0x8]\n  char v5[1];             // rdx, Other Possible Types: unsigned long\n  char *v6;               // rax\n  unsigned long v7;       // rax\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  unsigned long v10;      // r13\n  unsigned long v11;      // r12\n  unsigned long v12;      // rbx\n  unsigned long v13;      // r12\n  char *v14;              // rbp, Other Possible Types: unsigned long, char\n  char *v15;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v16; // r8\n  char v17;               // r8b\n  char v18;               // al\n  char v19;               // al\n  char v20[1];            // rcx, Other Possible Types: unsigned long\n  unsigned long v21;      // rax\n  unsigned long v22;      // r8, Other Possible Types: unsigned long long\n  unsigned long v23;      // rax\n  unsigned long long v24; // r9, Other Possible Types: unsigned long\n\n  if (a1[0] == 43) {\n    if (a1[1] == 32) {\n      a1 += 1;\n    } else {\n    LABEL_405e07:\n      v5 = a1 + 4;\n      v20 = v5;\n      v6 = (unsigned long long)v5[4];\n      if ((char)v6 < 0)\n        return 4294967295;\n      v22 = *((char *)(&base64val + v6));\n      if ((char)v22 == 255)\n        return 4294967295;\n      v7 = (unsigned long long)v5[3];\n      if ((char)v7 < 0)\n        return 4294967295;\n      v9 = (&base64val)[v7];\n      if ((char)v9 == 255)\n        return 4294967295;\n      v3 = v10;\n      v2 = v11;\n      *((int *)&v1) = rbp;\n      v0 = v12;\n      while ((char)v13 != 61) {\n        v13 = *((char *)(v20 - 2));\n        if ((char)v13 < 0)\n          return 4294967295;\n        if ((&base64val)[(char)v13] == 255)\n          return 4294967295;\n        v14 = *((char *)(v20 - 1));\n        v15 = v14;\n        if ((char)v14 == 61) {\n          *((char *)a0) = (unsigned int)v22 * 4 | (unsigned int)(v9 >> 4);\n          v14 = 61;\n          goto LABEL_405eed;\n        }\n        if ((char)v14 < 0)\n          return 4294967295;\n        if ((&base64val)[(char)v15] == 255)\n          return 4294967295;\n        *((char *)a0) = (unsigned int)v22 * 4 | (unsigned int)(v9 >> 4);\n        if ((char)v13 == 61) {\n          a0 += 1;\n          v24 = 1;\n          goto LABEL_405f2d;\n        }\n        if ((char)v13 >= 0) {\n        LABEL_405eed:\n          v16 = (&base64val)[v13];\n          *((char *)(a0 + 1)) =\n              (unsigned int)v9 * 16 | (unsigned int)(v16 >> 2);\n          if ((char)v15 == 61)\n            return 2;\n          v17 = (unsigned int)v16 * 64;\n          goto LABEL_405f0f;\n        } else {\n          *((char *)(a0 + 1)) = 255;\n          if ((char)v15 == 61)\n            return 2;\n          v17 = 192;\n        LABEL_405f0f:\n          v18 = 255;\n          if ((char)v14 >= 0)\n            v18 = (&base64val)[(char)v15];\n          *((char *)(a0 + 2)) = v17 | v18;\n          v24 = 3;\n          a0 += 3;\n        LABEL_405f2d:\n          v19 = *((char *)v20);\n          v5 += 4;\n          if (!(v19 != 13 & v19)) {\n            return v24;\n          } else if ((char)v15 == 61) {\n            return v24;\n          } else {\n            v20 = v5;\n            v21 = (unsigned long long)v5[4];\n            if ((char)v21 < 0)\n              return 4294967295;\n            v22 = (&base64val)[v21];\n            if ((char)v22 == 255)\n              return 4294967295;\n            v23 = (unsigned long long)v5[3];\n            if ((char)v23 < 0)\n              return 4294967295;\n            v9 = (&base64val)[v23];\n            if ((char)v9 == 255)\n              return 4294967295;\n          }\n        }\n      }\n      v14 = *((char *)(v20 - 1));\n      v15 = v14;\n      if ((char)v14 == 61) {\n        *((char *)a0) = (unsigned int)v22 * 4 | (unsigned int)(v9 >> 4);\n        return 1;\n      }\n    }\n  }\n  if (*((char *)a1) == 13)\n    return 0;\n  goto LABEL_405e07;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp37wrhalu/HTTPBase64Decoder_name_conflict.c:55:16: error: array type 'char[1]' is not\nassignable 55 |             v5 = a1 + 4; |             ~~ ^\n/tmp/tmp37wrhalu/HTTPBase64Decoder_name_conflict.c:56:17: error: array type 'char[1]' is not\nassignable 56 |             v20 = v5; |             ~~~ ^\n/tmp/tmp37wrhalu/HTTPBase64Decoder_name_conflict.c:60:41: error: invalid operands to binary\nexpression ('char *' and 'char *') 60 |             v22 = *((char *)(&base64val\n+ v6)); |                              ~~~~~~~~~~ ^ ~~\n/tmp/tmp37wrhalu/HTTPBase64Decoder_name_conflict.c:124:24: error: invalid operands to binary\nexpression ('char[1]' and 'int') 124 |                     v5 += 4; | ~~ ^  ~\n/tmp/tmp37wrhalu/HTTPBase64Decoder_name_conflict.c:135:29: error: array type 'char[1]' is not\nassignable 135 |                         v20 = v5; |                         ~~~\n^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":0,"function":"static u8 gf_mult(u8 x, u8 y) {\n    u8 result = 0;\n    while (x != 0)\n        {\n            result ^= x & 1 ? y : 0;\n            x >>= 1;\n            y = ((y) & 128 ? ((y) << 1) ^ 27 : ((y) << 1));\n        }\n    return result;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"static u64 F(u64 x) {\n    u8 *temp = (u8 *)&x;\n    u8 a[8] = {};\n    int i, j;\n    for (i = 0; i < 8; i++)\n        temp[i] = sbox[temp[i]];\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            a[i] ^= gf_mult(temp[j], mds_matrix[i][j]);\n        }\n    }\n    x = *((u64 *)a);\n    return x;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern char Rc;\nextern struct_0 mds_matrix;\nextern char sbox;\n\nlong long F_name_conflict(unsigned long a0) {\n  unsigned long long v0;  // [bp-0x18]\n  char v1;                // [bp-0x10]\n  void *v2;               // [bp-0x8], Other Possible Types: char, unsigned long\n  struct_0 *v4;           // rax, Other Possible Types: unsigned long\n  struct_0 *v5;           // r9\n  unsigned long v6;       // r10\n  unsigned long long v7;  // rdx\n  unsigned int v8;        // ecx\n  unsigned long v9;       // rsi, Other Possible Types: char, unsigned int\n  unsigned long v10;      // rax, Other Possible Types: unsigned long long\n  unsigned long v11;      // r8\n  unsigned long long v12; // r9\n\n  v0 = a0;\n  v2 = 0;\n  v4 = &v0;\n  do {\n    *((char *)v4) = (&sbox)[*((char *)v4)];\n    v4 = &v0;\n  } while (v4 != &v1);\n  v5 = &v2;\n  v6 = &mds_matrix.field_0;\n  do {\n    v11 = 0;\n    do {\n      v10 = *((char *)(v6 + v11));\n      v7 = *((char *)&v0 + v11);\n      if (!(char)v7) {\n        v9 = v7;\n      } else {\n        v9 = 0;\n        do {\n          v8 = (unsigned int)v7 & 1;\n          if (((char)v7 & 1))\n            v8 = v10;\n        } while ((v2 = (char)v2 ^ (char)v9, v11 += 1, v11 != 8));\n      }\n    } while ((v2 = (char)v2 ^ (char)v9, v11 += 1, v11 != 8));\n    v12 = &v2;\n  } while (v6 + 8 != 4202656);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":1,"function":"static u8 char_val(char c) {\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    printf(\"Illegal character \\\"%c\\\"\\n\", c);\n    exit(1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long char_val_name_conflict(unsigned long a0) {\n  if ((char)(a0 - 48) <= 9) {\n    return a0 - 48;\n  } else if (a0 - 97 <= 5) {\n    return a0 - 87;\n  } else if (a0 - 65 <= 5) {\n    return a0 - 55;\n  } else {\n    printf(\"Illegal character \\\"%c\\\"\\n\", (char)a0);\n    exit(1); /* do not return */\n  }\n}\n","pass":1,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"char *build_chunked_response(int content_length, int *response_len) {\n    char *response_buffer;\n    char *content_buffer;\n    int buffer_length;\n    int i, n;\n    buffer_length = 256 + content_length + (content_length >> 4);\n    response_buffer = malloc(buffer_length);\n    *response_len = snprintf(response_buffer, buffer_length, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    content_buffer = malloc(content_length);\n    build_content(content_buffer, content_length);\n    i = 0;\n    while (i < content_length)\n        {\n            n = (rand() % 199) + 1;\n            if (i + n > content_length) {\n                n = content_length - i;\n            }\n            *response_len += snprintf(response_buffer + *response_len, buffer_length - *response_len, \"%x\\r\\n\", n);\n            memcpy(response_buffer + *response_len, content_buffer + i, n);\n            *response_len += n;\n            i += n;\n            response_buffer[(*response_len)++] = '\\r';\n            response_buffer[(*response_len)++] = '\\n';\n        }\n    memcpy(response_buffer + *response_len, \"0\\r\\n\\r\\n\", 5);\n    *response_len += 5;\n    free(content_buffer);\n    printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", *response_len, buffer_length, content_length);\n    return response_buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(build_content)(long long, long long);\nint(rand)();\n\nlong long build_chunked_response_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned int v0;        // [bp-0x44]\n  void *v1;               // [bp-0x40]\n  unsigned long long v3;  // r14\n  unsigned int *v4;       // r15\n  char *v5;               // r13\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rax\n  unsigned int v8;        // ecx\n  unsigned int v10;       // rbx\n  unsigned long long v11; // rdi\n  unsigned long long v15; // rax\n  unsigned long v16;      // rbp\n  void *v17;              // r12, Other Possible Types: unsigned long\n  unsigned long long v19; // rbx\n  unsigned int v20;       // ebx\n\n  v3 = a0;\n  v4 = a1;\n  v0 = a0 + (a0 >> 4) + 0x100;\n  v5 = malloc(v0);\n  *(a1) = snprintf(v5, v0,\n                   \"HTTP/1.1 200 OK\\r\\nContent-Type: \"\n                   \"text/plain\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n  v1 = malloc(a0);\n  build_content(v1, a0);\n  if ((unsigned int)a0 <= 0) {\n    v19 = *(v4);\n    strncpy(&v5[v19], \"0\\r\\n\\r\\n\", 5);\n    v20 = (unsigned int)v19 + 5;\n    *(v4) = v20;\n    free(v1);\n    printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", v20, v0,\n           (unsigned int)v3);\n    return v5;\n  }\n  v17 = 0;\n  do {\n    (unsigned int)v6 = rand();\n    v7 = v6 - (unsigned int)((v6 * 1381296015 >> 38) - (v6 >> 31)) * 199;\n    v8 = v17 + v7 + 1;\n    v10 = (v8 <= (unsigned int)v3 ? v3 - v17 : (unsigned int)v7 + 1);\n    v11 = *(v4);\n    v15 = snprintf(&v5[v11], v0 - v11, \"%x\\r\\n\", v10) + *(v4);\n    memcpy(&v5[v15], v17 + v1, v10);\n    v16 = v15 + v10;\n    v17 += v10;\n    v5[v16] = 13;\n    *(v4) = (unsigned int)v16 + 2;\n    v5[1 + v16] = 10;\n  } while ((unsigned int)v3 > (unsigned int)v17);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpefq76v9v/build_chunked_response_name_conflict.c:16:6: error: conflicting types for\n'snprintf' 16 | int (snprintf)(char *, unsigned long, char *, ...); |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpefq76v9v/build_chunked_response_name_conflict.c:58:9: error: assignment to cast is\nillegal, lvalue casts are not supported 58 |         (unsigned int)v6 = rand();\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpefq76v9v/build_chunked_response_name_conflict.c:61:44: error: invalid operands to\nbinary expression ('unsigned long long' and 'void *') 61 |         v10 = (v8 <=\n(unsigned int)v3 ? v3 - v17 : (unsigned int)v7 + 1); | ~~ ^ ~~~\n/tmp/tmpefq76v9v/build_chunked_response_name_conflict.c:64:30: error: invalid operands to\nbinary expression ('void *' and 'void *') 64 |         memcpy(&v5[v15], v17 +\nv1, v10); |                          ~~~ ^ ~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mdilai_jweegad/external/miniupnpc/minihttptestserver.c"}
{"compilable":0,"function":"unsigned long long fatorial(unsigned int valor) {\n    unsigned long long i, fatorial = 1;\n    for (i = 1; i <= valor; i++) {\n        fatorial *= i;\n    }\n    return fatorial;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fatorial_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  if (!(unsigned int)a0)\n    return 1;\n  v1 = 1;\n  v2 = 1;\n  do {\n    v1 = v2 * v1;\n    v2 += 1;\n  } while (a0 >= v2);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_29-05/ex1.c"}
{"compilable":1,"function":"bool comparar(int *v1, int *v2) {\n    if (*v1 > *v2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long comparar_name_conflict(unsigned int *a0, unsigned int *a1) {\n  unsigned long long v1; // rax\n\n  v1 = *(a1);\n  *((char *)&v1) = (unsigned int)v1 < *(a0);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_31-05/bouble_sort.c"}
{"compilable":0,"function":"char *init_palavra(char *texto_palavra) {\n    char *palavra = (char *)malloc(sizeof(char) * (strlen(texto_palavra) + 1));\n    strcpy(palavra, texto_palavra);\n    return palavra;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_palavra_name_conflict(char *a0) { return strcpy(malloc(strlen(a0) + 1), a0); }\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"char *init_mascara(unsigned int tamanho_palavra) {\n    unsigned int i;\n    char *mascara = (char *)malloc(sizeof(char) * (tamanho_palavra + 1));\n    for (i = 0; i < tamanho_palavra; i++) {\n        mascara[i] = '_';\n    }\n    mascara[i] = '\\x00';\n    return mascara;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_mascara_name_conflict(char *a0) {\n  unsigned long v1; // rax\n  char *v2;         // rdx, Other Possible Types: unsigned long\n\n  v1 = malloc(a0 + 1);\n  if ((unsigned int)a0) {\n    v2 = v1;\n    do {\n      *((char *)v2) = 95;\n      v2 += 1;\n    } while (v2 != &a0[v1]);\n  }\n  a0[v1] = 0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"bool existe_letra_na_palavra(char letra, char *palavra) {\n    unsigned int i;\n    for (i = 0; i < strlen(palavra); i++) {\n        if (letra == palavra[i]) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long existe_letra_na_palavra_name_conflict(unsigned long a0, char *a1) {\n  unsigned long v2; // rcx\n\n  for (v2 = 0; v2 < strlen(a1); v2 = (unsigned int)v2 + 1) {\n    if (a1[v2] == (char)a0)\n      return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"bool eh_palindromo(int *vetor, int tamanho) {\n    int i = 0;\n    for (i = 0; i < tamanho / 2; i++) {\n        if (vetor[i] != vetor[tamanho - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_ - 4;\n} struct_0;\n\nlong long eh_palindromo_name_conflict(unsigned int *a0, unsigned long a1) {\n  struct_0 *v1; // rdx, Other Possible Types: unsigned long\n  void *v2;     // rax, Other Possible Types: unsigned long\n\n  if ((unsigned int)a1 <= 1)\n    return 1;\n  v1 = &a0[a1];\n  v2 = 0;\n  while (a0[v2] == *((int *)(v1 - 4))) {\n    v2 += 1;\n    v1 -= 4;\n    if ((unsigned int)((a1 >> 31) + a1 >> 1) <= (unsigned int)v2)\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpumt6hy3t/eh_palindromo_name_conflict.c:18:24: error: expected ';' at end of\ndeclaration list 18 |     unsigned int field_-4; |                        ^ | ;\n/tmp/tmpumt6hy3t/eh_palindromo_name_conflict.c:30:14: error: array subscript is not an integer\n   30 |     while (a0[v2] == *((int *)(v1 - 4)))\n      |              ^~~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_05-06/ex1.c"}
{"compilable":0,"function":"unsigned int calcularTamanhoRegistro(const Registro registro) {\n    unsigned int tamanhoRegistro = strlen(registro.ra) + strlen(registro.nome) + strlen(registro.curso) + strlen(registro.ano);\n    tamanhoRegistro *= sizeof(char);\n    tamanhoRegistro += 5;\n    return tamanhoRegistro;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long calcularTamanhoRegistro_name_conflict() {\n  char v0; // [bp+0x8]\n  char v1; // [bp+0xd8]\n  char v2; // [bp+0x1a1]\n\n  return strlen(&v0) + strlen(&v0) + 5 + strlen(&v1) + strlen(&v2);\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"LittleEndian toLittleEndian(const unsigned short numero) {\n    unsigned short primeiroByte = (numero & 65280) >> 8;\n    unsigned short segundoByte = (numero & 255);\n    LittleEndian little;\n    little.number[0] = segundoByte;\n    little.number[1] = primeiroByte;\n    return little;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long toLittleEndian_name_conflict(unsigned long a0) {\n  void *v1; // rdx\n  char v2;  // ah\n\n  v1 = 0;\n  *((char *)&v1) = a0;\n  *((char *)&v1) = v2;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"unsigned short revertLittleEndian(const LittleEndian little) {\n    unsigned short primeiroByte = (little.number[1] & 255) << 8;\n    unsigned short segundoByte = little.number[0] & 255;\n    return primeiroByte | segundoByte;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long revertLittleEndian_name_conflict(unsigned long a0) { return a0; }\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":1,"function":"int count(char *string) {\n    int length = 0;\n    while (string[length] != '\\x00')\n        {\n            length++;\n        }\n    return length;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long count_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  unsigned long long v2; // rax\n\n  if (!*(a0))\n    return 0;\n  v1 = 1;\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (a0[1 + v1]);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/08-09/ex3.c"}
{"compilable":0,"function":"int ordenar(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    quantidadeArquivos = contarArquivos(nomeBase);\n    if (quantidadeArquivos == 0) {\n        fprintf(stderr, \"Nao existe outros arquivos a patir do arquivo base especificado!\\n\");\n        return 1;\n    }\n    return intercalar(nomeBase, quantidadeArquivos);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(contarArquivos)(long long);\nlong long(intercalar)(long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long ordenar_name_conflict(unsigned long long a0) {\n  unsigned long long v1; // rax\n\n  if (!malloc(strlen(a0 + 10))) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n    return 1;\n  }\n  v1 = contarArquivos(a0);\n  if ((unsigned int)v1)\n    return intercalar(a0, v1);\n  fwrite(\"Nao existe outros arquivos a patir do arquivo base especificado!\\n\",\n         1, 65, stderr @GLIBC_2.2.5);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5z8li989/ordenar_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5z8li989/ordenar_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp5z8li989/ordenar_name_conflict.c:27:92: error: expected ')'\n   27 |         fwrite(\"Problema com alocacao dinamica! Possivel falta de\nmemoria\\n\", 1, 58, stderr@GLIBC_2.2.5); | ^ /tmp/tmp5z8li989/ordenar_name_conflict.c:27:15:\nnote: to match this '(' 27 |         fwrite(\"Problema com alocacao dinamica!\nPossivel falta de memoria\\n\", 1, 58, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp5z8li989/ordenar_name_conflict.c:33:95: error: expected ')'\n   33 |     fwrite(\"Nao existe outros arquivos a patir do arquivo base\nespecificado!\\n\", 1, 65, stderr@GLIBC_2.2.5); | ^\n/tmp/tmp5z8li989/ordenar_name_conflict.c:33:11: note: to match this '('\n   33 |     fwrite(\"Nao existe outros arquivos a patir do arquivo base\nespecificado!\\n\", 1, 65, stderr@GLIBC_2.2.5); |           ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int contarArquivos(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < 10; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        if (existeArquivo(nomeArquivo)) {\n            quantidadeArquivos++;\n        }\n    }\n    free(nomeArquivo);\n    return quantidadeArquivos;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(existeArquivo)(long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long contarArquivos_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rax\n  void *v2;              // rbp\n  unsigned long v3;      // r12d, Other Possible Types: unsigned int\n\n  v1 = malloc(strlen(a0 + 10));\n  if (!v1) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n    return 1;\n  }\n  v2 = v1;\n  v3 = 0;\n  do {\n    sprintf(v2, \"%s%d\", (unsigned int)a0, 0);\n    v3 = (unsigned int)v3 - -1 - ((char)existeArquivo(v2) < 1);\n  } while (true);\n  free(v2);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3fe2tvtm/contarArquivos_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp3fe2tvtm/contarArquivos_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp3fe2tvtm/contarArquivos_name_conflict.c:29:92: error: expected ')'\n   29 |         fwrite(\"Problema com alocacao dinamica! Possivel falta de\nmemoria\\n\", 1, 58, stderr@GLIBC_2.2.5); | ^\n/tmp/tmp3fe2tvtm/contarArquivos_name_conflict.c:29:15: note: to match this '('\n   29 |         fwrite(\"Problema com alocacao dinamica! Possivel falta de\nmemoria\\n\", 1, 58, stderr@GLIBC_2.2.5); |               ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"_Bool existeArquivo(const char *nomeArquivo) {\n    FILE *arquivo = fopen(nomeArquivo, \"rb\");\n    _Bool result = arquivo != ((void *)0);\n    if (result) {\n        fclose(arquivo);\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long existeArquivo_name_conflict(char *a0) {\n  FILE_t *v1;       // rax\n  char v2;          // bl\n  unsigned long v3; // rbx\n\n  v1 = fopen(a0, \"rb\");\n  v2 = v1;\n  if (v1) {\n    fclose(v1);\n    return v3;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfgw7xsr0/existeArquivo_name_conflict.c:85:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 85 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int intercalar(const char *nomeBase, int quantidadeArquivos) {\n    FILE *arquivosEntrada[10];\n    FILE *arquivoSaida;\n    int buffer[10][5];\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        arquivosEntrada[i] = fopen(nomeArquivo, \"rb\");\n        if (arquivosEntrada[i] == ((void *)0)) {\n            fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeArquivo);\n            for (int j = 0; j < i; j++) {\n                fclose(arquivosEntrada[j]);\n            }\n            free(nomeArquivo);\n            return 1;\n        }\n    }\n    arquivoSaida = fopen(nomeBase, \"wb\");\n    if (arquivoSaida == ((void *)0)) {\n        fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeBase);\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            fclose(arquivosEntrada[i]);\n        }\n        free(nomeArquivo);\n        return 1;\n    }\n    while (!leuTodosOsArquivosPorCompleto(arquivosEntrada, quantidadeArquivos))\n        {\n            int lidoAtual[10] = {0};\n            for (int i = 0; i < quantidadeArquivos; i++) {\n                lidoAtual[i] = fread(buffer[i], sizeof(int), 5, arquivosEntrada[i]);\n            }\n            int indices[10] = {0};\n            int min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n            while (min != -1)\n                {\n                    fwrite(&buffer[min][indices[min]], sizeof(int), 1, arquivoSaida);\n                    indices[min]++;\n                    if (indices[min] == lidoAtual[min]) {\n                        lidoAtual[min] = fread(buffer[min], sizeof(int), 5, arquivosEntrada[min]);\n                        indices[min] = 0;\n                    }\n                    min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n                }\n        }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        fclose(arquivosEntrada[i]);\n    }\n    fclose(arquivoSaida);\n    free(nomeArquivo);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(leuTodosOsArquivosPorCompleto)(long long, long long);\nlong long(pegaMenor)(long long, long long, long long, long long);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long intercalar_name_conflict(char *a0, unsigned long long a1) {\n  FILE_t *v0;             // [bp-0x1c8], Other Possible Types: unsigned long\n  void *v1;               // [bp-0x1c0]\n  int v2;                 // [bp-0x1b8]\n  int v3;                 // [bp-0x1a8]\n  void *v4;               // [bp-0x198]\n  int v5;                 // [bp-0x188]\n  int v6;                 // [bp-0x178]\n  void *v7;               // [bp-0x168]\n  char v8;                // [bp-0x158]\n  FILE_t *v9;             // [bp-0x88]\n  char v10;               // [bp-0x80]\n  struct FILE_t **v12;    // rbx, Other Possible Types: unsigned long\n  struct_0 *v13;          // rbp\n  unsigned long long v14; // rax\n  unsigned long v16;      // rbx\n  unsigned long v17;      // rbx\n  unsigned long long v18; // r12\n  unsigned int v19;       // r12d\n  struct FILE_t **v20;    // rbp, Other Possible Types: unsigned long\n  unsigned long long v21; // rbx\n  struct FILE_t **v22;    // rbx, Other Possible Types: unsigned long\n  struct FILE_t **v23;    // rbx, Other Possible Types: unsigned long\n\n  v1 = malloc(strlen(a0 + 10));\n  if (!v1) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n    return 1;\n  }\n  v12 = 0;\n  if ((unsigned int)a1 <= 0) {\n    v0 = &fopen(a0, \"wb\")->_flags;\n    if (!v0) {\n      fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n              (unsigned int)a0);\n    LABEL_401573:\n      free(v1);\n      return 1;\n    }\n  } else {\n    do {\n      v13 = v12;\n      sprintf(v1, \"%s%d\", (unsigned int)a0, (unsigned int)v12);\n      v14 = fopen(v1, \"rb\");\n      (&v9)[v12] = v14;\n      if (!v14) {\n        fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n                (unsigned int)v1);\n        if ((unsigned int)v12 > 0) {\n          v22 = &v9;\n          do {\n            fclose(*((long long *)v22));\n            v22 = &v10;\n          } while (v22 != (char *)&v9 + 0x8 * v13);\n        }\n        free(v1);\n        return 1;\n      }\n    } while ((v12 += 1, v12 != a1));\n    v0 = fopen(a0, \"wb\");\n    if (!v0) {\n      fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n              (unsigned int)a0);\n      v20 = &v9;\n      v21 = &(&v9)[v12];\n      do {\n        fclose(*((long long *)v20));\n        v20 = &v10;\n      } while (v20 != v21);\n      goto LABEL_401573;\n    }\n  }\n  while (!(char)leuTodosOsArquivosPorCompleto(&v9, a1)) {\n    *((int128_t *)&v2) = 0;\n    *((int128_t *)&v3) = 0;\n    v4 = 0;\n    if ((unsigned int)a1 > 0) {\n      v16 = 0;\n      do {\n        *((unsigned int *)((char *)&v2 + 4 * v16)) =\n            fread(&(&v8)[20 * v16], 4, 5, (&v9)[v16]);\n        v16 += 1;\n      } while (v16 != a1);\n    }\n    *((int128_t *)&v5) = 0;\n    *((int128_t *)&v6) = 0;\n    v7 = 0;\n    v17 = pegaMenor(&v8, a1, &v5, &v2);\n    if ((unsigned int)v17 == -1)\n      continue;\n    do {\n      v18 = *((int *)((char *)&v5 + 4 * v17));\n      fwrite(&(&v8)[20 * v17 + 4 * v18], 4, 1, v0);\n      v19 = (unsigned int)v18 + 1;\n      *((unsigned int *)((char *)&v5 + 4 * v17)) = v19;\n      if (v19 == *((int *)((char *)&v2 + 4 * v17))) {\n        *((unsigned int *)((char *)&v2 + 4 * v17)) =\n            fread(&(&v8)[20 * v17], 4, 5, (&v9)[v17]);\n        *((int *)((char *)&v5 + 4 * v17)) = 0;\n      }\n    } while ((v12 += 1, v12 != a1));\n  }\n  if ((unsigned int)a1 > 0) {\n    v23 = &v9;\n    do {\n      fclose(*((long long *)v23));\n      v23 = &v10;\n    } while (v23 != &(&v9)[a1]);\n  }\n  fclose(v0);\n  free(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:32:16: error: nested redefinition of '_IO_marker'\n   32 |         struct _IO_marker {\n      |                ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:75:13: error: declaration of anonymous union must\nbe a definition 75 |             union <anon> { |             ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:78:22: error: type name requires a specifier or\nqualifier 78 |             } __value; |                      ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:82:13: error: declaration of anonymous union must\nbe a definition 82 |             union <anon> { |             ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:85:22: error: type name requires a specifier or\nqualifier 85 |             } __value; |                      ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:18:16: error: conflicting types for 'fread'\n   18 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:147:16: error: redefinition of '_IO_marker'\n  147 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:153:16: error: redefinition of '_IO_codecvt'\n  153 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:53:12: note: previous definition is here\n   53 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:157:16: error: redefinition of '_IO_wide_data'\n  157 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:61:12: note: previous definition is here\n   61 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:180:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 180 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpv1vr713c/intercalar_name_conflict.c:182:16: error: redeclaration of 'stderr' with a\ndifferent type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka 'struct\n_IO_FILE *') 182 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 182 : 22 : error\n    : expected ';' after top level declarator 182 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpv1vr713c / intercalar_name_conflict.c : 212 : 92 : error : expected ')' 212 |\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 212 : 15 : note : to match this '(' 212 |\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr @GLIBC_2.2.5);\n| ^/ tmp / tmpv1vr713c / intercalar_name_conflict.c : 221 : 27 : error : expected ')' 221 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 221 : 20 : note : to match this '(' 221 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 234 : 18 : error\n    : array subscript is not an integer 234 |\n    (&v9)[v12] = v14;\n| ^~~~/ tmp / tmpv1vr713c / intercalar_name_conflict.c : 237 : 31 : error : expected ')' 237 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)v1);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 237 : 24 : note : to match this '(' 237 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)v1);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 245 : 55 : error\n    : invalid operands to binary\n          expression('int' and 'struct_0 *'(aka 'struct struct_0 *')) 245 |\n}\nwhile (v22 != (char *)&v9 + 0x8 * v13)\n  ;\n|\n    ~~~^~~~/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 254 : 27 : error : expected ')' 254 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 254 : 20 : note : to match this '(' 254 |\n    fprintf(stderr @GLIBC_2.2.5, \"Problema na abertura do arquivo %s\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpv1vr713c /\n        intercalar_name_conflict.c : 256 : 25 : error\n    : array subscript is not an integer 256 |\n    v21 = &(&v9)[v12];\n| ^~~~fatal error : too many errors emitted,\n    stopping now[-ferror - limit = ] 20 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int pegaMenor(const int buffer[][5], const int quantidadeArquivos, const int *indices, const int *lidoAtual) {\n    int min = -1;\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        if (lidoAtual[i] > 0 && indices[i] < lidoAtual[i]) {\n            min = i;\n            break;\n        }\n    }\n    if (min != -1) {\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            if (buffer[min][indices[min]] > buffer[i][indices[i]] && indices[i] < lidoAtual[i]) {\n                min = i;\n            }\n        }\n    }\n    return min;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pegaMenor(unsigned int *a0, unsigned long a1, unsigned int *a2,\n                    unsigned int *a3) {\n  unsigned long v0;       // [bp-0x10]\n  unsigned long v1;       // [bp-0x8]\n  unsigned int *v3;       // r11\n  unsigned int *v4;       // rdi\n  unsigned int *v5;       // r8\n  unsigned int v7;        // edx\n  unsigned long v8;       // rax\n  unsigned int *v9;       // r10, Other Possible Types: unsigned long\n  unsigned long v10;      // rbx\n  unsigned int *v11;      // rsi, Other Possible Types: unsigned long\n  unsigned long v12;      // rdx\n  unsigned long long v13; // r9\n\n  if ((unsigned int)a1 <= 0)\n    return 4294967295;\n  v3 = a0;\n  v4 = a2;\n  v5 = a3;\n  v8 = 0;\n  while (true) {\n    v7 = v5[v8];\n    if (!(v7 <= 0) && !(v7 <= v4[v8]))\n      break;\n    v8 += 1;\n    if (v8 == a1)\n      return 4294967295;\n  }\n  v9 = v8;\n  if ((unsigned int)v8 == -1)\n    return v8;\n  *((int *)&v1) = rbp;\n  v0 = v10;\n  v11 = v3;\n  v12 = 0;\n  do {\n    v13 = v4[v12];\n    if (v3[4 * v9 + v4[v9] + v9] > *((int *)(v11 + (v13 << 2))) &&\n        (unsigned int)v13 < v5[v12])\n      v9 = v12;\n  } while ((v12 += 1, v11 += 20, v12 != a1));\n  return v9;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp7pl7apr/pegaMenor.c:58:18: error: invalid operands to binary expression\n('int' and 'unsigned int *') 58 |         if (v3[4 * v9 + v4[v9] + v9] > *((int\n*)(v11 + (v13 << 2))) && (unsigned int)v13 < v5[v12]) |                ~ ^ ~~\n/tmp/tmpp7pl7apr/pegaMenor.c:58:27: error: array subscript is not an integer\n   58 |         if (v3[4 * v9 + v4[v9] + v9] > *((int *)(v11 + (v13 << 2))) &&\n(unsigned int)v13 < v5[v12]) |                           ^~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"int comprimento(char *string) {\n    unsigned int quantidade = 0;\n    while (*string != '\\x00')\n        {\n            quantidade++;\n            string++;\n        }\n    return quantidade;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long comprimento_name_conflict(char *a0) {\n  char *v1; // rax, Other Possible Types: unsigned long\n  char *v2; // rdx\n\n  if (!*(a0))\n    return 0;\n  v1 = a0;\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (*((char *)v1));\n  return v2 - a0 + 1;\n}\n","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"char *maiuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96) {\n            *string -= 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(comprimento)(long long);\n\nlong long maiuscula_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n  unsigned long long v3; // rax\n  char *v4;              // rdx, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = comprimento(a0);\n  if (!(unsigned int)v2)\n    return a0;\n  v4 = &a0[1 + v2 + 1];\n  do {\n    v3 = *((char *)v1);\n    if ((char)v3 > 96)\n      *((char *)v1) = (unsigned int)v3 - 32;\n  } while ((v1 += 1, v1 != v4));\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"char *intercala(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    bool foi = 0;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96 && *string < 123) {\n            if (!foi) {\n                *string -= 32;\n                foi = 1;\n            } else {\n                foi = 0;\n            }\n        }\n    }\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(comprimento)(long long);\n\nlong long intercala_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n  unsigned long long v3; // rax\n  char v4;               // sil\n  char *v5;              // rcx, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = comprimento(a0);\n  if (!(unsigned int)v2)\n    return a0;\n  v5 = &a0[1 + v2 + 1];\n  v4 = 0;\n  do {\n    v3 = *((char *)v1);\n    if (v3 - 97 <= 25) {\n      if (v4) {\n        v4 = 0;\n      } else {\n        *((char *)v1) = (unsigned int)v3 - 32;\n        v4 = 1;\n      }\n    }\n  } while ((v1 += 1, v1 != v5));\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"char *minuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string < 91 && *string > 64) {\n            *string += 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(comprimento)(long long);\n\nlong long minuscula_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n  unsigned long long v3; // rax\n  char *v4;              // rcx, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = comprimento(a0);\n  if (!(unsigned int)v2)\n    return a0;\n  v4 = &a0[1 + v2 + 1];\n  do {\n    v3 = *((char *)v1);\n    if (v3 - 65 <= 25)\n      *((char *)v1) = (unsigned int)v3 + 32;\n  } while ((v1 += 1, v1 != v4));\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":0,"function":"int jogar(int ev1, int ev2, int at, int d) {\n    int dado, ganhador;\n    while (ev1 > 0 && ev2 > 0)\n        {\n            dado = aleatorio();\n            if (dado <= at) {\n                ev1 += d;\n                ev2 -= d;\n            } else {\n                ev1 -= d;\n                ev2 += d;\n            }\n            printf(\"Dado %d EV1 %d EV2 %d\\n\", dado, ev1, ev2);\n        }\n    if (ev1 <= 0) {\n        ganhador = 2;\n    } else {\n        ganhador = 1;\n    }\n    return ganhador;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(aleatorio)();\n\nlong long jogar(unsigned long a0, unsigned long a1, unsigned long a2,\n                unsigned long a3) {\n  unsigned long v1;      // rbx, Other Possible Types: unsigned long long\n  unsigned long v2;      // rbp, Other Possible Types: unsigned long long\n  unsigned long long v3; // rax\n\n  v1 = a0;\n  if ((unsigned int)a0 <= 0)\n    return ((unsigned int)a0 <= 0) + 1;\n  v2 = a1;\n  if ((unsigned int)a1 <= 0)\n    return ((unsigned int)a0 <= 0) + 1;\n  while (true) {\n    (unsigned int)v3 = aleatorio();\n    if ((unsigned int)v3 <= (unsigned int)a2) {\n      v1 += a3;\n      v2 -= a3;\n    } else {\n      v1 -= a3;\n      v2 += a3;\n    }\n    printf(\"Dado %d EV1 %d EV2 %d\\n\", (unsigned int)v3, (unsigned int)v1,\n           (unsigned int)v2);\n    if ((unsigned int)v1 <= 0) {\n      return ((unsigned int)v1 <= 0) + 1;\n    } else if ((unsigned int)v2 <= 0) {\n      return ((unsigned int)v1 <= 0) + 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj1sjqmbp/jogar.c:32:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 32 |         (unsigned int)v3 = aleatorio(); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":0,"function":"int aleatorio() {\n    srand(time(((void *)0)));\n    return rand() % 6 + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nvoid(srand)(unsigned int);\nint(rand)();\n\nlong long aleatorio_name_conflict() {\n  unsigned long long v1; // rax\n\n  srand(time(NULL));\n  (unsigned int)v1 = rand();\n  return (unsigned int)v1 - (unsigned int)(v1 / 6 - (v1 >> 31)) * 6 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplwbz4eud/aleatorio_name_conflict.c:25:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 25 |     (unsigned int)v1 = rand(); | ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(3, 8);\n  do {\n    *((void **)v1) = calloc(3, 4);\n    v1 += 8;\n  } while (v1 != v1 + 3);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long a0) {\n  struct struct_0 **v1; // rbp\n  unsigned long v2;     // rbx\n  unsigned int v3[3];   // rax\n  unsigned int v4[3];   // rdx\n\n  v1 = calloc(3, 8);\n  v2 = 0;\n  do {\n    v3 = calloc(3, 4);\n    *((unsigned int *[3])((char *)v1 + v2)) = v3;\n    v4 = *((long long *)(a0 + v2));\n    v3[0] = v4[0];\n    v3[1] = v4[1];\n    v3[2] = v4[2];\n    v2 += 8;\n  } while (v2 != 24);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6qc78c6d/clone_name_conflict.c:28:12: error: array type 'unsigned int[3]' is not\nassignable 28 |         v3 = calloc(3, 4); |         ~~ ^\n/tmp/tmp6qc78c6d/clone_name_conflict.c:29:11: error: used type 'unsigned int *[3]' where\narithmetic or pointer type is required 29 |         *((unsigned int *[3])((char\n*)v1 + v2)) = v3; |           ^                  ~~~~~~~~~~~~~~~~~\n/tmp/tmp6qc78c6d/clone_name_conflict.c:30:12: error: array type 'unsigned int[3]' is not\nassignable 30 |         v4 = *((long long *)(a0 + v2)); |         ~~ ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  struct struct_0 **v2;  // rdi\n  unsigned long long v3; // r8\n  char v4;               // cl\n  unsigned int *v5;      // rdx, Other Possible Types: unsigned long\n  char *v6;              // rsi, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = new_board();\n  v3 = v1 + 9;\n  do {\n    v6 = v1;\n    v5 = 0;\n    do {\n      v4 = *((char *)v6);\n      if (v4 == 79) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 2;\n      } else if (v4 == 88) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 1;\n      } else if (v4 == 45) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 0;\n      }\n    } while ((v6 += 1, v5 += 4, v5 != 12));\n    v1 += 3;\n  } while (v3 != v1);\n  return v2 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcyu0_8vh/read_encode_name_conflict.c:39:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; |                                     ~~~~^\n~~~~~~~ /tmp/tmpcyu0_8vh/read_encode_name_conflict.c:39:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpcyu0_8vh/read_encode_name_conflict.c:43:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; |                                     ~~~~^\n~~~~~~~ /tmp/tmpcyu0_8vh/read_encode_name_conflict.c:43:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpcyu0_8vh/read_encode_name_conflict.c:47:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; |                                     ~~~~^\n~~~~~~~ /tmp/tmpcyu0_8vh/read_encode_name_conflict.c:47:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(struct struct_0 **a0) {\n  void *v2;              // rcx, Other Possible Types: unsigned long\n  unsigned long long v3; // rsi\n  unsigned int v4;       // edx\n  unsigned int *v5;      // rax, Other Possible Types: unsigned long\n  unsigned int v6;       // r8d\n  void *v7;              // rax, Other Possible Types: unsigned long\n\n  v2 = 0;\n  v6 = 0;\n  do {\n    v5 = *((long long *)a0);\n    v3 = v5 + 3;\n    do {\n      v4 = *((int *)v5);\n      if (v4 == 1)\n        v6 += 1;\n      else\n        v2 += v4 == 2;\n    } while ((v5 += 4, v5 != v3));\n    a0 += 1;\n  } while (a0 != a0 + 3);\n  v7 = 0;\n  if (v6 + (unsigned int)v2 != 9)\n    v7 = ((unsigned int)v2 < v6) + 1;\n  return_name_conflict v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned int *a2) {\n  unsigned long long *v1; // rax\n\n  v1 = clone(a0);\n  *((int *)(v1[a1] + a2 * 4)) = turn(a0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpza0fa1a9/move_name_conflict.c:24:27: error: invalid operands to binary expression\n('unsigned int *' and 'int') 24 |     *((int *)(v1[a1] + a2 * 4)) = turn(a0); |\n~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  struct struct_1 *field_8;\n  struct struct_2 *field_10;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned int field_4;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_2;\n\nlong long winner_name_conflict(unsigned long a0) {\n  struct_0 *v1;     // rax, Other Possible Types: unsigned long\n  struct_0 *v2;     // rcx\n  unsigned int v3;  // edx\n  unsigned long v4; // rcx\n  unsigned int v5;  // edx\n  unsigned int v6;  // eax\n  unsigned long v7; // rsi, Other Possible Types: unsigned long long\n\n  v1 = 0;\n  do {\n    v2 = *((long long *)(a0 + v1 * 2));\n    v3 = (int)v2->field_0;\n    if (v3 && v3 == *((int *)((char *)&v2->field_0 + 4))) {\n      v7 = (int)v2->field_8;\n      if (v3 == (unsigned int)v7)\n        return (int)v2->field_8;\n    }\n    v4 = *((long long *)a0);\n    v5 = *((int *)(v4 + v1));\n    if (v5 && v5 == *((int *)(*((long long *)(a0 + 8)) + v1))) {\n      v7 = *((int *)(*((long long *)(a0 + 16)) + v1));\n      if (v5 == (unsigned int)v7)\n        return *((int *)(*((long long *)(a0 + 16)) + v1));\n    }\n    v1 += 4;\n  } while (v1 != 12);\n  v6 = *((int *)v4);\n  if (v6 && v6 == *((int *)(*((long long *)(a0 + 8)) + 4))) {\n    v7 = *((int *)(*((long long *)(a0 + 16)) + 8));\n    if (v6 == (unsigned int)v7)\n      return *((int *)(*((long long *)(a0 + 16)) + 8));\n  }\n  v7 = *((int *)*((long long *)(a0 + 16)));\n  if ((unsigned int)v7) {\n    v7 =\n        ((unsigned int)v7 == *((int *)(*((long long *)(a0 + 8)) + 4))\n             ? 0\n             : ((unsigned int)v7 == (unsigned int)v7 ? 0 : *((int *)(v4 + 8))));\n    return v7;\n  }\n  return *((int *)*((long long *)(a0 + 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr773hl6b/winner_name_conflict.c:47:38: error: invalid operands to binary expression\n('struct_0 *' (aka 'struct struct_0 *') and 'int') 47 |         v2 = *((long\nlong *)(a0 + v1 * 2)); |                                   ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu)(struct struct_0 { unsigned int field_0; } **);\n\nlong long cpu(struct struct_0 **a0) {\n  unsigned int v0;       // [bp-0x44]\n  unsigned int v1;       // [bp-0x40]\n  unsigned int v2;       // [bp-0x3c]\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v5; // r14, Other Possible Types: unsigned long\n  unsigned long long v6; // r15\n  unsigned long long v7; // r13\n  unsigned long long v8; // rax\n  unsigned long long v9; // rax\n  void *v10;             // rbx, Other Possible Types: unsigned long\n\n  v1 = turn(a0);\n  v4 = 0;\n  v5 = 4294967287;\n  do {\n    v0 = v4;\n    v6 = v4;\n    v10 = 0;\n    do {\n      if (!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) {\n        v2 = v10;\n        v7 = move(a0, v6, v10);\n        if (v1 == (int)winner(v7)) {\n          return v6 * 3 + 18 + v10;\n        } else if ((int)turn(v7)) {\n          v8 = cpu(v7);\n          v9 = (unsigned int)((v8 >> 31) - (v8 * 954437177 >> 33)) + 2;\n          if ((unsigned int)((v5 * 954437177 >> 33) - (v5 >> 31)) <\n              (unsigned int)v9)\n            v5 = v9 * 9 + v0 * 3 + v2;\n        } else if ((unsigned int)v5 <= 8) {\n          v5 = v0 * 3 + 9 + v10;\n        }\n      }\n    } while ((v10 += 1, v10 != 3));\n    v4 += 1;\n  } while (v4 != 3);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgk51y6mi/cpu.c:23:11: error: conflicting types for 'cpu'\n   23 | long long cpu(struct struct_0 **a0)\n      |           ^\n/tmp/tmpgk51y6mi/cpu.c:19:12: note: previous declaration is here\n   19 | long long (cpu)(struct struct_0 {\n      |            ^\n/tmp/tmpgk51y6mi/cpu.c:46:61: error: invalid operands to binary expression\n('int' and 'void *') 46 |             if (!*((int *)(*((long long *)((char *)a0\n+ 0x8 * v4)) + (v10 << 2)))) | ~~~ ^ ~~ /tmp/tmpgk51y6mi/cpu.c:46:75: error:\ninvalid operands to binary expression ('void *' and 'int') 46 |             if\n(!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) | ~~~ ^  ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(3, 8);\n  do {\n    *((void **)v1) = calloc(3, 4);\n    v1 += 8;\n  } while (v1 != v1 + 3);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long a0) {\n  struct struct_0 **v1; // rbp\n  unsigned long v2;     // rbx\n  unsigned int v3[3];   // rax\n  unsigned int v4[3];   // rdx\n\n  v1 = calloc(3, 8);\n  v2 = 0;\n  do {\n    v3 = calloc(3, 4);\n    *((unsigned int *[3])((char *)v1 + v2)) = v3;\n    v4 = *((long long *)(a0 + v2));\n    v3[0] = v4[0];\n    v3[1] = v4[1];\n    v3[2] = v4[2];\n    v2 += 8;\n  } while (v2 != 24);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo74kgse6/clone_name_conflict.c:28:12: error: array type 'unsigned int[3]' is not\nassignable 28 |         v3 = calloc(3, 4); |         ~~ ^\n/tmp/tmpo74kgse6/clone_name_conflict.c:29:11: error: used type 'unsigned int *[3]' where\narithmetic or pointer type is required 29 |         *((unsigned int *[3])((char\n*)v1 + v2)) = v3; |           ^                  ~~~~~~~~~~~~~~~~~\n/tmp/tmpo74kgse6/clone_name_conflict.c:30:12: error: array type 'unsigned int[3]' is not\nassignable 30 |         v4 = *((long long *)(a0 + v2)); |         ~~ ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  struct struct_0 **v2;  // rdi\n  unsigned long long v3; // r8\n  char v4;               // cl\n  unsigned int *v5;      // rdx, Other Possible Types: unsigned long\n  char *v6;              // rsi, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = new_board();\n  v3 = v1 + 9;\n  do {\n    v6 = v1;\n    v5 = 0;\n    do {\n      v4 = *((char *)v6);\n      if (v4 == 79) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 2;\n      } else if (v4 == 88) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 1;\n      } else if (v4 == 45) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 0;\n      }\n    } while ((v6 += 1, v5 += 4, v5 != 12));\n    v1 += 3;\n  } while (v3 != v1);\n  return v2 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0tzkwyx5/read_encode_name_conflict.c:39:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; |                                     ~~~~^\n~~~~~~~ /tmp/tmp0tzkwyx5/read_encode_name_conflict.c:39:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmp0tzkwyx5/read_encode_name_conflict.c:43:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; |                                     ~~~~^\n~~~~~~~ /tmp/tmp0tzkwyx5/read_encode_name_conflict.c:43:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmp0tzkwyx5/read_encode_name_conflict.c:47:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; |                                     ~~~~^\n~~~~~~~ /tmp/tmp0tzkwyx5/read_encode_name_conflict.c:47:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(struct struct_0 **a0) {\n  void *v2;              // rcx, Other Possible Types: unsigned long\n  unsigned long long v3; // rsi\n  unsigned int v4;       // edx\n  unsigned int *v5;      // rax, Other Possible Types: unsigned long\n  unsigned int v6;       // r8d\n  void *v7;              // rax, Other Possible Types: unsigned long\n\n  v2 = 0;\n  v6 = 0;\n  do {\n    v5 = *((long long *)a0);\n    v3 = v5 + 3;\n    do {\n      v4 = *((int *)v5);\n      if (v4 == 1)\n        v6 += 1;\n      else\n        v2 += v4 == 2;\n    } while ((v5 += 4, v5 != v3));\n    a0 += 1;\n  } while (a0 != a0 + 3);\n  v7 = 0;\n  if (v6 + (unsigned int)v2 != 9)\n    v7 = ((unsigned int)v2 < v6) + 1;\n  return_name_conflict v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned int *a2) {\n  unsigned long long *v1; // rax\n\n  v1 = clone(a0);\n  *((int *)(v1[a1] + a2 * 4)) = turn(a0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprdzzcfvb/move_name_conflict.c:24:27: error: invalid operands to binary expression\n('unsigned int *' and 'int') 24 |     *((int *)(v1[a1] + a2 * 4)) = turn(a0); |\n~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  struct struct_1 *field_8;\n  struct struct_2 *field_10;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned int field_4;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_2;\n\nlong long winner_name_conflict(unsigned long a0) {\n  struct_0 *v1;     // rax, Other Possible Types: unsigned long\n  struct_0 *v2;     // rcx\n  unsigned int v3;  // edx\n  unsigned long v4; // rcx\n  unsigned int v5;  // edx\n  unsigned int v6;  // eax\n  unsigned long v7; // rsi, Other Possible Types: unsigned long long\n\n  v1 = 0;\n  do {\n    v2 = *((long long *)(a0 + v1 * 2));\n    v3 = (int)v2->field_0;\n    if (v3 && v3 == *((int *)((char *)&v2->field_0 + 4))) {\n      v7 = (int)v2->field_8;\n      if (v3 == (unsigned int)v7)\n        return (int)v2->field_8;\n    }\n    v4 = *((long long *)a0);\n    v5 = *((int *)(v4 + v1));\n    if (v5 && v5 == *((int *)(*((long long *)(a0 + 8)) + v1))) {\n      v7 = *((int *)(*((long long *)(a0 + 16)) + v1));\n      if (v5 == (unsigned int)v7)\n        return *((int *)(*((long long *)(a0 + 16)) + v1));\n    }\n    v1 += 4;\n  } while (v1 != 12);\n  v6 = *((int *)v4);\n  if (v6 && v6 == *((int *)(*((long long *)(a0 + 8)) + 4))) {\n    v7 = *((int *)(*((long long *)(a0 + 16)) + 8));\n    if (v6 == (unsigned int)v7)\n      return *((int *)(*((long long *)(a0 + 16)) + 8));\n  }\n  v7 = *((int *)*((long long *)(a0 + 16)));\n  if ((unsigned int)v7) {\n    v7 =\n        ((unsigned int)v7 == *((int *)(*((long long *)(a0 + 8)) + 4))\n             ? 0\n             : ((unsigned int)v7 == (unsigned int)v7 ? 0 : *((int *)(v4 + 8))));\n    return v7;\n  }\n  return *((int *)*((long long *)(a0 + 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt1t0s74f/winner_name_conflict.c:47:38: error: invalid operands to binary expression\n('struct_0 *' (aka 'struct struct_0 *') and 'int') 47 |         v2 = *((long\nlong *)(a0 + v1 * 2)); |                                   ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu)(struct struct_0 { unsigned int field_0; } **);\n\nlong long cpu(struct struct_0 **a0) {\n  unsigned int v0;       // [bp-0x44]\n  unsigned int v1;       // [bp-0x40]\n  unsigned int v2;       // [bp-0x3c]\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v5; // r14, Other Possible Types: unsigned long\n  unsigned long long v6; // r15\n  unsigned long long v7; // r13\n  unsigned long long v8; // rax\n  unsigned long long v9; // rax\n  void *v10;             // rbx, Other Possible Types: unsigned long\n\n  v1 = turn(a0);\n  v4 = 0;\n  v5 = 4294967287;\n  do {\n    v0 = v4;\n    v6 = v4;\n    v10 = 0;\n    do {\n      if (!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) {\n        v2 = v10;\n        v7 = move(a0, v6, v10);\n        if (v1 == (int)winner(v7)) {\n          return v6 * 3 + 18 + v10;\n        } else if ((int)turn(v7)) {\n          v8 = cpu(v7);\n          v9 = (unsigned int)((v8 >> 31) - (v8 * 954437177 >> 33)) + 2;\n          if ((unsigned int)((v5 * 954437177 >> 33) - (v5 >> 31)) <\n              (unsigned int)v9)\n            v5 = v9 * 9 + v0 * 3 + v2;\n        } else if ((unsigned int)v5 <= 8) {\n          v5 = v0 * 3 + 9 + v10;\n        }\n      }\n    } while ((v10 += 1, v10 != 3));\n    v4 += 1;\n  } while (v4 != 3);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkdghab4s/cpu.c:23:11: error: conflicting types for 'cpu'\n   23 | long long cpu(struct struct_0 **a0)\n      |           ^\n/tmp/tmpkdghab4s/cpu.c:19:12: note: previous declaration is here\n   19 | long long (cpu)(struct struct_0 {\n      |            ^\n/tmp/tmpkdghab4s/cpu.c:46:61: error: invalid operands to binary expression\n('int' and 'void *') 46 |             if (!*((int *)(*((long long *)((char *)a0\n+ 0x8 * v4)) + (v10 << 2)))) | ~~~ ^ ~~ /tmp/tmpkdghab4s/cpu.c:46:75: error:\ninvalid operands to binary expression ('void *' and 'int') 46 |             if\n(!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) | ~~~ ^  ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(3, 8);\n  do {\n    *((void **)v1) = calloc(3, 4);\n    v1 += 8;\n  } while (v1 != v1 + 3);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long a0) {\n  struct struct_0 **v1; // rbp\n  unsigned long v2;     // rbx\n  unsigned int v3[3];   // rax\n  unsigned int v4[3];   // rdx\n\n  v1 = calloc(3, 8);\n  v2 = 0;\n  do {\n    v3 = calloc(3, 4);\n    *((unsigned int *[3])((char *)v1 + v2)) = v3;\n    v4 = *((long long *)(a0 + v2));\n    v3[0] = v4[0];\n    v3[1] = v4[1];\n    v3[2] = v4[2];\n    v2 += 8;\n  } while (v2 != 24);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphs4nq1_x/clone_name_conflict.c:28:12: error: array type 'unsigned int[3]' is not\nassignable 28 |         v3 = calloc(3, 4); |         ~~ ^\n/tmp/tmphs4nq1_x/clone_name_conflict.c:29:11: error: used type 'unsigned int *[3]' where\narithmetic or pointer type is required 29 |         *((unsigned int *[3])((char\n*)v1 + v2)) = v3; |           ^                  ~~~~~~~~~~~~~~~~~\n/tmp/tmphs4nq1_x/clone_name_conflict.c:30:12: error: array type 'unsigned int[3]' is not\nassignable 30 |         v4 = *((long long *)(a0 + v2)); |         ~~ ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  struct struct_0 **v2;  // rdi\n  unsigned long long v3; // r8\n  char v4;               // cl\n  unsigned int *v5;      // rdx, Other Possible Types: unsigned long\n  char *v6;              // rsi, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = new_board();\n  v3 = v1 + 9;\n  do {\n    v6 = v1;\n    v5 = 0;\n    do {\n      v4 = *((char *)v6);\n      if (v4 == 79) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 2;\n      } else if (v4 == 88) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 1;\n      } else if (v4 == 45) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 0;\n      }\n    } while ((v6 += 1, v5 += 4, v5 != 12));\n    v1 += 3;\n  } while (v3 != v1);\n  return v2 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt3ctlijp/read_encode_name_conflict.c:39:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; |                                     ~~~~^\n~~~~~~~ /tmp/tmpt3ctlijp/read_encode_name_conflict.c:39:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpt3ctlijp/read_encode_name_conflict.c:43:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; |                                     ~~~~^\n~~~~~~~ /tmp/tmpt3ctlijp/read_encode_name_conflict.c:43:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpt3ctlijp/read_encode_name_conflict.c:47:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; |                                     ~~~~^\n~~~~~~~ /tmp/tmpt3ctlijp/read_encode_name_conflict.c:47:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(struct struct_0 **a0) {\n  void *v2;              // rcx, Other Possible Types: unsigned long\n  unsigned long long v3; // rsi\n  unsigned int v4;       // edx\n  unsigned int *v5;      // rax, Other Possible Types: unsigned long\n  unsigned int v6;       // r8d\n  void *v7;              // rax, Other Possible Types: unsigned long\n\n  v2 = 0;\n  v6 = 0;\n  do {\n    v5 = *((long long *)a0);\n    v3 = v5 + 3;\n    do {\n      v4 = *((int *)v5);\n      if (v4 == 1)\n        v6 += 1;\n      else\n        v2 += v4 == 2;\n    } while ((v5 += 4, v5 != v3));\n    a0 += 1;\n  } while (a0 != a0 + 3);\n  v7 = 0;\n  if (v6 + (unsigned int)v2 != 9)\n    v7 = ((unsigned int)v2 < v6) + 1;\n  return_name_conflict v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned int *a2) {\n  unsigned long long *v1; // rax\n\n  v1 = clone(a0);\n  *((int *)(v1[a1] + a2 * 4)) = turn(a0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcr3m8ou0/move_name_conflict.c:24:27: error: invalid operands to binary expression\n('unsigned int *' and 'int') 24 |     *((int *)(v1[a1] + a2 * 4)) = turn(a0); |\n~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  struct struct_1 *field_8;\n  struct struct_2 *field_10;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned int field_4;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_2;\n\nlong long winner_name_conflict(unsigned long a0) {\n  struct_0 *v1;     // rax, Other Possible Types: unsigned long\n  struct_0 *v2;     // rcx\n  unsigned int v3;  // edx\n  unsigned long v4; // rcx\n  unsigned int v5;  // edx\n  unsigned int v6;  // eax\n  unsigned long v7; // rsi, Other Possible Types: unsigned long long\n\n  v1 = 0;\n  do {\n    v2 = *((long long *)(a0 + v1 * 2));\n    v3 = (int)v2->field_0;\n    if (v3 && v3 == *((int *)((char *)&v2->field_0 + 4))) {\n      v7 = (int)v2->field_8;\n      if (v3 == (unsigned int)v7)\n        return (int)v2->field_8;\n    }\n    v4 = *((long long *)a0);\n    v5 = *((int *)(v4 + v1));\n    if (v5 && v5 == *((int *)(*((long long *)(a0 + 8)) + v1))) {\n      v7 = *((int *)(*((long long *)(a0 + 16)) + v1));\n      if (v5 == (unsigned int)v7)\n        return *((int *)(*((long long *)(a0 + 16)) + v1));\n    }\n    v1 += 4;\n  } while (v1 != 12);\n  v6 = *((int *)v4);\n  if (v6 && v6 == *((int *)(*((long long *)(a0 + 8)) + 4))) {\n    v7 = *((int *)(*((long long *)(a0 + 16)) + 8));\n    if (v6 == (unsigned int)v7)\n      return *((int *)(*((long long *)(a0 + 16)) + 8));\n  }\n  v7 = *((int *)*((long long *)(a0 + 16)));\n  if ((unsigned int)v7) {\n    v7 =\n        ((unsigned int)v7 == *((int *)(*((long long *)(a0 + 8)) + 4))\n             ? 0\n             : ((unsigned int)v7 == (unsigned int)v7 ? 0 : *((int *)(v4 + 8))));\n    return v7;\n  }\n  return *((int *)*((long long *)(a0 + 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8rh7y9br/winner_name_conflict.c:47:38: error: invalid operands to binary expression\n('struct_0 *' (aka 'struct struct_0 *') and 'int') 47 |         v2 = *((long\nlong *)(a0 + v1 * 2)); |                                   ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu)(struct struct_0 { unsigned int field_0; } **);\n\nlong long cpu(struct struct_0 **a0) {\n  unsigned int v0;       // [bp-0x44]\n  unsigned int v1;       // [bp-0x40]\n  unsigned int v2;       // [bp-0x3c]\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v5; // r14, Other Possible Types: unsigned long\n  unsigned long long v6; // r15\n  unsigned long long v7; // r13\n  unsigned long long v8; // rax\n  unsigned long long v9; // rax\n  void *v10;             // rbx, Other Possible Types: unsigned long\n\n  v1 = turn(a0);\n  v4 = 0;\n  v5 = 4294967287;\n  do {\n    v0 = v4;\n    v6 = v4;\n    v10 = 0;\n    do {\n      if (!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) {\n        v2 = v10;\n        v7 = move(a0, v6, v10);\n        if (v1 == (int)winner(v7)) {\n          return v6 * 3 + 18 + v10;\n        } else if ((int)turn(v7)) {\n          v8 = cpu(v7);\n          v9 = (unsigned int)((v8 >> 31) - (v8 * 954437177 >> 33)) + 2;\n          if ((unsigned int)((v5 * 954437177 >> 33) - (v5 >> 31)) <\n              (unsigned int)v9)\n            v5 = v9 * 9 + v0 * 3 + v2;\n        } else if ((unsigned int)v5 <= 8) {\n          v5 = v0 * 3 + 9 + v10;\n        }\n      }\n    } while ((v10 += 1, v10 != 3));\n    v4 += 1;\n  } while (v4 != 3);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8vr9ariu/cpu.c:23:11: error: conflicting types for 'cpu'\n   23 | long long cpu(struct struct_0 **a0)\n      |           ^\n/tmp/tmp8vr9ariu/cpu.c:19:12: note: previous declaration is here\n   19 | long long (cpu)(struct struct_0 {\n      |            ^\n/tmp/tmp8vr9ariu/cpu.c:46:61: error: invalid operands to binary expression\n('int' and 'void *') 46 |             if (!*((int *)(*((long long *)((char *)a0\n+ 0x8 * v4)) + (v10 << 2)))) | ~~~ ^ ~~ /tmp/tmp8vr9ariu/cpu.c:46:75: error:\ninvalid operands to binary expression ('void *' and 'int') 46 |             if\n(!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) | ~~~ ^  ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(3, 8);\n  do {\n    *((void **)v1) = calloc(3, 4);\n    v1 += 8;\n  } while (v1 != v1 + 3);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long a0) {\n  struct struct_0 **v1; // rbp\n  unsigned long v2;     // rbx\n  unsigned int v3[3];   // rax\n  unsigned int v4[3];   // rdx\n\n  v1 = calloc(3, 8);\n  v2 = 0;\n  do {\n    v3 = calloc(3, 4);\n    *((unsigned int *[3])((char *)v1 + v2)) = v3;\n    v4 = *((long long *)(a0 + v2));\n    v3[0] = v4[0];\n    v3[1] = v4[1];\n    v3[2] = v4[2];\n    v2 += 8;\n  } while (v2 != 24);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb1ge285z/clone_name_conflict.c:28:12: error: array type 'unsigned int[3]' is not\nassignable 28 |         v3 = calloc(3, 4); |         ~~ ^\n/tmp/tmpb1ge285z/clone_name_conflict.c:29:11: error: used type 'unsigned int *[3]' where\narithmetic or pointer type is required 29 |         *((unsigned int *[3])((char\n*)v1 + v2)) = v3; |           ^                  ~~~~~~~~~~~~~~~~~\n/tmp/tmpb1ge285z/clone_name_conflict.c:30:12: error: array type 'unsigned int[3]' is not\nassignable 30 |         v4 = *((long long *)(a0 + v2)); |         ~~ ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  struct struct_0 **v2;  // rdi\n  unsigned long long v3; // r8\n  char v4;               // cl\n  unsigned int *v5;      // rdx, Other Possible Types: unsigned long\n  char *v6;              // rsi, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = new_board();\n  v3 = v1 + 9;\n  do {\n    v6 = v1;\n    v5 = 0;\n    do {\n      v4 = *((char *)v6);\n      if (v4 == 79) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 2;\n      } else if (v4 == 88) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 1;\n      } else if (v4 == 45) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 0;\n      }\n    } while ((v6 += 1, v5 += 4, v5 != 12));\n    v1 += 3;\n  } while (v3 != v1);\n  return v2 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjzh8well/read_encode_name_conflict.c:39:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; |                                     ~~~~^\n~~~~~~~ /tmp/tmpjzh8well/read_encode_name_conflict.c:39:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpjzh8well/read_encode_name_conflict.c:43:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; |                                     ~~~~^\n~~~~~~~ /tmp/tmpjzh8well/read_encode_name_conflict.c:43:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpjzh8well/read_encode_name_conflict.c:47:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; |                                     ~~~~^\n~~~~~~~ /tmp/tmpjzh8well/read_encode_name_conflict.c:47:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(struct struct_0 **a0) {\n  void *v2;              // rcx, Other Possible Types: unsigned long\n  unsigned long long v3; // rsi\n  unsigned int v4;       // edx\n  unsigned int *v5;      // rax, Other Possible Types: unsigned long\n  unsigned int v6;       // r8d\n  void *v7;              // rax, Other Possible Types: unsigned long\n\n  v2 = 0;\n  v6 = 0;\n  do {\n    v5 = *((long long *)a0);\n    v3 = v5 + 3;\n    do {\n      v4 = *((int *)v5);\n      if (v4 == 1)\n        v6 += 1;\n      else\n        v2 += v4 == 2;\n    } while ((v5 += 4, v5 != v3));\n    a0 += 1;\n  } while (a0 != a0 + 3);\n  v7 = 0;\n  if (v6 + (unsigned int)v2 != 9)\n    v7 = ((unsigned int)v2 < v6) + 1;\n  return_name_conflict v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned int *a2) {\n  unsigned long long *v1; // rax\n\n  v1 = clone(a0);\n  *((int *)(v1[a1] + a2 * 4)) = turn(a0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplr63xi5n/move_name_conflict.c:24:27: error: invalid operands to binary expression\n('unsigned int *' and 'int') 24 |     *((int *)(v1[a1] + a2 * 4)) = turn(a0); |\n~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  struct struct_1 *field_8;\n  struct struct_2 *field_10;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned int field_4;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_2;\n\nlong long winner_name_conflict(unsigned long a0) {\n  struct_0 *v1;     // rax, Other Possible Types: unsigned long\n  struct_0 *v2;     // rcx\n  unsigned int v3;  // edx\n  unsigned long v4; // rcx\n  unsigned int v5;  // edx\n  unsigned int v6;  // eax\n  unsigned long v7; // rsi, Other Possible Types: unsigned long long\n\n  v1 = 0;\n  do {\n    v2 = *((long long *)(a0 + v1 * 2));\n    v3 = (int)v2->field_0;\n    if (v3 && v3 == *((int *)((char *)&v2->field_0 + 4))) {\n      v7 = (int)v2->field_8;\n      if (v3 == (unsigned int)v7)\n        return (int)v2->field_8;\n    }\n    v4 = *((long long *)a0);\n    v5 = *((int *)(v4 + v1));\n    if (v5 && v5 == *((int *)(*((long long *)(a0 + 8)) + v1))) {\n      v7 = *((int *)(*((long long *)(a0 + 16)) + v1));\n      if (v5 == (unsigned int)v7)\n        return *((int *)(*((long long *)(a0 + 16)) + v1));\n    }\n    v1 += 4;\n  } while (v1 != 12);\n  v6 = *((int *)v4);\n  if (v6 && v6 == *((int *)(*((long long *)(a0 + 8)) + 4))) {\n    v7 = *((int *)(*((long long *)(a0 + 16)) + 8));\n    if (v6 == (unsigned int)v7)\n      return *((int *)(*((long long *)(a0 + 16)) + 8));\n  }\n  v7 = *((int *)*((long long *)(a0 + 16)));\n  if ((unsigned int)v7) {\n    v7 =\n        ((unsigned int)v7 == *((int *)(*((long long *)(a0 + 8)) + 4))\n             ? 0\n             : ((unsigned int)v7 == (unsigned int)v7 ? 0 : *((int *)(v4 + 8))));\n    return v7;\n  }\n  return *((int *)*((long long *)(a0 + 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmajbozpn/winner_name_conflict.c:47:38: error: invalid operands to binary expression\n('struct_0 *' (aka 'struct struct_0 *') and 'int') 47 |         v2 = *((long\nlong *)(a0 + v1 * 2)); |                                   ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu)(struct struct_0 { unsigned int field_0; } **);\n\nlong long cpu(struct struct_0 **a0) {\n  unsigned int v0;       // [bp-0x44]\n  unsigned int v1;       // [bp-0x40]\n  unsigned int v2;       // [bp-0x3c]\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v5; // r14, Other Possible Types: unsigned long\n  unsigned long long v6; // r15\n  unsigned long long v7; // r13\n  unsigned long long v8; // rax\n  unsigned long long v9; // rax\n  void *v10;             // rbx, Other Possible Types: unsigned long\n\n  v1 = turn(a0);\n  v4 = 0;\n  v5 = 4294967287;\n  do {\n    v0 = v4;\n    v6 = v4;\n    v10 = 0;\n    do {\n      if (!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) {\n        v2 = v10;\n        v7 = move(a0, v6, v10);\n        if (v1 == (int)winner(v7)) {\n          return v6 * 3 + 18 + v10;\n        } else if ((int)turn(v7)) {\n          v8 = cpu(v7);\n          v9 = (unsigned int)((v8 >> 31) - (v8 * 954437177 >> 33)) + 2;\n          if ((unsigned int)((v5 * 954437177 >> 33) - (v5 >> 31)) <\n              (unsigned int)v9)\n            v5 = v9 * 9 + v0 * 3 + v2;\n        } else if ((unsigned int)v5 <= 8) {\n          v5 = v0 * 3 + 9 + v10;\n        }\n      }\n    } while ((v10 += 1, v10 != 3));\n    v4 += 1;\n  } while (v4 != 3);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3ee1smi9/cpu.c:23:11: error: conflicting types for 'cpu'\n   23 | long long cpu(struct struct_0 **a0)\n      |           ^\n/tmp/tmp3ee1smi9/cpu.c:19:12: note: previous declaration is here\n   19 | long long (cpu)(struct struct_0 {\n      |            ^\n/tmp/tmp3ee1smi9/cpu.c:46:61: error: invalid operands to binary expression\n('int' and 'void *') 46 |             if (!*((int *)(*((long long *)((char *)a0\n+ 0x8 * v4)) + (v10 << 2)))) | ~~~ ^ ~~ /tmp/tmp3ee1smi9/cpu.c:46:75: error:\ninvalid operands to binary expression ('void *' and 'int') 46 |             if\n(!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) | ~~~ ^  ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long new_board_name_conflict() {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(3, 8);\n  do {\n    *((void **)v1) = calloc(3, 4);\n    v1 += 8;\n  } while (v1 != v1 + 3);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long clone_name_conflict(unsigned long a0) {\n  struct struct_0 **v1; // rbp\n  unsigned long v2;     // rbx\n  unsigned int v3[3];   // rax\n  unsigned int v4[3];   // rdx\n\n  v1 = calloc(3, 8);\n  v2 = 0;\n  do {\n    v3 = calloc(3, 4);\n    *((unsigned int *[3])((char *)v1 + v2)) = v3;\n    v4 = *((long long *)(a0 + v2));\n    v3[0] = v4[0];\n    v3[1] = v4[1];\n    v3[2] = v4[2];\n    v2 += 8;\n  } while (v2 != 24);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4rgzyage/clone_name_conflict.c:28:12: error: array type 'unsigned int[3]' is not\nassignable 28 |         v3 = calloc(3, 4); |         ~~ ^\n/tmp/tmp4rgzyage/clone_name_conflict.c:29:11: error: used type 'unsigned int *[3]' where\narithmetic or pointer type is required 29 |         *((unsigned int *[3])((char\n*)v1 + v2)) = v3; |           ^                  ~~~~~~~~~~~~~~~~~\n/tmp/tmp4rgzyage/clone_name_conflict.c:30:12: error: array type 'unsigned int[3]' is not\nassignable 30 |         v4 = *((long long *)(a0 + v2)); |         ~~ ^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(new_board)();\n\nlong long read_encode_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  struct struct_0 **v2;  // rdi\n  unsigned long long v3; // r8\n  char v4;               // cl\n  unsigned int *v5;      // rdx, Other Possible Types: unsigned long\n  char *v6;              // rsi, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = new_board();\n  v3 = v1 + 9;\n  do {\n    v6 = v1;\n    v5 = 0;\n    do {\n      v4 = *((char *)v6);\n      if (v4 == 79) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 2;\n      } else if (v4 == 88) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 1;\n      } else if (v4 == 45) {\n        *((int *)((char *)&*(v2)->field_0 + v5)) = 0;\n      }\n    } while ((v6 += 1, v5 += 4, v5 != 12));\n    v1 += 3;\n  } while (v3 != v1);\n  return v2 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvszrly7e/read_encode_name_conflict.c:39:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; |                                     ~~~~^\n~~~~~~~ /tmp/tmpvszrly7e/read_encode_name_conflict.c:39:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 39 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 2; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpvszrly7e/read_encode_name_conflict.c:43:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; |                                     ~~~~^\n~~~~~~~ /tmp/tmpvszrly7e/read_encode_name_conflict.c:43:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 43 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 1; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpvszrly7e/read_encode_name_conflict.c:47:41: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; |                                     ~~~~^\n~~~~~~~ /tmp/tmpvszrly7e/read_encode_name_conflict.c:47:51: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 47 |                 *((int *)((char\n*)&*(v2)->field_0 + v5)) = 0; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long turn_name_conflict(struct struct_0 **a0) {\n  void *v2;              // rcx, Other Possible Types: unsigned long\n  unsigned long long v3; // rsi\n  unsigned int v4;       // edx\n  unsigned int *v5;      // rax, Other Possible Types: unsigned long\n  unsigned int v6;       // r8d\n  void *v7;              // rax, Other Possible Types: unsigned long\n\n  v2 = 0;\n  v6 = 0;\n  do {\n    v5 = *((long long *)a0);\n    v3 = v5 + 3;\n    do {\n      v4 = *((int *)v5);\n      if (v4 == 1)\n        v6 += 1;\n      else\n        v2 += v4 == 2;\n    } while ((v5 += 4, v5 != v3));\n    a0 += 1;\n  } while (a0 != a0 + 3);\n  v7 = 0;\n  if (v6 + (unsigned int)v2 != 9)\n    v7 = ((unsigned int)v2 < v6) + 1;\n  return_name_conflict v7;\n}\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(clone)(long long);\n\nlong long move_name_conflict(unsigned long long a0, unsigned long a1, unsigned int *a2) {\n  unsigned long long *v1; // rax\n\n  v1 = clone(a0);\n  *((int *)(v1[a1] + a2 * 4)) = turn(a0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxq8lgdn8/move_name_conflict.c:24:27: error: invalid operands to binary expression\n('unsigned int *' and 'int') 24 |     *((int *)(v1[a1] + a2 * 4)) = turn(a0); |\n~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  struct struct_1 *field_8;\n  struct struct_2 *field_10;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned int field_4;\n} struct_1;\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned int field_8;\n} struct_2;\n\nlong long winner_name_conflict(unsigned long a0) {\n  struct_0 *v1;     // rax, Other Possible Types: unsigned long\n  struct_0 *v2;     // rcx\n  unsigned int v3;  // edx\n  unsigned long v4; // rcx\n  unsigned int v5;  // edx\n  unsigned int v6;  // eax\n  unsigned long v7; // rsi, Other Possible Types: unsigned long long\n\n  v1 = 0;\n  do {\n    v2 = *((long long *)(a0 + v1 * 2));\n    v3 = (int)v2->field_0;\n    if (v3 && v3 == *((int *)((char *)&v2->field_0 + 4))) {\n      v7 = (int)v2->field_8;\n      if (v3 == (unsigned int)v7)\n        return (int)v2->field_8;\n    }\n    v4 = *((long long *)a0);\n    v5 = *((int *)(v4 + v1));\n    if (v5 && v5 == *((int *)(*((long long *)(a0 + 8)) + v1))) {\n      v7 = *((int *)(*((long long *)(a0 + 16)) + v1));\n      if (v5 == (unsigned int)v7)\n        return *((int *)(*((long long *)(a0 + 16)) + v1));\n    }\n    v1 += 4;\n  } while (v1 != 12);\n  v6 = *((int *)v4);\n  if (v6 && v6 == *((int *)(*((long long *)(a0 + 8)) + 4))) {\n    v7 = *((int *)(*((long long *)(a0 + 16)) + 8));\n    if (v6 == (unsigned int)v7)\n      return *((int *)(*((long long *)(a0 + 16)) + 8));\n  }\n  v7 = *((int *)*((long long *)(a0 + 16)));\n  if ((unsigned int)v7) {\n    v7 =\n        ((unsigned int)v7 == *((int *)(*((long long *)(a0 + 8)) + 4))\n             ? 0\n             : ((unsigned int)v7 == (unsigned int)v7 ? 0 : *((int *)(v4 + 8))));\n    return v7;\n  }\n  return *((int *)*((long long *)(a0 + 16)));\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ve8ri6a/winner_name_conflict.c:47:38: error: invalid operands to binary expression\n('struct_0 *' (aka 'struct struct_0 *') and 'int') 47 |         v2 = *((long\nlong *)(a0 + v1 * 2)); |                                   ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(turn)(long long);\nlong long(move)(long long, long long, long long);\nlong long(winner)(long long);\nlong long(cpu)(struct struct_0 { unsigned int field_0; } **);\n\nlong long cpu(struct struct_0 **a0) {\n  unsigned int v0;       // [bp-0x44]\n  unsigned int v1;       // [bp-0x40]\n  unsigned int v2;       // [bp-0x3c]\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v5; // r14, Other Possible Types: unsigned long\n  unsigned long long v6; // r15\n  unsigned long long v7; // r13\n  unsigned long long v8; // rax\n  unsigned long long v9; // rax\n  void *v10;             // rbx, Other Possible Types: unsigned long\n\n  v1 = turn(a0);\n  v4 = 0;\n  v5 = 4294967287;\n  do {\n    v0 = v4;\n    v6 = v4;\n    v10 = 0;\n    do {\n      if (!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) {\n        v2 = v10;\n        v7 = move(a0, v6, v10);\n        if (v1 == (int)winner(v7)) {\n          return v6 * 3 + 18 + v10;\n        } else if ((int)turn(v7)) {\n          v8 = cpu(v7);\n          v9 = (unsigned int)((v8 >> 31) - (v8 * 954437177 >> 33)) + 2;\n          if ((unsigned int)((v5 * 954437177 >> 33) - (v5 >> 31)) <\n              (unsigned int)v9)\n            v5 = v9 * 9 + v0 * 3 + v2;\n        } else if ((unsigned int)v5 <= 8) {\n          v5 = v0 * 3 + 9 + v10;\n        }\n      }\n    } while ((v10 += 1, v10 != 3));\n    v4 += 1;\n  } while (v4 != 3);\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp47vbzmuq/cpu.c:23:11: error: conflicting types for 'cpu'\n   23 | long long cpu(struct struct_0 **a0)\n      |           ^\n/tmp/tmp47vbzmuq/cpu.c:19:12: note: previous declaration is here\n   19 | long long (cpu)(struct struct_0 {\n      |            ^\n/tmp/tmp47vbzmuq/cpu.c:46:61: error: invalid operands to binary expression\n('int' and 'void *') 46 |             if (!*((int *)(*((long long *)((char *)a0\n+ 0x8 * v4)) + (v10 << 2)))) | ~~~ ^ ~~ /tmp/tmp47vbzmuq/cpu.c:46:75: error:\ninvalid operands to binary expression ('void *' and 'int') 46 |             if\n(!*((int *)(*((long long *)((char *)a0 + 0x8 * v4)) + (v10 << 2)))) | ~~~ ^  ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int init_net(char *address, char *port, int *sock) {\n    int s, v, i;\n    struct addrinfo hints, *result, *rp;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = 0;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = 1 | 4;\n    hints.ai_protocol = IPPROTO_IP;\n    if ((s = getaddrinfo(address, port, &hints, &result)) != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n        exit(1);\n    }\n    for (rp = result , i = 0; rp != ((void *)0) && i < 2; rp = rp->ai_next , ++i) {\n        sock[i] = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if (sock[i] == -1) {\n            perror(\"socket\");\n            continue;\n        }\n        v = 1;\n        if (setsockopt(sock[i], 1, 2, &v, sizeof (v)) < 0) {\n            perror(\"setsockopt\");\n            return -1;\n        }\n        if (bind(sock[i], rp->ai_addr, rp->ai_addrlen) < 0) {\n            perror(\"socket\");\n            return -1;\n        }\n        if (listen(sock[i], 5) < 0) {\n            perror(\"listen\");\n            return -1;\n        }\n    }\n    freeaddrinfo(result);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":0,"function":"int sockaddr2string(struct sockaddr *sa, char *address) {\n    struct sockaddr_in *server;\n    struct sockaddr_in6 *server6;\n    if (sa->sa_family == 2) {\n        server = (struct sockaddr_in *)sa;\n        if (inet_ntop(sa->sa_family, &(server->sin_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    } else {\n        server6 = (struct sockaddr_in6 *)sa;\n        if (inet_ntop(sa->sa_family, &(server6->sin6_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntop)(int, void *, char *, int);\nvoid(perror)(char *);\n\nlong long sockaddr2string_name_conflict(unsigned short *a0, char *a1) {\n  unsigned long long v1; // rax\n\n  v1 = *(a0);\n  if ((unsigned short)v1 != 2) {\n    if (!inet_ntop((unsigned short)v1, a0 + 4, a1, 46)) {\n      perror(\"inet_ntop\");\n      return 4294967295;\n    }\n    return 0;\n  } else {\n    if (!inet_ntop(2, a0 + 2, a1, 46)) {\n      perror(\"inet_ntop\");\n      return 4294967295;\n    }\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpauvc6h1h/sockaddr2string_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":0,"function":"int is_number(char *str) {\n    int i;\n    int len = strlen(str);\n    for (i = 0; i < len; ++i)\n        if (!((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit))\n            return 0;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_number_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n  char *v5;              // rdx, Other Possible Types: unsigned long\n\n  v1 = strlen(a0);\n  if ((unsigned int)v1 <= 0)\n    return 1;\n  v5 = a0;\n  while ((\n      *((char *)(*((long long *)&__ctype_b_loc()) + (*((char *)v5) << 1) + 1)) &\n      8)) {\n    v5 += 1;\n    if (v5 == &a0[1 + v1 + 1])\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf56w8hsr/is_number_name_conflict.c:26:39: error: cannot take the address of an rvalue\nof type 'int' 26 |     while ((*((char *)(*((long long *)&__ctype_b_loc()) +\n(*((char *)v5) << 1) + 1)) & 8)) | ^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/main.c"}
{"compilable":0,"function":"int q_isEmpty(enum_q_type t) {\n    int ret = 0;\n    pthread_mutex_t *mutex = ((void *)0);\n    _task_queue_entry **head = ((void *)0);\n    if (t == TASK) {\n        mutex = &task_mutex;\n        head = &task_head;\n    } else if (t == RESPONSE) {\n        mutex = &response_mutex;\n        head = &response_head;\n    } else {\n        return 1;\n    }\n    pthread_mutex_lock(mutex);\n    ret = *head == ((void *)0) ? 1 : 0;\n    pthread_mutex_unlock(mutex);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(pthread_mutex_lock)(char *);\nchar *(pthread_mutex_unlock)(char *);\n\nextern unsigned long long response_head;\nextern char response_mutex;\nextern unsigned long long task_head;\nextern char task_mutex;\n\nlong long q_isEmpty_name_conflict(unsigned long a0) {\n  unsigned long v1;       // rbx\n  unsigned long long *v2; // rbx, Other Possible Types: unsigned long\n  char *v3;               // rbp, Other Possible Types: unsigned long\n\n  if (!(unsigned int)a0) {\n    v2 = &task_head;\n    v3 = &task_mutex;\n  } else if ((unsigned int)a0 == 1) {\n    v2 = &response_head;\n    v3 = &response_mutex;\n  } else {\n    return 1;\n  }\n  pthread_mutex_lock(v3);\n  v1 = !*((long long *)v2);\n  pthread_mutex_unlock(v3);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/task_queue.c"}
{"compilable":0,"function":"int init_epoll(int sock) {\n    int epfd;\n    struct epoll_event ev;\n    if ((epfd = epoll_create(100)) < 0) {\n        perror(\"epoll_create\");\n        return -1;\n    }\n    ev.events = EPOLLIN | EPOLLET;\n    ev.data.fd = sock;\n    if (epoll_ctl(epfd, 1, sock, &ev) < 0) {\n        perror(\"epoll_ctl\");\n        return -1;\n    }\n    return epfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(perror)(char *);\n\nlong long init_epoll_name_conflict(unsigned long long a0) {\n  unsigned int v0;       // [bp-0x24]\n  unsigned int v1;       // [bp-0x20]\n  unsigned long long v3; // rax\n\n  (unsigned int)v3 = epoll_create(100);\n  if ((unsigned int)v3 < 0) {\n    perror(\"epoll_create\");\n    return 4294967295;\n  }\n  v0 = 2147483649;\n  v1 = a0;\n  if (epoll_ctl(v3, 1, a0, &v0) < 0) {\n    perror(\"epoll_ctl\");\n    return 4294967295;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi3nnkr72/init_epoll_name_conflict.c:16:7: error: conflicting types for 'perror'\n   16 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpi3nnkr72/init_epoll_name_conflict.c:24:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 24 |     (unsigned int)v3 = epoll_create(100); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/main.c"}
{"compilable":0,"function":"int setnonblocking(int fd) {\n    int flags = fcntl(fd, 3, 0);\n    if (flags < 0) {\n        return -1;\n    }\n    if (fcntl(fd, 4, flags | 2048) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long setnonblocking_name_conflict(unsigned long a0) {\n  return (fcntl(a0, 3) < 0 ? -(fcntl(a0, 4) == -1) : 4294967295);\n}\n","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/util.c"}
{"compilable":0,"function":"int spawn(char *program, char **arg_list) {\n    pid_t child_pid;\n    child_pid = fork();\n    if (child_pid != 0)\n        return child_pid;\n    else {\n        execvp(program, arg_list);\n        fprintf(stderr, \"an error occurred in execvp\\n\");\n        abort();\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(execvp)(char *, char *[0]);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long spawn_name_conflict(char *a0, char *a1[0]) {\n  unsigned long long v1; // rax\n\n  (unsigned int)v1 = fork();\n  if (!(unsigned int)v1) {\n    execvp(a0, a1);\n    fwrite(\"an error occurred in execvp\\n\", 1, 28, stderr @GLIBC_2.2.5);\n    abort(); /* do not return */\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9yd0q7hc/spawn_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp9yd0q7hc/spawn_name_conflict.c:19:22: error: expected ';' after top level declarator\n   19 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp9yd0q7hc/spawn_name_conflict.c:25:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 25 |     (unsigned int)v1 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp9yd0q7hc/spawn_name_conflict.c:29:62: error: expected ')'\n   29 |         fwrite(\"an error occurred in execvp\\n\", 1, 28,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp9yd0q7hc/spawn_name_conflict.c:29:15: note: to match this '('\n   29 |         fwrite(\"an error occurred in execvp\\n\", 1, 28,\nstderr@GLIBC_2.2.5); |               ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap03/fork-exec.c"}
{"compilable":0,"function":"int f() {\n    return 3;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n\nlong long f_name_conflict() { return 3; }\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap02/test.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *copy = strdup(s);\n    if (copy == ((void *)0))\n        abort();\n    else\n        return copy;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1)\n    abort(); /* do not return */\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":0,"function":"char *get_self_executable_directory() {\n    int rval;\n    char link_target[1024];\n    char *last_slash;\n    size_t result_length;\n    char *result;\n    rval = readlink(\"/proc/self/exe\", link_target, sizeof (link_target));\n    if (rval == -1)\n        abort();\n    else\n        link_target[rval] = '\\x00';\n    last_slash = strrchr(link_target, '/');\n    if (last_slash == ((void *)0) || last_slash == link_target)\n        abort();\n    result_length = last_slash - link_target;\n    result = (char *)xmalloc(result_length + 1);\n    strncpy(result, link_target, result_length);\n    result[result_length] = '\\x00';\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long get_self_executable_directory_name_conflict() {\n  char v0;               // [bp-0x418]\n  unsigned long v2;      // rax\n  unsigned long long v3; // rax\n  char *v4;              // rbx\n  unsigned long v5;      // rbp\n\n  v2 = readlink(\"/proc/self/exe\", &v0, 0x400);\n  if ((unsigned int)v2 == -1)\n    abort(); /* do not return */\n  (&v0)[v2] = 0;\n  v3 = strrchr(&v0, 47);\n  if (!(v3 != &v0 && v3))\n    abort(); /* do not return */\n  v4 = v3 - &v0;\n  v5 = xmalloc(v4 + 1);\n  v4[v5] = 0;\n  return strncpy(v5, &v0, v4);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpofex1os9/get_self_executable_directory_name_conflict.c:35:13: error: invalid operands\nto binary expression ('unsigned long long' and 'char *') 35 |     v4 = v3 - &v0;\n      |          ~~ ^ ~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":0,"function":"ipstats_t *ip_get(char *ip_txt) {\n    unsigned int ip;\n    ipstats_t *l;\n    int p[4];\n    sscanf(ip_txt, \"%d.%d.%d.%d\", p + 0, p + 1, p + 2, p + 3);\n    ip = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3]);\n    for (l = ipstats; l; l = l->next) {\n        if (l->ip == ip) {\n            return (l);\n        }\n    }\n    if (ipstats) {\n        for (l = ipstats; l->next; l = l->next) {\n            ;\n        }\n        l->next = malloc(sizeof(ipstats_t));\n        l = l->next;\n    } else {\n        l = malloc(sizeof(ipstats_t));\n        ipstats = l;\n    }\n    memset(l, 0, sizeof(ipstats_t));\n    l->ip = ip;\n    return (l);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\nextern char ipstats;\n\nlong long ip_get_name_conflict(unsigned long a0) {\n  char v0;          // [bp-0x28]\n  char v1;          // [bp-0x24]\n  char v2;          // [bp-0x20]\n  char v3;          // [bp-0x1c]\n  unsigned int v5;  // ebx\n  unsigned long v6; // rdx\n  unsigned long v7; // rbp\n  unsigned long v8; // rax\n\n  __isoc99_sscanf(a0, \"%d.%d.%d.%d\", (unsigned int)&v0, (unsigned int)&v1,\n                  (unsigned int)&v2, (unsigned int)&v3);\n  v5 = *((int *)&v0) * 0x1000000 | *((int *)&v1) * 0x10000 | *((int *)&v3) |\n       *((int *)&v2) * 0x100;\n  v6 = ipstats;\n  if (!ipstats) {\n    v8 = malloc(40);\n    ipstats = v8;\n  } else {\n    v8 = ipstats;\n    do {\n      if (*((int *)v8) == v5)\n        return v8;\n    } while ((v8 = *((long long *)(v8 + 32)), v8));\n    do {\n      v7 = v6;\n      v6 = *((long long *)(v6 + 32));\n    } while (v6);\n    v8 = malloc(40);\n    *((unsigned long *)(v7 + 32)) = v8;\n  }\n  *((int128_t *)(v8 + 4)) = 0;\n  *((int128_t *)(v8 + 20)) = 0;\n  *((int *)(v8 + 36)) = 0;\n  *((unsigned int *)v8) = v5;\n  return v8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu3p0harh/ip_get_name_conflict.c:57:18: error: expected expression\n   57 |     *((int128_t *)(v8 + 4)) = 0;\n      |                  ^\n/tmp/tmpu3p0harh/ip_get_name_conflict.c:58:18: error: expected expression\n   58 |     *((int128_t *)(v8 + 20)) = 0;\n      |                  ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/meh_bitlbee/utils/bitlbeed.c"}
{"compilable":0,"function":"static int *get_arr() {\n    static int arr[50000] = {8};\n    return arr;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/array.c"}
{"compilable":0,"function":"static int pop() {\n    int val = heap[0];\n    heap[0] = heap[--sz];\n    heap[sz] = val;\n    heap_adjust(heap, sz, 0);\n    return val;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/algorithms/heap_sort.c"}
{"compilable":0,"function":"QueryConnexionResponse callback_new_connexion(QueryConnexion *q) {\n    static int i;\n    static int iter = (int)(16 / 6);\n    for (i = 0; i < 16; i += iter) {\n        if (__anneau->connexion[i] == 0) {\n            break;\n        }\n    }\n    if (i > 16) {\n        for (i = 16; i >= 0; i--) {\n            if (__anneau->connexion[i] == 0) {\n                break;\n            }\n        }\n    }\n    QueryConnexionResponse r;\n    r.type = q->bot.pid;\n    r.pos = i;\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[12];\n  unsigned int field_c;\n} struct_0;\n\nextern unsigned long long __anneau;\nextern unsigned int i.4;\n\nlong long callback_new_connexion_name_conflict(struct_0 *a0) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  char v2;          // sil\n  unsigned int v3;  // ecx\n  unsigned long v4; // rax, Other Possible Types: unsigned long long\n  char v5;          // cl\n  unsigned int v6;  // r9d\n\n  i.4 = 0;\n  v1 = 2;\n  v2 = 0;\n  do {\n    if (!*((int *)(__anneau + (v1 << 2) + 508))) {\n      if (v2)\n        i.4 = v3;\n      v3 = (unsigned int)v1 - 2;\n      goto LABEL_401951;\n    }\n  } while ((v3 = (unsigned int)v1, v1 += 2, v2 = 1, v1 != 18));\n  i.4 = v3;\nLABEL_401951:\n  if (v3 <= 16)\n    return a0->field_c;\n  i.4 = 16;\n  v4 = 15;\n  v5 = 0;\n  while (*((int *)(__anneau + (v4 << 2) + 520))) {\n    v6 = v4;\n    v4 -= 1;\n    v5 = 1;\n    if (v4 == -2) {\n      i.4 = v6;\n      return a0->field_c;\n    }\n  }\n  if (!v5)\n    return a0->field_c;\n  i.4 = i.4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:23:22: error: expected ';' after top\nlevel declarator 23 | extern unsigned int i.4; |                      ^ | ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:34:6: error: expected ';' after\nexpression 34 |     i.4 = 0; |      ^ |      ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:34:9: error: expression is not\nassignable 34 |     i.4 = 0; |      ~~ ^\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:42:18: error: expected ';' after\nexpression 42 |                 i.4 = v3; |                  ^ | ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:42:21: error: expression is not\nassignable 42 |                 i.4 = v3; |                  ~~ ^\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:47:6: error: expected ';' after\nexpression 47 |     i.4 = v3; |      ^ |      ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:47:9: error: expression is not\nassignable 47 |     i.4 = v3; |      ~~ ^\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:51:6: error: expected ';' after\nexpression 51 |     i.4 = 16; |      ^ |      ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:51:9: error: expression is not\nassignable 51 |     i.4 = 16; |      ~~ ^\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:61:14: error: expected ';' after\nexpression 61 |             i.4 = v6; |              ^ |              ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:61:17: error: expression is not\nassignable 61 |             i.4 = v6; |              ~~ ^\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:67:6: error: expected ';' after\nexpression 67 |     i.4 = i.4; |      ^ |      ;\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:67:9: error: expression is not\nassignable 67 |     i.4 = i.4; |      ~~ ^\n/tmp/tmpymuw91ix/callback_new_connexion_name_conflict.c:67:12: error: expected ';' after\nexpression 67 |     i.4 = i.4; |            ^ |            ; 14 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int ya_til_des_robots_connectes() {\n    static int i;\n    for (i = 0; i < 6; i++) {\n        if (__anneau->connexion[i] != 0 && __anneau->connexion[i] != __pid) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long __anneau;\nextern unsigned int __pid;\nextern unsigned int i.2;\n\nlong long ya_til_des_robots_connectes_name_conflict() {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  char v2;          // cl\n  unsigned int v3;  // edx\n  unsigned int v4;  // r8d\n\n  i.2 = 0;\n  v1 = 1;\n  v2 = 0;\n  while (true) {\n    v3 = *((int *)(__anneau + v1 * 4 + 0x200));\n    if (!(!v3) && !(v3 == __pid))\n      break;\n    v4 = v1;\n    v1 += 1;\n    v2 = 1;\n    if (v1 == 7) {\n      i.2 = v4;\n      return 0;\n    }\n  }\n  if (v2)\n    i.2 = i.2;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:19:22: error: expected ';' after\ntop level declarator 19 | extern unsigned int i.2; |                      ^ | ;\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:28:6: error: expected ';' after\nexpression 28 |     i.2 = 0; |      ^ |      ;\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:28:9: error: expression is not\nassignable 28 |     i.2 = 0; |      ~~ ^\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:41:14: error: expected ';' after\nexpression 41 |             i.2 = v4; |              ^ |              ;\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:41:17: error: expression is not\nassignable 41 |             i.2 = v4; |              ~~ ^\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:46:10: error: expected ';' after\nexpression 46 |         i.2 = i.2; |          ^ |          ;\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:46:13: error: expression is not\nassignable 46 |         i.2 = i.2; |          ~~ ^\n/tmp/tmpsrl8w4qf/ya_til_des_robots_connectes_name_conflict.c:46:16: error: expected ';' after\nexpression 46 |         i.2 = i.2; |                ^ |                ; 8\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if ((__anneau->cases[16 - 1]).p.etat == -1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint __anneau; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *__anneau;\n\nlong long puis_je_prendre_produit_name_conflict() { return __anneau->field_1fc == -1; }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5yg80be1/puis_je_prendre_produit_name_conflict.c:18:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 18 | extern struct_0 *__anneau; | ^~~~~~~~ |\nstruct /tmp/tmp5yg80be1/puis_je_prendre_produit_name_conflict.c:18:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmp5yg80be1/puis_je_prendre_produit_name_conflict.c:22:22: error: member reference type\n'int' is not a pointer 22 |     return __anneau->field_1fc == -1; | ~~~~~~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int nb_composants_restants() {\n    static int i, num;\n    for (i = 0 , num = 0; i < 4; i++) {\n        num += stockComposants[i];\n    }\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int g_404144;\nextern unsigned int g_404148;\nextern unsigned int g_40414c;\nextern unsigned int i.1;\nextern unsigned int num.0;\nextern unsigned int stockComposants;\n\nlong long nb_composants_restants_name_conflict() {\n  num.0 = g_404144 + stockComposants + g_404148 + g_40414c;\n  i.1 = 4;\n  return g_404144 + stockComposants + g_404148 + g_40414c;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvgpu0sn_/nb_composants_restants_name_conflict.c:20:22: error: expected ';' after top\nlevel declarator 20 | extern unsigned int i.1; |                      ^ | ;\n/tmp/tmpvgpu0sn_/nb_composants_restants_name_conflict.c:21:24: error: expected ';' after top\nlevel declarator 21 | extern unsigned int num.0; |                        ^ | ;\n/tmp/tmpvgpu0sn_/nb_composants_restants_name_conflict.c:26:8: error: expected ';' after\nexpression 26 |     num.0 = g_404144 + stockComposants + g_404148 + g_40414c; |\n^ |        ; /tmp/tmpvgpu0sn_/nb_composants_restants_name_conflict.c:26:11: error: expression\nis not assignable 26 |     num.0 = g_404144 + stockComposants + g_404148 +\ng_40414c; |        ~~ ^ /tmp/tmpvgpu0sn_/nb_composants_restants_name_conflict.c:27:6: error:\nexpected ';' after expression 27 |     i.1 = 4; |      ^ |      ;\n/tmp/tmpvgpu0sn_/nb_composants_restants_name_conflict.c:27:9: error: expression is not\nassignable 27 |     i.1 = 4; |      ~~ ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"static int has(char *array, char val) {\n    static int i;\n    for (i = 0; array[i]; i++) {\n        if (array[i] == val) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int i.7;\n\nlong long has_name_conflict(char *a0, unsigned long a1) {\n  char v1;          // dl\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n  char v3;          // cl\n  unsigned int v4;  // r9d\n\n  i.7 = 0;\n  v1 = *(a0);\n  if (!v1)\n    return 0;\n  v2 = 1;\n  v3 = 0;\n  while ((char)a1 != v1) {\n    v4 = v2;\n    v2 += 1;\n    v1 = a0[1 + v2];\n    v3 = 1;\n    if (!v1) {\n      i.7 = v4;\n      return 0;\n    }\n  }\n  if (!v3)\n    return 1;\n  i.7 = i.7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmk_vfzdb/has_name_conflict.c:17:22: error: expected ';' after top level declarator\n   17 | extern unsigned int i.7;\n      |                      ^\n      |                      ;\n/tmp/tmpmk_vfzdb/has_name_conflict.c:26:6: error: expected ';' after expression\n   26 |     i.7 = 0;\n      |      ^\n      |      ;\n/tmp/tmpmk_vfzdb/has_name_conflict.c:26:9: error: expression is not assignable\n   26 |     i.7 = 0;\n      |      ~~ ^\n/tmp/tmpmk_vfzdb/has_name_conflict.c:40:14: error: expected ';' after expression\n   40 |             i.7 = v4;\n      |              ^\n      |              ;\n/tmp/tmpmk_vfzdb/has_name_conflict.c:40:17: error: expression is not assignable\n   40 |             i.7 = v4;\n      |              ~~ ^\n/tmp/tmpmk_vfzdb/has_name_conflict.c:46:6: error: expected ';' after expression\n   46 |     i.7 = i.7;\n      |      ^\n      |      ;\n/tmp/tmpmk_vfzdb/has_name_conflict.c:46:9: error: expression is not assignable\n   46 |     i.7 = i.7;\n      |      ~~ ^\n/tmp/tmpmk_vfzdb/has_name_conflict.c:46:12: error: expected ';' after expression\n   46 |     i.7 = i.7;\n      |            ^\n      |            ;\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_composant() {\n    if (has(bot.mode == NORMAL ? bot.prods : bot.prodsDegrades, (__anneau->cases[bot.pos]).c.num)) {\n        static int i;\n        i = ctoi((__anneau->cases[bot.pos]).c.num) - 1;\n        if (bot.stockComposants[i] < 3) {\n            if (bot.stockComposants[i] == (produits[i].nbComp - 1)) {\n                if (bot.stockProduits[i] == 0) {\n                    return 1;\n                }\n            } else {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(has)(long long, long long);\nlong long(ctoi)(long long);\n\nextern unsigned long long __anneau;\nextern char bot;\nextern unsigned int g_4051e8;\nextern unsigned int g_4051ec;\nextern char g_4051f6;\nextern char g_4051fa;\nextern unsigned long long produits;\n\nlong long puis_je_prendre_composant_name_conflict() {\n  unsigned long long v2; // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rdx\n  unsigned int v4;       // ecx\n\n  v2 = has((g_4051ec == 1 ? &g_4051fa : &g_4051f6),\n           *((char *)(g_4051e8 * 32 + __anneau + 8)));\n  if (!(unsigned int)v2)\n    return v2;\n  v3 = ctoi(*((char *)(g_4051e8 * 32 + __anneau + 8))) - 1;\n  v4 = *((int *)&(&bot)[32 + 4 * v3]);\n  if (v4 > 2) {\n    return 0;\n  } else if (v4 != *((int *)((v3 + (v3 << 2) << 2) + produits + 4)) - 1) {\n    return 1;\n  } else {\n    return !*((int *)&(&bot)[48 + 4 * v3]);\n  }\n}\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if (bot.mode == NORMAL) {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prods, (__anneau->cases[bot.pos]).p.num)) {\n                    if (bot.ops[0] == (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat]) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    } else {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prodsDegrades, (__anneau->cases[bot.pos]).p.num)) {\n                    if (has(bot.ops, (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat])) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ctoi)(long long);\nlong long(has)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[28];\n  unsigned int field_1c;\n} struct_0;\n\nextern unsigned long long __anneau;\nextern char bot;\nextern unsigned int g_4051e8;\nextern unsigned int g_4051ec;\nextern char g_4051f0;\nextern unsigned long long g_4051f6;\nextern unsigned long long g_4051fa;\n\nlong long puis_je_prendre_produit_name_conflict() {\n  unsigned long long v1; // rcx\n  unsigned long v2;      // rax\n  unsigned long long v3; // rcx\n  struct_0 *v6;          // rax\n  struct_0 *v7;          // rax\n\n  if (g_4051ec != 1) {\n    v1 = g_4051e8 * 32;\n    if (*((int *)(__anneau + v1 + 28)) < 0) {\n      return 0;\n    } else if (*((int *)&(\n                   &bot)[44 + 4 * ctoi(*((char *)(__anneau + v1 + 12)))])) {\n      return 0;\n    } else {\n      v2 = has(&g_4051fa, *((char *)(g_4051e8 * 32 + __anneau + 12)));\n      if ((unsigned int)v2) {\n        v6 = g_4051e8 * 32 + __anneau;\n        v2 = (int)has(&g_4051f0, v6->padding_0[20 + v6->field_1c]);\n        return v2;\n      }\n      return v2;\n    }\n  } else {\n    v3 = g_4051e8 * 32;\n    if (*((int *)(__anneau + v3 + 28)) < 0) {\n      return 0;\n    } else if (*((int *)&(\n                   &bot)[44 + 4 * ctoi(*((char *)(__anneau + v3 + 12)))])) {\n      return 0;\n    } else {\n      v2 = has(&g_4051f6, *((char *)(g_4051e8 * 32 + __anneau + 12)));\n      if ((unsigned int)v2) {\n        v7 = g_4051e8 * 32 + __anneau;\n        v2 = v7->padding_0[20 + v7->field_1c] == g_4051f0;\n        return v2;\n      }\n      return v2;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Composant prendre_composant() {\n    static Composant c;\n    c = (__anneau->cases[bot.pos]).c;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).c.num = 0;\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  char field_8;\n  char padding_9[23];\n  unsigned int field_20;\n} struct_0;\n\nextern unsigned long long __anneau;\nextern char c.6;\nextern unsigned int g_4051e8;\n\nlong long prendre_composant_name_conflict() {\n  struct_0 *v1; // rax\n\n  v1 = g_4051e8 * 32 + __anneau;\n  c.6 = v1->field_8;\n  v1->field_20 = 0;\n  v1->field_8 = 0;\n  return c.6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpug_t_gls/prendre_composant_name_conflict.c:25:14: error: expected ';' after top level\ndeclarator 25 | extern char c.6; |              ^ |              ;\n/tmp/tmpug_t_gls/prendre_composant_name_conflict.c:33:6: error: expected ';' after expression\n   33 |     c.6 = v1->field_8;\n      |      ^\n      |      ;\n/tmp/tmpug_t_gls/prendre_composant_name_conflict.c:33:9: error: expression is not assignable\n   33 |     c.6 = v1->field_8;\n      |      ~~ ^\n/tmp/tmpug_t_gls/prendre_composant_name_conflict.c:36:13: error: expected ';' after return\nstatement 36 |     return c.6; |             ^ |             ; 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Produit prendre_produit() {\n    static Produit p;\n    p = (__anneau->cases[bot.pos]).p;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).p.num = 0;\n    return p;\n}\n","function_prediction":"static int *get_arr() {\n  static int arr[50000] = {8};\n  return arr;\n}\n","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"static int bind_local(uint16_t port) {\n    int fd;\n    struct sockaddr_in servaddr;\n    fd = socket(2, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"socket\");\n        exit(1);\n    }\n    bzero(&servaddr, sizeof (servaddr));\n    servaddr.sin_family = 2;\n    servaddr.sin_port = htons(port);\n    if (inet_pton(2, \"127.0.0.1\", &servaddr.sin_addr) <= 0) {\n        perror(\"inet_pton\");\n        exit(1);\n    }\n    if (bind(fd, (struct sockaddr *)&servaddr, sizeof (servaddr)) < 0) {\n        perror(\"bind\");\n        exit(1);\n    }\n    if (listen(fd, 128) < 0) {\n        perror(\"listen\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/sduzh_snippet/src/net/test_epoll.c"}
{"compilable":1,"function":"static int test_hexdigit(char ch) {\n    if (ch >= '0' && ch <= '9')\n        return ch - '0';\n    if (ch >= 'A' && ch <= 'F')\n        return ch - 'A' + 10;\n    if (ch >= 'a' && ch <= 'f')\n        return ch - 'a' + 10;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test_hexdigit_name_conflict(unsigned long a0) {\n  if (a0 - 48 <= 9) {\n    return a0 - 48;\n  } else if (a0 - 65 <= 5) {\n    return a0 - 55;\n  } else if (6 <= (a0 - 97 & 255)) {\n    return 4294967295;\n  } else {\n    return (char)a0 - 87;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"static int test_readhex(uint8_t *buf, const char *str, int maxbytes) {\n    int i, h, l;\n    for (i = 0; i < maxbytes; i++) {\n        h = test_hexdigit(str[2 * i]);\n        if (h < 0)\n            return i;\n        l = test_hexdigit(str[2 * i + 1]);\n        if (l < 0)\n            return i;\n        buf[i] = (h << 4) + l;\n    }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_hexdigit)(long long);\n\nlong long test_readhex_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char *v1;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n  unsigned long long v5; // rax\n\n  if ((unsigned int)a2 <= 0)\n    return 0;\n  for (v1 = 0; (unsigned int)v3 >= 0; v1 += 1) {\n    v3 = test_hexdigit(*((char *)(a1 + v1 * 2)));\n    v5 = test_hexdigit(*((char *)(a1 + v1 * 2 + 1)));\n    if ((unsigned int)v5 < 0)\n      return v1;\n    *((char *)(a0 + v1)) = (char)v3 * 16 + (char)v5;\n    if (v1 == a2)\n      return v1 + 1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8xtorp4x/test_readhex_name_conflict.c:28:47: error: invalid operands to binary\nexpression ('char *' and 'int') 28 |         v3 = test_hexdigit(*((char *)(a1 +\nv1 * 2))); |                                            ~~ ^ ~\n/tmp/tmp8xtorp4x/test_readhex_name_conflict.c:29:47: error: invalid operands to binary\nexpression ('char *' and 'int') 29 |         v5 = test_hexdigit(*((char *)(a1 +\nv1 * 2 + 1))); |                                            ~~ ^ ~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_sha3() {\n    const char *testvec[][2] = {{\"\", \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\"}, {\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\", \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"}, {\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\", \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DAF3BB7B1BC5E8D722BAC85943A\"}, {\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\", \"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE12205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\"}};\n    int i, fails, msg_len, sha_len;\n    uint8_t sha[64], buf[64], msg[256];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        memset(sha, 0, sizeof (sha));\n        memset(buf, 0, sizeof (buf));\n        memset(msg, 0, sizeof (msg));\n        msg_len = test_readhex(msg, testvec[i][0], sizeof (msg));\n        sha_len = test_readhex(sha, testvec[i][1], sizeof (sha));\n        sha3(msg, msg_len, buf, sha_len);\n        if (memcmp(sha, buf, sha_len) != 0) {\n            fprintf(stderr, \"[%d] SHA3-%d, len %d test FAILED.\\n\", i, sha_len * 8, msg_len);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_readhex)(long long, long long, long long);\nlong long(sha3)(long long, long long, long long, long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern char g_402004;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long test_sha3_name_conflict() {\n  unsigned int v0;        // [bp-0x1fc]\n  char v1;                // [bp-0x1f8]\n  int v2;                 // [bp-0xf8]\n  int v3;                 // [bp-0xe8]\n  int v4;                 // [bp-0xd8]\n  int v5;                 // [bp-0xc8]\n  int v6;                 // [bp-0xb8]\n  int v7;                 // [bp-0xa8]\n  int v8;                 // [bp-0x98]\n  int v9;                 // [bp-0x88]\n  unsigned long long v10; // [bp-0x78]\n  unsigned long long v11; // [bp-0x70]\n  unsigned long v12;      // [bp-0x68]\n  unsigned long v13;      // [bp-0x60]\n  unsigned long v14;      // [bp-0x58]\n  unsigned long v15;      // [bp-0x50]\n  unsigned long v16;      // [bp-0x48]\n  unsigned long v17;      // [bp-0x40]\n  void *v19;              // r12\n  unsigned long v20;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v21;          // rdi, Other Possible Types: unsigned long\n  unsigned long v22;      // d\n  unsigned long long v23; // rbx\n  unsigned long long v24; // r13\n  unsigned long v25;      // rax\n\n  v10 = &g_402004;\n  v11 = \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\";\n  v12 = \"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\";\n  v13 = \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\";\n  v14 = \"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F8\"\n        \"0189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F\"\n        \"33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\";\n  v15 = \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99D\"\n        \"AF3BB7B1BC5E8D722BAC85943A\";\n  v16 = \"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB6\"\n        \"6B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03\"\n        \"AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496\"\n        \"DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD952\"\n        \"46C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8\"\n        \"F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565\"\n        \"CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5\"\n        \"BE6BB0E4A92ECEEBAEB1\";\n  v17 = \"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE1\"\n        \"2205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\";\n  v19 = 0;\n  v0 = 0;\n  do {\n    *((int128_t *)&v6) = 0;\n    *((int128_t *)&v7) = 0;\n    *((int128_t *)&v8) = 0;\n    *((int128_t *)&v9) = 0;\n    *((int128_t *)&v2) = 0;\n    *((int128_t *)&v3) = 0;\n    *((int128_t *)&v4) = 0;\n    *((int128_t *)&v5) = 0;\n    v20 = 32;\n    for (v21 = &v1; v20; v21 += v22 * 8) {\n      v20 -= 1;\n      *((long long *)v21) = 0;\n    }\n    v23 = v19 * 16;\n    v24 = test_readhex(&v1, v10, 0x100);\n    v25 = test_readhex(&v6, v11, 64);\n    sha3(&v1, v24, &v2, v25);\n    if (memcmp(&v6, &v2, v25)) {\n      fprintf(stderr @GLIBC_2.2.5, \"[%d] SHA3-%d, len %d test FAILED.\\n\",\n              (unsigned int)v19, (unsigned int)v25 * 8, (unsigned int)v24);\n      v0 += 1;\n    }\n  } while (v19 + 1 != 4);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:32:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 32 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:32:22: error: expected ';' after top level\ndeclarator 32 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:74:22: error: expected expression\n   74 |         *((int128_t *)&v6) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:75:22: error: expected expression\n   75 |         *((int128_t *)&v7) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:76:22: error: expected expression\n   76 |         *((int128_t *)&v8) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:77:22: error: expected expression\n   77 |         *((int128_t *)&v9) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:78:22: error: expected expression\n   78 |         *((int128_t *)&v2) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:79:22: error: expected expression\n   79 |         *((int128_t *)&v3) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:80:22: error: expected expression\n   80 |         *((int128_t *)&v4) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:81:22: error: expected expression\n   81 |         *((int128_t *)&v5) = 0;\n      |                      ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:88:19: error: invalid operands to binary expression\n('void *' and 'int') 88 |         v23 = v19 * 16; |               ~~~ ^ ~~\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:94:27: error: expected ')'\n   94 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHA3-%d, len %d test\nFAILED.\\n\", (unsigned int)v19, (unsigned int)v25 * 8, (unsigned int)v24); | ^\n/tmp/tmpx1c90tio/test_sha3_name_conflict.c:94:20: note: to match this '('\n   94 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHA3-%d, len %d test\nFAILED.\\n\", (unsigned int)v19, (unsigned int)v25 * 8, (unsigned int)v24); | ^ 12\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_shake() {\n    const char *testhex[4] = {\"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\", \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\", \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\", \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\"};\n    int i, j, fails;\n    sha3_ctx_t sha3;\n    uint8_t buf[32], ref[32];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        if ((i & 1) == 0) {\n            sha3_init(&sha3, 16);\n        } else {\n            sha3_init(&sha3, 32);\n        }\n        if (i >= 2) {\n            memset(buf, 163, 20);\n            for (j = 0; j < 200; j += 20)\n                sha3_update(&sha3, buf, 20);\n        }\n        shake_xof(&sha3);\n        for (j = 0; j < 512; j += 32)\n            shake_out(&sha3, buf, 32);\n        test_readhex(ref, testhex[i], sizeof (ref));\n        if (memcmp(buf, ref, 32) != 0) {\n            fprintf(stderr, \"[%d] SHAKE%d, len %d test FAILED.\\n\", i, i & 1 ? 256 : 128, i >= 2 ? 1600 : 0);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sha3_init)(long long, long long);\nlong long(shake_xof)(long long);\nlong long(sha3_update)(long long, long long, long long);\nlong long(shake_out)(long long, long long, long long);\nlong long(test_readhex)(long long, long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long test_shake_name_conflict() {\n  unsigned int v0;       // [bp-0x184]\n  unsigned int v1;       // [bp-0x180]\n  unsigned int v2;       // [bp-0x17c]\n  char v3;               // [bp-0x178]\n  int v4;                // [bp-0x158]\n  unsigned int v5;       // [bp-0x148]\n  char v6;               // [bp-0x138]\n  unsigned long long v7; // [bp-0x58]\n  unsigned long v8;      // [bp-0x50]\n  unsigned long v9;      // [bp-0x48]\n  unsigned long v10;     // [bp-0x40]\n  void *v12;             // r13, Other Possible Types: unsigned long\n  unsigned int v13;      // r15d\n  unsigned int v14;      // ebx\n  unsigned int v15;      // ebx\n\n  v7 = \"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\";\n  v8 = \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\";\n  v9 = \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\";\n  v10 = \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\";\n  v12 = 0;\n  v2 = 0;\n  do {\n    v1 = v12;\n    v13 = (unsigned int)v12 & 1;\n    if (!((char)v12 & 1))\n      sha3_init(&v6, 16);\n    else\n      sha3_init(&v6, 32);\n    v0 = v12;\n    if ((unsigned int)v12 > 1) {\n      *((int128_t *)&v4) = 217513826698482233507961023574032229283;\n      v5 = 2745410467;\n      v14 = 10;\n      do {\n        sha3_update(&v6, &v4, 20);\n        v14 -= 1;\n      } while (true);\n    }\n    shake_xof(&v6);\n    v15 = 16;\n    do {\n      shake_out(&v6, &v4, 32);\n      v15 -= 1;\n    } while (true);\n    test_readhex(&v3, v7, 32);\n    if (memcmp(&v4, &v3, 32)) {\n      fprintf(stderr @GLIBC_2.2.5, \"[%d] SHAKE%d, len %d test FAILED.\\n\", v1,\n              (-(v13 < 1) & -128) + 0x100, (2 <= v0 ? 0 : 1600));\n      v2 += 1;\n    }\n    v12 += 1;\n  } while (v12 != 4);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5fcg0m3w/test_shake_name_conflict.c:23:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 23 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5fcg0m3w/test_shake_name_conflict.c:23:22: error: expected ';' after top level\ndeclarator 23 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp5fcg0m3w/test_shake_name_conflict.c:60:26: error: expected expression\n   60 |             *((int128_t *)&v4) =\n217513826698482233507961023574032229283; |                          ^\n/tmp/tmp5fcg0m3w/test_shake_name_conflict.c:60:34: error: integer literal is too large to be\nrepresented in any integer type 60 |             *((int128_t *)&v4) =\n217513826698482233507961023574032229283; |                                  ^\n/tmp/tmp5fcg0m3w/test_shake_name_conflict.c:79:27: error: expected ')'\n   79 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHAKE%d, len %d test\nFAILED.\\n\", v1, (-(v13 < 1) & -128) + 0x100, (2 <= v0 ? 0 : 1600)); | ^\n/tmp/tmp5fcg0m3w/test_shake_name_conflict.c:79:20: note: to match this '('\n   79 |             fprintf(stderr@GLIBC_2.2.5, \"[%d] SHAKE%d, len %d test\nFAILED.\\n\", v1, (-(v13 < 1) & -128) + 0x100, (2 <= v0 ? 0 : 1600)); | ^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":1,"function":"int sha3_init(sha3_ctx_t *c, int mdlen) {\n    int i;\n    for (i = 0; i < 25; i++)\n        c->st.q[i] = 0;\n    c->mdlen = mdlen;\n    c->rsiz = 200 - 2 * mdlen;\n    c->pt = 0;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n  char padding_8[192];\n  unsigned int field_c8;\n  unsigned int field_cc;\n  unsigned int field_d0;\n} struct_0;\n\nlong long sha3_init_name_conflict(struct_0 *a0, unsigned long a1) {\n  struct_0 *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = a0;\n  do {\n    *((long long *)v1) = 0;\n    v1 += 8;\n  } while (v1 != &a0->field_c8);\n  a0->field_d0 = a1;\n  a0->field_cc = (100 - (unsigned int)a1) * 2;\n  a0->field_c8 = 0;\n  return 1;\n}\n","pass":1,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/sha3.c"}
{"compilable":0,"function":"int randomTile(int lowerLim, int upperLim) {\n    return rand() % (upperLim - lowerLim + 1) + lowerLim;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long randomTile_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v2; // rax\n\n  (unsigned int)v2 = rand();\n  return (((unsigned int)v2 >> 31 CONCAT(unsigned int) v2) /\n              m((unsigned int)a1 - (unsigned int)a0 + 1) >>\n          32) +\n         a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo7skwfui/randomTile_name_conflict.c:22:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 22 |     (unsigned int)v2 = rand(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpo7skwfui/randomTile_name_conflict.c:23:37: error: expected ')'\n   23 |     return (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0 + 1) >> 32) + a0; | ^\n/tmp/tmpo7skwfui/randomTile_name_conflict.c:23:13: note: to match this '('\n   23 |     return (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0 + 1) >> 32) + a0; |             ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int swapTile(char grid[6][6], gridcoord tile, char direction) {\n    gridcoord partnertile;\n    char temp;\n    partnertile.x = tile.x;\n    partnertile.y = tile.y;\n    unsigned long score = 0;\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    int linsertat = 0;\n    int cinsertat = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char prompt_resp;\n    switch (direction) {\n      case 'w':\n      case 'W':\n        partnertile.y = tile.y - 1;\n        break;\n      case 's':\n      case 'S':\n        partnertile.y = tile.y + 1;\n        break;\n      case 'a':\n      case 'A':\n        partnertile.x = tile.x - 1;\n        break;\n      case 'd':\n      case 'D':\n        partnertile.x = tile.x + 1;\n        break;\n      default:\n        printf(\"\\n:( ERROR. Unknown command.\");\n    }\n    temp = grid[tile.y][tile.x];\n    grid[tile.y][tile.x] = grid[partnertile.y][partnertile.x];\n    grid[partnertile.y][partnertile.x] = temp;\n    lengtmt = checkmatches_lengthwise(grid, partnertile, lmatches, &linsertat);\n    crossmt = checkmatches_crosswise(grid, partnertile, cmatches, &cinsertat);\n    if (lengtmt >= 2 || crossmt >= 2) {\n        if (lengtmt >= 2) {\n            score += lengtmt;\n            assasinate(grid, lmatches, lengtmt);\n        }\n        if (crossmt >= 2) {\n            score += crossmt;\n            assasinate(grid, cmatches, crossmt);\n        }\n        grid[partnertile.y][partnertile.x] = '\\x00';\n        score += 1;\n    } else {\n        linsertat = 0;\n        cinsertat = 0;\n        lengtmt = checkmatches_lengthwise(grid, tile, lmatches, &linsertat);\n        crossmt = checkmatches_crosswise(grid, tile, cmatches, &cinsertat);\n        if (lengtmt >= 2 || crossmt >= 2) {\n            if (lengtmt >= 2) {\n                score += lengtmt;\n                assasinate(grid, lmatches, lengtmt);\n            }\n            if (crossmt >= 2) {\n                score += crossmt;\n                assasinate(grid, cmatches, crossmt);\n            }\n            grid[tile.y][tile.x] = '\\x00';\n            score += 1;\n        } else {\n            temp = grid[partnertile.y][partnertile.x];\n            grid[partnertile.y][partnertile.x] = grid[tile.y][tile.x];\n            grid[tile.y][tile.x] = temp;\n        }\n    }\n    return score;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkmatches_lengthwise)(long long, long long, long long, long long);\nlong long(checkmatches_crosswise)(long long, long long, long long, long long);\nlong long(assasinate)(long long, long long, long long);\n\nlong long swapTile_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned int v0;        // [bp-0x290]\n  char v1;                // [bp-0x289]\n  unsigned int v2;        // [bp-0x280]\n  unsigned int v3;        // [bp-0x27c]\n  char v4;                // [bp-0x278]\n  char v5;                // [bp-0x158]\n  unsigned long long v7;  // r13\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  char *v10;              // r12, Other Possible Types: unsigned long\n  unsigned long v11;      // r15\n  char v12;               // dil\n  unsigned long v13;      // r14\n  char *v14;              // r13\n  unsigned long long v15; // rax\n  void *v16;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v17; // r13\n  void *v19;              // r12, Other Possible Types: unsigned long\n  unsigned long long v20; // rdx\n\n  v7 = a1 >> 32;\n  v3 = 0;\n  v2 = 0;\n  switch ((unsigned int)a2) {\n  case 65:\n  case 97:\n    v10 = a1 + 1;\n    v9 = v7;\n    break;\n  case 68:\n  case 100:\n    v10 = a1 + 1;\n    v9 = v7;\n    break;\n  case 83:\n  case 115:\n    v9 = v7 + 1;\n    v10 = a1;\n    break;\n  case 87:\n  case 119:\n    v9 = v7 - 1;\n    v10 = a1;\n    break;\n  default:\n    printf(\"\\n:( ERROR. Unknown command.\");\n    v9 = v7;\n    v10 = a1;\n    break;\n  }\n  v11 = a0 + v7 * 6;\n  v12 = a1[v11];\n  v1 = v12;\n  v13 = a0 + v9 * 6;\n  a1[v11] = *((char *)(v13 + v10));\n  *((char *)(v13 + v10)) = v1;\n  v14 = v10 | v9 * 0x100000000;\n  v0 = checkmatches_lengthwise(a0, v14, &v5, &v3);\n  v15 = checkmatches_crosswise(a0, v14, &v4, &v2);\n  if (v0 <= 1 && (unsigned int)v15 <= 1) {\n    v3 = 0;\n    v2 = 0;\n    v17 = checkmatches_lengthwise(a0, a1, &v5, &v3);\n    v0 = checkmatches_crosswise(a0, a1, &v4, &v2);\n    if ((unsigned int)v17 <= 1 && v0 <= 1) {\n      *((char *)(v13 + v10)) = a1[v11];\n      a1[v11] = v1;\n      return 0;\n    }\n    v19 = 0;\n    if ((unsigned int)v17 <= 1 ||\n        (v19 = v17, assasinate(a0, &v5, v17), v0 > 1)) {\n      v20 = v0;\n      v19 += v20;\n      assasinate(a0, &v4, v20);\n    }\n    a1[v11] = 0;\n    return v19 + 1;\n  }\n  v16 = 0;\n  v16 += v15;\n  assasinate(a0, &v4, v15);\n  *((char *)(v13 + v10)) = 0;\n  return v16 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnoob9p09/swapTile_name_conflict.c:41:13: error: invalid operands to binary expression\n('char *' and 'int') 41 |     v7 = a1 >> 32; |          ~~ ^  ~~\n/tmp/tmpnoob9p09/swapTile_name_conflict.c:74:15: error: invalid operands to binary expression\n('char *' and 'unsigned long') 74 |     v14 = v10 | v9 * 0x100000000; | ~~~ ^\n~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int popmatches_universal(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char gridcopy[6][6];\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    gridcoord tile;\n    int didchangel = 0;\n    int didchangec = 0;\n    int tsambapoints = 0;\n    int linsertat = 0;\n    int cinsertat = 0;\n    copymatrix2d(grid, gridcopy);\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            lengtmt = checkmatches_lengthwise(gridcopy, tile, lmatches, &linsertat);\n            crossmt = checkmatches_crosswise(gridcopy, tile, cmatches, &cinsertat);\n            if (lengtmt >= 2 || crossmt >= 2) {\n                if (lengtmt >= 2) {\n                    didchangel = 1;\n                    tsambapoints += lengtmt;\n                }\n                if (crossmt >= 2) {\n                    didchangec = 1;\n                    tsambapoints += crossmt;\n                }\n                grid[tile.y][tile.x] = '\\x00';\n                tsambapoints += 1;\n            }\n        }\n    }\n    if (didchangel) {\n        assasinate(gridcopy, lmatches, linsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    if (didchangec) {\n        assasinate(gridcopy, cmatches, cinsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    fillGaps(grid);\n    if (didchangec == 1 || didchangel == 1) {\n        return tsambapoints += popmatches_universal(grid);\n    }\n    return tsambapoints;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(copymatrix2d)(long long, long long);\nlong long(checkmatches_lengthwise)(long long, long long, long long, long long);\nlong long(checkmatches_crosswise)(long long, long long, long long, long long);\nlong long(assasinate)(long long, long long, long long);\nlong long(fillGaps)(long long);\nlong long(popmatches_universal_name_conflict)(char *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long popmatches_universal_name_conflict(char *a0) {\n  unsigned long long v0; // [bp-0x2f0]\n  struct_0 *v1;          // [bp-0x2e8]\n  char *v2;              // [bp-0x2e0]\n  unsigned int v3;       // [bp-0x2d4]\n  char *v4;              // [bp-0x2d0]\n  unsigned int v5;       // [bp-0x2c8]\n  unsigned int v6;       // [bp-0x2c4]\n  char *v7;              // [bp-0x2c0]\n  unsigned int v8;       // [bp-0x2b0]\n  unsigned int v9;       // [bp-0x2ac]\n  char v10;              // [bp-0x2a8]\n  char v11;              // [bp-0x188]\n  char v12;              // [bp-0x68]\n  void *v14; // r14, Other Possible Types: unsigned long, unsigned int\n  char *v15; // r13, Other Possible Types: unsigned long\n  void *v16; // r12, Other Possible Types: unsigned long\n  char *v17; // rbx\n  unsigned long long v18; // r12\n  unsigned long long v19; // rax\n  unsigned long v20;      // r15\n  char *v21;              // r12\n\n  v9 = 0;\n  v8 = 0;\n  copymatrix2d(a0, &v12);\n  v14 = 0;\n  v5 = 0;\n  v3 = 0;\n  v15 = a0;\n  v7 = a0;\n  v16 = 0;\n  do {\n    v2 = v15;\n    v20 = 0;\n    v0 = v16 * 0x100000000;\n    v1 = &v11;\n    v4 = v15;\n    v6 = v16;\n    do {\n      v17 = v20 | v0;\n      v18 = checkmatches_lengthwise(&v12, v17, v1, &v9);\n      (unsigned int)v19 = checkmatches_crosswise(&v12, v17, &v10, &v8);\n      if ((unsigned int)v18 > 1 || (unsigned int)v19 > 1) {\n        if ((unsigned int)v18 <= 1 ||\n            (v14 += v18, v3 = (unsigned int)1, (unsigned int)v19 > 1)) {\n          v14 = (unsigned int)v14 + (unsigned int)v19;\n          v5 = 1;\n        }\n        v2[v20] = 0;\n        v14 = (unsigned int)v14 + 1;\n      }\n    } while ((v20 += 1, v20 != 6));\n    v16 = v6 + 1;\n    v15 = v4 + 6;\n  } while ((unsigned int)v16 != 6);\n  v21 = v7;\n  if (v3) {\n    assasinate(&v12, &v11, v9);\n    copymatrix2d(&v12, v21);\n    if (!v5) {\n      fillGaps(v21);\n      v14 += popmatches_universal_name_conflict(v21);\n      return v14;\n    }\n  } else if (!v5) {\n    fillGaps(v21);\n    return v14;\n  }\n  assasinate(&v12, &v10, v8);\n  copymatrix2d(&v12, v21);\n  fillGaps(v21);\n  if (!v5 && !v3)\n    return v14;\n  v14 += popmatches_universal_name_conflict(v21);\n  return v14;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf00nwbz0/popmatches_universal_name_conflict.c:64:18: error: invalid operands to binary\nexpression ('void *' and 'long') 64 |         v0 = v16 * 0x100000000; | ~~~ ^\n~~~~~~~~~~~ /tmp/tmpf00nwbz0/popmatches_universal_name_conflict.c:72:13: error: assignment to\ncast is illegal, lvalue casts are not supported 72 |             (unsigned\nint)v19 = checkmatches_crosswise(&v12, v17, &v10, &v8); | ^~~~~~~~~~~~~~~~~ ~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_lengthwise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.y - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.y + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  char field_ - 6;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[6];\n  char field_6;\n} struct_0;\n\nlong long checkmatches_lengthwise(unsigned long a0, char *a1, unsigned int *a2,\n                                  unsigned int *a3) {\n  char *v1;               // rbx\n  unsigned int *v2;       // rsi\n  unsigned int *v3;       // rax\n  char *v4;               // r10\n  unsigned long long v5;  // r9\n  unsigned long long v6;  // rdx\n  void *v8;               // rdx, Other Possible Types: unsigned long\n  unsigned int v9;        // ecx\n  struct_1 *v10;          // r8, Other Possible Types: unsigned long\n  unsigned long long v11; // rcx\n  struct_0 *v13;          // rcx, Other Possible Types: unsigned long\n  unsigned long long v14; // rbx\n  unsigned int v15;       // edi\n  unsigned int v16;       // r8d\n\n  v1 = a1;\n  v2 = a2;\n  v3 = a3;\n  v4 = v1;\n  v5 = v1 >> 32;\n  v9 = (unsigned int)v5 - 1;\n  if ((unsigned int)(v5 - 1) < 0) {\n    v8 = 0;\n  } else {\n    v6 = v5 * 6;\n    v10 = &v1[v6 + a0];\n    v8 = 0;\n    while (v1[v6 + a0] == *((char *)(v10 - 6)) &&\n           (v8 = (unsigned long long)((unsigned int)v8 + 1),\n            v2[2 * *(v3)] = (unsigned int)v1, v2[1 + 2 * *(v3)] = v9,\n            *(v3) = *(v3) + 1, v9 -= 1, v10 -= 6, v9 != -1))\n      ;\n  }\n  if ((unsigned int)v5 > 4)\n    return v8;\n  v11 = v5 * 6;\n  v13 = &v1[v11 + a0];\n  v14 = v8 - v5 + 5;\n  v15 = v5 + 1 - v8;\n  while (v4[v11 + a0] == *((char *)(v13 + 6))) {\n    v16 = v15 + (unsigned int)v8;\n    v8 = (unsigned int)v8 + 1;\n    v2[2 * *(v3)] = (unsigned int)v4;\n    v2[1 + 2 * *(v3)] = v16;\n    *(v3) = *(v3) + 1;\n    v13 += 6;\n    if ((unsigned int)v8 == (unsigned int)v14)\n      return v14;\n  }\n  return v8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp25ev64fz/checkmatches_lengthwise.c:18:16: error: expected ';' at end of\ndeclaration list 18 |     char field_-6; |                ^ |                ;\n/tmp/tmp25ev64fz/checkmatches_lengthwise.c:47:13: error: invalid operands to\nbinary expression ('char *' and 'int') 47 |     v5 = v1 >> 32; |          ~~ ^\n~~ /tmp/tmp25ev64fz/checkmatches_lengthwise.c:66:18: error: invalid operands to\nbinary expression ('unsigned long long' and 'void *') 66 |     v15 = v5 + 1 -\nv8; |           ~~~~~~ ^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_crosswise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.x - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.x + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long checkmatches_crosswise(unsigned long a0, char *a1, unsigned int *a2,\n                                 unsigned int *a3) {\n  unsigned long long v1; // rbx\n  unsigned int *v2;      // rdi\n  unsigned int *v3;      // rax\n  unsigned long long v5; // r12\n  unsigned long v6;      // r9\n  unsigned long v7;      // rdx\n  char *v8;              // rcx, Other Possible Types: unsigned long\n  unsigned long v9;      // rdx\n  unsigned long v10;     // rsi\n\n  v1 = a0;\n  v2 = a2;\n  v3 = a3;\n  v5 = a1 >> 32;\n  v7 = (unsigned int)a1 - 1;\n  if ((unsigned int)(a1 + 1) < 0) {\n    v8 = 0;\n  } else {\n    v6 = v1 + v5 * 6;\n    v8 = 0;\n    while (a1[v6] == *((char *)(v6 + v7))) {\n      v8 = (unsigned int)v8 + 1;\n      v2[2 * *(v3)] = v7;\n      v2[1 + 2 * *(v3)] = v5;\n      *(v3) = *(v3) + 1;\n      v7 -= 1;\n      if ((unsigned int)v8 == (unsigned int)a1) {\n        v8 = a1;\n        break;\n      }\n    }\n  }\n  v9 = a1 + 1;\n  if ((unsigned int)v9 > 5)\n    return v8;\n  v10 = v1 + v5 * 6;\n  while (a1[v10] == *((char *)(v10 + v9)) &&\n         (v8 = (unsigned long long)((unsigned int)v8 + 1),\n          v2[2 * *(v3)] = (unsigned int)v9,\n          v2[1 + 2 * *(v3)] = (unsigned int)v5, *(v3) = *(v3) + 1, v9 += 1,\n          (unsigned int)v9 <= 5))\n    ;\n  return v8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0xm6vkm9/checkmatches_crosswise.c:32:13: error: invalid operands to\nbinary expression ('char *' and 'int') 32 |     v5 = a1 >> 32; |          ~~ ^\n~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int isValid(gridcoord move, char direction) {\n    if (move.x == -1 && move.y == -1 && direction == '0') {\n        return 1;\n    }\n    if (move.x == 0 && (direction == 'a' || direction == 'A')) {\n        printf(\"\\tYou can't move that to the left.\\n\");\n        return 0;\n    }\n    if (move.x == 6 - 1 && (direction == 'd' || direction == 'D')) {\n        printf(\"\\tYou can't move that to the right.\\n\");\n        return 0;\n    }\n    if (move.y == 0 && (direction == 'w' || direction == 'W')) {\n        printf(\"\\tYou can't move that up.\\n\");\n        return 0;\n    }\n    if (move.y == 6 - 1 && (direction == 's' || direction == 'S')) {\n        printf(\"\\tYou can't move that down.\\n\");\n        return 0;\n    }\n    if (move.y < 0 || move.x < 0 || move.y >= 6 || move.x >= 6) {\n        printf(\"\\tI can't find those coordinates. Terminals are dumb, huh?\\n\");\n        return 0;\n    }\n    if (direction != 'a' && direction != 'A' && direction != 's' && direction != 'S' && direction != 'd' && direction != 'D' && direction != 'w' && direction != 'W') {\n        printf(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D for RIGHT.\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isValid_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;               // [bp-0x138]\n  unsigned long long v3; // rbx\n  unsigned long long v4; // rsi\n\n  v3 = a0 >> 32;\n  if (((unsigned int)a0 & (unsigned int)v3) == -1 && (char)a1 == 48)\n    return 1;\n  if ((unsigned int)a0) {\n    if ((unsigned int)a0 == 5 && (char)((unsigned int)a1 & -33) == 68) {\n      puts(\"\\tYou can't move that to the right.\");\n      return 0;\n    }\n  } else {\n    if ((char)((unsigned int)a1 & -33) == 65) {\n      puts(\"\\tYou can't move that to the left.\");\n      return a0;\n    }\n  }\n  if ((unsigned int)v3) {\n    if ((unsigned int)v3 == 5 && (char)((unsigned int)a1 & -33) == 83) {\n      puts(\"\\tYou can't move that down.\");\n      return 0;\n    }\n  } else {\n    if ((char)((unsigned int)a1 & -33) == 87) {\n      puts(\"\\tYou can't move that up.\");\n      return v3;\n    }\n  }\n  if ((unsigned int)a0 <= 5 && (unsigned int)v3 <= 5) {\n    v4 = (unsigned int)a1 - 65;\n    if ((char)v4 <= 54) {\n      wstrncpy(&v0, \"\\tD\\tD\", 4);\n      if (((char)((&v0)[(v4 & 63) >> 3] >> (char)(v4 & 63 & 7)) & 1))\n        return 1;\n    }\n    puts(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D \"\n         \"for RIGHT.\");\n    return 0;\n  }\n  puts(\"\\tI can't find those coordinates. Terminals are dumb, huh?\");\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int game() {\n    char grid[6][6];\n    gridcoord target;\n    unsigned long gamescore = 0;\n    char direction;\n    do {\n        populate(grid);\n        popmatches_universal(grid);\n    } while (!trymatches(grid));\n    do {\n        drawGrid(grid, gamescore);\n        do {\n            printf(\"\\n\\tMOVE: \");\n            scanf(\"%d %d %c\", &target.x, &target.y, &direction);\n            target.x -= 1;\n            target.y -= 1;\n            if (target.x == -1 && target.y == -1 && direction == '0') {\n                return gamescore;\n            }\n        } while (!isValid(target, direction));\n        gamescore += swapTile(grid, target, direction);\n        gamescore += popmatches_universal(grid);\n    } while ((target.x != -1 && target.y != -1 && direction != '0') && (trymatches(grid) == 1));\n    return gamescore;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(populate)(long long);\nlong long(popmatches_universal)(long long);\nlong long(trymatches)(long long);\nlong long(drawGrid)(long long, long long);\nint(__isoc99_scanf)(char *, ...);\nlong long(isValid)(long long, long long);\nlong long(swapTile)(long long, long long, long long);\n\nlong long game_name_conflict() {\n  char v0;         // [bp-0x71]\n  char v1;         // [bp-0x70], Other Possible Types: unsigned int\n  unsigned int v2; // [bp-0x6c], Other Possible Types: char\n  char v3;         // [bp-0x68]\n  void *v5;        // r15, Other Possible Types: unsigned long\n  unsigned int v6; // eax\n  unsigned int v7; // edx\n\n  do {\n    populate(&v3);\n    popmatches_universal(&v3);\n  } while (!(int)trymatches(&v3));\n  v5 = 0;\n  while (true) {\n    drawGrid(&v3, v5);\n    do {\n      printf(\"\\n\\tMOVE: \");\n      __isoc99_scanf(\"%d %d %c\", (unsigned int)&v1, (unsigned int)&v2,\n                     (unsigned int)&v0);\n      v6 = *((int *)&v1);\n      v1 = v6 - 1;\n      v7 = v2;\n      v2 = v7 - 1;\n      if (!v6 && !v7 && v0 == 48)\n        return v5;\n    } while (!(int)isValid(*((long long *)&v1), v0));\n    v5 += swapTile(&v3, *((long long *)&v1), v0) + popmatches_universal(&v3);\n    if (v1 == -1)\n      break;\n    if (!(v2 != -1) || !(v0 != 48) || !((int)trymatches(&v3) == 1))\n      break;\n    if ((int)trymatches(&v3) != 1)\n      break;\n  }\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int trymatches(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    gridcoord tile;\n    char prompt_resp;\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            if (isValid(tile, 'w')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y - 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 's')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y + 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'a')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x - 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'd')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x + 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(isValid)(long long, long long);\nlong long(areThereMatches)(long long, long long);\n\nlong long trymatches_name_conflict(char *a0) {\n  unsigned long long v0; // [bp-0x60]\n  unsigned int v1;       // [bp-0x54]\n  unsigned int v2;       // [bp-0x50]\n  char v3;               // [bp-0x49]\n  unsigned int v4;       // [bp-0x48]\n  char *v5;              // [bp-0x40], Other Possible Types: unsigned long\n  char *v7;              // rax\n  unsigned long v8;      // r13\n  unsigned long v9;      // r12\n  unsigned long v10;     // r14\n  char *v11;             // rbp\n  char v12;              // r15b\n  char v13;              // r15b\n  char v14;              // r15b\n  char v15;              // r15b\n  unsigned long v16;     // rbx\n  unsigned long v17;     // rax\n  unsigned long v19;     // rax\n  unsigned long v20;     // rax\n  unsigned long v21;     // rax\n\n  v5 = a0;\n  v4 = 0;\n  do {\n    v7 = v5;\n    v8 = v7 + 6;\n    v9 = v7;\n    v5 = v7 + 6;\n    v10 = v5;\n    v16 = 0;\n    v0 = *((long long *)&v4) * 0x100000000;\n    do {\n      v2 = v16;\n      v1 = v16;\n      v11 = v16 | v0;\n      if ((int)isValid(v11, 119)) {\n        v12 = *((char *)(v8 + v16));\n        *((char *)(v8 + v16)) = v7[v16];\n        v7[v16] = v12;\n        if ((int)areThereMatches(a0, v11)) {\n          v17 = v1;\n          *((char *)(v9 + v17)) = *((char *)(v8 + v17));\n          *((char *)(v8 + v17)) = v12;\n          return 1;\n        }\n        v7[v16] = *((char *)(v8 + v16));\n        *((char *)(v8 + v16)) = v12;\n      }\n      if ((int)isValid(v11, 115)) {\n        v13 = *((char *)(v10 + v16));\n        *((char *)(v10 + v16)) = v7[v16];\n        v7[v16] = v13;\n        if ((int)areThereMatches(a0, v11)) {\n          v19 = v1;\n          *((char *)(v9 + v19)) = *((char *)(v10 + v19));\n          *((char *)(v10 + v19)) = v13;\n          return 1;\n        }\n        v7[v16] = *((char *)(v10 + v16));\n        *((char *)(v10 + v16)) = v13;\n      }\n      if ((int)isValid(v11, 97)) {\n        v14 = v7[1 + v16];\n        v3 = v7[v16];\n        v7[1 + v16] = v3;\n        v7[v16] = v14;\n        if ((int)areThereMatches(a0, v11)) {\n          v20 = v2 - 1;\n          *((char *)(v9 + v1)) = *((char *)(v9 + v20));\n          *((char *)(v9 + v20)) = v14;\n          return 1;\n        }\n        v7[v16] = v3;\n        v7[1 + v16] = v14;\n      }\n      if ((int)isValid(v11, 100)) {\n        v15 = v7[1 + v16];\n        v3 = v7[v16];\n        v7[1 + v16] = v3;\n        v7[v16] = v15;\n        if ((int)areThereMatches(a0, v11)) {\n          v21 = v2 + 1;\n          *((char *)(v9 + v1)) = *((char *)(v9 + v21));\n          *((char *)(v9 + v21)) = v15;\n          return 1;\n        }\n        v7[v16] = v3;\n        v7[1 + v16] = v15;\n      }\n      v16 += 1;\n    } while (v16 != 6);\n    v4 += 1;\n  } while (v4 != 6);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int areThereMatches(char grid[6][6], gridcoord tile) {\n    gridcoord dummy[36];\n    int dummyinsertat = 0;\n    if (checkmatches_lengthwise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    if (checkmatches_crosswise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkmatches_lengthwise)(long long, long long, long long, long long);\nlong long(checkmatches_crosswise)(long long, long long, long long, long long);\n\nlong long areThereMatches_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0; // [bp-0x13c]\n  char v1;         // [bp-0x138]\n\n  v0 = 0;\n  if ((int)checkmatches_lengthwise(a0, a1, &v1, &v0) <= 1)\n    return 1 < (int)checkmatches_crosswise(a0, a1, &v1, &v0);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":1,"function":"int params_finish(struct params *fsm) {\n    if (fsm->cs == params_error)\n        return -1;\n    if (fsm->cs >= params_first_final)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1032];\n  unsigned int field_408;\n} struct_0;\n\nlong long params_finish_name_conflict(struct_0 *a0) {\n  unsigned int v1;  // edx\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0->field_408;\n  v2 = 4294967295;\n  if (v1)\n    v2 = 22 < v1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/brson_ragel-dist/examples/params.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long count_nucleotides_name_conflict(unsigned long long a0[5], char *a1) {\n  char *v0;              // [bp-0x50], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x48], Other Possible Types: unsigned long\n  char *v2;              // [bp-0x40], Other Possible Types: unsigned long\n  char *v4;              // rax\n  char *v5;              // rbx\n  unsigned long long v6; // rdx\n  unsigned long v7;      // rax\n  char *v8;              // r14, Other Possible Types: unsigned long\n  char *v9; // r15, Other Possible Types: unsigned long, unsigned long long\n\n  v4 = strlen(a1);\n  v5 = v4;\n  if (!v4) {\n    v2 = v4;\n    v1 = v4;\n    v0 = v4;\n    v8 = v4;\n    v9 = v4;\n  } else {\n    v2 = 0;\n    v1 = 0;\n    v0 = 0;\n    v8 = 0;\n    v9 = 0;\n    v7 = 0;\n    do {\n      v6 = a1[v7];\n      switch ((char)v6) {\n      case 65:\n      case 97:\n        v9 += 1;\n        break;\n      case 67:\n      case 99:\n        v8 += 1;\n        break;\n      case 71:\n      case 103:\n        v0 += 1;\n        break;\n      case 84:\n      case 116:\n        v1 += 1;\n        break;\n      case 85:\n      case 117:\n        v2 += 1;\n        break;\n      default:\n        fprintf(stderr @GLIBC_2.2.5,\n                \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\",\n                (unsigned int)v6);\n        v7 = v5;\n        break;\n      }\n      v7 += 1;\n    } while (v7 < v5);\n  }\n  a0[0] = v9;\n  a0[1] = v8;\n  a0[2] = v0;\n  a0[3] = v1;\n  a0[4] = v2;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy0ii00cm/count_nucleotides_name_conflict.c:17:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpy0ii00cm/count_nucleotides_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpy0ii00cm/count_nucleotides_name_conflict.c:70:31: error: expected ')'\n   70 |                 fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict():\nUnexpected character: '%c'\\n\", (unsigned int)v6); | ^\n/tmp/tmpy0ii00cm/count_nucleotides_name_conflict.c:70:24: note: to match this '('\n   70 |                 fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict():\nUnexpected character: '%c'\\n\", (unsigned int)v6); |                        ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long transcribe_dna_to_rna_name_conflict(char *a0) {\n  char *v1;              // rbx\n  unsigned long long v2; // rax\n  char *v3;              // rdx, Other Possible Types: unsigned long\n  char v5;               // cl\n\n  v1 = strdup(a0);\n  v2 = strlen(v1);\n  if (!v2)\n    return v1;\n  v3 = v1;\n  do {\n    v5 = *((char *)v3);\n    if ((v5 & 223) == 84)\n      *((char *)v3) = v5 + 1;\n  } while ((v3 += 1, v3 != v2 + v1));\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long get_dna_complement_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n  char *v4;              // rsi\n  char v5;               // dl\n  char *v6;              // rcx, Other Possible Types: unsigned long\n\n  v1 = strdup(a0);\n  v2 = strlen(v1);\n  if (!v2)\n    return v1;\n  v6 = v1;\n  while (true) {\n    v4 = v6;\n    switch (*((char *)v6)) {\n    case 65:\n    case 97:\n      v5 = 84;\n      break;\n    case 67:\n    case 99:\n      v5 = 71;\n      break;\n    case 71:\n    case 103:\n      v5 = 67;\n      break;\n    case 84:\n    case 116:\n      v5 = 65;\n      break;\n    default:\n      free(v1);\n      return 0;\n    }\n    *(v4) = v5;\n    v6 += 1;\n    if (v6 == &v1[v2])\n      return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamming_distance_name_conflict(char *a0, unsigned long a1) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rdx, Other Possible Types: unsigned long long\n  unsigned long v3;      // rax\n\n  v1 = strlen(a0);\n  if (v1 != strlen(a1)) {\n    return -1;\n  } else if (!v1) {\n    return 0;\n  } else {\n    v3 = 0;\n    v2 = 0;\n    do {\n      if (a0[v3] != *((char *)(a1 + v3)))\n        v2 += 1;\n    } while ((v3 += 1, v1 != v3));\n    return v2;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strstrip_name_conflict(char *a0) {\n  unsigned long long v1; // rdx\n  unsigned long v2;      // rax\n  char v3[2];            // rbx, Other Possible Types: unsigned long\n  unsigned long v6;      // rbx, Other Possible Types: unsigned long long\n\n  v1 = strlen(a0);\n  if (!v1)\n    return a0;\n  v3 = &a0[v1 + 1];\n  if (v3 >= a0) {\n    while ((*((char *)(*((long long *)&__ctype_b_loc()) + (*((char *)v3) << 1) +\n                       1)) &\n            32) &&\n           (v3 -= 1, v3 >= a0))\n      ;\n  }\n  *((char *)(v3 + 1)) = 0;\n  v6 = *(a0);\n  if (!(char)v6)\n    return a0;\n  v2 = a0;\n  while ((*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v6 << 1) + 1)) &\n          32) &&\n         (v2 += 1, v6 = (unsigned long long)(char)*((char *)v2), (char)v6))\n    ;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph6t1r7ln/strstrip_name_conflict.c:27:8: error: array type 'char[2]' is not assignable\n   27 |     v3 = &a0[v1 + 1];\n      |     ~~ ^\n/tmp/tmph6t1r7ln/strstrip_name_conflict.c:30:43: error: cannot take the address of an rvalue\nof type 'int' 30 |         while ((*((char *)(*((long long *)&__ctype_b_loc()) +\n(*((char *)v3) << 1) + 1)) & 32) && (v3 -= 1, v3 >= a0)) | ^~~~~~~~~~~~~~~~\n/tmp/tmph6t1r7ln/strstrip_name_conflict.c:30:103: error: invalid operands to binary expression\n('char[2]' and 'int') 30 |         while ((*((char *)(*((long long\n*)&__ctype_b_loc()) + (*((char *)v3) << 1) + 1)) & 32) && (v3 -= 1, v3 >= a0))\n      | ~~ ^  ~ /tmp/tmph6t1r7ln/strstrip_name_conflict.c:38:39: error: cannot take the\naddress of an rvalue of type 'int' 38 |     while ((*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v6 << 1) + 1)) & 32) && (v2 += 1, v6 = (unsigned\nlong long)(char)*((char *)v2), (char)v6)) | ^~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strrev_name_conflict(char *a0) {\n  unsigned long long v1; // rbp\n  char *v2;              // rax\n  char *v3;              // rdx, Other Possible Types: unsigned long\n  char *v4;              // rcx, Other Possible Types: unsigned long\n  char *v5;              // rsi\n\n  v1 = strlen(a0);\n  v2 = calloc(v1 + 1, 1);\n  if (!v2) {\n    return v2;\n  } else if (!v1) {\n    return v2;\n  } else {\n    v3 = &a0[v1 + 1];\n    v4 = v2;\n    do {\n      *((char *)v4) = *((char *)v3);\n      v5 = v3;\n      v3 -= 1;\n      v4 += 1;\n    } while (v5 != a0);\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long count_nucleotides_name_conflict(unsigned long long a0[5], char *a1) {\n  char *v0;              // [bp-0x50], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x48], Other Possible Types: unsigned long\n  char *v2;              // [bp-0x40], Other Possible Types: unsigned long\n  char *v4;              // rax\n  char *v5;              // rbx\n  unsigned long long v6; // rdx\n  unsigned long v7;      // rax\n  char *v8;              // r14, Other Possible Types: unsigned long\n  char *v9; // r15, Other Possible Types: unsigned long, unsigned long long\n\n  v4 = strlen(a1);\n  v5 = v4;\n  if (!v4) {\n    v2 = v4;\n    v1 = v4;\n    v0 = v4;\n    v8 = v4;\n    v9 = v4;\n  } else {\n    v2 = 0;\n    v1 = 0;\n    v0 = 0;\n    v8 = 0;\n    v9 = 0;\n    v7 = 0;\n    do {\n      v6 = a1[v7];\n      switch ((char)v6) {\n      case 65:\n      case 97:\n        v9 += 1;\n        break;\n      case 67:\n      case 99:\n        v8 += 1;\n        break;\n      case 71:\n      case 103:\n        v0 += 1;\n        break;\n      case 84:\n      case 116:\n        v1 += 1;\n        break;\n      case 85:\n      case 117:\n        v2 += 1;\n        break;\n      default:\n        fprintf(stderr @GLIBC_2.2.5,\n                \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\",\n                (unsigned int)v6);\n        v7 = v5;\n        break;\n      }\n      v7 += 1;\n    } while (v7 < v5);\n  }\n  a0[0] = v9;\n  a0[1] = v8;\n  a0[2] = v0;\n  a0[3] = v1;\n  a0[4] = v2;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkbma8yi5/count_nucleotides_name_conflict.c:17:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpkbma8yi5/count_nucleotides_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpkbma8yi5/count_nucleotides_name_conflict.c:70:31: error: expected ')'\n   70 |                 fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict():\nUnexpected character: '%c'\\n\", (unsigned int)v6); | ^\n/tmp/tmpkbma8yi5/count_nucleotides_name_conflict.c:70:24: note: to match this '('\n   70 |                 fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict():\nUnexpected character: '%c'\\n\", (unsigned int)v6); |                        ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long transcribe_dna_to_rna_name_conflict(char *a0) {\n  char *v1;              // rbx\n  unsigned long long v2; // rax\n  char *v3;              // rdx, Other Possible Types: unsigned long\n  char v5;               // cl\n\n  v1 = strdup(a0);\n  v2 = strlen(v1);\n  if (!v2)\n    return v1;\n  v3 = v1;\n  do {\n    v5 = *((char *)v3);\n    if ((v5 & 223) == 84)\n      *((char *)v3) = v5 + 1;\n  } while ((v3 += 1, v3 != v2 + v1));\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long get_dna_complement_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n  char *v4;              // rsi\n  char v5;               // dl\n  char *v6;              // rcx, Other Possible Types: unsigned long\n\n  v1 = strdup(a0);\n  v2 = strlen(v1);\n  if (!v2)\n    return v1;\n  v6 = v1;\n  while (true) {\n    v4 = v6;\n    switch (*((char *)v6)) {\n    case 65:\n    case 97:\n      v5 = 84;\n      break;\n    case 67:\n    case 99:\n      v5 = 71;\n      break;\n    case 71:\n    case 103:\n      v5 = 67;\n      break;\n    case 84:\n    case 116:\n      v5 = 65;\n      break;\n    default:\n      free(v1);\n      return 0;\n    }\n    *(v4) = v5;\n    v6 += 1;\n    if (v6 == &v1[v2])\n      return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamming_distance_name_conflict(char *a0, unsigned long a1) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rdx, Other Possible Types: unsigned long long\n  unsigned long v3;      // rax\n\n  v1 = strlen(a0);\n  if (v1 != strlen(a1)) {\n    return -1;\n  } else if (!v1) {\n    return 0;\n  } else {\n    v3 = 0;\n    v2 = 0;\n    do {\n      if (a0[v3] != *((char *)(a1 + v3)))\n        v2 += 1;\n    } while ((v3 += 1, v1 != v3));\n    return v2;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strstrip_name_conflict(char *a0) {\n  unsigned long long v1; // rdx\n  unsigned long v2;      // rax\n  char v3[2];            // rbx, Other Possible Types: unsigned long\n  unsigned long v6;      // rbx, Other Possible Types: unsigned long long\n\n  v1 = strlen(a0);\n  if (!v1)\n    return a0;\n  v3 = &a0[v1 + 1];\n  if (v3 >= a0) {\n    while ((*((char *)(*((long long *)&__ctype_b_loc()) + (*((char *)v3) << 1) +\n                       1)) &\n            32) &&\n           (v3 -= 1, v3 >= a0))\n      ;\n  }\n  *((char *)(v3 + 1)) = 0;\n  v6 = *(a0);\n  if (!(char)v6)\n    return a0;\n  v2 = a0;\n  while ((*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v6 << 1) + 1)) &\n          32) &&\n         (v2 += 1, v6 = (unsigned long long)(char)*((char *)v2), (char)v6))\n    ;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp119ls1dy/strstrip_name_conflict.c:27:8: error: array type 'char[2]' is not assignable\n   27 |     v3 = &a0[v1 + 1];\n      |     ~~ ^\n/tmp/tmp119ls1dy/strstrip_name_conflict.c:30:43: error: cannot take the address of an rvalue\nof type 'int' 30 |         while ((*((char *)(*((long long *)&__ctype_b_loc()) +\n(*((char *)v3) << 1) + 1)) & 32) && (v3 -= 1, v3 >= a0)) | ^~~~~~~~~~~~~~~~\n/tmp/tmp119ls1dy/strstrip_name_conflict.c:30:103: error: invalid operands to binary expression\n('char[2]' and 'int') 30 |         while ((*((char *)(*((long long\n*)&__ctype_b_loc()) + (*((char *)v3) << 1) + 1)) & 32) && (v3 -= 1, v3 >= a0))\n      | ~~ ^  ~ /tmp/tmp119ls1dy/strstrip_name_conflict.c:38:39: error: cannot take the\naddress of an rvalue of type 'int' 38 |     while ((*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v6 << 1) + 1)) & 32) && (v2 += 1, v6 = (unsigned\nlong long)(char)*((char *)v2), (char)v6)) | ^~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strrev_name_conflict(char *a0) {\n  unsigned long long v1; // rbp\n  char *v2;              // rax\n  char *v3;              // rdx, Other Possible Types: unsigned long\n  char *v4;              // rcx, Other Possible Types: unsigned long\n  char *v5;              // rsi\n\n  v1 = strlen(a0);\n  v2 = calloc(v1 + 1, 1);\n  if (!v2) {\n    return v2;\n  } else if (!v1) {\n    return v2;\n  } else {\n    v3 = &a0[v1 + 1];\n    v4 = v2;\n    do {\n      *((char *)v4) = *((char *)v3);\n      v5 = v3;\n      v3 -= 1;\n      v4 += 1;\n    } while (v5 != a0);\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long count_nucleotides_name_conflict(unsigned long long a0[5], char *a1) {\n  char *v0;              // [bp-0x50], Other Possible Types: unsigned long\n  char *v1;              // [bp-0x48], Other Possible Types: unsigned long\n  char *v2;              // [bp-0x40], Other Possible Types: unsigned long\n  char *v4;              // rax\n  char *v5;              // rbx\n  unsigned long long v6; // rdx\n  unsigned long v7;      // rax\n  char *v8;              // r14, Other Possible Types: unsigned long\n  char *v9;              // r15, Other Possible Types: unsigned long\n\n  v4 = strlen(a1);\n  v5 = v4;\n  if (!v4) {\n    v2 = v4;\n    v1 = v4;\n    v0 = v4;\n    v8 = v4;\n    v9 = v4;\n  } else {\n    v2 = 0;\n    v1 = 0;\n    v0 = 0;\n    v8 = 0;\n    v9 = 0;\n    v7 = 0;\n    do {\n      v6 = a1[v7];\n      switch ((char)v6) {\n      case 65:\n      case 97:\n        v9 += 1;\n        break;\n      case 67:\n      case 99:\n        v8 += 1;\n        break;\n      case 71:\n      case 103:\n        v0 += 1;\n        break;\n      case 84:\n      case 116:\n        v1 += 1;\n        break;\n      case 85:\n      case 117:\n        v2 += 1;\n        break;\n      default:\n        fprintf(stderr @GLIBC_2.2.5,\n                \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\",\n                (unsigned int)v6);\n        v7 = v5;\n        break;\n      }\n      v7 += 1;\n    } while (v7 < v5);\n  }\n  a0[0] = v9;\n  a0[1] = v8;\n  a0[2] = v0;\n  a0[3] = v1;\n  a0[4] = v2;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaupr8wdk/count_nucleotides_name_conflict.c:17:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpaupr8wdk/count_nucleotides_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpaupr8wdk/count_nucleotides_name_conflict.c:70:31: error: expected ')'\n   70 |                 fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict():\nUnexpected character: '%c'\\n\", (unsigned int)v6); | ^\n/tmp/tmpaupr8wdk/count_nucleotides_name_conflict.c:70:24: note: to match this '('\n   70 |                 fprintf(stderr@GLIBC_2.2.5, \"count_nucleotides_name_conflict():\nUnexpected character: '%c'\\n\", (unsigned int)v6); |                        ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long transcribe_dna_to_rna_name_conflict(char *a0) {\n  char *v1;              // rbx\n  unsigned long long v2; // rax\n  char *v3;              // rdx, Other Possible Types: unsigned long\n  char v5;               // cl\n\n  v1 = strdup(a0);\n  v2 = strlen(v1);\n  if (!v2)\n    return v1;\n  v3 = v1;\n  do {\n    v5 = *((char *)v3);\n    if ((v5 & 223) == 84)\n      *((char *)v3) = v5 + 1;\n  } while ((v3 += 1, v3 != v2 + v1));\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nlong long get_dna_complement_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n  char *v4;              // rsi\n  char v5;               // dl\n  char *v6;              // rcx, Other Possible Types: unsigned long\n\n  v1 = strdup(a0);\n  v2 = strlen(v1);\n  if (!v2)\n    return v1;\n  v6 = v1;\n  while (true) {\n    v4 = v6;\n    switch (*((char *)v6)) {\n    case 65:\n    case 97:\n      v5 = 84;\n      break;\n    case 67:\n    case 99:\n      v5 = 71;\n      break;\n    case 71:\n    case 103:\n      v5 = 67;\n      break;\n    case 84:\n    case 116:\n      v5 = 65;\n      break;\n    default:\n      free(v1);\n      return 0;\n    }\n    *(v4) = v5;\n    v6 += 1;\n    if (v6 == &v1[v2])\n      return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamming_distance_name_conflict(char *a0, unsigned long a1) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rdx, Other Possible Types: unsigned long long\n  unsigned long v3;      // rax\n\n  v1 = strlen(a0);\n  if (v1 != strlen(a1)) {\n    return -1;\n  } else if (!v1) {\n    return 0;\n  } else {\n    v3 = 0;\n    v2 = 0;\n    do {\n      if (a0[v3] != *((char *)(a1 + v3)))\n        v2 += 1;\n    } while ((v3 += 1, v1 != v3));\n    return v2;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strstrip_name_conflict(char *a0) {\n  unsigned long long v1; // rdx\n  unsigned long v2;      // rax\n  char v3[2];            // rbx, Other Possible Types: unsigned long\n  unsigned long v6;      // rbx, Other Possible Types: unsigned long long\n\n  v1 = strlen(a0);\n  if (!v1)\n    return a0;\n  v3 = &a0[v1 + 1];\n  if (v3 >= a0) {\n    while ((*((char *)(*((long long *)&__ctype_b_loc()) + (*((char *)v3) << 1) +\n                       1)) &\n            32) &&\n           (v3 -= 1, v3 >= a0))\n      ;\n  }\n  *((char *)(v3 + 1)) = 0;\n  v6 = *(a0);\n  if (!(char)v6)\n    return a0;\n  v2 = a0;\n  while ((*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v6 << 1) + 1)) &\n          32) &&\n         (v2 += 1, v6 = (unsigned long long)(char)*((char *)v2), (char)v6))\n    ;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppado1dj5/strstrip_name_conflict.c:27:8: error: array type 'char[2]' is not assignable\n   27 |     v3 = &a0[v1 + 1];\n      |     ~~ ^\n/tmp/tmppado1dj5/strstrip_name_conflict.c:30:43: error: cannot take the address of an rvalue\nof type 'int' 30 |         while ((*((char *)(*((long long *)&__ctype_b_loc()) +\n(*((char *)v3) << 1) + 1)) & 32) && (v3 -= 1, v3 >= a0)) | ^~~~~~~~~~~~~~~~\n/tmp/tmppado1dj5/strstrip_name_conflict.c:30:103: error: invalid operands to binary expression\n('char[2]' and 'int') 30 |         while ((*((char *)(*((long long\n*)&__ctype_b_loc()) + (*((char *)v3) << 1) + 1)) & 32) && (v3 -= 1, v3 >= a0))\n      | ~~ ^  ~ /tmp/tmppado1dj5/strstrip_name_conflict.c:38:39: error: cannot take the\naddress of an rvalue of type 'int' 38 |     while ((*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v6 << 1) + 1)) & 32) && (v2 += 1, v6 = (unsigned\nlong long)(char)*((char *)v2), (char)v6)) | ^~~~~~~~~~~~~~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strrev_name_conflict(char *a0) {\n  unsigned long long v1; // rbp\n  char *v2;              // rax\n  char *v3;              // rdx, Other Possible Types: unsigned long\n  char *v4;              // rcx, Other Possible Types: unsigned long\n  char *v5;              // rsi\n\n  v1 = strlen(a0);\n  v2 = calloc(v1 + 1, 1);\n  if (!v2) {\n    return v2;\n  } else if (!v1) {\n    return v2;\n  } else {\n    v3 = &a0[v1 + 1];\n    v4 = v2;\n    do {\n      *((char *)v4) = *((char *)v3);\n      v5 = v3;\n      v3 -= 1;\n      v4 += 1;\n    } while (v5 != a0);\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rot13_name_conflict(unsigned long a0) {\n  if ((*((char *)(*((long long *)&__ctype_b_loc()) + (a0 << 1) + 1)) & 4))\n    return *((char *)(4202463 + a0));\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm27sbrg5/rot13_name_conflict.c:19:36: error: cannot take the address of an rvalue of\ntype 'int' 19 |     if ((*((char *)(*((long long *)&__ctype_b_loc()) + (a0 << 1)\n+ 1)) & 4)) |                                    ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(rot13)(long long);\n\nlong long srot13_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n  char *v2;              // rbx, Other Possible Types: unsigned long\n\n  v1 = strlen(a0);\n  if ((unsigned int)v1 <= 0)\n    return a0;\n  v2 = a0;\n  do {\n    *((char *)v2) = rot13(*((char *)v2));\n    v2 += 1;\n  } while (v2 != &a0[1 + v1 + 1]);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rot13_name_conflict(unsigned long a0) {\n  if ((*((char *)(*((long long *)&__ctype_b_loc()) + (a0 << 1) + 1)) & 4))\n    return *((char *)(4203103 + a0));\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpc5tq8zea/rot13_name_conflict.c:19:36: error: cannot take the address of an rvalue of\ntype 'int' 19 |     if ((*((char *)(*((long long *)&__ctype_b_loc()) + (a0 << 1)\n+ 1)) & 4)) |                                    ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(rot13)(long long);\n\nlong long srot13_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n  char *v2;              // rbx, Other Possible Types: unsigned long\n\n  v1 = strlen(a0);\n  if ((unsigned int)v1 <= 0)\n    return a0;\n  v2 = a0;\n  do {\n    *((char *)v2) = rot13(*((char *)v2));\n    v2 += 1;\n  } while (v2 != &a0[1 + v1 + 1]);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *s_tolower(char *s) {\n    char *cp;\n    if (s == ((void *)0))\n        return ((void *)0);\n    if (!*s)\n        return s;\n    for (cp = s; (*cp = tolower(*cp)); cp++)\n        ;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_tolower_loc)();\n\nlong long s_tolower_name_conflict(char *a0) {\n  char *v2; // rdx, Other Possible Types: unsigned long\n  char v3;  // cl\n\n  if (!a0) {\n    return a0;\n  } else if (!*(a0)) {\n    return a0;\n  } else {\n    v2 = a0;\n    while (true) {\n      v3 = *(\n          (int *)(*((long long *)&__ctype_tolower_loc()) + *((char *)v2) * 4));\n      *((char *)v2) = v3;\n      if (!v3)\n        break;\n      v2 += 1;\n    }\n    return a0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxoqk00ll/s_tolower_name_conflict.c:36:43: error: cannot take the address of an rvalue\nof type 'char *' 36 |             v3 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + *((char *)v2) * 4)); | ^~~~~~~~~~~~~~~~~~~~~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":0,"function":"int s_tokenize(char *s, char *tokens[], int ntoks, const char *delims) {\n    register int i;\n    if (s == ((void *)0) || tokens == ((void *)0) || delims == ((void *)0) || !*s || !*delims || ntoks < 1)\n        return 0;\n    tokens[0] = strtok(s, delims);\n    if (tokens[0] == ((void *)0))\n        return 0;\n    for (i = 1; i < ntoks && (tokens[i] = strtok(((void *)0), delims)) != ((void *)0); i++)\n        ;\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok)(char *, char *);\n\nlong long s_tokenize(char *a0, unsigned long long *a1, unsigned long a2,\n                     char *a3) {\n  unsigned long v1;       // r12\n  unsigned long long v2;  // rax\n  unsigned long long v3;  // rax\n  unsigned long long *v4; // rbx, Other Possible Types: unsigned long\n\n  if (!(a1 && a3 && a0))\n    return 0;\n  if (!*(a0))\n    return 0;\n  if (!(*(a3) && (unsigned int)a2 > 0))\n    return 0;\n  v2 = strtok(a0, a3);\n  *(a1) = v2;\n  if (!v2) {\n    return 0;\n  } else if ((unsigned int)a2 <= 1) {\n    return 1;\n  } else {\n    v4 = a1 + 1;\n    v1 = 1;\n    while (v3) {\n      v3 = strtok(NULL, a3);\n      *((unsigned long long *)v4) = v3;\n      v1 = (unsigned int)v1 + 1;\n      v4 += 8;\n      if ((unsigned int)a2 == (unsigned int)v1)\n        return a2;\n    }\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":0,"function":"static inline size_t SCREEN(size_t x, size_t y) {\n    y = min(y, (terminal.rows - 1));\n    if (between(y, terminal.page.top, terminal.page.bottom)) {\n        return PAGE(x, y - terminal.page.top);\n    } else {\n        return y * terminal.cols + min(x, (terminal.cols - 1));\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool term_flushlines() {\n    size_t row;\n    size_t col_start, col_stop, col_this;\n    struct glyph_t *start, *this;\n    bool retval = 0;\n    wchar_t *buffer = emalloc(terminal.cols * sizeof (*buffer));\n    for (row = 0; row < terminal.rows; row++) {\n        col_start = terminal.dirty[row].left;\n        col_stop = terminal.dirty[row].right;\n        start = terminal.text + SCREEN(col_start, row);\n        for (col_this = col_start , this = start; col_this < col_stop; col_this++ , this++) {\n            buffer[col_this] = this->c;\n            if ((start->c != '\\x00') != (this->c != '\\x00') || start->background != this->background || start->foreground != this->foreground || start->attr != this->attr) {\n                term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n                col_start = col_this;\n                start = this;\n                retval = 1;\n            }\n        }\n        if (col_stop > col_start) {\n            term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n            retval = 1;\n        }\n        terminal.dirty[row].left = terminal.dirty[row].right = 0;\n    }\n    free(buffer);\n    return retval;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"size_t term_write(char *utf8s) {\n    size_t n;\n    wchar_t ucs2char;\n    char *utf8s_orig = utf8s;\n    do {\n        if (*utf8s == '\\x00') {\n            break;\n        } else if (term_do_control_char(*utf8s)) {\n            n = 1;\n        } else if ((n = utf8towchar(utf8s, &ucs2char)) > 0) {\n            term_writechar(ucs2char);\n        }\n        utf8s += n;\n    } while (n);\n    return utf8s - utf8s_orig;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(term_do_control_char)(long long);\nlong long(utf8towchar)(long long, long long);\nlong long(term_write_name_conflictchar)(long long);\n\nlong long term_write_name_conflict(char *a0) {\n  char v0;               // [bp-0x2c]\n  char *v2;              // r12\n  char *v3;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v4; // rdi\n  unsigned long v5;      // rbp, Other Possible Types: unsigned long long\n\n  v2 = a0;\n  for (v3 = a0; (char)v4; v3 += v5) {\n    v4 = *((char *)v3);\n    v5 = 1;\n    if (!(char)term_do_control_char(v4)) {\n      v5 = utf8towchar(v3, &v0);\n      if (!v5)\n        return v3 - v2;\n      term_write_name_conflictchar(*((int *)&v0));\n    }\n  }\n  return v3 - v2;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"bool term_handle_keypress(KeySym key, uint32_t mod) {\n    size_t i;\n    if (mod & (1 << 3)) {\n        term_cb->write_host(\"\\033\", 1);\n    }\n    if (key == 65293) {\n        if (terminal.crlf) {\n            term_cb->write_host(\"\\r\\n\", 2);\n        } else {\n            term_cb->write_host(\"\\r\", 1);\n        }\n        return 1;\n    }\n    for (i = 0; i < (sizeof (keymap) / sizeof (keymap[0])); i++) {\n        if (keymap[i].key == key && keymap[i].mod == (mod & ~(1 << 3))) {\n            term_cb->write_host(keymap[i].out, strlen(keymap[i].out));\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint term_cb; // add global variable by heuristics\nint term_cb; // add global variable by heuristics\nint term_cb; // add global variable by heuristics\nint term_cb; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_2 {\n  unsigned long long field_0;\n  unsigned int field_8;\n} struct_2;\n\nextern unsigned long long g_40e0ea;\nextern char g_411e70;\nextern struct_2 keymap;\n\nlong long term_handle_keypress_name_conflict(unsigned long a0, unsigned long a1) {\n  struct_2 *v1; // rax, Other Possible Types: unsigned long\n  void *v2;     // rdx, Other Possible Types: unsigned long\n  char *v3;     // rbx\n\n  if (((char)a1 & 8))\n    term_cb->field_0(&g_40e0ea, 1);\n  v1 = &keymap.field_0;\n  v2 = 0;\n  if (a0 != 65293) {\n    while (true) {\n      if (*((long long *)v1) == a0 &&\n          *((int *)(v1 + 8)) == ((unsigned int)a1 & -9)) {\n        v3 = (&keymap.field_0)[2 + 4 * v2];\n        term_cb->field_0(v3, strlen(v3));\n        return 1;\n      }\n      v2 += 1;\n      v1 += 32;\n      if (v2 == 90)\n        return 0;\n    }\n  } else if (g_411e70) {\n    term_cb->field_0(\"\\r\\n\", 2);\n    return g_411e70;\n  } else {\n    term_cb->field_0(\n        L\"\\r\\x7fsZAC\"\n        L\"D~ed~1~\"\n        L\"p\\u2437M\\u2438D\\u2432$\"\n        L\"C\\u2435V\\u2436T^^^@@\"\n        L\"\"\n        L\"0~\"\n        L\"23456~\"\n        L\"8~0~2~\"\n        L\"45678~\"\n        L\"0~2~4~\"\n        L\"67890~\"\n        L\"2~4~6~\"\n        L\"8\",\n        1);\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmy2fs44v/term_handle_keypress_name_conflict.c:37:18: error: member reference type\n'int' is not a pointer 37 |         term_cb->field_0(&g_40e0ea, 1); | ~~~~~~~  ^\n/tmp/tmpmy2fs44v/term_handle_keypress_name_conflict.c:46:46: error: invalid operands to binary\nexpression ('int' and 'void *') 46 |                 v3 = (&keymap.field_0)[2 +\n4 * v2]; |                                            ~ ^ ~~\n/tmp/tmpmy2fs44v/term_handle_keypress_name_conflict.c:47:26: error: member reference type\n'int' is not a pointer 47 |                 term_cb->field_0(v3, strlen(v3)); |\n~~~~~~~  ^ /tmp/tmpmy2fs44v/term_handle_keypress_name_conflict.c:58:18: error: member\nreference type 'int' is not a pointer 58 |         term_cb->field_0(\"\\r\\n\", 2);\n      |         ~~~~~~~  ^\n/tmp/tmpmy2fs44v/term_handle_keypress_name_conflict.c:63:18: error: member reference type\n'int' is not a pointer 63 |\nterm_cb->field_0(L\"\\r\\x7fsZACD~ed~1~p\\u2437M\\u2438D\\u2432$C\\u2435V\\u2436T^^^@@0~23456~8~0~2~45678~0~2~4~67890~2~4~6~8\",\n1); |         ~~~~~~~  ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_collect)(long long);\nlong long(esc_clear)();\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct struct_2 {\n  char field_0;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  char field_10;\n} struct_0;\n\nextern char __func__ .1;\nextern struct_1 *dispatch;\nextern struct_0 esc_seq;\nextern char g_40ea08;\nextern char g_411f30;\nextern unsigned long long g_412330;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long esc_state_csi_name_conflict(unsigned long a0) {\n  struct_0 *v0;           // [bp-0x88]\n  char v1;                // [bp-0x7f]\n  char v2;                // [bp-0x7e]\n  char v3;                // [bp-0x7d]\n  unsigned int v4;        // [bp-0x7c]\n  char v5;                // [bp-0x78], Other Possible Types: unsigned int\n  char v6;                // [bp-0x74]\n  char v7;                // [bp-0x38]\n  unsigned long v9;       // r15, Other Possible Types: unsigned long long\n  struct_2 *v11;          // rax, Other Possible Types: unsigned long\n  unsigned long v13;      // r15\n  unsigned long long v14; // rax\n  void *v15;              // rbp, Other Possible Types: unsigned long\n  struct_0 *v16;          // rbx, Other Possible Types: unsigned long\n  unsigned long v17;      // rax\n\n  v9 = (char)a0;\n  if (a0 - 64 <= 62) {\n    v11 = &v5;\n    do {\n      *((int *)v11) = -1;\n      v11 = &v6;\n    } while (&v7 != v11);\n    if (!g_412330) {\n      v5 = 0;\n      v1 = 0;\n    } else {\n      v16 = &esc_seq.padding_0[0];\n      v2 = 0;\n      v3 = 0;\n      v1 = 0;\n      v15 = 0;\n      v4 = v9;\n      v13 = 0;\n      do {\n        v0 = v16;\n        v14 = *((char *)(v16 + 16));\n        if ((*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v14 << 1) +\n                        1)) &\n             8)) {\n          v15 = v14 + v15 * 10 - 48;\n        } else {\n          if ((char)v14 != 59) {\n            if (v14 - 60 > 3) {\n              if (v14 - 32 > 15) {\n                if ((char)v14 == 58) {\n                  fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                          &g_40ea08);\n                  fprintf(stderr @GLIBC_2.2.5, \": in code %s\", &g_411f30);\n                  fputc(10, stderr @GLIBC_2.2.5);\n                  v2 = 1;\n                } else {\n                  fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                          &g_40ea08);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Error parsing params: %s, ignoring 0x%02x\",\n                          &g_411f30, v0->field_10);\n                  fputc(10, stderr @GLIBC_2.2.5);\n                }\n              } else {\n                if (!v3) {\n                  v3 = v14;\n                } else {\n                  fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                          &g_40ea08);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Intermediate character already set %s\", &g_411f30);\n                  fputc(10, stderr @GLIBC_2.2.5);\n                  v2 = 1;\n                }\n              }\n            } else {\n              if (!v1) {\n                v1 = v14;\n              } else {\n                fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                        &g_40ea08);\n                fprintf(stderr @GLIBC_2.2.5, \"Private marker already set %s\",\n                        &g_411f30);\n                fputc(10, stderr @GLIBC_2.2.5);\n                v2 = 1;\n              }\n            }\n          } else {\n            if (v13 <= 15) {\n              *((unsigned int *)&(&v5)[4 * v13]) = v15;\n              v13 += 1;\n              v15 = 0;\n            } else {\n              fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                      &g_40ea08);\n              fprintf(stderr @GLIBC_2.2.5, \"Too many parameters: %s\",\n                      &g_411f30);\n              fputc(10, stderr @GLIBC_2.2.5);\n              v2 = 1;\n              v15 = 0;\n            }\n          }\n        }\n      } while ((v16 += 1, v16 - 4267808 < g_412330));\n      v17 = v13;\n      v9 = v4;\n      if (v17 > 15) {\n        fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                &g_40ea08);\n        fprintf(stderr @GLIBC_2.2.5, \"Too many parameters: %s\", &g_411f30);\n        fputc(10, stderr @GLIBC_2.2.5);\n        esc_clear();\n        return 1;\n      }\n      *((unsigned int *)&(&v5)[4 * v17]) = v15;\n      if (v2) {\n        esc_clear();\n        return 1;\n      }\n    }\n    if (dispatch)\n      dispatch(v9, &v5, v1);\n    esc_clear();\n    return 1;\n  } else if ((char)a0 == 127) {\n    return 1;\n  } else if ((char)a0 <= 31) {\n    return 0;\n  } else {\n    esc_collect(v9);\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:78:22: error: type name requires a specifier or\nqualifier 78 |             } __value; |                      ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:85:22: error: type name requires a specifier or\nqualifier 85 |             } __value; |                      ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:18:6: error: conflicting types for 'fputc'\n   18 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:117:13: error: expected identifier or '('\n  117 | extern char __func__.1;\n      |             ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:118:8: error: unknown type name 'struct_1'\n  118 | extern struct_1 *dispatch;\n      |        ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:123:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 123 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:123:22: error: expected ';' after top level\ndeclarator 123 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:170:48: error: cannot take the address of an\nrvalue of type 'int' 170 |                 if ((*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v14 << 1) + 1)) & 8)) | ^~~~~~~~~~~~~~~~\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:172:37: error: invalid operands to binary\nexpression ('void *' and 'int') 172 |                     v15 = v14 + v15 * 10 -\n48; |                                 ~~~ ^ ~~\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:184:51: error: expected ')'\n  184 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_40ea08); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:184:44: note: to match this '('\n  184 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_40ea08); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:185:51: error: expected ')'\n  185 |                                     fprintf(stderr@GLIBC_2.2.5, \": in\ncode %s\", &g_411f30); |                                                   ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:185:44: note: to match this '('\n  185 |                                     fprintf(stderr@GLIBC_2.2.5, \": in\ncode %s\", &g_411f30); |                                            ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:186:53: error: expected ')'\n  186 |                                     fputc(10, stderr@GLIBC_2.2.5);\n      |                                                     ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:186:42: note: to match this '('\n  186 |                                     fputc(10, stderr@GLIBC_2.2.5);\n      |                                          ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:191:51: error: expected ')'\n  191 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_40ea08); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:191:44: note: to match this '('\n  191 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_40ea08); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:192:51: error: expected ')'\n  192 |                                     fprintf(stderr@GLIBC_2.2.5, \"Error\nparsing params: %s, ignoring 0x%02x\", &g_411f30, v0->field_10); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:192:44: note: to match this '('\n  192 |                                     fprintf(stderr@GLIBC_2.2.5, \"Error\nparsing params: %s, ignoring 0x%02x\", &g_411f30, v0->field_10); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:193:53: error: expected ')'\n  193 |                                     fputc(10, stderr@GLIBC_2.2.5);\n      |                                                     ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:193:42: note: to match this '('\n  193 |                                     fputc(10, stderr@GLIBC_2.2.5);\n      |                                          ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:204:51: error: expected ')'\n  204 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_40ea08); | ^\n/tmp/tmpwjjb6_66/esc_state_csi_name_conflict.c:204:44: note: to match this '('\n  204 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_40ea08); | ^ fatal error: too many errors emitted,\nstopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\nlong long(esc_collect)(long long);\n\nlong long esc_state_osc_name_conflict(unsigned long long a0) {\n  if ((char)a0 == 7) {\n    esc_clear();\n    return 1;\n  } else if ((char)a0 <= 31) {\n    return 1;\n  } else {\n    esc_collect(a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long esc_state_wait_for_ST_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint esc_seq;          // add global variable by heuristics\nint esc_state_escape; // add global variable by heuristics\nint esc_seq;          // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\n\nextern struct_0 *esc_seq;\n\nlong long esc_handle_name_conflict(unsigned long long a0) {\n  int tmp_67;            // tmp #67\n  unsigned long long v1; // rax\n\n  v1 = a0 - 26;\n  tmp_67 = (char)v1;\n  *((char *)&v1) = (char)v1 <= 1 | (char)a0 == 24;\n  if (!(tmp_67 > 1) || !((char)a0 != 24)) {\n    esc_clear();\n    if ((char)a0 == 27) {\n      esc_seq = &esc_state_escape;\n      return v1;\n    }\n    return v1;\n  } else if (!esc_seq) {\n    return v1;\n  } else {\n    return esc_seq(a0);\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8tu952f1/esc_handle_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *esc_seq; |        ^~~~~~~~ |        struct\n/tmp/tmp8tu952f1/esc_handle_name_conflict.c:21:8: error: declaration of anonymous struct must\nbe a definition /tmp/tmp8tu952f1/esc_handle_name_conflict.c:47:23: error: called object type\n'int' is not a function or function pointer 47 |         return esc_seq(a0); |\n~~~~~~~^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static inline wchar_t O(size_t col, size_t row) {\n    oflush();\n    return output.text[oindex(col, row)];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BO_name_conflictT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BO_name_conflictT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(term_flush)();\nlong long(oindex)(long long, long long);\n\nextern unsigned long long output;\n\nlong long O_name_conflict(unsigned long long a0, unsigned long long a1) {\n  term_flush();\n  return *((int *)(output + oindex(a0, a1) * 4));\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t F(size_t col, size_t row) {\n    oflush();\n    return output.fgs[oindex(col, row)];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t B(size_t col, size_t row) {\n    oflush();\n    return output.bgs[oindex(col, row)];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline uint32_t A(size_t col, size_t row) {\n    oflush();\n    return output.attrs[oindex(col, row)];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"bool oisempty() {\n    size_t x, y;\n    for (y = 0; y < output.rows; y++) {\n        for (x = 0; x < output.cols; x++) {\n            if (O(x, y) != L'\\x00') {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(term_flush)();\nlong long(oindex)(long long, long long);\n\nextern unsigned long long g_411da0;\nextern unsigned long long g_411da8;\nextern unsigned long long output;\n\nlong long oisempty_name_conflict() {\n  void *v1; // r13, Other Possible Types: unsigned long long, unsigned long\n\n  v1 = 0;\n  if (!g_411da8)\n    return 1;\n  do {\n    if (g_411da0) {\n      do {\n        term_flush();\n        if (*((int *)(output + (oindex(0, v1) << 2))))\n          return 0;\n      } while ((v1 += 1, v1 < g_411da8));\n    }\n  } while ((v1 += 1, v1 < g_411da8));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_reset\");\n        char *message = test_reset();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_movement\");\n        char *message = test_movement();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_crlf\");\n        char *message = test_crlf();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_line\");\n        char *message = test_erase_line();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_display\");\n        char *message = test_erase_display();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_newline\");\n        char *message = test_newline();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_control_characters\");\n        char *message = test_control_characters();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_ignored_controls\");\n        char *message = test_ignored_controls();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_statusreport\");\n        char *message = test_statusreport();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_DECALN\");\n        char *message = test_DECALN();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_scrollregion\");\n        char *message = test_scrollregion();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_wraparound\");\n        char *message = test_wraparound();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_editing\");\n        char *message = test_editing();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_repeat\");\n        char *message = test_repeat();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_col_modes\");\n        char *message = test_col_modes();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_style\");\n        char *message = test_style();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_tabstops\");\n        char *message = test_tabstops();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_cursor\");\n        char *message = test_cursor();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_reset)();\nlong long(test_movement)();\nlong long(test_crlf)();\nlong long(test_erase_line)();\nlong long(test_erase_display)();\nlong long(test_newline)();\nlong long(test_control_characters)();\nlong long(test_ignored_controls)();\nlong long(test_statusreport)();\nlong long(test_DECALN)();\nlong long(test_scrollregion)();\nlong long(test_wraparound)();\nlong long(test_editing)();\nlong long(test_repeat)();\nlong long(test_col_modes)();\nlong long(test_style)();\nlong long(test_tabstops)();\nlong long(test_cursor)();\n\nextern char g_40dcb1;\nextern char g_40dcc4;\nextern char g_40dcd2;\nextern char g_40dcdc;\nextern char g_40dcec;\nextern char g_40dcff;\nextern char g_40dd0c;\nextern char g_40dd24;\nextern char g_40dd3a;\nextern char g_40dd4c;\nextern char g_40dd58;\nextern char g_40dd6a;\nextern char g_40dd7a;\nextern char g_40dd87;\nextern char g_40dd93;\nextern char g_40dda2;\nextern char g_40ddad;\nextern char g_40ddbb;\nextern unsigned int tests_run;\n\nlong long run_tests_name_conflict() {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  printf(\"--> %s\\n\", &g_40dcb1);\n  v1 = test_reset();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dcc4);\n  v1 = test_movement();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dcd2);\n  v1 = test_crlf();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dcdc);\n  v1 = test_erase_line();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dcec);\n  v1 = test_erase_display();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dcff);\n  v1 = test_newline();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd0c);\n  v1 = test_control_characters();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd24);\n  v1 = test_ignored_controls();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd3a);\n  v1 = test_statusreport();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd4c);\n  v1 = test_DECALN();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd58);\n  v1 = test_scrollregion();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd6a);\n  v1 = test_wraparound();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd7a);\n  v1 = test_editing();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd87);\n  v1 = test_repeat();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dd93);\n  v1 = test_col_modes();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40dda2);\n  v1 = test_style();\n  tests_run = tests_run + 1;\n  if (v1)\n    return v1;\n  printf(\"--> %s\\n\", &g_40ddad);\n  v1 = test_tabstops();\n  tests_run = tests_run + 1;\n  if (!v1) {\n    printf(\"--> %s\\n\", &g_40ddbb);\n    v1 = test_cursor();\n    tests_run = tests_run + 1;\n    return v1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_collect)(long long);\nlong long(esc_clear)();\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  char field_10;\n} struct_0;\n\nextern char __func__ .1;\nextern struct_2 *dispatch;\nextern struct_0 esc_seq;\nextern char g_4040e8;\nextern char g_406570;\nextern unsigned long long g_406970;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long esc_state_csi_name_conflict(unsigned long a0) {\n  struct_0 *v0;           // [bp-0x88]\n  char v1;                // [bp-0x7f]\n  char v2;                // [bp-0x7e]\n  char v3;                // [bp-0x7d]\n  unsigned int v4;        // [bp-0x7c]\n  unsigned int v5;        // [bp-0x78], Other Possible Types: char\n  char v6;                // [bp-0x74]\n  char v7;                // [bp-0x38]\n  unsigned long v9;       // r15, Other Possible Types: unsigned long long\n  struct_1 *v11;          // rax, Other Possible Types: unsigned long\n  unsigned long v13;      // r15\n  unsigned long long v14; // rax\n  void *v15;              // rbp, Other Possible Types: unsigned long\n  struct_0 *v16;          // rbx, Other Possible Types: unsigned long\n  unsigned long v17;      // rax\n\n  v9 = (char)a0;\n  if (a0 - 64 <= 62) {\n    v11 = &v5;\n    do {\n      *((int *)v11) = -1;\n      v11 = &v6;\n    } while (&v7 != v11);\n    if (!g_406970) {\n      v5 = 0;\n      v1 = 0;\n    } else {\n      v16 = &esc_seq.padding_0[0];\n      v2 = 0;\n      v3 = 0;\n      v1 = 0;\n      v15 = 0;\n      v4 = v9;\n      v13 = 0;\n      do {\n        v0 = v16;\n        v14 = *((char *)(v16 + 16));\n        if ((*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v14 << 1) +\n                        1)) &\n             8)) {\n          v15 = v14 + v15 * 10 - 48;\n        } else {\n          if ((char)v14 == 59) {\n            if (v13 > 15) {\n              fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                      &g_4040e8);\n              fprintf(stderr @GLIBC_2.2.5, \"Too many parameters: %s\",\n                      &g_406570);\n              fputc(10, stderr @GLIBC_2.2.5);\n              v2 = 1;\n              v15 = 0;\n            } else {\n              *((unsigned int *)&(&v5)[4 * v13]) = v15;\n              v13 += 1;\n              v15 = 0;\n            }\n          } else {\n            if (v14 - 60 > 3) {\n              if (v14 - 32 > 15) {\n                if ((char)v14 != 58) {\n                  fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                          &g_4040e8);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Error parsing params: %s, ignoring 0x%02x\",\n                          &g_406570, v0->field_10);\n                  fputc(10, stderr @GLIBC_2.2.5);\n                } else {\n                  fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                          &g_4040e8);\n                  fprintf(stderr @GLIBC_2.2.5, \": in code %s\", &g_406570);\n                  fputc(10, stderr @GLIBC_2.2.5);\n                  v2 = 1;\n                }\n              } else {\n                if (!v3) {\n                  v3 = v14;\n                } else {\n                  fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                          &g_4040e8);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"Intermediate character already set %s\", &g_406570);\n                  fputc(10, stderr @GLIBC_2.2.5);\n                  v2 = 1;\n                }\n              }\n            } else {\n              if (v1) {\n                fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                        &g_4040e8);\n                fprintf(stderr @GLIBC_2.2.5, \"Private marker already set %s\",\n                        &g_406570);\n                fputc(10, stderr @GLIBC_2.2.5);\n                v2 = 1;\n              } else {\n                v1 = v14;\n              }\n            }\n          }\n        }\n      } while ((v16 += 1, v16 - 4220256 < g_406970));\n      v17 = v13;\n      v9 = v4;\n      if (v17 > 15) {\n        fprintf(stderr @GLIBC_2.2.5, \"%-10s (%s:%d): \", &__func__ .1,\n                &g_4040e8);\n        fprintf(stderr @GLIBC_2.2.5, \"Too many parameters: %s\", &g_406570);\n        fputc(10, stderr @GLIBC_2.2.5);\n        esc_clear();\n        return 1;\n      }\n      *((unsigned int *)&(&v5)[4 * v17]) = v15;\n      if (v2) {\n        esc_clear();\n        return 1;\n      }\n    }\n    if (dispatch)\n      dispatch(v9, &v5, v1);\n    esc_clear();\n    return 1;\n  } else if ((char)a0 == 127) {\n    return 1;\n  } else if ((char)a0 <= 31) {\n    return 0;\n  } else {\n    esc_collect(v9);\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:78:22: error: type name requires a specifier or\nqualifier 78 |             } __value; |                      ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:85:22: error: type name requires a specifier or\nqualifier 85 |             } __value; |                      ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:18:6: error: conflicting types for 'fputc'\n   18 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:117:13: error: expected identifier or '('\n  117 | extern char __func__.1;\n      |             ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:118:8: error: unknown type name 'struct_2'\n  118 | extern struct_2 *dispatch;\n      |        ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:123:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 123 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:123:22: error: expected ';' after top level\ndeclarator 123 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:170:48: error: cannot take the address of an\nrvalue of type 'int' 170 |                 if ((*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v14 << 1) + 1)) & 8)) | ^~~~~~~~~~~~~~~~\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:172:37: error: invalid operands to binary\nexpression ('void *' and 'int') 172 |                     v15 = v14 + v15 * 10 -\n48; |                                 ~~~ ^ ~~\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:180:43: error: expected ')'\n  180 |                             fprintf(stderr@GLIBC_2.2.5, \"%-10s (%s:%d):\n\", &__func__.1, &g_4040e8); |                                           ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:180:36: note: to match this '('\n  180 |                             fprintf(stderr@GLIBC_2.2.5, \"%-10s (%s:%d):\n\", &__func__.1, &g_4040e8); |                                    ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:181:43: error: expected ')'\n  181 |                             fprintf(stderr@GLIBC_2.2.5, \"Too many\nparameters: %s\", &g_406570); |                                           ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:181:36: note: to match this '('\n  181 |                             fprintf(stderr@GLIBC_2.2.5, \"Too many\nparameters: %s\", &g_406570); |                                    ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:182:45: error: expected ')'\n  182 |                             fputc(10, stderr@GLIBC_2.2.5);\n      |                                             ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:182:34: note: to match this '('\n  182 |                             fputc(10, stderr@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:201:51: error: expected ')'\n  201 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_4040e8); | ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:201:44: note: to match this '('\n  201 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_4040e8); | ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:202:51: error: expected ')'\n  202 |                                     fprintf(stderr@GLIBC_2.2.5, \"Error\nparsing params: %s, ignoring 0x%02x\", &g_406570, v0->field_10); | ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:202:44: note: to match this '('\n  202 |                                     fprintf(stderr@GLIBC_2.2.5, \"Error\nparsing params: %s, ignoring 0x%02x\", &g_406570, v0->field_10); | ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:203:53: error: expected ')'\n  203 |                                     fputc(10, stderr@GLIBC_2.2.5);\n      |                                                     ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:203:42: note: to match this '('\n  203 |                                     fputc(10, stderr@GLIBC_2.2.5);\n      |                                          ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:207:51: error: expected ')'\n  207 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_4040e8); | ^\n/tmp/tmpx2yxstsj/esc_state_csi_name_conflict.c:207:44: note: to match this '('\n  207 |                                     fprintf(stderr@GLIBC_2.2.5, \"%-10s\n(%s:%d): \", &__func__.1, &g_4040e8); | ^ fatal error: too many errors emitted,\nstopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\nlong long(esc_collect)(long long);\n\nlong long esc_state_osc_name_conflict(unsigned long long a0) {\n  if ((char)a0 == 7) {\n    esc_clear();\n    return 1;\n  } else if ((char)a0 <= 31) {\n    return 1;\n  } else {\n    esc_collect(a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long esc_state_wait_for_ST_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint esc_seq;          // add global variable by heuristics\nint esc_state_escape; // add global variable by heuristics\nint esc_seq;          // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(esc_clear)();\n\nextern struct_0 *esc_seq;\n\nlong long esc_handle_name_conflict(unsigned long long a0) {\n  int tmp_67;            // tmp #67\n  unsigned long long v1; // rax\n\n  v1 = a0 - 26;\n  tmp_67 = (char)v1;\n  *((char *)&v1) = (char)v1 <= 1 | (char)a0 == 24;\n  if (!(tmp_67 > 1) || !((char)a0 != 24)) {\n    esc_clear();\n    if ((char)a0 == 27) {\n      esc_seq = &esc_state_escape;\n      return v1;\n    }\n    return v1;\n  } else if (!esc_seq) {\n    return v1;\n  } else {\n    return esc_seq(a0);\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwag3i7q6/esc_handle_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *esc_seq; |        ^~~~~~~~ |        struct\n/tmp/tmpwag3i7q6/esc_handle_name_conflict.c:21:8: error: declaration of anonymous struct must\nbe a definition /tmp/tmpwag3i7q6/esc_handle_name_conflict.c:47:23: error: called object type\n'int' is not a function or function pointer 47 |         return esc_seq(a0); |\n~~~~~~~^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"char *test_dcs() {\n    escbatch(\"\\033P123456789\\033\\\\\");\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(escbatch)(long long);\n\nextern unsigned long long g_403019;\n\nlong long test_dcs_name_conflict() {\n  escbatch(&g_403019);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_anywhere\");\n        char *message = test_anywhere();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi\");\n        char *message = test_csi();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_bad\");\n        char *message = test_csi_bad();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_many_params\");\n        char *message = test_csi_too_many_params();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_long_param\");\n        char *message = test_csi_too_long_param();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_C0\");\n        char *message = test_csi_C0();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_osc\");\n        char *message = test_osc();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_dcs\");\n        char *message = test_dcs();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(reset)();\nlong long(escbatch)(long long);\nlong long(test_csi)();\nlong long(esc_handle)(long long);\nlong long(test_osc)();\n\nextern char csi_function;\nextern unsigned int csi_param;\nextern char csi_privflag;\nextern unsigned long long g_403019;\nextern char g_403041;\nextern unsigned long long g_403057;\nextern char g_403062;\nextern unsigned long long g_40306f;\nextern unsigned long long g_403075;\nextern unsigned long long g_40307b;\nextern char g_40307e;\nextern char g_403087;\nextern char g_403090;\nextern unsigned long long g_40309c;\nextern char g_4030a2;\nextern char g_4030ba;\nextern char g_4030d3;\nextern unsigned long long g_403f90;\nextern unsigned long long g_403fb8;\nextern unsigned int g_4064e4;\nextern unsigned int g_40651c;\nextern unsigned int tests_checks;\nextern unsigned int tests_run;\n\nlong long run_tests_name_conflict() {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rbx, Other Possible Types: unsigned long\n  unsigned int v3;       // eax\n  unsigned int v4;       // eax\n  unsigned int v5;       // ebx\n  unsigned int v6;       // eax\n  unsigned long v7;      // ebp, Other Possible Types: unsigned int\n  unsigned int v8;       // eax\n  unsigned int v9;       // eax\n\n  printf(\"--> %s\\n\", &g_403041);\n  reset();\n  escbatch(&g_403057);\n  v1 = tests_checks;\n  tests_checks = tests_checks + 1;\n  if (csi_function != 65) {\n    v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(156): csi_function \"\n         \"== 'A' failed\";\n  } else {\n    tests_checks = v1 + 2;\n    if (csi_privflag != 63) {\n      v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(157): \"\n           \"csi_privflag == '?' failed\";\n    } else {\n      tests_checks = v1 + 3;\n      if (csi_param) {\n        v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(158): \"\n             \"csi_param[0] == 0 failed\";\n      } else {\n        tests_checks = v1 + 4;\n        v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(159): \"\n             \"csi_param[1] == -1 failed\";\n        if (g_4064e4 == -1) {\n          tests_run = tests_run + 1;\n          printf(\"--> %s\\n\", &g_4030d3);\n          v2 = test_csi();\n          tests_run = tests_run + 1;\n          if (v2)\n            return v2;\n          printf(\"--> %s\\n\", &g_403062);\n          reset();\n          escbatch(&g_40306f);\n          v3 = tests_checks;\n          tests_checks = tests_checks + 1;\n          v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(89): \"\n               \"csi_function == '\\\\0' failed\";\n          if (!csi_function) {\n            tests_checks = v3 + 2;\n            v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(90): \"\n                 \"esc_handle('a') == false failed\";\n            if (!(char)esc_handle(97)) {\n              reset();\n              escbatch(&g_403075);\n              tests_checks = tests_checks + 1;\n              v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(93): \"\n                   \"csi_function == '\\\\0' failed\";\n              if (!csi_function) {\n                tests_run = tests_run + 1;\n                printf(\"--> %s\\n\", &g_4030ba);\n                reset();\n                escbatch(&g_403fb8);\n                v4 = tests_checks;\n                tests_checks = tests_checks + 1;\n                if (csi_function != 65) {\n                  v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(125): \"\n                       \"csi_function == 'A' failed\";\n                } else {\n                  tests_checks = v4 + 2;\n                  v2 = \"C_COMPILE/halhen_terma/test/unit/test_escparse.c(126): \"\n                       \"csi_param[15] == 5 failed\";\n                  if (g_40651c == 5) {\n                    reset();\n                    escbatch(&g_403f90);\n                    tests_checks = tests_checks + 1;\n                    v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                         \"test_escparse.c(129): csi_function == '\\\\0' failed\";\n                    if (!csi_function) {\n                      tests_run = tests_run + 1;\n                      printf(\"--> %s\\n\", &g_4030a2);\n                      reset();\n                      escbatch(&g_40307b);\n                      v5 = 1023;\n                      do {\n                        esc_handle(48);\n                        v5 -= 1;\n                      } while (true);\n                      esc_handle(49);\n                      tests_checks = tests_checks + 1;\n                      if (!(char)esc_handle(65)) {\n                        v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                             \"test_escparse.c(106): esc_handle('A') == true \"\n                             \"failed\";\n                      } else {\n                        v6 = tests_checks;\n                        tests_checks = tests_checks + 1;\n                        if (csi_function != 65) {\n                          v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                               \"test_escparse.c(107): csi_function == 'A' \"\n                               \"failed\";\n                        } else {\n                          tests_checks = v6 + 2;\n                          v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                               \"test_escparse.c(108): csi_param[0] == 1 failed\";\n                          if (csi_param == 1) {\n                            reset();\n                            escbatch(&g_40307b);\n                            v7 = 0x400;\n                            do {\n                              esc_handle(48);\n                              v7 = (unsigned int)v7 - 1;\n                            } while (true);\n                            esc_handle(49);\n                            tests_checks = tests_checks + 1;\n                            if (!(char)esc_handle(65)) {\n                              v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                   \"test_escparse.c(115): esc_handle('A') == \"\n                                   \"true failed\";\n                            } else {\n                              v8 = tests_checks;\n                              tests_checks = tests_checks + 1;\n                              if (csi_function != 65) {\n                                v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                     \"test_escparse.c(116): csi_function == \"\n                                     \"'A' failed\";\n                              } else {\n                                tests_checks = v8 + 2;\n                                v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                     \"test_escparse.c(117): csi_param[0] == 0 \"\n                                     \"failed\";\n                                if (!csi_param) {\n                                  tests_run = tests_run + 1;\n                                  printf(\"--> %s\\n\", &g_403090);\n                                  reset();\n                                  escbatch(&g_40309c);\n                                  do {\n                                    if (v7 - 26 > 1 && (char)v7 != 24) {\n                                      tests_checks = tests_checks + 1;\n                                      if ((char)esc_handle(v7)) {\n                                        tests_run = tests_run + 1;\n                                        return \"C_COMPILE/halhen_terma/test/\"\n                                               \"unit/test_escparse.c(142): \"\n                                               \"esc_handle(c) == false failed\";\n                                      }\n                                    }\n                                  } while (\n                                      (v7 = (unsigned long long)((unsigned int)\n                                                                     v7 +\n                                                                 1),\n                                       (unsigned int)v7 != 32));\n                                  esc_handle(65);\n                                  v9 = tests_checks;\n                                  tests_checks = tests_checks + 1;\n                                  if (csi_function != 65) {\n                                    v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                         \"test_escparse.c(145): csi_function \"\n                                         \"== 'A' failed\";\n                                  } else {\n                                    tests_checks = v9 + 2;\n                                    if (csi_privflag) {\n                                      v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                           \"test_escparse.c(146): csi_privflag \"\n                                           \"== '\\\\0' failed\";\n                                    } else {\n                                      tests_checks = v9 + 3;\n                                      if (csi_param != 1) {\n                                        v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                             \"test_escparse.c(147): \"\n                                             \"csi_param[0] == 1 failed\";\n                                      } else {\n                                        tests_checks = v9 + 4;\n                                        v2 = \"C_COMPILE/halhen_terma/test/unit/\"\n                                             \"test_escparse.c(148): \"\n                                             \"csi_param[1] == 2 failed\";\n                                        if (g_4064e4 == 2) {\n                                          tests_run = tests_run + 1;\n                                          printf(\"--> %s\\n\", &g_403087);\n                                          v2 = test_osc();\n                                          tests_run = tests_run + 1;\n                                          if (!v2) {\n                                            printf(\"--> %s\\n\", &g_40307e);\n                                            escbatch(&g_403019);\n                                            tests_run = tests_run + 1;\n                                            return v2;\n                                          }\n                                          return v2;\n                                        }\n                                      }\n                                    }\n                                  }\n                                  tests_run = tests_run + 1;\n                                  return v2;\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                      tests_run = tests_run + 1;\n                      return v2;\n                    }\n                  }\n                }\n                tests_run = tests_run + 1;\n                return v2;\n              }\n            }\n          }\n          tests_run = tests_run + 1;\n          return v2;\n        }\n      }\n    }\n  }\n  tests_run = tests_run + 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_utf8toucs2\");\n        char *message = test_utf8toucs2();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_helpers\");\n        char *message = test_helpers();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(test_utf8toucs2)();\nlong long(test_helpers)();\n\nextern char g_40215e;\nextern char g_402176;\nextern unsigned int tests_run;\n\nlong long run_tests_name_conflict() {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  printf(\"--> %s\\n\", &g_40215e);\n  v1 = test_utf8toucs2();\n  tests_run = tests_run + 1;\n  if (!v1) {\n    printf(\"--> %s\\n\", &g_402176);\n    v1 = test_helpers();\n    tests_run = tests_run + 1;\n    return v1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_util.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nlong long ASTEmpty_create_name_conflict() {\n  struct_0 *v1; // rax\n\n  v1 = calloc(1, 8);\n  v1->field_4 = 3;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char field_8;\n} struct_0;\n\nlong long ASTLiteral_create_name_conflict(unsigned long a0) {\n  struct_0 *v1; // rax\n\n  v1 = calloc(1, 12);\n  v1->field_0 = 1;\n  v1->field_4 = 3;\n  v1->field_8 = a0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nlong long ASTEmpty_create_name_conflict() {\n  struct_0 *v1; // rax\n\n  v1 = calloc(1, 8);\n  v1->field_4 = 3;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char field_8;\n} struct_0;\n\nlong long ASTLiteral_create_name_conflict(unsigned long a0) {\n  struct_0 *v1; // rax\n\n  v1 = calloc(1, 12);\n  v1->field_0 = 1;\n  v1->field_4 = 3;\n  v1->field_8 = a0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ASTEmpty_create)();\nlong long(yyparse_name_conflict)(long long);\nlong long(yyrelease)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long parse_name_conflict(char *a0) {\n  char v0;          // [bp-0x78]\n  char *v1;         // [bp-0x18]\n  char v2;          // [bp-0x10]\n  unsigned long v5; // rcx, Other Possible Types: unsigned long long\n  struct_0 *v6;     // rdi, Other Possible Types: unsigned long\n  unsigned long v7; // d\n  unsigned long v8; // rbx, Other Possible Types: unsigned long long\n\n  if (!*(a0)) {\n    v8 = ASTEmpty_create();\n    return v8;\n  }\n  v5 = 14;\n  for (v6 = &v0; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v1 = a0;\n  do {\n  } while ((int)yyparse_name_conflict(&v0));\n  v8 = *((long long *)&v2);\n  yyrelease(&v0);\n  return v8;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nlong long ASTEmpty_create_name_conflict() {\n  struct_0 *v1; // rax\n\n  v1 = calloc(1, 8);\n  v1->field_4 = 3;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char field_8;\n} struct_0;\n\nlong long ASTLiteral_create_name_conflict(unsigned long a0) {\n  struct_0 *v1; // rax\n\n  v1 = calloc(1, 12);\n  v1->field_0 = 1;\n  v1->field_4 = 3;\n  v1->field_8 = a0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ASTEmpty_create)();\nlong long(yyparse_name_conflict)(long long);\nlong long(yyrelease)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long parse_name_conflict(char *a0) {\n  char v0;          // [bp-0x78]\n  char *v1;         // [bp-0x18]\n  char v2;          // [bp-0x10]\n  unsigned long v5; // rcx, Other Possible Types: unsigned long long\n  struct_0 *v6;     // rdi, Other Possible Types: unsigned long\n  unsigned long v7; // d\n  unsigned long v8; // rbx, Other Possible Types: unsigned long long\n\n  if (!*(a0)) {\n    v8 = ASTEmpty_create();\n    return v8;\n  }\n  v5 = 14;\n  for (v6 = &v0; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v1 = a0;\n  do {\n  } while ((int)yyparse_name_conflict(&v0));\n  v8 = *((long long *)&v2);\n  yyrelease(&v0);\n  return v8;\n}\n","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long dump978_reader_new_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v1[1134]; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(1, 4536);\n  if (!v1)\n    return v1;\n  if ((unsigned int)a1 && (!(fcntl(a0, 3) >= 0) || !(fcntl(a0, 4) >= 0))) {\n    free(v1);\n    return 0;\n  }\n  v1[0] = a0;\n  v1[1133] = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjcjtejtz/dump978_reader_new_name_conflict.c:22:8: error: array type 'unsigned\nint[1134]' is not assignable 22 |     v1 = calloc(1, 4536); |     ~~ ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":1,"function":"static int encode_altitude(int ft) {\n    int i;\n    i = (ft + 1000) / 25;\n    if (i < 0)\n        i = 0;\n    if (i > 2047)\n        i = 2047;\n    return (i & 15) | 16 | ((i & 2032) << 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long encode_altitude_name_conflict(unsigned long a0) {\n  unsigned int v1; // edx\n\n  v1 = 0;\n  if ((unsigned int)a0 >= -0x400) {\n    v1 = 2047;\n    if ((unsigned int)a0 <= 50199)\n      v1 = ((unsigned int)a0 + 1000) / 25;\n  }\n  return v1 * 2 & 4064 | v1 & 15 | 16;\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_ground_speed(int kt) {\n    if (kt > 175)\n        return 124;\n    if (kt > 100)\n        return (kt - 100) / 5 + 108;\n    if (kt > 70)\n        return (kt - 70) / 2 + 93;\n    if (kt > 15)\n        return (kt - 15) + 38;\n    if (kt > 2)\n        return (kt - 2) * 2 + 11;\n    if (kt == 2)\n        return 12;\n    if (kt == 1)\n        return 8;\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_air_speed(int kt, int supersonic) {\n    int sign;\n    if (kt < 0) {\n        sign = 1024;\n        kt = -kt;\n    } else {\n        sign = 0;\n    }\n    if (supersonic)\n        kt = kt / 4;\n    ++kt;\n    if (kt > 1023)\n        kt = 1023;\n    return kt | sign;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_vert_rate(int rate) {\n    int sign;\n    if (rate < 0) {\n        sign = 512;\n        rate = -rate;\n    } else {\n        sign = 0;\n    }\n    rate = (rate / 64) + 1;\n    if (rate > 511)\n        rate = 511;\n    return rate | sign;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint8_t char_to_ais(int ch) {\n    char *match;\n    if (!ch)\n        return 32;\n    match = strchr(ais_charset, ch);\n    if (match)\n        return (uint8_t)(match - ais_charset);\n    else\n        return 32;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_406038; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long char_to_ais_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rax\n\n  if ((unsigned int)a0) {\n    v1 = strchr(\n        \"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_ !\\\"#$%&\\'()*+,-./0123456789:;<=>?\",\n        a0);\n    return (!v1 ? (unsigned long long)(v1 - &g_406038) : 32);\n  }\n  return 32;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3hucz3e1/char_to_ais_name_conflict.c:25:47: error: invalid operands to binary\nexpression ('unsigned long long' and 'int *') 25 |         return (!v1 ?\n(unsigned long long)(v1 - &g_406038) : 32); | ~~ ^ ~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static unsigned int encodeSquawk(char *squawkStr) {\n    unsigned int squawk = strtoul(squawkStr, ((void *)0), 16);\n    unsigned int encoded = 0;\n    if (squawk & 4096)\n        encoded |= 2048;\n    if (squawk & 8192)\n        encoded |= 512;\n    if (squawk & 16384)\n        encoded |= 128;\n    if (squawk & 256)\n        encoded |= 32;\n    if (squawk & 512)\n        encoded |= 8;\n    if (squawk & 1024)\n        encoded |= 2;\n    if (squawk & 16)\n        encoded |= 4096;\n    if (squawk & 32)\n        encoded |= 1024;\n    if (squawk & 64)\n        encoded |= 256;\n    if (squawk & 1)\n        encoded |= 16;\n    if (squawk & 2)\n        encoded |= 4;\n    if (squawk & 4)\n        encoded |= 1;\n    return encoded;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtoul)(char *, char *, char *);\n\nlong long encodeSquawk_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n  char v2;               // dl\n  unsigned long long v3; // rcx\n  unsigned long long v4; // rcx\n  unsigned long v5;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v6; // rcx\n  unsigned long long v7; // rcx\n  unsigned long long v8; // rcx\n\n  v1 = strtoul(a0, NULL, 0x10);\n  v2 = v1;\n  v5 = (unsigned int)v1 / 2 & 0x800;\n  v3 = v5;\n  *((char *)&v3) = (char)v3 | 2;\n  if (false)\n    v5 = v3;\n  v4 = v5;\n  *((char *)&v4) = (char)v4 | 128;\n  if (false)\n    v5 = v4;\n  if (!(true))\n    v5 = (unsigned int)v5 | 32;\n  if (!(true))\n    v5 = (unsigned int)v5 | 8;\n  if (!(true))\n    v5 = (unsigned int)v5 | 2;\n  v6 = v5;\n  *((char *)&v6) = (char)v6 | 16;\n  if ((v2 & 16))\n    v5 = v6;\n  v7 = v5;\n  *((char *)&v7) = (char)v7 | 4;\n  if ((v2 & 32))\n    v5 = v7;\n  v8 = v5;\n  *((char *)&v8) = (char)v8 | 1;\n  if ((v2 & 64))\n    v5 = v8;\n  if ((v2 & 1))\n    v5 = (unsigned int)v5 | 16;\n  if ((v2 & 2))\n    v5 = (unsigned int)v5 | 4;\n  if (!(v2 & 4))\n    return v5;\n  v5 = (unsigned int)v5 | 1;\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint32_t checksum(uint8_t *message, int n) {\n    uint32_t rem = 0;\n    int i;\n    for (i = 0; i < n; ++i) {\n        rem = (rem << 8) ^ crc_table[message[i] ^ ((rem & 16711680) >> 16)];\n        rem = rem & 16777215;\n    }\n    return rem;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long dump978_reader_new_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v1[1134]; // rbx, Other Possible Types: unsigned long\n\n  v1 = calloc(1, 4536);\n  if (!v1)\n    return v1;\n  if ((unsigned int)a1 && (!(fcntl(a0, 3) >= 0) || !(fcntl(a0, 4) >= 0))) {\n    free(v1);\n    return 0;\n  }\n  v1[0] = a0;\n  v1[1133] = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgpj_pump/dump978_reader_new_name_conflict.c:22:8: error: array type 'unsigned\nint[1134]' is not assignable 22 |     v1 = calloc(1, 4536); |     ~~ ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  char *v4;         // rax\n\n  for (v2 = 1; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 0x100) * 19342813113834067 >> 64 >> 11) * 0x1dcd6500;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 << 4) + 8)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbheq9o6v/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpbheq9o6v/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpbheq9o6v/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500; | ~~~~~~ ^  ~\n/tmp/tmpbheq9o6v/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpbheq9o6v/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[2]; // rbx\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *((long long *)&vocab_size) * 16 + vocab;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (60 < (unsigned int)v2)\n    v2 = 60;\n  v3 = calloc(v2, 1);\n  v1[1] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2lpu6gkh/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[2]' is not assignable 33 |     v1 = *((long long *)&vocab_size) * 16 +\nvocab; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  void *v2; // rcx, Other Possible Types: unsigned long\n  char *v4; // rax\n\n  for (v2 = 0; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4dshipoj/GetWordHash_name_conflict.c:27:22: error: invalid operands to binary\nexpression ('void *' and 'int') 27 |         v2 = v2 + v2 * 0x100 + *((char\n*)rax); |                   ~~ ^ ~~~~~ /tmp/tmp4dshipoj/GetWordHash_name_conflict.c:29:22:\nerror: invalid operands to binary expression ('void *' and 'int') 29 | return v2\n- ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000; | ~~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 + (v4 << 2) << 3) + 16)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3v5ap0mq/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmp3v5ap0mq/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmp3v5ap0mq/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000; | ~~~~~~ ^  ~\n/tmp/tmp3v5ap0mq/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmp3v5ap0mq/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[3]; // rbp\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = vocab + *((long long *)&vocab_size) * 40;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (100 < (unsigned int)v2)\n    v2 = 100;\n  v3 = calloc(v2, 1);\n  v1[2] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 7) * 18764999 >> 42) * 30000000;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5zo4zljt/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[3]' is not assignable 33 |     v1 = vocab + *((long long *)&vocab_size) *\n40; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int setup() {\n    int i;\n    FILE *test_input = fopen(\"test_input.log\", \"w\");\n    if (!test_input)\n        return 1;\n    for (i = 1; i <= 10; i++)\n        fprintf(test_input, \"this is line %d\\n\", i);\n    fclose(test_input);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long setup_name_conflict() {\n  FILE_t *v1;       // rax\n  unsigned long v2; // ebx, Other Possible Types: unsigned int\n  unsigned int v4;  // edx\n\n  v1 = fopen(\"test_input.log\", \"w\");\n  if (!v1)\n    return 1;\n  v2 = 1;\n  do {\n    v4 = v2;\n    fprintf(v1, \"this is line %d\\n\", v4);\n    v2 = (unsigned int)v2 + 1;\n  } while ((unsigned int)v2 != 11);\n  fclose(v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwicc6054/setup_name_conflict.c:85:3: error: typedef redefinition with different types\n('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 85 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/test/dbfr_test.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fields_in_line_name_conflict(unsigned long a0, char *a1) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long v2;      // rbp\n  unsigned long long v4; // rax\n\n  if (a0) {\n    v1 = a0;\n    if (a1) {\n      v2 = 1;\n      while (true) {\n        v4 = strstr(v1, a1);\n        if (!v4)\n          break;\n        v2 += 1;\n        v1 = v4 + strlen(a1);\n      }\n      return v2;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_field(char *a0, char *a1, unsigned long a2, unsigned long a3,\n                         char *a4) {\n  char *v2;         // r12\n  char *v3;         // rax, Other Possible Types: unsigned long\n  unsigned long v4; // rax, Other Possible Types: unsigned long long\n  char *v5;         // rax\n  unsigned long v6; // rbx\n\n  if (a4 && *(a4)) {\n    v2 = field_start(a1, (unsigned int)a3 + 1, a4);\n    if (!v2) {\n      *(a0) = 0;\n      return 4294967295;\n    }\n    v4 = strstr(v2, a4);\n    if (!v4) {\n      v3 = &a1[strlen(a1) + 1];\n      a2 = *(v3);\n      if (a2 != 10 && a2 != 13)\n        goto LABEL_40159a;\n      while (true) {\n        v3 -= 1;\n        a2 = *((char *)v3);\n      }\n    LABEL_40159a:\n      v4 = v3 + 1;\n    }\n    v5 = v4 - v2;\n    v6 = a2 - 1;\n    if (v6 <= v6)\n      v6 = v5;\n    strncpy(a0, v2, v6);\n    a0[v6] = 0;\n    return v6;\n  }\n  strncpy(a0, a1, a2);\n  a0[a2] = 0;\n  return strlen(a0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzg0255g9/get_line_field.c:50:17: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 50 |         v5 = v4 - v2; | ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long copy_field(unsigned long long a0, char **a1, unsigned long long *a2,\n                     unsigned long a3, char *a4) {\n  char *v1;              // rax\n  char *v2;              // rbp\n  struct_0 *v3;          // rax, Other Possible Types: unsigned long\n  char *v4;              // rax\n  unsigned long long v6; // rdi\n  unsigned long long v7; // r15\n  unsigned long long v8; // r15\n\n  v1 = field_start(a0, a3 + 1, a4);\n  if (!v1)\n    return 4294967295;\n  v2 = v1;\n  v3 = strstr(v1, a4);\n  if (!v3) {\n    v3 = &v2[strlen(v2)];\n    a2 = *((char *)(v3 - 1));\n    if (a2 != 10 && a2 != 13)\n      goto LABEL_4015e2;\n    while (true) {\n      v3 -= 1;\n      a2 = *((char *)(v3 - 1));\n    }\n  }\nLABEL_4015e2:\n  v4 = v3 - v2;\n  v6 = *(a1);\n  if (!a2 || !v6) {\n    v8 = v4 + 1;\n    *(a1) = xmalloc(v8);\n    *((unsigned long long *)a2) = v8;\n  } else {\n    v7 = v4 + 1;\n    if (*((long long *)a2) < v7) {\n      *(a1) = xrealloc(v6, v7);\n      *((unsigned long long *)a2) = v7;\n    }\n  }\n  *((char *)(*(a1) + v4)) = 0;\n  strncpy(*(a1), v2, v4);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp34qyjc45/copy_field.c:21:16: error: expected ';' at end of declaration\nlist 21 |     char field_-1; |                ^ |                ;\n/tmp/tmp34qyjc45/copy_field.c:52:13: error: 'struct_0 *' (aka 'struct struct_0\n*') and 'char *' are not pointers to compatible types 52 |     v4 = v3 - v2; |\n~~ ^ ~~ /tmp/tmp34qyjc45/copy_field.c:69:22: error: invalid operands to binary\nexpression ('char *' and 'char *') 69 |     *((char *)(*(a1) + v4)) = 0; | ~~~~~\n^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long field_start_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v3; // r14\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long v5;      // rax\n\n  v1 = a0;\n  if (a1 <= 1)\n    return a0;\n  v3 = strlen(a2);\n  v4 = 0;\n  while (v5) {\n    v5 = strstr(v1, a2);\n    v1 = v5 + v3;\n    v4 += 1;\n    if (v4 == a1 - 1)\n      return v1;\n  }\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mdyhms_datecmp_name_conflict(char a0[10], char a1[10]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0[6] == a1[6] && a0[7] == a1[7] && a0[8] == a1[8] && a0[9] == a1[9]) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  (unsigned int)v1 = strncmp(&a0[6], &a1[6], 4);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw6pmsl4b/mdyhms_datecmp_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpw6pmsl4b/mdyhms_datecmp_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v1 = strncmp(&a0[6],\n&a1[6], 4); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long dmyhms_datecmp_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = strncmp(a0 + 6, a1 + 6, 4);\n  if ((unsigned int)v1)\n    return v1;\n  (unsigned int)v1 = strncmp(a0 + 3, a1 + 3, 2);\n  if (!(unsigned int)v1) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb_jnjxzr/dmyhms_datecmp_name_conflict.c:21:5: error: assignment to cast is illegal,\nlvalue casts are not supported 21 |     (unsigned int)v1 = strncmp(a0 + 6, a1 +\n6, 4); |     ^~~~~~~~~~~~~~~~ ~ /tmp/tmpb_jnjxzr/dmyhms_datecmp_name_conflict.c:24:5: error:\nassignment to cast is illegal, lvalue casts are not supported 24 |     (unsigned\nint)v1 = strncmp(a0 + 3, a1 + 3, 2); |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpb_jnjxzr/dmyhms_datecmp_name_conflict.c:27:9: error: assignment to cast is illegal,\nlvalue casts are not supported 27 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strtok)(char *, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long expand_nums_name_conflict(char *a0, struct struct_1 **a1, unsigned long long *a2) {\n  unsigned long v0;        // [bp-0x50]\n  char v1;                 // [bp-0x40]\n  char v2;                 // [bp-0x3c]\n  unsigned long v3;        // [bp-0x30]\n  unsigned long v4;        // [bp-0x28]\n  unsigned long v5;        // [bp-0x20]\n  unsigned long v6;        // [bp-0x18]\n  unsigned long v7;        // [bp-0x10]\n  unsigned long v8;        // [bp-0x8]\n  unsigned long v10;       // r15\n  unsigned long v11;       // r14\n  unsigned long v12;       // r13\n  unsigned long v13;       // r12\n  unsigned long v14;       // rbx\n  unsigned long long *v15; // r15\n  struct_0 *v17; // rax, Other Possible Types: unsigned long long, unsigned long\n  unsigned long v18; // rbx, Other Possible Types: unsigned long long\n  unsigned int *v19; // rax, Other Possible Types: unsigned long\n  char *v20; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      *v21; // r13, Other Possible Types: unsigned long, unsigned long long\n  unsigned int *v22;      // rbx\n  unsigned long long v23; // r14\n  unsigned long long v24; // r14\n  unsigned long long v25; // rax\n  unsigned int *v26;      // r14\n  unsigned long long v27; // r12\n  unsigned long long v28; // r12\n  unsigned long long v29; // rcx\n  unsigned int *v30;      // rbx, Other Possible Types: unsigned long\n  unsigned long v31;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v32; // rdx\n\n  if (!a0)\n    return 0;\n  v8 = v10;\n  v7 = v11;\n  v6 = v12;\n  v5 = v13;\n  *((int *)&v4) = rbp;\n  v3 = v14;\n  v15 = a2;\n  v18 = *(a0);\n  v19 = 0;\n  if (!(char)v18)\n    return v19;\n  v17 = a0 + 1;\n  do {\n    if (!(*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v18 << 1) + 1)) &\n          8) &&\n        (char)((unsigned int)v18 - 44) > 1) {\n    LABEL_401a23:\n      return -2;\n    }\n  } while ((v17 += 1, v18 = (unsigned long long)v17[1].field_ - 1, (char)v18));\n  if (!*(a1) && !*(a2)) {\n    *(a1) = xmalloc(64);\n    *(a2) = 16;\n  }\n  if (strchr(a0, 44) || strchr(a0, 45)) {\n    v20 = strtok(a0, \",\");\n    if (!v20) {\n      v21 = 0;\n    } else {\n      v21 = 0;\n      v0 = &v2;\n      do {\n        v22 = v21;\n        v23 = *(v15);\n        if (v21 >= v23) {\n          v24 = v23 + 16;\n          xrealloc(*(a1), v24 * 4);\n          *(v15) = v24;\n          if (!v24)\n            return -1;\n        }\n        if (!strchr(v20, 45)) {\n          __isoc99_sscanf(\n              v20, \"%u\",\n              (unsigned int)(struct struct_1 *)((char *)*(a1) + 0x4 * v22));\n          v21 = (unsigned int)v21 + 1;\n        } else {\n          __isoc99_sscanf(v20, \"%u-%u\", (unsigned int)&v1, (unsigned int)v0);\n          v25 = *(v15);\n          v26 = v21;\n          v27 = *((int *)&v2) - *((int *)&v1);\n          if (v25 < v21 + v27) {\n            v28 = v27 + v25;\n            xrealloc(*(a1), v28 * 4);\n            *(v15) = v28;\n            if (!v28)\n              return -1;\n          }\n          v29 = *((int *)&v1);\n          if (*((int *)&v2) >= (unsigned int)v29) {\n            v30 = v22 * 4;\n            v31 = v29;\n            do {\n              *((unsigned int *)((char *)&*(a1)->field_0 + v30)) = v31;\n              v32 = v31;\n              v31 = (unsigned int)v31 + 1;\n              v30 += 4;\n            } while (*((int *)&v2) >= (unsigned int)v31);\n            v21 = 1 + v32 + (char *)v26 - v29;\n          }\n        }\n        v20 = strtok(NULL, \",\");\n      } while (v20);\n    }\n    v19 = v21;\n    goto LABEL_401a23;\n  } else {\n    __isoc99_sscanf(a0, \"%u\", (unsigned int)*(a1));\n    v19 = 1;\n    goto LABEL_401a23;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9qxdf8_y/expand_nums_name_conflict.c:22:16: error: expected ';' at end of declaration\nlist 22 |     char field_-1; |                ^ |                ;\n/tmp/tmp9qxdf8_y/expand_nums_name_conflict.c:75:41: error: cannot take the address of an\nrvalue of type 'int' 75 |         if (!(*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v18 << 1) + 1)) & 8) && (char)((unsigned int)v18 -\n44) > 1) |                                         ^~~~~~~~~~~~~~~~\n/tmp/tmp9qxdf8_y/expand_nums_name_conflict.c:111:102: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 111 | __isoc99_sscanf(v20, \"%u\",\n(unsigned int)(struct struct_1 *)((char *)*(a1) + 0x4 * v22)); | ~~~ ^ ~~~\n/tmp/tmp9qxdf8_y/expand_nums_name_conflict.c:131:35: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 131 |                         v30 = v22\n* 4; |                               ~~~ ^ ~\n/tmp/tmp9qxdf8_y/expand_nums_name_conflict.c:135:62: error: member reference base type 'struct\nstruct_1 *' is not a structure or union 135 | *((unsigned int *)((char\n*)&*(a1)->field_0 + v30)) = v31; | ~~~~^ ~~~~~~~\n/tmp/tmp9qxdf8_y/expand_nums_name_conflict.c:135:72: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 135 | *((unsigned int *)((char\n*)&*(a1)->field_0 + v30)) = v31; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(field_str)(long long, long long, long long);\n\nlong long expand_label_list(char *a0, unsigned long a1, unsigned long a2,\n                            struct struct_0 **a3, unsigned long long *a4) {\n  unsigned long long v0; // [bp-0x178]\n  unsigned long long v1; // [bp-0x50]\n  unsigned long long v2; // [bp-0x48]\n  unsigned int v3;       // [bp-0x3c]\n  struct struct_0 **v5;  // r14\n  unsigned long long v6; // rbp\n  char v7[2];            // r13\n  char v8;               // al\n  char *v9;              // rcx\n  char v10;              // al\n  char *v11;             // rsi, Other Possible Types: unsigned long\n  unsigned long v12;     // rax\n  unsigned long v13;     // edx, Other Possible Types: unsigned int\n  void *v14; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned long v15;      // rcx\n  unsigned int *v16;      // rdi\n  unsigned long long v17; // r15\n  char v18[2];            // rbp, Other Possible Types: unsigned long\n  unsigned int\n      *v19; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v21; // rax\n\n  v1 = a1;\n  v2 = a2;\n  v5 = a3;\n  v6 = strlen(a0) + 1;\n  v7 = xmalloc(v6);\n  v14 = 0;\n  v13 = 0;\n  v15 = 0;\n  do {\n    v8 = a0[v15];\n    if (v8 <= 13) {\n      v0 = 9217;\n      if (((char)(*((char *)&v0 + ((a0[v15] & 63) >> 3)) >>\n                  (a0[v15] & 63 & 7)) &\n           1)) {\n        v7[v13] = 0;\n        v14 += 1;\n        break;\n      }\n    } else if (v8 == 92) {\n      v9 = &a0[v15 + 1];\n      v10 = *(v9);\n      if (v10 == 92) {\n        v7[v13] = 92;\n      } else {\n        if (v10 == 44) {\n          v7[v13] = 44;\n        } else {\n          v12 = v13 + 1;\n          v7[v13] = 92;\n          v7[v12] = *(v9);\n          v13 = v12;\n        }\n      }\n      v11 = 2;\n      continue;\n    } else if (v8 == 44) {\n      v7[v13] = 0;\n      v14 += 1;\n      v11 = 1;\n      continue;\n    }\n    v7[v13] = v8;\n    v11 = 1;\n  } while (\n      (v13 = (unsigned long long)((unsigned int)v13 + 1), v15 = v11, v11 < v6));\n  v16 = *(v5);\n  if (!v16) {\n    *(v5) = xmalloc(v14 * 4);\n    *(a4) = v14;\n  } else if (*(a4) < v14) {\n    xrealloc(v16, v14 * 4);\n    *(a4) = v14;\n    if (!v14)\n      return -2;\n  }\n  v17 = &v7[v13 + 1];\n  v18 = v7;\n  v19 = 0;\n  v3 = 0;\n  if (v7 != v17) {\n    while (true) {\n      (unsigned int)v21 = field_str(v18, v1, v2);\n      if ((unsigned int)v21 < 0) {\n        warnx(\"Failed to find field label: %s\");\n        v3 += 1;\n      }\n      (*(v5))[v19].field_0 = (unsigned int)v21 + 1;\n      v18 = v18 + strlen(v18) + 1;\n      if (v18 == v17)\n        break;\n      v19 += 1;\n    }\n    if (v3)\n      return -1;\n    v19 = (unsigned int)v19 + 1;\n  }\n  free(v7);\n  return v19;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplbj888b5/expand_label_list.c:46:8: error: array type 'char[2]' is not\nassignable 46 |     v7 = xmalloc(v6); |     ~~ ^\n/tmp/tmplbj888b5/expand_label_list.c:101:29: error: invalid operands to binary\nexpression ('void *' and 'int') 101 |         *(v5) = xmalloc(v14 * 4); | ~~~ ^\n~ /tmp/tmplbj888b5/expand_label_list.c:106:27: error: invalid operands to binary\nexpression ('void *' and 'int') 106 |         xrealloc(v16, v14 * 4); | ~~~ ^ ~\n/tmp/tmplbj888b5/expand_label_list.c:112:9: error: array type 'char[2]' is not\nassignable 112 |     v18 = v7; |     ~~~ ^\n/tmp/tmplbj888b5/expand_label_list.c:119:13: error: assignment to cast is\nillegal, lvalue casts are not supported 119 |             (unsigned int)v21 =\nfield_str(v18, v1, v2); |             ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmplbj888b5/expand_label_list.c:125:20: error: array subscript is not an\ninteger 125 |             (*(v5))[v19].field_0 = (unsigned int)v21 + 1; | ^~~~\n/tmp/tmplbj888b5/expand_label_list.c:126:17: error: array type 'char[2]' is not\nassignable 126 |             v18 = v18 + strlen(v18) + 1; |             ~~~ ^ 7\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_pos(char *a0, unsigned long a1, unsigned long long a2,\n                       unsigned int *a3, unsigned int *a4) {\n  unsigned long long v0;  // [bp-0x148]\n  char *v2;               // r13\n  unsigned int *v3;       // r14\n  char *v4;               // rax\n  unsigned long long v6;  // rax\n  unsigned int v7;        // eax\n  unsigned long long v8;  // rax\n  char v9;                // dl\n  unsigned long v10;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v11; // rcx\n  unsigned long v12;      // esi, Other Possible Types: unsigned int\n  char v13;               // dl\n  unsigned int v14;       // eax\n  unsigned long long v15; // rdx\n  unsigned int v16;       // eax\n  char *v17;              // rbx\n  unsigned long v18;      // rax\n\n  v2 = a2;\n  v3 = a3;\n  v4 = field_start(a0, (unsigned int)a1 + 1, a2);\n  if (!v4) {\n    *(a3) = -1;\n    *(a4) = -1;\n    return 4294967295;\n  }\n  *(a3) = v4 - a0;\n  v6 = strstr(v4, v2);\n  if (!v6) {\n    v8 = strlen(a0);\n    v12 = v8 - 1;\n    *(a4) = v12;\n    v9 = a0[v12];\n    if (v9 == 10 || v9 == 13) {\n      v10 = (unsigned int)v8 - 2;\n      v11 = &a0[v12 + -1 * v10];\n      while (true) {\n        v12 = v10;\n        *(a4) = v10;\n        v13 = *((char *)(v11 + v10 - 1));\n        v10 -= 1;\n      }\n    }\n    v14 = *(v3);\n    if (v14 > (unsigned int)v12)\n      *(a4) = v14;\n  } else {\n    v7 = (v4 != v6 ? (unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1);\n    *(a4) = v7;\n  }\n  v15 = *(v3);\n  v16 = *(a4);\n  if ((unsigned int)v15 != v16) {\n    v18 = v16 - (unsigned int)v15 + 1;\n    return v18;\n  }\n  v17 = &a0[v15];\n  if (*(v17) <= 13) {\n    v0 = 9217;\n    if (((char)(*((char *)&v0 + ((*(v17) & 63) >> 3)) >> (*(v17) & 63 & 7)) &\n         1))\n      return 0;\n  }\n  v18 = strncmp(v17, v2, strlen(v2));\n  return v18;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpunv1b8zz/get_line_pos.c:73:44: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 73 |         v7 = (v4 != v6 ?\n(unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1); | ~~ ^ ~~\n/tmp/tmpunv1b8zz/get_line_pos.c:73:70: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 73 |         v7 = (v4 != v6 ?\n(unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1); | ~~ ^ ~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(get_line_field)(long long, long long, long long, long long,\n                          long long);\n\nlong long field_str_name_conflict(char *a0, char *a1, char *a2) {\n  unsigned long v0;       // [bp-0x30]\n  unsigned long v1;       // [bp-0x28]\n  unsigned long v2;       // [bp-0x20]\n  unsigned long v3;       // [bp-0x18]\n  unsigned long v4;       // [bp-0x10]\n  unsigned long v5;       // [bp-0x8]\n  unsigned long v7;       // r15\n  unsigned long v8;       // r14\n  unsigned long v9;       // r13\n  unsigned long v10;      // r12\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rax\n  char *v15;              // r14\n  void *v16;              // rbx, Other Possible Types: unsigned long\n  unsigned long v17;      // rax, Other Possible Types: unsigned long long\n\n  if (!a0)\n    return -2;\n  v5 = v7;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  if (!a1) {\n    v17 = -1;\n  } else if (!*(a1)) {\n    v17 = -1;\n  } else if (!a2 || !*(a2)) {\n    v17 = -(0 < strcmp(a0, a1));\n  } else {\n    v12 = strlen(a0);\n    v15 = xmalloc((unsigned int)v12 + 4);\n    v16 = 0;\n    while (true) {\n      if ((int)get_line_field(v15, a1, v12 + 3, v16, a2) < 0) {\n        free(v15);\n        v17 = -1;\n        break;\n      } else if (strcmp(v15, a0)) {\n        v16 = (unsigned int)v16 + 1;\n      } else {\n        free(v15);\n        v17 = v16;\n        break;\n      }\n    }\n  }\n  return v17;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fields_in_line_name_conflict(unsigned long a0, char *a1) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long v2;      // rbp\n  unsigned long long v4; // rax\n\n  if (a0) {\n    v1 = a0;\n    if (a1) {\n      v2 = 1;\n      while (true) {\n        v4 = strstr(v1, a1);\n        if (!v4)\n          break;\n        v2 += 1;\n        v1 = v4 + strlen(a1);\n      }\n      return v2;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_field(char *a0, char *a1, unsigned long a2, unsigned long a3,\n                         char *a4) {\n  char *v2;         // r12\n  char *v3;         // rax, Other Possible Types: unsigned long\n  unsigned long v4; // rax, Other Possible Types: unsigned long long\n  char *v5;         // rax\n  unsigned long v6; // rbx\n\n  if (a4 && *(a4)) {\n    v2 = field_start(a1, (unsigned int)a3 + 1, a4);\n    if (!v2) {\n      *(a0) = 0;\n      return 4294967295;\n    }\n    v4 = strstr(v2, a4);\n    if (!v4) {\n      v3 = &a1[strlen(a1) + 1];\n      a2 = *(v3);\n      if (a2 != 10 && a2 != 13)\n        goto LABEL_403ec0;\n      while (true) {\n        v3 -= 1;\n        a2 = *((char *)v3);\n      }\n    LABEL_403ec0:\n      v4 = v3 + 1;\n    }\n    v5 = v4 - v2;\n    v6 = a2 - 1;\n    if (v6 <= v6)\n      v6 = v5;\n    strncpy(a0, v2, v6);\n    a0[v6] = 0;\n    return v6;\n  }\n  strncpy(a0, a1, a2);\n  a0[a2] = 0;\n  return strlen(a0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvzlz8_3r/get_line_field.c:50:17: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 50 |         v5 = v4 - v2; | ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long copy_field(unsigned long long a0, char **a1, unsigned long long *a2,\n                     unsigned long a3, char *a4) {\n  char *v1;              // rax\n  char *v2;              // rbp\n  struct_0 *v3;          // rax, Other Possible Types: unsigned long\n  char *v4;              // rax\n  unsigned long long v6; // rdi\n  unsigned long long v7; // r15\n  unsigned long long v8; // r15\n\n  v1 = field_start(a0, a3 + 1, a4);\n  if (!v1)\n    return 4294967295;\n  v2 = v1;\n  v3 = strstr(v1, a4);\n  if (!v3) {\n    v3 = &v2[strlen(v2)];\n    a2 = *((char *)(v3 - 1));\n    if (a2 != 10 && a2 != 13)\n      goto LABEL_403f08;\n    while (true) {\n      v3 -= 1;\n      a2 = *((char *)(v3 - 1));\n    }\n  }\nLABEL_403f08:\n  v4 = v3 - v2;\n  v6 = *(a1);\n  if (!a2 || !v6) {\n    v8 = v4 + 1;\n    *(a1) = xmalloc(v8);\n    *((unsigned long long *)a2) = v8;\n  } else {\n    v7 = v4 + 1;\n    if (*((long long *)a2) < v7) {\n      *(a1) = xrealloc(v6, v7);\n      *((unsigned long long *)a2) = v7;\n    }\n  }\n  *((char *)(*(a1) + v4)) = 0;\n  strncpy(*(a1), v2, v4);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7m6tzpvl/copy_field.c:21:16: error: expected ';' at end of declaration\nlist 21 |     char field_-1; |                ^ |                ;\n/tmp/tmp7m6tzpvl/copy_field.c:52:13: error: 'struct_0 *' (aka 'struct struct_0\n*') and 'char *' are not pointers to compatible types 52 |     v4 = v3 - v2; |\n~~ ^ ~~ /tmp/tmp7m6tzpvl/copy_field.c:69:22: error: invalid operands to binary\nexpression ('char *' and 'char *') 69 |     *((char *)(*(a1) + v4)) = 0; | ~~~~~\n^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long field_start_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v3; // r14\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long v5;      // rax\n\n  v1 = a0;\n  if (a1 <= 1)\n    return a0;\n  v3 = strlen(a2);\n  v4 = 0;\n  while (v5) {\n    v5 = strstr(v1, a2);\n    v1 = v5 + v3;\n    v4 += 1;\n    if (v4 == a1 - 1)\n      return v1;\n  }\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mdyhms_datecmp_name_conflict(char a0[10], char a1[10]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0[6] == a1[6] && a0[7] == a1[7] && a0[8] == a1[8] && a0[9] == a1[9]) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  (unsigned int)v1 = strncmp(&a0[6], &a1[6], 4);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4ly8x0c8/mdyhms_datecmp_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp4ly8x0c8/mdyhms_datecmp_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v1 = strncmp(&a0[6],\n&a1[6], 4); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long dmyhms_datecmp_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = strncmp(a0 + 6, a1 + 6, 4);\n  if ((unsigned int)v1)\n    return v1;\n  (unsigned int)v1 = strncmp(a0 + 3, a1 + 3, 2);\n  if (!(unsigned int)v1) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3h4xkkdr/dmyhms_datecmp_name_conflict.c:21:5: error: assignment to cast is illegal,\nlvalue casts are not supported 21 |     (unsigned int)v1 = strncmp(a0 + 6, a1 +\n6, 4); |     ^~~~~~~~~~~~~~~~ ~ /tmp/tmp3h4xkkdr/dmyhms_datecmp_name_conflict.c:24:5: error:\nassignment to cast is illegal, lvalue casts are not supported 24 |     (unsigned\nint)v1 = strncmp(a0 + 3, a1 + 3, 2); |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp3h4xkkdr/dmyhms_datecmp_name_conflict.c:27:9: error: assignment to cast is illegal,\nlvalue casts are not supported 27 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strtok)(char *, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_1 {\n  char field_ - 1;\n} struct_1;\n\nlong long expand_nums_name_conflict(char *a0, struct struct_0 **a1, unsigned long long *a2) {\n  unsigned long v0;        // [bp-0x50]\n  char v1;                 // [bp-0x40]\n  char v2;                 // [bp-0x3c]\n  unsigned long v3;        // [bp-0x30]\n  unsigned long v4;        // [bp-0x28]\n  unsigned long v5;        // [bp-0x20]\n  unsigned long v6;        // [bp-0x18]\n  unsigned long v7;        // [bp-0x10]\n  unsigned long v8;        // [bp-0x8]\n  unsigned long v10;       // r15\n  unsigned long v11;       // r14\n  unsigned long v12;       // r13\n  unsigned long v13;       // r12\n  unsigned long v14;       // rbx\n  unsigned long long *v15; // r15\n  struct_1 *v17; // rax, Other Possible Types: unsigned long long, unsigned long\n  unsigned long v18; // rbx, Other Possible Types: unsigned long long\n  unsigned int *v19; // rax, Other Possible Types: unsigned long\n  char *v20; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      *v21; // r13, Other Possible Types: unsigned long, unsigned long long\n  unsigned int *v22;      // rbx\n  unsigned long long v23; // r14\n  unsigned long long v24; // r14\n  unsigned long long v25; // rax\n  unsigned int *v26;      // r14\n  unsigned long long v27; // r12\n  unsigned long long v28; // r12\n  unsigned long long v29; // rcx\n  unsigned int *v30;      // rbx, Other Possible Types: unsigned long\n  unsigned long v31;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v32; // rdx\n\n  if (!a0)\n    return 0;\n  v8 = v10;\n  v7 = v11;\n  v6 = v12;\n  v5 = v13;\n  *((int *)&v4) = rbp;\n  v3 = v14;\n  v15 = a2;\n  v18 = *(a0);\n  v19 = 0;\n  if (!(char)v18)\n    return v19;\n  v17 = a0 + 1;\n  do {\n    if (!(*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v18 << 1) + 1)) &\n          8) &&\n        (char)((unsigned int)v18 - 44) > 1) {\n    LABEL_404349:\n      return -2;\n    }\n  } while ((v17 += 1, v18 = (unsigned long long)v17[1].field_ - 1, (char)v18));\n  if (!*(a1) && !*(a2)) {\n    *(a1) = xmalloc(64);\n    *(a2) = 16;\n  }\n  if (strchr(a0, 44) || strchr(a0, 45)) {\n    v20 = strtok(a0, \",\");\n    if (!v20) {\n      v21 = 0;\n    } else {\n      v21 = 0;\n      v0 = &v2;\n      do {\n        v22 = v21;\n        v23 = *(v15);\n        if (v21 >= v23) {\n          v24 = v23 + 16;\n          xrealloc(*(a1), v24 * 4);\n          *(v15) = v24;\n          if (!v24)\n            return -1;\n        }\n        if (!strchr(v20, 45)) {\n          __isoc99_sscanf(\n              v20, \"%u\",\n              (unsigned int)(struct struct_0 *)((char *)*(a1) + 0x4 * v22));\n          v21 = (unsigned int)v21 + 1;\n        } else {\n          __isoc99_sscanf(v20, \"%u-%u\", (unsigned int)&v1, (unsigned int)v0);\n          v25 = *(v15);\n          v26 = v21;\n          v27 = *((int *)&v2) - *((int *)&v1);\n          if (v25 < v21 + v27) {\n            v28 = v27 + v25;\n            xrealloc(*(a1), v28 * 4);\n            *(v15) = v28;\n            if (!v28)\n              return -1;\n          }\n          v29 = *((int *)&v1);\n          if (*((int *)&v2) >= (unsigned int)v29) {\n            v30 = v22 * 4;\n            v31 = v29;\n            do {\n              *((unsigned int *)((char *)&*(a1)->field_0 + v30)) = v31;\n              v32 = v31;\n              v31 = (unsigned int)v31 + 1;\n              v30 += 4;\n            } while (*((int *)&v2) >= (unsigned int)v31);\n            v21 = 1 + v32 + (char *)v26 - v29;\n          }\n        }\n        v20 = strtok(NULL, \",\");\n      } while (v20);\n    }\n    v19 = v21;\n    goto LABEL_404349;\n  } else {\n    __isoc99_sscanf(a0, \"%u\", (unsigned int)*(a1));\n    v19 = 1;\n    goto LABEL_404349;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbrafaxam/expand_nums_name_conflict.c:22:16: error: expected ';' at end of declaration\nlist 22 |     char field_-1; |                ^ |                ;\n/tmp/tmpbrafaxam/expand_nums_name_conflict.c:75:41: error: cannot take the address of an\nrvalue of type 'int' 75 |         if (!(*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v18 << 1) + 1)) & 8) && (char)((unsigned int)v18 -\n44) > 1) |                                         ^~~~~~~~~~~~~~~~\n/tmp/tmpbrafaxam/expand_nums_name_conflict.c:111:102: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 111 | __isoc99_sscanf(v20, \"%u\",\n(unsigned int)(struct struct_0 *)((char *)*(a1) + 0x4 * v22)); | ~~~ ^ ~~~\n/tmp/tmpbrafaxam/expand_nums_name_conflict.c:131:35: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 131 |                         v30 = v22\n* 4; |                               ~~~ ^ ~\n/tmp/tmpbrafaxam/expand_nums_name_conflict.c:135:62: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 135 | *((unsigned int *)((char\n*)&*(a1)->field_0 + v30)) = v31; | ~~~~^ ~~~~~~~\n/tmp/tmpbrafaxam/expand_nums_name_conflict.c:135:72: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 135 | *((unsigned int *)((char\n*)&*(a1)->field_0 + v30)) = v31; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(field_str)(long long, long long, long long);\n\nlong long expand_label_list(char *a0, unsigned long a1, unsigned long a2,\n                            struct struct_0 **a3, unsigned long long *a4) {\n  unsigned long long v0; // [bp-0x178]\n  unsigned long long v1; // [bp-0x50]\n  unsigned long long v2; // [bp-0x48]\n  unsigned int v3;       // [bp-0x3c]\n  struct struct_0 **v5;  // r14\n  unsigned long long v6; // rbp\n  char v7[2];            // r13\n  char v8;               // al\n  char *v9;              // rcx\n  char v10;              // al\n  char *v11;             // rsi, Other Possible Types: unsigned long\n  unsigned long v12;     // rax\n  unsigned long v13;     // edx, Other Possible Types: unsigned int\n  void *v14; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned long v15;      // rcx\n  unsigned int *v16;      // rdi\n  unsigned long long v17; // r15\n  char v18[2];            // rbp, Other Possible Types: unsigned long\n  unsigned int\n      *v19; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v21; // rax\n\n  v1 = a1;\n  v2 = a2;\n  v5 = a3;\n  v6 = strlen(a0) + 1;\n  v7 = xmalloc(v6);\n  v14 = 0;\n  v13 = 0;\n  v15 = 0;\n  do {\n    v8 = a0[v15];\n    if (v8 <= 13) {\n      v0 = 9217;\n      if (((char)(*((char *)&v0 + ((a0[v15] & 63) >> 3)) >>\n                  (a0[v15] & 63 & 7)) &\n           1)) {\n        v7[v13] = 0;\n        v14 += 1;\n        break;\n      }\n    } else if (v8 == 92) {\n      v9 = &a0[v15 + 1];\n      v10 = *(v9);\n      if (v10 == 92) {\n        v7[v13] = 92;\n      } else {\n        if (v10 == 44) {\n          v7[v13] = 44;\n        } else {\n          v12 = v13 + 1;\n          v7[v13] = 92;\n          v7[v12] = *(v9);\n          v13 = v12;\n        }\n      }\n      v11 = 2;\n      continue;\n    } else if (v8 == 44) {\n      v7[v13] = 0;\n      v14 += 1;\n      v11 = 1;\n      continue;\n    }\n    v7[v13] = v8;\n    v11 = 1;\n  } while (\n      (v13 = (unsigned long long)((unsigned int)v13 + 1), v15 = v11, v11 < v6));\n  v16 = *(v5);\n  if (!v16) {\n    *(v5) = xmalloc(v14 * 4);\n    *(a4) = v14;\n  } else if (*(a4) < v14) {\n    xrealloc(v16, v14 * 4);\n    *(a4) = v14;\n    if (!v14)\n      return -2;\n  }\n  v17 = &v7[v13 + 1];\n  v18 = v7;\n  v19 = 0;\n  v3 = 0;\n  if (v7 != v17) {\n    while (true) {\n      (unsigned int)v21 = field_str(v18, v1, v2);\n      if ((unsigned int)v21 < 0) {\n        warnx(\"Failed to find field label: %s\");\n        v3 += 1;\n      }\n      (*(v5))[v19].field_0 = (unsigned int)v21 + 1;\n      v18 = v18 + strlen(v18) + 1;\n      if (v18 == v17)\n        break;\n      v19 += 1;\n    }\n    if (v3)\n      return -1;\n    v19 = (unsigned int)v19 + 1;\n  }\n  free(v7);\n  return v19;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp6ixgyoh/expand_label_list.c:46:8: error: array type 'char[2]' is not\nassignable 46 |     v7 = xmalloc(v6); |     ~~ ^\n/tmp/tmpp6ixgyoh/expand_label_list.c:101:29: error: invalid operands to binary\nexpression ('void *' and 'int') 101 |         *(v5) = xmalloc(v14 * 4); | ~~~ ^\n~ /tmp/tmpp6ixgyoh/expand_label_list.c:106:27: error: invalid operands to binary\nexpression ('void *' and 'int') 106 |         xrealloc(v16, v14 * 4); | ~~~ ^ ~\n/tmp/tmpp6ixgyoh/expand_label_list.c:112:9: error: array type 'char[2]' is not\nassignable 112 |     v18 = v7; |     ~~~ ^\n/tmp/tmpp6ixgyoh/expand_label_list.c:119:13: error: assignment to cast is\nillegal, lvalue casts are not supported 119 |             (unsigned int)v21 =\nfield_str(v18, v1, v2); |             ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpp6ixgyoh/expand_label_list.c:125:20: error: array subscript is not an\ninteger 125 |             (*(v5))[v19].field_0 = (unsigned int)v21 + 1; | ^~~~\n/tmp/tmpp6ixgyoh/expand_label_list.c:126:17: error: array type 'char[2]' is not\nassignable 126 |             v18 = v18 + strlen(v18) + 1; |             ~~~ ^ 7\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_pos(char *a0, unsigned long a1, unsigned long long a2,\n                       unsigned int *a3, unsigned int *a4) {\n  unsigned long long v0;  // [bp-0x148]\n  char *v2;               // r13\n  unsigned int *v3;       // r14\n  char *v4;               // rax\n  unsigned long long v6;  // rax\n  unsigned int v7;        // eax\n  unsigned long long v8;  // rax\n  char v9;                // dl\n  unsigned long v10;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v11; // rcx\n  unsigned long v12;      // esi, Other Possible Types: unsigned int\n  char v13;               // dl\n  unsigned int v14;       // eax\n  unsigned long long v15; // rdx\n  unsigned int v16;       // eax\n  char *v17;              // rbx\n  unsigned long v18;      // rax\n\n  v2 = a2;\n  v3 = a3;\n  v4 = field_start(a0, (unsigned int)a1 + 1, a2);\n  if (!v4) {\n    *(a3) = -1;\n    *(a4) = -1;\n    return 4294967295;\n  }\n  *(a3) = v4 - a0;\n  v6 = strstr(v4, v2);\n  if (!v6) {\n    v8 = strlen(a0);\n    v12 = v8 - 1;\n    *(a4) = v12;\n    v9 = a0[v12];\n    if (v9 == 10 || v9 == 13) {\n      v10 = (unsigned int)v8 - 2;\n      v11 = &a0[v12 + -1 * v10];\n      while (true) {\n        v12 = v10;\n        *(a4) = v10;\n        v13 = *((char *)(v11 + v10 - 1));\n        v10 -= 1;\n      }\n    }\n    v14 = *(v3);\n    if (v14 > (unsigned int)v12)\n      *(a4) = v14;\n  } else {\n    v7 = (v4 != v6 ? (unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1);\n    *(a4) = v7;\n  }\n  v15 = *(v3);\n  v16 = *(a4);\n  if ((unsigned int)v15 != v16) {\n    v18 = v16 - (unsigned int)v15 + 1;\n    return v18;\n  }\n  v17 = &a0[v15];\n  if (*(v17) <= 13) {\n    v0 = 9217;\n    if (((char)(*((char *)&v0 + ((*(v17) & 63) >> 3)) >> (*(v17) & 63 & 7)) &\n         1))\n      return 0;\n  }\n  v18 = strncmp(v17, v2, strlen(v2));\n  return v18;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplzdrt34e/get_line_pos.c:73:44: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 73 |         v7 = (v4 != v6 ?\n(unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1); | ~~ ^ ~~\n/tmp/tmplzdrt34e/get_line_pos.c:73:70: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 73 |         v7 = (v4 != v6 ?\n(unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1); | ~~ ^ ~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(get_line_field)(long long, long long, long long, long long,\n                          long long);\n\nlong long field_str_name_conflict(char *a0, char *a1, char *a2) {\n  unsigned long v0;       // [bp-0x30]\n  unsigned long v1;       // [bp-0x28]\n  unsigned long v2;       // [bp-0x20]\n  unsigned long v3;       // [bp-0x18]\n  unsigned long v4;       // [bp-0x10]\n  unsigned long v5;       // [bp-0x8]\n  unsigned long v7;       // r15\n  unsigned long v8;       // r14\n  unsigned long v9;       // r13\n  unsigned long v10;      // r12\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rax\n  void *v15;              // r14\n  void *v16;              // rbx, Other Possible Types: unsigned long\n  unsigned long v17;      // rax, Other Possible Types: unsigned long long\n\n  if (!a0)\n    return -2;\n  v5 = v7;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  if (!a1) {\n    v17 = -1;\n  } else if (!*(a1)) {\n    v17 = -1;\n  } else if (!a2 || !*(a2)) {\n    v17 = -(0 < strcmp(a0, a1));\n  } else {\n    v12 = strlen(a0);\n    v15 = xmalloc((unsigned int)v12 + 4);\n    v16 = 0;\n    while (true) {\n      if ((int)get_line_field(v15, a1, v12 + 3, v16, a2) < 0) {\n        free(v15);\n        v17 = -1;\n        break;\n      } else if (strcmp(v15, a0)) {\n        v16 = (unsigned int)v16 + 1;\n      } else {\n        free(v15);\n        v17 = v16;\n        break;\n      }\n    }\n  }\n  return v17;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fields_in_line_name_conflict(unsigned long a0, char *a1) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long v2;      // rbp\n  unsigned long long v4; // rax\n\n  if (a0) {\n    v1 = a0;\n    if (a1) {\n      v2 = 1;\n      while (true) {\n        v4 = strstr(v1, a1);\n        if (!v4)\n          break;\n        v2 += 1;\n        v1 = v4 + strlen(a1);\n      }\n      return v2;\n    }\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_field(char *a0, char *a1, unsigned long a2, unsigned long a3,\n                         char *a4) {\n  char *v2;         // r12\n  char *v3;         // rax, Other Possible Types: unsigned long\n  unsigned long v4; // rax, Other Possible Types: unsigned long long\n  char *v5;         // rax\n  unsigned long v6; // rbx\n\n  if (a4 && *(a4)) {\n    v2 = field_start(a1, (unsigned int)a3 + 1, a4);\n    if (!v2) {\n      *(a0) = 0;\n      return 4294967295;\n    }\n    v4 = strstr(v2, a4);\n    if (!v4) {\n      v3 = &a1[strlen(a1) + 1];\n      a2 = *(v3);\n      if (a2 != 10 && a2 != 13)\n        goto LABEL_40147d;\n      while (true) {\n        v3 -= 1;\n        a2 = *((char *)v3);\n      }\n    LABEL_40147d:\n      v4 = v3 + 1;\n    }\n    v5 = v4 - v2;\n    v6 = a2 - 1;\n    if (v6 <= v6)\n      v6 = v5;\n    strncpy(a0, v2, v6);\n    a0[v6] = 0;\n    return v6;\n  }\n  strncpy(a0, a1, a2);\n  a0[a2] = 0;\n  return strlen(a0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpec_qnolg/get_line_field.c:50:17: error: invalid operands to binary\nexpression ('unsigned long' and 'char *') 50 |         v5 = v4 - v2; | ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\nlong long(xmalloc)(long long);\nchar *(strncpy)(char *, char *, unsigned long);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long copy_field(unsigned long long a0, char **a1, unsigned long long *a2,\n                     unsigned long a3, char *a4) {\n  char *v1;              // rax\n  char *v2;              // rbp\n  struct_0 *v3;          // rax, Other Possible Types: unsigned long\n  char *v4;              // rax\n  unsigned long long v6; // rdi\n  unsigned long long v7; // r15\n  unsigned long long v8; // r15\n\n  v1 = field_start(a0, a3 + 1, a4);\n  if (!v1)\n    return 4294967295;\n  v2 = v1;\n  v3 = strstr(v1, a4);\n  if (!v3) {\n    v3 = &v2[strlen(v2)];\n    a2 = *((char *)(v3 - 1));\n    if (a2 != 10 && a2 != 13)\n      goto LABEL_4014c5;\n    while (true) {\n      v3 -= 1;\n      a2 = *((char *)(v3 - 1));\n    }\n  }\nLABEL_4014c5:\n  v4 = v3 - v2;\n  v6 = *(a1);\n  if (!a2 || !v6) {\n    v8 = v4 + 1;\n    *(a1) = xmalloc(v8);\n    *((unsigned long long *)a2) = v8;\n  } else {\n    v7 = v4 + 1;\n    if (*((long long *)a2) < v7) {\n      *(a1) = xrealloc(v6, v7);\n      *((unsigned long long *)a2) = v7;\n    }\n  }\n  *((char *)(*(a1) + v4)) = 0;\n  strncpy(*(a1), v2, v4);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwhc1_b6s/copy_field.c:21:16: error: expected ';' at end of declaration\nlist 21 |     char field_-1; |                ^ |                ;\n/tmp/tmpwhc1_b6s/copy_field.c:52:13: error: 'struct_0 *' (aka 'struct struct_0\n*') and 'char *' are not pointers to compatible types 52 |     v4 = v3 - v2; |\n~~ ^ ~~ /tmp/tmpwhc1_b6s/copy_field.c:69:22: error: invalid operands to binary\nexpression ('char *' and 'char *') 69 |     *((char *)(*(a1) + v4)) = 0; | ~~~~~\n^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long field_start_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v3; // r14\n  void *v4;              // rbp, Other Possible Types: unsigned long\n  unsigned long v5;      // rax\n\n  v1 = a0;\n  if (a1 <= 1)\n    return a0;\n  v3 = strlen(a2);\n  v4 = 0;\n  while (v5) {\n    v5 = strstr(v1, a2);\n    v1 = v5 + v3;\n    v4 += 1;\n    if (v4 == a1 - 1)\n      return v1;\n  }\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mdyhms_datecmp_name_conflict(char a0[10], char a1[10]) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0[6] == a1[6] && a0[7] == a1[7] && a0[8] == a1[8] && a0[9] == a1[9]) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  (unsigned int)v1 = strncmp(&a0[6], &a1[6], 4);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9ge5xtsn/mdyhms_datecmp_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp9ge5xtsn/mdyhms_datecmp_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v1 = strncmp(&a0[6],\n&a1[6], 4); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long dmyhms_datecmp_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = strncmp(a0 + 6, a1 + 6, 4);\n  if ((unsigned int)v1)\n    return v1;\n  (unsigned int)v1 = strncmp(a0 + 3, a1 + 3, 2);\n  if (!(unsigned int)v1) {\n    (unsigned int)v1 = strcmp(a0, a1);\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy4qz_das/dmyhms_datecmp_name_conflict.c:21:5: error: assignment to cast is illegal,\nlvalue casts are not supported 21 |     (unsigned int)v1 = strncmp(a0 + 6, a1 +\n6, 4); |     ^~~~~~~~~~~~~~~~ ~ /tmp/tmpy4qz_das/dmyhms_datecmp_name_conflict.c:24:5: error:\nassignment to cast is illegal, lvalue casts are not supported 24 |     (unsigned\nint)v1 = strncmp(a0 + 3, a1 + 3, 2); |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpy4qz_das/dmyhms_datecmp_name_conflict.c:27:9: error: assignment to cast is illegal,\nlvalue casts are not supported 27 |         (unsigned int)v1 = strcmp(a0, a1);\n      |         ^~~~~~~~~~~~~~~~ ~\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nchar *(strtok)(char *, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_1 {\n  char field_ - 1;\n} struct_1;\n\nlong long expand_nums_name_conflict(char *a0, struct struct_0 **a1, unsigned long long *a2) {\n  unsigned long v0;        // [bp-0x50]\n  char v1;                 // [bp-0x40]\n  char v2;                 // [bp-0x3c]\n  unsigned long v3;        // [bp-0x30]\n  unsigned long v4;        // [bp-0x28]\n  unsigned long v5;        // [bp-0x20]\n  unsigned long v6;        // [bp-0x18]\n  unsigned long v7;        // [bp-0x10]\n  unsigned long v8;        // [bp-0x8]\n  unsigned long v10;       // r15\n  unsigned long v11;       // r14\n  unsigned long v12;       // r13\n  unsigned long v13;       // r12\n  unsigned long v14;       // rbx\n  unsigned long long *v15; // r15\n  struct_1 *v17; // rax, Other Possible Types: unsigned long, unsigned long long\n  unsigned long v18; // rbx, Other Possible Types: unsigned long long\n  unsigned int *v19; // rax, Other Possible Types: unsigned long\n  char *v20; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned int\n      *v21; // r13, Other Possible Types: unsigned long, unsigned long long\n  unsigned int *v22;      // rbx\n  unsigned long long v23; // r14\n  unsigned long long v24; // r14\n  unsigned long long v25; // rax\n  unsigned int *v26;      // r14\n  unsigned long long v27; // r12\n  unsigned long long v28; // r12\n  unsigned long long v29; // rcx\n  unsigned int *v30;      // rbx, Other Possible Types: unsigned long\n  unsigned long v31;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v32; // rdx\n\n  if (!a0)\n    return 0;\n  v8 = v10;\n  v7 = v11;\n  v6 = v12;\n  v5 = v13;\n  *((int *)&v4) = rbp;\n  v3 = v14;\n  v15 = a2;\n  v18 = *(a0);\n  v19 = 0;\n  if (!(char)v18)\n    return v19;\n  v17 = a0 + 1;\n  do {\n    if (!(*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v18 << 1) + 1)) &\n          8) &&\n        (char)((unsigned int)v18 - 44) > 1) {\n    LABEL_401906:\n      return -2;\n    }\n  } while ((v17 += 1, v18 = (unsigned long long)v17[1].field_ - 1, (char)v18));\n  if (!*(a1) && !*(a2)) {\n    *(a1) = xmalloc(64);\n    *(a2) = 16;\n  }\n  if (strchr(a0, 44) || strchr(a0, 45)) {\n    v20 = strtok(a0, \",\");\n    if (!v20) {\n      v21 = 0;\n    } else {\n      v21 = 0;\n      v0 = &v2;\n      do {\n        v22 = v21;\n        v23 = *(v15);\n        if (v21 >= v23) {\n          v24 = v23 + 16;\n          xrealloc(*(a1), v24 * 4);\n          *(v15) = v24;\n          if (!v24)\n            return -1;\n        }\n        if (!strchr(v20, 45)) {\n          __isoc99_sscanf(\n              v20, \"%u\",\n              (unsigned int)(struct struct_0 *)((char *)*(a1) + 0x4 * v22));\n          v21 = (unsigned int)v21 + 1;\n        } else {\n          __isoc99_sscanf(v20, \"%u-%u\", (unsigned int)&v1, (unsigned int)v0);\n          v25 = *(v15);\n          v26 = v21;\n          v27 = *((int *)&v2) - *((int *)&v1);\n          if (v25 < v21 + v27) {\n            v28 = v27 + v25;\n            xrealloc(*(a1), v28 * 4);\n            *(v15) = v28;\n            if (!v28)\n              return -1;\n          }\n          v29 = *((int *)&v1);\n          if (*((int *)&v2) >= (unsigned int)v29) {\n            v30 = v22 * 4;\n            v31 = v29;\n            do {\n              *((unsigned int *)((char *)&*(a1)->field_0 + v30)) = v31;\n              v32 = v31;\n              v31 = (unsigned int)v31 + 1;\n              v30 += 4;\n            } while (*((int *)&v2) >= (unsigned int)v31);\n            v21 = 1 + v32 + (char *)v26 - v29;\n          }\n        }\n        v20 = strtok(NULL, \",\");\n      } while (v20);\n    }\n    v19 = v21;\n    goto LABEL_401906;\n  } else {\n    __isoc99_sscanf(a0, \"%u\", (unsigned int)*(a1));\n    v19 = 1;\n    goto LABEL_401906;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo0rp5l2k/expand_nums_name_conflict.c:22:16: error: expected ';' at end of declaration\nlist 22 |     char field_-1; |                ^ |                ;\n/tmp/tmpo0rp5l2k/expand_nums_name_conflict.c:75:41: error: cannot take the address of an\nrvalue of type 'int' 75 |         if (!(*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v18 << 1) + 1)) & 8) && (char)((unsigned int)v18 -\n44) > 1) |                                         ^~~~~~~~~~~~~~~~\n/tmp/tmpo0rp5l2k/expand_nums_name_conflict.c:111:102: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 111 | __isoc99_sscanf(v20, \"%u\",\n(unsigned int)(struct struct_0 *)((char *)*(a1) + 0x4 * v22)); | ~~~ ^ ~~~\n/tmp/tmpo0rp5l2k/expand_nums_name_conflict.c:131:35: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 131 |                         v30 = v22\n* 4; |                               ~~~ ^ ~\n/tmp/tmpo0rp5l2k/expand_nums_name_conflict.c:135:62: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 135 | *((unsigned int *)((char\n*)&*(a1)->field_0 + v30)) = v31; | ~~~~^ ~~~~~~~\n/tmp/tmpo0rp5l2k/expand_nums_name_conflict.c:135:72: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 135 | *((unsigned int *)((char\n*)&*(a1)->field_0 + v30)) = v31; | ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(field_str)(long long, long long, long long);\n\nlong long expand_label_list(char *a0, unsigned long a1, unsigned long a2,\n                            struct struct_0 **a3, unsigned long long *a4) {\n  unsigned long long v0; // [bp-0x178]\n  unsigned long long v1; // [bp-0x50]\n  unsigned long long v2; // [bp-0x48]\n  unsigned int v3;       // [bp-0x3c]\n  struct struct_0 **v5;  // r14\n  unsigned long long v6; // rbp\n  char v7[2];            // r13\n  char v8;               // al\n  char *v9;              // rcx\n  char v10;              // al\n  char *v11;             // rsi, Other Possible Types: unsigned long\n  unsigned long v12;     // rax\n  unsigned long v13;     // edx, Other Possible Types: unsigned int\n  void *v14; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned long v15;      // rcx\n  unsigned int *v16;      // rdi\n  unsigned long long v17; // r15\n  char v18[2];            // rbp, Other Possible Types: unsigned long\n  unsigned int\n      *v19; // r12, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v21; // rax\n\n  v1 = a1;\n  v2 = a2;\n  v5 = a3;\n  v6 = strlen(a0) + 1;\n  v7 = xmalloc(v6);\n  v14 = 0;\n  v13 = 0;\n  v15 = 0;\n  do {\n    v8 = a0[v15];\n    if (v8 <= 13) {\n      v0 = 9217;\n      if (((char)(*((char *)&v0 + ((a0[v15] & 63) >> 3)) >>\n                  (a0[v15] & 63 & 7)) &\n           1)) {\n        v7[v13] = 0;\n        v14 += 1;\n        break;\n      }\n    } else if (v8 == 92) {\n      v9 = &a0[v15 + 1];\n      v10 = *(v9);\n      if (v10 == 92) {\n        v7[v13] = 92;\n      } else {\n        if (v10 == 44) {\n          v7[v13] = 44;\n        } else {\n          v12 = v13 + 1;\n          v7[v13] = 92;\n          v7[v12] = *(v9);\n          v13 = v12;\n        }\n      }\n      v11 = 2;\n      continue;\n    } else if (v8 == 44) {\n      v7[v13] = 0;\n      v14 += 1;\n      v11 = 1;\n      continue;\n    }\n    v7[v13] = v8;\n    v11 = 1;\n  } while (\n      (v13 = (unsigned long long)((unsigned int)v13 + 1), v15 = v11, v11 < v6));\n  v16 = *(v5);\n  if (!v16) {\n    *(v5) = xmalloc(v14 * 4);\n    *(a4) = v14;\n  } else if (*(a4) < v14) {\n    xrealloc(v16, v14 * 4);\n    *(a4) = v14;\n    if (!v14)\n      return -2;\n  }\n  v17 = &v7[v13 + 1];\n  v18 = v7;\n  v19 = 0;\n  v3 = 0;\n  if (v7 != v17) {\n    while (true) {\n      (unsigned int)v21 = field_str(v18, v1, v2);\n      if ((unsigned int)v21 < 0) {\n        warnx(\"Failed to find field label: %s\");\n        v3 += 1;\n      }\n      (*(v5))[v19].field_0 = (unsigned int)v21 + 1;\n      v18 = v18 + strlen(v18) + 1;\n      if (v18 == v17)\n        break;\n      v19 += 1;\n    }\n    if (v3)\n      return -1;\n    v19 = (unsigned int)v19 + 1;\n  }\n  free(v7);\n  return v19;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt14lbuwn/expand_label_list.c:46:8: error: array type 'char[2]' is not\nassignable 46 |     v7 = xmalloc(v6); |     ~~ ^\n/tmp/tmpt14lbuwn/expand_label_list.c:101:29: error: invalid operands to binary\nexpression ('void *' and 'int') 101 |         *(v5) = xmalloc(v14 * 4); | ~~~ ^\n~ /tmp/tmpt14lbuwn/expand_label_list.c:106:27: error: invalid operands to binary\nexpression ('void *' and 'int') 106 |         xrealloc(v16, v14 * 4); | ~~~ ^ ~\n/tmp/tmpt14lbuwn/expand_label_list.c:112:9: error: array type 'char[2]' is not\nassignable 112 |     v18 = v7; |     ~~~ ^\n/tmp/tmpt14lbuwn/expand_label_list.c:119:13: error: assignment to cast is\nillegal, lvalue casts are not supported 119 |             (unsigned int)v21 =\nfield_str(v18, v1, v2); |             ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpt14lbuwn/expand_label_list.c:125:20: error: array subscript is not an\ninteger 125 |             (*(v5))[v19].field_0 = (unsigned int)v21 + 1; | ^~~~\n/tmp/tmpt14lbuwn/expand_label_list.c:126:17: error: array type 'char[2]' is not\nassignable 126 |             v18 = v18 + strlen(v18) + 1; |             ~~~ ^ 7\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(field_start)(long long, long long, long long);\n\nlong long get_line_pos(char *a0, unsigned long a1, unsigned long long a2,\n                       unsigned int *a3, unsigned int *a4) {\n  unsigned long long v0;  // [bp-0x148]\n  char *v2;               // r13\n  unsigned int *v3;       // r14\n  char *v4;               // rax\n  unsigned long long v6;  // rax\n  unsigned int v7;        // eax\n  unsigned long long v8;  // rax\n  char v9;                // dl\n  unsigned long v10;      // rax, Other Possible Types: unsigned long long\n  unsigned long long v11; // rcx\n  unsigned long v12;      // esi, Other Possible Types: unsigned int\n  char v13;               // dl\n  unsigned int v14;       // eax\n  unsigned long long v15; // rdx\n  unsigned int v16;       // eax\n  char *v17;              // rbx\n  unsigned long v18;      // rax\n\n  v2 = a2;\n  v3 = a3;\n  v4 = field_start(a0, (unsigned int)a1 + 1, a2);\n  if (!v4) {\n    *(a3) = -1;\n    *(a4) = -1;\n    return 4294967295;\n  }\n  *(a3) = v4 - a0;\n  v6 = strstr(v4, v2);\n  if (!v6) {\n    v8 = strlen(a0);\n    v12 = v8 - 1;\n    *(a4) = v12;\n    v9 = a0[v12];\n    if (v9 == 10 || v9 == 13) {\n      v10 = (unsigned int)v8 - 2;\n      v11 = &a0[v12 + -1 * v10];\n      while (true) {\n        v12 = v10;\n        *(a4) = v10;\n        v13 = *((char *)(v11 + v10 - 1));\n        v10 -= 1;\n      }\n    }\n    v14 = *(v3);\n    if (v14 > (unsigned int)v12)\n      *(a4) = v14;\n  } else {\n    v7 = (v4 != v6 ? (unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1);\n    *(a4) = v7;\n  }\n  v15 = *(v3);\n  v16 = *(a4);\n  if ((unsigned int)v15 != v16) {\n    v18 = v16 - (unsigned int)v15 + 1;\n    return v18;\n  }\n  v17 = &a0[v15];\n  if (*(v17) <= 13) {\n    v0 = 9217;\n    if (((char)(*((char *)&v0 + ((*(v17) & 63) >> 3)) >> (*(v17) & 63 & 7)) &\n         1))\n      return 0;\n  }\n  v18 = strncmp(v17, v2, strlen(v2));\n  return v18;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0km1ls9y/get_line_pos.c:73:44: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 73 |         v7 = (v4 != v6 ?\n(unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1); | ~~ ^ ~~\n/tmp/tmp0km1ls9y/get_line_pos.c:73:70: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 73 |         v7 = (v4 != v6 ?\n(unsigned int)(v6 - a0) : (unsigned int)(v6 - a0) - 1); | ~~ ^ ~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xmalloc)(long long);\nlong long(get_line_field)(long long, long long, long long, long long,\n                          long long);\n\nlong long field_str_name_conflict(char *a0, char *a1, char *a2) {\n  unsigned long v0;       // [bp-0x30]\n  unsigned long v1;       // [bp-0x28]\n  unsigned long v2;       // [bp-0x20]\n  unsigned long v3;       // [bp-0x18]\n  unsigned long v4;       // [bp-0x10]\n  unsigned long v5;       // [bp-0x8]\n  unsigned long v7;       // r15\n  unsigned long v8;       // r14\n  unsigned long v9;       // r13\n  unsigned long v10;      // r12\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rax\n  void *v15;              // r14\n  void *v16;              // rbx, Other Possible Types: unsigned long\n  unsigned long v17;      // rax, Other Possible Types: unsigned long long\n\n  if (!a0)\n    return -2;\n  v5 = v7;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  if (!a1) {\n    v17 = -1;\n  } else if (!*(a1)) {\n    v17 = -1;\n  } else if (!a2 || !*(a2)) {\n    v17 = -(0 < strcmp(a0, a1));\n  } else {\n    v12 = strlen(a0);\n    v15 = xmalloc((unsigned int)v12 + 4);\n    v16 = 0;\n    while (true) {\n      if ((int)get_line_field(v15, a1, v12 + 3, v16, a2) < 0) {\n        free(v15);\n        v17 = -1;\n        break;\n      } else if (strcmp(v15, a0)) {\n        v16 = (unsigned int)v16 + 1;\n      } else {\n        free(v15);\n        v17 = v16;\n        break;\n      }\n    }\n  }\n  return v17;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nvoid(warn)(char *, ...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1) {\n    strlen(a0);\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\");\n    exit(1); /* do not return */\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"int qsort_strcmp(const char **a, const char **b) {\n    return strcmp(*a, *b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long qsort_strcmp_name_conflict(char **a0, unsigned long long *a1) {\n  return strcmp(*(a0), *(a1));\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_intcmp(const int *a, const int *b) {\n    return *a - *b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long qsort_intcmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a0) - *(a1);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_uintcmp(const unsigned int *a, const unsigned int *b) {\n    return *a - *b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long qsort_uintcmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a0) - *(a1);\n}\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"static char *striplower(char *s) {\n    char *p = ((void *)0);\n    for (p = s; p && *p; p++) {\n        if (*p == '/')\n            *p = ',';\n        *p = tolower(*p);\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_tolower_loc)();\n\nlong long striplower_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n  char v2;  // al\n  char v3;  // al\n\n  v1 = a0;\n  if (!a0)\n    return a0;\n  while (true) {\n    v2 = *((char *)v1);\n    if (!v2)\n      break;\n    if (v2 == 47)\n      *((char *)v1) = 44;\n    v3 = *((int *)(*((long long *)&__ctype_tolower_loc()) + *((char *)v1) * 4));\n    *((char *)v1) = v3;\n    v1 += 1;\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5hjeil1q/striplower_name_conflict.c:34:39: error: cannot take the address of an rvalue\nof type 'char *' 34 |         v3 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + *((char *)v1) * 4)); | ^~~~~~~~~~~~~~~~~~~~~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int get_filepath(char *filepath, size_t len, char *channel, char *file) {\n    if (channel) {\n        if (!snprintf(filepath, len, \"%s/%s\", path, channel))\n            return 0;\n        create_dirtree(filepath);\n        return snprintf(filepath, len, \"%s/%s/%s\", path, channel, file);\n    }\n    return snprintf(filepath, len, \"%s/%s\", path, file);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int open_channel(char *name) {\n    static char infile[256];\n    create_filepath(infile, sizeof (infile), name, \"in\");\n    if (access(infile, 0) == -1)\n        mkfifo(infile, (256 | 128 | 64));\n    return open(infile, 0 | 2048, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(create_filepath)(long long, long long, long long, long long);\nint(access)(char *, int);\nint(mkfifo)(char *, unsigned short);\nint(open)(char *, int, unsigned short);\n\nextern char infile.3;\n\nlong long open_channel_name_conflict(unsigned long long a0) {\n  create_filepath(&infile.3, 0x100, a0, \"in\");\n  if (access(&infile.3, 0) != -1)\n    return open(&infile.3, 0x800, 0);\n  mkfifo(&infile.3, 448);\n  return open(&infile.3, 0x800, 0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:21:19: error: expected ';' after top level\ndeclarator 21 | extern char infile.3; |                   ^ | ;\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:25:28: error: expected ')'\n   25 |     create_filepath(&infile.3, 0x100, a0, \"in\");\n      |                            ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:25:20: note: to match this '('\n   25 |     create_filepath(&infile.3, 0x100, a0, \"in\");\n      |                    ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:26:23: error: expected ')'\n   26 |     if (access(&infile.3, 0) != -1)\n      |                       ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:26:15: note: to match this '('\n   26 |     if (access(&infile.3, 0) != -1)\n      |               ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:27:28: error: expected ')'\n   27 |         return open(&infile.3, 0x800, 0);\n      |                            ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:27:20: note: to match this '('\n   27 |         return open(&infile.3, 0x800, 0);\n      |                    ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:28:19: error: expected ')'\n   28 |     mkfifo(&infile.3, 448);\n      |                   ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:28:11: note: to match this '('\n   28 |     mkfifo(&infile.3, 448);\n      |           ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:29:24: error: expected ')'\n   29 |     return open(&infile.3, 0x800, 0);\n      |                        ^\n/tmp/tmpx9v5z0vi/open_channel_name_conflict.c:29:16: note: to match this '('\n   29 |     return open(&infile.3, 0x800, 0);\n      |                ^\n6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int tcpopen(unsigned short port) {\n    int fd;\n    struct sockaddr_in sin;\n    memset(&sin, 0, sizeof(struct sockaddr_in));\n    struct hostent *hp = gethostbyname(host);\n    if (!hp) {\n        perror(\"plom-ii: cannot retrieve host information\");\n        exit(1);\n    }\n    memcpy(&sin.sin_addr, hp->h_addr_list[0], hp->h_length);\n    sin.sin_family = 2;\n    sin.sin_port = htons(port);\n    if ((fd = socket(2, SOCK_STREAM, 0)) < 0) {\n        perror(\"plom-ii: cannot create socket\");\n        exit(1);\n    }\n    if (connect(fd, (const struct sockaddr *)&sin, sizeof (sin)) < 0) {\n        perror(\"plom-ii: cannot connect to host\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static size_t tokenize(char **result, size_t reslen, char *str, char delim) {\n    char *p = ((void *)0), *n = ((void *)0);\n    size_t i;\n    if (!str)\n        return 0;\n    for (n = str; *n == ' '; n++)\n        ;\n    p = n;\n    for (i = 0; *n != 0;) {\n        if (i == reslen)\n            return 0;\n        if (*n == delim) {\n            *n = 0;\n            result[i++] = p;\n            p = ++n;\n        } else\n            n++;\n    }\n    if (i < reslen && p < n && strlen(p))\n        result[i++] = p;\n    return i;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int read_line(int fd, size_t res_len, char *buf) {\n    size_t i = 0;\n    char c = 0;\n    do {\n        if (read(fd, &c, sizeof(char)) != sizeof(char))\n            return -1;\n        buf[i++] = c;\n    } while (c != '\\n' && i < res_len);\n    buf[i - 1] = 0;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long read_line_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char v0;  // [bp-0x29]\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rcx\n  char v4;  // al\n\n  v0 = 0;\n  v2 = a2;\n  while (true) {\n    if (read(a0, &v0, 1) == 1) {\n      v3 = v2;\n      v4 = v0;\n      *((char *)v2) = v4;\n      a2 = v2 - a2 + 1 < a1;\n      v2 += 1;\n      if (!(v4 != 10 & a2)) {\n        *(v3) = 0;\n        return 0;\n      }\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptzylz1vv/read_line_name_conflict.c:36:28: error: invalid operands to binary expression\n('int' and 'char *') 36 |             if (!(v4 != 10 & a2)) | ~~~~~~~~ ^ ~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"int Needs_Quote(char *str) {\n    while (*str)\n        {\n            if (!((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) && strchr(\"-_./\", *str) == ((void *)0))\n                return 1;\n            str++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Needs_Quote_name_conflict(char *a0) {\n  unsigned long v1; // rbx, Other Possible Types: unsigned long long\n  char *v2;         // rbp, Other Possible Types: unsigned long\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = a0;\n  while (true) {\n    if (!(*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v1 << 1))) &\n          8) &&\n        !strchr(\"-_./\", (char)v1))\n      return 1;\n    v2 += 1;\n    v1 = *(v2);\n    if (!(char)v1)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa3c__4tk/Needs_Quote_name_conflict.c:28:41: error: cannot take the address of an\nrvalue of type 'int' 28 |         if (!(*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v1 << 1))) & 8) && !strchr(\"-_./\", (char)v1)) |\n^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"char *Get_Label(char *str) {\n    if (((*__ctype_b_loc())[(int)((*buff))] & (unsigned short)_ISspace))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) || strchr(\".$_\", *str))\n        str++;\n    if (*str != ':' || str[1] != '\\x00')\n        return ((void *)0);\n    *str = '\\x00';\n    return buff;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char buff;\n\nlong long Get_Label_name_conflict(char a0[2]) {\n  char v1[2];            // rbx, Other Possible Types: unsigned long\n  char *v2;              // r12\n  unsigned long v3;      // rax\n  unsigned long long v4; // rbp\n\n  v1 = a0;\n  v2 = *((long long *)&__ctype_b_loc());\n  if ((v2[1 + 2 * buff] & 32))\n    return 0;\n  while (true) {\n    v4 = *((char *)v1);\n    if (!((v2[2 * (char)v4] & 8)) &&\n        !((v3 = strchr(\".$_\", (unsigned int)(char)v4), v3)))\n      break;\n    v1 += 1;\n  }\n  if (!((char)v4 == 58 && !*((char *)(v1 + 1))))\n    return v3;\n  *((char *)v1) = 0;\n  v3 = &buff;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsxcbrjb8/Get_Label_name_conflict.c:26:8: error: array type 'char[2]' is not assignable\n   26 |     v1 = a0;\n      |     ~~ ^\n/tmp/tmpsxcbrjb8/Get_Label_name_conflict.c:27:25: error: cannot take the address of an rvalue\nof type 'int' 27 |     v2 = *((long long *)&__ctype_b_loc()); | ^~~~~~~~~~~~~~~~\n/tmp/tmpsxcbrjb8/Get_Label_name_conflict.c:35:12: error: invalid operands to binary expression\n('char[2]' and 'int') 35 |         v1 += 1; |         ~~ ^  ~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"int Detect_End_Of_Fct(char *buff) {\n    if (strncmp(buff, \"END\", 3) == 0)\n        return 1;\n    {\n        static int i = 0;\n        if (i == 0) {\n            fprintf(stderr, \"warning, Detect_End_Of_Fct() not customizedfor this architecture\\n)\");\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int i.0;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long Detect_End_Of_Fct_name_conflict(char *a0) {\n  unsigned long v1; // rbx\n\n  if (!strncmp(a0, \"END\", 3))\n    return 1;\n  v1 = i.0;\n  if (i.0)\n    return 0;\n  fwrite(\"warning, Detect_End_Of_Fct_name_conflict() not customizedfor this architecture\\n)\",\n         1, 66, stderr @GLIBC_2.2.5);\n  i.0 = i.0 + 1;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern unsigned int i.0; |                      ^ | ;\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:18:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:26:11: error: expected ';' after expression\n   26 |     v1 = i.0;\n      |           ^\n      |           ;\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:27:10: error: expected ')'\n   27 |     if (i.0)\n      |          ^\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:27:8: note: to match this '('\n   27 |     if (i.0)\n      |        ^\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:29:96: error: expected ')'\n   29 |     fwrite(\"warning, Detect_End_Of_Fct_name_conflict() not customizedfor this\narchitecture\\n)\", 1, 66, stderr@GLIBC_2.2.5); | ^\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:29:11: note: to match this '('\n   29 |     fwrite(\"warning, Detect_End_Of_Fct_name_conflict() not customizedfor this\narchitecture\\n)\", 1, 66, stderr@GLIBC_2.2.5); |           ^\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:30:6: error: expected ';' after expression\n   30 |     i.0 = i.0 + 1;\n      |      ^\n      |      ;\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:30:9: error: expression is not assignable\n   30 |     i.0 = i.0 + 1;\n      |      ~~ ^\n/tmp/tmplinlyhae/Detect_End_Of_Fct_name_conflict.c:30:12: error: expected ';' after expression\n   30 |     i.0 = i.0 + 1;\n      |            ^\n      |            ;\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"static int Common_Prefix_Length(char *str1, int l1, char *str2, int l2) {\n    if (l1 < l2)\n        l2 = l1;\n    l1 = 0;\n    while (l1 < l2 && *str1 == *str2)\n        {\n            str1++;\n            str2++;\n            l1++;\n        }\n    return l1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":0,"function":"int Display_Completion(char *str, int length, int no) {\n    printf(\"match %6d  :<%s> len=%d\\n\", no, str, length);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Display_Completion(unsigned long a0, unsigned long a1,\n                             unsigned long a2) {\n  printf(\"match %6d  :<%s> len=%d\\n\", (unsigned int)a2, (unsigned int)a0,\n         (unsigned int)a1);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":0,"function":"static int init_mparams(void) {\n    ;\n    if (mparams.magic == 0) {\n        size_t magic;\n        size_t psize;\n        size_t gsize;\n        psize = sysconf(_SC_PAGESIZE);\n        gsize = (((0) != 0) ? (0) : psize);\n        if ((sizeof(size_t) != sizeof(char *)) || ((~(size_t)0) < (((sizeof(mchunk)) + (((size_t)8U) - ((size_t)1))) & ~(((size_t)8U) - ((size_t)1)))) || (sizeof(int) < 4) || (((size_t)8U) < (size_t)8U) || ((((size_t)8U) & (((size_t)8U) - ((size_t)1))) != 0) || (((sizeof(mchunk)) & ((sizeof(mchunk)) - ((size_t)1))) != 0) || ((gsize & (gsize - ((size_t)1))) != 0) || ((psize & (psize - ((size_t)1))) != 0))\n            abort();\n        mparams.granularity = gsize;\n        mparams.page_size = psize;\n        mparams.mmap_threshold = ((size_t)256U * (size_t)1024U);\n        mparams.trim_threshold = ((size_t)2U * (size_t)1024U * (size_t)1024U);\n        mparams.default_mflags = (0U) | (((size_t)1));\n        (&_gm_)->mflags = mparams.default_mflags;\n        (void)(0);\n        {\n            magic = (size_t)(time(0) ^ (size_t)1431655765U);\n            magic |= (size_t)8U;\n            magic &= ~(size_t)7U;\n            (*(volatile size_t *)(&(mparams.magic))) = magic;\n        }\n    }\n    ;\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sysconf)(int);\nlong(time)(long *);\n\nextern unsigned int g_4084f0;\nextern unsigned long long g_408548;\nextern unsigned long long g_408550;\nextern unsigned long long g_408558;\nextern unsigned long long g_408560;\nextern unsigned int g_408568;\nextern unsigned long long mparams;\n\nlong long init_mparams_name_conflict() {\n  unsigned long long v1; // rax\n\n  if (mparams)\n    return 1;\n  v1 = sysconf(30);\n  if (!(v1 & v1 - 1)) {\n    g_408550 = v1;\n    g_408548 = v1;\n    g_408558 = 0x40000;\n    g_408560 = 0x200000;\n    g_408568 = 1;\n    g_4084f0 = 1;\n    mparams = (time(NULL) ^ 1431655765) & -8 | 8;\n    return 1;\n  }\n  abort(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"static int change_mparam(int param_number, int value) {\n    size_t val;\n    (void)(mparams.magic != 0 || init_mparams());\n    val = (value == -1) ? (~(size_t)0) : (size_t)value;\n    switch (param_number) {\n      case (-1):\n        mparams.trim_threshold = val;\n        return 1;\n      case (-2):\n        if (val >= mparams.page_size && ((val & (val - 1)) == 0)) {\n            mparams.granularity = val;\n            return 1;\n        } else\n            return 0;\n      case (-3):\n        mparams.mmap_threshold = val;\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int malloc_trim(size_t pad) {\n    int result = 0;\n    (void)(mparams.magic != 0 || init_mparams());\n    if (!(0)) {\n        result = sys_trim((&_gm_), pad);\n        ;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_mparams)();\nlong long(sys_trim)(long long, long long);\n\nextern unsigned long long _gm_;\nextern unsigned long long mparams;\n\nlong long malloc_trim_name_conflict(unsigned long long a0) {\n  if (mparams)\n    return sys_trim(&_gm_, a0);\n  init_mparams();\n  return sys_trim(&_gm_, a0);\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint(void) {\n    return (&_gm_)->footprint;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_4084d8;\n\nlong long malloc_footprint_name_conflict() { return g_4084d8; }\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_max_footprint(void) {\n    return (&_gm_)->max_footprint;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_4084e0;\n\nlong long malloc_max_footprint_name_conflict() { return g_4084e0; }\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint_limit(void) {\n    size_t maf = (&_gm_)->footprint_limit;\n    return maf == 0 ? (~(size_t)0) : maf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_4084e8;\n\nlong long malloc_footprint_limit_name_conflict() {\n  if (g_4084e8)\n    return g_4084e8;\n  return -1;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_set_footprint_limit(size_t bytes) {\n    size_t result;\n    if (bytes == 0)\n        result = (((1) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    if (bytes == (~(size_t)0))\n        result = 0;\n    else\n        result = (((bytes) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    return (&_gm_)->footprint_limit = result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long g_4084e8;\nextern unsigned long long g_408550;\n\nlong long malloc_set_footprint_limit_name_conflict(unsigned long a0) {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if (a0 != -1)\n    v1 = g_408550 + a0 - 1 & -(g_408550);\n  g_4084e8 = v1;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"struct mallinfo mallinfo(void) {\n    return internal_mallinfo((&_gm_));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_mparams)();\n\ntypedef struct struct_1 {\n  struct struct_0 *field_0;\n  unsigned long long field_8;\n  struct struct_1 *field_10;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  unsigned long long field_8;\n} struct_0;\n\nextern unsigned long long g_408190;\nextern unsigned long long g_4081a8;\nextern unsigned long long g_4084d8;\nextern unsigned long long g_4084e0;\nextern struct_1 g_4084f8;\nextern unsigned long long mparams;\n\nlong long mallinfo_name_conflict(unsigned long long a0[10]) {\n  int tmp_9;                 // tmp #9\n  unsigned long long v1[10]; // rbx\n  void *v2;                  // rbp, Other Possible Types: unsigned long\n  void *v3;                  // rcx, Other Possible Types: unsigned long\n  void *v4;     // r10, Other Possible Types: unsigned long, unsigned long long\n  void *v5;     // rsi, Other Possible Types: unsigned long\n  struct_0 *v6; // rdi\n  struct_0 *v7; // rax, Other Possible Types: unsigned long\n  unsigned long long v8;  // rax\n  unsigned long long v9;  // r12\n  unsigned long long v10; // rdx\n  unsigned long long v11; // rcx\n  void *v13;     // r9, Other Possible Types: unsigned long, unsigned long long\n  struct_1 *v14; // r11, Other Possible Types: unsigned long\n  void *v15;     // rdx, Other Possible Types: unsigned long\n  void *v16;     // rax, Other Possible Types: unsigned long\n\n  v1 = a0;\n  if (!mparams)\n    init_mparams();\n  if (!g_4081a8) {\n    v2 = 0;\n    v13 = 0;\n    v16 = 0;\n    v15 = 0;\n    v3 = 0;\n    v4 = 0;\n    v5 = 0;\n  } else {\n    v2 = g_408190;\n    v5 = g_408190 + 72;\n    v13 = v5;\n    v4 = 1;\n    v14 = &g_4084f8.field_0;\n    do {\n      v6 = *((long long *)v14);\n      if (!((char)v6 & 7)) {\n        v7 = v6;\n      } else {\n        v8 = (unsigned int)-(v6 + 1) & 7;\n        tmp_9 = v8;\n        v7 = &v6->padding_0[v8];\n        if ((char)__CFADD__(tmp_9, v6))\n          continue;\n      }\n      v9 = &v6->padding_0[*((long long *)(v14 + 8))];\n      if (g_4081a8 != v7 && v7 < v9) {\n        while (true) {\n          v10 = *((long long *)(v7 + 8));\n          if (v10 == 11)\n            break;\n          v11 = v10 & -8;\n          v5 += v11;\n          if (((unsigned int)v10 & 3) == 1) {\n            v13 += v11;\n            v4 += 1;\n          }\n          v7 += v11;\n          if (!(v7 >= v6) || !(g_4081a8 != v7) || !(v7 < v9))\n            break;\n          if (v7 >= v9)\n            break;\n        }\n      }\n    } while ((v14 = *((long long *)(v14 + 16)), v14));\n    v3 = g_4084d8 - v5;\n    v15 = g_4084e0;\n    v16 = g_4084d8 - v13;\n  }\n  v1[0] = v5;\n  v1[1] = v4;\n  v1[2] = 0;\n  v1[3] = 0;\n  v1[4] = v3;\n  v1[5] = v15;\n  v1[6] = 0;\n  v1[7] = v16;\n  v1[8] = v13;\n  v1[9] = v2;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpla92l79_/mallinfo_name_conflict.c:55:8: error: array type 'unsigned long long[10]' is\nnot assignable 55 |     v1 = a0; |     ~~ ^ /tmp/tmpla92l79_/mallinfo_name_conflict.c:84:36:\nerror: invalid argument type 'struct_0 *' (aka 'struct struct_0 *') to unary\nexpression 84 |                 v8 = (unsigned int)-(v6 + 1) & 7; | ^~~~~~~~~\n/tmp/tmpla92l79_/mallinfo_name_conflict.c:113:23: error: invalid operands to binary expression\n('unsigned long long' and 'void *') 113 |         v3 = g_4084d8 - v5; | ~~~~~~~~\n^ ~~ /tmp/tmpla92l79_/mallinfo_name_conflict.c:115:24: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 115 |         v16 = g_4084d8 -\nv13; |               ~~~~~~~~ ^ ~~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int mallopt(int param_number, int value) {\n    return change_mparam(param_number, value);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(init_mparams)();\n\nextern unsigned long long g_408548;\nextern unsigned long long g_408550;\nextern unsigned long long g_408558;\nextern unsigned long long g_408560;\nextern unsigned long long mparams;\n\nlong long mallopt_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  if (!mparams)\n    init_mparams();\n  if ((unsigned int)a0 == -2) {\n    v2 = 0;\n    if (!(a1 >= g_408548 && !(a1 & a1 - 1)))\n      return v2;\n    g_408550 = a1;\n    v2 = 1;\n  } else if ((unsigned int)a0 != -1) {\n    v2 = 0;\n    if ((unsigned int)a0 != -3)\n      return v2;\n    g_408558 = a1;\n    v2 = 1;\n  } else {\n    g_408560 = a1;\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(localtime)(long *);\n\nlong long format_date_r_name_conflict(char *a0) {\n  unsigned long v0;   // [bp-0x20]\n  unsigned int v1;    // [bp-0x10]\n  unsigned int v3[6]; // rax\n  unsigned int v4;    // r9d\n  unsigned int v5;    // esi\n  unsigned int v6;    // ecx\n  unsigned int v7;    // edx\n\n  *((long *)&v1) = time(NULL);\n  v3 = localtime(&v1);\n  v4 = v3[2];\n  v5 = v3[5];\n  v6 = v3[3];\n  v7 = v3[4] + 1;\n  v0 = v3[0];\n  sprintf(a0, \"%02d/%02d/%04d %02d:%02d:%02d\", v7, v6, v5 + 1900, v4, v3[1],\n          (int)v0);\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpif7xg293/format_date_r_name_conflict.c:30:8: error: array type 'unsigned int[6]' is\nnot assignable 30 |     v3 = localtime(&v1); |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(localtime)(long *);\n\nlong long format_date_r_name_conflict(char *a0) {\n  unsigned long v0;   // [bp-0x20]\n  unsigned int v1;    // [bp-0x10]\n  unsigned int v3[6]; // rax\n  unsigned int v4;    // r9d\n  unsigned int v5;    // esi\n  unsigned int v6;    // ecx\n  unsigned int v7;    // edx\n\n  *((long *)&v1) = time(NULL);\n  v3 = localtime(&v1);\n  v4 = v3[2];\n  v5 = v3[5];\n  v6 = v3[3];\n  v7 = v3[4] + 1;\n  v0 = v3[0];\n  sprintf(a0, \"%02d/%02d/%04d %02d:%02d:%02d\", v7, v6, v5 + 1900, v4, v3[1],\n          (int)v0);\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgup1_mkj/format_date_r_name_conflict.c:30:8: error: array type 'unsigned int[6]' is\nnot assignable 30 |     v3 = localtime(&v1); |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *strtok_r(char *s1, const char *s2, char **lasts) {\n    char *ret;\n    if (s1 == ((void *)0))\n        s1 = *lasts;\n    while (*s1 && strchr(s2, *s1))\n        ++s1;\n    if (*s1 == '\\x00')\n        return ((void *)0);\n    ret = s1;\n    while (*s1 && !strchr(s2, *s1))\n        ++s1;\n    if (*s1)\n        *s1++ = '\\x00';\n    *lasts = s1;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strtok_r_name_conflict(char *a0, char *a1, struct struct_0 **a2) {\n  char *v1;         // rbx, Other Possible Types: unsigned long\n  unsigned long v2; // rbp, Other Possible Types: unsigned long long\n  unsigned long v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n  char *v5;         // rbp, Other Possible Types: unsigned long\n\n  v1 = a0;\n  if (!a0)\n    v1 = *(a2);\n  v2 = *((char *)v1);\n  if (!(char)v2)\n    return 0;\n  while (true) {\n    v3 = strchr(a1, (char)v2);\n    if (!v3)\n      break;\n    v1 += 1;\n    v2 = *((char *)v1);\n    if (!(char)v2)\n      return 0;\n  }\n  if (!(char)v2)\n    return v3;\n  v4 = *((char *)v1);\n  v5 = v1;\n  if ((char)v4) {\n    do {\n      if (strchr(a1, (char)v4) && (char)v4) {\n        *((char *)v5) = 0;\n        v5 += 1;\n        break;\n      }\n    } while ((v5 += 1, v4 = (unsigned long long)(char)*((char *)v5), (char)v4));\n  }\n  *(a2) = v5;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strsep(char **stringp, const char *delim) {\n    char *ret = *stringp;\n    if (ret == ((void *)0))\n        return (((void *)0));\n    if ((*stringp = strpbrk(*stringp, delim)) != ((void *)0))\n        *((*stringp)++) = '\\x00';\n    return (ret);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strsep_name_conflict(unsigned long long *a0, char *a1) {\n  char *v1; // rbp\n  char *v2; // rax\n\n  v1 = *(a0);\n  if (!v1)\n    return *(a0);\n  v2 = strpbrk(v1, a1);\n  if (!v2) {\n    *(a0) = 0;\n    return *(a0);\n  }\n  *(a0) = v2 + 1;\n  *(v2) = 0;\n  return *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *ltrim(char *str) {\n    char *p;\n    if (!str || !str[0])\n        return str;\n    for (p = str; ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); ++p) {\n    }\n    if (p > str)\n        strcpy(str, p);\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ltrim_name_conflict(char *a0) {\n  char *v2; // rsi, Other Possible Types: unsigned long\n\n  if (!a0) {\n    return a0;\n  } else if (!*(a0)) {\n    return a0;\n  } else {\n    for (v2 = a0; (*((char *)(*((long long *)&__ctype_b_loc()) +\n                              (*((char *)v2) << 1) + 1)) &\n                   32);\n         v2 += 1)\n      ;\n    if (a0 < v2) {\n      strcpy(a0, v2);\n      return a0;\n    }\n    return a0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1m3opfmi/ltrim_name_conflict.c:31:50: error: cannot take the address of an rvalue of\ntype 'int' 31 |         for (v2 = a0; (*((char *)(*((long long\n*)&__ctype_b_loc()) + (*((char *)v2) << 1) + 1)) & 32); v2 += 1); |\n^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *rtrim(char *str) {\n    size_t offset;\n    char *p;\n    if (!str || !str[0])\n        return str;\n    offset = strlen(str);\n    p = str + offset - 1;\n    for (; p >= str && ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); --p) {\n        *p = 0;\n    }\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rtrim_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n\n  if (!a0) {\n    return a0;\n  } else if (!*(a0)) {\n    return a0;\n  } else {\n    v1 = &a0[strlen(a0) + 1];\n    if (v1 < a0)\n      return a0;\n    while ((*((char *)(*((long long *)&__ctype_b_loc()) + (*((char *)v1) << 1) +\n                       1)) &\n            32) &&\n           (*((char *)v1) = 0, v1 -= 1, v1 >= a0))\n      ;\n    return a0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdsh5jfm8/rtrim_name_conflict.c:34:43: error: cannot take the address of an rvalue of\ntype 'int' 34 |         while ((*((char *)(*((long long *)&__ctype_b_loc()) +\n(*((char *)v1) << 1) + 1)) & 32) && (*((char *)v1) = 0, v1 -= 1, v1 >= a0)) |\n^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcat(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    size_t dlen;\n    while (n-- != 0 && *d != '\\x00')\n        d++;\n    dlen = d - dst;\n    n = siz - dlen;\n    if (n == 0)\n        return (dlen + strlen(s));\n    while (*s != '\\x00')\n        {\n            if (n != 1) {\n                *d++ = *s;\n                n--;\n            }\n            s++;\n        }\n    *d = '\\x00';\n    return (dlen + (s - src));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlcat_name_conflict(char *a0, char *a1, unsigned long a2) {\n  int tmp_5;             // tmp #5\n  char *v1;              // rcx\n  char *v2;              // rax, Other Possible Types: unsigned long\n  char *v3;              // rcx, Other Possible Types: unsigned long\n  unsigned long v4;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v5; // rdx, Other Possible Types: unsigned long\n  char v6;               // r8b\n  unsigned long long v7; // rax, Other Possible Types: unsigned long\n\n  if (!a2) {\n    v4 = a2;\n  } else {\n    v1 = &a0[a2];\n    v2 = a0;\n    while (*((char *)v2)) {\n      v2 += 1;\n      if (v2 == v1) {\n        v2 = v1;\n        break;\n      }\n    }\n    v4 = v2 - a0;\n    tmp_5 = a2;\n    v5 = a2 - v4;\n    if (tmp_5 != v4) {\n      v6 = *(a1);\n      v3 = a1;\n      if (v6) {\n        do {\n          if (v5 != 1) {\n            *((char *)v2) = v6;\n            v5 -= 1;\n            v2 += 1;\n          }\n        } while ((v3 += 1, v6 = *((char *)v3), v6));\n      }\n      *((char *)v2) = 0;\n      return v3 - a1 + v4;\n    }\n  }\n  v7 = strlen(a1) + v4;\n  return v7;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcpy(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    if (n != 0 && --n != 0) {\n        do {\n            if ((*d++ = *s++) == 0)\n                break;\n        } while (--n != 0);\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long strlcpy_name_conflict(char a0[1], struct_0 *a1, unsigned long a2) {\n  int tmp_2;        // tmp #2\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  struct_0 *v2;     // rax, Other Possible Types: unsigned long\n  char v3;          // cl\n\n  if (!a2) {\n    v2 = a1;\n  } else {\n    tmp_2 = a2;\n    v1 = a2 - 1;\n    if (tmp_2 == 1) {\n      v2 = a1;\n    } else {\n      v2 = a1;\n      do {\n        v2 += 1;\n        a0 += 1;\n        v3 = *((char *)(v2 - 1));\n        *((char *)(a0 - 1)) = v3;\n      } while (v3 && (tmp_2 = v1, v1 -= 1, tmp_2 != 1));\n      if (v1)\n        return -1 + v2 - (char *)a1;\n    }\n    *((char *)a0) = 0;\n  }\n  do {\n    v2 += 1;\n  } while (*((char *)(v2 - 1)));\n  return -1 + v2 - (char *)a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw7sj0zrz/strlcpy_name_conflict.c:18:16: error: expected ';' at end of declaration list\n   18 |     char field_-1;\n      |                ^\n      |                ;\n/tmp/tmpw7sj0zrz/strlcpy_name_conflict.c:51:32: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 51 |                 return -1\n+ v2 - (char *)a1; |                        ~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpw7sj0zrz/strlcpy_name_conflict.c:59:20: error: 'struct_0 *' (aka 'struct struct_0 *')\nand 'char *' are not pointers to compatible types 59 |     return -1 + v2 -\n(char *)a1; |            ~~~~~~~ ^ ~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"const char *_ds_userdir_path(char *path, const char *home, const char *filename, const char *extension) {\n    char username[4096];\n    char userpath[4096];\n    if (filename == ((void *)0) || filename[0] == 0) {\n        path[0] = 0;\n        return path;\n    }\n    strlcpy(username, filename, 4096);\n    strcpy(userpath, username);\n    if (extension != ((void *)0) && (!strcmp(extension, \"nodspam\") || !strcmp(extension, \"dspam\"))) {\n        snprintf(path, 4096, \"%s/opt-%s/%s.%s\", home, (!strcmp(extension, \"nodspam\")) ? \"out\" : \"in\", userpath, extension);\n        return path;\n    }\n    if (extension == ((void *)0)) {\n        snprintf(path, 4096, \"%s/data/%s\", home, userpath);\n    } else {\n        snprintf(path, 4096, \"%s/data/%s/%s.%s\", home, userpath, username, extension);\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strlcpy)(long long, long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\n\nextern char g_402035;\nextern char g_402039;\n\nlong long _ds_userdir_path_name_conflict(char *a0, unsigned long a1, char *a2, char *a3) {\n  char v0;         // [bp-0x2028]\n  char v1;         // [bp-0x1028]\n  unsigned int v3; // r8d\n\n  if (a2 && *(a2)) {\n    strlcpy(&v1, a2, 0x1000);\n    strcpy(&v0, &v1);\n    if (!a3) {\n      snprintf(a0, 0x1000, \"%s/data/%s\", (unsigned int)a1, (unsigned int)&v0);\n      return a0;\n    }\n    if (!strcmp(a3, \"nodspam\")) {\n      v3 = &g_402035;\n    } else {\n      v3 = &g_402039;\n      if (strcmp(a3, \"dspam\")) {\n        snprintf(a0, 0x1000, \"%s/data/%s/%s.%s\", (unsigned int)a1,\n                 (unsigned int)&v0, (unsigned int)&v1, (unsigned int)a3);\n        return a0;\n      }\n    }\n    snprintf(a0, 0x1000, \"%s/opt-%s/%s.%s\", (unsigned int)a1, v3,\n             (unsigned int)&v0, (unsigned int)a3);\n    return a0;\n  }\n  *(a0) = 0;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9r7hl84a/_ds_userdir_path_name_conflict.c:17:6: error: conflicting types for\n'snprintf' 17 | int (snprintf)(char *, unsigned long, char *, ...); |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_prepare_path_for(const char *filename) {\n    char path[4096];\n    char *dir, *file;\n    char *file_buffer_start;\n    struct stat s;\n    if (!filename)\n        return 22;\n    file = strdup(filename);\n    if (!file) {\n        LOG(3, \"Memory allocation failed\");\n        return -5;\n    }\n    file_buffer_start = file;\n    path[0] = 0;\n    dir = strsep(&file, \"/\");\n    while (dir != ((void *)0))\n        {\n            strlcat(path, dir, sizeof (path));\n            dir = strsep(&file, \"/\");\n            {\n                if (dir != ((void *)0) && stat(path, &s) && path[0] != 0) {\n                    int x;\n                    ;\n                    ;\n                    x = mkdir(path, 504);\n                    if (x) {\n                        LOG(3, \"Unable to create directory: %s: %s\", path, strerror((*__errno_location())));\n                        free(file_buffer_start);\n                        return -3;\n                    }\n                }\n            }\n            strlcat(path, \"/\", sizeof (path));\n        }\n    free(file_buffer_start);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(LOG)();\nlong long(strsep)(long long, long long);\nlong long(strlcat)(long long, long long, long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nchar *(strerror)(int);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long _ds_prepare_path_for_name_conflict(char *a0) {\n  stat v0;           // [bp-0x10b8]\n  void *v1;          // [bp-0x1020]\n  char v2;           // [bp-0x1018]\n  unsigned long v3;  // [bp-0x18]\n  unsigned long v4;  // [bp-0x10]\n  unsigned long v5;  // [bp-0x8]\n  unsigned long v7;  // r12\n  unsigned long v8;  // rbx\n  unsigned long v9;  // rbx, Other Possible Types: unsigned long long\n  unsigned long v10; // rax, Other Possible Types: unsigned long long\n\n  if (!a0)\n    return 22;\n  v5 = v7;\n  *((int *)&v4) = rbp;\n  v3 = v8;\n  v1 = strdup(a0);\n  if (!v1) {\n    LOG();\n    v10 = 4294967291;\n  } else {\n    v2 = 0;\n    v9 = strsep(&v1, \"/\");\n    if (v9) {\n      while (true) {\n        strlcat(&v2, v9, 0x1000);\n        v9 = strsep(&v1, \"/\");\n        if (!v9)\n          break;\n        if (stat(&v2, &v0) && v2 && mkdir(&v2, 504)) {\n          strerror(*(__errno_location()));\n          LOG();\n          free(v1);\n          return 4294967293;\n        }\n        strlcat(&v2, \"/\", 0x1000);\n      }\n      strlcat(&v2, \"/\", 0x1000);\n    }\n    free(v1);\n    v10 = 0;\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpos2lv616/_ds_prepare_path_for_name_conflict.c:53:3: error: redefinition of 'stat' as\ndifferent kind of symbol 53 | } stat; |   ^\n/tmp/tmpos2lv616/_ds_prepare_path_for_name_conflict.c:21:6: note: previous definition is here\n   21 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpos2lv616/_ds_prepare_path_for_name_conflict.c:57:5: error: must use 'struct' tag to\nrefer to type 'stat' 57 |     stat v0;  // [bp-0x10b8] |     ^ |     struct\n/tmp/tmpos2lv616/_ds_prepare_path_for_name_conflict.c:21:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 21 | int (stat)(char *, struct stat { | ^\n/tmp/tmpos2lv616/_ds_prepare_path_for_name_conflict.c:93:30: error: indirection requires\npointer operand ('int' invalid) 93 | strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int lc(char *buff, const char *string) {\n    char *buffer;\n    int i, j = 0;\n    int len = strlen(string);\n    buffer = malloc(len + 1);\n    if (len == 0) {\n        buff[0] = 0;\n        free(buffer);\n        return 0;\n    }\n    for (i = 0; i < len; i++) {\n        if (((*__ctype_b_loc())[(int)(((int)string[i]))] & (unsigned short)_ISupper)) {\n            buffer[i] = tolower(string[i]);\n            j++;\n        } else {\n            buffer[i] = string[i];\n        }\n    }\n    buffer[len] = 0;\n    strcpy(buff, buffer);\n    free(buffer);\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_tolower_loc)();\n\nlong long lc_name_conflict(char *a0, char *a1) {\n  char *v0;              // [bp-0x50]\n  unsigned long v1;      // [bp-0x48]\n  unsigned long long v3; // rax\n  unsigned int v4;       // ebx\n  unsigned long long v6; // rax\n  unsigned int *v7;      // r12\n  void *v8;  // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v9;  // rbx, Other Possible Types: unsigned long\n  char *v10; // rbp, Other Possible Types: unsigned long\n  char *v11; // rbx\n\n  v3 = strlen(a1);\n  v4 = v3;\n  v1 = v3;\n  v0 = malloc(v1 + 1);\n  if (!v4) {\n    *(a0) = 0;\n    free(v0);\n    return (unsigned int)v1;\n  }\n  v8 = 0;\n  if (v4 > 0) {\n    v9 = a1;\n    v10 = v0;\n    v8 = 0;\n    do {\n      v6 = *((char *)v9);\n      v7 = (char)v6;\n      if ((*((char *)(*((long long *)&__ctype_b_loc()) + (v7 << 1) + 1)) & 1)) {\n        *((char *)v10) =\n            *((int *)(*((long long *)&__ctype_tolower_loc()) + v7 * 4));\n        v8 = (unsigned int)v8 + 1;\n      } else {\n        *((char *)v10) = v6;\n      }\n    } while ((v9 += 1, v10 += 1, v9 != a1 + v1 - 1 + 1));\n  }\n  v11 = v0;\n  v11[(int)v1] = 0;\n  strcpy(a0, v11);\n  free(v11);\n  return v8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpljbgmf9_/lc_name_conflict.c:51:44: error: cannot take the address of an rvalue of type\n'int' 51 |             if ((*((char *)(*((long long *)&__ctype_b_loc()) + (v7 <<\n1) + 1)) & 1)) |                                            ^~~~~~~~~~~~~~~~\n/tmp/tmpljbgmf9_/lc_name_conflict.c:51:68: error: invalid operands to binary expression\n('unsigned int *' and 'int') 51 |             if ((*((char *)(*((long long\n*)&__ctype_b_loc()) + (v7 << 1) + 1)) & 1)) | ~~ ^  ~\n/tmp/tmpljbgmf9_/lc_name_conflict.c:53:59: error: cannot take the address of an rvalue of type\n'char *' 53 |                 *((char *)v10) = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + v7 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpljbgmf9_/lc_name_conflict.c:53:88: error: invalid operands to binary expression\n('unsigned int *' and 'int') 53 |                 *((char *)v10) = *((int\n*)(*((long long *)&__ctype_tolower_loc()) + v7 * 4)); | ~~ ^ ~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long long _ds_getcrc64(const char *s) {\n    static unsigned long long CRCTable[256];\n    unsigned long long crc = 0;\n    static int init = 0;\n    if (!init) {\n        int i;\n        init = 1;\n        for (i = 0; i <= 255; i++) {\n            int j;\n            unsigned long long part = i;\n            for (j = 0; j < 8; j++) {\n                if (part & 1)\n                    part = (part >> 1) ^ 15564440312192434176ULL;\n                else\n                    part >>= 1;\n            }\n            CRCTable[i] = part;\n        }\n    }\n    for (; *s; s++) {\n        unsigned long long temp1 = crc >> 8;\n        unsigned long long temp2 = CRCTable[(crc ^ (unsigned long long)*s) & 255];\n        crc = temp1 ^ temp2;\n    }\n    return crc;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long CRCTable.0;\nextern unsigned int init.1;\n\nlong long _ds_getcrc64_name_conflict(char *a0) {\n  void *v1;         // rcx, Other Possible Types: unsigned long\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n  unsigned long v3; // edx, Other Possible Types: unsigned int\n  void *v4;         // rdx, Other Possible Types: unsigned long\n  unsigned long v5; // rax\n  unsigned long v6; // rax, Other Possible Types: unsigned long long\n\n  if (!init.1) {\n    init.1 = 1;\n    v1 = 0;\n    do {\n      v2 = v1;\n      v3 = 8;\n      do {\n        v2 = (!((char)v2 & 1) ? v2 / 2 ^ 0xd800000000000000 : v2 / 2);\n      } while ((v3 = (unsigned long long)((unsigned int)v3 - 1), true));\n      *((unsigned long *)((char *)&CRCTable.0 + 0x8 * v1)) = v2;\n      v1 += 1;\n    } while (v1 != 0x100);\n  }\n  v6 = *(a0);\n  v4 = 0;\n  if ((char)v6) {\n    do {\n      v5 = (unsigned int)v6 ^ (unsigned int)v4;\n      v4 = v4 / 0x100 ^ (&CRCTable.0)[v5];\n      a0 += 1;\n      v6 = *((char *)a0);\n    } while ((char)v6);\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:17:35: error: expected ';' after top level\ndeclarator 17 | extern unsigned long long CRCTable.0; | ^ | ;\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:18:25: error: expected ';' after top level\ndeclarator 18 | extern unsigned int init.1; |                         ^ | ;\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:29:14: error: expected ')'\n   29 |     if (!init.1)\n      |              ^\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:29:8: note: to match this '('\n   29 |     if (!init.1)\n      |        ^\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:31:13: error: expected ';' after expression\n   31 |         init.1 = 1;\n      |             ^\n      |             ;\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:31:16: error: expression is not assignable\n   31 |         init.1 = 1;\n      |             ~~ ^\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:41:50: error: expected ')'\n   41 |             *((unsigned long *)((char *)&CRCTable.0 + 0x8 * v1)) = v2;\n      |                                                  ^\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:41:32: note: to match this '('\n   41 |             *((unsigned long *)((char *)&CRCTable.0 + 0x8 * v1)) = v2;\n      |                                ^\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:52:21: error: invalid operands to binary\nexpression ('void *' and 'int') 52 |             v4 = v4 / 0x100 ^\n(&CRCTable.0)[v5]; |                  ~~ ^ ~~~~~\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:52:41: error: expected ')'\n   52 |             v4 = v4 / 0x100 ^ (&CRCTable.0)[v5];\n      |                                         ^\n/tmp/tmpo1xn3g6y/_ds_getcrc64_name_conflict.c:52:31: note: to match this '('\n   52 |             v4 = v4 / 0x100 ^ (&CRCTable.0)[v5];\n      |                               ^\n8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_weight(const char *token) {\n    int complexity = _ds_compute_complexity(token);\n    int sparse = _ds_compute_sparse(token);\n    if (complexity == 5) {\n        if (sparse == 1)\n            return 64;\n        if (sparse == 2)\n            return 16;\n        if (sparse == 3)\n            return 4;\n        if (sparse == 0)\n            return 256;\n    }\n    if (complexity == 4) {\n        if (sparse == 1)\n            return 16;\n        if (sparse == 2)\n            return 4;\n        if (sparse == 0)\n            return 64;\n    }\n    if (complexity == 3) {\n        if (sparse == 1)\n            return 4;\n        if (sparse == 0)\n            return 16;\n    }\n    if (complexity == 2) {\n        if (sparse == 0)\n            return 4;\n    }\n    if (complexity == 1) {\n        if (sparse == 0)\n            return 1;\n    }\n    LOG(4, \"_ds_compute_weight: no rule to compute markovian weight for '%s'; complexity: %d; sparse: %d\", token, complexity, sparse);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_ds_compute_complexity)(long long);\nlong long(_ds_compute_sparse)(long long);\nlong long(LOG)();\n\nlong long _ds_compute_weight_name_conflict(unsigned long long a0) {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n\n  v1 = _ds_compute_complexity(a0);\n  (unsigned int)v2 = _ds_compute_sparse(a0);\n  if ((unsigned int)v1 == 5) {\n    if ((unsigned int)v2 == 1) {\n      return 64;\n    } else if ((unsigned int)v2 == 2) {\n      return 16;\n    } else if ((unsigned int)v2 == 3) {\n      return 4;\n    } else if (!(unsigned int)v2) {\n      return 0x100;\n    }\n  } else {\n    if ((unsigned int)v1 != 4) {\n      if ((unsigned int)v1 != 3) {\n        *((char *)&v2) = !(unsigned int)v2;\n        if ((unsigned int)v1 == 2 && (char)v2)\n          return 4;\n      } else {\n        if ((unsigned int)v2 == 1)\n          return 4;\n        if (!(unsigned int)v2)\n          return 16;\n        goto LABEL_401aea;\n      }\n      goto LABEL_401b2c;\n    } else if ((unsigned int)v2 == 1) {\n      return 16;\n    } else if ((unsigned int)v2 == 2) {\n      return v1;\n    } else if (!(unsigned int)v2) {\n      return 64;\n    }\n  }\n  *((char *)&v2) = !(unsigned int)v2;\nLABEL_401b2c:\n  if ((unsigned int)v1 == 1 && (char)v2)\n    return 1;\nLABEL_401aea:\n  LOG();\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcv796zxe/_ds_compute_weight_name_conflict.c:26:5: error: assignment to cast is\nillegal, lvalue casts are not supported 26 |     (unsigned int)v2 =\n_ds_compute_sparse(a0); |     ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_sparse(const char *token) {\n    int sparse = 0, i;\n    if (!strncmp(token, \"#+\", 2))\n        sparse++;\n    if (strlen(token) >= 2 && !strncmp((token + strlen(token)) - 2, \"+#\", 2))\n        sparse++;\n    for (i = 0; token[i]; i++) {\n        if (!strncmp(token + i, \"+#+\", 3)) {\n            sparse++;\n            i++;\n        }\n    }\n    return sparse;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _ds_compute_sparse_name_conflict(char *a0) {\n  unsigned long v2;      // r12, Other Possible Types: unsigned long long\n  unsigned long long v3; // rax\n  unsigned int v4;       // rbx, Other Possible Types: unsigned long\n\n  v2 = !strncmp(a0, \"#+\", 2);\n  v3 = strlen(a0);\n  if (v3 > 1)\n    v2 += strncmp(&a0[v3 + 2], \"+#\", 2) < 1;\n  v4 = 0;\n  if (!*(a0))\n    return v2;\n  do {\n    if (!strncmp(a0, \"+#+\", 3)) {\n      v2 = (unsigned int)v2 + 1;\n      v4 = (unsigned int)v4 + 1;\n    }\n  } while ((v4 = (unsigned long long)(v4 + 1), a0 = v4 + a0, *((char *)a0)));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_complexity(const char *token) {\n    int i, complexity = 1;\n    if (token == ((void *)0))\n        return 1;\n    for (i = 0; token[i]; i++) {\n        if (token[i] == '+') {\n            complexity++;\n            i++;\n        }\n    }\n    return complexity;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _ds_compute_complexity_name_conflict(char *a0) {\n  char v1;          // dl\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  unsigned int v3;  // rax, Other Possible Types: unsigned long\n\n  if (!a0)\n    return 1;\n  v1 = *(a0);\n  if (!v1)\n    return 1;\n  v2 = 1;\n  v3 = 0;\n  do {\n    if (v1 == 43) {\n      v2 = (unsigned int)v2 + 1;\n      v3 = (unsigned int)v3 + 1;\n    }\n  } while ((v3 = (unsigned long long)(v3 + 1), v1 = a0[v3], v1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_extract_address(char *buf, const char *address, size_t len) {\n    char *str = strdup(address);\n    char *x, *y;\n    if (str == ((void *)0))\n        return -2;\n    x = strchr(str, '<');\n    if (!x) {\n        free(str);\n        return -5;\n    }\n    y = strchr(x, '>');\n    if (y)\n        y[0] = 0;\n    strlcpy(buf, x + 1, len);\n    free(str);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(strlcpy)(long long, long long, long long);\n\nlong long _ds_extract_address(unsigned long long a0, char *a1,\n                              unsigned long long a2) {\n  char *v1; // rax\n  void *v2; // rbp\n  char *v4; // rbx\n  char *v5; // rax\n\n  v1 = strdup(a1);\n  if (!v1)\n    return 4294967294;\n  v2 = v1;\n  v4 = strchr(v1, 60);\n  if (!v4) {\n    free(v2);\n    return 4294967291;\n  }\n  v5 = strchr(v4, 62);\n  if (v5)\n    *(v5) = 0;\n  strlcpy(a0, v4 + 1, a2);\n  free(v2);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_get_fcntl_lock(int fd) {\n    struct flock f;\n    int r;\n    f.l_type = 1;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    signal(14, timeout);\n    alarm(300);\n    r = fcntl(fd, 7, &f);\n    alarm(0);\n    signal(14, ((__sighandler_t)0));\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint timeout; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(alarm)(unsigned int);\nint(fcntl)(int, int, ...);\n\nlong long _ds_get_fcntl_lock_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0x28]\n  unsigned short v1; // [bp-0x26]\n  void *v2;          // [bp-0x20]\n  void *v3;          // [bp-0x18]\n\n  v0 = 1;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  signal(14, timeout);\n  alarm(300);\n  alarm(0);\n  signal(14, 0);\n  return fcntl(a0, 7);\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_free_fcntl_lock(int fd) {\n    struct flock f;\n    f.l_type = 2;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    return fcntl(fd, 7, &f);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long _ds_free_fcntl_lock_name_conflict(unsigned long a0) {\n  unsigned short v0; // [bp-0x28]\n  unsigned short v1; // [bp-0x26]\n  void *v2;          // [bp-0x20]\n  void *v3;          // [bp-0x18]\n\n  v0 = 2;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  return fcntl(a0, 7);\n}\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow(int base, unsigned int exp) {\n    int result = 1;\n    while (exp > 0)\n        {\n            if (exp & 1)\n                result *= base;\n            base *= base;\n            exp /= 2;\n        }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _ds_pow_name_conflict(unsigned long a0, char a1) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  unsigned long v3; // rax\n\n  if (!a1)\n    return 1;\n  v1 = 1;\n  while (true) {\n    if (((char)a1 & 1))\n      v1 = (unsigned int)a0 * (unsigned int)v1;\n    a0 = (unsigned int)a0 * (unsigned int)a0;\n    v3 = rax / 2;\n    if ((unsigned int)v3 <= 1)\n      break;\n    a1 = v3;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow2(int exp) {\n    return _ds_pow(2, exp);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_ds_pow)(long long, long long);\n\nlong long _ds_pow2_name_conflict(unsigned long long a0) { return _ds_pow(2, a0); }\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strcasestr(s, find)\n    const char *s;\n    const char *find;\n {\n    char c, sc;\n    size_t len;\n    if ((c = *find++) != 0) {\n        c = tolower((unsigned char)c);\n        len = strlen(find);\n        do {\n            do {\n                if ((sc = *s++) == 0)\n                    return (((void *)0));\n            } while ((char)tolower((unsigned char)sc) != c);\n        } while (strncasecmp(s, find, len) != 0);\n        s--;\n    }\n    return ((char *)s);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_tolower_loc)();\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long strcasestr_name_conflict(char *a0, char *a1) {\n  char *v2;         // rbx\n  char *v3;         // rbp\n  unsigned long v4; // r12\n  unsigned long v7; // rax, Other Possible Types: unsigned long long\n  struct_0 *v8;     // rbx, Other Possible Types: unsigned long\n\n  v2 = *(a1);\n  if (!(char)v2)\n    return a0;\n  v3 = a1 + 1;\n  v4 = *((long long *)&__ctype_tolower_loc());\n  v8 = a0 + 1;\n  v7 = *(a0);\n  if (!(char)v7)\n    return 0;\n  while (true) {\n    if (*((char *)(v4 + v2 * 4)) == *((char *)(v4 + (v7 << 2))) &&\n        !strncasecmp(v8, v3, strlen(v3)))\n      return v8 - 1;\n    v8 += 1;\n    v7 = *((char *)(v8 - 1));\n    if (!(char)v7)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfl_ebe69/strcasestr_name_conflict.c:19:16: error: expected ';' at end of declaration\nlist 19 |     char field_-1; |                ^ |                ;\n/tmp/tmpfl_ebe69/strcasestr_name_conflict.c:34:25: error: cannot take the address of an rvalue\nof type 'char *' 34 |     v4 = *((long long *)&__ctype_tolower_loc()); |\n^~~~~~~~~~~~~~~~~~~~~~ /tmp/tmpfl_ebe69/strcasestr_name_conflict.c:41:32: error: invalid\noperands to binary expression ('char *' and 'int') 41 |         if (*((char\n*)(v4 + v2 * 4)) == *((char *)(v4 + (v7 << 2))) && !strncasecmp(v8, v3,\nstrlen(v3))) |                             ~~ ^ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *inet_ntoa_r(struct in_addr in, char *buf, int len) {\n    char b[18];\n    register char *p;\n    p = (char *)&in;\n    snprintf(b, sizeof (b), \"%d.%d.%d.%d\", (((int)p[0]) & 255), (((int)p[1]) & 255), (((int)p[2]) & 255), (((int)p[3]) & 255));\n    if (len <= strlen(b)) {\n        (*__errno_location()) = 34;\n        return (((void *)0));\n    }\n    return strcpy(buf, b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\n\nlong long inet_ntoa_r_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  char v0;          // [bp-0x38]\n  unsigned long v1; // [bp-0x18]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v6; // r12\n  unsigned long v7; // rbx\n  void *v8;         // rax, Other Possible Types: unsigned long\n\n  v2 = v6;\n  v1 = v7;\n  snprintf(&v0, 18, \"%d.%d.%d.%d\", (char)a0, (unsigned int)a0 / 0x100,\n           (unsigned int)(a0 * 0x100 >> 24), (unsigned int)a0 / 0x1000000);\n  if (strlen(&v0) < a2) {\n    v8 = strcpy(a1, &v0);\n  } else {\n    *(__errno_location()) = 34;\n    v8 = 0;\n  }\n  return v8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf6a0edp0/inet_ntoa_r_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpf6a0edp0/inet_ntoa_r_name_conflict.c:36:9: error: indirection requires pointer operand\n('int' invalid) 36 |         *(__errno_location()) = 34; | ^~~~~~~~~~~~~~~~~~~~~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcpy_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rdx, Other Possible Types: unsigned long\n  char v2;  // cl\n\n  v1 = 0;\n  do {\n    v2 = *((char *)(a1 + v1));\n    *((char *)(a0 + v1)) = v2;\n    v1 += 1;\n  } while (v2);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcmp_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = *(a0);\n  if ((char)v1) {\n    while (*((char *)a1) == (char)v1 &&\n           (a0 += 1, a1 += 1, v1 = (unsigned long long)(char)*((char *)a0),\n            (char)v1))\n      ;\n  }\n  return v1 - *((char *)a1);\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlen_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  unsigned long long v2; // rax\n\n  if (!*(a0))\n    return 0;\n  v1 = 1;\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (a0[1 + v1]);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strchr_name_conflict(char *a0, unsigned long a1) {\n  char v1; // al\n\n  v1 = *(a0);\n  if (!v1)\n    return 0;\n  while ((char)a1 != v1) {\n    a0 += 1;\n    v1 = *((char *)a0);\n    if (!v1)\n      return 0;\n  }\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long gets_name_conflict(char *a0, unsigned long a1) {\n  char v0;          // [bp-0x39]\n  char *v2;         // rbp, Other Possible Types: unsigned long\n  char *v3;         // rbx, Other Possible Types: unsigned long\n  char v4;          // al\n  unsigned long v5; // r15\n\n  v2 = a0;\n  v3 = 0;\n  while (true) {\n    v5 = v3;\n    v3 = (unsigned int)v3 + 1;\n    if (!((unsigned int)v3 < (unsigned int)a1) || !((int)read(0, &v0, 1) > 0))\n      break;\n    v4 = v0;\n    *((char *)v2) = v4;\n    v2 += 1;\n    if (v4 == 10 || v4 == 13) {\n      v5 = v3;\n      break;\n    }\n  }\n  a0[v5] = 0;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nint(fstat_name_conflict)(\n    int, struct stat_name_conflict {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(close)(int);\n\ntypedef struct stat_name_conflict {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat_name_conflict;\n\nlong long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) {\n  unsigned long long v1; // rax\n\n  (unsigned int)v1 = open(a0, 0, a2);\n  if ((unsigned int)v1 < 0)\n    return 4294967295;\n  close(v1);\n  return fstat_name_conflict(v1, a1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvr9d4qsy/stat_name_conflict.c:51:11: error: redefinition of 'stat_name_conflict' as different kind\nof symbol 51 | long long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) | ^\n/tmp/tmpvr9d4qsy/stat_name_conflict.c:49:3: note: previous definition is here\n   49 | } stat_name_conflict;\n      |   ^\n/tmp/tmpvr9d4qsy/stat_name_conflict.c:55:5: error: assignment to cast is illegal, lvalue casts\nare not supported 55 |     (unsigned int)v1 = open(a0, 0, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long atoi_name_conflict(char *a0) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  void *v2;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *(a0);\n  if (v1 - 48 > 9)\n    return 0;\n  v2 = 0;\n  do {\n    a0 += 1;\n    v2 = v1 + v2 * 10 - 48;\n    v1 = *((char *)a0);\n  } while (v1 - 48 <= 9);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_6zvo1mo/atoi_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v2 = v1 + v2 * 10 - 48; |                   ~~\n^ ~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcpy_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rdx, Other Possible Types: unsigned long\n  char v2;  // cl\n\n  v1 = 0;\n  do {\n    v2 = *((char *)(a1 + v1));\n    *((char *)(a0 + v1)) = v2;\n    v1 += 1;\n  } while (v2);\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strcmp_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = *(a0);\n  if ((char)v1) {\n    while (*((char *)a1) == (char)v1 &&\n           (a0 += 1, a1 += 1, v1 = (unsigned long long)(char)*((char *)a0),\n            (char)v1))\n      ;\n  }\n  return v1 - *((char *)a1);\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strlen_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  unsigned long long v2; // rax\n\n  if (!*(a0))\n    return 0;\n  v1 = 1;\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (a0[1 + v1]);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strchr_name_conflict(char *a0, unsigned long a1) {\n  char v1; // al\n\n  v1 = *(a0);\n  if (!v1)\n    return 0;\n  while ((char)a1 != v1) {\n    a0 += 1;\n    v1 = *((char *)a0);\n    if (!v1)\n      return 0;\n  }\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long gets_name_conflict(char *a0, unsigned long a1) {\n  char v0;          // [bp-0x39]\n  char *v2;         // rbp, Other Possible Types: unsigned long\n  char *v3;         // rbx, Other Possible Types: unsigned long\n  char v4;          // al\n  unsigned long v5; // r15\n\n  v2 = a0;\n  v3 = 0;\n  while (true) {\n    v5 = v3;\n    v3 = (unsigned int)v3 + 1;\n    if (!((unsigned int)v3 < (unsigned int)a1) || !((int)read(0, &v0, 1) > 0))\n      break;\n    v4 = v0;\n    *((char *)v2) = v4;\n    v2 += 1;\n    if (v4 == 10 || v4 == 13) {\n      v5 = v3;\n      break;\n    }\n  }\n  a0[v5] = 0;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nint(fstat_name_conflict)(\n    int, struct stat_name_conflict {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(close)(int);\n\ntypedef struct stat_name_conflict {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat_name_conflict;\n\nlong long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) {\n  unsigned long long v1; // rax\n\n  (unsigned int)v1 = open(a0, 0, a2);\n  if ((unsigned int)v1 < 0)\n    return 4294967295;\n  close(v1);\n  return fstat_name_conflict(v1, a1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplx2jf037/stat_name_conflict.c:51:11: error: redefinition of 'stat_name_conflict' as different kind\nof symbol 51 | long long stat_name_conflict(char *a0, stat_name_conflict *a1, unsigned long a2) | ^\n/tmp/tmplx2jf037/stat_name_conflict.c:49:3: note: previous definition is here\n   49 | } stat_name_conflict;\n      |   ^\n/tmp/tmplx2jf037/stat_name_conflict.c:55:5: error: assignment to cast is illegal, lvalue casts\nare not supported 55 |     (unsigned int)v1 = open(a0, 0, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long atoi_name_conflict(char *a0) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  void *v2;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *(a0);\n  if (v1 - 48 > 9)\n    return 0;\n  v2 = 0;\n  do {\n    a0 += 1;\n    v2 = v1 + v2 * 10 - 48;\n    v1 = *((char *)a0);\n  } while (v1 - 48 <= 9);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx9aojl0i/atoi_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v2 = v1 + v2 * 10 - 48; |                   ~~\n^ ~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"bool check(const char *word) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long check_name_conflict() { return 0; }\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool load(const char *dictionary) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long load_name_conflict() { return 0; }\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"unsigned int size(void) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long size_name_conflict() { return 0; }\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool unload(void) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long unload_name_conflict() { return 0; }\n","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":0,"function":"int open_serial(int k) {\n    if (k == 0) {\n        fd = open(\"/dev/ttyUSB0\", 2 | 256);\n        perror(\"open /dev/ttyUSB0\");\n    } else {\n        fd = open(\"/dev/ttyUSB1\", 2 | 256);\n        perror(\"open /dev/ttyUSB1\");\n    }\n    if (fd == -1)\n        return -1;\n    else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nextern unsigned int fd;\n\nlong long open_serial_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  if (!(unsigned int)a0) {\n    fd = open(\"/dev/ttyUSB0\", 258, a2);\n    perror(\"open /dev/ttyUSB0\");\n    return -(fd == -1);\n  }\n  fd = open(\"/dev/ttyUSB1\", 258, a2);\n  perror(\"open /dev/ttyUSB1\");\n  return -(fd == -1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptmqd8syj/open_serial_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":1,"function":"unsigned int calc_crc16(unsigned char *snd, unsigned char num) {\n    unsigned char i, j;\n    unsigned int c, crc = 65535;\n    for (i = 0; i < num; i++) {\n        c = snd[i] & 255;\n        crc ^= c;\n        for (j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc >>= 1;\n                crc ^= 40961;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return (crc);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long calc_crc16_name_conflict(char *a0, unsigned long a1) {\n  char *v1;         // r8, Other Possible Types: unsigned long\n  char v3;          // cl\n  unsigned long v4; // rax, Other Possible Types: unsigned int\n\n  if (!(char)a1)\n    return 65535;\n  v1 = a0;\n  v4 = 65535;\n  do {\n    v4 = (unsigned int)v4 ^ *((char *)v1);\n    v3 = 8;\n    do {\n      v4 = (!((char)v4 & 1) ? (unsigned int)v4 / 2 ^ 40961 : v4 / 2);\n    } while ((v3 -= 1, true));\n    v1 += 1;\n  } while (v1 != &a0[a1]);\n  return v4;\n}\n","pass":1,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":0,"function":"int read(char *name, char *permission) {\n    int buf;\n    FILE *file;\n    file = fopen(name, permission);\n    fread(&buf, sizeof (buf), 1, file);\n    fclose(file);\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned long(fread_name_conflict)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_name_conflict_ptr;\n      char *_IO_read_name_conflict_end;\n      char *_IO_read_name_conflict_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_name_conflict_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_name_conflict_ptr;\n        short *_IO_read_name_conflict_end;\n        short *_IO_read_name_conflict_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_name_conflict_ptr;\n  char *_IO_read_name_conflict_end;\n  char *_IO_read_name_conflict_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_name_conflict_ptr;\n  unsigned short *_IO_read_name_conflict_end;\n  unsigned short *_IO_read_name_conflict_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_name_conflict(char *a0, char *a1) {\n  char v0;    // [bp-0xc]\n  FILE_t *v2; // rax\n\n  v2 = fopen(a0, a1);\n  fread_name_conflict(&v0, 4, 1, v2);\n  fclose(v2);\n  return *((int *)&v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz_5e1vhx/read_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:16:16: error: conflicting types for 'fread_name_conflict'\n   16 | unsigned long (fread_name_conflict)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread_name_conflict (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:141:16: error: redefinition of '_IO_marker'\n  141 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:147:16: error: redefinition of '_IO_codecvt'\n  147 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:151:16: error: redefinition of '_IO_wide_data'\n  151 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpz_5e1vhx/read_name_conflict.c:174:3: error: typedef redefinition with different types\n('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 174 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":0,"function":"int average(int *data, int size) {\n    if (data == ((void *)0) || size == 0) {\n        return 0;\n    }\n    printf(\"size=%d\\n\", sizeof data / sizeof(int));\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long average_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned long v0; // [bp-0x10]\n  unsigned long v1; // [bp-0x8]\n  unsigned long v3; // rbx\n  unsigned long v4; // rax\n  unsigned int *v5; // rdx, Other Possible Types: unsigned long\n  unsigned int v6;  // eax\n\n  if (!a0)\n    return 0;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  if (!(unsigned int)a1)\n    return 0;\n  printf(\"size=%d\\n\", 2);\n  if ((unsigned int)a1 <= 0) {\n    v6 = 0;\n  } else {\n    v5 = a0;\n    v6 = 0;\n    do {\n      v6 += *((int *)v5);\n      v5 += 4;\n    } while (v5 != &a0[a1]);\n  }\n  v4 = (v6 >> 31 CONCAT v6) / m(unsigned int) a1;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp20y5_b0f/average_name_conflict.c:48:20: error: expected ')'\n   48 |     v4 = (v6 >> 31 CONCAT v6) /m (unsigned int)a1;\n      |                    ^\n/tmp/tmp20y5_b0f/average_name_conflict.c:48:10: note: to match this '('\n   48 |     v4 = (v6 >> 31 CONCAT v6) /m (unsigned int)a1;\n      |          ^\n/tmp/tmp20y5_b0f/average_name_conflict.c:48:35: error: expected expression\n   48 |     v4 = (v6 >> 31 CONCAT v6) /m (unsigned int)a1;\n      |                                   ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":0,"function":"int average2(int data[], int size) {\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long average2_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int *v1; // rdx, Other Possible Types: unsigned long\n  unsigned int v2;  // eax\n\n  if ((unsigned int)a1 <= 0)\n    return (0 >> 31 CONCAT 0) / m(unsigned int) a1;\n  v1 = a0;\n  v2 = 0;\n  do {\n    v2 += *((int *)v1);\n    v1 += 4;\n  } while (v1 != &a0[a1]);\n  return (v2 >> 31 CONCAT v2) / m(unsigned int) a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl33025hw/average2_name_conflict.c:23:25: error: expected ')'\n   23 |         return (0 >> 31 CONCAT 0) /m (unsigned int)a1;\n      |                         ^\n/tmp/tmpl33025hw/average2_name_conflict.c:23:16: note: to match this '('\n   23 |         return (0 >> 31 CONCAT 0) /m (unsigned int)a1;\n      |                ^\n/tmp/tmpl33025hw/average2_name_conflict.c:23:39: error: expected expression\n   23 |         return (0 >> 31 CONCAT 0) /m (unsigned int)a1;\n      |                                       ^\n/tmp/tmpl33025hw/average2_name_conflict.c:31:22: error: expected ')'\n   31 |     return (v2 >> 31 CONCAT v2) /m (unsigned int)a1;\n      |                      ^\n/tmp/tmpl33025hw/average2_name_conflict.c:31:12: note: to match this '('\n   31 |     return (v2 >> 31 CONCAT v2) /m (unsigned int)a1;\n      |            ^\n/tmp/tmpl33025hw/average2_name_conflict.c:31:37: error: expected expression\n   31 |     return (v2 >> 31 CONCAT v2) /m (unsigned int)a1;\n      |                                     ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":0,"function":"char readchar() {\n    while (uartadr[8] & 1)\n        ;\n    return uartadr[4];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint uartadr; // add global variable by heuristics\nint uartadr; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *uartadr;\n\nlong long readchar_name_conflict() {\n  while ((uartadr->field_8 & 1))\n    ;\n  return uartadr->field_4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpeid1iqvk/readchar_name_conflict.c:19:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 19 | extern struct_0 *uartadr; |        ^~~~~~~~ |        struct\n/tmp/tmpeid1iqvk/readchar_name_conflict.c:19:8: error: declaration of anonymous struct must be\na definition /tmp/tmpeid1iqvk/readchar_name_conflict.c:23:22: error: member reference type\n'int' is not a pointer 23 |     while ((uartadr->field_8 & 1)) | ~~~~~~~  ^\n/tmp/tmpeid1iqvk/readchar_name_conflict.c:25:21: error: member reference type 'int' is not a\npointer 25 |     return uartadr->field_4; |            ~~~~~~~  ^ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bonfireprocessor_bonfire-soc/riscv/software/cpptest/uart.c"}
{"compilable":0,"function":"_Bool show_cmd_help(int argc, char **argv) {\n    return (argc > 0 && (0 == strcmp(argv[0], \"-h\") || 0 == strcmp(argv[0], \"--help\")));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long show_cmd_help_name_conflict(unsigned long a0, unsigned long long *a1) {\n  unsigned long v0;      // [bp-0x8]\n  unsigned long v2;      // rbx\n  char *v3;              // rbx\n  unsigned int v4;       // eax\n  unsigned long long v5; // rax\n\n  if ((unsigned int)a0 <= 0)\n    return 0;\n  v0 = v2;\n  v3 = *(a1);\n  v4 = 1;\n  if (!strcmp(v3, \"-h\")) {\n    v5 = v4 & 1;\n    return v5;\n  }\n  v4 = !strcmp(v3, \"--help\");\n}\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/punch.c"}
{"compilable":0,"function":"int in_cmd(int argc, char **argv) {\n    if (0 == argc) {\n        char *cmd = \"in\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_in = with_open_log_file(argv[0], in_cmd_with_fh);\n    return (0 != did_punch_in);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint in_cmd_name_conflict_with_fh; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(help_cmd)(long long, long long);\nlong long(with_open_log_file)(long long, long long);\n\nlong long in_cmd_name_conflict(unsigned long a0, unsigned long long *a1) {\n  unsigned long v0; // [bp-0x10]\n\n  if (!(unsigned int)a0) {\n    v0 = \"in\";\n    help_cmd(1, &v0);\n    return 64;\n  }\n  return (int)with_open_log_file(*(a1), in_cmd_name_conflict_with_fh);\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/in_cmd.c"}
{"compilable":0,"function":"bool ensure_data_dir_exists(void) {\n    char path[4096];\n    get_data_dir(path);\n    struct stat finfo;\n    int success = stat(path, &finfo);\n    if (-1 == success) {\n        if (2 == (*__errno_location())) {\n            success = mkdir(path, 16384 | (256 | 128 | 64) | (256 >> 3));\n            if (-1 == success) {\n                goto fail;\n            }\n        } else {\n            goto fail;\n        }\n    }\n    return 1;\n  fail:\n    fprintf(stderr, \"Error %d (%s) trying to create %s\\n\", (*__errno_location()), edesc((*__errno_location())), path);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_data_dir)(long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(edesc)(long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long ensure_data_dir_exists_name_conflict() {\n  stat v0;               // [bp-0x1098]\n  char v1;               // [bp-0x1008]\n  unsigned int *v4;      // rbx\n  unsigned long long v5; // rbx\n\n  get_data_dir(&v1);\n  if (stat(&v1, &v0) != -1)\n    return 1;\n  v4 = __errno_location();\n  if (*(v4) == 2 && mkdir(&v1, 16864) != -1)\n    return 1;\n  v5 = *(v4);\n  fprintf(stderr @GLIBC_2.2.5, \"Error %d (%s) trying to create %s\\n\",\n          (unsigned int)v5, (int)edesc(v5), (unsigned int)&v1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:49:3: error: redefinition of 'stat' as\ndifferent kind of symbol 49 | } stat; |   ^\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:17:6: note: previous definition is\nhere 17 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:51:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:51:22: error: expected ';' after top\nlevel declarator 51 | extern FILE_t *stderr@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:55:5: error: must use 'struct' tag to\nrefer to type 'stat' 55 |     stat v0;  // [bp-0x1098] |     ^ |     struct\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:17:6: note: struct 'stat' is hidden by\na non-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:67:19: error: expected ')'\n   67 |     fprintf(stderr@GLIBC_2.2.5, \"Error %d (%s) trying to create %s\\n\",\n(unsigned int)v5, (int)edesc(v5), (unsigned int)&v1); |                   ^\n/tmp/tmpi1r9zfnd/ensure_data_dir_exists_name_conflict.c:67:12: note: to match this '('\n   67 |     fprintf(stderr@GLIBC_2.2.5, \"Error %d (%s) trying to create %s\\n\",\n(unsigned int)v5, (int)edesc(v5), (unsigned int)&v1); |            ^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":1,"function":"char *edesc(int err) {\n    switch (err) {\n      case 2:\n        return \"file does not exist\";\n      case 20:\n        return \"is not a directory\";\n      case 13:\n        return \"access denied\";\n      case 9:\n        return \"bad file descriptor\";\n      case 17:\n        return \"the file exists\";\n      case 36:\n        return \"filename too long\";\n      case 30:\n        return \"write access requested on a read-only filesystem\";\n      case 22:\n        return \"flag is invalid\";\n      default:\n        return \"unknown error\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long edesc_name_conflict(unsigned long a0) {\n  switch ((unsigned int)a0) {\n  case 2:\n    return \"file does not exist\";\n  case 9:\n    return \"bad file descriptor\";\n  case 13:\n    return \"access denied\";\n  case 17:\n    return \"the file exists\";\n  case 20:\n    return \"is not a directory\";\n  case 22:\n    return \"flag is invalid\";\n  case 30:\n    return \"write access requested on a read-only filesystem\";\n  case 36:\n    return \"filename too long\";\n  default:\n    return \"unknown error\";\n  }\n}\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":0,"function":"int out_cmd(int argc) {\n    if (argc > 0) {\n        char *cmd = \"out\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_out = with_open_log_file(((void *)0), out_cmd_with_fh);\n    return (0 != did_punch_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint out_cmd_name_conflict_with_fh; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(with_open_log_file)(long long, long long);\nlong long(help_cmd)(long long, long long);\n\nlong long out_cmd_name_conflict(unsigned long a0) {\n  unsigned long v0; // [bp-0x10]\n\n  if ((unsigned int)a0 > 0) {\n    v0 = \"out\";\n    help_cmd(1, &v0);\n    return 64;\n  }\n  return (int)with_open_log_file(0, out_cmd_name_conflict_with_fh);\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/out_cmd.c"}
{"compilable":0,"function":"size_t strfentry_time(char *buf, time_t *t) {\n    struct tm tt;\n    localtime_r(t, &tt);\n    size_t foo = strfiso8601(buf, 26, &tt);\n    return foo;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct tm *(localtime_r)(long *, struct tm {\n    int tm_sec;\n    int tm_min;\n    int tm_hour;\n    int tm_mday;\n    int tm_mon;\n    int tm_year;\n    int tm_wday;\n    int tm_yday;\n    int tm_isdst;\n    long tm_gmtoff;\n    char *tm_zone;\n} *);\nlong long(strfiso8601)(long long, long long, long long);\n\ntypedef struct tm {\n  unsigned int tm_sec;\n  unsigned int tm_min;\n  unsigned int tm_hour;\n  unsigned int tm_mday;\n  unsigned int tm_mon;\n  unsigned int tm_year;\n  unsigned int tm_wday;\n  unsigned int tm_yday;\n  unsigned int tm_isdst;\n  char padding_24[4];\n  unsigned int tm_gmtoff;\n  char padding_2c[4];\n  char *tm_zone;\n} tm;\n\nlong long strfentry_time(unsigned long long a0, unsigned int *a1) {\n  tm v0; // [bp-0x58]\n\n  localtime_r(a1, &v0);\n  return strfiso8601(a0, 26, &v0);\n}\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/entry.c"}
{"compilable":0,"function":"int summary_cmd(int argc, char **argv) {\n    t_formatter_fn formatter = print_summary_human;\n    if (argc > 0 && 0 == strncmp(\"--csv\", argv[0], 5)) {\n        formatter = print_summary_csv;\n    }\n    int exit_code = 0;\n    if (isatty(fileno(stdin))) {\n        exit_code = with_open_log_file((void *)formatter, summary_cmd_with_fh);\n    } else {\n        exit_code = summary_cmd_with_fh(stdin, (void *)formatter);\n    }\n    return exit_code;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint print_summary_human; // add global variable by heuristics\nint print_summary_csv;   // add global variable by heuristics\nint print_summary_human; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(summary_cmd_name_conflict_with_fh)(long long, long long);\nlong long(with_open_log_file)(long long, long long);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long summary_cmd_name_conflict(unsigned long a0, unsigned long long *a1) {\n  unsigned long v1; // rbx, Other Possible Types: unsigned long long\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = print_summary_human;\n  if ((unsigned int)a0 > 0)\n    v1 = (strncmp(\"--csv\", *(a1), 5) ? print_summary_csv : print_summary_human);\n  if (isatty(fileno(stdin @GLIBC_2.2.5))) {\n    v3 = with_open_log_file(v1, summary_cmd_name_conflict_with_fh);\n    return v3;\n  }\n  v3 = summary_cmd_name_conflict_with_fh(stdin @GLIBC_2.2.5, v1);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1i7jh8e0/summary_cmd_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp1i7jh8e0/summary_cmd_name_conflict.c:22:21: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmp1i7jh8e0/summary_cmd_name_conflict.c:32:28: error: expected ')'\n   32 |     if (isatty(fileno(stdin@GLIBC_2.2.5)))\n      |                            ^\n/tmp/tmp1i7jh8e0/summary_cmd_name_conflict.c:32:22: note: to match this '('\n   32 |     if (isatty(fileno(stdin@GLIBC_2.2.5)))\n      |                      ^\n/tmp/tmp1i7jh8e0/summary_cmd_name_conflict.c:37:35: error: expected ')'\n   37 |     v3 = summary_cmd_name_conflict_with_fh(stdin@GLIBC_2.2.5, v1);\n      |                                   ^\n/tmp/tmp1i7jh8e0/summary_cmd_name_conflict.c:37:29: note: to match this '('\n   37 |     v3 = summary_cmd_name_conflict_with_fh(stdin@GLIBC_2.2.5, v1);\n      |                             ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/summary_cmd.c"}
{"compilable":0,"function":"static int choose_pivot(int *p, int n) {\n    int *pl, *pm, *pn;\n    int s;\n    pm = p + (n >> 1);\n    if (n > 7) {\n        pl = p;\n        pn = p + n - 1;\n        if (n > 40) {\n            s = n >> 3;\n            pl = ((V[*(pl) + (h)]) < (V[*(pl + s) + (h)]) ? ((V[*(pl + s) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)) : ((V[*(pl + s) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)));\n            pm = ((V[*(pm - s) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) < (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)) : ((V[*(pm) + (h)]) > (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) > (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)));\n            pn = ((V[*(pn - s - s) + (h)]) < (V[*(pn - s) + (h)]) ? ((V[*(pn - s) + (h)]) < (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pn - s - s)) : ((V[*(pn - s) + (h)]) > (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pn - s - s)));\n        }\n        pm = ((V[*(pl) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pl)) : ((V[*(pm) + (h)]) > (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pl)));\n    }\n    return (V[*(pm) + (h)]);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"static int transform(int *x, int *p, int n, int k, int l, int q) {\n    int b, c, d, e, i, j, m, s;\n    int *pi, *pj;\n    for (s = 0 , i = k - l; i; i >>= 1)\n        ++s;\n    e = 2147483647 >> s;\n    for (b = d = r = 0; r < n && d <= e && (c = d << s | (k - l)) <= q; ++r) {\n        b = b << s | (x[r] - l + 1);\n        d = c;\n    }\n    m = (1 << (r - 1) * s) - 1;\n    x[n] = l - 1;\n    if (d <= n) {\n        for (pi = p; pi <= p + d; ++pi)\n            *pi = 0;\n        for (pi = x + r , c = b; pi <= x + n; ++pi) {\n            p[c] = 1;\n            c = (c & m) << s | (*pi - l + 1);\n        }\n        for (i = 1; i < r; ++i) {\n            p[c] = 1;\n            c = (c & m) << s;\n        }\n        for (pi = p , j = 1; pi <= p + d; ++pi)\n            if (*pi)\n                *pi = j++;\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = p[c];\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = p[c];\n                c = (c & m) << s;\n            }\n    } else {\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = c;\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = c;\n                c = (c & m) << s;\n            }\n        j = d + 1;\n    }\n    x[n] = 0;\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int r;\n\nlong long transform(unsigned int a0[1], unsigned int *a1, unsigned long a2,\n                    unsigned long a3, unsigned long a4, unsigned long a5) {\n  unsigned int *v1;       // r10\n  unsigned long long v2;  // r12\n  unsigned long long v3;  // rcx\n  unsigned long v4;       // rax, Other Possible Types: unsigned long long\n  unsigned long v5;       // rdx, Other Possible Types: unsigned long long\n  void *v6;               // r11, Other Possible Types: unsigned long\n  void *v7;               // rbx, Other Possible Types: unsigned long\n  unsigned long v8;       // rsi, Other Possible Types: unsigned long long\n  unsigned int v9;        // r9d\n  unsigned int *v10;      // r13, Other Possible Types: unsigned long\n  unsigned int *v11;      // rsi, Other Possible Types: unsigned long\n  unsigned int v12[1];    // r10, Other Possible Types: unsigned long\n  unsigned int *v13;      // rcx, Other Possible Types: unsigned long\n  unsigned int *v14;      // r12\n  unsigned int *v15;      // r11, Other Possible Types: unsigned long\n  unsigned long v16;      // rcx\n  unsigned int v17;       // r11d\n  unsigned int *v18;      // rcx, Other Possible Types: unsigned long\n  unsigned long long v19; // r11, Other Possible Types: unsigned long\n  unsigned int *v20;      // rsi, Other Possible Types: unsigned long\n  unsigned int v21[1];    // rbx, Other Possible Types: unsigned long\n  void *v22;         // rax, Other Possible Types: unsigned long, unsigned int\n  unsigned int *v23; // rax\n  unsigned int *v24; // rbp, Other Possible Types: unsigned long\n\n  v1 = a1;\n  v2 = a2;\n  v3 = a3 - a4;\n  if ((unsigned int)v3 == (unsigned int)a4) {\n    v5 = v3;\n  } else {\n    v4 = v3;\n    do {\n      v5 = 1;\n      v4 >>= 1;\n    } while ((unsigned int)(v3 >> 1));\n  }\n  r = 0;\n  if ((unsigned int)v2 <= 0) {\n    v6 = 0;\n    v22 = 0;\n    v7 = 0;\n  } else if ((unsigned int)v3 <= (unsigned int)a5) {\n    v6 = v3;\n    v8 = 1;\n    v22 = 0;\n    while (true) {\n      v22 = (unsigned int)v22 << ((char)v5 & 31) |\n            a0[1 + v8] - (unsigned int)a4 + 1;\n      v7 = v8;\n      if ((int)(2147483647 >> ((char)v5 & 31)) < (unsigned int)v6 ||\n          (unsigned int)v2 <= (unsigned int)v8) {\n        r = v7;\n        break;\n      } else {\n        v8 += 1;\n        if ((unsigned int)v6 <= (unsigned int)a5) {\n          v6 = (unsigned int)(v6 << ((char)v5 & 31)) | (unsigned int)v3;\n        } else {\n          r = v7;\n          break;\n        }\n      }\n    }\n  } else {\n    v9 = (int)(1 << ((char)-((unsigned int)v5) & 31)) - 1;\n    v24 = &a0[v2];\n    *(v24) = (unsigned int)a4 - 1;\n    v10 = a1;\n    v7 = 0;\n    v22 = 0;\n  LABEL_401b87:\n    v13 = v1;\n    do {\n      *((int *)v13) = 0;\n      v13 += 4;\n    } while (v10 >= v13);\n  LABEL_401b99:\n    v14 = &a0[v7];\n    if (v24 < v14) {\n      v16 = v22;\n    } else {\n      v15 = v14;\n      v16 = v22;\n      do {\n        v1[v16] = 1;\n        v16 = ((unsigned int)v16 & v9) << ((char)v5 & 31) |\n              *((int *)v15) - (unsigned int)a4 + 1;\n        v15 += 4;\n      } while (v24 >= v15);\n    }\n    if ((unsigned int)v7 > 1) {\n      v17 = 1;\n      do {\n        v1[v16] = 1;\n        v16 = ((unsigned int)v16 & v9) << ((char)v5 & 31);\n        v17 += 1;\n      } while ((unsigned int)v7 != v17);\n    }\n    if (v10 < v1) {\n      v19 = 1;\n    } else {\n      v18 = v1;\n      v19 = 1;\n      do {\n        if (*((int *)v18)) {\n          *((unsigned int *)v18) = v19;\n          v19 += 1;\n        }\n      } while ((v18 += 4, v10 >= v18));\n    }\n    if (v24 >= v14) {\n      v20 = v14;\n      v21 = a0;\n      do {\n        *((unsigned int *)v21) = v1[v22];\n        v22 = ((unsigned int)v22 & v9) << ((char)v5 & 31) |\n              *((int *)v20) - (unsigned int)a4 + 1;\n        v21 += 4;\n        v20 += 4;\n      } while (v24 >= v20);\n      a0 = &a0[(v24 - (char *)v14 >> 2) + 1];\n    }\n    if (a0 >= v24) {\n      *((int *)v24) = 0;\n      return v19;\n    }\n    do {\n      a0 += 4;\n      *((unsigned int *)(a0 - 4)) = v1[v22];\n      v23 = (unsigned int)v22 & v9;\n      v22 = v23 << ((char)v5 & 31);\n    } while (a0 < v24);\n  }\n  v9 = (int)(1 << ((char)((unsigned int)v5 * ((unsigned int)v7 - 1)) & 31)) - 1;\n  v24 = &a0[v2];\n  *(v24) = (unsigned int)a4 - 1;\n  if ((unsigned int)v2 < (unsigned int)v6) {\n    v11 = &a0[v7];\n    if (v24 >= v11) {\n      v12 = a0;\n      do {\n        *((unsigned int *)v12) = v22;\n        v22 = ((unsigned int)v22 & v9) << ((char)v5 & 31) |\n              *((int *)v11) - (unsigned int)a4 + 1;\n        v12 += 4;\n        v11 += 4;\n      } while (v24 >= v11);\n      a0 = &a0[v2 + -1 * v7 + 1];\n    }\n    if (a0 < v24) {\n      do {\n        a0 += 4;\n        *((unsigned int *)(a0 - 4)) = v22;\n        v22 = ((unsigned int)v22 & v9) << ((char)v5 & 31);\n      } while (a0 < v24);\n    }\n    v19 = (unsigned int)v6 + 1;\n    *((int *)v24) = 0;\n    return v19;\n  }\n  v10 = &v1[v6];\n  if (v10 < v1)\n    goto LABEL_401b99;\n  goto LABEL_401b87;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1axvgvtm/transform.c:88:44: error: invalid operands to binary expression\n('void *' and 'int') 88 |                     v6 = (unsigned int)(v6 <<\n((char)v5 & 31)) | (unsigned int)v3; | ~~ ^  ~~~~~~~~~~~~~~~\n/tmp/tmp1axvgvtm/transform.c:114:18: error: array subscript is not an integer\n  114 |         v14 = &a0[v7];\n      |                  ^~~\n/tmp/tmp1axvgvtm/transform.c:160:17: error: array type 'unsigned int[1]' is not\nassignable 160 |             v21 = a0; |             ~~~ ^\n/tmp/tmp1axvgvtm/transform.c:163:44: error: array subscript is not an integer\n  163 |                 *((unsigned int *)v21) = v1[v22];\n      |                                            ^~~~\n/tmp/tmp1axvgvtm/transform.c:165:21: error: invalid operands to binary\nexpression ('unsigned int[1]' and 'int') 165 |                 v21 += 4; | ~~~ ^\n~ /tmp/tmp1axvgvtm/transform.c:168:27: error: 'unsigned int *' and 'char *' are\nnot pointers to compatible types 168 |             a0 = &a0[(v24 - (char *)v14\n>> 2) + 1]; |                       ~~~ ^ ~~~~~~~~~~~\n/tmp/tmp1axvgvtm/transform.c:178:45: error: array subscript is not an integer\n  178 |             *((unsigned int *)(a0 - 4)) = v1[v22];\n      |                                             ^~~~\n/tmp/tmp1axvgvtm/transform.c:180:23: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 180 |             v22 = v23 << ((char)v5\n& 31); |                   ~~~ ^  ~~~~~~~~~~~~~~~\n/tmp/tmp1axvgvtm/transform.c:188:18: error: array subscript is not an integer\n  188 |         v11 = &a0[v7];\n      |                  ^~~\n/tmp/tmp1axvgvtm/transform.c:191:17: error: array type 'unsigned int[1]' is not\nassignable 191 |             v12 = a0; |             ~~~ ^\n/tmp/tmp1axvgvtm/transform.c:196:21: error: invalid operands to binary\nexpression ('unsigned int[1]' and 'int') 196 |                 v12 += 4; | ~~~ ^\n~ /tmp/tmp1axvgvtm/transform.c:199:30: error: invalid operands to binary\nexpression ('int' and 'void *') 199 |             a0 = &a0[v2 + -1 * v7 + 1]; |\n~~ ^ ~~ /tmp/tmp1axvgvtm/transform.c:214:14: error: array subscript is not an\ninteger 214 |     v10 = &v1[v6]; |              ^~~ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int vcblocksortCompress(int level, const unsigned char *data, size_t avail_in, unsigned char *odata, size_t *avail_out) {\n    double result;\n    struct BlockSortCompressionInstance *bsci;\n    bsci = calloc(sizeof (*bsci), 1);\n    resetStatistics(bsci);\n    result = bs_compress(bsci, (unsigned char *)data, avail_in);\n    freeBSCI(bsci);\n    *avail_out = (int)result;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble(log)(double);\ndouble(bs_compress)(long long, long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[1032];\n  unsigned int field_408;\n  char padding_40c[4];\n  void *field_410;\n  void *field_418;\n  unsigned int field_420;\n} struct_0;\n\nlong long vcblocksortCompress(unsigned long a0, unsigned long long a1,\n                              unsigned long a2, unsigned long a3,\n                              unsigned long long *a4) {\n  void *v0;              // [bp-0x40], Other Possible Types: unsigned long\n  int tmp_22;            // tmp #22\n  int tmp_23;            // tmp #23\n  int tmp_20;            // tmp #20\n  struct_0 *v3;          // r12\n  unsigned long long v4; // xmm1lq\n  int v5;                // xmm0\n  unsigned long long v6; // rdx\n  unsigned int v7;       // eax\n  void *v8;              // rbx, Other Possible Types: unsigned long\n  void *v9;              // rbp, Other Possible Types: unsigned long\n  unsigned int v10;      // eax\n\n  v3 = calloc(1064, 1);\n  v8 = 0;\n  v9 = 0;\n  v0 = 0;\n  do {\n    log((long long)((0 CONCAT v8) + 0x3ff0000000000000));\n    v4 = v0;\n    tmp_22 = DivV(tmp_23, tmp_20);\n    v5 = tmp_22;\n    v0 = (unsigned long long)v5;\n    v6 = (unsigned long long)v5 - v4;\n    if (1 < (unsigned int)v6)\n      v9 = v6 + v9 - 1;\n    v7 = (unsigned long long)v5 - v9;\n    *((unsigned int *)&v3->padding_0[8 + 4 * v8]) = v7;\n    v8 += 1;\n  } while (v8 != 0x100);\n  v10 = v7 + 1;\n  v3->field_408 = v10;\n  if (v10 > 13)\n    __assert_fail(); /* do not return */\n  bs_compress(v3, a1, a2);\n  v0 = (unsigned long long)v5;\n  if (v3->field_420 <= 0) {\n    free(v3);\n    *(a4) = v0;\n    return 0;\n  }\n  free(v3->field_410);\n  free(v3->field_418);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuz3h0amx/vcblocksortCompress.c:49:28: error: expected ')'\n   49 |         log((long long)((0 CONCAT v8) + 0x3ff0000000000000));\n      |                            ^\n/tmp/tmpuz3h0amx/vcblocksortCompress.c:49:25: note: to match this '('\n   49 |         log((long long)((0 CONCAT v8) + 0x3ff0000000000000));\n      |                         ^\n/tmp/tmpuz3h0amx/vcblocksortCompress.c:57:37: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 57 |         v7 = (unsigned long\nlong)v5 - v9; |              ~~~~~~~~~~~~~~~~~~~~~~ ^ ~~\n/tmp/tmpuz3h0amx/vcblocksortCompress.c:58:48: error: invalid operands to binary\nexpression ('int' and 'void *') 58 |         *((unsigned int *)&v3->padding_0[8\n+ 4 * v8]) = v7; |                                              ~ ^ ~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int smaz_compress(const unsigned char *in, size_t inlen, unsigned char *out, size_t outlen) {\n    unsigned int h1, h2, h3 = 0;\n    int verblen = 0, _outlen = outlen;\n    unsigned char verb[256], *_out = out;\n    while (inlen)\n        {\n            int j = 7, needed;\n            unsigned char *flush = ((void *)0);\n            char *slot;\n            h1 = h2 = in[0] << 3;\n            if (inlen > 1)\n                h2 += in[1];\n            if (inlen > 2)\n                h3 = h2 ^ in[2];\n            if (j > inlen)\n                j = inlen;\n            for (; j > 0; j--) {\n                switch (j) {\n                  case 1:\n                    slot = Smaz_cb[h1 % 241];\n                    break;\n                  case 2:\n                    slot = Smaz_cb[h2 % 241];\n                    break;\n                  default:\n                    slot = Smaz_cb[h3 % 241];\n                    break;\n                }\n                while (slot[0])\n                    {\n                        if (slot[0] == j && memcmp(slot + 1, in, j) == 0) {\n                            if (verblen) {\n                                needed = (verblen == 1) ? 2 : 2 + verblen;\n                                flush = out;\n                                out += needed;\n                                outlen -= needed;\n                            }\n                            if (outlen <= 0)\n                                return _outlen + 1;\n                            out[0] = slot[slot[0] + 1];\n                            out++;\n                            outlen--;\n                            inlen -= j;\n                            in += j;\n                            goto out;\n                        } else {\n                            slot += slot[0] + 2;\n                        }\n                    }\n            }\n            verb[verblen] = in[0];\n            verblen++;\n            inlen--;\n            in++;\n          out:\n            if (!flush && (verblen == 256 || (verblen > 0 && inlen == 0))) {\n                needed = (verblen == 1) ? 2 : 2 + verblen;\n                flush = out;\n                out += needed;\n                outlen -= needed;\n                if (outlen < 0)\n                    return _outlen + 1;\n            }\n            if (flush) {\n                if (verblen == 1) {\n                    flush[0] = (signed char)254;\n                    flush[1] = verb[0];\n                } else {\n                    flush[0] = (signed char)255;\n                    flush[1] = (signed char)(verblen - 1);\n                    memcpy(flush + 2, verb, verblen);\n                }\n                flush = ((void *)0);\n                verblen = 0;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern char Smaz_cb;\n\nlong long smaz_compress(char a0[3], unsigned long a1, char a2[2],\n                        unsigned long a3) {\n  unsigned int v0;      // [bp-0x17c]\n  int tmp_8;            // tmp #8\n  char v1[2];           // [bp-0x178], Other Possible Types: unsigned long\n  unsigned long v2;     // [bp-0x170]\n  struct struct_1 **v3; // [bp-0x168]\n  unsigned long v4;     // [bp-0x160]\n  unsigned long v5;     // [bp-0x158]\n  unsigned int v6;      // [bp-0x150]\n  char v7;              // [bp-0x149]\n  char v8[2];           // [bp-0x148]\n  unsigned long v9;     // [bp-0x140]\n  char v10;             // [bp-0x138]\n  char v12[2];          // rbx, Other Possible Types: unsigned long\n  char v13[3]; // r15, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v14; // rdi\n  unsigned long long v15; // r8, Other Possible Types: unsigned long\n  unsigned long v16;      // r12, Other Possible Types: unsigned long long\n  unsigned long long v17; // rbx\n  unsigned long v18;      // r13\n  char *v19;              // rbp, Other Possible Types: unsigned long\n  unsigned long v20;      // rbx, Other Possible Types: unsigned long long\n  struct_0 *v21;          // rcx\n  char v22[2];            // rax, Other Possible Types: unsigned long\n  struct_0 *v23;          // rcx\n  unsigned long v25;      // rcx, Other Possible Types: unsigned long long\n  char v26[2];            // rsi\n  unsigned int v27;       // esi\n  unsigned long long v28; // rdx\n  struct_0 *v29;          // rcx\n  unsigned long v30;      // r14, Other Possible Types: unsigned long long\n\n  v12 = a2;\n  if (!a1) {\n    *(&v1) = a2;\n  } else {\n    v13 = a0;\n    v30 = a1;\n    v2 = a3;\n    *(&v1) = a2;\n    v0 = 0;\n    v6 = 0;\n    *(&v8) = a2;\n    v9 = a3;\n  }\n  do {\n    v7 = *((char *)v13);\n    v14 = v7 * 8;\n    if (v30 <= 1) {\n      v15 = v14;\n    } else {\n      v15 = *((char *)(v13 + 1)) + v14;\n      if (v30 > 2) {\n        v6 = *((char *)(v13 + 2)) ^ (unsigned int)v15;\n      } else {\n      LABEL_4044ad:\n        v16 = v30;\n        if ((unsigned int)v30 <= 0)\n          goto LABEL_40453f;\n        goto LABEL_4044b9;\n      }\n    }\n    if (v30 <= 6)\n      goto LABEL_4044ad;\n    v16 = 7;\n  LABEL_4044b9:\n    v17 = v6;\n    v18 = v16;\n    v3 = v14 - (unsigned int)v14 / 241 * 241;\n    v4 = v17 - (unsigned int)v17 / 241 * 241;\n    v5 = v15 - (unsigned int)v15 / 241 * 241;\n    while (true) {\n      if ((unsigned int)v16 == 1) {\n        v19 = *((long long *)(&Smaz_cb + 0x8 * v3));\n        v20 = *(v19);\n        if (!(char)v20)\n          goto LABEL_40453f;\n        goto LABEL_4045f6;\n      }\n      if ((unsigned int)v16 != 2)\n        break;\n      v19 = *((long long *)&(&Smaz_cb)[8 * v5]);\n      v20 = *((char *)v19);\n      if (!(!(char)v20))\n        goto LABEL_4045f6;\n      v16 = (unsigned int)v16 - 1;\n      v18 -= 1;\n    }\n    v19 = *((long long *)&(&Smaz_cb)[8 * v4]);\n    v20 = *((char *)v19);\n    if (!(char)v20)\n      goto LABEL_4046df;\n  LABEL_4045f6:\n    if (!((char)v20 == (unsigned int)v16) || !(!memcmp(v19 + 1, v13, v18))) {\n      v19 = v19 + (char)v20 + 2;\n      v20 = *((char *)v19);\n      if (!(!(char)v20))\n        continue;\n    LABEL_4046df:\n      v18 -= 1;\n      tmp_8 = v16;\n      v16 = (unsigned int)v16 - 1;\n      if (!((int)tmp_8 == 1))\n        continue;\n    LABEL_40453f:\n      v21 = v0;\n      *((char *)(&v10 + v21)) = v7;\n      v0 = (unsigned int)v21 + 1;\n      v30 -= 1;\n      v13 += 1;\n      v22 = v1;\n      goto LABEL_404563;\n    }\n    v22 = 0;\n    v23 = v0;\n    if ((unsigned int)v23) {\n      v25 = v23 + 2;\n      if ((unsigned int)v23 == 1)\n        v25 = 2;\n      v2 -= v25;\n      v22 = v1;\n      v1 = v22 + v25;\n    }\n    if (!v2)\n      return v9 + 1;\n    v26 = v1;\n    v26[0] = *((char *)(v19 + (char)v20 + 1));\n    *(&v1) = &v26[1];\n    v2 -= 1;\n    v30 -= v18;\n    v13 = &v13[v18];\n    if (v22) {\n    LABEL_40467d:\n      if (v0 != 1) {\n        *((char *)v22) = 255;\n        v29 = v0;\n        *((char *)(v22 + 1)) = (unsigned int)v29 - 1;\n        memcpy(v22 + 2, &v10, v29);\n        v0 = 0;\n        goto LABEL_40469b;\n      }\n    }\n    v22 = v1;\n  LABEL_404563:\n    v27 = v0;\n    if (v27 == 0x100) {\n      v28 = v0 + 2;\n      *((unsigned long long *)&v1) = v22 + v28;\n      v2 -= v28;\n      if (!v22)\n        goto LABEL_40469b;\n      goto LABEL_40467d;\n    }\n    if (!(v27 <= 0) && !(v30) && v27 == 1) {\n      *((unsigned long *)&v1) = v22 + 2;\n      v2 -= 2;\n      if (!v22)\n        goto LABEL_40469b;\n      *((char *)v22) = 254;\n      *((char *)(v22 + 1)) = v10;\n      v0 = 0;\n      goto LABEL_40469b;\n    }\n    *((unsigned long *)&v1) = v22;\n  LABEL_40469b:\n  } while (v30);\n  v12 = v8;\n  return (int)v1 - v12;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzx1sb7t3/smaz_compress.c:56:9: error: array type 'char[2]' is not\nassignable 56 |     v12 = a2; |     ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:59:16: error: array type 'char[2]' is not\nassignable 59 |         *(&v1) = a2; |         ~~~~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:63:13: error: array type 'char[3]' is not\nassignable 63 |         v13 = a0; |         ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:66:16: error: array type 'char[2]' is not\nassignable 66 |         *(&v1) = a2; |         ~~~~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:69:16: error: array type 'char[2]' is not\nassignable 69 |         *(&v8) = a2; |         ~~~~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:109:54: error: invalid operands to binary\nexpression ('int' and 'struct struct_1 **') 109 |                 v19 = *((long\nlong *)(&Smaz_cb + 0x8 * v3)); | ~~~ ^ ~~\n/tmp/tmpzx1sb7t3/smaz_compress.c:143:29: error: invalid operands to binary\nexpression ('char *' and 'struct_0 *' (aka 'struct struct_0 *')) 143 | *((char\n*)(&v10 + v21)) = v7; |                        ~~~~ ^ ~~~\n/tmp/tmpzx1sb7t3/smaz_compress.c:146:17: error: invalid operands to binary\nexpression ('char[3]' and 'int') 146 |             v13 += 1; |             ~~~ ^\n~ /tmp/tmpzx1sb7t3/smaz_compress.c:147:17: error: array type 'char[2]' is not\nassignable 147 |             v22 = v1; |             ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:150:13: error: array type 'char[2]' is not\nassignable 150 |         v22 = 0; |         ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:158:17: error: array type 'char[2]' is not\nassignable 158 |             v22 = v1; |             ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:159:16: error: array type 'char[2]' is not\nassignable 159 |             v1 = v22 + v25; |             ~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:163:13: error: array type 'char[2]' is not\nassignable 163 |         v26 = v1; |         ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:165:16: error: array type 'char[2]' is not\nassignable 165 |         *(&v1) = &v26[1]; |         ~~~~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:168:13: error: array type 'char[3]' is not\nassignable 168 |         v13 = &v13[v18]; |         ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:182:13: error: array type 'char[2]' is not\nassignable 182 |         v22 = v1; |         ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:208:9: error: array type 'char[2]' is not\nassignable 208 |     v12 = v8; |     ~~~ ^\n/tmp/tmpzx1sb7t3/smaz_compress.c:209:20: error: invalid operands to binary\nexpression ('int' and 'char[2]') 209 |     return (int)v1 - v12; | ~~~~~~~ ^ ~~~\n18 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"int sCompress(int level, const unsigned char *in, size_t inlen, unsigned char *out, size_t *outlen) {\n    int res = smaz_compress(in, inlen, out, *outlen);\n    *outlen = res;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(smaz_compress)(long long, long long, long long, long long);\n\nlong long sCompress(unsigned long a0, unsigned long long a1,\n                    unsigned long long a2, unsigned long long a3,\n                    unsigned long long *a4) {\n  *(a4) = smaz_compress(a1, a2, a3, *(a4));\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"int smaz_decompress(char *in, int inlen, char *out, int outlen) {\n    unsigned char *c = (unsigned char *)in;\n    char *_out = out;\n    int _outlen = outlen;\n    while (inlen)\n        {\n            if (*c == 254) {\n                if (outlen < 1)\n                    return _outlen + 1;\n                *out = *(c + 1);\n                out++;\n                outlen--;\n                c += 2;\n                inlen -= 2;\n            } else if (*c == 255) {\n                int len = (*(c + 1)) + 1;\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, c + 2, len);\n                out += len;\n                outlen -= len;\n                c += 2 + len;\n                inlen -= 2 + len;\n            } else {\n                char *s = Smaz_rcb[*c];\n                int len = strlen(s);\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, s, len);\n                out += len;\n                outlen -= len;\n                c++;\n                inlen--;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  unsigned long long field_2;\n} struct_0;\n\nextern char Smaz_rcb;\n\nlong long smaz_decompress(struct_0 *a0, unsigned long a1, char *a2,\n                          unsigned long a3) {\n  void *v0;        // [bp-0x50]\n  char *v1;        // [bp-0x48]\n  unsigned int v2; // [bp-0x3c]\n  char *v4; // rbx, Other Possible Types: unsigned long, unsigned long long,\n            // struct_0 *\n  unsigned long v5;        // r12, Other Possible Types: unsigned long long\n  unsigned long long *v6;  // rax\n  unsigned long v7;        // rax\n  unsigned long long v8;   // r8\n  unsigned long long v9;   // rdx\n  char *v10;               // rsi\n  unsigned long long *v11; // rdi, Other Possible Types: unsigned long\n  unsigned long long v12;  // rax\n  unsigned long long *v13; // rsi, Other Possible Types: unsigned long\n  unsigned long v14;       // rcx, Other Possible Types: unsigned long long\n  char *v15; // rbp, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v16; // r13, Other Possible Types: unsigned long\n  unsigned long v17;      // d\n  unsigned long long v18; // r8\n\n  v1 = a2;\n  v2 = a3;\n  if (!(unsigned int)a1) {\n    v15 = v1;\n  } else {\n    v4 = a0;\n    v5 = a1;\n    v16 = a3;\n    v15 = a2;\n    do {\n      v6 = *((char *)v4);\n      if ((char)v6 != 254) {\n        if ((char)v6 == 255) {\n          v8 = *((char *)(v4 + 1));\n          v9 = v8 + 1;\n          if ((unsigned int)v9 > (unsigned int)v16)\n            return v2 + 1;\n          v10 = v4 + 2;\n          if ((unsigned int)v9 >= 8) {\n            *((long long *)v15) = *((long long *)(v4 + 2));\n            *((long long *)(v15 + v9 - 8)) = *((long long *)&v10[8 + v9]);\n            v11 = v15 + 8 & -8;\n            v12 = v15 - (char *)v11;\n            v13 = &v10[-1 * v12];\n            for (v14 = v9 + v12 >> 3; v14; v13 += v17 * 8) {\n              v14 -= 1;\n              *((long long *)v11) = *((long long *)v13);\n              v11 += v17 * 8;\n            }\n          } else if (((char)v9 & 4)) {\n            *((int *)v15) = *((int *)&v10);\n            *((int *)(v15 + v9 - 4)) = *((int *)&v10[4 + v9]);\n          } else if ((unsigned int)v9) {\n            *((char *)v15) = *(v10);\n            if (((char)v9 & 2))\n              *((short *)(v15 + v9 - 2)) = *((short *)&v10[2 + v9]);\n          }\n          v15 += v9;\n          v16 -= v9;\n          v18 = (unsigned int)v8 + 3;\n          v4 += v18;\n          v5 -= v18;\n        } else {\n          v0 = *((long long *)(&Smaz_rcb + 0x8 * v6));\n          v7 = strlen(v0);\n          if ((unsigned int)v7 > (unsigned int)v16)\n            return v2 + 1;\n          memcpy(v15, v0, v7);\n          v15 += v7;\n          v16 -= v7;\n          v4 += 1;\n          v5 = (unsigned int)v5 - 1;\n        }\n      } else {\n        if ((unsigned int)v16 > 0) {\n          *((char *)v15) = *((char *)(v4 + 1));\n          v15 += 1;\n          v16 = (unsigned int)v16 - 1;\n          v4 += 2;\n          v5 = (unsigned int)v5 - 2;\n        } else {\n          return v2 + 1;\n        }\n      }\n    } while ((unsigned int)v5);\n  }\n  return v15 - (int)v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxl6z5hbb/smaz_decompress.c:74:39: error: invalid operands to binary\nexpression ('char *' and 'int') 74 |                         v11 = v15 + 8 & -8;\n      |                               ~~~~~~~ ^ ~~\n/tmp/tmpxl6z5hbb/smaz_decompress.c:103:58: error: invalid operands to binary\nexpression ('int' and 'unsigned long long *') 103 |                     v0 =\n*((long long *)(&Smaz_rcb + 0x8 * v6)); | ~~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"long rand() {\n    _lastRand = _lastRand * 71762886081639153L;\n    return _lastRand;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long _lastRand;\n\nlong long rand_name_conflict() {\n  _lastRand = _lastRand * 71762886081639153;\n  return _lastRand;\n}\n","pass":0,"source_file":"C_COMPILE/zma_cc0/src/toolchain/test/srad.c"}
{"compilable":0,"function":"long rand_long() {\n    int lower_32bit, upper_32bit;\n    long rand_long;\n    lower_32bit = rand();\n    upper_32bit = rand();\n    return (((long)upper_32bit << 32) + lower_32bit);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long rand_long_name_conflict() { return rand() * 4294967297; }\n","pass":0,"source_file":"C_COMPILE/zma_cc0/apps/kmeans/input-generator/gen-input.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isAlphanum_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x120]\n  unsigned int v2;       // eax\n  unsigned int v3;       // edx\n  unsigned long long v4; // rax\n\n  if ((unsigned int)(a0 - 97) > 25) {\n    v2 = (unsigned int)a0 - 48;\n    if (v2 > 9) {\n      v3 = (unsigned int)a0 - 36;\n      if (v3 > 59) {\n        *((char *)&v2) = (unsigned int)a0 == 92;\n        *((char *)&v3) = 126 < (unsigned int)a0;\n        v4 = v2 | v3;\n        return v4;\n      }\n      v2 = 1;\n      v0 = 612489548785516545;\n      if (((char)(*((char *)&v0 + ((a0 - 36 & 63) >> 3)) >>\n                  (char)(a0 - 36 & 63 & 7)) &\n           1))\n        return 1;\n    }\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\nextern unsigned int theLookahead;\n\nlong long get() {\n  unsigned long long v1; // rax\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = theLookahead;\n  theLookahead = -1;\n  if ((unsigned int)v1 == -1) {\n    (unsigned int)v2 = getc(stdin @GLIBC_2.2.5);\n    if (!(31 >= (unsigned int)v2) || !((unsigned int)v2 != 10)) {\n      return v2;\n    } else if ((unsigned int)v2 == -1) {\n      return v2;\n    } else {\n      v2 = ((unsigned int)v2 != 13 ? 10 : 32);\n      return v2;\n    }\n  }\n  if (!(31 >= (unsigned int)v1) || !((unsigned int)v1 != 10))\n    return v1;\n  if ((unsigned int)v1 == -1)\n    goto LABEL_0x401233;\n  else\n    goto LABEL_0x4011e8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxccahdx3/get.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpxccahdx3/get.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpxccahdx3/get.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpxccahdx3/get.c:76:22: error: type name requires a specifier or qualifier\n   76 |             } __value;\n      |                      ^\n/tmp/tmpxccahdx3/get.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpxccahdx3/get.c:83:22: error: type name requires a specifier or qualifier\n   83 |             } __value;\n      |                      ^\n/tmp/tmpxccahdx3/get.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpxccahdx3/get.c:106:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpxccahdx3/get.c:106:21: error: expected ';' after top level declarator\n  106 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmpxccahdx3/get.c:118:38: error: expected ')'\n  118 |         (unsigned int)v2 = getc(stdin@GLIBC_2.2.5);\n      |                                      ^\n/tmp/tmpxccahdx3/get.c:118:32: note: to match this '('\n  118 |         (unsigned int)v2 = getc(stdin@GLIBC_2.2.5);\n      |                                ^\n/tmp/tmpxccahdx3/get.c:136:14: error: use of undeclared label 'LABEL_0x401233'\n  136 |         goto LABEL_0x401233;\n      |              ^\n/tmp/tmpxccahdx3/get.c:138:14: error: use of undeclared label 'LABEL_0x4011e8'\n  138 |         goto LABEL_0x4011e8;\n      |              ^\n11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get)();\n\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int theLookahead;\n\nlong long next_name_conflict() {\n  unsigned long v1;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v2; // rax\n\n  v1 = get();\n  if ((unsigned int)v1 != 47)\n    return v1;\n  theLookahead = get();\n  if (theLookahead == 42) {\n    get();\n    do {\n      do {\n        (unsigned int)v2 = get();\n        if ((unsigned int)v2 == -1) {\n          fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35,\n                 stderr @GLIBC_2.2.5);\n          exit(1); /* do not return */\n        }\n      } while ((unsigned int)v2 != 42);\n    } while ((theLookahead = (unsigned int)(int)get(), theLookahead != 47));\n    get();\n    return 32;\n  } else if (theLookahead != 47) {\n    return v1;\n  } else {\n    do {\n      v1 = get();\n    } while ((unsigned int)v1 > 10);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplxi73mnk/next_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmplxi73mnk/next_name_conflict.c:18:22: error: expected ';' after top level declarator\n   18 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmplxi73mnk/next_name_conflict.c:37:17: error: assignment to cast is illegal, lvalue\ncasts are not supported 37 |                 (unsigned int)v2 = get(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmplxi73mnk/next_name_conflict.c:40:81: error: expected ')' 40 |\nfwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35, stderr@GLIBC_2.2.5); | ^\n/tmp/tmplxi73mnk/next_name_conflict.c:40:27: note: to match this '('\n   40 |                     fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1,\n35, stderr@GLIBC_2.2.5); |                           ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"unsigned short CheckSum(unsigned short *ptr, int nbytes) {\n    register long sum;\n    unsigned short oddbyte;\n    register short answer;\n    sum = 0;\n    while (nbytes > 1)\n        {\n            sum += *ptr++;\n            nbytes -= 2;\n        }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n    sum = (sum >> 16) + (sum & 65535);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n    return (answer);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned short field_ - 2;\n  char field_0;\n} struct_0;\n\nlong long CheckSum_name_conflict(struct_0 *a0, unsigned int a1) {\n  unsigned long long v1; // r8\n  struct_0 *v2;          // rcx, Other Possible Types: unsigned long\n  void *v4;              // rax, Other Possible Types: unsigned long\n  unsigned long long v5; // rdx\n  unsigned long long v7; // rax\n\n  if (a1 <= 1) {\n    v2 = a0;\n    v4 = 0;\n  } else {\n    v1 = a1 - 2 >> 1;\n    v2 = &(&a0->field_0)[2 * v1];\n    v4 = 0;\n    do {\n      a0 += 2;\n      v4 += *((short *)(a0 - 2));\n    } while (a0 != v2);\n    a1 = a1 + -((unsigned int)v1) * 2 - 2;\n  }\n  if ((unsigned int)a1 == 1)\n    v4 += *((char *)v2);\n  v5 = (v4 >> 16) + v4;\n  v7 = ~((unsigned int)(v5 >> 16) + (unsigned int)v5);\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn7lz9uu1/CheckSum_name_conflict.c:18:26: error: expected ';' at end of declaration\nlist 18 |     unsigned short field_-2; |                          ^ | ;\n/tmp/tmpn7lz9uu1/CheckSum_name_conflict.c:49:14: error: invalid operands to binary expression\n('void *' and 'int') 49 |     v5 = (v4 >> 16) + v4; |           ~~ ^  ~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/2dango_Custom-UDP-packet/udp.c"}
{"compilable":0,"function":"size_t encode_string(char *dest, const char *src) {\n    char *start = dest, c;\n    while ((c = *(src++)))\n        {\n            switch (c) {\n              case '\\n':\n                *(dest++) = '\\\\';\n                *(dest++) = 'n';\n                break;\n              case '\\\\':\n                *(dest++) = '\\\\';\n                *(dest++) = '\\\\';\n                break;\n              case ':':\n                *(dest++) = '\\\\';\n              default:\n                *(dest++) = c;\n            }\n        }\n    *dest = '\\x00';\n    return dest - start;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long encode_string_name_conflict(char a0[2], char *a1) {\n  struct_0 *v1; // rcx, Other Possible Types: unsigned long, unsigned long long\n  char v2;      // dl\n  char v3[2];   // rax, Other Possible Types: unsigned long, unsigned long long\n\n  v1 = a1 + 1;\n  v2 = *(a1);\n  if (!v2) {\n    v3 = a0;\n  } else {\n    v3 = a0;\n    do {\n      if (v2 == 58) {\n        *((char *)v3) = 92;\n        v3 += 1;\n      } else if (v2 == 92) {\n        *((char *)v3) = 92;\n        *((char *)(v3 + 1)) = 92;\n        v3 += 2;\n        continue;\n      } else if (v2 == 10) {\n        *((char *)v3) = 92;\n        *((char *)(v3 + 1)) = 110;\n        v3 += 2;\n        continue;\n      }\n      *((char *)v3) = v2;\n      v3 += 1;\n    } while ((v1 += 1, v2 = v1[1].field_ - 1, v2));\n  }\n  *((char *)v3) = 0;\n  return v3 - (char *)a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:18:16: error: expected ';' at end of\ndeclaration list 18 |     char field_-1; |                ^ |                ;\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:31:12: error: array type 'char[2]' is not\nassignable 31 |         v3 = a0; |         ~~ ^\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:35:12: error: array type 'char[2]' is not\nassignable 35 |         v3 = a0; |         ~~ ^\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:41:20: error: invalid operands to binary\nexpression ('char[2]' and 'int') 41 |                 v3 += 1; | ~~ ^  ~\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:47:20: error: invalid operands to binary\nexpression ('char[2]' and 'int') 47 |                 v3 += 2; | ~~ ^  ~\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:54:20: error: invalid operands to binary\nexpression ('char[2]' and 'int') 54 |                 v3 += 2; | ~~ ^  ~\n/tmp/tmpehwwk3es/encode_string_name_conflict.c:58:16: error: invalid operands to binary\nexpression ('char[2]' and 'int') 58 |             v3 += 1; |             ~~ ^  ~\n7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/DSV.c"}
{"compilable":1,"function":"static inline unsigned int digits(unsigned int n) {\n    return n ? 1 + digits(n / 10) : n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(digits_name_conflict)(unsigned long);\n\nlong long digits_name_conflict(unsigned long a0) {\n  if (!(unsigned int)a0) {\n    return a0;\n  } else if ((unsigned int)a0 <= 9) {\n    return 0 + 1;\n  } else if ((unsigned int)a0 <= 99) {\n    return 1 + 1;\n  } else {\n    return (int)digits_name_conflict(a0 * 274877907 >> 38) + 3;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/redo.c"}
{"compilable":0,"function":"static char **parse_shebang(char *target, char *doscript, char *temp_output) {\n    FILE *fp = fopen(doscript, \"rb\");\n    if (!fp)\n        die_(\"(build.c:137): redo: failed to open %s: %s\\n\", doscript, strerror((*__errno_location())));\n    char *buf = xmalloc(1024);\n    buf[fread(buf, 1, 1023, fp)] = '\\x00';\n    if (ferror(fp))\n        die_(\"(build.c:141): redo: failed to read from %s: %s\\n\", doscript, strerror((*__errno_location())));\n    fclose(fp);\n    char **argv;\n    size_t i = 0;\n    if (buf[0] == '#' && buf[1] == '!') {\n        argv = parsecmd(&buf[2], &i, 5);\n    } else {\n        argv = xmalloc(7 * sizeof(char *));\n        argv[i++] = \"/bin/sh\";\n        argv[i++] = \"-e\";\n    }\n    argv[i++] = doscript;\n    argv[i++] = target;\n    char *__xpg_basename = remove_ext(target);\n    argv[i++] = __xpg_basename;\n    argv[i++] = temp_output;\n    argv[i] = ((void *)0);\n    return argv;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char **parsecmd(char *cmd, size_t *i, size_t keep_free) {\n    size_t argv_len = 16;\n    char **argv = xmalloc(argv_len * sizeof(char *));\n    size_t j = 0;\n    bool prev_space = 1;\n    for (;; ++j) {\n        switch (cmd[j]) {\n          case ' ':\n            cmd[j] = '\\x00';\n            prev_space = 1;\n            break;\n          case '\\n':\n          case '\\r':\n            cmd[j] = '\\x00';\n          case '\\x00':\n            return argv;\n          default:\n            if (!prev_space)\n                break;\n            while (*i + keep_free >= argv_len)\n                {\n                    argv_len *= 2;\n                    argv = xrealloc(argv, argv_len * sizeof(char *));\n                }\n            prev_space = 0;\n            argv[*i] = &cmd[j];\n            ++*i;\n        }\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *xrealpath(const char *path) {\n    char *dirc = xstrdup(path);\n    char *dname = dirname(dirc);\n    char *absdir = realpath(dname, ((void *)0));\n    char *abstarget = ((void *)0);\n    if (absdir)\n        abstarget = concat(3, absdir, \"/\", xbasename(path));\n    free(dirc);\n    free(absdir);\n    return abstarget;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\nchar *(dirname)(char *);\nchar *(realpath)(char *, char *);\nlong long(xbasename)(long long);\nlong long(concat)(long long, ...);\n\nlong long xrealpath_name_conflict(unsigned long long a0) {\n  void *v1;              // rbp\n  unsigned long long v2; // rax\n  unsigned long v4;      // r13, Other Possible Types: unsigned long long\n\n  v1 = xstrdup(a0);\n  v2 = realpath(dirname(v1), NULL);\n  v4 = v2;\n  if (v2) {\n    xbasename(a0);\n    v4 = concat(3);\n  }\n  free(v1);\n  free(v2);\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *get_relpath(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *abstarget = xrealpath(target);\n    if (!abstarget)\n        return ((void *)0);\n    char *path = xstrdup(relpath(abstarget, root));\n    free(abstarget);\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nlong long(xrealpath)(long long);\nlong long(relpath)(long long, long long);\nlong long(xstrdup)(long long);\n\nlong long get_relpath_name_conflict(unsigned long long a0) {\n  unsigned long long v2; // rax\n  unsigned long v4;      // rbp\n\n  v2 = xrealpath(a0);\n  if (!v2)\n    return v2;\n  v4 = xstrdup(relpath(v2, getenv(\"REDO_ROOT\")));\n  free(v2);\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *get_dep_path(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *dep_path;\n    char *reltarget = get_relpath(target);\n    if (!reltarget)\n        return ((void *)0);\n    char *redodir = is_absolute(reltarget) ? \"/.redo/abs/\" : \"/.redo/rel/\";\n    dep_path = concat(3, root, redodir, reltarget);\n    mkpath(dep_path, 493);\n    free(reltarget);\n    return dep_path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nlong long(get_relpath)(long long);\nchar(is_absolute)(long long);\nlong long(concat)(long long, ...);\nlong long(mkpath)(long long, long long);\n\nlong long get_dep_path_name_conflict(unsigned long long a0) {\n  unsigned long long v1; // rbp\n  unsigned long long v2; // rax\n  unsigned long v4;      // rbp\n\n  v1 = getenv(\"REDO_ROOT\");\n  v2 = get_relpath(a0);\n  if (v2) {\n    v4 = concat(3);\n    mkpath(v4, 493);\n    free(v2);\n    return v4;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"int update_target(const char *target, int ident) {\n    dep_info dep = {.target = target, .path = get_dep_path(target)};\n    if (!dep.path)\n        return 1;\n    int retval = handle_ident(&dep, ident);\n    free(dep.path);\n    free(dep.hash);\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_dep_path)(long long);\nlong long(fexists)(long long);\nlong long(dsv_init)(long long, long long);\nlong long(build_target)(long long);\nlong long(die_)(long long, ...);\nlong long(dsv_parse_file)(long long, long long);\nchar *(strerror)(int);\nint(__isoc99_sscanf)(char *, char *, ...);\nlong long(dsv_free)(long long);\nint(fstat)(\n    int, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(xmalloc)(long long);\nlong long(hex_to_sha1)(long long, long long);\nlong long(hash_file)(long long);\nlong long(concat)(long long, ...);\nlong long(write_dep_information)(long long);\nchar *(getenv)(char *);\nlong long(make_abs)(long long, long long);\nlong long(update_target_name_conflict)(char *, unsigned long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern unsigned int DBG_LVL;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long update_target_name_conflict(char *a0, unsigned long a1) {\n  void *v0;    // [bp-0x180]\n  char v1;     // [bp-0x178]\n  char v2;     // [bp-0x170]\n  char v3;     // [bp-0x150]\n  char v4;     // [bp-0x138]\n  char v5;     // [bp-0x110]\n  stat v6;     // [bp-0xf8]\n  char v7;     // [bp-0x90]\n  char v8;     // [bp-0x88]\n  char v9;     // [bp-0x68]\n  int v10;     // [bp-0x60], Other Possible Types: char *\n  void *v11;   // [bp-0x58], Other Possible Types: unsigned long\n  int v12;     // [bp-0x50]\n  void *v13;   // [bp-0x40]\n  void *v15;   // rbx, Other Possible Types: unsigned long long, unsigned long\n  FILE_t *v16; // r12\n  unsigned int v17; // edi\n  FILE_t *v18;      // r14\n  unsigned int v19; // edi\n  void *v20;        // rax\n  FILE_t *v21;      // r15\n  void *v23;        // rbp\n  unsigned int v25; // edi\n  void **v26;       // rbp, Other Possible Types: unsigned long\n\n  *((int128_t *)&v10) = 0;\n  *((int128_t *)&v12) = 0;\n  v13 = 0;\n  v10 = get_dep_path(a0);\n  if (!v10)\n    return 1;\n  if ((unsigned int)a1 == 99) {\n    v16 = fopen(v10, \"rb\");\n    if (v16) {\n      dsv_init(&v1, 4);\n      if ((int)dsv_parse_file(&v1, v16)) {\n        if (DBG_LVL > 1)\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"(build.c:334): %s ood: parsing of dependency file failed\\n\",\n                  (unsigned int)a0);\n        v15 = build_target(&v9);\n        dsv_free(&v1);\n      } else {\n        v18 = fopen(a0, \"rb\");\n        if (!v18) {\n          v19 = *(__errno_location());\n          if (v19 != 2) {\n            strerror(v19);\n            die_(\"(build.c:341): redo: failed to open %s: %s\\n\"); /* do not\n                                                                     return */\n          }\n          if (*((char *)*((long long *)(*((long long *)&v3) + 24))) == 115) {\n            v15 = 1;\n          } else {\n            if (DBG_LVL > 1)\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"(build.c:346): %s ood: target file nonexistent\\n\",\n                      (unsigned int)a0);\n            v15 = build_target(&v9);\n          }\n        } else {\n          if (__isoc99_sscanf(*((long long *)(*((long long *)&v3) + 8)),\n                              \"%lld.%ld\", (unsigned int)&v12,\n                              (unsigned int)&v12) <= 1) {\n            if (DBG_LVL > 1)\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"(build.c:354): %s ood: ctime parsing failed\\n\",\n                      (unsigned int)a0);\n            v15 = build_target(&v9);\n          } else {\n            v15 = fstat(fileno(v18), &v6);\n            if ((unsigned int)v15) {\n              strerror(*(__errno_location()));\n              die_(\"(build.c:359): redo: failed to stat() %s: %s\\n\"); /* do not\n                                                                         return\n                                                                       */\n            }\n            v20 = xmalloc(20);\n            hex_to_sha1(*((long long *)*((long long *)&v3)), v20);\n            v11 = v20;\n            if ((long long)v12 != *((long long *)&v7) ||\n                (long long)(&v12)[8] != *((long long *)&v8)) {\n              *((int128_t *)&v12) = *((int128_t *)&v7);\n              v11 = hash_file(v18);\n              if (!memcmp(v20, v11, 20)) {\n                free(v20);\n                write_dep_information(&v9);\n              } else {\n                if (DBG_LVL > 1)\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"(build.c:368): %s ood: hashes don't match\\n\",\n                          (unsigned int)a0);\n                free(v20);\n                v15 = build_target(&v9);\n                fclose(v18);\n              }\n            }\n            v0 = concat(2);\n            v21 = fopen(v0, \"rb\");\n            if (v21) {\n              dsv_init(&v4, 2);\n              while (!(int)dsv_parse_file(&v4, v21)) {\n                v23 = make_abs(getenv(\"REDO_ROOT\"),\n                               *((long long *)(*((long long *)&v5) + 8)));\n                free(v23);\n                free(*((long long *)*((long long *)&v5)));\n                free(*((long long *)(*((long long *)&v5) + 8)));\n                if ((int)update_target_name_conflict(\n                        v23, *((char *)*((long long *)*((long long *)&v5))))) {\n                  if (DBG_LVL > 1)\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"(build.c:391): %s ood: subtarget(s) ood\\n\",\n                            (unsigned int)a0);\n                  v15 = build_target(&v9);\n                  dsv_free(&v4);\n                }\n              }\n              dsv_free(&v4);\n              fclose(v21);\n            } else {\n              v25 = *(__errno_location());\n              if (v25 != 2) {\n                strerror(v25);\n                die_(\"(build.c:380): redo: failed to open %s: %s\\n\"); /* do not\n                                                                         return\n                                                                       */\n              }\n            }\n            free(v0);\n          }\n          fclose(v18);\n        }\n        if (*((long long *)&v2)) {\n          v26 = 0;\n          do {\n            free(*((long long *)(*((long long *)&v3) + v26 * 8)));\n            v26 += 1;\n          } while (v26 < *((long long *)&v2));\n        }\n        dsv_free(&v1);\n        fclose(v16);\n        free(v10);\n        free((long long)(&v10)[8]);\n        return v15;\n      }\n    } else {\n      v17 = *(__errno_location());\n      if (v17 != 2) {\n        strerror(v17);\n        die_(\n            \"(build.c:329): redo: failed to open %s: %s\\n\"); /* do not return */\n      }\n      if (DBG_LVL > 2)\n        fprintf(stderr @GLIBC_2.2.5,\n                \"(build.c:326): %s ood: dependency record doesn't exist\\n\",\n                (unsigned int)a0);\n      v15 = build_target(&v9);\n    }\n  } else if ((unsigned int)a1 == 101) {\n    v15 = 0;\n    if ((char)fexists(a0)) {\n      v15 = build_target(&v9);\n      free(v10);\n      free((long long)(&v10)[8]);\n      return v15;\n    }\n  } else if ((unsigned int)a1 != 97) {\n    die_(\"(build.c:317): redo: unknown identifier '%c'\\n\"); /* do not return */\n  } else {\n    v15 = build_target(&v9);\n    free(v10);\n    free((long long)(&v10)[8]);\n    return v15;\n  }\n  free(v10);\n  free((long long)(&v10)[8]);\n  return v15;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx_bauvxn/update_target_name_conflict.c:138:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 138 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpx_bauvxn/update_target_name_conflict.c:141:16: error: redeclaration of 'stderr' with a\ndifferent type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka 'struct\n_IO_FILE *') 141 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 141 : 22 : error\n    : expected ';' after top level declarator 141 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 170 : 18 : error : expected expression 170 |\n    *((int128_t *)&v10) = 0;\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 171 : 18 : error : expected expression 171 |\n    *((int128_t *)&v12) = 0;\n| ^/ tmp / tmpx_bauvxn / update_target_name_conflict.c : 185 : 35 : error : expected ')' 185 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:334): %s ood: parsing of dependency file failed\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 185 : 28 : note : to match this '(' 185 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:334): %s ood: parsing of dependency file failed\\n\",\n            (unsigned int)a0);\n| ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 194 : 27 : error : indirection\n                                               requires pointer\n                                             operand('int' invalid) 194 |\n                                             v19 = *(__errno_location());\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 207 : 43 : error : expected ')' 207 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:346): %s ood: target file nonexistent\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 207 : 36 : note : to match this '(' 207 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:346): %s ood: target file nonexistent\\n\",\n            (unsigned int)a0);\n| ^/ tmp / tmpx_bauvxn / update_target_name_conflict.c : 216 : 43 : error : expected ')' 216 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:354): %s ood: ctime parsing failed\\n\", (unsigned int)a0);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 216 : 36 : note : to match this '(' 216 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:354): %s ood: ctime parsing failed\\n\", (unsigned int)a0);\n| ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 224 : 38 : error : indirection\n                                               requires pointer\n                                             operand('int' invalid) 224 |\n                                             strerror(*(__errno_location()));\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 232 : 42 : error : expected expression 232 |\n    *((int128_t *)&v12) = *((int128_t *)&v7);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 232 : 64 : error : expected expression 232 |\n    *((int128_t *)&v12) = *((int128_t *)&v7);\n| ^/ tmp / tmpx_bauvxn / update_target_name_conflict.c : 242 : 51 : error : expected ')' 242 |\n    fprintf(stderr @GLIBC_2.2.5, \"(build.c:368): %s ood: hashes don't match\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 242 : 44 : note : to match this '(' 242 |\n    fprintf(stderr @GLIBC_2.2.5, \"(build.c:368): %s ood: hashes don't match\\n\",\n            (unsigned int)a0);\n| ^/ tmp / tmpx_bauvxn / update_target_name_conflict.c : 262 : 55 : error : expected ')' 262 |\n    fprintf(stderr @GLIBC_2.2.5, \"(build.c:391): %s ood: subtarget(s) ood\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 262 : 48 : note : to match this '(' 262 |\n    fprintf(stderr @GLIBC_2.2.5, \"(build.c:391): %s ood: subtarget(s) ood\\n\",\n            (unsigned int)a0);\n| ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 272 : 35 : error : indirection\n                                               requires pointer\n                                             operand('int' invalid) 272 |\n                                             v25 = *(__errno_location());\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 288 : 72 : error\n    : invalid operands to binary expression('void **' and 'int') 288 |\n    free(*((long long *)(*((long long *)&v3) + v26 * 8)));\n| ~~~^~/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 301 : 19 : error : indirection\n                                               requires pointer\n                                             operand('int' invalid) 301 |\n                                             v17 = *(__errno_location());\n|\n    ^~~~~~~~~~~~~~~~~~~~~/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 308 : 31 : error : expected ')' 308 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:326): %s ood: dependency record doesn't exist\\n\",\n            (unsigned int)a0);\n|\n    ^/ tmp / tmpx_bauvxn /\n        update_target_name_conflict.c : 308 : 24 : note : to match this '(' 308 |\n    fprintf(stderr @GLIBC_2.2.5,\n            \"(build.c:326): %s ood: dependency record doesn't exist\\n\",\n            (unsigned int)a0);\n| ^18 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"bool is_absolute(const char *path) {\n    return path[0] == '/';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar is_absolute_name_conflict(char *a0) { return *(a0) == 47; }\n","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"char *relpath(char *path, char *start) {\n    int i;\n    for (i = 0; path[i] && start[i]; ++i) {\n        if (path[i] != start[i])\n            return path;\n    }\n    if (!path[i] && start[i])\n        return start;\n    if (!path[i] && !start[i])\n        return \".\";\n    if (path[i] == '/')\n        ++i;\n    return &path[i];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long relpath_name_conflict(char a0[2], unsigned long a1) {\n  char v1;          // cl\n  unsigned long v2; // rdx\n  char v3;          // r8b\n  unsigned long v4; // rax\n\n  v1 = a0[0];\n  v2 = 0;\n  if (v1) {\n    do {\n      v3 = *((char *)(a1 + v2));\n      if (!v3) {\n        if (v1)\n          return &a0[v2 + (v1 == 47)];\n        break;\n      }\n      if (v3 != v1)\n        return a0;\n      v2 += 1;\n      v1 = a0[v2];\n    } while (v1);\n  }\n  v4 = (*((char *)(a1 + v2)) ? \".\" : a1);\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"off_t fsize(const char *fn) {\n    struct stat st;\n    if (stat(fn, &st)) {\n        if ((*__errno_location()) != 2)\n            die_(\"(build.c:66): redo: failed to aquire stat() information about %s: %s\\n\", fn, strerror((*__errno_location())));\n        return -1;\n    }\n    return st.st_size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nchar *(strerror)(int);\nlong long(die_)(long long, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long fsize_name_conflict(char *a0) {\n  stat v0;         // [bp-0x98]\n  char v1;         // [bp-0x68]\n  unsigned int v4; // edi\n\n  if (!stat(a0, &v0))\n    return *((long long *)&v1);\n  v4 = *(__errno_location());\n  if (v4 == 2)\n    return -1;\n  strerror(v4);\n  die_(\"(build.c:65): redo: failed to aquire stat() information about %s: \"\n       \"%s\\n\"); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd85y0gae/fsize_name_conflict.c:49:3: error: redefinition of 'stat' as different kind\nof symbol 49 | } stat; |   ^ /tmp/tmpd85y0gae/fsize_name_conflict.c:16:6: note: previous\ndefinition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpd85y0gae/fsize_name_conflict.c:53:5: error: must use 'struct' tag to refer to type\n'stat' 53 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpd85y0gae/fsize_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpd85y0gae/fsize_name_conflict.c:59:10: error: indirection requires pointer operand\n('int' invalid) 59 |     v4 = *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"char *make_abs(char *root, char *path) {\n    if (!is_absolute(path))\n        return concat(3, root, \"/\", path);\n    else\n        return xstrdup(path);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\nlong long(concat)(long long, ...);\n\nlong long make_abs_name_conflict(unsigned long a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (*(a1) != 47) {\n    v1 = concat(3);\n    return v1;\n  }\n  v1 = xstrdup(a1);\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = open(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6afvrr53/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp6afvrr53/file_open_name_conflict.c:23:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 23 |     (unsigned int)v1 = open(a0, a1, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = write(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq8ajt0ga/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return !access(a0, 0); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3jpjmi6y/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\n\nlong long file_read_int_fd_name_conflict(unsigned long long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read(a0, &v0, 20) >= 0) {\n    *(a1) = strtol(&v0, NULL, 10);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_read_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0; // [bp-0x38]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return file_write(a0, &v0, 20) >> 31;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path(unsigned long long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_write_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_read(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_write(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents(char *a0, unsigned long a1,\n                             unsigned long long a2) {\n  stat v0;               // [bp-0xa8]\n  char v1;               // [bp-0x78]\n  unsigned long long v3; // rbp\n  unsigned long v4;      // rbx\n  unsigned long long v5; // r12\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0, a2);\n  if ((unsigned int)v3 < 0)\n    return 0;\n  v5 = *((long long *)&v1);\n  v4 = malloc(v5);\n  if (!v4) {\n    return v4;\n  } else if (file_read(v3, v4, v5) == *((long long *)&v1)) {\n    return v4;\n  } else {\n    free(v4);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqyijezy6/file_read_contents.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpqyijezy6/file_read_contents.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpqyijezy6/file_read_contents.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpqyijezy6/file_read_contents.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpqyijezy6/file_read_contents.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"spi *libsoc_spi_init(uint8_t spidev_device, uint8_t chip_select) {\n    spi *spi_dev;\n    libsoc_spi_debug(__func__, ((void *)0), \"initialising spidev device %d.%d\", spidev_device, chip_select);\n    spi_dev = malloc(sizeof(spi));\n    if (spi_dev == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"failed to allocate memory\");\n        return ((void *)0);\n    }\n    char path[40];\n    spi_dev->spi_dev = spidev_device;\n    spi_dev->chip_select = chip_select;\n    sprintf(path, \"/dev/spidev%d.%d\", spi_dev->spi_dev, spi_dev->chip_select);\n    if (!file_valid(path)) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s not a vaild device\", path);\n        goto error;\n    }\n    spi_dev->fd = file_open(path, 1052672 | 2);\n    if (spi_dev->fd < 0) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s could not be opened\", path);\n        goto error;\n    }\n    return spi_dev;\n  error:\n    free(spi_dev);\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_valid)(long long);\nlong long(file_open)(long long, long long, long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n  char field_5;\n} struct_0;\n\nlong long libsoc_spi_init_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;               // [bp-0x58]\n  unsigned int v2;       // r13d\n  struct_0 *v3;          // rbx, Other Possible Types: unsigned long\n  unsigned long long v5; // rax\n\n  v2 = (char)a0;\n  v3 = malloc(8);\n  if (!v3)\n    return v3;\n  v3->field_4 = a0;\n  v3->field_5 = a1;\n  sprintf(&v0, \"/dev/spidev%d.%d\", v2, (char)a1);\n  if ((int)file_valid(&v0)) {\n    (unsigned int)v5 = file_open(&v0, 1052674, v2);\n    v3->field_0 = v5;\n    if ((unsigned int)v5 >= 0)\n      return v3;\n  }\n  free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdn65ki0y/libsoc_spi_init_name_conflict.c:41:9: error: assignment to cast is illegal,\nlvalue casts are not supported 41 |         (unsigned int)v5 = file_open(&v0,\n1052674, v2); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_bits_per_word(spi *spi, spi_bpw bpw) {\n    if (bpw != BITS_8 && bpw != BITS_16) {\n        libsoc_spi_debug(__func__, spi, \"bits per word was not BITS_8 or BITS_16\", bpw);\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting bits per word to %d\", bpw);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting bits per word\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_set_bits_per_word_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0;  // [bp-0xc]\n  unsigned long v2; // rdx\n\n  v0 = a1;\n  if (!((unsigned int)a1 - 8 & -9)) {\n    v2 = ioctl(*(a0), 1073834755) == -1;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_bpw libsoc_spi_get_bits_per_word(spi *spi) {\n    uint8_t bpw;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading bits per word\");\n        return BPW_ERROR;\n    }\n    switch (bpw) {\n      case 8:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 8\");\n        return BITS_8;\n      case 16:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 16\");\n        return BITS_16;\n      default:\n        libsoc_spi_debug(__func__, spi, \"bits per word not recognised\");\n        return BPW_ERROR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_get_bits_per_word_name_conflict(unsigned int *a0) {\n  char v0; // [bp-0x9]\n  char v4; // dl\n\n  if (ioctl(*(a0), 2147576579) == -1)\n    return 17;\n  v4 = v0;\n  if (v4 != 8)\n    return (v4 != 16) + 16;\n  return 8;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_speed(spi *spi, uint32_t speed) {\n    libsoc_spi_debug(__func__, spi, \"setting speed to %dHz\", speed);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting speed\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_set_speed_name_conflict(unsigned int *a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a1;\n  return ioctl(*(a0), 1074031364) == -1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"uint32_t libsoc_spi_get_speed(spi *spi) {\n    uint32_t speed;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading speed\");\n        return -1;\n    }\n    libsoc_spi_debug(__func__, spi, \"read speed as %dHz\", speed);\n    return speed;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_get_speed_name_conflict(unsigned int *a0) {\n  char v0;          // [bp-0xc]\n  unsigned long v3; // rax\n\n  v3 = (ioctl(*(a0), 2147773188) == -1 ? *((int *)&v0) : 4294967295);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_mode(spi *spi, spi_mode mode) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting mode to %d\", mode);\n    uint8_t new_mode;\n    switch (mode) {\n      case MODE_0:\n        new_mode = (0 | 0);\n        break;\n      case MODE_1:\n        new_mode = (0 | (((1UL)) << (0)));\n        break;\n      case MODE_2:\n        new_mode = ((((1UL)) << (1)) | 0);\n        break;\n      case MODE_3:\n        new_mode = ((((1UL)) << (1)) | (((1UL)) << (0)));\n        break;\n      default:\n        return 1;\n    }\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &new_mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting mode\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_set_mode_name_conflict(unsigned int *a0, unsigned long a1) {\n  char v0; // [bp-0x9]\n  char v2; // al\n\n  if (!a0)\n    return 1;\n  if ((unsigned int)a1 == 2) {\n    v2 = 2;\n  } else if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rsi,\n                                                  0x2 < 64 >, cc_ndep)) {\n    v2 = (unsigned int)a1;\n  } else {\n    if ((unsigned int)a1 != 3)\n      return 1;\n    v2 = 3;\n  }\n  v0 = v2;\n  return ioctl(*(a0), 1073834753) == -1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp4p3buj6/libsoc_spi_set_mode_name_conflict.c:28:20: error: expected expression\n   28 |     else if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rsi,\n0x2<64>, cc_ndep)) |                    ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_mode libsoc_spi_get_mode(spi *spi) {\n    uint8_t mode;\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return MODE_ERROR;\n    }\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading mode\");\n        return MODE_ERROR;\n    }\n    switch (mode) {\n      case (0 | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 0\");\n        return MODE_0;\n      case (0 | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 1\");\n        return MODE_1;\n      case ((((1UL)) << (1)) | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 2\");\n        return MODE_2;\n      case ((((1UL)) << (1)) | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 3\");\n        return MODE_3;\n      default:\n        libsoc_spi_debug(__func__, spi, \"mode not recognised\");\n        return MODE_ERROR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_get_mode_name_conflict(unsigned int *a0) {\n  char v0; // [bp-0x9]\n  char v3; // al\n\n  if (!a0) {\n    return 4;\n  } else if (ioctl(*(a0), 2147576577) == -1) {\n    return 4;\n  } else {\n    v3 = v0;\n    return (v3 == 2 ? (v3 <= 2 ? (v3 != 3) + 3 : v3) : 2);\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_write(spi *spi, uint8_t *tx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing write transfer of %d bytes\", len);\n    if (spi == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed sending message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_write(unsigned int *a0, unsigned long a1,\n                           unsigned long a2) {\n  unsigned long v0; // [bp-0x28]\n  int v1;           // [bp-0x20]\n  unsigned int v2;  // [bp-0x18]\n  void *v3;         // [bp-0x10]\n\n  if (!(a1) || !((unsigned int)a2)) {\n    return 1;\n  } else if (!a0) {\n    return 1;\n  } else {\n    *((int128_t *)&v1) = 0;\n    v3 = 0;\n    v0 = a1;\n    v2 = a2;\n    return ioctl(*(a0), 0x40206b00) <= 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7eni6tzi/libsoc_spi_write.c:35:22: error: expected expression\n   35 |         *((int128_t *)&v1) = 0;\n      |                      ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_read(spi *spi, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing read transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or rx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed recieving message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_read(unsigned int *a0, unsigned long a1,\n                          unsigned long a2) {\n  int v0;           // [bp-0x28]\n  unsigned long v1; // [bp-0x20]\n  int v2;           // [bp-0x18], Other Possible Types: unsigned int\n\n  if (!(a1) || !((unsigned int)a2)) {\n    return 1;\n  } else if (!a0) {\n    return 1;\n  } else {\n    *((int128_t *)&v0) = 0;\n    *((int128_t *)&v2) = 0;\n    v1 = a1;\n    v2 = a2;\n    return ioctl(*(a0), 0x40206b00) <= 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvg4chzot/libsoc_spi_read.c:35:22: error: expected expression\n   35 |         *((int128_t *)&v0) = 0;\n      |                      ^\n/tmp/tmpvg4chzot/libsoc_spi_read.c:36:22: error: expected expression\n   36 |         *((int128_t *)&v2) = 0;\n      |                      ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_rw(spi *spi, uint8_t *tx, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing duplex rw transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi | rx | tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed duplex transfer\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_spi_rw(unsigned int *a0, unsigned long a1, unsigned long a2,\n                        unsigned long a3) {\n  unsigned long v0; // [bp-0x28]\n  unsigned long v1; // [bp-0x20]\n  unsigned int v2;  // [bp-0x18]\n  void *v3;         // [bp-0x14]\n  unsigned int v4;  // [bp-0xc]\n\n  *((char *)&a0) = !a1;\n  if (!(a2) || !(!(char)a0) || !((unsigned int)a3)) {\n    return 1;\n  } else if (!a0) {\n    return 1;\n  } else {\n    v3 = 0;\n    v4 = 0;\n    v0 = a1;\n    v1 = a2;\n    v2 = a3;\n    return ioctl(*(a0), 0x40206b00) <= 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_free(spi *spi) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"freeing spi device\");\n    if (file_close(spi->fd) < 0)\n        return 1;\n    free(spi);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_close)(long long);\n\nlong long libsoc_spi_free_name_conflict(unsigned int *a0) {\n  unsigned long v0; // [bp-0x8]\n  unsigned long v2; // rbx\n\n  if (!a0)\n    return 1;\n  v0 = v2;\n  if ((int)file_close(*(a0)) >= 0) {\n    free(a0);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"uint8_t read_status_register(spi *spi_dev) {\n    printf(\"Reading STATUS register\\n\");\n    tx[0] = 5;\n    tx[1] = 0;\n    rx[0] = 0;\n    rx[1] = 0;\n    libsoc_spi_rw(spi_dev, tx, rx, 2);\n    printf(\"STATUS is 0x%02x\\n\", rx[1]);\n    return rx[1];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_rw)(long long, long long, long long, long long);\n\nextern char g_4040e1;\nextern char g_404121;\nextern char rx;\nextern char tx;\n\nlong long read_status_register_name_conflict(unsigned long long a0) {\n  puts(\"Reading STATUS register\");\n  tx = 5;\n  g_404121 = 0;\n  rx = 0;\n  g_4040e1 = 0;\n  libsoc_spi_rw(a0, &tx, &rx, 2);\n  printf(\"STATUS is 0x%02x\\n\", g_4040e1);\n  return g_4040e1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int write_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Writing to page %d\\n\", page_address);\n    page_address = page_address * 32;\n    tx[0] = 2;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    if (len > 32) {\n        printf(\"Page size is 32 bytes\\n\");\n        return 1;\n    }\n    int i;\n    for (i = 0; i < len; i++) {\n        tx[(i + 3)] = data[i];\n    }\n    libsoc_spi_write(spi_dev, tx, (len + 3));\n    int status;\n    do {\n        status = read_status_register(spi_dev);\n        if (status & 1) {\n            printf(\"Write in progress...\\n\");\n        } else {\n            printf(\"Write finished...\\n\");\n        }\n    } while (status & 1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_write)(long long, long long, long long);\nlong long(read_status_register)(long long);\n\nextern char g_404121;\nextern char g_404122;\nextern char g_404123;\nextern char tx;\n\nlong long write_page(unsigned long long a0, unsigned long a1, unsigned long a2,\n                     unsigned long a3) {\n  char v1[4210980]; // rax, Other Possible Types: unsigned long\n\n  tx = 2;\n  g_404121 = 0;\n  g_404122 = (char)a1 * 32;\n  if ((unsigned int)a3 > 32) {\n    puts(\"Page size is 32 bytes\");\n    return 1;\n  }\n  v1 = 0;\n  if ((unsigned int)a3 > 0) {\n    do {\n      (&g_404123)[v1] = *((char *)(a2 + v1));\n      v1 += 1;\n    } while (v1 != a3);\n  }\n  libsoc_spi_write(a0, &tx, a3 + 3);\n  while (((char)read_status_register(a0) & 1)) {\n    puts(\"Write in progress...\");\n  }\n  puts(\"Write finished...\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvmo6zo7r/write_page.c:36:8: error: array type 'char[4210980]' is not\nassignable 36 |     v1 = 0; |     ~~ ^ /tmp/tmpvmo6zo7r/write_page.c:41:24:\nerror: array subscript is not an integer 41 |             (&g_404123)[v1] =\n*((char *)(a2 + v1)); |                        ^~~\n/tmp/tmpvmo6zo7r/write_page.c:42:16: error: invalid operands to binary\nexpression ('char[4210980]' and 'int') 42 |             v1 += 1; | ~~ ^  ~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int read_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Reading page address %d\\n\", page_address);\n    tx[0] = 3;\n    page_address = page_address * 32;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    libsoc_spi_rw(spi_dev, tx, rx, (len + 3));\n    int i;\n    for (i = 0; i < len; i++) {\n        data[i] = rx[(i + 3)];\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_rw)(long long, long long, long long, long long);\n\nextern char g_4040e3;\nextern char g_404121;\nextern char g_404122;\nextern unsigned long long rx;\nextern char tx;\n\nlong long read_page(unsigned long long a0, unsigned long a1, unsigned long a2,\n                    unsigned long a3) {\n  char v1[4210916]; // rax, Other Possible Types: unsigned long\n\n  tx = 3;\n  g_404121 = 0;\n  g_404122 = (char)a1 * 32;\n  libsoc_spi_rw(a0, &tx, &rx, a3 + 3);\n  if ((unsigned int)a3 <= 0)\n    return 0;\n  v1 = 0;\n  do {\n    *((char *)(a2 + v1)) = (&g_4040e3)[v1];\n    v1 += 1;\n  } while (v1 != a3);\n  return 0;\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4rtjl50w/read_page.c:34:8: error: array type 'char[4210916]' is not\nassignable 34 |     v1 = 0; |     ~~ ^ /tmp/tmp4rtjl50w/read_page.c:37:43:\nerror: array subscript is not an integer 37 |         *((char *)(a2 + v1)) =\n(&g_4040e3)[v1]; |                                           ^~~\n/tmp/tmp4rtjl50w/read_page.c:38:12: error: invalid operands to binary expression\n('char[4210916]' and 'int') 38 |         v1 += 1; |         ~~ ^  ~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int set_write_enable(spi *spi_dev) {\n    tx[0] = 6;\n    printf(\"Setting write enable bit\\n\");\n    libsoc_spi_write(spi_dev, tx, 1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(libsoc_spi_write)(long long, long long, long long);\n\nextern char tx;\n\nlong long set_write_enable_name_conflict(unsigned long long a0) {\n  tx = 6;\n  puts(\"Setting write enable bit\");\n  libsoc_spi_write(a0, &tx, 1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = open(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvkrq291m/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpvkrq291m/file_open_name_conflict.c:23:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 23 |     (unsigned int)v1 = open(a0, a1, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = write(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnf9ue7d1/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return !access(a0, 0); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdr1gya7e/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\n\nlong long file_read_int_fd_name_conflict(unsigned long long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read(a0, &v0, 20) >= 0) {\n    *(a1) = strtol(&v0, NULL, 10);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_read_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0; // [bp-0x38]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return file_write(a0, &v0, 20) >> 31;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path(unsigned long long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_write_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_read(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_write(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents(char *a0, unsigned long a1,\n                             unsigned long long a2) {\n  stat v0;               // [bp-0xa8]\n  char v1;               // [bp-0x78]\n  unsigned long long v3; // rbp\n  unsigned long v4;      // rbx\n  unsigned long long v5; // r12\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0, a2);\n  if ((unsigned int)v3 < 0)\n    return 0;\n  v5 = *((long long *)&v1);\n  v4 = malloc(v5);\n  if (!v4) {\n    return v4;\n  } else if (file_read(v3, v4, v5) == *((long long *)&v1)) {\n    return v4;\n  } else {\n    free(v4);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnivswojp/file_read_contents.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpnivswojp/file_read_contents.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpnivswojp/file_read_contents.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpnivswojp/file_read_contents.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpnivswojp/file_read_contents.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = open(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz4fu5kx3/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpz4fu5kx3/file_open_name_conflict.c:23:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 23 |     (unsigned int)v1 = open(a0, a1, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  unsigned long long v1; // rdx, Other Possible Types: unsigned long\n\n  v1 = write(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprjb1bkuw/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return !access(a0, 0); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1lc3gmbq/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\n\nlong long file_read_int_fd_name_conflict(unsigned long long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read(a0, &v0, 20) >= 0) {\n    *(a1) = strtol(&v0, NULL, 10);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_read_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0; // [bp-0x38]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return file_write(a0, &v0, 20) >> 31;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path(unsigned long long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_write_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_read(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_write(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents(char *a0, unsigned long a1,\n                             unsigned long long a2) {\n  stat v0;               // [bp-0xa8]\n  char v1;               // [bp-0x78]\n  unsigned long long v3; // rbp\n  unsigned long v4;      // rbx\n  unsigned long long v5; // r12\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0, a2);\n  if ((unsigned int)v3 < 0)\n    return 0;\n  v5 = *((long long *)&v1);\n  v4 = malloc(v5);\n  if (!v4) {\n    return v4;\n  } else if (file_read(v3, v4, v5) == *((long long *)&v1)) {\n    return v4;\n  } else {\n    free(v4);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp6oa169y/file_read_contents.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpp6oa169y/file_read_contents.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpp6oa169y/file_read_contents.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpp6oa169y/file_read_contents.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpp6oa169y/file_read_contents.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = open(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptnht3kqv/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmptnht3kqv/file_open_name_conflict.c:23:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 23 |     (unsigned int)v1 = open(a0, a1, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  unsigned long long v1; // rdx, Other Possible Types: unsigned long\n\n  v1 = write(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp80qv_7ah/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return !access(a0, 0); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgsc55i4q/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\n\nlong long file_read_int_fd_name_conflict(unsigned long long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read(a0, &v0, 20) >= 0) {\n    *(a1) = strtol(&v0, NULL, 10);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_read_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0; // [bp-0x38]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return file_write(a0, &v0, 20) >> 31;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path(unsigned long long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_write_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_read(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_write(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents(char *a0, unsigned long a1,\n                             unsigned long long a2) {\n  stat v0;               // [bp-0xa8]\n  char v1;               // [bp-0x78]\n  unsigned long long v3; // rbp\n  unsigned long v4;      // rbx\n  unsigned long long v5; // r12\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0, a2);\n  if ((unsigned int)v3 < 0)\n    return 0;\n  v5 = *((long long *)&v1);\n  v4 = malloc(v5);\n  if (!v4) {\n    return v4;\n  } else if (file_read(v3, v4, v5) == *((long long *)&v1)) {\n    return v4;\n  } else {\n    free(v4);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0toexjz9/file_read_contents.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp0toexjz9/file_read_contents.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmp0toexjz9/file_read_contents.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmp0toexjz9/file_read_contents.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmp0toexjz9/file_read_contents.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"pwm *libsoc_pwm_request(unsigned int chip, unsigned int pwm_num, shared_mode mode) {\n    pwm *new_pwm;\n    char tmp_str[256];\n    int shared = 0;\n    if (mode != LS_PWM_SHARED && mode != LS_PWM_GREEDY && mode != LS_PWM_WEAK) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"mode was not set, or invalid, setting mode to LS_PWM_SHARED\");\n        mode = LS_PWM_SHARED;\n    }\n    libsoc_pwm_debug(__func__, chip, pwm_num, \"requested PWM\");\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    if (file_valid(tmp_str)) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"PWM already exported\");\n        switch (mode) {\n          case LS_PWM_WEAK:\n            {\n                return ((void *)0);\n            }\n          case LS_PWM_SHARED:\n            {\n                shared = 1;\n                break;\n            }\n          default:\n            {\n                break;\n            }\n        }\n    } else {\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/export\", chip);\n        if (file_write_int_path(tmp_str, pwm_num) == 1) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"write failed\");\n            return ((void *)0);\n        }\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n        if (!file_valid(tmp_str)) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"failed to export PWM\");\n            perror(\"libsoc-pwm-debug\");\n            return ((void *)0);\n        }\n    }\n    new_pwm = malloc(sizeof(pwm));\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    new_pwm->enable_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", chip, pwm_num);\n    new_pwm->period_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/duty_cycle\", chip, pwm_num);\n    new_pwm->duty_fd = file_open(tmp_str, 1052672 | 2);\n    if (new_pwm->enable_fd < 0 || new_pwm->period_fd < 0 || new_pwm->duty_fd < 0) {\n        free(new_pwm);\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"Failed to open pwm sysfs file: %d\", new_pwm->enable_fd);\n        return ((void *)0);\n    }\n    new_pwm->chip = chip;\n    new_pwm->pwm = pwm_num;\n    new_pwm->shared = shared;\n    return new_pwm;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_valid)(long long);\nlong long(file_write_int_path)(long long, long long, long long);\nlong long(file_open)(long long, long long, long long);\nvoid(perror)(char *);\n\nlong long libsoc_pwm_request(unsigned long a0, unsigned long long a1,\n                             unsigned long a2) {\n  char v0;               // [bp-0x128]\n  unsigned long v3;      // rbx\n  unsigned long long v8; // rax\n\n  if ((unsigned int)a2 > 2) {\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n            (unsigned int)a1);\n  } else {\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n            (unsigned int)a1);\n    if ((int)file_valid(&v0) && (unsigned int)a2 && (unsigned int)a2 == 2)\n      return 0;\n  }\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/export\", (unsigned int)a0);\n  if ((int)file_write_int_path(&v0, a1, (unsigned int)a0) == 1)\n    return 0;\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n          (unsigned int)a1);\n  if (!(int)file_valid(&v0)) {\n    perror(\"libsoc-pwm-debug\");\n    return 0;\n  }\n  v3 = malloc(24);\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", (unsigned int)a0,\n          (unsigned int)a1);\n  *((int *)(v3 + 8)) = file_open(&v0, 1052674, (unsigned int)a0);\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", (unsigned int)a0,\n          (unsigned int)a1);\n  *((int *)(v3 + 16)) = file_open(&v0, 1052674, (unsigned int)a0);\n  sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/duty_cycle\", (unsigned int)a0,\n          (unsigned int)a1);\n  (unsigned int)v8 = file_open(&v0, 1052674, (unsigned int)a0);\n  *((unsigned int *)(v3 + 12)) = v8;\n  if (*((int *)(v3 + 8)) >= 0 &&\n      ((unsigned int)v8 | *((int *)(v3 + 16))) >= 0) {\n    *((unsigned int *)v3) = a0;\n    *((unsigned int *)(v3 + 4)) = a1;\n    *((int *)(v3 + 20)) = 0;\n    return v3;\n  }\n  free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjtmnnmkd/libsoc_pwm_request.c:19:7: error: conflicting types for\n'perror' 19 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpjtmnnmkd/libsoc_pwm_request.c:52:5: error: assignment to cast is\nillegal, lvalue casts are not supported 52 |     (unsigned int)v8 =\nfile_open(&v0, 1052674, (unsigned int)a0); |     ^~~~~~~~~~~~~~~~ ~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_free(pwm *pwm) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing pwm\");\n    if (file_close(pwm->enable_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->period_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->duty_fd) < 0) {\n        return 1;\n    }\n    if (pwm->shared == 1) {\n        free(pwm);\n        return 0;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/unexport\", pwm->chip);\n    file_write_int_path(path, pwm->pwm);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d\", pwm->chip, pwm->pwm);\n    if (file_valid(path)) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing failed\");\n        return 1;\n    }\n    free(pwm);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_close)(long long);\nlong long(file_write_int_path)(long long, long long, long long);\nlong long(file_valid)(long long);\n\nlong long libsoc_pwm_free_name_conflict(unsigned int a0[6]) {\n  char v0;            // [bp-0x118]\n  unsigned long v2;   // rbp\n  unsigned int v3[6]; // rbx\n  unsigned int v5;    // edx\n\n  if (!a0)\n    return 1;\n  v3 = a0;\n  if ((int)file_close(a0[2]) < 0) {\n    return 1;\n  } else if ((int)file_close(v3[4]) < 0) {\n    return 1;\n  } else if ((int)file_close(v3[3]) < 0) {\n    return 1;\n  } else if (v3[5] != 1) {\n    v5 = v3[0];\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/unexport\", v5);\n    file_write_int_path(&v0, v3[1], *((unsigned long long *)&v5));\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d\", v3[0], v3[1]);\n    v2 = file_valid(&v0);\n    if ((unsigned int)v2)\n      return 1;\n    free(v3);\n    return v2;\n  } else {\n    free(v3);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkzpxjkfq/libsoc_pwm_free_name_conflict.c:29:8: error: array type 'unsigned int[6]' is\nnot assignable 29 |     v3 = a0; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_enabled(pwm *pwm, pwm_enabled enabled) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (enabled != ENABLED && enabled != DISABLED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting enabled to %s\", pwm_enabled_strings[enabled]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_enabled_strings[enabled], 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write_str)(long long, long long, long long);\n\nextern char pwm_enabled_strings;\n\nlong long libsoc_pwm_set_enabled_name_conflict(unsigned int a0[2], unsigned long a1) {\n  char v0;          // [bp-0x118]\n  unsigned long v1; // [bp-0x10]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v4; // rbx\n\n  if (!a0)\n    return 1;\n  *((int *)&v2) = rbp;\n  v1 = v4;\n  if ((unsigned int)a1 <= 1) {\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", a0[0], a0[1]);\n    return file_write_str(&v0, 4210848 + 0x100 * a1, 1);\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"pwm_enabled libsoc_pwm_get_enabled(pwm *pwm) {\n    int val;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return ENABLED_ERROR;\n    }\n    if (file_read_int_fd(pwm->enable_fd, &val) == 1) {\n        return ENABLED_ERROR;\n    }\n    if (val == 1) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as enabled\");\n        return ENABLED;\n    } else if (val == 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as disabled\");\n        return DISABLED;\n    } else {\n        return ENABLED_ERROR;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read_int_fd)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  unsigned int field_8;\n} struct_0;\n\nlong long libsoc_pwm_get_enabled_name_conflict(struct_0 *a0) {\n  char v0;          // [bp-0xc]\n  unsigned long v3; // rax\n\n  if (!a0) {\n    return 4294967295;\n  } else if ((int)file_read_int_fd(a0->field_8, &v0) == 1) {\n    return 4294967295;\n  } else {\n    v3 = *((int *)&v0);\n    if ((unsigned int)v3 != 1) {\n      v3 = -(0 < (unsigned int)v3);\n      return v3;\n    }\n    return v3;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_period(pwm *pwm, unsigned int period) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting period to %d\", period);\n    return file_write_int_fd(pwm->period_fd, period);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write_int_fd)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long libsoc_pwm_set_period_name_conflict(struct_0 *a0, unsigned long long a1) {\n  if (a0)\n    return file_write_int_fd(a0->field_10, a1);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_duty_cycle(pwm *pwm, unsigned int duty) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting duty to %d\", duty);\n    return file_write_int_fd(pwm->duty_fd, duty);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write_int_fd)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[12];\n  unsigned int field_c;\n} struct_0;\n\nlong long libsoc_pwm_set_duty_cycle_name_conflict(struct_0 *a0, unsigned long long a1) {\n  if (a0)\n    return file_write_int_fd(a0->field_c, a1);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_period(pwm *pwm) {\n    int period = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->period_fd, &period);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got period as %d\", period);\n    return period;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read_int_fd)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long libsoc_pwm_get_period_name_conflict(struct_0 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = -1;\n  if (!a0)\n    return 4294967295;\n  file_read_int_fd(a0->field_10, &v0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_duty_cycle(pwm *pwm) {\n    int duty = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->duty_fd, &duty);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got duty as %d\", duty);\n    return duty;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read_int_fd)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[12];\n  unsigned int field_c;\n} struct_0;\n\nlong long libsoc_pwm_get_duty_cycle_name_conflict(struct_0 *a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = -1;\n  if (!a0)\n    return 4294967295;\n  file_read_int_fd(a0->field_c, &v0);\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_polarity(pwm *pwm, pwm_polarity polarity) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (polarity != NORMAL && polarity != INVERSED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting polarity to %s\", pwm_polarity_strings[polarity]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_polarity_strings[polarity], 256);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write_str)(long long, long long, long long);\n\nextern char pwm_polarity_strings;\n\nlong long libsoc_pwm_set_polarity_name_conflict(unsigned int a0[2], unsigned long a1) {\n  char v0;          // [bp-0x118]\n  unsigned long v1; // [bp-0x10]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v4; // rbx\n\n  if (!a0)\n    return 1;\n  *((int *)&v2) = rbp;\n  v1 = v4;\n  if ((unsigned int)a1 <= 1) {\n    sprintf(&v0, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", a0[0], a0[1]);\n    return file_write_str(&v0, 4211360 + 0x100 * a1, 0x100);\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_polarity(pwm *pwm) {\n    int polarity;\n    char path[256];\n    char tmp_str[1];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    if (file_read_str(path, tmp_str, 1) == 1) {\n        return POLARITY_ERROR;\n    }\n    if (strncmp(tmp_str, \"i\", 1) == 0) {\n        polarity = INVERSED;\n    } else if (strncmp(tmp_str, \"n\", 1) == 0) {\n        polarity = NORMAL;\n    } else {\n        polarity = POLARITY_ERROR;\n    }\n    if (polarity > 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got polarity as %s\", pwm_polarity_strings[polarity]);\n    } else {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"getting polarity failed\");\n    }\n    return polarity;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read_str)(long long, long long, long long);\n\nlong long libsoc_pwm_get_polarity_name_conflict(unsigned int a0[2]) {\n  char v0;          // [bp-0x109]\n  char v1;          // [bp-0x108]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v4; // rbx\n  char v6;          // dl\n\n  if (!a0)\n    return 1;\n  v2 = v4;\n  sprintf(&v1, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", a0[0], a0[1]);\n  if ((int)file_read_str(&v1, &v0, 1) == 1)\n    return 4294967295;\n  v6 = v0;\n  if (v6 != 105)\n    return -(v6 != 110);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long file_open_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = open(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_l1jrxkq/file_open_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp_l1jrxkq/file_open_name_conflict.c:23:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 23 |     (unsigned int)v1 = open(a0, a1, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(write)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nlong long file_write_name_conflict(unsigned long a0, void *a1, unsigned int a2) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = write(a0, a1, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"libsoc-file-debug\");\n    return 4294967295;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmperw9s_q9/file_write_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long file_valid_name_conflict(char *a0) { return !access(a0, 0); }\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nvoid(perror)(char *);\n\nlong long file_close_name_conflict(unsigned long a0) {\n  if (close(a0) >= 0)\n    return 0;\n  perror(\"libsoc-file-debug\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2kgk7m25/file_close_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_read)(long long, long long, long long);\n\nlong long file_read_int_fd_name_conflict(unsigned long long a0, unsigned int *a1) {\n  char v0; // [bp-0x28]\n\n  if ((int)file_read(a0, &v0, 20) >= 0) {\n    *(a1) = strtol(&v0, NULL, 10);\n    return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_int_path(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_read_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_write)(long long, long long, long long);\n\nlong long file_write_int_fd_name_conflict(unsigned long long a0, unsigned long a1) {\n  char v0; // [bp-0x38]\n\n  sprintf(&v0, \"%d\", (unsigned int)a1);\n  return file_write(a0, &v0, 20) >> 31;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write_int_fd)(long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_int_path(unsigned long long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 >= 0) {\n    *((char *)&v2) = (int)file_write_int_fd(v1, a1) == 1;\n    v2 = (unsigned int)v2 | (int)file_close(v1) / 0x80000000;\n    return v2;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_read)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_read_str(unsigned long long a0, unsigned long long a1,\n                        unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 0x101000, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_read(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(file_open)(long long, long long, long long);\nlong long(file_write)(long long, long long, long long);\nlong long(file_close)(long long);\n\nlong long file_write_str(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2) {\n  unsigned long long v1; // rbx\n\n  v1 = file_open(a0, 1052673, a2);\n  if ((unsigned int)v1 < 0) {\n    return 1;\n  } else if ((int)file_write(v1, a1, a2) < 0) {\n    return 1;\n  } else {\n    return file_close(v1) >> 31;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(file_open)(long long, long long, long long);\nvoid(perror)(char *);\nlong long(file_read)(long long, long long, long long);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long file_read_contents(char *a0, unsigned long a1,\n                             unsigned long long a2) {\n  stat v0;               // [bp-0xa8]\n  char v1;               // [bp-0x78]\n  unsigned long long v3; // rbp\n  unsigned long v4;      // rbx\n  unsigned long long v5; // r12\n\n  if (stat(a0, &v0)) {\n    perror(\"libsoc-file-debug\");\n    return 0;\n  }\n  v3 = file_open(a0, 0, a2);\n  if ((unsigned int)v3 < 0)\n    return 0;\n  v5 = *((long long *)&v1);\n  v4 = malloc(v5);\n  if (!v4) {\n    return v4;\n  } else if (file_read(v3, v4, v5) == *((long long *)&v1)) {\n    return v4;\n  } else {\n    free(v4);\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpisn06ujd/file_read_contents.c:29:7: error: conflicting types for\n'perror' 29 | void (perror)(char *); |       ^ /usr/include/stdio.h:804:13:\nnote: previous declaration is here 804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpisn06ujd/file_read_contents.c:50:3: error: redefinition of 'stat' as\ndifferent kind of symbol 50 | } stat; |   ^\n/tmp/tmpisn06ujd/file_read_contents.c:16:6: note: previous definition is here\n   16 | int (stat)(char *, struct stat {\n      |      ^\n/tmp/tmpisn06ujd/file_read_contents.c:54:5: error: must use 'struct' tag to\nrefer to type 'stat' 54 |     stat v0;  // [bp-0xa8] |     ^ |     struct\n/tmp/tmpisn06ujd/file_read_contents.c:16:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 16 | int (stat)(char *, struct stat { | ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libsoc_get_debug_name_conflict() {\n  return puts(\"libsoc-debug: warning debug support missing!\");\n}\n","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"static int wait_for_process(pid_t pid) {\n    int rv = 70;\n    int stats = 0;\n    int i = 0;\n    struct sigaction sig_handler;\n    sig_handler.__sigaction_handler.sa_handler = caught_signal;\n    sig_handler.sa_flags = 0;\n    sigaction(14, &sig_handler, ((void *)0));\n    sigaction(1, &sig_handler, ((void *)0));\n    sigaction(2, &sig_handler, ((void *)0));\n    sigaction(15, &sig_handler, ((void *)0));\n    sigaction(13, &sig_handler, ((void *)0));\n    for (i = 0; ; i++) {\n        pid_t p = waitpid(pid, &stats, 0);\n        if (p == pid) {\n            rv = (((stats) & 127) == 0) ? (((stats) & 65280) >> 8) : (128 | ((stats) & 127));\n            break;\n        } else {\n            int sig = 0;\n            switch (i) {\n              case 0:\n                sig = caught > 0 ? caught : 15;\n                if (caught == 14) {\n                    fprintf(stderr, \"Timeout.. killing the process\\n\");\n                }\n                break;\n              case 1:\n                sig = 15;\n                break;\n              default:\n                sig = 9;\n                break;\n            }\n            if (kill(pid, sig) < 0) {\n                perror(\"lost child when trying to kill\");\n            }\n            alarm(5);\n        }\n    }\n    return rv;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/shelsonjava_memcached/timedrun.c"}
{"compilable":1,"function":"unsigned int hamdist(unsigned int x, unsigned int y) {\n    unsigned int dist = 0, val = x ^ y;\n    while (val)\n        {\n            ++dist;\n            val &= val - 1;\n        }\n    return dist;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hamdist_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v1; // eax\n\n  v1 = (unsigned int)a0 ^ (unsigned int)a1;\n  if ((unsigned int)a0 == (unsigned int)a1)\n    return 0;\n  do {\n    v1 &= v1 - 1;\n  } while (v1);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Hamming_Distance/C/Arpan-Patel/HammingDistance.c"}
{"compilable":1,"function":"int partition(int a[], int lo, int hi) {\n    int i = lo, j = hi + 1, temp;\n    while (1)\n        {\n            while (a[++i] < a[lo])\n                {\n                    if (i == hi)\n                        break;\n                }\n            ;\n            while (a[lo] < a[--j])\n                {\n                    if (j == lo)\n                        break;\n                }\n            if (i >= j)\n                break;\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    temp = a[lo];\n    a[lo] = a[j];\n    a[j] = temp;\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long partition_name_conflict(unsigned int *a0, unsigned long a1, unsigned long a2) {\n  struct struct_0 **v3; // r12\n  unsigned int v4;      // edx\n  unsigned int *v5;     // r8\n  unsigned int v6;      // esi\n  unsigned int *v7;     // rax, Other Possible Types: unsigned long\n  unsigned long v8;     // rcx, Other Possible Types: unsigned long long\n  unsigned long v9;     // r10\n\n  v8 = a2 + 1;\n  v3 = &a0[a1];\n  v9 = a1 + 1;\n  while (true) {\n    v4 = *((int *)(a0 + v9 * 4));\n    a0 = *((int *)v3);\n    if (!((unsigned int)a2 != (unsigned int)v9) || !(v4 < a0)) {\n      v7 = a0 + v8 * 4 - 4;\n      do {\n        v8 = (unsigned int)v8 - 1;\n        v5 = v7;\n        v6 = *((int *)v7);\n        v7 -= 4;\n      } while ((unsigned int)a1 != (unsigned int)v8 && a0 < v6);\n      if ((unsigned int)v8 <= (unsigned int)v9)\n        break;\n      *((unsigned int *)(a0 + v9 * 4)) = v6;\n      *(v5) = v4;\n    }\n    v9 += 1;\n  }\n  *((unsigned int *)v3) = v6;\n  *(v5) = a0;\n  return v8;\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Quick_Sort/C/jonathanlebron/quick_sort.c"}
{"compilable":0,"function":"int parent(int i) {\n    return (int)((i + 1) / 2) - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parent_name_conflict(unsigned long a0) {\n  return (unsigned int)(((unsigned int)a0 + 1 >> 31) + (unsigned int)a0 + 1 >>\n                        1) -\n         1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int left(int i) {\n    return i * 2 + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long left_name_conflict(unsigned long a0) { return a0 * 2 + 1; }\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int right(int i) {\n    return 2 * i + 2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long right_name_conflict(unsigned long a0) { return a0 * 2 + 2; }\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int test_sorted_array(int *array, int size) {\n    int i;\n    for (i = 0; i < size - 2; i++) {\n        if (array[i] > array[i + 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test_sorted_array_name_conflict(unsigned int a0[2], unsigned long a1) {\n  unsigned int v1[2]; // rax, Other Possible Types: unsigned long\n\n  if ((unsigned int)a1 <= 2)\n    return 1;\n  v1 = a0;\n  while (*((int *)v1) <= *((int *)(v1 + 4))) {\n    v1 += 4;\n    if (v1 == &a0[1 + 1 + a1 + 1])\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp97b_c1dm/test_sorted_array_name_conflict.c:23:8: error: array type 'unsigned int[2]'\nis not assignable 23 |     v1 = a0; |     ~~ ^\n/tmp/tmp97b_c1dm/test_sorted_array_name_conflict.c:26:12: error: invalid operands to binary\nexpression ('unsigned int[2]' and 'int') 26 |         v1 += 4; |         ~~ ^  ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int BinarySearch(TypeArray a[], TypeArray key, int first, int last) {\n    if (first > last)\n        return -1;\n    ;\n    int length = last - first + 1;\n    int midIndex = (first + last) / 2;\n    TypeArray midValue = a[midIndex];\n    if (key > midValue) {\n        return BinarySearch(a, key, midIndex + 1, last);\n    } else if (key < midValue) {\n        return BinarySearch(a, key, first, midIndex - 1);\n    } else\n        return midIndex;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(BinarySearch)(unsigned int *, unsigned long, unsigned long long,\n                        unsigned long long);\n\nlong long BinarySearch(unsigned int *a0, unsigned long a1,\n                       unsigned long long a2, unsigned long long a3) {\n  unsigned int *v1;      // r8\n  unsigned long long v2; // rdi\n  unsigned long v3;      // rsi\n  unsigned long v4;      // rax\n  unsigned int v5;       // r9d\n\n  if ((unsigned int)a2 > (unsigned int)a3)\n    return 4294967295;\n  v1 = a0;\n  v2 = a1;\n  v3 = (a2 + a3 >> 31) + a2 + a3 >> 1;\n  v5 = v1[v3];\n  if (v5 < (unsigned int)v2) {\n    v4 = BinarySearch(v1, v2, v3 + 1, a3);\n    return v4;\n  } else if (v5 <= (unsigned int)v2) {\n    return v3;\n  } else {\n    v4 = BinarySearch(v1, v2, a2, v3 - 1);\n    return v4;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Binary_Search/C/mariolamacchia/binarysearch.c"}
{"compilable":0,"function":"int gcd_division(int a, int b) {\n    while (b != 0)\n        {\n            int tmp = a;\n            a = b;\n            b = tmp % b;\n        }\n    return a;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long gcd_division_name_conflict(unsigned long a0, unsigned int a1) {\n  unsigned int v1;       // eax\n  unsigned long long v3; // rdx\n\n  v1 = a0;\n  if (!a1)\n    return a0;\n  do {\n    v3 = (v1 >> 31 CONCAT v1) / m(unsigned int) a1 >> 32;\n    a1 = v3;\n    v1 = v3;\n  } while ((unsigned int)v3);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpelwoc4og/gcd_division_name_conflict.c:27:24: error: expected ')'\n   27 |         v3 = (v1 >> 31 CONCAT v1) /m (unsigned int)a1 >> 32;\n      |                        ^\n/tmp/tmpelwoc4og/gcd_division_name_conflict.c:27:14: note: to match this '('\n   27 |         v3 = (v1 >> 31 CONCAT v1) /m (unsigned int)a1 >> 32;\n      |              ^\n/tmp/tmpelwoc4og/gcd_division_name_conflict.c:27:39: error: expected expression\n   27 |         v3 = (v1 >> 31 CONCAT v1) /m (unsigned int)a1 >> 32;\n      |                                       ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"int gcd_substraction(int a, int b) {\n    while (a != b)\n        {\n            if (a > b) {\n                a = a - b;\n            } else {\n                b = b - a;\n            }\n        }\n    return a;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long gcd_substraction_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if ((unsigned int)a0 == (unsigned int)a1)\n    return a1;\n  do {\n    if ((unsigned int)a0 > (unsigned int)v1)\n      a0 -= v1;\n    else\n      v1 -= a0;\n  } while ((unsigned int)a0 != (unsigned int)v1);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":0,"function":"int gcd_recursive(int a, int b) {\n    return (b == 0) ? a : gcd_recursive(b, a % b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(gcd_recursive_name_conflict)(unsigned long, unsigned long long);\n\nlong long gcd_recursive_name_conflict(unsigned long a0, unsigned long long a1) {\n  if ((unsigned int)a1)\n    return gcd_recursive_name_conflict(a1, ((unsigned int)a0 >> 31 CONCAT(unsigned int) a0) /\n                                     m(unsigned int) a1 >>\n                                 32);\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoi0redrv/gcd_recursive_name_conflict.c:21:58: error: expected ')'\n   21 |         return gcd_recursive_name_conflict(a1, ((unsigned int)a0 >> 31 CONCAT\n(unsigned int)a0) /m (unsigned int)a1 >> 32); | ^\n/tmp/tmpoi0redrv/gcd_recursive_name_conflict.c:21:34: note: to match this '('\n   21 |         return gcd_recursive_name_conflict(a1, ((unsigned int)a0 >> 31 CONCAT\n(unsigned int)a0) /m (unsigned int)a1 >> 32); | ^\n/tmp/tmpoi0redrv/gcd_recursive_name_conflict.c:21:87: error: expected expression\n   21 |         return gcd_recursive_name_conflict(a1, ((unsigned int)a0 >> 31 CONCAT\n(unsigned int)a0) /m (unsigned int)a1 >> 32); | ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":0,"function":"bool test_doors(int doors[]) {\n    for (int i = 0; i <= 99; ++i) {\n        if (doors[i] && (int)sqrt(doors[i]) % 1 != 0)\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble(sqrt)(double);\n\nlong long test_doors_name_conflict(unsigned int *a0) {\n  unsigned int *v1; // rbx, Other Possible Types: unsigned long\n  unsigned long v2; // rax\n\n  v1 = a0;\n  do {\n    v2 = *((int *)v1);\n    if ((unsigned int)v2 &&\n        (((char)(CmpF(0, v2) & 69) | (char)((CmpF(0, v2) & 69) >> 6)) & 1) != 1)\n      sqrt(v2);\n  } while ((v1 += 4, v1 != a0 + 400));\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/100_Doors_Problem/C/kennyledet/100-Doors.c"}
{"compilable":1,"function":"int length(char *string) {\n    int count = 0;\n    while (string[count++] != '\\x00')\n        ;\n    return --count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long length_name_conflict(unsigned long a0) {\n  void *v1;              // rdx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n\n  v1 = 0;\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (*((char *)(a0 + v1 - 1)));\n  return v2;\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int exponentiation(int base, int exp) {\n    if (!exp) {\n        return 1;\n    }\n    int total = base;\n    int i = 1;\n    while (i++ < exp)\n        {\n            total *= base;\n        }\n    return total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long exponentiation_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned int\n  unsigned int v3;  // eax\n\n  if (!(unsigned int)a1) {\n    return 1;\n  } else if ((unsigned int)a1 <= 1) {\n    return a0;\n  } else {\n    v1 = a0;\n    v3 = 2;\n    do {\n      v1 = (unsigned int)a0 * (unsigned int)v1;\n      v3 += 1;\n    } while (v3 != (unsigned int)a1 + 1);\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":0,"function":"int parse(char *number) {\n    int size = length(number);\n    int exp = size - 1;\n    int total = 0;\n    int i;\n    for (i = 0; i < size; i++) {\n        if (number[i] >= '0' && number[i] <= '9') {\n            total += (number[i] - 48) * exponentiation(10, exp--);\n        }\n    }\n    return total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(length)(long long);\nlong long(exponentiation)(long long, long long);\n\nlong long parse_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n  unsigned long long v2; // rsi, Other Possible Types: unsigned long\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rbx\n  void *v6; // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v7; // rbp, Other Possible Types: unsigned long\n\n  v1 = length(a0);\n  if ((unsigned int)v1 <= 0)\n    return 0;\n  v2 = v1 - 1;\n  v7 = a0;\n  v6 = 0;\n  do {\n    v4 = *((char *)v7);\n    if (v4 - 48 <= 9) {\n      v5 = (int)exponentiation(10, v2) * ((unsigned int)v4 - 48);\n      v6 += v5;\n      v2 -= 1;\n    }\n  } while ((v7 += 1, v7 != a0 + v1));\n  return v6;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int linear_search(int arr[], int size, int element) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long linear_search_name_conflict(unsigned int *a0, unsigned long a1, unsigned long a2) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 0)\n    return 4294967295;\n  v1 = 0;\n  while (a0[v1] != (unsigned int)a2) {\n    v1 += 1;\n    if (v1 == a1)\n      return 4294967295;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Linear_Search/C/jay754/linear_search.c"}
{"compilable":1,"function":"unsigned long long factorial(int number) {\n    if (0 == number)\n        return 1;\n    else\n        return number * factorial(number - 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(factorial_name_conflict)(unsigned long);\n\nlong long factorial_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x8]\n  unsigned long v2;      // rbx\n  unsigned long long v4; // rbx\n\n  if ((unsigned int)a0) {\n    v0 = v2;\n    v4 = v0;\n    return factorial_name_conflict(a0 - 1) * a0;\n  }\n  return 1;\n}\n","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Factorial/C/harshasrisri/factorial.c"}
{"compilable":0,"function":"int fibo_r() {\n    static int a = 0, b = 1, count = 0;\n    if (0 == count) {\n        count++;\n        return a;\n    }\n    if (1 == count) {\n        count++;\n        return b;\n    }\n    return (b > a) ? (a += b) : (b += a);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int __TMC_END__;\nextern unsigned int b.0;\nextern unsigned int count.2;\n\nlong long fibo_r_name_conflict() {\n  if (!count.2) {\n    count.2 = 1;\n    return __TMC_END__;\n  } else if (count.2 == 1) {\n    count.2 = 2;\n    return b.0;\n  } else if (b.0 <= __TMC_END__) {\n    b.0 = b.0 + __TMC_END__;\n    return b.0;\n  } else {\n    __TMC_END__ = b.0 + __TMC_END__;\n    return __TMC_END__;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:18:22: error: expected ';' after top level declarator\n   18 | extern unsigned int b.0;\n      |                      ^\n      |                      ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:19:26: error: expected ';' after top level declarator\n   19 | extern unsigned int count.2;\n      |                          ^\n      |                          ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:23:15: error: expected ')'\n   23 |     if (!count.2)\n      |               ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:23:8: note: to match this '('\n   23 |     if (!count.2)\n      |        ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:25:14: error: expected ';' after expression\n   25 |         count.2 = 1;\n      |              ^\n      |              ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:25:17: error: expression is not assignable\n   25 |         count.2 = 1;\n      |              ~~ ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:28:19: error: expected ')'\n   28 |     else if (count.2 == 1)\n      |                   ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:28:13: note: to match this '('\n   28 |     else if (count.2 == 1)\n      |             ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:30:14: error: expected ';' after expression\n   30 |         count.2 = 2;\n      |              ^\n      |              ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:30:17: error: expression is not assignable\n   30 |         count.2 = 2;\n      |              ~~ ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:31:17: error: expected ';' after return statement\n   31 |         return b.0;\n      |                 ^\n      |                 ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:33:15: error: expected ')'\n   33 |     else if (b.0 <= __TMC_END__)\n      |               ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:33:13: note: to match this '('\n   33 |     else if (b.0 <= __TMC_END__)\n      |             ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:35:10: error: expected ';' after expression\n   35 |         b.0 = b.0 + __TMC_END__;\n      |          ^\n      |          ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:35:13: error: expression is not assignable\n   35 |         b.0 = b.0 + __TMC_END__;\n      |          ~~ ^\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:35:16: error: expected ';' after expression\n   35 |         b.0 = b.0 + __TMC_END__;\n      |                ^\n      |                ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:36:17: error: expected ';' after return statement\n   36 |         return b.0;\n      |                 ^\n      |                 ;\n/tmp/tmpan0g557l/fibo_r_name_conflict.c:40:24: error: expected ';' after expression\n   40 |         __TMC_END__ = b.0 + __TMC_END__;\n      |                        ^\n      |                        ;\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Fibonacci_series/C/harshasrisri/fibo_r.c"}
{"compilable":0,"function":"bool isSorted(int a[], int size) {\n    for (int i = 1; i < size; i++) {\n        if (a[i] < a[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isSorted_name_conflict(unsigned int a0[2], unsigned long a1) {\n  unsigned int v1[2]; // rax, Other Possible Types: unsigned long\n\n  if ((unsigned int)a1 <= 1)\n    return 1;\n  v1 = a0;\n  while (*((int *)(v1 + 4)) >= *((int *)v1)) {\n    v1 += 4;\n    if (v1 == &a0[1 + a1 + 1])\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8e3q5rsa/isSorted_name_conflict.c:23:8: error: array type 'unsigned int[2]' is not\nassignable 23 |     v1 = a0; |     ~~ ^ /tmp/tmp8e3q5rsa/isSorted_name_conflict.c:26:12:\nerror: invalid operands to binary expression ('unsigned int[2]' and 'int') 26 |\nv1 += 4; |         ~~ ^  ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Bogosort/C/jonathanlebron/bogo_sort.c"}
{"compilable":0,"function":"bool test_insertion_sort(int *sequence, int sequence_length) {\n    for (int i = 1; i < sequence_length; i++) {\n        if (sequence[i] < sequence[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test_insertion_sort_name_conflict(unsigned int a0[2], unsigned long a1) {\n  unsigned int v1[2]; // rax, Other Possible Types: unsigned long\n\n  if ((unsigned int)a1 <= 1)\n    return 1;\n  v1 = a0;\n  while (*((int *)(v1 + 4)) >= *((int *)v1)) {\n    v1 += 4;\n    if (v1 == &a0[1 + a1 + 1])\n      return 1;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp22futx49/test_insertion_sort_name_conflict.c:23:8: error: array type 'unsigned int[2]'\nis not assignable 23 |     v1 = a0; |     ~~ ^\n/tmp/tmp22futx49/test_insertion_sort_name_conflict.c:26:12: error: invalid operands to binary\nexpression ('unsigned int[2]' and 'int') 26 |         v1 += 4; |         ~~ ^  ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Insertion_Sort/C/kennyledet/insertion_sort.c"}
{"compilable":1,"function":"in_port_t get_port(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return ntohs(((struct sockaddr_in *)sa)->sin_port);\n      case 10:\n        return ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long get_port_name_conflict(unsigned short a0[2]) {\n  unsigned short v1;     // ax\n  unsigned long long v2; // rax\n  unsigned long long v3; // rax\n\n  v1 = a0[0];\n  if (v1 == 2) {\n    v2 = a0[1];\n    *((unsigned short *)&v2) = __ROL__((unsigned short)v2, 8);\n    return v2;\n  } else if (v1 != 10) {\n    return 0;\n  } else {\n    v3 = a0[1];\n    *((unsigned short *)&v3) = __ROL__((unsigned short)v3, 8);\n    return v3;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int is_addr_any(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return (((struct sockaddr_in *)sa)->sin_addr.s_addr == htonl(((in_addr_t)0)));\n      case 10:\n        return !memcmp(&((struct sockaddr_in6 *)sa)->sin6_addr, &in6addr_any, sizeof (in6addr_any));\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_0;\n\nextern void in6addr_any @GLIBC_2.2.5;\n\nlong long is_addr_any_name_conflict(struct_0 *a0) {\n  unsigned short v1; // ax\n\n  v1 = a0->field_0;\n  if (v1 == 2) {\n    return !a0->field_4;\n  } else if (v1 != 10) {\n    return 0;\n  } else {\n    return !memcmp(a0 + 1, &in6addr_any @GLIBC_2.2.5, 16);\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4l7jq8pi/is_addr_any_name_conflict.c:23:24: error: expected ';' after top level\ndeclarator 23 | extern void in6addr_any@GLIBC_2.2.5; |                        ^\n      |                        ;\n/tmp/tmp4l7jq8pi/is_addr_any_name_conflict.c:40:44: error: expected ')'\n   40 |         return !memcmp(a0 + 1, &in6addr_any@GLIBC_2.2.5, 16);\n      |                                            ^\n/tmp/tmp4l7jq8pi/is_addr_any_name_conflict.c:40:23: note: to match this '('\n   40 |         return !memcmp(a0 + 1, &in6addr_any@GLIBC_2.2.5, 16);\n      |                       ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int sed_the_buffer(int size, int *live) {\n    int i;\n    memmove(b2, buf, size);\n    for (i = 0; i < rules;) {\n        if (rule_live[i] == 0) {\n            i++;\n            break;\n        }\n        if (replace(b2, size, &rule[i].expression, rule[i].torig)) {\n            printf(\"\\033[32m[+] Replacing %s with %s\\n\\033[0m\", rule[i].forig, rule[i].torig);\n            rule_live[i]--;\n        }\n        i++;\n    }\n    return size;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rule_live; // add global variable by heuristics\nint rule_live; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(replace)(long long, long long, long long, long long);\n\nextern void b2;\nextern void buf;\nextern char g_404688;\nextern unsigned long long rule;\nextern struct_0 *rule_live;\nextern unsigned int rules;\n\nlong long sed_the_buffer_name_conflict(unsigned long a0) {\n  void *v1;                 // rbx, Other Possible Types: unsigned long\n  unsigned long long v2;    // rbp\n  unsigned long long v3[4]; // rbp\n  unsigned int *v4;         // r12\n\n  memcpy(&b2, &buf, a0);\n  if (rules <= 0)\n    return a0;\n  v1 = 0;\n  while (rule_live[v1].field_0) {\n    v2 = (v1 + v1 * 12) * 8;\n    if ((int)replace(&b2, a0, v2 + rule + 40,\n                     *((long long *)(v2 + rule + 24)))) {\n      v3 = v2 + rule;\n      printf(&g_404688, (unsigned int)v3[2], (unsigned int)v3[3]);\n      v4 = &rule_live[v1];\n      *(v4) = *(v4)-1;\n    }\n    v1 += 1;\n    if (rules <= (unsigned int)v1)\n      return a0;\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv0fwlrw5/sed_the_buffer_name_conflict.c:24:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 24 | extern struct_0 *rule_live; |        ^~~~~~~~ | struct\n/tmp/tmpv0fwlrw5/sed_the_buffer_name_conflict.c:24:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpv0fwlrw5/sed_the_buffer_name_conflict.c:38:25: error: member\nreference base type 'void' is not a structure or union 38 |     while\n(rule_live[v1].field_0) |            ~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpv0fwlrw5/sed_the_buffer_name_conflict.c:40:23: error: invalid operands to binary\nexpression ('void *' and 'int') 40 |         v2 = (v1 + v1 * 12) * 8; | ~~ ^ ~~\n/tmp/tmpv0fwlrw5/sed_the_buffer_name_conflict.c:43:16: error: array type 'unsigned long\nlong[4]' is not assignable 43 |             v3 = v2 + rule; |             ~~ ^\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(open)(char *, int, unsigned short);\nint(fcntl)(int, int, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern unsigned int xpmem_fd;\n\nlong long xpmem_init_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  stat v0;          // [bp-0x98]\n  char v1;          // [bp-0x80]\n  unsigned long v3; // rax\n\n  if (stat(\"/dev/xpmem\", &v0)) {\n    return 4294967295;\n  } else if (((short)*((int *)&v1) & 0xf000) == 0x2000) {\n    (unsigned int)v3 = open(\"/dev/xpmem\", 2, a2);\n    xpmem_fd = v3;\n    if ((unsigned int)v3 != -1) {\n      v3 = -(fcntl(v3, 2) == -1);\n      return v3;\n    }\n    return v3;\n  } else {\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjnvte3ux/xpmem_init_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpjnvte3ux/xpmem_init_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpjnvte3ux/xpmem_init_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpjnvte3ux/xpmem_init_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpjnvte3ux/xpmem_init_name_conflict.c:65:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 65 |         (unsigned int)v3 = open(\"/dev/xpmem\", 2,\na2); |         ^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_remove(unsigned long a0, unsigned long a1,\n                       unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return -((int)xpmem_ioctl(30722, &v0, a2) == -1);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_release(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return -((int)xpmem_ioctl(30724, &v0, a2) == -1);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_version(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  return xpmem_ioctl(0x7800, 0, a2);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(open)(char *, int, unsigned short);\nint(fcntl)(int, int, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern unsigned int xpmem_fd;\n\nlong long xpmem_init_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  stat v0;          // [bp-0x98]\n  char v1;          // [bp-0x80]\n  unsigned long v3; // rax\n\n  if (stat(\"/dev/xpmem\", &v0)) {\n    return 4294967295;\n  } else if (((short)*((int *)&v1) & 0xf000) == 0x2000) {\n    (unsigned int)v3 = open(\"/dev/xpmem\", 2, a2);\n    xpmem_fd = v3;\n    if ((unsigned int)v3 != -1) {\n      v3 = -(fcntl(v3, 2) == -1);\n      return v3;\n    }\n    return v3;\n  } else {\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm7jonjag/xpmem_init_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpm7jonjag/xpmem_init_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpm7jonjag/xpmem_init_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpm7jonjag/xpmem_init_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpm7jonjag/xpmem_init_name_conflict.c:65:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 65 |         (unsigned int)v3 = open(\"/dev/xpmem\", 2,\na2); |         ^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_remove(unsigned long a0, unsigned long a1,\n                       unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return -((int)xpmem_ioctl(30722, &v0, a2) == -1);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_release(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return -((int)xpmem_ioctl(30724, &v0, a2) == -1);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_version(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  return xpmem_ioctl(0x7800, 0, a2);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nint(open)(char *, int, unsigned short);\nint(fcntl)(int, int, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern unsigned int xpmem_fd;\n\nlong long xpmem_init_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  stat v0;          // [bp-0x98]\n  char v1;          // [bp-0x80]\n  unsigned long v3; // rax\n\n  if (stat(\"/dev/xpmem\", &v0)) {\n    return 4294967295;\n  } else if (((short)*((int *)&v1) & 0xf000) == 0x2000) {\n    (unsigned int)v3 = open(\"/dev/xpmem\", 2, a2);\n    xpmem_fd = v3;\n    if ((unsigned int)v3 != -1) {\n      v3 = -(fcntl(v3, 2) == -1);\n      return v3;\n    }\n    return v3;\n  } else {\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq6ese761/xpmem_init_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpq6ese761/xpmem_init_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpq6ese761/xpmem_init_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v0;  // [bp-0x98] |     ^ |     struct\n/tmp/tmpq6ese761/xpmem_init_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpq6ese761/xpmem_init_name_conflict.c:65:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 65 |         (unsigned int)v3 = open(\"/dev/xpmem\", 2,\na2); |         ^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_remove(unsigned long a0, unsigned long a1,\n                       unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return -((int)xpmem_ioctl(30722, &v0, a2) == -1);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_release(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  unsigned long v0; // [bp-0x10]\n\n  v0 = a0;\n  return -((int)xpmem_ioctl(30724, &v0, a2) == -1);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xpmem_ioctl)(long long, long long, long long);\n\nlong long xpmem_version(unsigned long a0, unsigned long a1,\n                        unsigned long long a2) {\n  return xpmem_ioctl(0x7800, 0, a2);\n}\n","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int RateStatement(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Agree\\n2. Nuetral\\n3. Disagree\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += agree;\n        return 1;\n      case 2:\n        *score += neutral;\n        return 1;\n      case 3:\n        *score += disagree;\n      default:\n        return 0;\n    }\n    printf(\"\\n\\n\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long RateStatement_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned long long v2; // rax\n\n  v0 = 0;\n  puts(\"1. Agree\\n2. Nuetral\\n3. Disagree\");\n  printf(\"%s: \", (unsigned int)a0);\n  __isoc99_scanf(\"%d\", (unsigned int)&v0);\n  v2 = v0;\n  if ((unsigned int)v2 == 2) {\n    *(a1) = *(a1) + 5;\n    return 1;\n  } else if ((unsigned int)v2 == 3) {\n    *(a1) = *(a1)-5;\n    return 0;\n  } else if ((unsigned int)v2 != 1) {\n    return 0;\n  } else {\n    *(a1) = *(a1) + 10;\n    return v0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":0,"function":"int AskQuestion(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Yes\\n2. No\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += yes;\n        printf(\"\\n\\n\");\n        return 1;\n      case 2:\n        *score += no;\n        printf(\"\\n\\n\");\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long AskQuestion_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned int v0; // [bp-0x1c]\n  void *v2;        // rbx\n\n  v0 = 0;\n  puts(\"1. Yes\\n2. No\");\n  printf(\"%s: \", (unsigned int)a0);\n  __isoc99_scanf(\"%d\", (unsigned int)&v0);\n  v2 = v0;\n  if ((unsigned int)v2 == 1) {\n    *(a1) = *(a1) + 15;\n    puts(\"\\n\");\n    return v0;\n  } else if ((unsigned int)v2 == 2) {\n    *(a1) = *(a1)-5;\n    puts(\"\\n\");\n    return 0;\n  } else {\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Sigil-Ebook_Sigil/3rdparty/zlib/examples/enough.c"}
{"compilable":0,"function":"int generateRandom(int min, int max) {\n    return rand() % (max - min + 1) + min;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long generateRandom_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v2; // rax\n\n  (unsigned int)v2 = rand();\n  return (((unsigned int)v2 >> 31 CONCAT(unsigned int) v2) /\n              m((unsigned int)a1 - (unsigned int)a0 + 1) >>\n          32) +\n         a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf_xlynh_/generateRandom_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v2 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpf_xlynh_/generateRandom_name_conflict.c:23:37: error: expected ')'\n   23 |     return (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0 + 1) >> 32) + a0; | ^\n/tmp/tmpf_xlynh_/generateRandom_name_conflict.c:23:13: note: to match this '('\n   23 |     return (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0 + 1) >> 32) + a0; |             ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int getEmptyCells(struct Pos empty[], struct Square m[][4]) {\n    int i, j;\n    int n = 0;\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            if (!m[i][j].value) {\n                struct Pos temp;\n                temp.x = i;\n                temp.y = j;\n                empty[n++] = temp;\n            }\n    return n;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long getEmptyCells_name_conflict(unsigned long a0, unsigned int *a1) {\n  void *v1;              // rdx, Other Possible Types: unsigned long\n  void *v2;              // rax, Other Possible Types: unsigned long\n  unsigned int v3[2];    // rcx\n  unsigned long long v4; // rsi\n\n  v1 = 0;\n  do {\n    v2 = 0;\n    do {\n      if (!a1[2 * v2]) {\n        v3 = a0 + v1 * 8;\n        v3[0] = 0;\n        v3[1] = v2;\n        v1 += 1;\n      }\n    } while ((v2 += 1, v2 != 4));\n    v4 = a1 + 8;\n  } while (true);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptklrzrc7/getEmptyCells_name_conflict.c:30:23: error: invalid operands to binary\nexpression ('int' and 'void *') 30 |             if (!a1[2 * v2]) | ~ ^ ~~\n/tmp/tmptklrzrc7/getEmptyCells_name_conflict.c:32:30: error: invalid operands to binary\nexpression ('void *' and 'int') 32 |                 v3 = a0 + v1 * 8; | ~~ ^ ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int playerWon(struct Square m[][4]) {\n    int i, j;\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            if (m[i][j].value == 2048)\n                return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long playerWon_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  unsigned int *v3; // rax, Other Possible Types: unsigned long\n\n  v1 = a0 + 32;\n  do {\n    v3 = v1 - 32;\n    do {\n      if (*((int *)v3) == 0x800)\n        return 1;\n    } while ((v3 += 8, v3 != v1));\n    v1 += 32;\n  } while (v1 != a0 + 160);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int readMove() {\n    int move, validMove = 0;\n    while (!validMove)\n        {\n            printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", RIGHT, DOWN, LEFT, UP);\n            scanf(\"%d\", &move);\n            if (move >= 0 && move < 3)\n                validMove = 1;\n        }\n    return move;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long readMove_name_conflict() {\n  char v0;               // [bp-0x1c]\n  unsigned long long v2; // rax\n\n  do {\n    printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", 0, 1, 2,\n           3);\n    __isoc99_scanf(\"%d\", (unsigned int)&v0);\n    v2 = *((int *)&v0);\n  } while ((unsigned int)v2 > 2);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int gpio_export(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/export\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_export_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;  // [bp-0x58]\n  void *v2; // rbx, Other Possible Types: unsigned long\n\n  v2 = open(\"/sys/class/gpio/export\", 1, a2);\n  if ((unsigned int)v2 < 0) {\n    perror(\"gpio/export\");\n    return v2;\n  }\n  write((unsigned int)v2, &v0, snprintf(&v0, 64, \"%d\", (unsigned int)a0));\n  close((unsigned int)v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2tt5lwka/gpio_export_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp2tt5lwka/gpio_export_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_unexport(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/unexport\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_unexport_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;  // [bp-0x58]\n  void *v2; // rbx, Other Possible Types: unsigned long\n\n  v2 = open(\"/sys/class/gpio/unexport\", 1, a2);\n  if ((unsigned int)v2 < 0) {\n    perror(\"gpio/export\");\n    return v2;\n  }\n  write((unsigned int)v2, &v0, snprintf(&v0, 64, \"%d\", (unsigned int)a0));\n  close((unsigned int)v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpiorp3fwm/gpio_unexport_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpiorp3fwm/gpio_unexport_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_set_dir(unsigned int gpio, char *ident, unsigned int out_flag) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/direction\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/direction\");\n        return fd;\n    }\n    if (out_flag)\n        write(fd, \"out\", 4);\n    else\n        write(fd, \"in\", 3);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_set_dir_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;  // [bp-0x58]\n  void *v2; // rbx, Other Possible Types: unsigned long\n\n  snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/direction\", (unsigned int)a0,\n           (unsigned int)a1);\n  v2 = open(&v0, 1, 8416);\n  if ((unsigned int)v2 < 0) {\n    perror(\"gpio/direction\");\n    return v2;\n  }\n  if ((unsigned int)a2)\n    write((unsigned int)v2, \"out\", 4);\n  else\n    write((unsigned int)v2, \"in\", 3);\n  close((unsigned int)v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7d4n6hhu/gpio_set_dir_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp7d4n6hhu/gpio_set_dir_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_set_value(unsigned int gpio, char *ident, unsigned int value) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-value\");\n        return fd;\n    }\n    if (value)\n        write(fd, \"1\", 2);\n    else\n        write(fd, \"0\", 2);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_set_value_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;  // [bp-0x58]\n  void *v2; // rbx, Other Possible Types: unsigned long\n\n  snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/value\", (unsigned int)a0,\n           (unsigned int)a1);\n  v2 = open(&v0, 1, 8456);\n  if ((unsigned int)v2 < 0) {\n    perror(\"gpio/set-value\");\n    return v2;\n  }\n  if ((unsigned int)a2)\n    write((unsigned int)v2, \"1\", 2);\n  else\n    write((unsigned int)v2, \"0\", 2);\n  close((unsigned int)v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkmc8axsu/gpio_set_value_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpkmc8axsu/gpio_set_value_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_get_value(unsigned int gpio, char *ident, unsigned int *value) {\n    int fd, len;\n    char buf[64];\n    char ch;\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0);\n    if (fd < 0) {\n        perror(\"gpio/get-value\");\n        return fd;\n    }\n    read(fd, &ch, 1);\n    if (ch != '0') {\n        *value = 1;\n    } else {\n        *value = 0;\n    }\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(read)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_get_value_name_conflict(unsigned long a0, unsigned long a1, unsigned int *a2) {\n  char v0;  // [bp-0x59]\n  char v1;  // [bp-0x58]\n  void *v3; // rbx, Other Possible Types: unsigned long\n\n  snprintf(&v1, 64, \"/sys/class/gpio/gpio%d_%s/value\", (unsigned int)a0,\n           (unsigned int)a1);\n  v3 = open(&v1, 0, 8456);\n  if ((unsigned int)v3 < 0) {\n    perror(\"gpio/get-value\");\n    return v3;\n  }\n  read((unsigned int)v3, &v0, 1);\n  *(a2) = v0 != 48;\n  close((unsigned int)v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplwvge30d/gpio_get_value_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmplwvge30d/gpio_get_value_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_set_edge(unsigned int gpio, char *ident, char *edge) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/edge\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-edge\");\n        return fd;\n    }\n    write(fd, edge, strlen(edge) + 1);\n    close(fd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\n\nlong long gpio_set_edge_name_conflict(unsigned long a0, unsigned long a1, char *a2) {\n  char v0;  // [bp-0x58]\n  void *v2; // rbx, Other Possible Types: unsigned long\n\n  snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/edge\", (unsigned int)a0,\n           (unsigned int)a1);\n  v2 = open(&v0, 1, 8488);\n  if ((unsigned int)v2 < 0) {\n    perror(\"gpio/set-edge\");\n    return v2;\n  }\n  write((unsigned int)v2, a2, strlen(a2) + 1);\n  close((unsigned int)v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe3vxp9i2/gpio_set_edge_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpe3vxp9i2/gpio_set_edge_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_fd_open(unsigned int gpio, char *ident) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0 | 2048);\n    if (fd < 0) {\n        perror(\"gpio/fd_open\");\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\n\nlong long gpio_fd_open_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;               // [bp-0x48]\n  unsigned long long v2; // rax\n\n  snprintf(&v0, 64, \"/sys/class/gpio/gpio%d_%s/value\", (unsigned int)a0,\n           (unsigned int)a1);\n  (unsigned int)v2 = open(&v0, 0x800, 8456);\n  if ((unsigned int)v2 < 0) {\n    perror(\"gpio/fd_open\");\n    return v2;\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph1tdcmj4/gpio_fd_open_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmph1tdcmj4/gpio_fd_open_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmph1tdcmj4/gpio_fd_open_name_conflict.c:26:5: error: assignment to cast is illegal,\nlvalue casts are not supported 26 |     (unsigned int)v2 = open(&v0, 0x800,\n8456); |     ^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_fd_close(int fd) {\n    return close(fd);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long gpio_fd_close_name_conflict(unsigned long a0) { return close(a0); }\n","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int hello(void) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hello_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/src/hello.c"}
{"compilable":0,"function":"int UnityEnd(void) {\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrint(UnityStrBreaker);\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrintNumber((_U_SINT)(Unity.NumberOfTests));\n    UnityPrint(UnityStrResultsTests);\n    UnityPrintNumber((_U_SINT)(Unity.TestFailures));\n    UnityPrint(UnityStrResultsFailures);\n    UnityPrintNumber((_U_SINT)(Unity.TestIgnores));\n    UnityPrint(UnityStrResultsIgnored);\n    {\n        putchar('\\n');\n    }\n    ;\n    if (Unity.TestFailures == 0U) {\n        UnityPrintOk();\n    } else {\n        UnityPrintFail();\n    }\n    {\n        putchar('\\n');\n    }\n    ;\n    ;\n    return (int)(Unity.TestFailures);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(putc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(UnityPrint)(long long);\nlong long(UnityPrintNumber)(long long);\nlong long(UnityPrintOk)();\nlong long(UnityPrintFail)();\n\nextern unsigned long long g_4070b8;\nextern unsigned long long g_4070c0;\nextern unsigned long long g_4070c8;\nextern FILE_t *stdout @GLIBC_2.2.5;\n\nlong long UnityEnd_name_conflict() {\n  putc(10, stdout @GLIBC_2.2.5);\n  UnityPrint(\"-----------------------\");\n  putc(10, stdout @GLIBC_2.2.5);\n  UnityPrintNumber(g_4070b8);\n  UnityPrint(\" Tests \");\n  UnityPrintNumber(g_4070c0);\n  UnityPrint(\" Failures \");\n  UnityPrintNumber(g_4070c8);\n  UnityPrint(\" Ignored \");\n  putc(10, stdout @GLIBC_2.2.5);\n  if (!g_4070c0)\n    UnityPrintOk();\n  else\n    UnityPrintFail();\n  putc(10, stdout @GLIBC_2.2.5);\n  return (unsigned int)g_4070c0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:16:6: error: conflicting types for 'putc'\n   16 | int (putc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:550:12: note: previous declaration is here\n  550 | extern int putc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:113:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 113 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:113:22: error: expected ';' after top level\ndeclarator 113 | extern FILE_t *stdout@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:117:20: error: expected ')'\n  117 |     putc(10, stdout@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:117:9: note: to match this '('\n  117 |     putc(10, stdout@GLIBC_2.2.5);\n      |         ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:119:20: error: expected ')'\n  119 |     putc(10, stdout@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:119:9: note: to match this '('\n  119 |     putc(10, stdout@GLIBC_2.2.5);\n      |         ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:126:20: error: expected ')'\n  126 |     putc(10, stdout@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:126:9: note: to match this '('\n  126 |     putc(10, stdout@GLIBC_2.2.5);\n      |         ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:131:20: error: expected ')'\n  131 |     putc(10, stdout@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpqsucma5w/UnityEnd_name_conflict.c:131:9: note: to match this '('\n  131 |     putc(10, stdout@GLIBC_2.2.5);\n      |         ^\n12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity.c"}
{"compilable":0,"function":"static int selected(const char *filter, const char *name) {\n    if (filter == 0)\n        return 1;\n    return strstr(name, filter) ? 1 : 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int testSelected(const char *test) {\n    return selected(UnityFixture.NameFilter, test);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int groupSelected(const char *group) {\n    return selected(UnityFixture.GroupFilter, group);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityFailureCount(void) {\n    return Unity.TestFailures;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int g_4070c0;\n\nlong long UnityFailureCount_name_conflict() { return g_4070c0; }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityGetCommandLineOptions(int argc, const char *argv[]) {\n    int i;\n    UnityFixture.Verbose = 0;\n    UnityFixture.GroupFilter = 0;\n    UnityFixture.NameFilter = 0;\n    UnityFixture.RepeatCount = 1;\n    if (argc == 1)\n        return 0;\n    for (i = 1; i < argc;) {\n        if (strcmp(argv[i], \"-v\") == 0) {\n            UnityFixture.Verbose = 1;\n            i++;\n        } else if (strcmp(argv[i], \"-g\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.GroupFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-n\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.NameFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-r\") == 0) {\n            UnityFixture.RepeatCount = 2;\n            i++;\n            if (i < argc) {\n                if (*(argv[i]) >= '0' && *(argv[i]) <= '9') {\n                    UnityFixture.RepeatCount = atoi(argv[i]);\n                    i++;\n                }\n            }\n        } else {\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_4071e0; // add global variable by heuristics\nint g_4071d8; // add global variable by heuristics\nint rbp;      // add global variable by heuristics\nint g_4071e0; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int UnityFixture;\nextern unsigned int g_4071d4;\nextern struct_0 *g_4071d8;\nextern struct_0 *g_4071e0;\n\nlong long UnityGetCommandLineOptions_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v0;          // [bp-0x30]\n  unsigned long v1;          // [bp-0x28]\n  unsigned long v2;          // [bp-0x20]\n  unsigned long v3;          // [bp-0x18]\n  unsigned long v4;          // [bp-0x10]\n  unsigned long v5;          // [bp-0x8]\n  unsigned long v7;          // r15\n  unsigned long v8;          // r14\n  unsigned long v9;          // r13\n  unsigned long v10;         // r12\n  unsigned long v11;         // rbx\n  unsigned int v12;          // r12d\n  unsigned long long v13[2]; // r14\n  char *v14;                 // rbp\n  unsigned long long v15[2]; // rbx, Other Possible Types: unsigned long\n  unsigned long long v16;    // rax, Other Possible Types: unsigned long\n  unsigned long long v17[2]; // rdx\n  char *v18;                 // rdi\n\n  UnityFixture = 0;\n  g_4071e0 = 0;\n  g_4071d8 = 0;\n  g_4071d4 = 1;\n  if ((unsigned int)a0 <= 1)\n    return 0;\n  v5 = v7;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  v12 = a0;\n  v15 = 1;\n  while (true) {\n    v13 = v15 * 8;\n    v14 = *((long long *)(a1 + v15 * 8));\n    if (!strcmp(v14, \"-v\")) {\n      UnityFixture = 1;\n      v15 = (unsigned int)v15 + 1;\n    } else if (!strcmp(v14, \"-g\")) {\n      if (v12 > (unsigned int)(v15 + 1)) {\n        g_4071e0 = *((long long *)(8 + a1 + (char *)&v13[0]));\n        v15 = (unsigned int)v15 + 2;\n      } else {\n        return 1;\n      }\n    } else {\n      if (strcmp(v14, \"-n\")) {\n        (unsigned int)v16 = strcmp(v14, \"-r\");\n        if ((unsigned int)v16) {\n          v15 = (unsigned int)v15 + 1;\n        } else {\n          g_4071d4 = 2;\n          v17 = v15 + 1;\n          if (v12 <= (unsigned int)v17)\n            return v16;\n          v18 = *((long long *)(8 + a1 + (char *)&v13[0]));\n          if (*(v18)-48 <= 9) {\n            g_4071d4 = strtol(v18, NULL, 10);\n            v15 = (unsigned int)v15 + 2;\n          } else {\n            v15 = v17;\n            continue;\n          }\n        }\n      } else if (v12 > (unsigned int)(v15 + 1)) {\n        g_4071d8 = *((long long *)(8 + a1 + (char *)&v13[0]));\n        v15 = (unsigned int)v15 + 2;\n      } else {\n        return 1;\n      }\n    }\n    if (v12 <= (unsigned int)v15)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:23:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 23 | extern struct_0 *g_4071d8; | ^~~~~~~~ |\nstruct /tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:23:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:24:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 24 | extern struct_0 *g_4071e0; | ^~~~~~~~ |\nstruct /tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:24:8: error: declaration of\nanonymous struct must be a definition\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:60:9: error: array type 'unsigned\nlong long[2]' is not assignable 60 |     v15 = 1; |     ~~~ ^\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:63:19: error: invalid operands to\nbinary expression ('unsigned long long[2]' and 'int') 63 |         v13 = v15 *\n8; |               ~~~ ^ ~ /tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:64:40:\nerror: invalid operands to binary expression ('unsigned long long[2]' and 'int')\n   64 |         v14 = *((long long *)(a1 + v15 * 8));\n      |                                    ~~~ ^ ~\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:68:17: error: array type 'unsigned\nlong long[2]' is not assignable 68 |             v15 = (unsigned int)v15 + 1; |\n~~~ ^ /tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:75:21: error: array type\n'unsigned long long[2]' is not assignable 75 |                 v15 = (unsigned\nint)v15 + 2; |                 ~~~ ^\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:86:17: error: assignment to cast\nis illegal, lvalue casts are not supported 86 |                 (unsigned\nint)v16 = strcmp(v14, \"-r\"); |                 ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:89:25: error: array type 'unsigned\nlong long[2]' is not assignable 89 |                     v15 = (unsigned int)v15\n+ 1; |                     ~~~ ^\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:94:25: error: array type 'unsigned\nlong long[2]' is not assignable 94 |                     v17 = v15 + 1; | ~~~ ^\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:101:29: error: array type\n'unsigned long long[2]' is not assignable 101 |                         v15 =\n(unsigned int)v15 + 2; |                         ~~~ ^\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:105:29: error: array type\n'unsigned long long[2]' is not assignable 105 |                         v15 =\nv17; |                         ~~~ ^\n/tmp/tmpg3d1rpof/UnityGetCommandLineOptions_name_conflict.c:113:21: error: array type\n'unsigned long long[2]' is not assignable 113 |                 v15 = (unsigned\nint)v15 + 2; |                 ~~~ ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int print_jpeg_metadata(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 1;\n    int offset = 0;\n    long metadata_size = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            buf[offset++] = c;\n            if (offset >= bufsize)\n                buf_resize(0);\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        metadata_size = offset - 2;\n                        if (metadata_size != ftell(f) - 2 || metadata_size < 0) {\n                            fprintf(stderr, \"unexpected error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        err = 0;\n                        fprintf(stderr, \"%li %s\\n\", metadata_size, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        exit(1);\n                    }\n                    length -= 2;\n                    if (offset + length > bufsize) {\n                        buf_resize(length);\n                    }\n                    uint16_t segment = *((uint16_t *)(buf + offset - 4));\n                    fprintf(stderr, \"segment: %02X%02X, length: %d\\n\", segment & 255, segment >> 8, length);\n                    if (length) {\n                        if (fread(buf + offset, 1, length, f) != length) {\n                            fprintf(stderr, \"error: read error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        offset += length;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    long file_offset = ftell(output_file);\n    if (file_offset < 0) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    uint32_t file_offset32 = (uint32_t)file_offset;\n    if (fwrite(&file_offset32, 1, sizeof (file_offset32), index_file) != sizeof (file_offset32)) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    if (metadata_size) {\n        if (fwrite(buf, 1, metadata_size, output_file) != metadata_size) {\n            fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n            exit(1);\n        }\n    }\n    fflush(output_file);\n    return err;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(buf_resize)(long long);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern struct_0 *buf;\nextern unsigned long long bufsize;\nextern FILE_t *index_file;\nextern FILE_t *output_file;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long print_jpeg_metadata(char *a0) {\n  unsigned int v0;        // [bp-0x3c]\n  unsigned long long v2;  // rax\n  FILE_t *v3;             // r15\n  unsigned long long v4;  // rax\n  char *v5;               // r13\n  unsigned long long v6;  // rax\n  char *v7;               // rbx\n  unsigned long long v9;  // rax\n  char *v10;              // r12, Other Possible Types: unsigned long\n  unsigned int v11;       // ebp\n  unsigned int v12;       // rbp, Other Possible Types: unsigned long\n  char *v13;              // r13\n  unsigned long long v14; // rdx\n  unsigned int v15;       // ecx\n  void *v16;              // rbx, Other Possible Types: unsigned long\n  void *v17; // rbp, Other Possible Types: unsigned long long, unsigned long\n  unsigned long long v18; // rax\n\n  v2 = fopen(a0, \"r\");\n  if (!v2) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: cannot open file %s\\n\",\n            (unsigned int)a0);\n    v17 = *(__errno_location());\n    return v17;\n  }\n  v3 = v2;\n  v10 = 0;\n  v12 = 0;\n  while (true) {\n    (unsigned int)v4 = fgetc(v3);\n    if ((unsigned int)v4 == -1) {\n      v16 = 0;\n      v17 = 1;\n      break;\n    } else {\n      v5 = v10 + 1;\n      (&buf->field_0)[v10] = v4;\n      if (v5 >= bufsize)\n        buf_resize(0);\n      if (!(unsigned int)v12) {\n        v12 = (unsigned int)v4 == 255;\n        v10 = v5;\n      } else {\n        ftell(v3);\n        if ((unsigned int)v4 == 216) {\n          v10 = v5;\n          v12 = 0;\n        } else if (((char)v4 & 240) == 224) {\n          (unsigned int)v6 = fgetc(v3);\n          if ((unsigned int)v6 == -1) {\n            fprintf(stderr @GLIBC_2.2.5, \"error: unexpected end of file %s\\n\",\n                    (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          *((char *)(buf + v5)) = v6;\n          v7 = v10 + 2;\n          if (v7 >= bufsize)\n            buf_resize(0);\n          (unsigned int)v9 = fgetc(v3);\n          if ((unsigned int)v9 == -1) {\n            fprintf(stderr @GLIBC_2.2.5, \"error: unexpected end of file %s\\n\",\n                    (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          v10 = (unsigned int)v10 + 3;\n          *((char *)(buf + v7)) = v9;\n          if (v10 >= bufsize)\n            buf_resize(0);\n          v11 = (unsigned int)v6 * 0x100 + (unsigned int)v9;\n          if (v11 <= 1) {\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"error: invalid segment length in %s\\n\", (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          v12 = v11 - 2;\n          v13 = v10 + v12;\n          if (bufsize < v13)\n            buf_resize(v12);\n          v14 = *((short *)&(&buf[1].field_1)[v10]);\n          v15 = v14;\n          *((unsigned short *)&v15) = (unsigned short)v14 / 0x100;\n          fprintf(stderr @GLIBC_2.2.5, \"segment: %02X%02X, length: %d\\n\",\n                  (unsigned int)v14, v15, (unsigned int)v12);\n          if ((unsigned int)v12) {\n            if (v12 != fread(&(&buf->field_0)[v10], 1, v12, v3)) {\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"error: read error while processing %s\\n\",\n                      (unsigned int)a0);\n              exit(1); /* do not return */\n            }\n            v10 = v13;\n            v12 = 0;\n          }\n        } else {\n          v16 = v10 - 1;\n          if (!(ftell(v3) - 2 == v16) || !(v16 >= 0)) {\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"unexpected error while processing %s\\n\", (unsigned int)a0);\n            exit(1); /* do not return */\n          }\n          fprintf(stderr @GLIBC_2.2.5, \"%li %s\\n\", (unsigned int)v16,\n                  (unsigned int)a0);\n          v17 = 0;\n          break;\n        }\n      }\n    }\n  }\n  fclose(v3);\n  v18 = ftell(output_file);\n  if (v18 < 0) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: write error while processing %s\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  v0 = v18;\n  if (fwrite(&v0, 1, 4, index_file) != 4) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: write error while processing %s\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  if (v16 && v16 != fwrite(buf, 1, v16, output_file)) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: write error while processing %s\\n\",\n            (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  fflush(output_file);\n  return v17;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:16:6: error: conflicting types for\n'fgetc' 16 | int (fgetc)(struct FILE_t { |      ^ /usr/include/stdio.h:513:12:\nnote: previous declaration is here 513 | extern int fgetc (FILE *__stream); | ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:163:13: error: declaration of anonymous\nunion must be a definition 163 |             union <anon> { |             ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:166:22: error: type name requires a\nspecifier or qualifier 166 |             } __value; |                      ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:170:13: error: declaration of anonymous\nunion must be a definition 170 |             union <anon> { |             ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:173:22: error: type name requires a\nspecifier or qualifier 173 |             } __value; |                      ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:106:7: error: conflicting types for\n'ftell' 106 | long (ftell)(struct FILE_t { |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:252:13: error: declaration of anonymous\nunion must be a definition 252 |             union <anon> { |             ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:255:22: error: type name requires a\nspecifier or qualifier 255 |             } __value; |                      ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:259:13: error: declaration of anonymous\nunion must be a definition 259 |             union <anon> { |             ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:262:22: error: type name requires a\nspecifier or qualifier 262 |             } __value; |                      ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:195:16: error: conflicting types for\n'fread' 195 | unsigned long (fread)(void*, unsigned long, unsigned long, struct\nFILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmp44gygr8_/print_jpeg_metadata.c:320:16: error:\nredefinition of '_IO_marker' 320 | typedef struct _IO_marker { | ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:326:16: error: redefinition of\n'_IO_codecvt' 326 | typedef struct _IO_codecvt { |                ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:330:16: error: redefinition of\n'_IO_wide_data' 330 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp44gygr8_/print_jpeg_metadata.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata.c"}
{"compilable":0,"function":"int print_jpeg_metadata_size(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        printf(\"%d %s\\n\", ftell(f) - 2, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        err = 1;\n                        break;\n                    }\n                    if (length && fseek(f, length - 2, 1) < 0) {\n                        fprintf(stderr, \"error: i/o error with %s\\n\", filename);\n                        err = (*__errno_location());\n                        break;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    return err;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long print_jpeg_metadata_size(char *a0) {\n  unsigned int v1;       // r14d\n  unsigned long long v2; // rax\n  FILE_t *v3;            // rbp\n  unsigned long long v4; // rax\n  unsigned long long v5; // rax\n  unsigned long long v7; // rax\n  unsigned long long v8; // rax\n  void *v9; // r12, Other Possible Types: unsigned long, unsigned long long\n\n  v1 = (unsigned int)a0;\n  v2 = fopen(a0, \"r\");\n  if (!v2) {\n    fprintf(stderr @GLIBC_2.2.5, \"error: cannot open file %s\\n\", v1);\n    v9 = *(__errno_location());\n    return v9;\n  }\n  v3 = v2;\n  v9 = 0;\n  while (true) {\n    (unsigned int)v4 = fgetc(v3);\n    if ((unsigned int)v4 == -1) {\n      v9 = 0;\n      break;\n    } else if (!(unsigned int)v9) {\n      v9 = (unsigned int)v4 == 255;\n    } else {\n      ftell(v3);\n      if ((unsigned int)v4 == 216) {\n        v9 = 0;\n      } else if (((char)v4 & 240) != 224) {\n        printf(\"%d %s\\n\", (int)ftell(v3) - 2, v1);\n        v9 = 0;\n        break;\n      } else {\n        (unsigned int)v5 = fgetc(v3);\n        if ((unsigned int)v5 == -1) {\n          v9 = 0;\n          break;\n        } else {\n          (unsigned int)v7 = fgetc(v3);\n          if ((unsigned int)v7 == -1) {\n            v9 = 0;\n            break;\n          } else {\n            v8 = v7 + v5 * 0x100;\n            if ((unsigned int)v8 <= 1) {\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"error: invalid segment length in %s\\n\", v1);\n              break;\n            } else if (fseek(v3, v8 - 2, 1) >= 0) {\n              v9 = 0;\n            } else {\n              fprintf(stderr @GLIBC_2.2.5, \"error: i/o error with %s\\n\", v1);\n              v9 = *(__errno_location());\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  fclose(v3);\n  return v9;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:16:6: error: conflicting types for\n'fgetc' 16 | int (fgetc)(struct FILE_t { |      ^ /usr/include/stdio.h:513:12:\nnote: previous declaration is here 513 | extern int fgetc (FILE *__stream); | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:162:13: error: declaration of\nanonymous union must be a definition 162 |             union <anon> { | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:169:13: error: declaration of\nanonymous union must be a definition 169 |             union <anon> { | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:105:7: error: conflicting types for\n'ftell' 105 | long (ftell)(struct FILE_t { |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:251:13: error: declaration of\nanonymous union must be a definition 251 |             union <anon> { | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:254:22: error: type name requires a\nspecifier or qualifier 254 |             } __value; |                      ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:258:13: error: declaration of\nanonymous union must be a definition 258 |             union <anon> { | ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:261:22: error: type name requires a\nspecifier or qualifier 261 |             } __value; |                      ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:194:6: error: conflicting types for\n'fseek' 194 | int (fseek)(struct FILE_t { |      ^ /usr/include/stdio.h:713:12:\nnote: previous declaration is here 713 | extern int fseek (FILE *__stream, long\nint __off, int __whence); |            ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:319:16: error: redefinition of\n'_IO_marker' 319 | typedef struct _IO_marker { |                ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:325:16: error: redefinition of\n'_IO_codecvt' 325 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:329:16: error: redefinition of\n'_IO_wide_data' 329 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpykgk3e2m/print_jpeg_metadata_size.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^ fatal error: too many errors\nemitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata_size.c"}
{"compilable":0,"function":"int mread(int s, char *bufp, unsigned int n) {\n    register unsigned int count = 0;\n    register int nread;\n    do {\n        nread = read(s, bufp, n - count);\n        numCalls++;\n        if (nread < 0) {\n            perror(\"ttcp_mread\");\n            return (-1);\n        }\n        if (nread == 0)\n            return ((int)count);\n        count += (unsigned int)nread;\n        bufp += nread;\n    } while (count < n);\n    return ((int)count);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nvoid(perror)(char *);\n\nextern unsigned long long numCalls;\n\nlong long mread_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long v1;      // rbp, Other Possible Types: unsigned long long\n  void *v3;              // rbx, Other Possible Types: unsigned long\n  void *v4;              // rsi\n  unsigned long long v5; // rax\n\n  v1 = a1;\n  v3 = 0;\n  while ((unsigned int)v5 >= 0) {\n    a2 -= v3;\n    v4 = v1;\n    v5 = read(a0, v4, a2);\n    numCalls = numCalls + 1;\n    if (!(unsigned int)v5)\n      return v3;\n    v3 += v5;\n    v1 += v5;\n    if ((unsigned int)v3 >= (unsigned int)a2)\n      return v3;\n  }\n  perror(\"ttcp_mread_name_conflict\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmrd0lckg/mread_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpmrd0lckg/mread_name_conflict.c:32:12: error: invalid operands to binary expression\n('unsigned long' and 'void *') 32 |         a2 -= v3; |         ~~ ^  ~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/hynnet_openwrt-mt7620/feeds/packages/net/ttcp/ttcp.c"}
{"compilable":0,"function":"int testfunction(int arg1, int *arg2) {\n    return arg2[arg1];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long testfunction_name_conflict(unsigned long a0, unsigned int *a1) { return a1[a0]; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test2function(void) {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long test2function_name_conflict() { return 0; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test4function(const int arg1) {\n    return carray[arg1];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int carray;\n\nlong long test4function_name_conflict(unsigned long a0) { return (&carray)[a0]; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_duplicate_function() {\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long possibly_duplicate_function_name_conflict() { return 0; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_dupli_function() {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long possibly_dupli_function_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_char_signed(int arg) {\n    if (arg == 189) {\n        return 0;\n    } else if (arg != -67) {\n        printf(\"Hmm, it seems 'char' is not eight bits wide on your machine.\\n\");\n        printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_char_signed_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 189)\n    return 0;\n  if ((unsigned int)a0 == -67)\n    return 1;\n  puts(\"Hmm, it seems 'char' is not eight bits wide on your machine.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n}\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_shifting_signed(long arg) {\n    long res = arg >> 4;\n    if (res == -133687308L) {\n        return 1;\n    }\n    res |= (~0L) << (32 - 4);\n    if (res == -133687308L) {\n        return 0;\n    }\n    printf(\"Right shift isn't acting as I expect it to.\\n\");\n    printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_shifting_signed_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rdi\n\n  v1 = a0 >> 4;\n  if (v1 == -133687308)\n    return 1;\n  if ((v1 | -0x10000000) == -133687308)\n    return 0;\n  puts(\"Right shift isn't acting as I expect it to.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n}\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"static int pmu_can_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((5)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &arg) < 0 || arg != 1)\n        return 1;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":0,"function":"static int pmu_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((0U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), arg) < 0)\n        return 1;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":0,"function":"off_t get_sig_offset(int orig) {\n    int pagesize = sysconf(_SC_PAGESIZE);\n    return (off_t)((sizeof(char) * pagesize) - (orig ? 20 : 10));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sysconf)(int);\n\nlong long get_sig_offset_name_conflict(unsigned long a0) {\n  return sysconf(30) - ((-((unsigned int)a0 < 1) & -10) + 20);\n}\n","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-reset-swap.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  char *v4;         // rax\n\n  for (v2 = 1; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 0x100) * 19342813113834067 >> 64 >> 11) * 0x1dcd6500;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 << 4) + 8)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgr3nmcsj/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpgr3nmcsj/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpgr3nmcsj/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500; | ~~~~~~ ^  ~\n/tmp/tmpgr3nmcsj/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpgr3nmcsj/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[2]; // rbx\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *((long long *)&vocab_size) * 16 + vocab;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (60 < (unsigned int)v2)\n    v2 = 60;\n  v3 = calloc(v2, 1);\n  v1[1] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp14g50baz/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[2]' is not assignable 33 |     v1 = *((long long *)&vocab_size) * 16 +\nvocab; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  void *v2; // rcx, Other Possible Types: unsigned long\n  char *v4; // rax\n\n  for (v2 = 0; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5k8ms9k3/GetWordHash_name_conflict.c:27:22: error: invalid operands to binary\nexpression ('void *' and 'int') 27 |         v2 = v2 + v2 * 0x100 + *((char\n*)rax); |                   ~~ ^ ~~~~~ /tmp/tmp5k8ms9k3/GetWordHash_name_conflict.c:29:22:\nerror: invalid operands to binary expression ('void *' and 'int') 29 | return v2\n- ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000; | ~~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 + (v4 << 2) << 3) + 16)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpox8l8x8k/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpox8l8x8k/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpox8l8x8k/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000; | ~~~~~~ ^  ~\n/tmp/tmpox8l8x8k/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpox8l8x8k/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[3]; // rbp\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = vocab + *((long long *)&vocab_size) * 40;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (100 < (unsigned int)v2)\n    v2 = 100;\n  v3 = calloc(v2, 1);\n  v1[2] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 7) * 18764999 >> 42) * 30000000;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptki6eh47/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[3]' is not assignable 33 |     v1 = vocab + *((long long *)&vocab_size) *\n40; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_ArvoreB(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    return offset;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Busca_Recursiva_ArvoreB)(long long, long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Buscar_Registro_ArvoreB_name_conflict(char *a0, unsigned long long a1) {\n  char v0;          // [bp-0x1c]\n  char v1;          // [bp-0x1a]\n  FILE_t *v3;       // rbx\n  unsigned long v4; // rax, Other Possible Types: unsigned long long\n\n  v3 = fopen(a0, \"r+\");\n  fseek(v3, 2, 0);\n  fread(&v1, 2, 1, v3);\n  v4 = *((short *)&v1);\n  if ((unsigned short)v4) {\n    Busca_Recursiva_ArvoreB(v3, (unsigned short)v4, a1, &v0);\n    v4 = *((short *)&v0);\n    return v4;\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:16:6: error: conflicting types for\n'fseek' 16 | int (fseek)(struct FILE_t { |      ^ /usr/include/stdio.h:713:12:\nnote: previous declaration is here 713 | extern int fseek (FILE *__stream, long\nint __off, int __whence); |            ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:162:13: error: declaration of\nanonymous union must be a definition 162 |             union <anon> { | ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:169:13: error: declaration of\nanonymous union must be a definition 169 |             union <anon> { | ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:105:16: error: conflicting types for\n'fread' 105 | unsigned long (fread)(void*, unsigned long, unsigned long, struct\nFILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:231:16:\nerror: redefinition of '_IO_marker' 231 | typedef struct _IO_marker { | ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:237:16: error: redefinition of\n'_IO_codecvt' 237 | typedef struct _IO_codecvt { |                ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:241:16: error: redefinition of\n'_IO_wide_data' 241 | typedef struct _IO_wide_data { |                ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^\n/tmp/tmppyi1wrmv/Buscar_Registro_ArvoreB_name_conflict.c:264:3: error: typedef redefinition\nwith different types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 264 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Inserir_No_ArvoreB(char *arquivo, uint32_t id, uint16_t offset) {\n    uint16_t raiz;\n    uint16_t raiz_pos;\n    uint16_t nova_rrn;\n    uint16_t promo_r_child;\n    uint32_t promo_key_id;\n    uint16_t promo_key_offset;\n    uint8_t flag;\n    FILE *arq_arv;\n    no_arvore_b_t nova;\n    no_arvore_b_t raiz_a;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0) {\n        nova.n = 1;\n        nova.id[0] = id;\n        nova.offset[0] = offset;\n        nova.filhas[0] = 0;\n        nova.filhas[1] = 0;\n        nova_rrn = (Criar_Pagina(arq_arv, nova));\n        fseek(arq_arv, 2, 0);\n        fwrite(&nova_rrn, sizeof(uint16_t), 1, arq_arv);\n    } else {\n        flag = Recursive_Insertion(arq_arv, raiz, id, offset, &promo_r_child, &promo_key_id, &promo_key_offset);\n        switch (flag) {\n          case 2:\n            raiz_a.filhas[0] = raiz;\n            raiz_a.id[0] = promo_key_id;\n            raiz_a.offset[0] = promo_key_offset;\n            raiz_a.filhas[1] = promo_r_child;\n            raiz_a.n = 1;\n            raiz = Criar_Pagina(arq_arv, raiz_a);\n            fseek(arq_arv, 2, 0);\n            fwrite(&raiz, sizeof(uint16_t), 1, arq_arv);\n            break;\n          case 1:\n            break;\n          case 0:\n            break;\n        }\n    }\n    fclose(arq_arv);\n    return nova_rrn;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Recursive_Insertion)(long long, long long, long long, long long,\n                               long long, long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Inserir_No_ArvoreB_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  int tmp_33;             // tmp #33\n  int v0;                 // [bp-0xb8]\n  int v1;                 // [bp-0xa8]\n  char v2;                // [bp-0x88]\n  unsigned int v3;        // [bp-0x84]\n  char v4;                // [bp-0x78]\n  unsigned short v5;      // [bp-0x74]\n  unsigned short v6;      // [bp-0x6c]\n  unsigned short v7;      // [bp-0x6a]\n  char v8;                // [bp-0x58]\n  unsigned int v9;        // [bp-0x54]\n  char v10;               // [bp-0x48]\n  unsigned short v11;     // [bp-0x44]\n  unsigned short v12;     // [bp-0x3c]\n  unsigned short v13;     // [bp-0x3a]\n  char v14;               // [bp-0x26]\n  char v15;               // [bp-0x24]\n  char v16;               // [bp-0x1e]\n  unsigned short v17;     // [bp-0x1c]\n  unsigned short v18;     // [bp-0x1a], Other Possible Types: char\n  unsigned long long v20; // r12\n  unsigned long long v21; // rbp\n  FILE_t *v22;            // rbx\n  unsigned long long v23; // rsi\n\n  v20 = a1;\n  v21 = a2;\n  v22 = fopen(a0, \"r+\");\n  fseek(v22, 2, 0);\n  fread(&v18, 2, 1, v22);\n  v23 = *((short *)&v18);\n  if (!(unsigned short)v23) {\n    v8 = 1;\n    v9 = v20;\n    v11 = v21;\n    v12 = 0;\n    v13 = 0;\n    tmp_33 = *((int128_t *)&v8);\n    *((int128_t *)&v0) = tmp_33;\n    *((int128_t *)&v1) = *((int128_t *)&v10);\n    v17 = Criar_Pagina(v22);\n    fseek(v22, 2, 0);\n    fwrite(&v17, 2, 1, v22);\n  } else if ((char)Recursive_Insertion(v22, v23, v20, (unsigned short)v21, &v16,\n                                       &v15, &v14) == 2) {\n    v6 = *((short *)&v18);\n    v3 = *((int *)&v15);\n    v5 = *((short *)&v14);\n    v7 = *((short *)&v16);\n    v2 = 1;\n    *((int128_t *)&v0) = *((int128_t *)&v2);\n    *((int128_t *)&v1) = *((int128_t *)&v4);\n    v18 = Criar_Pagina(v22);\n    fseek(v22, 2, 0);\n    fwrite(&v18, 2, 1, v22);\n  }\n  fclose(v22);\n  return v17;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:75:13: error: declaration of anonymous\nunion must be a definition 75 |             union <anon> { |             ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:78:22: error: type name requires a\nspecifier or qualifier 78 |             } __value; |                      ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:82:13: error: declaration of anonymous\nunion must be a definition 82 |             union <anon> { |             ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:85:22: error: type name requires a\nspecifier or qualifier 85 |             } __value; |                      ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:18:6: error: conflicting types for 'fseek'\n   18 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:107:16: error: conflicting types for\n'fread' 107 | unsigned long (fread)(void*, unsigned long, unsigned long, struct\nFILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:233:16: error:\nredefinition of '_IO_marker' 233 | typedef struct _IO_marker { | ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:239:16: error: redefinition of\n'_IO_codecvt' 239 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:53:12: note: previous definition is here\n   53 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:243:16: error: redefinition of\n'_IO_wide_data' 243 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:61:12: note: previous definition is here\n   61 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:266:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 266 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:308:31: error: expected expression\n  308 |         tmp_33 = *((int128_t *)&v8);\n      |                               ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:309:22: error: expected expression\n  309 |         *((int128_t *)&v0) = tmp_33;\n      |                      ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:310:22: error: expected expression\n  310 |         *((int128_t *)&v1) = *((int128_t *)&v10);\n      |                      ^\n/tmp/tmpq0gaytn8/Inserir_No_ArvoreB_name_conflict.c:310:43: error: expected expression\n  310 |         *((int128_t *)&v1) = *((int128_t *)&v10);\n      |                                           ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint8_t Inicializar_ArvoreB(char *arquivo) {\n    FILE *nova;\n    uint16_t ped = 0;\n    uint16_t raiz = 0;\n    nova = fopen(arquivo, \"r\");\n    if (nova == ((void *)0)) {\n        nova = fopen(arquivo, \"w\");\n        if (nova == ((void *)0))\n            return 0;\n        fwrite(&ped, sizeof(uint16_t), 1, nova);\n        fwrite(&raiz, sizeof(uint16_t), 1, nova);\n        fclose(nova);\n        return 2;\n    }\n    fclose(nova);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Inicializar_ArvoreB_name_conflict(char *a0) {\n  unsigned short v0; // [bp-0xc]\n  unsigned short v1; // [bp-0xa]\n  FILE_t *v3;        // rax\n  FILE_t *v4;        // rax\n\n  v1 = 0;\n  v0 = 0;\n  v3 = fopen(a0, \"r\");\n  if (v3) {\n    fclose(v3);\n    return 1;\n  }\n  v4 = fopen(a0, \"w\");\n  if (!v4)\n    return 0;\n  fwrite(&v1, 2, 1, v4);\n  fwrite(&v0, 2, 1, v4);\n  fclose(v4);\n  return 2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp96wceonw/Inicializar_ArvoreB_name_conflict.c:85:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 85 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t POS_to_RRN(uint16_t POS) {\n    POS -= 4;\n    POS /= sizeof(no_arvore_b_t);\n    POS += 1;\n    return POS;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long POS_to_RRN_name_conflict(unsigned long a0) {\n  return (unsigned int)(((unsigned int)a0 - 4) * 52429 >> 21) + 1;\n}\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t RRN_to_POS(uint16_t RRN) {\n    --RRN;\n    RRN *= sizeof(no_arvore_b_t);\n    RRN += 4;\n    return RRN;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long RRN_to_POS_name_conflict(unsigned long a0) { return (a0 * 5 - 5) * 8 + 4; }\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Remocao_Arvore_B(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    uint16_t rrn;\n    no_arvore_b_t pagina;\n    int i;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    rrn = Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    if (rrn == 0)\n        return 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Carregar_Pagina(arq_arv, &pagina);\n    i = 0;\n    while (pagina.id[i] != id)\n        ++i;\n    pagina.offset[i] = 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Escrever_Pagina(arq_arv, pagina);\n    fclose(arq_arv);\n    return rrn;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Busca_Recursiva_ArvoreB)(long long, long long, long long, long long);\nlong long(Carregar_Pagina)(long long, long long);\nlong long(Escrever_Pagina)(long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Remocao_Arvore_B_name_conflict(char *a0, unsigned long long a1) {\n  int v0;                 // [bp-0x88]\n  int v1;                 // [bp-0x78]\n  unsigned long long v2;  // [bp-0x68]\n  char v3;                // [bp-0x58]\n  char v4;                // [bp-0x54]\n  char v5;                // [bp-0x50]\n  char v6;                // [bp-0x4c]\n  char v7;                // [bp-0x48]\n  char v8;                // [bp-0x44]\n  char v9;                // [bp-0x38]\n  char v10;               // [bp-0x2c]\n  char v11;               // [bp-0x2a]\n  FILE_t *v13;            // rbp\n  unsigned long v14;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v15; // rax\n  unsigned long v16;      // r13\n  unsigned short *v17;    // rax, Other Possible Types: unsigned long\n\n  v13 = fopen(a0, \"r+\");\n  fseek(v13, 2, 0);\n  fread(&v11, 2, 1, v13);\n  v14 = *((short *)&v11);\n  if (!(unsigned short)v14)\n    return v14;\n  v15 = Busca_Recursiva_ArvoreB(v13, (unsigned short)v14, a1, &v10);\n  v14 = v15;\n  if (!(unsigned short)v15)\n    return v15;\n  v16 = (v15 * 5 - 5) * 8 + 4;\n  fseek(v13, v16, 0);\n  Carregar_Pagina(v13, &v3);\n  v17 = 0;\n  if ((unsigned int)a1 != *((int *)&v4)) {\n    v17 = 1;\n    if ((unsigned int)a1 != *((int *)&v5))\n      v17 = ((unsigned int)a1 != *((int *)&v6)) + 2;\n  }\n  *((short *)&(&v8)[2 * v17]) = 0;\n  fseek(v13, v16, 0);\n  *((int128_t *)&v0) = *((int128_t *)&v3);\n  *((int128_t *)&v1) = *((int128_t *)&v7);\n  v2 = *((long long *)&v9);\n  Escrever_Pagina(v13);\n  fclose(v13);\n  return v14;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:31:16: error: nested redefinition of\n'_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:30:12: note: previous definition is here\n   30 |     struct _IO_marker {\n      |            ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:74:13: error: declaration of anonymous union\nmust be a definition 74 |             union <anon> { |             ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:77:22: error: type name requires a specifier\nor qualifier 77 |             } __value; |                      ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:81:13: error: declaration of anonymous union\nmust be a definition 81 |             union <anon> { |             ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:84:22: error: type name requires a specifier\nor qualifier 84 |             } __value; |                      ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:17:6: error: conflicting types for 'fseek'\n   17 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:163:13: error: declaration of anonymous\nunion must be a definition 163 |             union <anon> { |             ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:166:22: error: type name requires a\nspecifier or qualifier 166 |             } __value; |                      ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:170:13: error: declaration of anonymous\nunion must be a definition 170 |             union <anon> { |             ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:173:22: error: type name requires a\nspecifier or qualifier 173 |             } __value; |                      ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:106:16: error: conflicting types for 'fread'\n  106 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:234:16: error: redefinition of '_IO_marker'\n  234 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:30:12: note: previous definition is here\n   30 |     struct _IO_marker {\n      |            ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:240:16: error: redefinition of '_IO_codecvt'\n  240 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:52:12: note: previous definition is here\n   52 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:244:16: error: redefinition of\n'_IO_wide_data' 244 | typedef struct _IO_wide_data { |                ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:60:12: note: previous definition is here\n   60 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:267:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 267 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:309:25: error: invalid operands to binary\nexpression ('int' and 'unsigned short *') 309 |     *((short *)&(&v8)[2 * v17])\n= 0; |                       ~ ^ ~~~ /tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:311:18:\nerror: expected expression 311 |     *((int128_t *)&v0) = *((int128_t *)&v3); |\n^ /tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:311:39: error: expected expression 311 |\n*((int128_t *)&v0) = *((int128_t *)&v3); | ^\n/tmp/tmprmzubcmx/Remocao_Arvore_B_name_conflict.c:312:18: error: expected expression\n  312 |     *((int128_t *)&v1) = *((int128_t *)&v7);\n      |                  ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_Com_Indice(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    char caminho_indice[128];\n    uint16_t pos;\n    int i;\n    char c;\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    pos = Buscar_Registro_ArvoreB(caminho_indice, id);\n    if (pos != 0 && registro != ((void *)0)) {\n        arq_reg = fopen(caminho_registro, \"r\");\n        fseek(arq_reg, pos + 2, 0);\n        fread(&(registro->id), sizeof(uint32_t), 1, arq_reg);\n        fgetc(arq_reg);\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n        fclose(arq_reg);\n    }\n    return pos;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Get_Caminho_Indice)(long long, long long);\nlong long(Buscar_Registro_ArvoreB)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Buscar_Registro_Com_Indice(char *a0, unsigned long long a1,\n                                     void *a2) {\n  char v0;                // [bp-0xa8]\n  unsigned long long v2;  // rbx\n  unsigned long long v3;  // r12\n  unsigned long long v4;  // rax\n  FILE_t *v5;             // rbp\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rdx\n  void *v8;               // r13, Other Possible Types: unsigned long\n  void *v9;               // r13, Other Possible Types: unsigned long\n  unsigned long long v10; // rax\n  unsigned long long v11; // rdx\n  void *v12;              // r13, Other Possible Types: unsigned long\n  unsigned long long v13; // rax\n  unsigned long long v14; // rdx\n  void *v15;              // r13, Other Possible Types: unsigned long\n  unsigned long long v16; // rax\n  unsigned long long v17; // rdx\n\n  v2 = a2;\n  Get_Caminho_Indice(a0, &v0);\n  v3 = Buscar_Registro_ArvoreB(&v0, a1);\n  if (!(unsigned short)v3) {\n    return v3;\n  } else if (!a2) {\n    return v3;\n  } else {\n    v4 = fopen(a0, \"r\");\n    v5 = v4;\n    fseek(v4, (unsigned short)v3 + 2, 0);\n    fread(a2, 4, 1, v4);\n    fgetc(v4);\n    v8 = 0;\n    while (true) {\n      (char)v6 = fgetc(v5);\n      v7 = v8 + 1;\n      if ((char)v6 == 124)\n        break;\n      *((char *)(v2 + v7 + 3)) = v6;\n      v8 = v7;\n    }\n    *((char *)(v2 + v8 + 4)) = 0;\n    v9 = 0;\n    while (true) {\n      (char)v10 = fgetc(v5);\n      v11 = v9 + 1;\n      if ((char)v10 == 124)\n        break;\n      *((char *)(v2 + v11 + 131)) = v10;\n      v9 = v11;\n    }\n    *((char *)(v2 + v9 + 132)) = 0;\n    v12 = 0;\n    while (true) {\n      (char)v13 = fgetc(v5);\n      v14 = v12 + 1;\n      if ((char)v13 == 124)\n        break;\n      *((char *)(v2 + v14 + 387)) = v13;\n      v12 = v14;\n    }\n    *((char *)(v2 + v12 + 388)) = 0;\n    v15 = 0;\n    while (true) {\n      (char)v16 = fgetc(v5);\n      v17 = v15 + 1;\n      if ((char)v16 == 124)\n        break;\n      *((char *)(v2 + v17 + 451)) = v16;\n      v15 = v17;\n    }\n    *((char *)(v2 + v15 + 452)) = 0;\n    fclose(v5);\n    return v3;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:32:16: error: nested redefinition\nof '_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:31:12: note: previous definition\nis here 31 |     struct _IO_marker { |            ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:75:13: error: declaration of\nanonymous union must be a definition 75 |             union <anon> { | ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:78:22: error: type name requires a\nspecifier or qualifier 78 |             } __value; |                      ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:82:13: error: declaration of\nanonymous union must be a definition 82 |             union <anon> { | ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:85:22: error: type name requires a\nspecifier or qualifier 85 |             } __value; |                      ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:18:6: error: conflicting types for\n'fseek' 18 | int (fseek)(struct FILE_t { |      ^ /usr/include/stdio.h:713:12:\nnote: previous declaration is here 713 | extern int fseek (FILE *__stream, long\nint __off, int __whence); |            ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:164:13: error: declaration of\nanonymous union must be a definition 164 |             union <anon> { | ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:167:22: error: type name requires\na specifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:171:13: error: declaration of\nanonymous union must be a definition 171 |             union <anon> { | ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:174:22: error: type name requires\na specifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:107:16: error: conflicting types\nfor 'fread' 107 | unsigned long (fread)(void*, unsigned long, unsigned long,\nstruct FILE_t { |                ^ /usr/include/stdio.h:675:15: note: previous\ndeclaration is here 675 | extern size_t fread (void *__restrict __ptr, size_t\n__size, |               ^ /tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:253:13:\nerror: declaration of anonymous union must be a definition 253 | union <anon> {\n      |             ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:256:22: error: type name requires\na specifier or qualifier 256 |             } __value; |                      ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:260:13: error: declaration of\nanonymous union must be a definition 260 |             union <anon> { | ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:263:22: error: type name requires\na specifier or qualifier 263 |             } __value; |                      ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:196:6: error: conflicting types\nfor 'fgetc' 196 | int (fgetc)(struct FILE_t { |      ^\n/usr/include/stdio.h:513:12: note: previous declaration is here\n  513 | extern int fgetc (FILE *__stream);\n      |            ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:321:16: error: redefinition of\n'_IO_marker' 321 | typedef struct _IO_marker { |                ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:31:12: note: previous definition\nis here 31 |     struct _IO_marker { |            ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:327:16: error: redefinition of\n'_IO_codecvt' 327 | typedef struct _IO_codecvt { |                ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:53:12: note: previous definition\nis here 53 |     struct _IO_codecvt { |            ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:331:16: error: redefinition of\n'_IO_wide_data' 331 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp2o8u52ce/Buscar_Registro_Com_Indice.c:61:12: note: previous definition\nis here 61 |     struct _IO_wide_data { |            ^ fatal error: too many\nerrors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    uint32_t id_c;\n    uint16_t tamanho_c;\n    int tamanho_arq;\n    uint16_t retorno = 2;\n    char is_vazio;\n    int i;\n    char c;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r\");\n    fseek(arq_reg, 0, 2);\n    tamanho_arq = ftell(arq_reg);\n    fseek(arq_reg, 2, 0);\n    fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n    fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n    fseek(arq_reg, tamanho_c - 4, 1);\n    while (id_c != id && ftell(arq_reg) < tamanho_arq)\n        {\n            retorno = ftell(arq_reg);\n            fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n            is_vazio = fgetc(arq_reg);\n            if (is_vazio == '*') {\n                id_c = id + 1;\n                fseek(arq_reg, tamanho_c - 1, 1);\n            } else {\n                fseek(arq_reg, -1, 1);\n                fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n                fseek(arq_reg, tamanho_c - 4, 1);\n            }\n        }\n    if (id_c != id)\n        retorno = 0;\n    else if (registro != ((void *)0)) {\n        fseek(arq_reg, retorno + 7, 0);\n        registro->id = id_c;\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n    }\n    fclose(arq_reg);\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Abrir_arquivo)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Buscar_Registro(unsigned long long a0, unsigned long a1,\n                          unsigned int *a2) {\n  char v0;                // [bp-0x2e]\n  unsigned int v1;        // [bp-0x2c], Other Possible Types: char\n  unsigned int *v3;       // r14\n  FILE_t *v4;             // rbx\n  unsigned long v6;       // rbp, Other Possible Types: unsigned long long\n  unsigned long long v7;  // rax\n  unsigned long long v8;  // rdx\n  void *v9;               // r12, Other Possible Types: unsigned long\n  void *v10;              // r12, Other Possible Types: unsigned long\n  unsigned long long v11; // rax\n  unsigned long long v12; // rdx\n  void *v13;              // r12, Other Possible Types: unsigned long\n  unsigned long long v14; // rax\n  unsigned long long v15; // rdx\n  void *v16;              // r12, Other Possible Types: unsigned long\n  unsigned long long v17; // rax\n  unsigned long long v18; // rdx\n\n  v3 = a2;\n  v4 = Abrir_arquivo(a0, \"r\");\n  fseek(v4, 0, 2);\n  fseek(v4, 2, 0);\n  fread(&v0, 2, 1, v4);\n  fread(&v1, 4, 1, v4);\n  fseek(v4, *((short *)&v0) - 4, 1);\n  v6 = 2;\n  if ((unsigned int)a1 != *((int *)&v1)) {\n    do {\n      if (ftell(v4) >= ftell(v4)) {\n        if (v1 != (unsigned int)a1) {\n        LABEL_402165:\n          fclose(v4);\n          return 0;\n        }\n        break;\n      }\n      v6 = ftell(v4);\n      fread(&v0, 2, 1, v4);\n      if ((char)fgetc(v4) == 42) {\n        v1 = (unsigned int)a1 + 1;\n        fseek(v4, *((short *)&v0) - 1, 1);\n      } else {\n        fseek(v4, -1, 1);\n        fread(&v1, 4, 1, v4);\n        fseek(v4, *((short *)&v0) - 4, 1);\n      }\n    } while (v1 != (unsigned int)a1);\n  }\n  if (!a2) {\n    fclose(v4);\n    return v6;\n  }\n  fseek(v4, (unsigned short)v6 + 7, 0);\n  *(a2) = v1;\n  v9 = 0;\n  while (true) {\n    (char)v7 = fgetc(v4);\n    v8 = v9 + 1;\n    if ((char)v7 == 124)\n      break;\n    *(3 + (char *)v3 + v8) = v7;\n    v9 = v8;\n  }\n  *(4 + (char *)v3 + v9) = 0;\n  v10 = 0;\n  while (true) {\n    (char)v11 = fgetc(v4);\n    v12 = v10 + 1;\n    if ((char)v11 == 124)\n      break;\n    *(131 + (char *)v3 + v12) = v11;\n    v10 = v12;\n  }\n  *(132 + (char *)v3 + v10) = 0;\n  v13 = 0;\n  while (true) {\n    (char)v14 = fgetc(v4);\n    v15 = v13 + 1;\n    if ((char)v14 == 124)\n      break;\n    *(387 + (char *)v3 + v15) = v14;\n    v13 = v15;\n  }\n  *(388 + (char *)v3 + v13) = 0;\n  v16 = 0;\n  while (true) {\n    (char)v17 = fgetc(v4);\n    v18 = v16 + 1;\n    if ((char)v17 == 124)\n      break;\n    *(451 + (char *)v3 + v18) = v17;\n    v16 = v18;\n  }\n  *(452 + (char *)v3 + v16) = 0;\n  goto LABEL_402165;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:31:16: error: nested redefinition of\n'_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:30:12: note: previous definition is here\n   30 |     struct _IO_marker {\n      |            ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:74:13: error: declaration of anonymous union\nmust be a definition 74 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:77:22: error: type name requires a specifier\nor qualifier 77 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:81:13: error: declaration of anonymous union\nmust be a definition 81 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:84:22: error: type name requires a specifier\nor qualifier 84 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:17:6: error: conflicting types for 'fseek'\n   17 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:163:13: error: declaration of anonymous union\nmust be a definition 163 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:166:22: error: type name requires a specifier\nor qualifier 166 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:170:13: error: declaration of anonymous union\nmust be a definition 170 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:173:22: error: type name requires a specifier\nor qualifier 173 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:106:7: error: conflicting types for 'ftell'\n  106 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:252:13: error: declaration of anonymous union\nmust be a definition 252 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:255:22: error: type name requires a specifier\nor qualifier 255 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:259:13: error: declaration of anonymous union\nmust be a definition 259 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:262:22: error: type name requires a specifier\nor qualifier 262 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:195:16: error: conflicting types for 'fread'\n  195 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:341:13: error: declaration of anonymous union\nmust be a definition 341 |             union <anon> { |             ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:344:22: error: type name requires a specifier\nor qualifier 344 |             } __value; |                      ^\n/tmp/tmp5m3qc7nd/Buscar_Registro.c:348:13: error: declaration of anonymous union\nmust be a definition 348 |             union <anon> { |             ^ fatal\nerror: too many errors emitted, stopping now [-ferror-limit=] 20 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Calcular_Tamanho(registro_t registro) {\n    uint16_t retorno = 0;\n    retorno += 5;\n    retorno += sizeof(uint32_t);\n    retorno += strlen(registro.autor);\n    retorno += strlen(registro.titulo);\n    retorno += strlen(registro.curso);\n    retorno += strlen(registro.tipo);\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long Calcular_Tamanho_name_conflict() {\n  unsigned long v0;      // [bp+0x8]\n  char v1;               // [bp+0x8c]\n  char v2;               // [bp+0x18c]\n  char v3;               // [bp+0x1cc]\n  unsigned long long v5; // rbx\n\n  v5 = strlen(&v0) + strlen(&v1) + 9 + strlen(&v2);\n  return strlen(&v3) + v5;\n}\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Inserir_Registro(char *caminho_registro, registro_t registro) {\n    FILE *arq_reg;\n    uint16_t first_led;\n    uint16_t nova_first_led;\n    uint16_t tamanho, tamanho_first_led, tamanho_novo_branco;\n    int retorno;\n    char caminho_indice[128];\n    tamanho = Calcular_Tamanho(registro);\n    tamanho_first_led = 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, 0, 0);\n    fread(&first_led, sizeof(uint16_t), 1, arq_reg);\n    if (first_led != 0) {\n        fseek(arq_reg, first_led, 0);\n        fread(&tamanho_first_led, sizeof(uint16_t), 1, arq_reg);\n    }\n    if (first_led == 0 || tamanho_first_led < tamanho)\n        retorno = Inserir_Registro_Final(arq_reg, registro);\n    else {\n        fgetc(arq_reg);\n        fread(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, 0, 0);\n        fwrite(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, first_led, 0);\n        tamanho_novo_branco = tamanho_first_led - tamanho - 2;\n        if (tamanho_novo_branco > 8) {\n            fwrite(&tamanho_novo_branco, sizeof(uint16_t), 1, arq_reg);\n            Inserir_ED(arq_reg, first_led);\n            fseek(arq_reg, first_led + 2 + tamanho_novo_branco, 0);\n        } else\n            tamanho = tamanho_first_led;\n        retorno = ftell(arq_reg);\n        fwrite(&tamanho, sizeof(uint16_t), 1, arq_reg);\n        fwrite(&(registro.id), sizeof(uint32_t), 1, arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.autor, sizeof(char), strlen(registro.autor), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.titulo, sizeof(char), strlen(registro.titulo), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.curso, sizeof(char), strlen(registro.curso), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.tipo, sizeof(char), strlen(registro.tipo), arq_reg);\n        fputc('|', arq_reg);\n    }\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Inserir_No_ArvoreB(caminho_indice, registro.id, (uint16_t)(retorno));\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Calcular_Tamanho)();\nlong long(Abrir_arquivo)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(Inserir_Registro_Final)(long long, long long, long long, long long,\n                                  long long, long long, char);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(Get_Caminho_Indice)(long long, long long);\nlong long(Inserir_No_ArvoreB)(long long, long long, long long);\nlong long(Inserir_ED)(long long, long long);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Inserir_Registro(unsigned long a0, unsigned long a1, unsigned long a2,\n                           unsigned long a3, unsigned long long a4,\n                           unsigned long long a5, char v7) {\n  char v0;                // [bp-0x2a8], Other Possible Types: unsigned long\n  char v1;                // [bp-0xb8]\n  unsigned short v2;      // [bp-0x32]\n  unsigned short v3;      // [bp-0x30]\n  unsigned short v4;      // [bp-0x2e]\n  char v5;                // [bp-0x2c]\n  char v6;                // [bp-0x2a]\n  char v8;                // [bp+0x8c]\n  char v9;                // [bp+0x18c]\n  char v10;               // [bp+0x1cc]\n  unsigned long long v11; // rbp\n  unsigned long v12;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v13;          // rsi, Other Possible Types: unsigned long\n  unsigned long v14;      // d\n  struct_0 *v15;          // rdi, Other Possible Types: unsigned long\n  FILE_t *v16;            // rbx\n  unsigned long v17;      // rsi\n  unsigned long v18;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v19;          // rdi, Other Possible Types: unsigned long\n  struct_0 *v20;          // rsi, Other Possible Types: unsigned long\n  unsigned long v21;      // r12, Other Possible Types: unsigned long long\n\n  v11 = a0;\n  v12 = 60;\n  v15 = &v0;\n  for (v13 = &v7; v12; v13 += v14 * 8) {\n    v12 -= 1;\n    *((long long *)v15) = *((long long *)v13);\n    v15 += v14 * 8;\n  }\n  *((int *)v15) = *((int *)v13);\n  v4 = Calcular_Tamanho();\n  v3 = 0;\n  v16 = Abrir_arquivo(v11, \"r+\");\n  fseek(v16, 0, 0);\n  fread(&v6, 2, 1, v16);\n  v17 = *((short *)&v6);\n  if (!(unsigned short)v17) {\n  LABEL_4022af:\n    v18 = 60;\n    v19 = &v0;\n    for (v20 = &v7; v18; v20 += v14 * 8) {\n      v18 -= 1;\n      *((long long *)v19) = *((long long *)v20);\n      v19 += v14 * 8;\n    }\n    *((int *)v19) = *((int *)v20);\n    v21 = Inserir_Registro_Final(v16, v20, 1, v18, a4, a5, v0);\n  } else {\n    fseek(v16, v17, 0);\n    fread(&v3, 2, 1, v16);\n    if (!(*((short *)&v6)) ||\n        !(!((char)[D] amd64g_calculate_condition(\n            0x2 < 64 >, 0x6 < 64 >,\n            Conv(16->64,\n                 Load(addr = stack_base - 48, size = 2, endness = Iend_LE)),\n            Conv(16->64,\n                 Load(addr = stack_base - 46, size = 2, endness = Iend_LE)),\n            cc_ndep))))\n      goto LABEL_4022af;\n    fgetc(v16);\n    fread(&v5, 2, 1, v16);\n    fseek(v16, 0, 0);\n    fwrite(&v5, 2, 1, v16);\n    fseek(v16, *((short *)&v6), 0);\n    v2 = v4 - 2 - v4;\n    if (v2 << 48 <= 0x8000000000000) {\n      v4 = v3;\n    } else {\n      fwrite(&v2, 2, 1, v16);\n      Inserir_ED(v16, *((short *)&v6));\n      fseek(v16, *((short *)&v6) + v2 + 2, 0);\n    }\n    v21 = ftell(v16);\n    fwrite(&v4, 2, 1, v16);\n    fwrite(&v7, 4, 1, v16);\n    fputc(124, v16);\n    fwrite(&v7, 1, strlen(&v7), v16);\n    fputc(124, v16);\n    fwrite(&v8, 1, strlen(&v8), v16);\n    fputc(124, v16);\n    fwrite(&v9, 1, strlen(&v9), v16);\n    fputc(124, v16);\n    fwrite(&v10, 1, strlen(&v10), v16);\n    fputc(124, v16);\n  }\n  fclose(v16);\n  Get_Caminho_Indice(v11, &v1);\n  Inserir_No_ArvoreB(&v1, (unsigned int)v7, (unsigned short)v21);\n  return v21;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:18:6: error: conflicting types for 'fseek'\n   18 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:164:13: error: declaration of anonymous\nunion must be a definition 164 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:167:22: error: type name requires a\nspecifier or qualifier 167 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:171:13: error: declaration of anonymous\nunion must be a definition 171 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:174:22: error: type name requires a\nspecifier or qualifier 174 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:107:16: error: conflicting types for 'fread'\n  107 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:254:13: error: declaration of anonymous\nunion must be a definition 254 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:257:22: error: type name requires a\nspecifier or qualifier 257 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:261:13: error: declaration of anonymous\nunion must be a definition 261 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:264:22: error: type name requires a\nspecifier or qualifier 264 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:197:6: error: conflicting types for 'fgetc'\n  197 | int (fgetc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:513:12: note: previous declaration is here\n  513 | extern int fgetc (FILE *__stream);\n      |            ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:346:13: error: declaration of anonymous\nunion must be a definition 346 |             union <anon> { |             ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:349:22: error: type name requires a\nspecifier or qualifier 349 |             } __value; |                      ^\n/tmp/tmpp5g0v6wm/Inserir_Registro.c:353:13: error: declaration of anonymous\nunion must be a definition 353 |             union <anon> { |             ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Remover_Registro(char *caminho_registro, uint32_t id) {\n    FILE *arq_reg;\n    uint16_t posicao;\n    char asteristico = '*';\n    char caminho_indice[128];\n    posicao = Buscar_Registro_Com_Indice(caminho_registro, id, ((void *)0));\n    if (posicao == 0)\n        return 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, posicao + 2, 0);\n    fwrite(&asteristico, sizeof(char), 1, arq_reg);\n    Inserir_ED(arq_reg, posicao);\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Remocao_Arvore_B(caminho_indice, id);\n    return posicao;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Buscar_Registro_Com_Indice)(long long, long long, long long);\nlong long(Abrir_arquivo)(long long, long long);\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong long(Inserir_ED)(long long, long long);\nlong long(Get_Caminho_Indice)(long long, long long);\nlong long(Remocao_Arvore_B)(long long, long long);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Remover_Registro_name_conflict(unsigned long long a0, unsigned long long a1) {\n  char v0;               // [bp-0xb8]\n  char v1;               // [bp-0x29]\n  unsigned long long v3; // rbx\n  FILE_t *v4;            // rax\n  unsigned long long v5; // r14\n\n  v1 = 42;\n  v3 = Buscar_Registro_Com_Indice(a0, a1, 0);\n  if ((unsigned short)v3) {\n    v4 = Abrir_arquivo(a0, \"r+\");\n    v5 = (unsigned short)v3;\n    fseek(v4, v5 + 2, 0);\n    fwrite(&v1, 1, 1, v4);\n    Inserir_ED(v4, v5);\n    fclose(v4);\n    Get_Caminho_Indice(a0, &v0);\n    Remocao_Arvore_B(&v0, a1);\n    return v3;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:18:6: error: conflicting types for 'fseek'\n   18 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:146:16: error: redefinition of '_IO_marker'\n  146 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:152:16: error: redefinition of '_IO_codecvt'\n  152 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:53:12: note: previous definition is here\n   53 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:156:16: error: redefinition of\n'_IO_wide_data' 156 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:61:12: note: previous definition is here\n   61 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp33y91604/Remover_Registro_name_conflict.c:179:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 179 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"registro_t String_to_reg(char *cadeia) {\n    registro_t retorno;\n    char *campo;\n    if (cadeia == ((void *)0)) {\n        printf(\"Erro ao converter arquivo de catalogo: linha vazia!\\n\");\n        retorno.id = 0;\n        return retorno;\n    }\n    campo = strtok(cadeia, \";\");\n    retorno.id = (uint32_t)(atoi(campo));\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.autor, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.titulo, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.curso, campo + 1);\n    campo = strtok(((void *)0), \"\\r\");\n    strcpy(retorno.tipo, campo + 1);\n    return retorno;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok)(char *, char *);\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n  char padding_8[468];\n  unsigned long long field_1dc;\n} struct_0;\n\nlong long String_to_reg_name_conflict(struct_0 *a0, char *a1) {\n  unsigned int v0;         // [bp-0x208]\n  char v1;                 // [bp-0x204]\n  char v2;                 // [bp-0x184]\n  char v3;                 // [bp-0x84]\n  char v4;                 // [bp-0x44]\n  char v5;                 // [bp-0x2c]\n  struct_0 *v7;            // rbx\n  unsigned long long *v8;  // rdi, Other Possible Types: unsigned long\n  unsigned long long v9;   // rcx\n  unsigned long v11;       // d\n  unsigned long v12;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v13; // rsi, Other Possible Types: unsigned long\n\n  v7 = a0;\n  if (!a1) {\n    puts(\"Erro ao converter arquivo de catalogo: linha vazia!\");\n    v0 = 0;\n  } else {\n    v0 = strtol(strtok(a1, \";\"), NULL, 10);\n    strcpy(&v1, strtok(NULL, \";\") + 1);\n    strcpy(&v2, strtok(NULL, \";\") + 1);\n    strcpy(&v3, strtok(NULL, \";\") + 1);\n    strcpy(&v4, strtok(NULL, \"\\r\") + 1);\n  }\n  a0->field_0 = *((long long *)&v0);\n  *((long long *)&(&a0->padding_8)[1]) = *((long long *)&v5);\n  v8 = &a0->padding_8 & -8;\n  v9 = v7 - v8;\n  v13 = (char *)&v0 - v9;\n  for (v12 = ((unsigned int)v9 + 484) / 8; v12; v13 += v11 * 8) {\n    v12 -= 1;\n    *((long long *)v8) = *((long long *)v13);\n    v8 += v11 * 8;\n  }\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf6sn9337/String_to_reg_name_conflict.c:55:25: error: invalid operands to binary\nexpression ('char (*)[468]' and 'int') 55 |     v8 = &a0->padding_8 & -8; |\n~~~~~~~~~~~~~~ ^ ~~ /tmp/tmpf6sn9337/String_to_reg_name_conflict.c:56:13: error: 'struct_0 *'\n(aka 'struct struct_0 *') and 'unsigned long long *' are not pointers to\ncompatible types 56 |     v9 = v7 - v8; |          ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Importar_arquivo_catalogo(char *caminho_catalogo, char *caminho_registro) {\n    char leitura[1024];\n    char c;\n    int i;\n    int n_reg = 0;\n    registro_t lido;\n    FILE *catalogo;\n    catalogo = Abrir_arquivo(caminho_catalogo, \"r\");\n    while (1)\n        {\n            i = 0;\n            while ((c = fgetc(catalogo)) != '\\n' && c != (-1))\n                {\n                    leitura[i] = c;\n                    ++i;\n                }\n            leitura[i] = '\\x00';\n            if (strlen(leitura) < 4)\n                break;\n            lido = String_to_reg(leitura);\n            i = Inserir_Registro(caminho_registro, lido);\n            printf(\"Inserido registro na posicao %d do arquivo.\\n\", i);\n            ++n_reg;\n        }\n    fclose(catalogo);\n    return n_reg;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Abrir_arquivo)(long long, long long);\nint(fgetc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nlong long(String_to_reg)(long long, long long);\nlong long(Inserir_Registro)(long long, long long, long long, long long,\n                            long long, long long, char);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long Importar_arquivo_catalogo(unsigned long long a0, unsigned long a1,\n                                    unsigned long long a2, unsigned long a3,\n                                    unsigned long long a4,\n                                    unsigned long long a5) {\n  char v0;                // [bp-0x1f0]\n  unsigned long v1;       // [bp-0x28]\n  unsigned long v2;       // [bp-0x18]\n  unsigned long v3;       // [bp-0x10]\n  unsigned long v4;       // [bp-0x8]\n  char v5;                // [bp+0x0]\n  char v7;                // [bp+0x1f0]\n  char v8;                // [bp+0x5f0]\n  char v9;                // [bp+0x600]\n  char v10;               // [bp+0x608]\n  char v11;               // [bp+0x610]\n  unsigned long v12;      // r14\n  unsigned long v13;      // r13\n  unsigned long v14;      // r12\n  unsigned long v15;      // rbx\n  FILE_t *v17;            // rbp\n  void *v18;              // r12\n  unsigned long long v19; // rax\n  struct_0 *v20;          // rbx, Other Possible Types: unsigned long\n  unsigned long v21;      // rcx, Other Possible Types: unsigned long long\n  unsigned int *v22;      // rdi, Other Possible Types: unsigned long\n  struct_0 *v23;          // rsi, Other Possible Types: unsigned long\n  unsigned long v24;      // d\n  unsigned long long v25; // r12\n  unsigned long long v27; // rbx\n  unsigned long long v28; // r12\n  unsigned long long v29; // r13\n  unsigned long long v30; // r14\n\n  v4 = v12;\n  v3 = v13;\n  v2 = v14;\n  v1 = v15;\n  v17 = Abrir_arquivo(a0, \"r\");\n  v18 = 0;\n  while (true) {\n    v20 = 0;\n    while (true) {\n      (char)v19 = fgetc(v17);\n      if (!((char)v19 != 255) || !((char)v19 != 10))\n        break;\n      (&v7)[v20] = v19;\n      v20 += 1;\n    }\n    (&v7)[v20] = 0;\n    if (strlen(&v7) <= 3)\n      break;\n    String_to_reg(&v5, &v7);\n    v21 = 60;\n    v22 = &v0;\n    for (v23 = &v5; v21; v23 += v24 * 8) {\n      v21 -= 1;\n      *((long long *)v22) = *((long long *)v23);\n      v22 += v24 * 8;\n    }\n    *((int *)v22) = *((int *)v23);\n    printf(\"Inserido registro na posicao %d do arquivo.\\n\",\n           (int)Inserir_Registro(a1, v23, a2, v21, a4, a5, v5));\n    v25 = (unsigned int)v18 + 1;\n  }\n  fclose(v17);\n  v27 = *((long long *)&v8);\n  v28 = *((long long *)&v9);\n  v29 = *((long long *)&v10);\n  v30 = *((long long *)&v11);\n  return v18;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:31:16: error: nested redefinition\nof '_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:30:12: note: previous definition is\nhere 30 |     struct _IO_marker { |            ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:74:13: error: declaration of\nanonymous union must be a definition 74 |             union <anon> { | ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:77:22: error: type name requires a\nspecifier or qualifier 77 |             } __value; |                      ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:81:13: error: declaration of\nanonymous union must be a definition 81 |             union <anon> { | ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:84:22: error: type name requires a\nspecifier or qualifier 84 |             } __value; |                      ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:17:6: error: conflicting types for\n'fgetc' 17 | int (fgetc)(struct FILE_t { |      ^ /usr/include/stdio.h:513:12:\nnote: previous declaration is here 513 | extern int fgetc (FILE *__stream); | ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:148:16: error: redefinition of\n'_IO_marker' 148 | typedef struct _IO_marker { |                ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:30:12: note: previous definition is\nhere 30 |     struct _IO_marker { |            ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:154:16: error: redefinition of\n'_IO_codecvt' 154 | typedef struct _IO_codecvt { |                ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:52:12: note: previous definition is\nhere 52 |     struct _IO_codecvt { |            ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:158:16: error: redefinition of\n'_IO_wide_data' 158 | typedef struct _IO_wide_data { |                ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:60:12: note: previous definition is\nhere 60 |     struct _IO_wide_data { |            ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:181:3: error: typedef redefinition\nwith different types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 181 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:225:13: error: assignment to cast\nis illegal, lvalue casts are not supported 225 |             (char)v19 =\nfgetc(v17); |             ^~~~~~~~~ ~\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:228:18: error: array subscript is\nnot an integer 228 |             (&v7)[v20] = v19; |                  ^~~~\n/tmp/tmp573cu4t3/Importar_arquivo_catalogo.c:231:14: error: array subscript is\nnot an integer 231 |         (&v7)[v20] = 0; |              ^~~~ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"static unsigned char *option_find1(unsigned char *p, unsigned char *end, int opt, int minsize) {\n    while (*p != 255)\n        {\n            if (p >= end)\n                return ((void *)0);\n            else if (*p == 0)\n                p++;\n            else {\n                int opt_len;\n                if (p >= end - 2)\n                    return ((void *)0);\n                opt_len = ((int)(((unsigned char *)(p))[1]));\n                if (p >= end - (2 + opt_len))\n                    return ((void *)0);\n                if (*p == opt && opt_len >= minsize)\n                    return p;\n                p += opt_len + 2;\n            }\n        }\n    return opt == 255 ? p : ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long option_find1(char a0[2], unsigned long a1, unsigned long a2,\n                       unsigned long a3) {\n  char v1[2];            // rax, Other Possible Types: unsigned long\n  unsigned long long v2; // r9\n  unsigned long long v3; // rdi\n  unsigned long v4;      // r10\n  unsigned long v5;      // rsi, Other Possible Types: unsigned long long\n\n  v1 = a0;\n  v2 = a1;\n  v5 = a0[0];\n  if ((char)v5 != 255) {\n    if (a0 >= v2)\n      return 0;\n    while (true) {\n      if (!(char)v5) {\n        v1 += 1;\n      } else {\n        if (v1 >= v2 - 2)\n          return 0;\n        v3 = *((char *)(v1 + 1));\n        v4 = (char)v3;\n        if (v1 >= v2 - (v4 + 2))\n          return 0;\n        if ((unsigned int)v4 >= (unsigned int)a3 &&\n            (unsigned int)v5 == (unsigned int)a2)\n          return v1;\n        v1 = v1 + v3 + 2;\n      }\n      v5 = *((char *)v1);\n      if ((char)v5 == 255)\n        break;\n      if (v1 >= v2)\n        return 0;\n    }\n  }\n  if ((unsigned int)a2 == 255)\n    return v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphukrb3r4/option_find1.c:25:8: error: array type 'char[2]' is not\nassignable 25 |     v1 = a0; |     ~~ ^ /tmp/tmphukrb3r4/option_find1.c:36:20:\nerror: invalid operands to binary expression ('char[2]' and 'int') 36 | v1 += 1;\n      |                 ~~ ^  ~\n/tmp/tmphukrb3r4/option_find1.c:48:20: error: array type 'char[2]' is not\nassignable 48 |                 v1 = v1 + v3 + 2; |                 ~~ ^ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static unsigned char *option_find(struct dhcp_packet *mess, size_t size, int opt_type, int minsize) {\n    unsigned char *ret, *overload;\n    if ((ret = option_find1(&mess->options[0], ((unsigned char *)mess) + size, opt_type, minsize)))\n        return ret;\n    if (!(overload = option_find1(&mess->options[0], ((unsigned char *)mess) + size, 52, 1)))\n        return ((void *)0);\n    if ((overload[2] & 1) && (ret = option_find1(&mess->file[0], &mess->file[128], opt_type, minsize)))\n        return ret;\n    if ((overload[2] & 2) && (ret = option_find1(&mess->sname[0], &mess->sname[64], opt_type, minsize)))\n        return ret;\n    return ((void *)0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static unsigned int option_uint(unsigned char *opt, int size) {\n    unsigned int ret = 0;\n    int i;\n    unsigned char *p = ((void *)&(((unsigned char *)(opt))[2]));\n    for (i = 0; i < size; i++)\n        ret = (ret << 8) | *p++;\n    return ret;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static ssize_t netlink_recv(int fd) {\n    struct msghdr msg;\n    ssize_t rc;\n    msg.msg_control = ((void *)0);\n    msg.msg_controllen = 0;\n    msg.msg_name = ((void *)0);\n    msg.msg_namelen = 0;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    while (1)\n        {\n            msg.msg_flags = 0;\n            while ((rc = recvmsg(fd, &msg, MSG_PEEK)) == -1 && (*__errno_location()) == 4)\n                ;\n            if (rc == -1 && (*__errno_location()) == 95) {\n                if (!expand_buf(&iov, 2000))\n                    return -1;\n                break;\n            }\n            if (rc == -1 || !(msg.msg_flags & MSG_TRUNC))\n                break;\n            if (!expand_buf(&iov, iov.iov_len + 100))\n                return -1;\n        }\n    while ((rc = recvmsg(fd, &msg, 0)) == -1 && (*__errno_location()) == 4)\n        ;\n    return rc;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static int parse_hex(char *in, unsigned char *out, int maxlen, int *mac_type) {\n    int i = 0;\n    char *r;\n    if (mac_type)\n        *mac_type = 0;\n    while (maxlen == -1 || i < maxlen)\n        {\n            for (r = in; *r != 0 && *r != ':' && *r != '-'; r++)\n                ;\n            if (*r == 0)\n                maxlen = i;\n            if (r != in) {\n                if (*r == '-' && i == 0 && mac_type) {\n                    *r = 0;\n                    *mac_type = strtol(in, ((void *)0), 16);\n                    mac_type = ((void *)0);\n                } else {\n                    *r = 0;\n                    out[i] = strtol(in, ((void *)0), 16);\n                    i++;\n                }\n            }\n            in = r + 1;\n        }\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long parse_hex(char *a0, unsigned long a1, unsigned long a2,\n                    unsigned int *a3) {\n  unsigned long long v0; // [bp-0x158]\n  unsigned int v2;       // r13d\n  unsigned int *v3;      // r14, Other Possible Types: unsigned long, void*\n  char *v4;              // rbx, Other Possible Types: unsigned long\n  char v5;               // al\n  unsigned long v6;      // r12\n\n  v2 = a2;\n  v3 = a3;\n  if (a3)\n    *(a3) = 0;\n  if ((unsigned int)a2 != -1 && (unsigned int)a2 <= 0)\n    return 0;\n  v6 = 0;\n  do {\n    while (true) {\n      v5 = *((char *)a0);\n      if (v5 <= 58) {\n        v4 = a0;\n        v0 = 288265560523800577;\n        if (!((*((char *)&v0 + ((*((char *)a0) & 63) >> 3)) >>\n                   (*((char *)a0) & 63 & 7) &\n               1 & 1)))\n          continue;\n        if (!v5) {\n          v4 = a0;\n          v2 = v6;\n          continue;\n        }\n      } else {\n        v4 = a0;\n        do {\n          v4 += 1;\n          v5 = *((char *)v4);\n        } while (v5 > 58);\n        v0 = 288265560523800577;\n        if (!v5) {\n          v2 = v6;\n          if (v4 != a0)\n            *((char *)v4) = 0;\n        }\n      }\n      if (v4 != a0) {\n        if (v5 != 45 || (unsigned int)v6 || !v3) {\n          *((char *)v4) = 0;\n          *((char *)(a1 + v6)) = strtol(a0, NULL, 16);\n          v6 = (unsigned int)v6 + 1;\n        } else {\n          *((char *)v4) = 0;\n          *((int *)v3) = strtol(a0, NULL, 16);\n          v3 = 0;\n        }\n      }\n      a0 = v4 + 1;\n      if (v2 != -1)\n        break;\n    }\n  } while ((unsigned int)v6 < v2);\n  return v6;\n}\n","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask) {\n    return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static struct in_addr find_interface(struct in_addr client, int fd, unsigned int index) {\n    struct sockaddr_nl addr;\n    struct nlmsghdr *h;\n    ssize_t len;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg g;\n    } req;\n    addr.nl_family = 16;\n    addr.nl_pad = 0;\n    addr.nl_groups = 0;\n    addr.nl_pid = 0;\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETADDR;\n    req.nlh.nlmsg_flags = 256 | 512 | 1 | 4;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = 1;\n    req.g.rtgen_family = 2;\n    if (sendto(fd, (void *)&req, sizeof (req), 0, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        perror(\"sendto failed\");\n        exit(1);\n    }\n    while (1)\n        {\n            if ((len = netlink_recv(fd)) == -1) {\n                perror(\"netlink\");\n                exit(1);\n            }\n            for (h = (struct nlmsghdr *)iov.iov_base; (((size_t)len) >= (int)sizeof(struct nlmsghdr) && (h)->nlmsg_len >= sizeof(struct nlmsghdr) && (h)->nlmsg_len <= ((size_t)len)); h = ((len) -= ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(h)) + ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)))))\n                if (h->nlmsg_type == 3)\n                    exit(0);\n                else if (h->nlmsg_type == RTM_NEWADDR) {\n                    struct ifaddrmsg *ifa = ((void *)(((char *)h) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    struct rtattr *rta;\n                    unsigned int len1 = h->nlmsg_len - ((sizeof (*ifa)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n                    if (ifa->ifa_index == index && ifa->ifa_family == 2) {\n                        struct in_addr netmask, addr;\n                        netmask.s_addr = htonl(4294967295U << (32 - ifa->ifa_prefixlen));\n                        addr.s_addr = 0;\n                        for (rta = ((struct rtattr *)(((char *)(ifa)) + (((sizeof(struct ifaddrmsg)) + 4U - 1) & ~(4U - 1)))); ((len1) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len1)); rta = ((len1) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n                            if (rta->rta_type == IFA_LOCAL)\n                                addr = *((struct in_addr *)(rta + 1));\n                        if (addr.s_addr && is_same_net(addr, client, netmask))\n                            return addr;\n                    }\n                }\n        }\n    exit(0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"int output(char *filename) {\n    FILE *fp;\n    char str[64];\n    if ((fp = fopen(filename, \"r\")) == ((void *)0)) {\n        printf(\"Cannot open file %s.\\n\", filename);\n        return 1;\n    }\n    while (!feof(fp))\n        {\n            if (fgets(str, 128, fp)) {\n                printf(\"%s\", str);\n            }\n        }\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(feof)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long output(char *a0) {\n  char v0;    // [bp-0x58]\n  FILE_t *v3; // rax\n\n  v3 = fopen(a0, \"r\");\n  if (!v3) {\n    printf(\"Cannot open file %s.\\n\", (unsigned int)a0);\n    return 1;\n  }\n  while (true) {\n    if (feof(v3)) {\n      fclose(v3);\n      return 0;\n    } else if (fgets(&v0, 128, v3)) {\n      printf(\"%s\", (unsigned int)&v0);\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfxx1xpwq/output.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpfxx1xpwq/output.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpfxx1xpwq/output.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpfxx1xpwq/output.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpfxx1xpwq/output.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpfxx1xpwq/output.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpfxx1xpwq/output.c:16:6: error: conflicting types for 'feof'\n   16 | int (feof)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:788:12: note: previous declaration is here\n  788 | extern int feof (FILE *__stream) __THROW __wur;\n      |            ^\n/tmp/tmpfxx1xpwq/output.c:162:13: error: declaration of anonymous union must be\na definition 162 |             union <anon> { |             ^\n/tmp/tmpfxx1xpwq/output.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmpfxx1xpwq/output.c:169:13: error: declaration of anonymous union must be\na definition 169 |             union <anon> { |             ^\n/tmp/tmpfxx1xpwq/output.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmpfxx1xpwq/output.c:105:8: error: conflicting types for 'fgets'\n  105 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpfxx1xpwq/output.c:230:16: error: redefinition\nof '_IO_marker' 230 | typedef struct _IO_marker { |                ^\n/tmp/tmpfxx1xpwq/output.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpfxx1xpwq/output.c:236:16: error: redefinition of '_IO_codecvt'\n  236 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpfxx1xpwq/output.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpfxx1xpwq/output.c:240:16: error: redefinition of '_IO_wide_data'\n  240 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpfxx1xpwq/output.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpfxx1xpwq/output.c:263:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 263 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lazyparser_honggfuzz/examples/targets/badcode1.c"}
{"compilable":0,"function":"int askCharQuestion(char *question) {\n    char answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %c\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askCharQuestion_name_conflict(unsigned long a0) {\n  char v0; // [bp-0x9]\n\n  v0 = 0;\n  printf(\"%s\\n> \", (unsigned int)a0);\n  __isoc99_scanf(\" %c\", (unsigned int)&v0);\n  fflush(stdin @GLIBC_2.2.5);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpemajmzn6/askCharQuestion_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpemajmzn6/askCharQuestion_name_conflict.c:18:21: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpemajmzn6/askCharQuestion_name_conflict.c:27:17: error: expected ')'\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |                 ^\n/tmp/tmpemajmzn6/askCharQuestion_name_conflict.c:27:11: note: to match this '('\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int askIntQuestion(char *question) {\n    int answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %i\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askIntQuestion_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  printf(\"%s\\n> \", (unsigned int)a0);\n  __isoc99_scanf(\" %i\", (unsigned int)&v0);\n  fflush(stdin @GLIBC_2.2.5);\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgnwgiq6g/askIntQuestion_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpgnwgiq6g/askIntQuestion_name_conflict.c:18:21: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpgnwgiq6g/askIntQuestion_name_conflict.c:27:17: error: expected ')'\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |                 ^\n/tmp/tmpgnwgiq6g/askIntQuestion_name_conflict.c:27:11: note: to match this '('\n   27 |     fflush(stdin@GLIBC_2.2.5);\n      |           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"short askBoolQuestion(char *question) {\n    int response = -1;\n    do {\n        printf(\"%s\\n> \", question);\n        scanf(\" %i\", &response);\n        fflush(stdin);\n        if (response < 0 || response > 1) {\n            printf(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\\n\");\n        }\n    } while (response < 0 || response > 1);\n    return response;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askBoolQuestion_name_conflict(unsigned long a0) {\n  unsigned int v0;  // [bp-0x2c]\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  v0 = -1;\n  while ((unsigned int)v2 > 1) {\n    printf(\"%s\\n> \", (unsigned int)a0);\n    __isoc99_scanf(\" %i\", (unsigned int)&v0);\n    fflush(stdin @GLIBC_2.2.5);\n    v2 = v0;\n    puts(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\");\n    v2 = v0;\n    if ((unsigned int)v2 <= 1)\n      return v0;\n  }\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfzt9b4eu/askBoolQuestion_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfzt9b4eu/askBoolQuestion_name_conflict.c:18:21: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpfzt9b4eu/askBoolQuestion_name_conflict.c:30:21: error: expected ')'\n   30 |         fflush(stdin@GLIBC_2.2.5);\n      |                     ^\n/tmp/tmpfzt9b4eu/askBoolQuestion_name_conflict.c:30:15: note: to match this '('\n   30 |         fflush(stdin@GLIBC_2.2.5);\n      |               ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char *askStringQuestion(char *question, int maxLength) {\n    char *answer = calloc(maxLength + 1, sizeof(char));\n    printf(\"%s\\n> \", question);\n    fgets(answer, maxLength, stdin);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long askStringQuestion(unsigned long a0, unsigned long a1) {\n  char *v1; // rax\n\n  v1 = calloc(a1 + 1, 1);\n  printf(\"%s\\n> \", (unsigned int)a0);\n  fgets(v1, a1, stdin @GLIBC_2.2.5);\n  fflush(stdin @GLIBC_2.2.5);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1jpdk2ln/askStringQuestion.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:16:8: error: conflicting types for 'fgets'\n   16 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmp1jpdk2ln/askStringQuestion.c:106:8: error:\nunknown type name 'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t\n*stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:106:21: error: expected ';' after top level\ndeclarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmp1jpdk2ln/askStringQuestion.c:114:24: error: expected ')'\n  114 |     fgets(v1, a1, stdin@GLIBC_2.2.5);\n      |                        ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:114:10: note: to match this '('\n  114 |     fgets(v1, a1, stdin@GLIBC_2.2.5);\n      |          ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:115:17: error: expected ')'\n  115 |     fflush(stdin@GLIBC_2.2.5);\n      |                 ^\n/tmp/tmp1jpdk2ln/askStringQuestion.c:115:11: note: to match this '('\n  115 |     fflush(stdin@GLIBC_2.2.5);\n      |           ^\n10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int multiprobabilisticRand(int probabilities[], int arraySize) {\n    int i, winner = -1, total = 0, choice = 0, currentTick = 0;\n    for (i = 0; i < arraySize; i++) {\n        total += probabilities[i];\n    }\n    choice = rand() % total;\n    for (i = 0; i < arraySize; i++) {\n        currentTick += probabilities[i];\n        if (choice < currentTick) {\n            winner = i;\n            break;\n        }\n    }\n    return winner;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long multiprobabilisticRand_name_conflict(unsigned int a0[2], unsigned long a1) {\n  unsigned int v1[2];    // rax, Other Possible Types: unsigned long\n  unsigned int v2;       // ebx\n  unsigned long long v3; // rax\n  unsigned int v4;       // edx\n  unsigned long v5;      // rax\n  unsigned int v6;       // esi\n\n  if ((unsigned int)a1 <= 0) {\n    rand();\n    return 4294967295;\n  }\n  v1 = a0;\n  v2 = 0;\n  do {\n    v2 += *((int *)v1);\n    v1 += 4;\n  } while (v1 != &a0[a1]);\n  (unsigned int)v3 = rand();\n  v4 = ((unsigned int)v3 >> 31 CONCAT(unsigned int) v3) / m v2 >> 32;\n  v6 = a0[0];\n  if (v4 < v6)\n    return 0;\n  for (v5 = 1; v5 != *((unsigned long long *)&v6); v5 += 1) {\n    v6 += a0[v5];\n    if (v4 < v6)\n      return v5;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpitfuw6tw/multiprobabilisticRand_name_conflict.c:33:8: error: array type 'unsigned\nint[2]' is not assignable 33 |     v1 = a0; |     ~~ ^\n/tmp/tmpitfuw6tw/multiprobabilisticRand_name_conflict.c:38:12: error: invalid operands to\nbinary expression ('unsigned int[2]' and 'int') 38 |         v1 += 4; | ~~ ^  ~\n/tmp/tmpitfuw6tw/multiprobabilisticRand_name_conflict.c:40:5: error: assignment to cast is\nillegal, lvalue casts are not supported 40 |     (unsigned int)v3 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpitfuw6tw/multiprobabilisticRand_name_conflict.c:41:34: error:\nexpected ')' 41 |     v4 = ((unsigned int)v3 >> 31 CONCAT (unsigned int)v3) /m\nv2 >> 32; |                                  ^\n/tmp/tmpitfuw6tw/multiprobabilisticRand_name_conflict.c:41:10: note: to match this '('\n   41 |     v4 = ((unsigned int)v3 >> 31 CONCAT (unsigned int)v3) /m v2 >> 32;\n      |          ^\n/tmp/tmpitfuw6tw/multiprobabilisticRand_name_conflict.c:41:61: error: expected ';' after\nexpression 41 |     v4 = ((unsigned int)v3 >> 31 CONCAT (unsigned int)v3) /m v2\n>> 32; |                                                             ^ | ; 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int randMinMax(int minimum, int maximum) {\n    return (rand() % (maximum - minimum)) + minimum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long randMinMax_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v2; // rax\n\n  (unsigned int)v2 = rand();\n  return (((unsigned int)v2 >> 31 CONCAT(unsigned int) v2) /\n              m((unsigned int)a1 - (unsigned int)a0) >>\n          32) +\n         a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqp_5ulxc/randMinMax_name_conflict.c:22:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 22 |     (unsigned int)v2 = rand(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpqp_5ulxc/randMinMax_name_conflict.c:23:37: error: expected ')'\n   23 |     return (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0) >> 32) + a0; | ^\n/tmp/tmpqp_5ulxc/randMinMax_name_conflict.c:23:13: note: to match this '('\n   23 |     return (((unsigned int)v2 >> 31 CONCAT (unsigned int)v2) /m\n((unsigned int)a1 - (unsigned int)a0) >> 32) + a0; |             ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char cycleChar(char original, int ticks) {\n    char alphabet[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int min = alphabet[0];\n    int max = alphabet[25];\n    if (isMutable(original))\n        return min + ((original + ticks - min) % 26);\n    return original;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(isMutable)(long long);\n\nlong long cycleChar_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v2; // rbx\n\n  v2 = (char)a0;\n  if ((char)isMutable(v2))\n    return (unsigned int)(v2 + a1 - 65 -\n                          (unsigned int)((v2 + a1 - 65) / 26) * 26) +\n           65;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"bool isMutable(char c) {\n    int i;\n    char mutables[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (i = 0; i < 26; i++) {\n        if (mutables[i] == c)\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long isMutable_name_conflict(unsigned long a0) {\n  char v0;      // [bp-0x28]\n  char v1;      // [bp-0x27]\n  char v2;      // [bp-0x1e]\n  char v3;      // [bp-0xe]\n  struct_0 *v5; // rax, Other Possible Types: unsigned long\n\n  strncpy(&v0, \"ABCDEFGHIJKLMNOP\", 16);\n  strncpy(&v2, \"KLMNOPQRSTUVWXYZ\", 16);\n  v5 = &v0;\n  while (*((char *)v5) != (char)a0) {\n    v5 = &v1;\n    if (v5 == &v3)\n      return 0;\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"char *loadFileToDecode(char *fileName) {\n    int length = 0;\n    FILE *file = fopen(fileName, \"rb\");\n    char *buffer = ((void *)0);\n    if (file) {\n        fseek(file, 0, 2);\n        length = ftell(file);\n        fseek(file, 0, 0);\n        buffer = calloc(length + 1, sizeof(char));\n        fread(buffer, 1, length, file);\n        fclose(file);\n        return buffer;\n    } else {\n        error(\"Couldn't read input file\");\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long loadFileToDecode(char *a0) {\n  FILE_t *v1;       // rax\n  FILE_t *v2;       // rbx\n  unsigned long v3; // r12\n  unsigned long v4; // rbp\n\n  v1 = fopen(a0, \"rb\");\n  v2 = v1;\n  if (!v1) {\n    error(\"Couldn't read input file\");\n    return v1;\n  }\n  fseek(v1, 0, 2);\n  v4 = ftell(v1);\n  fseek(v2, 0, 0);\n  v3 = calloc(v4 + 1, 1);\n  fread(v3, 1, v4, v2);\n  fclose(v2);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqpe22uxv/loadFileToDecode.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:73:13: error: declaration of anonymous union\nmust be a definition 73 |             union <anon> { |             ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:76:22: error: type name requires a specifier\nor qualifier 76 |             } __value; |                      ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:83:22: error: type name requires a specifier\nor qualifier 83 |             } __value; |                      ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:251:13: error: declaration of anonymous\nunion must be a definition 251 |             union <anon> { |             ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:254:22: error: type name requires a\nspecifier or qualifier 254 |             } __value; |                      ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:258:13: error: declaration of anonymous\nunion must be a definition 258 |             union <anon> { |             ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:261:22: error: type name requires a\nspecifier or qualifier 261 |             } __value; |                      ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:194:16: error: conflicting types for 'fread'\n  194 | unsigned long (fread)(void*, unsigned long, unsigned long, struct FILE_t\n{ |                ^ /usr/include/stdio.h:675:15: note: previous declaration is\nhere 675 | extern size_t fread (void *__restrict __ptr, size_t __size, | ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:319:16: error: redefinition of '_IO_marker'\n  319 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:325:16: error: redefinition of '_IO_codecvt'\n  325 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:329:16: error: redefinition of\n'_IO_wide_data' 329 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpqpe22uxv/loadFileToDecode.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"long timediff(clock_t t1, clock_t t2) {\n    long elapsed;\n    elapsed = ((double)t2 - t1) / ((__clock_t)1000000) * 1000;\n    return elapsed;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble timediff_name_conflict(long long a0, long long a1) {\n  int tmp_30; // tmp #30\n  int tmp_31; // tmp #31\n  int tmp_28; // tmp #28\n  int v2;     // xmm0\n\n  tmp_30 = DivV(tmp_31, tmp_28);\n  v2 = tmp_30 * 0x408f400000000000;\n  return (unsigned long long)v2;\n}\n","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/main.c"}
{"compilable":0,"function":"inline Limit init_limit(unsigned int h, struct Limit lim) {\n    double WSd = (double)sizeof(WORD) * 8;\n    unsigned int WSi = (unsigned int)sizeof(WORD) * 8;\n    lim.h = h;\n    WORD yWord = (9223372036854775807L * 2UL + 1UL);\n    unsigned int shift_places = (WSi - (h % WSi)) % WSi;\n    yWord = yWord >> shift_places;\n    lim.yWord = yWord;\n    lim.words = (unsigned int)ceil((double)lim.h / WSd);\n    lim.yIndex = 0;\n    return lim;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  uint128_t field_0;\n  unsigned long long field_10;\n} struct_0;\n\nlong long init_limit_name_conflict(struct_0 *a0, unsigned long a1) {\n  int tmp_13;            // tmp #13\n  int tmp_15;            // tmp #15\n  int tmp_14;            // tmp #14\n  unsigned int v0;       // [bp+0x8]\n  unsigned int v1;       // [bp+0xc]\n  unsigned int v2;       // [bp+0x10]\n  unsigned long v3;      // [bp+0x18]\n  int v4;                // xmm0\n  int v5;                // xmm3\n  unsigned long long v6; // xmm2\n  int v7;                // xmm1\n\n  v4 = (0 CONCAT a1) * 0x3f90000000000000;\n  v5 = v4;\n  v6 = 0;\n  v6 = 9223372036854775807;\n  v7 = v4 & v6;\n  if ((((char)(CmpF(0x4330000000000000, (unsigned long long)v7) & 69) |\n        (char)((CmpF(0x4330000000000000, (unsigned long long)v7) & 69) >> 6)) &\n       1) != 1) {\n    tmp_13 = CmpLEV(tmp_15, tmp_14);\n    v5 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT 0x3ff0000000000000)) +\n             (0 CONCAT(unsigned long long) v4) |\n         ~(v6)&v4;\n  }\n  v0 = (unsigned long long)v5;\n  v1 = a1;\n  v2 = 0;\n  *((int *)&v3) = (((char)-((unsigned int)a1) & 63)\n                       ? -1 >> ((char)-((unsigned int)a1) & 63)\n                       : -1 >> ((char)-((unsigned int)a1) & 63));\n  a0->field_0 = *((int128_t *)&v0);\n  a0->field_10 = v3;\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:19:5: error: unknown type name 'uint128_t'\n   19 |     uint128_t field_0;\n      |     ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:37:13: error: expected ')'\n   37 |     v4 = (0 CONCAT a1) * 0x3f90000000000000;\n      |             ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:37:10: note: to match this '('\n   37 |     v4 = (0 CONCAT a1) * 0x3f90000000000000;\n      |          ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:45:52: error: expected ')'\n   45 |         v5 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v4) | ~(v6) & v4; | ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:45:49: note: to match this '('\n   45 |         v5 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v4) | ~(v6) & v4; | ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:45:85: error: expected ')'\n   45 |         v5 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v4) | ~(v6) & v4; | ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:45:82: note: to match this '('\n   45 |         v5 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v4) | ~(v6) & v4; | ^\n/tmp/tmpdqnkn8q4/init_limit_name_conflict.c:51:32: error: expected expression\n   51 |     a0->field_0 = *((int128_t *)&v0);\n      |                                ^\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int popcount_words(WORD *words, int length) {\n    unsigned int count = 0;\n    unsigned int i;\n    for (i = 0; i < length; i++) {\n        count += __builtin_popcountl(words[i]);\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(__popcountdi2)(long long);\n\nlong long popcount_words_name_conflict(unsigned long long *a0, unsigned long a1) {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n  void *v2;               // rbp, Other Possible Types: unsigned long\n\n  if (!(unsigned int)a1)\n    return 0;\n  v1 = a0;\n  v2 = 0;\n  do {\n    v2 += __popcountdi2(*((long long *)v1));\n    v1 += 8;\n  } while (v1 != &a0[1 + a1 + 1]);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shift_words(WORD *words, int length) {\n    WORD mask = (WORD)1 << ((int)sizeof(WORD) * 8 - 1);\n    WORD carried_bit = 0;\n    WORD temp;\n    int i;\n    for (i = length - 1; i > -1; i--) {\n        temp = words[i];\n        words[i] = (WORD)((words[i] << 1) | carried_bit);\n        carried_bit = (WORD)((temp & mask) != 0);\n    }\n    return words;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shift_words_name_conflict(unsigned long long *a0, unsigned long a1) {\n  int tmp_6;              // tmp #6\n  unsigned long long *v1; // rax\n  unsigned long v2;       // rsi\n  void *v3;               // rdi, Other Possible Types: unsigned long\n  unsigned long long v4;  // rcx\n\n  v1 = a0;\n  tmp_6 = a1;\n  v2 = (unsigned int)a1 - 1;\n  if ((int)(tmp_6 - 1) < 0)\n    return a0;\n  v3 = 0;\n  do {\n    v4 = v1[v2];\n    v1[v2] = v4 * 2 | v3;\n    v3 = v4 / 0x8000000000000000;\n    v2 -= 1;\n  } while ((unsigned int)v2 >= 0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ko7u_gh/shift_words_name_conflict.c:34:25: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 34 |         v1[v2] = v4 * 2 |\nv3; |                  ~~~~~~ ^ ~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shiftc_words(WORD *words, struct Limit lim) {\n    words = shift_words(words, lim.words);\n    words[lim.yIndex] = words[lim.yIndex] & lim.yWord;\n    return words;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shiftc_words(unsigned long long *a0, unsigned long a1,\n                       unsigned long a2, unsigned long a3, unsigned long a4,\n                       unsigned long a5, unsigned int v0, unsigned int a6,\n                       unsigned long a7) {\n  int tmp_16;             // tmp #16\n  unsigned long long *v1; // rax\n  unsigned long v2;       // r8\n  unsigned long long v3;  // rdx\n  unsigned long v4;       // rdx\n  unsigned long long v5;  // rsi\n  void *v6;               // rdi, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = a6;\n  v3 = v0;\n  tmp_16 = v3;\n  v4 = (unsigned int)v3 - 1;\n  if ((int)(tmp_16 - 1) >= 0) {\n    v6 = 0;\n    do {\n      v5 = v1[v4];\n      v1[v4] = v5 * 2 | v6;\n      v6 = v5 / 0x8000000000000000;\n      v4 -= 1;\n    } while ((unsigned int)v4 >= 0);\n  }\n  v1[v2] = v1[v2] & a7;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph_3014h6/shiftc_words.c:38:29: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 38 |             v1[v4] = v5 * 2\n| v6; |                      ~~~~~~ ^ ~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD delta(char a, char b) {\n    return (WORD)(a != b);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long delta_name_conflict(unsigned long a0, unsigned long a1) {\n  return (char)a0 != (char)a1;\n}\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD ***M;\n    if ((M = (WORD ***)calloc((m + 1), sizeof(WORD **))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (i = 0; i < m + 1; i++) {\n        if ((M[i] = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M2 could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if ((M[i][j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n                fprintf(stderr, \" Error: M3 could not be allocated!\\n\");\n                return (0);\n            }\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0) {\n                if (i <= lim.h) {\n                    ones = shift_words(ones, lim.words);\n                    ones[lim.words - 1] = ones[lim.words - 1] + 1;\n                }\n                memcpy(M[i][j], ones, lim.words * sizeof(WORD));\n            } else {\n                for (k = 0; k < lim.words; k++) {\n                    M[i][j][k] = M[i - 1][j - 1][k];\n                }\n                M[i][j] = shiftc_words(M[i][j], lim);\n                M[i][j][lim.words - 1] = M[i][j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n            }\n            if (j >= lim.h && i >= lim.h) {\n                err = popcount_words(M[i][j], lim.words);\n                if (err < min_err) {\n                    min_err = err;\n                    (*dd) = min_err;\n                    (*ii) = i - 1;\n                    (*jj) = j - 1;\n                }\n            }\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            free(M[i][j]);\n        }\n        free(M[i]);\n    }\n    free(M);\n    free(ones);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(__popcountdi2)(long long);\n\ntypedef struct struct_1 {\n  unsigned long long field_ - 8;\n  struct struct_2 *field_0;\n} struct_1;\n\ntypedef struct struct_2 {\n  struct struct_0 *field_0;\n} struct_2;\n\ntypedef struct struct_0 {\n  unsigned long long field_0;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long maxshiftm_hd(unsigned long a0, unsigned long a1, char *a2,\n                       unsigned long a3, unsigned long a4, unsigned int *a5,\n                       unsigned int *v18, unsigned int *a6) {\n  int tmp_13;              // tmp #13\n  int tmp_15;              // tmp #15\n  int tmp_14;              // tmp #14\n  unsigned long v0;        // [bp-0xc0], Other Possible Types: unsigned int\n  unsigned int v1;         // [bp-0xb4]\n  unsigned int v2;         // [bp-0xac]\n  unsigned long v3;        // [bp-0xa8]\n  unsigned int v4;         // [bp-0xa0]\n  unsigned int v5;         // [bp-0x9c]\n  unsigned long long v6;   // [bp-0x98]\n  unsigned long v7;        // [bp-0x90]\n  char *v8;                // [bp-0x88]\n  unsigned long long *v9;  // [bp-0x80]\n  unsigned long v10;       // [bp-0x78]\n  unsigned long long *v11; // [bp-0x70]\n  unsigned long long *v12; // [bp-0x68]\n  unsigned long v13;       // [bp-0x60]\n  struct_1 *v14;           // [bp-0x50]\n  unsigned int v15;        // [bp-0x48]\n  unsigned int v16;        // [bp-0x44]\n  unsigned long long *v17; // [bp-0x40]\n  int v19;                 // xmm0\n  int v20;                 // xmm3\n  unsigned long long v21;  // xmm2\n  int v22;                 // xmm1\n  unsigned long long v24;  // rbp\n  unsigned long long v26;  // rax\n  struct_1 *v27;           // rbx, Other Possible Types: unsigned long\n  unsigned long long v28;  // rdi\n  unsigned long long v30;  // rax\n  struct_1 *v31;           // r15\n  unsigned long long *v32; // rsi\n  unsigned long long *v33; // rax\n  unsigned long long *v34; // rcx\n  unsigned long v35;       // rax\n  unsigned long long *v36; // rdi, Other Possible Types: unsigned long\n  void *v37;               // rsi, Other Possible Types: unsigned long\n  unsigned long long v38;  // rdx\n  unsigned long v39;       // rcx\n  void *v40;               // rsi, Other Possible Types: unsigned long\n  unsigned long long v42;  // rdx\n  unsigned int v43;        // eax\n  unsigned long long *v44; // rax\n  unsigned long long *v45; // rbp, Other Possible Types: unsigned long\n  unsigned long long v46;  // rax\n  void *v47;               // r12, Other Possible Types: unsigned long\n  unsigned long long *v49; // r12, Other Possible Types: unsigned long\n  unsigned long\n      v50; // r13, Other Possible Types: unsigned long long, unsigned int\n  struct struct_0 **v51;   // r14, Other Possible Types: unsigned long\n  unsigned long v52;       // rbx, Other Possible Types: unsigned int\n  unsigned long v53;       // rdx, Other Possible Types: unsigned long long\n  struct_1 *v54;           // r15\n  struct_1 *v55;           // rdi\n  unsigned long long v57;  // r13\n  unsigned long long v58;  // r14\n  unsigned long long *v59; // rbx, Other Possible Types: unsigned long\n  void *v60;               // rdi\n\n  v7 = a0;\n  v16 = a1;\n  v8 = a2;\n  v2 = a3;\n  v6 = -1 >> ((char)-((unsigned int)a4) & 63);\n  v19 = (0 CONCAT a4) * 0x3f90000000000000;\n  v20 = v19;\n  v21 = 0;\n  v21 = 9223372036854775807;\n  v22 = v19 & v21;\n  if ((((char)(CmpF(0x4330000000000000, (unsigned long long)v22) & 69) |\n        (char)((CmpF(0x4330000000000000, (unsigned long long)v22) & 69) >> 6)) &\n       1) != 1) {\n    tmp_13 = CmpLEV(tmp_15, tmp_14);\n    v20 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT 0x3ff0000000000000)) +\n              (0 CONCAT(unsigned long long) v19) |\n          ~(v21)&v19;\n  }\n  v4 = (unsigned long long)v20;\n  v17 = calloc((unsigned long long)v20, 8);\n  if (!v17) {\n    fwrite(\" Error: ow could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v1 = v16 + 1;\n  v14 = calloc(v1, 8);\n  if (!v14) {\n    fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  if (v1) {\n    v27 = v14;\n    v31 = v27;\n    v24 = &(&v27->field_ - 8)[v16 + 1];\n    do {\n      v26 = calloc(v2 + 1, 8);\n      *((unsigned long long *)v27) = v26;\n      if (!v26) {\n        fwrite(\" Error: M2 could not be allocated!\\n\", 1, 35,\n               stderr @GLIBC_2.2.5);\n        return 0;\n      }\n    } while ((v27 += 8, v27 != v24));\n    v28 = v2;\n    v0 = v24;\n    v3 = (unsigned long long)v20;\n    do {\n      if ((unsigned int)v28 != -1) {\n        do {\n          v30 = calloc((unsigned long long)v20, 8);\n          *((unsigned long long *)(0 + v31->field_ - 8)) = v30;\n          if (!v30) {\n            fwrite(\" Error: M3 could not be allocated!\\n\", 1, 35,\n                   stderr @GLIBC_2.2.5);\n            return 0;\n          }\n        } while ((v27 += 8, v27 != v24));\n      }\n    } while ((v27 += 8, v27 != v24));\n    if (v1 > 1) {\n      v32 = (v3 - 1) * 8;\n      v33 = v17;\n      v12 = v33 + v32;\n      v50 = (unsigned long long)v20 * 8;\n      v54 = &v14->field_0;\n      v53 = 1;\n      v15 = -1;\n      v5 = v4 - 1;\n      v9 = v32;\n      v13 = v16 + 1;\n      v49 = v33;\n      do {\n        v1 = v53;\n        v51 = 0;\n        v52 = -1;\n        if (v2 != -1) {\n          v3 = v53;\n          do {\n            v0 = v52;\n            v52 = (unsigned int)v52 + 1;\n            if (true) {\n              if ((unsigned int)a4 >= v1) {\n                if ((unsigned int)a3 >= 0) {\n                  a3 = v5;\n                  v37 = 0;\n                  do {\n                    v38 = v49[a3];\n                    v49[a3] = v38 * 2 | v37;\n                    v37 = v38 / 0x8000000000000000;\n                    a3 -= 1;\n                  } while ((unsigned int)a3 >= 0);\n                }\n                *(v12) = *(v12) + 1;\n              }\n              memcpy(*((long long *)v54->field_ - 8), v49, v50);\n            } else {\n              if (!v4) {\n                v36 = *((long long *)(v54->field_ - 8 + v51));\n              } else {\n                v34 = *((long long *)(v54->field_ - 8 + v51));\n                v35 = 0;\n                do {\n                  *((long long *)((char *)v34 + v35)) = *(\n                      (long long *)((char *)&v54->field_0[v0].field_0->field_0 +\n                                    v35));\n                  v35 += 8;\n                } while (v50 != v35);\n                v36 = *((long long *)(v54->field_ - 8 + (char *)v51));\n                if ((unsigned int)v34 >= 0) {\n                  v34 = v5;\n                  v40 = 0;\n                  do {\n                    v42 = *((long long *)(v36 + v39 * 8));\n                    *((unsigned long *)(v36 + v39 * 8)) = v42 * 2 | v40;\n                    v40 = v42 / 0x8000000000000000;\n                    v39 -= 1;\n                  } while ((unsigned int)v39 >= 0);\n                }\n              }\n              *((unsigned long long *)v36) = *((long long *)v36) & v6;\n              a3 = v9;\n              *((unsigned long long *)(v36 + a3)) =\n                  *((long long *)(v36 + a3)) |\n                  v8[v0] != *((char *)(v7 + v3 - 1));\n            }\n            v43 = v1;\n            if ((unsigned int)v52 < v43)\n              v43 = v52;\n            if (v43 >= (unsigned int)a4) {\n              v44 = *((long long *)(v54->field_ - 8 + v51));\n              if (!v4) {\n                a3 = v4;\n              } else {\n                v45 = v44;\n                v46 = (char *)v44 + v50;\n                v10 = v50;\n                v11 = v49;\n                v47 = 0;\n                do {\n                  v47 += __popcountdi2(*((long long *)v45));\n                  v45 += 8;\n                } while (v45 != v46);\n                v50 = v10;\n                a3 = v47;\n                v49 = v11;\n              }\n              if (a3 < v15) {\n                *(a6) = a3;\n                *(a5) = v1 - 1;\n                *(v18) = v0;\n                v15 = a3;\n              }\n            }\n            v51 += 8;\n          } while (v2 != (unsigned int)v52);\n          v53 = v3;\n        }\n      } while ((v27 += 8, v27 != v24));\n    }\n    v55 = v14;\n    v57 = &(&v55->field_ - 8)[v16 + 1];\n    v58 = v2;\n    do {\n      v59 = 0;\n      if ((unsigned int)v58 != -1) {\n        do {\n          v60 = *((long long *)(v55->field_ - 8 + v59));\n          free(v60);\n          v59 += 8;\n        } while ((v58 << 3) + 8 != v59);\n      }\n    } while ((v27 += 8, v27 != v24));\n  }\n  free(v14);\n  free(v17);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:19:30: error: expected ';' at end of declaration\nlist 19 |     unsigned long long field_-8; |                              ^ | ;\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:31:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 31 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:31:22: error: expected ';' after top level\ndeclarator 31 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:98:14: error: expected ')'\n   98 |     v19 = (0 CONCAT a4) * 0x3f90000000000000;\n      |              ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:98:11: note: to match this '('\n   98 |     v19 = (0 CONCAT a4) * 0x3f90000000000000;\n      |           ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:106:53: error: expected ')'\n  106 |         v20 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v19) | ~(v21) & v19; | ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:106:50: note: to match this '('\n  106 |         v20 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v19) | ~(v21) & v19; | ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:106:86: error: expected ')'\n  106 |         v20 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v19) | ~(v21) & v19; | ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:106:83: note: to match this '('\n  106 |         v20 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v19) | ~(v21) & v19; | ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:112:69: error: expected ')'\n  112 |         fwrite(\" Error: ow could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp6rnzvzmq/maxshiftm_hd.c:112:15: note: to match\nthis '(' 112 |         fwrite(\" Error: ow could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); |               ^ /tmp/tmp6rnzvzmq/maxshiftm_hd.c:119:69:\nerror: expected ')' 119 |         fwrite(\" Error: M1 could not be allocated!\\n\",\n1, 35, stderr@GLIBC_2.2.5); | ^ /tmp/tmp6rnzvzmq/maxshiftm_hd.c:119:15: note: to\nmatch this '(' 119 |         fwrite(\" Error: M1 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:133:77: error: expected ')'\n  133 |                 fwrite(\" Error: M2 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp6rnzvzmq/maxshiftm_hd.c:133:23: note: to match\nthis '(' 133 |                 fwrite(\" Error: M2 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |                       ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:150:85: error: expected ')'\n  150 |                         fwrite(\" Error: M3 could not be allocated!\\n\",\n1, 35, stderr@GLIBC_2.2.5); | ^ /tmp/tmp6rnzvzmq/maxshiftm_hd.c:150:31: note: to\nmatch this '(' 150 |                         fwrite(\" Error: M3 could not be\nallocated!\\n\", 1, 35, stderr@GLIBC_2.2.5); |                               ^\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:160:23: error: invalid operands to binary\nexpression ('unsigned long long *' and 'unsigned long long *') 160 | v12 = v33 +\nv32; |                   ~~~ ^ ~~~ /tmp/tmp6rnzvzmq/maxshiftm_hd.c:192:59:\nerror: invalid operands to binary expression ('unsigned long long' and 'void *')\n  192 |                                         v49[a3] = v38 * 2 | v37;\n      |                                                   ~~~~~~~ ^ ~~~\n/tmp/tmp6rnzvzmq/maxshiftm_hd.c:224:87: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 224 | *((unsigned long *)(v36 +\nv39 * 8)) = v42 * 2 | v40; | ~~~~~~~ ^ ~~~ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd_ls(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD **M0;\n    WORD **M1;\n    if ((M0 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M0 could not be allocated!\\n\");\n        return (0);\n    }\n    if ((M1 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (j = 0; j < n + 1; j++) {\n        if ((M0[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M0J could not be allocated!\\n\");\n            return (0);\n        }\n        if ((M1[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M1J could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0 && i <= lim.h) {\n                ones = shift_words(ones, lim.words);\n                ones[lim.words - 1] = ones[lim.words - 1] + 1;\n            }\n            switch (i % 2) {\n              case 0:\n                if (j == 0) {\n                    memcpy(M1[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M1[j][k] = M0[j - 1][k];\n                    }\n                    M1[j] = shiftc_words(M1[j], lim);\n                    M1[j][lim.words - 1] = M1[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M1[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n              case 1:\n                if (j == 0) {\n                    memcpy(M0[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M0[j][k] = M1[j - 1][k];\n                    }\n                    M0[j] = shiftc_words(M0[j], lim);\n                    M0[j][lim.words - 1] = M0[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M0[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (j = 0; j < n + 1; j++) {\n        free(M0[j]);\n        free(M1[j]);\n    }\n    free(M0);\n    free(M1);\n    free(ones);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(__popcountdi2)(long long);\n\ntypedef struct struct_0 {\n  struct struct_1 *field_0;\n  char padding_8[4294967287];\n  char field_ffffffff;\n  char padding_100000000[30064771064];\n  struct struct_1 *field_7fffffff8;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned long long field_0;\n} struct_1;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long maxshiftm_hd_ls(unsigned long a0, unsigned long a1, struct_0 *a2,\n                          unsigned long a3, unsigned long a4, unsigned int *a5,\n                          unsigned int *v17, unsigned int *a6) {\n  unsigned int v0; // [bp-0xb0], Other Possible Types: unsigned long\n  int tmp_13;      // tmp #13\n  int tmp_15;      // tmp #15\n  int tmp_14;      // tmp #14\n  unsigned long\n      v1; // [bp-0xa8], Other Possible Types: unsigned int, unsigned long long\n  unsigned long v2;        // [bp-0xa0]\n  unsigned long v3;        // [bp-0x98]\n  unsigned long long *v4;  // [bp-0x90]\n  unsigned long long v5;   // [bp-0x88]\n  unsigned long v6;        // [bp-0x80]\n  struct_0 *v7;            // [bp-0x78]\n  unsigned long long *v8;  // [bp-0x70]\n  unsigned int v9;         // [bp-0x68]\n  unsigned int v10;        // [bp-0x64]\n  unsigned int v11;        // [bp-0x60]\n  unsigned int v12;        // [bp-0x5c]\n  unsigned long long *v13; // [bp-0x58]\n  unsigned long v14;       // [bp-0x50]\n  unsigned int v15;        // [bp-0x48]\n  struct_0 *v16;           // [bp-0x44]\n  int v18;                 // xmm0\n  int v19;                 // xmm3\n  unsigned long long v20;  // xmm2\n  int v21;                 // xmm1\n  unsigned long v24;       // rbp\n  unsigned int v25;        // eax\n  unsigned long long v26;  // rax\n  unsigned long long v27;  // rax\n  unsigned long v28;       // r13d, Other Possible Types: unsigned int\n  unsigned long long *v29; // r14, Other Possible Types: unsigned long\n  unsigned long long v30;  // rbp\n  void *v31;               // rsi, Other Possible Types: unsigned long\n  unsigned long long v32;  // rdx\n  unsigned long v34;       // rsi\n  unsigned long v35;       // rax\n  unsigned long v36;       // rsi\n  unsigned long v37;       // rax\n  void *v38;               // rdi, Other Possible Types: unsigned long\n  unsigned long long v39;  // rdx\n  void *v41;               // rdi, Other Possible Types: unsigned long\n  unsigned long long v42;  // rdx\n  unsigned long long *v44; // rax\n  struct_0 *v45;           // r12d, Other Possible Types: unsigned int\n  unsigned long long *v46; // r12, Other Possible Types: unsigned long\n  unsigned long long v47;  // rax\n  void *v48;               // r13, Other Possible Types: unsigned long\n  unsigned long long *v50; // rax\n  unsigned long\n      v51; // r15, Other Possible Types: unsigned long long, unsigned int\n  unsigned long\n      v52; // r13d, Other Possible Types: unsigned int, unsigned long long\n  unsigned long long *v53; // r12, Other Possible Types: unsigned long\n  unsigned long long v54;  // rax\n  void *v55;               // r13, Other Possible Types: unsigned long\n  unsigned long v57;       // rbx\n  unsigned long v58;       // rbx\n\n  v6 = a0;\n  v0 = a1;\n  v7 = a2;\n  v10 = a3;\n  v5 = -1 >> ((char)-((unsigned int)a4) & 63);\n  v18 = (0 CONCAT a4) * 0x3f90000000000000;\n  v19 = v18;\n  v20 = 0;\n  v20 = 9223372036854775807;\n  v21 = v18 & v20;\n  if ((((char)(CmpF(0x4330000000000000, (unsigned long long)v21) & 69) |\n        (char)((CmpF(0x4330000000000000, (unsigned long long)v21) & 69) >> 6)) &\n       1) != 1) {\n    tmp_13 = CmpLEV(tmp_15, tmp_14);\n    v19 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT 0x3ff0000000000000)) +\n              (0 CONCAT(unsigned long long) v18) |\n          ~(v20)&v18;\n  }\n  v9 = (unsigned long long)v19;\n  v29 = calloc((unsigned long long)v19, 8);\n  if (!v29) {\n    fwrite(\" Error: ow could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v28 = v10 + 1;\n  v2 = calloc(v28, 8);\n  if (!v2) {\n    fwrite(\" Error: M0 could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v3 = calloc(v28, 8);\n  if (!v3) {\n    fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n    return 0;\n  }\n  v24 = 0;\n  if (!(unsigned int)v28) {\n    v25 = v0 + 1;\n    if (v25 <= 1)\n      free(v2);\n  } else {\n    v1 = v28;\n    v4 = v29;\n    do {\n      v26 = calloc((unsigned long long)v19, 8);\n      *((unsigned long long *)(v2 + v24)) = v26;\n      if (!v26) {\n        fwrite(\" Error: M0J could not be allocated!\\n\", 1, 36,\n               stderr @GLIBC_2.2.5);\n        return 0;\n      }\n      v27 = calloc((unsigned long long)v19, 8);\n      *((unsigned long long *)(v3 + v24)) = v27;\n      if (!v27) {\n        fwrite(\" Error: M1J could not be allocated!\\n\", 1, 36,\n               stderr @GLIBC_2.2.5);\n        return 0;\n      }\n      v24 += 8;\n    } while ((v10 << 3) + 8 != v24);\n    v28 = v1;\n    v29 = v4;\n    v25 = v0 + 1;\n    if (v25 <= 1)\n      goto LABEL_402376;\n  }\n  v8 = ((unsigned long long)v19 - 1) * 8;\n  v13 = (char *)v8 + v29;\n  v51 = (unsigned long long)v19 * 8;\n  v1 = 1;\n  v11 = -1;\n  *((unsigned int *)&v4) = v9 - 1;\n  v12 = v28;\n  v15 = v25;\n  do {\n    v30 = (unsigned int)v1;\n    v0 = v10;\n    v52 = 4294967295;\n    v57 = 0;\n    if (v12) {\n      while (true) {\n        v45 = (unsigned int)v57;\n        if (!(unsigned int)v57 && (unsigned int)a4 >= (unsigned int)v30) {\n          if ((unsigned int)a3 >= 0) {\n            a3 = (int)v4;\n            v31 = 0;\n            do {\n              v32 = *((long long *)(v29 + a3 * 8));\n              *((unsigned long *)(v29 + a3 * 8)) = v32 * 2 | v31;\n              v31 = v32 / 0x8000000000000000;\n              a3 -= 1;\n            } while ((unsigned int)a3 >= 0);\n          }\n          *(v13) = *(v13) + 1;\n          if (!((char)v30 & 1))\n            memcpy(*((long long *)v3), v29, v51);\n        } else if (!((char)v30 & 1)) {\n          if (!v45) {\n            memcpy(*((long long *)v3), v29, v51);\n          } else {\n            if (!v9) {\n              v34 = *((long long *)(v3 + v57 * 8));\n            } else {\n              a3 = *((long long *)(v2 + v52 * 8));\n              v34 = *((long long *)(v3 + v57 * 8));\n              v35 = 0;\n              do {\n                *((long long *)(v34 + v35)) =\n                    *((long long *)((char *)a3 + v35));\n                v35 += 8;\n              } while (v51 != v35);\n              if ((unsigned int)a3 >= 0) {\n                a3 = (int)v4;\n                v38 = 0;\n                do {\n                  v39 = *((long long *)(v34 + a3 * 8));\n                  *((unsigned long *)(v34 + a3 * 8)) = v39 * 2 | v38;\n                  v38 = v39 / 0x8000000000000000;\n                  a3 -= 1;\n                } while ((unsigned int)a3 >= 0);\n              }\n            }\n            *((unsigned long long *)v34) = *((long long *)v34) & v5;\n            *((unsigned long long *)(v34 + (char *)v8)) =\n                *((long long *)(v34 + (char *)v8)) |\n                *((char *)&v7->field_0 + v52) != *((char *)(v6 + v1 - 1));\n          }\n          if ((unsigned int)v30 <= v45)\n            v45 = v30;\n          if (v45 >= (unsigned int)a4) {\n            v44 = *((long long *)(v3 + v57 * 8));\n            if (!v9) {\n              a3 = v9;\n            } else {\n              v46 = v44;\n              v47 = (char *)v44 + v51;\n              v14 = v51;\n              *((unsigned int *)&v16) = v52;\n              v48 = 0;\n              do {\n                v48 += __popcountdi2(*((long long *)v46));\n                v46 += 8;\n              } while (v46 != v47);\n              v51 = v14;\n              a3 = v48;\n              v52 = (int)v16;\n            }\n            if (a3 < v11) {\n              *(a6) = a3;\n              *(a5) = (unsigned int)v30 - 1;\n              *(v17) = v52;\n              v11 = a3;\n              goto LABEL_402106;\n            }\n          }\n        }\n        if (!v45) {\n          memcpy(*((long long *)v2), v29, v51);\n        } else {\n          if (!v9) {\n            v36 = *((long long *)(v2 + v57 * 8));\n          } else {\n            a3 = *((long long *)(v3 + v52 * 8));\n            v36 = *((long long *)(v2 + v57 * 8));\n            v37 = 0;\n            do {\n              *((long long *)(v36 + v37)) = *((long long *)((char *)a3 + v37));\n              v37 += 8;\n            } while (v51 != v37);\n            if ((unsigned int)a3 >= 0) {\n              a3 = (int)v4;\n              v41 = 0;\n              do {\n                v42 = *((long long *)(v36 + a3 * 8));\n                *((unsigned long *)(v36 + a3 * 8)) = v42 * 2 | v41;\n                v41 = v42 / 0x8000000000000000;\n                a3 -= 1;\n              } while ((unsigned int)a3 >= 0);\n            }\n          }\n          *((unsigned long long *)v36) = *((long long *)v36) & v5;\n          *((unsigned long long *)(v36 + (char *)v8)) =\n              *((long long *)(v36 + (char *)v8)) |\n              *((char *)&v7->field_0 + v52) != *((char *)(v6 + v1 - 1));\n        }\n        if ((unsigned int)v30 <= v45)\n          v45 = v30;\n        if (v45 >= (unsigned int)a4) {\n          v50 = *((long long *)(v2 + v57 * 8));\n          if (!v9) {\n            a3 = v9;\n          } else {\n            v53 = v50;\n            v54 = (char *)v50 + v51;\n            v14 = v51;\n            *((unsigned int *)&v16) = v52;\n            v55 = 0;\n            do {\n              v55 += __popcountdi2(*((long long *)v53));\n              v53 += 8;\n            } while (v53 != v54);\n            v51 = v14;\n            a3 = v55;\n            v52 = (int)v16;\n          }\n          if ((unsigned int)a3 < v11) {\n            *(a6) = a3;\n            *(a5) = (unsigned int)v30 - 1;\n            *(v17) = v52;\n            v11 = a3;\n          }\n        }\n      LABEL_402106:\n        v52 = (unsigned int)v52 + 1;\n        if (v0 == v57)\n          break;\n        v57 += 1;\n      }\n    }\n  } while ((v1 += 1, (unsigned int)v1 < v15));\n  if (!v12)\n    free(v2);\n  v58 = 0;\n  do {\n  LABEL_402376:\n    free(*((long long *)(v2 + v58)));\n    free(*((long long *)(v3 + v58)));\n    v58 += 8;\n  } while ((v10 << 3) + 8 != v58);\n  free(v2);\n  free(v3);\n  free(v29);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:30:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 30 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:30:22: error: expected ';' after top level\ndeclarator 30 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:94:14: error: expected ')'\n   94 |     v18 = (0 CONCAT a4) * 0x3f90000000000000;\n      |              ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:94:11: note: to match this '('\n   94 |     v18 = (0 CONCAT a4) * 0x3f90000000000000;\n      |           ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:102:53: error: expected ')'\n  102 |         v19 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v18) | ~(v20) & v18; | ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:102:50: note: to match this '('\n  102 |         v19 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v18) | ~(v20) & v18; | ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:102:86: error: expected ')'\n  102 |         v19 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v18) | ~(v20) & v18; | ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:102:83: note: to match this '('\n  102 |         v19 = ((tmp_13 ^ 18446744073709551615) & (0 CONCAT\n0x3ff0000000000000)) + (0 CONCAT (unsigned long long)v18) | ~(v20) & v18; | ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:108:69: error: expected ')'\n  108 |         fwrite(\" Error: ow could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:108:15: note: to\nmatch this '(' 108 |         fwrite(\" Error: ow could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:115:69: error: expected ')'\n  115 |         fwrite(\" Error: M0 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:115:15: note: to\nmatch this '(' 115 |         fwrite(\" Error: M0 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:121:69: error: expected ')'\n  121 |         fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:121:15: note: to\nmatch this '(' 121 |         fwrite(\" Error: M1 could not be allocated!\\n\", 1,\n35, stderr@GLIBC_2.2.5); |               ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:141:78: error: expected ')'\n  141 |                 fwrite(\" Error: M0J could not be allocated!\\n\", 1, 36,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:141:23: note: to\nmatch this '(' 141 |                 fwrite(\" Error: M0J could not be\nallocated!\\n\", 1, 36, stderr@GLIBC_2.2.5); |                       ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:148:78: error: expected ')'\n  148 |                 fwrite(\" Error: M1J could not be allocated!\\n\", 1, 36,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:148:23: note: to\nmatch this '(' 148 |                 fwrite(\" Error: M1J could not be\nallocated!\\n\", 1, 36, stderr@GLIBC_2.2.5); |                       ^\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:160:22: error: invalid operands to binary\nexpression ('char *' and 'unsigned long long *') 160 |     v13 = (char *)v8 +\nv29; |           ~~~~~~~~~~ ^ ~~~ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:187:74:\nerror: invalid operands to binary expression ('unsigned long long' and 'void *')\n  187 |                             *((unsigned long *)(v29 + a3 * 8)) = v32 * 2\n| v31; | ~~~~~~~ ^ ~~~ /tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:225:82: error: invalid\noperands to binary expression ('unsigned long long' and 'void *') 225 |\n*((unsigned long *)(v34 + a3 * 8)) = v39 * 2 | v38; | ~~~~~~~ ^ ~~~\n/tmp/tmp3a2r4s8q/maxshiftm_hd_ls.c:296:78: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 296 | *((unsigned long *)(v36 +\na3 * 8)) = v42 * 2 | v41; | ~~~~~~~ ^ ~~~ 14 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"static int buf_prepare(size_t require) {\n    if (buf->size >= require) {\n        return 0;\n    }\n    buf->size = require * 2;\n    if (buf->size < 4096) {\n        buf->size = 4096;\n    }\n    if (buf->data == ((void *)0)) {\n        buf->data = malloc(buf->size);\n    } else {\n        buf->data = realloc(buf->data, buf->size);\n    }\n    if (buf->data == ((void *)0)) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\n\nextern void *bufst;\nextern unsigned long long g_40a4e8;\n\nlong long buf_prepare_name_conflict(unsigned long a0) {\n  unsigned long v1; // rsi, Other Possible Types: unsigned long long\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n  unsigned long v3; // rax\n\n  if (g_40a4e8 >= a0)\n    return 0;\n  v1 = a0 * 2;\n  if (v1 < 0x1000)\n    v1 = 0x1000;\n  g_40a4e8 = v1;\n  if (bufst)\n    v2 = realloc(bufst, v1);\n  else\n    v2 = malloc(v1);\n  bufst = v2;\n  v3 = -(v2 < 1);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_connect(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (connect(fd, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nchar *(strncpy)(char *, char *, unsigned long);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\n\nlong long pt_comm_connect_name_conflict(char *a0) {\n  unsigned short v0;     // [bp-0x88]\n  char v1;               // [bp-0x86]\n  char v2;               // [bp-0x1b]\n  unsigned long v4;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v5; // rax\n\n  v4 = socket(1, 1, 0);\n  if ((unsigned int)v4 == -1)\n    return v4;\n  v2 = 0;\n  v0 = 1;\n  strncpy(&v1, a0, 107);\n  (unsigned int)v5 = connect(v4, &v0, 110);\n  if ((unsigned int)v5 != -1)\n    return v4;\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqannknqj/pt_comm_connect_name_conflict.c:37:5: error: assignment to cast is illegal,\nlvalue casts are not supported 37 |     (unsigned int)v5 = connect(v4, &v0,\n110); |     ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_listen(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (unlink(addr.sun_path) == -1 && (*__errno_location()) != 2) {\n        return -1;\n    }\n    if (bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {\n        return -1;\n    }\n    if (chmod(addr.sun_path, (2048 | 1024 | 512 | (256 | 128 | 64) | ((256 | 128 | 64) >> 3) | (((256 | 128 | 64) >> 3) >> 3))) == 0) {\n        (*__errno_location()) = 0;\n    }\n    if (listen(fd, 128) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nchar *(strncpy)(char *, char *, unsigned long);\nint(unlink)(char *);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(chmod)(char *, unsigned short);\nint(listen)(int, int);\n\nlong long pt_comm_listen_name_conflict(char *a0) {\n  unsigned short v0;     // [bp-0x88]\n  char v1;               // [bp-0x86]\n  char v2;               // [bp-0x1b]\n  unsigned long v4;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v5; // rbp\n  unsigned long long v6; // rax\n  unsigned long long v7; // rax\n\n  v4 = socket(1, 1, 0);\n  if ((unsigned int)v4 == -1)\n    return v4;\n  v2 = 0;\n  v0 = 1;\n  strncpy(&v1, a0, 107);\n  v5 = unlink(&v1);\n  if ((unsigned int)v5 == -1 && *(__errno_location()) != 2)\n    return v5;\n  (unsigned int)v6 = bind(v4, &v0, 110);\n  if ((unsigned int)v6 == -1)\n    return v6;\n  if (!chmod(&v1, 4095))\n    *(__errno_location()) = 0;\n  (unsigned int)v7 = listen(v4, 128);\n  if ((unsigned int)v7 != -1)\n    return v4;\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplg08dxsr/pt_comm_listen_name_conflict.c:43:35: error: indirection requires pointer\noperand ('int' invalid) 43 |     if ((unsigned int)v5 == -1 &&\n*(__errno_location()) != 2) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplg08dxsr/pt_comm_listen_name_conflict.c:45:5: error: assignment to cast is illegal,\nlvalue casts are not supported 45 |     (unsigned int)v6 = bind(v4, &v0, 110);\n      |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmplg08dxsr/pt_comm_listen_name_conflict.c:49:9: error: indirection requires pointer\noperand ('int' invalid) 49 |         *(__errno_location()) = 0; |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmplg08dxsr/pt_comm_listen_name_conflict.c:50:5: error: assignment\nto cast is illegal, lvalue casts are not supported 50 |     (unsigned int)v7 =\nlisten(v4, 128); |     ^~~~~~~~~~~~~~~~ ~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_accept(int fd) {\n    struct sockaddr_un addr;\n    socklen_t addrlen = sizeof (addr);\n    return accept(fd, (struct sockaddr *)&addr, &addrlen);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long pt_comm_accept_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x7c]\n  sockaddr v1;     // [bp-0x78]\n\n  v0 = 110;\n  return accept(a0, &v1, &v0);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_recv_msg(int fd, pt_comm_message_t **msg_ptr) {\n    int i;\n    ssize_t retval, recvlen;\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t)) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    retval = recv(fd, msg, sizeof(pt_comm_message_t), MSG_DONTWAIT);\n    if (retval == -1) {\n        if ((*__errno_location()) == 11 || (*__errno_location()) == 11) {\n            return PT_MSG_EMPTY;\n        } else {\n            return PT_MSG_ERR_SOCK;\n        }\n    } else if (retval == 0) {\n        return PT_MSG_PEERDOWN;\n    } else if (retval != sizeof(pt_comm_message_t)) {\n        return PT_MSG_INVALID;\n    } else if (msg->len > 1024 * 1024 || msg->len < 0) {\n        return PT_MSG_INVALID;\n    }\n    if (msg->len == 0) {\n        return msg->type;\n    }\n    if (buf_prepare(sizeof(pt_comm_message_t) + msg->len) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    for (i = 0 , recvlen = 0; i < 10; i++) {\n        retval = recv(fd, msg->data + recvlen, msg->len - recvlen, 0);\n        if (retval == -1) {\n            return PT_MSG_ERR_SOCK;\n        } else if (retval == 0) {\n            return PT_MSG_PEERDOWN;\n        }\n        recvlen += retval;\n        if (recvlen == msg->len) {\n            break;\n        }\n    }\n    if (recvlen != msg->len) {\n        return PT_MSG_INVALID;\n    }\n    return msg->type;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(buf_prepare)(long long);\nlong(recv)(int, void *, unsigned long, int);\n\nextern struct_0 *bufst;\n\nlong long pt_comm_recv_msg_name_conflict(unsigned long a0, unsigned long long *a1) {\n  unsigned long long v3; // rdx\n  unsigned long long v4; // rdi\n  unsigned long long v5; // rax\n  void *v6;              // rbp, Other Possible Types: unsigned long\n  unsigned int v7;       // r12d\n\n  if ((int)buf_prepare(12) == -1)\n    return 3;\n  *(a1) = bufst;\n  v3 = recv(a0, bufst, 12, 64);\n  if (v3 == -1) {\n    return (*(__errno_location()) != 11) * 2;\n  } else if (!v3) {\n    return 1;\n  } else if (v3 != 12) {\n    return 4;\n  } else {\n    v4 = bufst->field_0;\n    if ((unsigned int)v4 > 0x100000) {\n      return 4;\n    } else if (!(unsigned int)v4) {\n      return bufst->field_4;\n    } else if ((int)buf_prepare(v4 + 12) == -1) {\n      return 3;\n    } else {\n      *(a1) = bufst;\n      v7 = 10;\n      v6 = 0;\n      while (v5 != -1) {\n        v5 = recv(a0, (char *)&bufst[1].field_4 + v6, bufst->field_0 - v6, 0);\n        if (!v5)\n          return 1;\n        v6 += v5;\n        if (bufst->field_0 == v6)\n          return bufst->field_4;\n        v7 -= 1;\n        if (false)\n          return 4;\n      }\n      return 2;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:28:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 28 | extern struct_0 *bufst; |        ^~~~~~~~ | struct\n/tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:28:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:44:17: error:\nindirection requires pointer operand ('int' invalid) 44 |         return\n(*(__errno_location()) != 11) * 2; |                 ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:56:21: error: member reference type 'int' is\nnot a pointer 56 |         v4 = bufst->field_0; |              ~~~~~  ^\n/tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:63:27: error: member reference type 'int' is\nnot a pointer 63 |             return bufst->field_4; |                    ~~~~~\n^ /tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:76:45: error: subscripted value is not an\narray, pointer, or vector 76 |                 v5 = recv(a0, (char\n*)&bufst[1].field_4 + v6, bufst->field_0 - v6, 0); | ~~~~~^~\n/tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:76:70: error: member reference type 'int' is\nnot a pointer 76 |                 v5 = recv(a0, (char *)&bufst[1].field_4 + v6,\nbufst->field_0 - v6, 0); | ~~~~~  ^ /tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:80:28:\nerror: member reference type 'int' is not a pointer 80 |                 if\n(bufst->field_0 == v6) |                     ~~~~~  ^\n/tmp/tmp92gz_85c/pt_comm_recv_msg_name_conflict.c:81:35: error: member reference type 'int' is\nnot a pointer 81 |                     return bufst->field_4; | ~~~~~  ^ 9\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_build_msg(pt_comm_message_t **msg_ptr, size_t size, int type) {\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t) + size) == -1) {\n        return -1;\n    }\n    msg = *msg_ptr = buf->data;\n    msg->len = size;\n    msg->type = type;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\nint bufst; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(buf_prepare)(long long);\n\nextern struct_0 *bufst;\n\nlong long pt_comm_build_msg(unsigned long long *a0, unsigned long a1,\n                            unsigned long a2) {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = buf_prepare(a1 + 12);\n  if ((unsigned int)v1 != -1) {\n    *(a0) = bufst;\n    bufst->field_0 = a1;\n    bufst->field_4 = a2;\n    return 0;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdio9nhjz/pt_comm_build_msg.c:21:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 21 | extern struct_0 *bufst; |        ^~~~~~~~ | struct\n/tmp/tmpdio9nhjz/pt_comm_build_msg.c:21:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmpdio9nhjz/pt_comm_build_msg.c:31:16: error:\nmember reference type 'int' is not a pointer 31 |         bufst->field_0 = a1;\n      |         ~~~~~  ^\n/tmp/tmpdio9nhjz/pt_comm_build_msg.c:32:16: error: member reference type 'int'\nis not a pointer 32 |         bufst->field_4 = a2; |         ~~~~~  ^ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_type(int fd, int type) {\n    pt_comm_message_t *msg;\n    if (pt_comm_build_msg(&msg, 0, type) == -1) {\n        return -1;\n    }\n    return pt_comm_send_msg(fd, msg);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pt_comm_build_msg)(long long, long long, long long);\nlong long(pt_comm_send_msg)(long long, long long);\n\nlong long pt_comm_send_type_name_conflict(unsigned long long a0, unsigned long long a1) {\n  char v0;          // [bp-0x10]\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  v2 = pt_comm_build_msg(&v0, 0, a1);\n  if ((unsigned int)v2 != -1) {\n    v2 = pt_comm_send_msg(a0, *((long long *)&v0));\n    return v2;\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_msg(int fd, pt_comm_message_t *msg) {\n    ssize_t retval;\n    retval = send(fd, msg, sizeof(pt_comm_message_t), 0);\n    if (retval == -1) {\n        return -1;\n    }\n    if (msg->len == 0) {\n        return 0;\n    }\n    retval = send(fd, msg->data, msg->len, 0);\n    if (retval == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\n\nlong long pt_comm_send_msg_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (send(a0, a1, 12, 0) == -1)\n    return 4294967295;\n  v1 = *(a1);\n  if ((unsigned int)v1) {\n    v1 = -(send(a0, a1 + 3, v1, 0) == -1);\n    return v1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_close(int fd, const char *addrstr) {\n    if (addrstr != ((void *)0)) {\n        unlink(addrstr);\n    }\n    return close(fd);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\nint(unlink)(char *);\n\nlong long pt_comm_close_name_conflict(unsigned long a0, char *a1) {\n  if (a1)\n    unlink(a1);\n  return close(a0);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"static int has_color(void) {\n    if (output_is_tty == -1) {\n        output_is_tty = isatty(1);\n    }\n    return output_is_tty == 1 ? 1 : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int output_is_tty;\n\nlong long has_color_name_conflict() {\n  if (output_is_tty == -1)\n    output_is_tty = isatty(1);\n  return output_is_tty == 1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_type.c"}
{"compilable":0,"function":"static int pt_send_msg(int fd) {\n    if (clictx.pft.type != (1 << 0)) {\n        pt_comm_message_t *msg;\n        if (pt_comm_build_msg(&msg, sizeof(pt_filter_t), PT_MSG_DO_FILTER) == -1) {\n            return -1;\n        }\n        pt_filter_pack_filter_msg(&clictx.pft, msg->data);\n        if (pt_comm_send_msg(fd, msg) == -1) {\n            return -1;\n        }\n    }\n    if (clictx.pft.type != (1 << 1)) {\n        return pt_comm_send_type(fd, PT_MSG_DO_TRACE);\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/trace.c"}
{"compilable":0,"function":"int pt_status_main(void) {\n    int ret, try_ptrace;\n    try_ptrace = 0;\n    if (!clictx.ptrace) {\n        ret = status_ext();\n        if (ret == -1) {\n            printf(\"Fetch status error\\n\");\n            try_ptrace = 1;\n        } else if (ret == -2) {\n            printf(\"Operation timed out, no response received, make sure PHP process is active and extension already installed.\\n\");\n            try_ptrace = 1;\n        }\n    }\n    try_ptrace = 0;\n    if (clictx.ptrace || try_ptrace) {\n        ret = status_ptrace();\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(status_ext)();\nlong long(pt_log)(long long, long long, long long, long long, ...);\n\nextern unsigned int g_40a2ac;\n\nlong long pt_status_main_name_conflict() {\n  unsigned long v1; // rbx, Other Possible Types: unsigned long long\n\n  if (!g_40a2ac) {\n    v1 = status_ext();\n    if ((unsigned int)v1 == -1) {\n      puts(\"Fetch status error\");\n    } else if ((unsigned int)v1 == -2) {\n      puts(\"Operation timed out, no response received, make sure PHP process \"\n           \"is active and extension already installed.\");\n    }\n    if (!g_40a2ac)\n      return v1;\n  }\n  pt_log(0, \"C_COMPILE/silkCut_phptrace/src/status.c\", 144,\n         \"ptrace supported only on Linux\");\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/status.c"}
{"compilable":0,"function":"sds sdsempty(void) {\n    return sdsnewlen(\"\", 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\n\nextern unsigned long long g_407b16;\n\nlong long sdsempty_name_conflict() { return sdsnewlen(&g_407b16, 0); }\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsnew(const char *init) {\n    size_t initlen = (init == ((void *)0)) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnew_name_conflictlen)(long long, long long);\n\nlong long sdsnew_name_conflict(char *a0) {\n  if (!a0)\n    return sdsnew_name_conflictlen(a0, 0);\n  return sdsnew_name_conflictlen(a0, strlen(a0));\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\n\ntypedef struct struct_0 {\n  unsigned int field_ - 8;\n} struct_0;\n\nlong long sdsdup_name_conflict(struct_0 *a0) { return sdsnewlen(a0, a0[2].field_ - 8); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp23bbo_3b/sdsdup_name_conflict.c:19:24: error: expected ';' at end of declaration list\n   19 |     unsigned int field_-8;\n      |                        ^\n      |                        ;\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsMakeRoomFor(sds s, size_t addlen) {\n    struct sdshdr *sh, *newsh;\n    size_t free = sdsavail(s);\n    size_t len, newlen;\n    if (free >= addlen)\n        return s;\n    len = sdslen(s);\n    sh = (void *)(s - sizeof *sh);\n    ;\n    newlen = (len + addlen);\n    if (newlen < (1024 * 1024))\n        newlen *= 2;\n    else\n        newlen += (1024 * 1024);\n    newsh = realloc(sh, sizeof *newsh + newlen + 1);\n    if (newsh == ((void *)0))\n        return ((void *)0);\n    newsh->free = newlen - len;\n    return newsh->buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\n\ntypedef struct struct_0 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_0;\n\nlong long sdsMakeRoomFor_name_conflict(unsigned int a0[0], unsigned long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v1;      // [bp-0x8]\n  unsigned long v3;      // rbx\n  unsigned long long v4; // rbx\n  unsigned long long v6; // rsi\n  unsigned long v7;      // rbp, Other Possible Types: unsigned long long\n  struct_0 *v8;          // rax, Other Possible Types: unsigned long\n  unsigned long long v9; // rbx\n\n  if (*((int *)&a0[4]) >= a1)\n    return a0;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  v4 = *((int *)&a0[8]);\n  v6 = a1 + v4;\n  v7 = v6 + 0x100000;\n  if (v6 <= 1048575)\n    v7 = v6 * 2;\n  v8 = realloc(a0 + 8, v7 + 9);\n  if (!v8) {\n    v9 = v0;\n    return v8;\n  }\n  v8->field_4 = v7 - v4;\n  v8 += 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsRemoveFreeSpace(sds s) {\n    struct sdshdr *sh;\n    sh = (void *)(s - sizeof *sh);\n    ;\n    sh = realloc(sh, sizeof *sh + sh->len + 1);\n    sh->free = 0;\n    return sh->buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid *(realloc)(void *, unsigned long);\n\ntypedef struct struct_0 {\n  unsigned int field_ - 8;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_1;\n\nlong long sdsRemoveFreeSpace_name_conflict(struct_0 *a0) {\n  struct_1 *v1; // rax\n\n  v1 = realloc(a0 + 2, a0[2].field_ - 8 + 9);\n  v1->field_4 = 0;\n  return v1 + 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe_d2o1jq/sdsRemoveFreeSpace_name_conflict.c:19:24: error: expected ';' at end of\ndeclaration list 19 |     unsigned int field_-8; |                        ^ | ;\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"size_t sdsAllocSize(sds s) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    return sizeof (*sh) + sh->len + sh->free + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sdsAllocSize_name_conflict(unsigned int a0[0]) {\n  return *((int *)&a0[8]) + *((int *)&a0[4]) + 9;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsgrowzero(sds s, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    size_t totlen, curlen = sh->len;\n    if (len <= curlen)\n        return s;\n    s = sdsMakeRoomFor(s, len - curlen);\n    if (s == ((void *)0))\n        return ((void *)0);\n    sh = (void *)(s - sizeof *sh);\n    memset(s + curlen, 0, (len - curlen + 1));\n    totlen = sh->len + sh->free;\n    sh->len = len;\n    sh->free = totlen - sh->len;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsMakeRoomFor)(long long, long long);\n\nlong long sdsgrowzero_name_conflict(unsigned int a0[0], unsigned long a1) {\n  unsigned long v1;      // rbx\n  unsigned long long v2; // r12\n  unsigned int v3;       // ebp\n  unsigned long long v4; // r13\n  unsigned int v5;       // eax\n\n  v2 = *((int *)&a0[8]);\n  if (v2 >= a1)\n    return a0;\n  v3 = a1;\n  v4 = a1 - v2;\n  v1 = sdsMakeRoomFor(a0, v4);\n  if (v1) {\n    memset(v1 + v2, 0, v4 + 1);\n    v5 = *((int *)(v1 - 4)) + *((int *)(v1 - 8));\n    *((unsigned int *)(v1 - 8)) = v3;\n    *((unsigned int *)(v1 - 4)) = v5 - v3;\n    return v1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscat_name_conflictlen)(long long, long long, long long);\n\nlong long sdscat_name_conflict(unsigned long long a0, char *a1) {\n  return sdscat_name_conflictlen(a0, a1, strlen(a1));\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscatlen)(long long, long long, long long);\n\ntypedef struct struct_0 {\n  unsigned int field_ - 8;\n} struct_0;\n\nlong long sdscatsds_name_conflict(unsigned long long a0, struct_0 *a1) {\n  return sdscatlen(a0, a1, a1[2].field_ - 8);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkfl50wjs/sdscatsds_name_conflict.c:19:24: error: expected ';' at end of declaration\nlist 19 |     unsigned int field_-8; |                        ^ | ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpylen(sds s, const char *t, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    size_t totlen = sh->free + sh->len;\n    if (totlen < len) {\n        s = sdsMakeRoomFor(s, len - sh->len);\n        if (s == ((void *)0))\n            return ((void *)0);\n        sh = (void *)(s - sizeof *sh);\n        ;\n        totlen = sh->free + sh->len;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\x00';\n    sh->len = len;\n    sh->free = totlen - len;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsMakeRoomFor)(long long, long long);\n\ntypedef struct struct_0 {\n  unsigned int field_ - 8;\n  unsigned int field_ - 4;\n  char field_0;\n} struct_0;\n\nlong long sdscpylen_name_conflict(struct_0 *a0, void *a1, struct_0 *a2) {\n  unsigned long long v1; // rax\n  unsigned long v2;      // rbp, Other Possible Types: unsigned int\n  struct_0 *v3;          // rax\n  unsigned int v4[2];    // r13, Other Possible Types: unsigned long\n  unsigned long v5;      // rbx\n\n  v1 = *((int *)&a0->field_0);\n  v2 = (unsigned int)v1 + a0->field_ - 4;\n  if (v2 >= a2) {\n    v4 = &a0->field_0;\n    v5 = a0;\n  } else {\n    v3 = sdsMakeRoomFor(a0, (char *)a2 - v1);\n    v5 = v3;\n    if (!v3)\n      return v3;\n    v4 = &v3->field_0;\n    v2 = *((int *)&v3->field_0) + v3->field_ - 4;\n  }\n  memcpy(v5, a1, a2);\n  *(v5 + (char *)&a2->field_ - 8) = 0;\n  *((unsigned int *)v4) = (unsigned int)a2;\n  *((unsigned int *)(v4 + 4)) = (unsigned int)v2 - (unsigned int)a2;\n  return v5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxgsqdg5e/sdscpylen_name_conflict.c:19:24: error: expected ';' at end of declaration\nlist 19 |     unsigned int field_-8; |                        ^ | ;\n/tmp/tmpxgsqdg5e/sdscpylen_name_conflict.c:20:18: error: duplicate member 'field_'\n   20 |     unsigned int field_-4;\n      |                  ^\n/tmp/tmpxgsqdg5e/sdscpylen_name_conflict.c:19:18: note: previous declaration is here\n   19 |     unsigned int field_-8;\n      |                  ^\n/tmp/tmpxgsqdg5e/sdscpylen_name_conflict.c:20:24: error: expected ';' at end of declaration\nlist 20 |     unsigned int field_-4; |                        ^ | ;\n/tmp/tmpxgsqdg5e/sdscpylen_name_conflict.c:36:12: error: array type 'unsigned int[2]' is not\nassignable 36 |         v4 = &a0->field_0; |         ~~ ^\n/tmp/tmpxgsqdg5e/sdscpylen_name_conflict.c:45:12: error: array type 'unsigned int[2]' is not\nassignable 45 |         v4 = &v3->field_0; |         ~~ ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscpy_name_conflictlen)(long long, long long, long long);\n\nlong long sdscpy_name_conflict(unsigned long long a0, char *a1) {\n  return sdscpy_name_conflictlen(a0, a1, strlen(a1));\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    __builtin_va_start(ap, fmt);\n    t = sdscatvprintf(s, fmt, ap);\n    __builtin_va_end(ap);\n    return t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscatvprintf)(long long, long long, long long);\n\nlong long sdscatprintf_name_conflict(unsigned long long a0, unsigned long long a1) {\n  unsigned int v0;   // [bp-0xd0]\n  unsigned int v1;   // [bp-0xcc]\n  unsigned long v2;  // [bp-0xc8]\n  unsigned long v3;  // [bp-0xc0]\n  char v4;           // [bp-0xb8]\n  unsigned long v5;  // [bp-0xa8]\n  unsigned long v6;  // [bp-0xa0]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  unsigned long v18; // rdx\n  unsigned long v19; // rcx\n  unsigned long v20; // r8\n  unsigned long v21; // r9\n  char v22;          // al\n  int v23;           // xmm0\n  int v24;           // xmm1\n  int v25;           // xmm2\n  int v26;           // xmm3\n  int v27;           // xmm4\n  int v28;           // xmm5\n  int v29;           // xmm6\n  int v30;           // xmm7\n\n  v5 = v18;\n  v6 = v19;\n  v7 = v20;\n  v8 = v21;\n  if (v22) {\n    v9 = v23;\n    v10 = v24;\n    v11 = v25;\n    v12 = v26;\n    v13 = v27;\n    v14 = v28;\n    v15 = v29;\n    v16 = v30;\n  }\n  v0 = 16;\n  v1 = 48;\n  v2 = &v17;\n  v3 = &v4;\n  return sdscatvprintf(a0, a1, &v0);\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1, s2, minlen);\n    if (cmp == 0)\n        return l1 - l2;\n    return cmp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_ - 8;\n} struct_0;\n\nlong long sdscmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v2;      // rbx\n  unsigned long long v3; // rbx\n  unsigned long long v4; // rbp\n  unsigned long v6;      // rax, Other Possible Types: unsigned long long\n\n  v0 = v2;\n  v3 = a0[2].field_ - 8;\n  v4 = a1[2].field_ - 8;\n  (unsigned int)v6 = memcmp(a0, a1, (!(v4 <= v3) ? v4 : v3));\n  if (!(unsigned int)v6) {\n    v6 = v3 - v4;\n    return v6;\n  }\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_o6ze6n4/sdscmp_name_conflict.c:18:24: error: expected ';' at end of declaration list\n   18 |     unsigned int field_-8;\n      |                        ^\n      |                        ;\n/tmp/tmp_o6ze6n4/sdscmp_name_conflict.c:32:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 32 |     (unsigned int)v6 = memcmp(a0, a1, (!(v4 <= v3)\n? v4 : v3)); |     ^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5, start = 0, j;\n    sds *tokens;\n    if (seplen < 1 || len < 0)\n        return ((void *)0);\n    tokens = malloc(sizeof(sds) * slots);\n    if (tokens == ((void *)0))\n        return ((void *)0);\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len - (seplen - 1)); j++) {\n        if (slots < elements + 2) {\n            sds *newtokens;\n            slots *= 2;\n            newtokens = realloc(tokens, sizeof(sds) * slots);\n            if (newtokens == ((void *)0))\n                goto cleanup;\n            tokens = newtokens;\n        }\n        if ((seplen == 1 && *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s + start, j - start);\n            if (tokens[elements] == ((void *)0))\n                goto cleanup;\n            elements++;\n            start = j + seplen;\n            j = j + seplen - 1;\n        }\n    }\n    tokens[elements] = sdsnewlen(s + start, len - start);\n    if (tokens[elements] == ((void *)0))\n        goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n  cleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++)\n            sdsfree(tokens[i]);\n        free(tokens);\n        *count = 0;\n        return ((void *)0);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\nvoid *(realloc)(void *, unsigned long);\nlong long(sdsfree)(long long);\n\nlong long sdssplitlen(unsigned long a0, unsigned long long a1, char *a2,\n                      unsigned int a3, unsigned int *a4) {\n  unsigned long long *v0; // [bp-0x68], Other Possible Types: unsigned long\n  unsigned long long *v1; // [bp-0x58]\n  unsigned int v2;        // [bp-0x40], Other Possible Types: char\n  char *v4; // rbx, Other Possible Types: unsigned long, unsigned long long,\n            // unsigned int\n  void *v5; // rbp, Other Possible Types: unsigned long\n  unsigned long v6;        // r14d, Other Possible Types: unsigned int\n  unsigned long long v7;   // rax\n  unsigned long long *v8;  // r12\n  unsigned long long *v9;  // rax\n  unsigned long long v10;  // rax\n  unsigned long v11;       // r15\n  unsigned long long v12;  // rax\n  unsigned long long *v13; // rbx, Other Possible Types: unsigned long\n\n  if (a3 > 0 && (unsigned int)a1 >= 0) {\n    v0 = malloc(40);\n    if (!v0) {\n      return v0;\n    } else if ((unsigned int)a1) {\n      if (*((int *)&v2) > 0) {\n        v4 = 0;\n        v5 = 0;\n        v6 = 5;\n        v11 = 0;\n        v2 = a1 - (a3 - 1);\n        do {\n          v8 = v11 + 1;\n          if ((unsigned int)v8 >= (unsigned int)v6) {\n            v6 = (unsigned int)v6 * 2;\n            v9 = realloc(v0, v6 * 8);\n            if (!v9)\n              goto LABEL_403cc2;\n            v0 = v9;\n          }\n          if (!(a3 != 1) && !(*((char *)(a0 + v4)) != *(a2)) ||\n              !(memcmp(v4 + a0, a2, a3))) {\n            v1 = v0 + v11 * 8;\n            v10 = sdsnewlen(v5 + a0, v4 - v5);\n            *(v1) = v10;\n            if (!v10)\n              goto LABEL_403cc2;\n            v5 = a3 + v4;\n            v4 = (unsigned int)v5 - 1;\n            v11 = v8;\n          }\n        } while ((v4 = (unsigned long long)((unsigned int)v4 + 1),\n                  (unsigned int)v4 < v2));\n        v12 = sdsnewlen(v5 + a0, a1 - v5);\n        *((unsigned long long *)(v0 + v11 * 8)) = v12;\n        if (v12) {\n          *(a4) = (unsigned int)v11 + 1;\n          return v0;\n        }\n      LABEL_403cc2:\n        if ((unsigned int)v11 > 0) {\n          v13 = v0;\n          do {\n            sdsfree(*((long long *)v13));\n            v13 += 8;\n          } while (v13 + (v11 << 3) != v13);\n        }\n      } else {\n        v7 = sdsnewlen(a0, a1);\n        *((unsigned long long *)v0) = v7;\n        if (v7) {\n          *(a4) = 0 + 1;\n          return v0;\n        }\n      }\n      free(v0);\n      *(a4) = 0;\n      v0 = 0;\n      return v0;\n    } else {\n      *(a4) = 0;\n      return v0;\n    }\n  }\n  v0 = 0;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphghmuglm/sdssplitlen.c:66:53: error: 'char *' and 'void *' are not\npointers to compatible types 66 |                         v10 = sdsnewlen(v5 +\na0, v4 - v5); |                                                  ~~ ^ ~~\n/tmp/tmphghmuglm/sdssplitlen.c:75:45: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 75 |                 v12 =\nsdsnewlen(v5 + a0, a1 - v5); |                                          ~~ ^ ~~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsfromlonglong(long long value) {\n    char buf[32], *p;\n    unsigned long long v;\n    v = (value < 0) ? -value : value;\n    p = buf + 31;\n    do {\n        *p-- = '0' + (v % 10);\n        v /= 10;\n    } while (v);\n    if (value < 0)\n        *p-- = '-';\n    p++;\n    return sdsnewlen(p, 32 - (p - buf));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsnewlen)(long long, long long);\n\nlong long sdsfromlonglong_name_conflict(unsigned long a0) {\n  char v0;                // [bp-0xa]\n  char v1;                // [bp-0x9]\n  char v2;                // [bp-0x8]\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  char v6[2];             // r9\n  unsigned long long v7;  // rdx\n  unsigned long long v8;  // rax\n  char v9[2];             // rdi, Other Possible Types: unsigned long\n  unsigned long long v10; // rdi\n\n  v5 = -(a0);\n  if ((char)(-(a0) >> 63))\n    v5 = a0;\n  v9 = &v1;\n  do {\n    v6 = v9;\n    v9 = &v0;\n    v7 = v5 * 14757395258967641293 >> 64 >> 3;\n    *((char *)(v9 + 1)) = (unsigned int)v5 - (unsigned int)v7 * 10 + 48;\n    v8 = v5;\n    v5 = v7;\n  } while (v8 > 9);\n  if (a0 < 0) {\n    *((char *)v9) = 45;\n    v9 = v6 + 1;\n  }\n  v10 = v9 + 1;\n  return sdsnewlen(v10, &(&v2)[-1 * v10]);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj88ced6q/sdsfromlonglong_name_conflict.c:33:8: error: array type 'char[2]' is not\nassignable 33 |     v9 = &v1; |     ~~ ^\n/tmp/tmpj88ced6q/sdsfromlonglong_name_conflict.c:36:12: error: array type 'char[2]' is not\nassignable 36 |         v6 = v9; |         ~~ ^\n/tmp/tmpj88ced6q/sdsfromlonglong_name_conflict.c:37:12: error: array type 'char[2]' is not\nassignable 37 |         v9 = &v0; |         ~~ ^\n/tmp/tmpj88ced6q/sdsfromlonglong_name_conflict.c:46:12: error: array type 'char[2]' is not\nassignable 46 |         v9 = v6 + 1; |         ~~ ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s, \"\\\"\", 1);\n    while (len--)\n        {\n            switch (*p) {\n              case '\\\\':\n              case '\"':\n                s = sdscatprintf(s, \"\\\\%c\", *p);\n                break;\n              case '\\n':\n                s = sdscatlen(s, \"\\\\n\", 2);\n                break;\n              case '\\r':\n                s = sdscatlen(s, \"\\\\r\", 2);\n                break;\n              case '\\t':\n                s = sdscatlen(s, \"\\\\t\", 2);\n                break;\n              case '\\a':\n                s = sdscatlen(s, \"\\\\a\", 2);\n                break;\n              case '\\b':\n                s = sdscatlen(s, \"\\\\b\", 2);\n                break;\n              default:\n                if (((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISprint))\n                    s = sdscatprintf(s, \"%c\", *p);\n                else\n                    s = sdscatprintf(s, \"\\\\x%02x\", (unsigned char)*p);\n                break;\n            }\n            p++;\n        }\n    return sdscatlen(s, \"\\\"\", 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdscatlen)(long long, long long, long long);\nlong long(sdscatprintf)(long long, long long, ...);\n\nlong long sdscatrepr_name_conflict(unsigned long long a0, char *a1, unsigned long a2) {\n  char *v1;              // r12, Other Possible Types: unsigned long\n  unsigned long long v2; // rbp, Other Possible Types: unsigned long\n  unsigned long long v3; // rbx\n\n  v1 = a1;\n  v2 = sdscatlen(a0, \"\\\"\", 1);\n  if (!a2)\n    return sdscatlen(v2, \"\\\"\", 1);\n  while (true) {\n    v3 = *((char *)v1);\n    if ((char)v3 > 34) {\n      if ((char)v3 == 92)\n        goto LABEL_403e4e;\n      else\n        goto LABEL_403f29;\n    } else if ((char)v3 <= 6) {\n    LABEL_403f29:\n    } else {\n      switch ((char)v3) {\n      case 7:\n        v2 = sdscatlen(v2, \"\\\\a\", 2);\n        break;\n      case 8:\n        v2 = sdscatlen(v2, \"\\\\b\", 2);\n        break;\n      case 9:\n        v2 = sdscatlen(v2, \"\\\\t\", 2);\n        break;\n      case 10:\n        v2 = sdscatlen(v2, \"\\\\n\", 2);\n        break;\n      case 13:\n        v2 = sdscatlen(v2, \"\\\\r\", 2);\n        break;\n      case 34:\n      LABEL_403e4e:\n        v2 = sdscatprintf(v2, \"\\\\%c\");\n        break;\n      default:\n      LABEL_403f29:\n        v2 = (!(*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v3 << 1) +\n                           1)) &\n                64)\n                  ? sdscatprintf(v2, \"%c\")\n                  : sdscatprintf(v2, \"\\\\x%02x\"));\n        break;\n      }\n      v1 += 1;\n      if (&a1[a2] == v1)\n        return sdscatlen(v2, \"\\\"\", 1);\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg69imd0m/sdscatrepr_name_conflict.c:68:51: error: cannot take the address of an rvalue\nof type 'int' 68 |                 v2 = (!(*((char *)(*((long long\n*)&__ctype_b_loc()) + ((char)v3 << 1) + 1)) & 64) ? sdscatprintf(v2, \"%c\") :\nsdscatprintf(v2, \"\\\\x%02x\")); | ^~~~~~~~~~~~~~~~\n/tmp/tmpg69imd0m/sdscatrepr_name_conflict.c:67:1: error: redefinition of label 'LABEL_403f29'\n   67 | LABEL_403f29:\n      | ^\n/tmp/tmpg69imd0m/sdscatrepr_name_conflict.c:41:1: note: previous definition is here\n   41 | LABEL_403f29:\n      | ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_hex_digit_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v1; // rax\n  unsigned long long v2; // rax\n\n  v1 = ((unsigned int)a0 & -33) - 65;\n  *((char *)&v1) = (char)v1 <= 5;\n  v2 = (unsigned int)v1 | (char)((unsigned int)a0 - 48) <= 9;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int hex_digit_to_int(char c) {\n    switch (c) {\n      case '0':\n        return 0;\n      case '1':\n        return 1;\n      case '2':\n        return 2;\n      case '3':\n        return 3;\n      case '4':\n        return 4;\n      case '5':\n        return 5;\n      case '6':\n        return 6;\n      case '7':\n        return 7;\n      case '8':\n        return 8;\n      case '9':\n        return 9;\n      case 'a':\n      case 'A':\n        return 10;\n      case 'b':\n      case 'B':\n        return 11;\n      case 'c':\n      case 'C':\n        return 12;\n      case 'd':\n      case 'D':\n        return 13;\n      case 'e':\n      case 'E':\n        return 14;\n      case 'f':\n      case 'F':\n        return 15;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_digit_to_int_name_conflict(unsigned long a0) {\n  switch ((unsigned int)a0) {\n  case 49:\n    return 1;\n  case 50:\n    return 2;\n  case 51:\n    return 3;\n  case 52:\n    return 4;\n  case 53:\n    return 5;\n  case 54:\n    return 6;\n  case 55:\n    return 7;\n  case 56:\n    return 8;\n  case 57:\n    return 9;\n  case 65:\n  case 97:\n    return 10;\n  case 66:\n  case 98:\n    return 11;\n  case 67:\n  case 99:\n    return 12;\n  case 68:\n  case 100:\n    return 13;\n  case 69:\n  case 101:\n    return 14;\n  case 70:\n  case 102:\n    return 15;\n  default:\n    return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = ((void *)0);\n    char **vector = ((void *)0);\n    *argc = 0;\n    while (1)\n        {\n            while (*p && ((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISspace))\n                p++;\n            if (*p) {\n                int inq = 0;\n                int insq = 0;\n                int done = 0;\n                if (current == ((void *)0))\n                    current = sdsempty();\n                while (!done)\n                    {\n                        if (inq) {\n                            if (*p == '\\\\' && *(p + 1) == 'x' && is_hex_digit(*(p + 2)) && is_hex_digit(*(p + 3))) {\n                                unsigned char byte;\n                                byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3));\n                                current = sdscatlen(current, (char *)&byte, 1);\n                                p += 3;\n                            } else if (*p == '\\\\' && *(p + 1)) {\n                                char c;\n                                p++;\n                                switch (*p) {\n                                  case 'n':\n                                    c = '\\n';\n                                    break;\n                                  case 'r':\n                                    c = '\\r';\n                                    break;\n                                  case 't':\n                                    c = '\\t';\n                                    break;\n                                  case 'b':\n                                    c = '\\b';\n                                    break;\n                                  case 'a':\n                                    c = '\\a';\n                                    break;\n                                  default:\n                                    c = *p;\n                                    break;\n                                }\n                                current = sdscatlen(current, &c, 1);\n                            } else if (*p == '\"') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else if (insq) {\n                            if (*p == '\\\\' && *(p + 1) == '\\'') {\n                                p++;\n                                current = sdscatlen(current, \"'\", 1);\n                            } else if (*p == '\\'') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else {\n                            switch (*p) {\n                              case ' ':\n                              case '\\n':\n                              case '\\r':\n                              case '\\t':\n                              case '\\x00':\n                                done = 1;\n                                break;\n                              case '\"':\n                                inq = 1;\n                                break;\n                              case '\\'':\n                                insq = 1;\n                                break;\n                              default:\n                                current = sdscatlen(current, p, 1);\n                                break;\n                            }\n                        }\n                        if (*p)\n                            p++;\n                    }\n                vector = realloc(vector, ((*argc) + 1) * sizeof(char *));\n                vector[*argc] = current;\n                (*argc)++;\n                current = ((void *)0);\n            } else {\n                if (vector == ((void *)0))\n                    vector = malloc(sizeof(void *));\n                return vector;\n            }\n        }\n  err:\n    while ((*argc)--)\n        sdsfree(vector[*argc]);\n    free(vector);\n    if (current)\n        sdsfree(current);\n    *argc = 0;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsempty)();\nlong long(sdscatlen)(long long, long long, long long);\nlong long(is_hex_digit)(long long, long long, long long);\nvoid *(realloc)(void *, unsigned long);\nlong long(sdsfree)(long long);\nlong long(hex_digit_to_int)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long sdssplitargs_name_conflict(char a0[4], unsigned int *a1, unsigned long long a2) {\n  unsigned long long *v0; // [bp-0x70]\n  struct_0 *v1;           // [bp-0x68]\n  unsigned long long *v2; // [bp-0x60], Other Possible Types: unsigned long\n  unsigned int *v3;       // [bp-0x58]\n  unsigned int v4;        // [bp-0x50]\n  unsigned int v5;        // [bp-0x4c]\n  char v6;                // [bp-0x39]\n  char v8[4];             // rbx, Other Possible Types: unsigned long\n  unsigned int *v9;       // r14, Other Possible Types: unsigned long\n  unsigned long long v10; // rbp\n  char v11;               // al\n  char v12;               // al\n  char v13;               // cl\n  char v14;               // r14, Other Possible Types: unsigned long\n  unsigned long long v15; // rax\n  unsigned long long v16; // rax\n  unsigned int v18;       // eax\n  unsigned long long v22; // r15, Other Possible Types: unsigned long\n  unsigned long v23;      // rax\n  unsigned int *v24;      // r14\n  unsigned long long v25; // rdx\n  unsigned long v26;      // rax\n  unsigned long long v27; // rdx\n\n  v8 = a0;\n  v9 = a1;\n  *(a1) = 0;\n  v2 = 0;\n  while (true) {\n  LABEL_404371:\n    v10 = *((char *)v8);\n    if (!(char)v10)\n      break;\n    v0 = &__ctype_b_loc();\n    if ((*((char *)(*(v0) + ((char)v10 << 1) + 1)) & 32)) {\n      v8 += 1;\n    } else {\n      v22 = sdsempty();\n      v1 = &v6;\n      v3 = v9;\n      while (!(int)0) {\n        if (!(int)0) {\n          v13 = *((char *)v8);\n          if (v13 > 39) {\n            v22 = sdscatlen(v22, v8, 1);\n            goto LABEL_40430d;\n          } else if ((4294977025 & 1 << (v13 & 63))) {\n            if (*((char *)v8)) {\n              v18 = 1;\n            } else {\n              v9 = v3;\n              v2 = realloc(v2, (*((int *)v9) + 1) * 8);\n              v23 = *((int *)v9);\n              *((unsigned long *)(v2 + v23 * 8)) = v22;\n              *((unsigned int *)v9) = (unsigned int)v23 + 1;\n              goto LABEL_404371;\n            }\n            v8 += 1;\n          LABEL_4042d3:\n          } else if (v13 == 34) {\n            goto LABEL_4042d3;\n          } else if (v13 == 39) {\n            goto LABEL_4042d3;\n          }\n        } else {\n          v12 = *((char *)v8);\n          if (v12 == 92) {\n            if (*((char *)(v8 + 1)) == 39) {\n              v8 += 1;\n              v22 = sdscatlen(v22, \"'\", 1);\n              goto LABEL_40430d;\n            }\n          } else {\n            if (v12 == 39) {\n              v16 = *((char *)(v8 + 1));\n              if (!(char)v16) {\n                goto LABEL_4042d3;\n              } else {\n                if ((*((char *)(*(v0) + ((char)v16 << 1) + 1)) & 32))\n                  goto LABEL_4042d3;\n              }\n            LABEL_404172:\n              v24 = v3;\n              v25 = *(v24);\n              v26 = v25 - 1;\n              *(v24) = v26;\n              if ((unsigned int)v25) {\n                do {\n                  sdsfree(v2[v26]);\n                  v27 = *(v24);\n                  v26 = v27 - 1;\n                  *(v24) = v26;\n                } while ((unsigned int)v27);\n              }\n              free(v2);\n              if (v22)\n                sdsfree(v22);\n              *(v24) = 0;\n              v2 = 0;\n              return v2;\n            } else if (!v12) {\n              goto LABEL_404172;\n            }\n          }\n          v22 = sdscatlen(v22, v8, 1);\n          goto LABEL_40430d;\n        }\n      }\n      v11 = *((char *)v8);\n      if (v11 == 92) {\n        v14 = *((char *)(v8 + 1));\n        if (v14 != 120) {\n          if (!(!v14))\n            goto LABEL_40407f;\n        } else {\n          v4 = *((char *)(v8 + 2));\n          if ((int)is_hex_digit(v4, 4294977025, a2) &&\n              (v5 = (unsigned int)(char)*((char *)(v8 + 3)),\n               (int)is_hex_digit((unsigned long long)v5, 4294977025, a2))) {\n            v6 = (char)hex_digit_to_int(v4) * 16 + (char)hex_digit_to_int(v5);\n            v22 = sdscatlen(v22, &v6, 1);\n            v8 += 3;\n            goto LABEL_40430d;\n          }\n        LABEL_40407f:\n          v8 += 1;\n          switch (v14) {\n          case 97:\n            v14 = 7;\n            break;\n          case 98:\n            v14 = 8;\n            break;\n          case 110:\n            v14 = 10;\n            break;\n          case 114:\n            v14 = 13;\n            break;\n          case 116:\n            v14 = 9;\n            break;\n          }\n          v6 = v14;\n          v22 = sdscatlen(v22, v1, 1);\n          goto LABEL_40430d;\n        }\n      } else if (v11 == 34) {\n        v15 = *((char *)(v8 + 1));\n        if (!(char)v15) {\n          goto LABEL_4042d3;\n        } else {\n          if ((*((char *)(*(v0) + ((char)v15 << 1) + 1)) & 32))\n            goto LABEL_4042d3;\n        }\n      } else if (!v11) {\n        goto LABEL_404172;\n      }\n      v22 = sdscatlen(v22, v8, 1);\n    LABEL_40430d:\n      v18 = 0;\n      if (!*((char *)v8))\n        goto LABEL_4042d3;\n    }\n  }\n  if (!v2) {\n    v2 = malloc(8);\n    return v2;\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:53:8: error: array type 'char[4]' is not\nassignable 53 |     v8 = a0; |     ~~ ^ /tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:63:14:\nerror: cannot take the address of an rvalue of type 'int' 63 |         v0 =\n&__ctype_b_loc(); |              ^~~~~~~~~~~~~~~~\n/tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:66:16: error: invalid operands to binary\nexpression ('char[4]' and 'int') 66 |             v8 += 1; |             ~~ ^  ~\n/tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:98:28: error: invalid operands to binary\nexpression ('char[4]' and 'int') 98 |                         v8 += 1; | ~~ ^  ~\n/tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:117:32: error: invalid operands to binary\nexpression ('char[4]' and 'int') 117 |                             v8 += 1; | ~~\n^  ~ /tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:183:28: error: invalid operands to binary\nexpression ('char[4]' and 'int') 183 |                         v8 += 3; | ~~ ^ ~\n/tmp/tmpe_8og3wg/sdssplitargs_name_conflict.c:187:24: error: invalid operands to binary\nexpression ('char[4]' and 'int') 187 |                     v8 += 1; | ~~ ^  ~ 7\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_ - 8;\n  char padding_ - 4 [4];\n  char field_0;\n} struct_0;\n\nlong long sdsmapchars(struct_0 *a0, unsigned long a1, unsigned long a2,\n                      unsigned long a3) {\n  unsigned long long v1; // r9\n  struct_0 *v2; // r8, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v3; // r9\n  char *v4;              // rax, Other Possible Types: unsigned long\n\n  v1 = *((int *)&a0->field_0);\n  if (!v1)\n    return a0;\n  v2 = a0;\n  v3 = v1 + (char *)a0;\n  do {\n    if (a3) {\n      v4 = 0;\n      do {\n        if ((char)v2->field_ - 8 == *((char *)(a1 + v4))) {\n          *((char *)&v2->field_ - 8) = *((char *)(a2 + v4));\n          break;\n        }\n      } while ((v2 += 1, v2 != v3));\n    }\n  } while ((v2 += 1, v2 != v3));\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt766cv0u/sdsmapchars.c:18:24: error: expected ';' at end of declaration\nlist 18 |     unsigned int field_-8; |                        ^ | ;\n/tmp/tmpt766cv0u/sdsmapchars.c:19:18: error: expected ';' at end of declaration\nlist 19 |     char padding_-4[4]; |                  ^ |                  ; 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoin(char **argv, int argc, char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsempty)();\nlong long(sdscat)(long long, long long);\nlong long(sdscatlen)(long long, long long, long long);\n\nlong long sdsjoin(unsigned long long *a0, unsigned long a1,\n                  unsigned long long a2, unsigned long long a3) {\n  unsigned long long v2; // rdi, Other Possible Types: unsigned long\n  unsigned long v3;      // rbx\n\n  v2 = sdsempty();\n  if ((unsigned int)a1 <= 0)\n    return v2;\n  v3 = 0;\n  do {\n    v2 = sdscat(v2, a0[v3]);\n    if ((unsigned int)a1 - 1 != (unsigned int)v3)\n      v2 = sdscatlen(v2, a2, a3);\n  } while ((v3 += 1, v3 != a1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(sdsempty)();\nlong long(sdscatsds)(long long, long long);\nlong long(sdscatlen)(long long, long long, long long);\n\nlong long sdsjoinsds(unsigned long long *a0, unsigned long a1,\n                     unsigned long long a2, unsigned long long a3) {\n  unsigned long long v2; // rdi, Other Possible Types: unsigned long\n  unsigned long v3;      // rbx\n\n  v2 = sdsempty();\n  if ((unsigned int)a1 <= 0)\n    return v2;\n  v3 = 0;\n  do {\n    v2 = sdscatsds(v2, a0[v3]);\n    if ((unsigned int)a1 - 1 != (unsigned int)v3)\n      v2 = sdscatlen(v2, a2, a3);\n  } while ((v3 += 1, v3 != a1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_ceil_half_name_conflict(unsigned long a0, unsigned long a1) {\n  return ((a0 & ~(-1 << ((char)a1 & 63)))) + (a0 >> ((char)a1 & 63));\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_ceil_half)(long long, long long);\n\nlong long jbg_stripes(unsigned long a0, unsigned long long a1,\n                      unsigned long long a2) {\n  int tmp_2;             // tmp #2\n  unsigned long long v1; // rax\n\n  v1 = jbg_ceil_half(a1, a2);\n  tmp_2 = (0 CONCAT v1) / m a0;\n  return (0 CONCAT v1) / m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplj8eoesc/jbg_stripes.c:26:16: error: expected ')'\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |                ^\n/tmp/tmplj8eoesc/jbg_stripes.c:26:13: note: to match this '('\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |             ^\n/tmp/tmplj8eoesc/jbg_stripes.c:26:29: error: expected ';' after expression\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |                             ^\n      |                             ;\n/tmp/tmplj8eoesc/jbg_stripes.c:27:15: error: expected ')'\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |               ^\n/tmp/tmplj8eoesc/jbg_stripes.c:27:12: note: to match this '('\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |            ^\n/tmp/tmplj8eoesc/jbg_stripes.c:27:28: error: expected ';' after return statement\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |                            ^\n      |                            ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long errmsg;\n\nlong long jbg_strerror_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  if ((unsigned int)a0 <= 143)\n    v1 = (&errmsg)[a0 >> 4];\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"int nisgraph(char *s, int n) {\n  for (; *s && n; s++, n--)\n    if (!((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISgraph))\n      return (0);\n  return (1);\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_next_pscdms)(long long, long long);\n\nlong long jbg_newlen_name_conflict(char a0[20], unsigned long a1) {\n  unsigned long v0;      // [bp-0x18]\n  unsigned long v1;      // [bp-0x10]\n  unsigned long v2;      // [bp-0x8]\n  unsigned long v4;      // r12\n  unsigned long v5;      // rbx\n  char v6[20];           // rbx\n  unsigned long long v9; // r12\n  char v10[6];           // rax\n  char v11[6];           // rdi, Other Possible Types: unsigned long\n  char v12;              // al\n  unsigned long v13;     // rax, Other Possible Types: unsigned long long\n\n  if (a1 <= 19)\n    return 32;\n  v2 = v4;\n  *((int *)&v1) = rbp;\n  v0 = v5;\n  v6 = a0;\n  v11 = &a0[87 + 8];\n  if ((a0[19] & 7) != 6)\n    v11 = a0 + 1;\n  v9 = &v6[a1];\n  v13 = 32;\n  if (v11 >= v9)\n    return v13;\n  do {\n    do {\n      v10 = jbg_next_pscdms(v11, &v6[a1 + -1 * v11]);\n      v11 = v10;\n      if (!v10) {\n      LABEL_408aa4:\n        return 96;\n      }\n      if (v9 == v10)\n        return 0;\n    } while (v10[0] != 255);\n    v12 = v10[1];\n    if (v12 == 4)\n      return 64;\n  } while (v12 != 5);\n  v6[8] = *((char *)(v11 + 2));\n  v6[9] = *((char *)(v11 + 3));\n  v6[10] = *((char *)(v11 + 4));\n  v6[11] = *((char *)(v11 + 5));\n  v13 = 0;\n  goto LABEL_408aa4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0qf863fk/jbg_newlen_name_conflict.c:38:8: error: array type 'char[20]' is not\nassignable 38 |     v6 = a0; |     ~~ ^ /tmp/tmp0qf863fk/jbg_newlen_name_conflict.c:39:9:\nerror: array type 'char[6]' is not assignable 39 |     v11 = &a0[87 + 8]; | ~~~\n^ /tmp/tmp0qf863fk/jbg_newlen_name_conflict.c:41:13: error: array type 'char[6]' is not\nassignable 41 |         v11 = a0 + 1; |         ~~~ ^\n/tmp/tmp0qf863fk/jbg_newlen_name_conflict.c:50:52: error: invalid operands to binary\nexpression ('int' and 'char[6]') 50 |             v10 = jbg_next_pscdms(v11,\n&v6[a1 + -1 * v11]); |                                                 ~~ ^ ~~~\n/tmp/tmp0qf863fk/jbg_newlen_name_conflict.c:51:17: error: array type 'char[6]' is not\nassignable 51 |             v11 = v10; |             ~~~ ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long errmsg;\n\nlong long jbg85_strerror_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  if ((unsigned int)a0 <= 127)\n    v1 = (&errmsg)[a0 >> 4];\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_ceil_half_name_conflict(unsigned long a0, unsigned long a1) {\n  return ((a0 & ~(-1 << ((char)a1 & 63)))) + (a0 >> ((char)a1 & 63));\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_ceil_half)(long long, long long);\n\nlong long jbg_stripes(unsigned long a0, unsigned long long a1,\n                      unsigned long long a2) {\n  int tmp_2;             // tmp #2\n  unsigned long long v1; // rax\n\n  v1 = jbg_ceil_half(a1, a2);\n  tmp_2 = (0 CONCAT v1) / m a0;\n  return (0 CONCAT v1) / m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptqecqsea/jbg_stripes.c:26:16: error: expected ')'\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |                ^\n/tmp/tmptqecqsea/jbg_stripes.c:26:13: note: to match this '('\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |             ^\n/tmp/tmptqecqsea/jbg_stripes.c:26:29: error: expected ';' after expression\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |                             ^\n      |                             ;\n/tmp/tmptqecqsea/jbg_stripes.c:27:15: error: expected ')'\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |               ^\n/tmp/tmptqecqsea/jbg_stripes.c:27:12: note: to match this '('\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |            ^\n/tmp/tmptqecqsea/jbg_stripes.c:27:28: error: expected ';' after return statement\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |                            ^\n      |                            ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long errmsg;\n\nlong long jbg_strerror_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  if ((unsigned int)a0 <= 143)\n    v1 = (&errmsg)[a0 >> 4];\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_next_pscdms_name_conflict(char a0[6], unsigned long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v1;      // [bp-0x8]\n  unsigned long v3;      // rbx\n  char v4[6];            // rbx, Other Possible Types: unsigned long\n  unsigned long long v5; // rdx\n  unsigned long long v6; // rbp, Other Possible Types: unsigned long\n  void *v7; // rax, Other Possible Types: unsigned long, unsigned long long,\n            // char [6]\n  unsigned long long v8; // rdx\n\n  if (a1 <= 1)\n    return 0;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  v4 = a0;\n  v6 = a1;\n  if (a0[0] == 255) {\n    v5 = a0[1];\n    if ((char)v5) {\n      if ((char)v5 == 6) {\n        v7 = &a0[1 + 2];\n        if (a1 > 7)\n          return v7;\n        v7 = 0;\n      } else if (!((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x5 < 64 >,\n                                                        Conv(8->64, dl<1>),\n                                                        0x6 < 64 >, cc_ndep))) {\n        if ((char)v5 != 7) {\n          return 0;\n        } else if (a1 > 5) {\n          v8 = a0[2] * 0x1000000 | a0[3] * 0x10000 | a0[5] | a0[4] * 0x100;\n          v7 = &a0[v8 + 6];\n          if (a1 - 6 >= v8)\n            return v7;\n          v7 = 0;\n        } else {\n          return 0;\n        }\n      } else {\n        if ((char)v5 <= 4) {\n          if ((char)v5 <= 1)\n            return 0;\n          return &a0[2];\n        } else {\n          if ((char)v5 != 5)\n            return 0;\n          v7 = a0 + 1;\n          if (a1 > 5)\n            return v7;\n          v7 = 0;\n        }\n      }\n    }\n  }\n  for (; !(*((char *)v4) != 255) && !(*((char *)(v4 + 1))); v4 = v7) {\n    v7 = v4 + 2;\n    v6 -= 2;\n    if (v6 <= 1)\n      return 0;\n  }\n  v7 = memchr(v4, 255, v6 - 1);\n  if (!v7)\n    return v7;\n  v6 -= &v7[-1 * v4];\n  if (v7[1])\n    return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9dt11l_a/jbg_next_pscdms_name_conflict.c:33:8: error: array type 'char[6]' is not\nassignable 33 |     v4 = a0; |     ~~ ^\n/tmp/tmp9dt11l_a/jbg_next_pscdms_name_conflict.c:47:30: error: expected expression\n   47 |             else if (!((char)[D] amd64g_calculate_condition(0x6<64>,\n0x5<64>, Conv(8->64, dl<1>), 0x6<64>, cc_ndep))) | ^\n/tmp/tmp9dt11l_a/jbg_next_pscdms_name_conflict.c:86:66: error: array type 'char[6]' is not\nassignable 86 |     for (; !(*((char *)v4) != 255) && !(*((char *)(v4 + 1))); v4\n= v7) |                                                               ~~ ^\n/tmp/tmp9dt11l_a/jbg_next_pscdms_name_conflict.c:96:18: error: invalid operands to binary\nexpression ('int' and 'char[6]') 96 |     v6 -= &v7[-1 * v4]; |               ~~\n^ ~~ /tmp/tmp9dt11l_a/jbg_next_pscdms_name_conflict.c:97:5: error: statement requires\nexpression of scalar type ('void' invalid) 97 |     if (v7[1]) |     ^   ~~~~~\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_next_pscdms)(long long, long long);\n\nlong long jbg_newlen_name_conflict(char a0[20], unsigned long a1) {\n  unsigned long v0;      // [bp-0x18]\n  unsigned long v1;      // [bp-0x10]\n  unsigned long v2;      // [bp-0x8]\n  unsigned long v4;      // r12\n  unsigned long v5;      // rbx\n  char v6[20];           // rbx\n  unsigned long long v9; // r12\n  char v10[6];           // rax\n  char v11[6];           // rdi, Other Possible Types: unsigned long\n  char v12;              // al\n  unsigned long v13;     // rax, Other Possible Types: unsigned long long\n\n  if (a1 <= 19)\n    return 32;\n  v2 = v4;\n  *((int *)&v1) = rbp;\n  v0 = v5;\n  v6 = a0;\n  v11 = &a0[87 + 8];\n  if ((a0[19] & 7) != 6)\n    v11 = a0 + 1;\n  v9 = &v6[a1];\n  v13 = 32;\n  if (v11 >= v9)\n    return v13;\n  do {\n    do {\n      v10 = jbg_next_pscdms(v11, &v6[a1 + -1 * v11]);\n      v11 = v10;\n      if (!v10) {\n      LABEL_408b11:\n        return 96;\n      }\n      if (v9 == v10)\n        return 0;\n    } while (v10[0] != 255);\n    v12 = v10[1];\n    if (v12 == 4)\n      return 64;\n  } while (v12 != 5);\n  v6[8] = *((char *)(v11 + 2));\n  v6[9] = *((char *)(v11 + 3));\n  v6[10] = *((char *)(v11 + 4));\n  v6[11] = *((char *)(v11 + 5));\n  v13 = 0;\n  goto LABEL_408b11;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppw8sl7jw/jbg_newlen_name_conflict.c:38:8: error: array type 'char[20]' is not\nassignable 38 |     v6 = a0; |     ~~ ^ /tmp/tmppw8sl7jw/jbg_newlen_name_conflict.c:39:9:\nerror: array type 'char[6]' is not assignable 39 |     v11 = &a0[87 + 8]; | ~~~\n^ /tmp/tmppw8sl7jw/jbg_newlen_name_conflict.c:41:13: error: array type 'char[6]' is not\nassignable 41 |         v11 = a0 + 1; |         ~~~ ^\n/tmp/tmppw8sl7jw/jbg_newlen_name_conflict.c:50:52: error: invalid operands to binary\nexpression ('int' and 'char[6]') 50 |             v10 = jbg_next_pscdms(v11,\n&v6[a1 + -1 * v11]); |                                                 ~~ ^ ~~~\n/tmp/tmppw8sl7jw/jbg_newlen_name_conflict.c:51:17: error: array type 'char[6]' is not\nassignable 51 |             v11 = v10; |             ~~~ ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long errmsg;\n\nlong long jbg85_strerror_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  if ((unsigned int)a0 <= 127)\n    v1 = (&errmsg)[a0 >> 4];\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char **orig_image, int width, int height, int options, int order, int layers, int planes, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg_enc_state sje;\n    struct jbg_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size;\n    int i, result;\n    unsigned char **image;\n    plane_size = ((width + 7) / 8) * height;\n    image = (unsigned char **)checkedmalloc(planes * sizeof(unsigned char *));\n    for (i = 0; i < planes; i++) {\n        image[i] = (unsigned char *)checkedmalloc(plane_size);\n        memcpy(image[i], orig_image[i], plane_size);\n    }\n    printf(\"\\nTest %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg_enc_init(&sje, width, height, planes, image, testbuf_writel, ((void *)0));\n    jbg_enc_layers(&sje, layers);\n    jbg_enc_options(&sje, order, options, l0, mx, 0);\n    jbg_enc_out(&sje);\n    jbg_enc_free(&sje);\n    for (i = 0; i < planes; i++)\n        free(image[i]);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    printf(\"Test %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = jbg_dec_in(&sjd, testbuf, testbuf_len, ((void *)0));\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value %d: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        for (i = 0; i < planes; i++) {\n            if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n            }\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    jbg_dec_free(&sjd);\n    printf(\"Test %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value %d at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value %d at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            for (i = 0; i < planes; i++) {\n                if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                    result = 0;\n                    trouble++;\n                    printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n                }\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    jbg_dec_free(&sjd);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint testbuf_writel; // add global variable by heuristics\nint testbuf_writel; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkedmalloc)(long long);\nlong long(jbg_enc_init)(long long, long long, long long, long long, long long,\n                        long long, long long);\nlong long(jbg_enc_layers)(long long, long long);\nlong long(jbg_enc_options)(long long, long long, long long, long long,\n                           long long, long long);\nlong long(jbg_enc_out)(long long);\nlong long(jbg_enc_free)(long long);\nlong long(jbg_dec_init)(long long);\nlong long(jbg_dec_in)(long long, long long, long long, long long);\nlong long(jbg_strerror)(long long);\nlong long(jbg_dec_free)(long long);\n\nextern char g_409078;\nextern char g_4090d8;\nextern char g_409128;\nextern char g_409180;\nextern char g_4091d8;\nextern char g_409ba5;\nextern unsigned long long testbuf;\nextern void *testbuf_len;\n\nlong long test_cycle(void **a0, unsigned long a1, unsigned long a2,\n                     unsigned long a3, unsigned long a4, unsigned long long *a5,\n                     unsigned int v6, unsigned long long a6, unsigned int a7,\n                     unsigned long a8, unsigned long a9) {\n  unsigned long long *v0;  // [bp-0x650], Other Possible Types: unsigned int\n  unsigned long long *v1;  // [bp-0x644]\n  unsigned long long *v2;  // [bp-0x640]\n  unsigned long v3;        // [bp-0x630]\n  char v4;                 // [bp-0x628]\n  char v5;                 // [bp-0xf8]\n  unsigned long v8;        // rax\n  unsigned long v9;        // r15\n  unsigned long long v10;  // r13\n  unsigned long long *v11; // rax\n  unsigned long long v12;  // r13\n  void *v13;               // rax\n  unsigned long long *v14; // rbp, Other Possible Types: unsigned long\n  void **v15;              // r12, Other Possible Types: unsigned long\n  void **v16;              // rbx, Other Possible Types: unsigned long\n  unsigned long\n      v17; // rbp, Other Possible Types: unsigned int, unsigned long long\n  unsigned long long v18; // rax\n  void *v19;              // rbx, Other Possible Types: unsigned long\n  void *v20;              // r12, Other Possible Types: unsigned long\n  unsigned long long v21; // rax\n  unsigned long v22;      // rbx, Other Possible Types: unsigned long long\n  void *v23;              // r12, Other Possible Types: unsigned long\n  unsigned long long v24; // r13\n\n  *((unsigned int *)&v2) = a1;\n  *((unsigned int *)&v1) = (unsigned int)a5;\n  v8 = (unsigned int)a2 *\n       (unsigned int)(((char)[D] amd64g_calculate_condition(\n                           0x9 < 64 >, 0x3 < 64 >, rsi, 0x7 < 64 >, cc_ndep)\n                           ? (unsigned int)a1 + 7\n                           : (unsigned int)(a1 + 14)) >>\n                      3);\n  v9 = v8;\n  v3 = v6;\n  v10 = v3 * 8;\n  v11 = checkedmalloc(v10);\n  v0 = v11;\n  if (v6 <= 0) {\n    printf(\"\\nTest %s.1: Encoding ...\\n\", (unsigned int)a9);\n    testbuf_len = 0;\n    jbg_enc_init(&v5, (int)v2, (int)a2, v6, v0, testbuf_writel, 0);\n    jbg_enc_layers(&v5, (int)v1);\n    jbg_enc_options(&v5, (unsigned int)a4, (unsigned int)a3, a6, a7, 0);\n    jbg_enc_out(&v5);\n    jbg_enc_free(&v5);\n  } else {\n    v14 = v11;\n    v16 = v11;\n    v15 = a0;\n    v12 = v10 + (char *)v11;\n    do {\n      v13 = checkedmalloc(v9);\n      *((void **)v14) = v13;\n      memcpy(v13, *((long long *)v15), v9);\n      v14 += 8;\n      v15 += 8;\n    } while (v14 != v12);\n    printf(\"\\nTest %s.1: Encoding ...\\n\", (unsigned int)a9);\n    testbuf_len = 0;\n    jbg_enc_init(&v5, (int)v2, (int)a2, v6, v0, testbuf_writel, 0);\n    jbg_enc_layers(&v5, (int)v1);\n    jbg_enc_options(&v5, (unsigned int)a4, (unsigned int)a3, a6, a7, 0);\n    jbg_enc_out(&v5);\n    jbg_enc_free(&v5);\n    do {\n      free(*((long long *)v16));\n      v16 += 8;\n    } while (v16 != v12);\n  }\n  free(v0);\n  printf(\"Encoded BIE has %6ld bytes: \", (unsigned int)testbuf_len);\n  if ((char)(a8 - 0 >> 63)) {\n    puts(&g_409ba5);\n    v17 = 0;\n  } else if (testbuf_len == a8) {\n    puts(\"PASSED\");\n    v17 = 0;\n  } else {\n    printf(&g_409078, (unsigned int)a8);\n    v17 = 1;\n  }\n  printf(\"Test %s.2: Decoding whole chunk ...\\n\", (unsigned int)a9);\n  jbg_dec_init(&v4);\n  v18 = jbg_dec_in(&v4, testbuf, testbuf_len, 0);\n  if ((unsigned int)v18) {\n    printf(&g_4090d8, (unsigned int)v18, (int)jbg_strerror(v18));\n    v17 = (unsigned int)v17 + 1;\n  } else {\n    printf(\"Image comparison: \");\n    if (v6 > 0) {\n      v19 = 0;\n      *((int *)&v0) = 1;\n      *((unsigned int *)&v2) = v18;\n      do {\n        if (memcmp(\n                a0[v19],\n                *((long long *)(*((long long *)&(&v4)[96 + 8 * ((int)v1 & 1)]) +\n                                (v19 << 3))),\n                v9)) {\n          v17 = (unsigned int)v17 + 1;\n          printf(&g_409128, (unsigned int)v19);\n          v0 = (int)v2;\n        }\n      } while ((v19 += 1, v3 != v19));\n      if (!v0)\n        jbg_dec_free(&v4);\n    }\n    puts(\"PASSED\");\n  }\n  jbg_dec_free(&v4);\n  printf(\"Test %s.3: Decoding with single-byte feed ...\\n\", (unsigned int)a9);\n  jbg_dec_init(&v4);\n  if (testbuf_len > 0) {\n    v20 = 0;\n    do {\n      v21 = jbg_dec_in(&v4, v20 + testbuf, 1, 0);\n      if (testbuf_len - 1 > v20 && (unsigned int)v21 != 32) {\n        v22 = v21;\n        printf(&g_409180, (unsigned int)v21, (unsigned int)v20,\n               (int)jbg_strerror(v21));\n        v17 = (unsigned int)v17 + 1;\n        goto LABEL_4017f8;\n      }\n    } while ((v19 += 1, v3 != v19));\n    v22 = v21;\n  LABEL_4017f8:\n    if (testbuf_len != v20) {\n      jbg_dec_free(&v4);\n      puts(&g_409ba5);\n      return (unsigned int)v17;\n    }\n    if (!(unsigned int)v22) {\n      printf(\"Image comparison: \");\n      if (v6 > 0) {\n        v23 = 0;\n        *((int *)&v0) = 1;\n        v24 = ((int)v1 & 1) + 12;\n        *((unsigned int *)&v1) = v22;\n        do {\n          if (memcmp(a0[v23],\n                     *((long long *)(*((long long *)&(&v4)[8 * v24]) +\n                                     (v23 << 3))),\n                     v9)) {\n            v17 = (unsigned int)v17 + 1;\n            printf(&g_409128, (unsigned int)v23);\n            v0 = (int)v1;\n          }\n        } while ((v19 += 1, v3 != v19));\n        if (!v0) {\n          jbg_dec_free(&v4);\n          puts(&g_409ba5);\n          return (unsigned int)v17;\n        }\n      }\n      puts(\"PASSED\");\n      jbg_dec_free(&v4);\n      puts(&g_409ba5);\n      return (unsigned int)v17;\n    }\n  } else if (!testbuf_len) {\n    v22 = 32;\n  } else {\n    jbg_dec_free(&v4);\n    puts(&g_409ba5);\n    return (unsigned int)v17;\n  }\n  printf(&g_4091d8, (unsigned int)v22, (int)jbg_strerror(v22));\n  v17 = (unsigned int)v17 + 1;\n  jbg_dec_free(&v4);\n  puts(&g_409ba5);\n  return (unsigned int)v17;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcpmv5pc9/test_cycle.c:66:51: error: expected expression\n   66 |     v8 = (unsigned int)a2 * (unsigned int)(((char)[D]\namd64g_calculate_condition(0x9<64>, 0x3<64>, rsi, 0x7<64>, cc_ndep) ? (unsigned\nint)a1 + 7 : (unsigned int)(a1 + 14)) >> 3); | ^\n/tmp/tmpcpmv5pc9/test_cycle.c:144:30: error: array subscript is not an integer\n  144 |                 if (memcmp(a0[v19], *((long long *)(*((long long\n*)&(&v4)[96 + 8 * ((int)v1 & 1)]) + (v19 << 3))), v9)) | ^~~~\n/tmp/tmpcpmv5pc9/test_cycle.c:144:107: error: invalid operands to binary\nexpression ('void *' and 'int') 144 |                 if (memcmp(a0[v19],\n*((long long *)(*((long long *)&(&v4)[96 + 8 * ((int)v1 & 1)]) + (v19 << 3))),\nv9)) | ~~~ ^  ~ /tmp/tmpcpmv5pc9/test_cycle.c:192:34: error: array subscript is\nnot an integer 192 |                     if (memcmp(a0[v23], *((long long\n*)(*((long long *)&(&v4)[8 * v24]) + (v23 << 3))), v9)) | ^~~~\n/tmp/tmpcpmv5pc9/test_cycle.c:192:96: error: invalid operands to binary\nexpression ('void *' and 'int') 192 |                     if (memcmp(a0[v23],\n*((long long *)(*((long long *)&(&v4)[8 * v24]) + (v23 << 3))), v9)) | ~~~ ^  ~\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec.c"}
{"compilable":1,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_ceil_half_name_conflict(unsigned long a0, unsigned long a1) {\n  return ((a0 & ~(-1 << ((char)a1 & 63)))) + (a0 >> ((char)a1 & 63));\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_ceil_half)(long long, long long);\n\nlong long jbg_stripes(unsigned long a0, unsigned long long a1,\n                      unsigned long long a2) {\n  int tmp_2;             // tmp #2\n  unsigned long long v1; // rax\n\n  v1 = jbg_ceil_half(a1, a2);\n  tmp_2 = (0 CONCAT v1) / m a0;\n  return (0 CONCAT v1) / m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbyaohqxa/jbg_stripes.c:26:16: error: expected ')'\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |                ^\n/tmp/tmpbyaohqxa/jbg_stripes.c:26:13: note: to match this '('\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |             ^\n/tmp/tmpbyaohqxa/jbg_stripes.c:26:29: error: expected ';' after expression\n   26 |     tmp_2 = (0 CONCAT v1) /m a0;\n      |                             ^\n      |                             ;\n/tmp/tmpbyaohqxa/jbg_stripes.c:27:15: error: expected ')'\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |               ^\n/tmp/tmpbyaohqxa/jbg_stripes.c:27:12: note: to match this '('\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |            ^\n/tmp/tmpbyaohqxa/jbg_stripes.c:27:28: error: expected ';' after return statement\n   27 |     return (0 CONCAT v1) /m a0 - -1 - ((long long)(tmp_2 >> 64) < 1);\n      |                            ^\n      |                            ;\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long errmsg;\n\nlong long jbg_strerror_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  if ((unsigned int)a0 <= 143)\n    v1 = (&errmsg)[a0 >> 4];\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long jbg_next_pscdms_name_conflict(char a0[6], unsigned long a1) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v1;      // [bp-0x8]\n  unsigned long v3;      // rbx\n  char v4[6];            // rbx, Other Possible Types: unsigned long\n  unsigned long long v5; // rdx\n  unsigned long long v6; // rbp, Other Possible Types: unsigned long\n  void *v7; // rax, Other Possible Types: unsigned long long, unsigned long,\n            // char [6]\n  unsigned long long v8; // rdx\n\n  if (a1 <= 1)\n    return 0;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  v4 = a0;\n  v6 = a1;\n  if (a0[0] == 255) {\n    v5 = a0[1];\n    if ((char)v5) {\n      if ((char)v5 == 6) {\n        v7 = &a0[1 + 2];\n        if (a1 > 7)\n          return v7;\n        v7 = 0;\n      } else if (!((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x5 < 64 >,\n                                                        Conv(8->64, dl<1>),\n                                                        0x6 < 64 >, cc_ndep))) {\n        if ((char)v5 != 7) {\n          return 0;\n        } else if (a1 > 5) {\n          v8 = a0[2] * 0x1000000 | a0[3] * 0x10000 | a0[5] | a0[4] * 0x100;\n          v7 = &a0[v8 + 6];\n          if (a1 - 6 >= v8)\n            return v7;\n          v7 = 0;\n        } else {\n          return 0;\n        }\n      } else {\n        if ((char)v5 <= 4) {\n          if ((char)v5 <= 1)\n            return 0;\n          return &a0[2];\n        } else {\n          if ((char)v5 != 5)\n            return 0;\n          v7 = a0 + 1;\n          if (a1 > 5)\n            return v7;\n          v7 = 0;\n        }\n      }\n    }\n  }\n  for (; !(*((char *)v4) != 255) && !(*((char *)(v4 + 1))); v4 = v7) {\n    v7 = v4 + 2;\n    v6 -= 2;\n    if (v6 <= 1)\n      return 0;\n  }\n  v7 = memchr(v4, 255, v6 - 1);\n  if (!v7)\n    return v7;\n  v6 -= &v7[-1 * v4];\n  if (v7[1])\n    return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpodiizl_r/jbg_next_pscdms_name_conflict.c:33:8: error: array type 'char[6]' is not\nassignable 33 |     v4 = a0; |     ~~ ^\n/tmp/tmpodiizl_r/jbg_next_pscdms_name_conflict.c:47:30: error: expected expression\n   47 |             else if (!((char)[D] amd64g_calculate_condition(0x6<64>,\n0x5<64>, Conv(8->64, dl<1>), 0x6<64>, cc_ndep))) | ^\n/tmp/tmpodiizl_r/jbg_next_pscdms_name_conflict.c:86:66: error: array type 'char[6]' is not\nassignable 86 |     for (; !(*((char *)v4) != 255) && !(*((char *)(v4 + 1))); v4\n= v7) |                                                               ~~ ^\n/tmp/tmpodiizl_r/jbg_next_pscdms_name_conflict.c:96:18: error: invalid operands to binary\nexpression ('int' and 'char[6]') 96 |     v6 -= &v7[-1 * v4]; |               ~~\n^ ~~ /tmp/tmpodiizl_r/jbg_next_pscdms_name_conflict.c:97:5: error: statement requires\nexpression of scalar type ('void' invalid) 97 |     if (v7[1]) |     ^   ~~~~~\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(jbg_next_pscdms)(long long, long long);\n\nlong long jbg_newlen_name_conflict(char a0[20], unsigned long a1) {\n  unsigned long v0;      // [bp-0x18]\n  unsigned long v1;      // [bp-0x10]\n  unsigned long v2;      // [bp-0x8]\n  unsigned long v4;      // r12\n  unsigned long v5;      // rbx\n  char v6[20];           // rbx\n  unsigned long long v9; // r12\n  char v10[6];           // rax\n  char v11[6];           // rdi, Other Possible Types: unsigned long\n  char v12;              // al\n  unsigned long v13;     // rax, Other Possible Types: unsigned long long\n\n  if (a1 <= 19)\n    return 32;\n  v2 = v4;\n  *((int *)&v1) = rbp;\n  v0 = v5;\n  v6 = a0;\n  v11 = &a0[87 + 8];\n  if ((a0[19] & 7) != 6)\n    v11 = a0 + 1;\n  v9 = &v6[a1];\n  v13 = 32;\n  if (v11 >= v9)\n    return v13;\n  do {\n    do {\n      v10 = jbg_next_pscdms(v11, &v6[a1 + -1 * v11]);\n      v11 = v10;\n      if (!v10) {\n      LABEL_408de3:\n        return 96;\n      }\n      if (v9 == v10)\n        return 0;\n    } while (v10[0] != 255);\n    v12 = v10[1];\n    if (v12 == 4)\n      return 64;\n  } while (v12 != 5);\n  v6[8] = *((char *)(v11 + 2));\n  v6[9] = *((char *)(v11 + 3));\n  v6[10] = *((char *)(v11 + 4));\n  v6[11] = *((char *)(v11 + 5));\n  v13 = 0;\n  goto LABEL_408de3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpore1wwrm/jbg_newlen_name_conflict.c:38:8: error: array type 'char[20]' is not\nassignable 38 |     v6 = a0; |     ~~ ^ /tmp/tmpore1wwrm/jbg_newlen_name_conflict.c:39:9:\nerror: array type 'char[6]' is not assignable 39 |     v11 = &a0[87 + 8]; | ~~~\n^ /tmp/tmpore1wwrm/jbg_newlen_name_conflict.c:41:13: error: array type 'char[6]' is not\nassignable 41 |         v11 = a0 + 1; |         ~~~ ^\n/tmp/tmpore1wwrm/jbg_newlen_name_conflict.c:50:52: error: invalid operands to binary\nexpression ('int' and 'char[6]') 50 |             v10 = jbg_next_pscdms(v11,\n&v6[a1 + -1 * v11]); |                                                 ~~ ^ ~~~\n/tmp/tmpore1wwrm/jbg_newlen_name_conflict.c:51:17: error: array type 'char[6]' is not\nassignable 51 |             v11 = v10; |             ~~~ ^ 5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long errmsg;\n\nlong long jbg85_strerror_name_conflict(unsigned long a0) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n\n  v1 = \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  if ((unsigned int)a0 <= 127)\n    v1 = (&errmsg)[a0 >> 4];\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char *orig_image, int width, int height, int options, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg85_enc_state sje;\n    struct jbg85_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size, buffer_len;\n    int i, result;\n    unsigned char *image, *buffer;\n    size_t bpl;\n    size_t cnt;\n    bpl = (width + 7) / 8;\n    plane_size = bpl * height;\n    image = (unsigned char *)checkedmalloc(plane_size);\n    memcpy(image, orig_image, plane_size);\n    printf(\"\\nTest-85 %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg85_enc_init(&sje, width, height, testbuf_writel, ((void *)0));\n    jbg85_enc_options(&sje, options, l0, mx);\n    for (i = 0; i < height; i++)\n        jbg85_enc_lineout(&sje, image + i * bpl, image + (i - 1) * bpl, image + (i - 2) * bpl);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    buffer_len = ((width >> 3) + !!(width & 7)) * 3;\n    buffer = (unsigned char *)checkedmalloc(buffer_len);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = jbg85_dec_in(&sjd, testbuf, testbuf_len, &cnt);\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value 0x%02x: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n        printf(\"%ld bytes of BIE read, %lu lines decoded.\\n\", (long)cnt, sjd.y);\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        if (memcmp(orig_image, image, plane_size)) {\n            result = 0;\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    free(image);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg85_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg85_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            if (memcmp(orig_image, image, plane_size)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    free(image);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint testbuf_writel; // add global variable by heuristics\nint line_out;       // add global variable by heuristics\nint line_out;       // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(checkedmalloc)(long long);\nlong long(jbg85_enc_init)(long long, long long, long long, long long,\n                          long long);\nlong long(jbg85_enc_options)(long long, long long, long long, long long);\nlong long(jbg85_enc_lineout)(long long, long long, long long, long long);\nlong long(jbg85_dec_init)(long long, long long, long long, long long,\n                          long long);\nlong long(jbg85_dec_in)(long long, long long, long long, long long);\nlong long(jbg85_strerror)(long long);\n\nextern char g_405078;\nextern char g_4050d8;\nextern char g_405190;\nextern char g_4051f0;\nextern char g_4057a2;\nextern char g_4057e3;\nextern unsigned long long testbuf;\nextern void *testbuf_len;\n\nlong long test_cycle(void *a0, unsigned long long a1, unsigned long long a2,\n                     unsigned long a3, unsigned long long a4,\n                     unsigned long long a5, unsigned long v8,\n                     unsigned long a6) {\n  unsigned long v0;       // [bp-0x2630]\n  void *v1;               // [bp-0x2628]\n  unsigned int v2;        // [bp-0x2614]\n  char v3;                // [bp-0x2600]\n  char v4;                // [bp-0x25f8]\n  char v5;                // [bp-0x1540]\n  char v6;                // [bp-0x14d8]\n  unsigned long v7;       // [bp-0x30]\n  unsigned long v9;       // rbx\n  unsigned int v10;       // r13d\n  unsigned long long v12; // r12\n  unsigned long long v13; // rcx\n  unsigned long long v14; // rdx\n  unsigned long v15;      // rbx, Other Possible Types: unsigned long long\n  unsigned long\n      v16; // r13, Other Possible Types: unsigned int, unsigned long long\n  unsigned long long v17; // rbx\n  unsigned long long v18; // r12\n  void *v19;              // rbp\n  unsigned long long v20; // rax\n  void *v21;              // r14\n  void *v22;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v23; // rax\n  unsigned long v24;      // rbp, Other Possible Types: unsigned long long\n\n  v7 = v9;\n  v10 = a2;\n  v2 = a3;\n  v12 = ((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x3 < 64 >, rsi,\n                                              0x7 < 64 >, cc_ndep)\n             ? (unsigned int)a1 + 7\n             : (unsigned int)(a1 + 14)) >>\n        3;\n  v0 = v12 * a2;\n  v1 = checkedmalloc(v0);\n  memcpy(v1, a0, v0);\n  printf(\"\\nTest-85 %s.1: Encoding ...\\n\", (unsigned int)a6);\n  testbuf_len = 0;\n  jbg85_enc_init(&v6, a1, a2, testbuf_writel, 0);\n  jbg85_enc_options(&v6, v2, a4, a5);\n  if (v10 > 0) {\n    v15 = v1 - v12;\n    do {\n      v13 = v15 - v12;\n      v14 = v15;\n      v15 += v12;\n      jbg85_enc_lineout(&v6, v15, v14, v13);\n    } while (v10 != 1);\n  }\n  free(v1);\n  printf(\"Encoded BIE has %6ld bytes: \", (unsigned int)testbuf_len);\n  if ((char)(v8 - 0 >> 63)) {\n    puts(&g_4057e3);\n    v16 = 0;\n  } else if (testbuf_len == v8) {\n    puts(\"PASSED\");\n    v16 = 0;\n  } else {\n    printf(&g_405078, (unsigned int)v8);\n    v16 = 1;\n  }\n  v17 = ((((char)a1 & 7)) + (a1 >> 3)) * 3;\n  v18 = checkedmalloc(v17);\n  v19 = checkedmalloc(v0);\n  printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", (unsigned int)a6);\n  jbg85_dec_init(&v4, v18, v17, line_out, v19);\n  v20 = jbg85_dec_in(&v4, testbuf, testbuf_len, &v3);\n  if ((unsigned int)v20) {\n    printf(&g_4050d8, (unsigned int)v20, (int)jbg85_strerror(v20));\n    printf(\"%ld bytes of BIE read, %lu lines decoded.\\n\",\n           (int)*((long long *)&v3), (int)*((long long *)&v5));\n    v16 = (unsigned int)v16 + 1;\n  } else {\n    printf(\"Image comparison: \");\n    if (!memcmp(a0, v19, v0)) {\n      puts(\"PASSED\");\n    } else {\n      v16 = (unsigned int)v16 + 1;\n      printf(&g_4057a2);\n    }\n  }\n  free(v19);\n  v21 = checkedmalloc(v0);\n  printf(\"Test-85 %s.3: Decoding with single-byte feed ...\\n\",\n         (unsigned int)a6);\n  jbg85_dec_init(&v4, v18, v17, line_out, v21);\n  if (testbuf_len > 0) {\n    v22 = 0;\n    do {\n      v23 = jbg85_dec_in(&v4, v22 + testbuf, 1, 0);\n      if (testbuf_len - 1 > v22 && (unsigned int)v23 != 32) {\n        v24 = v23;\n        printf(&g_405190, (unsigned int)v23, (unsigned int)v22,\n               (int)jbg85_strerror(v23));\n        v16 = (unsigned int)v16 + 1;\n        goto LABEL_4017b9;\n      }\n    } while ((v22 += 1, testbuf_len > v22));\n    v24 = v23;\n  LABEL_4017b9:\n    if (testbuf_len != v22) {\n      free(v21);\n      puts(&g_4057e3);\n      return (unsigned int)v16;\n    }\n    if (!(unsigned int)v24) {\n      printf(\"Image comparison: \");\n      if (!memcmp(a0, v21, v0)) {\n        puts(\"PASSED\");\n        free(v21);\n        puts(&g_4057e3);\n        return (unsigned int)v16;\n      }\n      v16 = (unsigned int)v16 + 1;\n      printf(&g_4057a2);\n      free(v21);\n      puts(&g_4057e3);\n      return (unsigned int)v16;\n    }\n  } else if (!testbuf_len) {\n    v24 = 32;\n  } else {\n    free(v21);\n    puts(&g_4057e3);\n    return (unsigned int)v16;\n  }\n  printf(&g_4051f0, (unsigned int)v24, (int)jbg85_strerror(v24));\n  v16 = (unsigned int)v16 + 1;\n  free(v21);\n  puts(&g_4057e3);\n  return (unsigned int)v16;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2ihkevfp/test_cycle.c:65:18: error: expected expression\n   65 |     v12 = ((char)[D] amd64g_calculate_condition(0x9<64>, 0x3<64>, rsi,\n0x7<64>, cc_ndep) ? (unsigned int)a1 + 7 : (unsigned int)(a1 + 14)) >> 3; | ^ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec85.c"}
{"compilable":0,"function":"int discovery() {\n    DIR *dir;\n    struct dirent *ent;\n    bool comma = 0;\n    if ((dir = opendir(\"/sys/kernel/debug/ieee80211/\")) != ((void *)0)) {\n        printf(\"{\\\"data\\\":[\");\n        while ((ent = readdir(dir)) != ((void *)0))\n            {\n                if (strcmp(\".\", ent->d_name) && strcmp(\"..\", ent->d_name)) {\n                    if (comma)\n                        printf(\",\");\n                    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", ent->d_name);\n                    comma = 1;\n                }\n            }\n        printf(\"]}\\n\");\n        closedir(dir);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(opendir)(char *);\nvoid(perror)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nint(putchar)(int);\n\nextern char g_40204d;\n\nlong long discovery_name_conflict() {\n  unsigned long long v1; // rax\n  char *v2;              // rbp\n  char v3;               // r14b\n  unsigned long long v4; // rax\n  char *v5;              // rbx\n\n  v1 = opendir(\"/sys/kernel/debug/ieee80211/\");\n  if (!v1) {\n    perror(&g_40204d);\n    return 1;\n  }\n  v2 = v1;\n  printf(\"{\\\"data\\\":[\");\n  v3 = 0;\n  while (true) {\n    do {\n      do {\n        v4 = readdir(v2);\n        if (!v4) {\n          puts(\"]}\");\n          closedir(v2);\n          return 0;\n        }\n      } while ((v5 = v4 + 19, !strcmp(\".\", v5)));\n    } while (!strcmp(\"..\", v5));\n    if (v3)\n      putchar(44);\n    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", (unsigned int)v5);\n    v3 = 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4ly38quk/discovery_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"int get_param(char *phy, char *stat) {\n    char *filename = ((void *)0);\n    FILE *f = ((void *)0);\n    phy = basename(phy);\n    stat = basename(stat);\n    if (asprintf(&filename, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\", phy, stat) > 0)\n        f = fopen(filename, \"r\");\n    if (f != ((void *)0)) {\n        char temp[256];\n        while (fgets(temp, 256, f) != ((void *)0))\n            printf(\"%s\", temp);\n        fclose(f);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    free(filename);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(basename)(char *);\nint(asprintf)(char **, char *, ...);\nvoid(perror)(char *);\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern char g_40204d;\n\nlong long get_param(char *a0, char *a1) {\n  char v0;    // [bp-0x128]\n  void *v1;   // [bp-0x20]\n  FILE_t *v3; // rbx\n\n  v1 = 0;\n  if (asprintf(&v1, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\",\n               (unsigned int)basename(a0), (unsigned int)basename(a1)) > 0) {\n    v3 = fopen(v1, \"r\");\n    if (v3) {\n      while (fgets(&v0, 0x100, v3)) {\n        printf(\"%s\", (unsigned int)&v0);\n      }\n      fclose(v3);\n      free(v1);\n      return 0;\n    }\n  }\n  perror(&g_40204d);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6ro_wp6c/get_param.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp6ro_wp6c/get_param.c:33:16: error: nested redefinition of '_IO_marker'\n   33 |         struct _IO_marker {\n      |                ^\n/tmp/tmp6ro_wp6c/get_param.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp6ro_wp6c/get_param.c:76:13: error: declaration of anonymous union must\nbe a definition 76 |             union <anon> { |             ^\n/tmp/tmp6ro_wp6c/get_param.c:79:22: error: type name requires a specifier or\nqualifier 79 |             } __value; |                      ^\n/tmp/tmp6ro_wp6c/get_param.c:83:13: error: declaration of anonymous union must\nbe a definition 83 |             union <anon> { |             ^\n/tmp/tmp6ro_wp6c/get_param.c:86:22: error: type name requires a specifier or\nqualifier 86 |             } __value; |                      ^\n/tmp/tmp6ro_wp6c/get_param.c:19:8: error: conflicting types for 'fgets'\n   19 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmp6ro_wp6c/get_param.c:144:16: error:\nredefinition of '_IO_marker' 144 | typedef struct _IO_marker { | ^\n/tmp/tmp6ro_wp6c/get_param.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmp6ro_wp6c/get_param.c:150:16: error: redefinition of '_IO_codecvt'\n  150 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmp6ro_wp6c/get_param.c:54:12: note: previous definition is here\n   54 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmp6ro_wp6c/get_param.c:154:16: error: redefinition of '_IO_wide_data'\n  154 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmp6ro_wp6c/get_param.c:62:12: note: previous definition is here\n   62 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmp6ro_wp6c/get_param.c:177:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 177 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"int usage(char *name) {\n    fprintf(stderr, \"Usage:\\n\");\n    fprintf(stderr, \" %s discovery\\n\", name);\n    fprintf(stderr, \" => print mac80211.phydiscovery discovery rule\\n\");\n    fprintf(stderr, \" %s PHY STAT\\n\", name);\n    fprintf(stderr, \" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\");\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long usage_name_conflict(unsigned long a0) {\n  fwrite(\"Usage:\\n\", 1, 7, stderr @GLIBC_2.2.5);\n  fprintf(stderr @GLIBC_2.2.5, \" %s discovery\\n\", (unsigned int)a0);\n  fwrite(\" => print mac80211.phydiscovery discovery rule\\n\", 1, 47,\n         stderr @GLIBC_2.2.5);\n  fprintf(stderr @GLIBC_2.2.5, \" %s PHY STAT\\n\", (unsigned int)a0);\n  fwrite(\" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\", 1,\n         64, stderr @GLIBC_2.2.5);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaf311epu/usage_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpaf311epu/usage_name_conflict.c:17:22: error: expected ';' after top level declarator\n   17 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpaf311epu/usage_name_conflict.c:21:36: error: expected ')'\n   21 |     fwrite(\"Usage:\\n\", 1, 7, stderr@GLIBC_2.2.5);\n      |                                    ^\n/tmp/tmpaf311epu/usage_name_conflict.c:21:11: note: to match this '('\n   21 |     fwrite(\"Usage:\\n\", 1, 7, stderr@GLIBC_2.2.5);\n      |           ^\n/tmp/tmpaf311epu/usage_name_conflict.c:22:19: error: expected ')'\n   22 |     fprintf(stderr@GLIBC_2.2.5, \" %s discovery\\n\", (unsigned int)a0);\n      |                   ^\n/tmp/tmpaf311epu/usage_name_conflict.c:22:12: note: to match this '('\n   22 |     fprintf(stderr@GLIBC_2.2.5, \" %s discovery\\n\", (unsigned int)a0);\n      |            ^\n/tmp/tmpaf311epu/usage_name_conflict.c:23:77: error: expected ')'\n   23 |     fwrite(\" => print mac80211.phydiscovery discovery rule\\n\", 1, 47,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmpaf311epu/usage_name_conflict.c:23:11: note: to match this '('\n   23 |     fwrite(\" => print mac80211.phydiscovery discovery rule\\n\", 1, 47,\nstderr@GLIBC_2.2.5); |           ^ /tmp/tmpaf311epu/usage_name_conflict.c:24:19: error:\nexpected ')' 24 |     fprintf(stderr@GLIBC_2.2.5, \" %s PHY STAT\\n\", (unsigned\nint)a0); |                   ^ /tmp/tmpaf311epu/usage_name_conflict.c:24:12: note: to match\nthis '(' 24 |     fprintf(stderr@GLIBC_2.2.5, \" %s PHY STAT\\n\", (unsigned\nint)a0); |            ^ /tmp/tmpaf311epu/usage_name_conflict.c:25:94: error: expected ')' 25 |\nfwrite(\" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\", 1,\n64, stderr@GLIBC_2.2.5); | ^ /tmp/tmpaf311epu/usage_name_conflict.c:25:11: note: to match this\n'(' 25 |     fwrite(\" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as\nroot\\n\", 1, 64, stderr@GLIBC_2.2.5); |           ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"static char *xasprintf(const char *fmt, ...) {\n    va_list ap;\n    char *ret;\n    __builtin_va_start(ap, fmt);\n    ret = xvasprintf(fmt, ap);\n    __builtin_va_end(ap);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vasprintf)(char **, char *, struct va_list[1]);\nlong long(oom_die)();\n\nlong long xasprintf_name_conflict(char *a0) {\n  char *v0;          // [bp-0xd8]\n  unsigned int v1;   // [bp-0xd0]\n  unsigned int v2;   // [bp-0xcc]\n  unsigned long v3;  // [bp-0xc8]\n  unsigned long v4;  // [bp-0xc0]\n  char v5;           // [bp-0xb8]\n  unsigned long v6;  // [bp-0xb0]\n  unsigned long v7;  // [bp-0xa8]\n  unsigned long v8;  // [bp-0xa0]\n  unsigned long v9;  // [bp-0x98]\n  unsigned long v10; // [bp-0x90]\n  int v11;           // [bp-0x88]\n  int v12;           // [bp-0x78]\n  int v13;           // [bp-0x68]\n  int v14;           // [bp-0x58]\n  int v15;           // [bp-0x48]\n  int v16;           // [bp-0x38]\n  int v17;           // [bp-0x28]\n  int v18;           // [bp-0x18]\n  unsigned long v19; // [bp+0x8]\n  unsigned long v20; // rsi\n  unsigned long v21; // rdx\n  unsigned long v22; // rcx\n  unsigned long v23; // r8\n  unsigned long v24; // r9\n  char v25;          // al\n  int v26;           // xmm0\n  int v27;           // xmm1\n  int v28;           // xmm2\n  int v29;           // xmm3\n  int v30;           // xmm4\n  int v31;           // xmm5\n  int v32;           // xmm6\n  int v33;           // xmm7\n\n  v6 = v20;\n  v7 = v21;\n  v8 = v22;\n  v9 = v23;\n  v10 = v24;\n  if (v25) {\n    v11 = v26;\n    v12 = v27;\n    v13 = v28;\n    v14 = v29;\n    v15 = v30;\n    v16 = v31;\n    v17 = v32;\n    v18 = v33;\n  }\n  v1 = 8;\n  v2 = 48;\n  v3 = &v19;\n  v4 = &v5;\n  if (vasprintf(&v0, a0, &v1) >= 0) {\n    return v0;\n  } else if (*(__errno_location()) == 12) {\n    oom_die(); /* do not return */\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkah5xd8r/xasprintf_name_conflict.c:16:48: error: array has incomplete element type\n'struct va_list' 16 | int (vasprintf)(char **, char *, struct va_list[1]); | ^\n/tmp/tmpkah5xd8r/xasprintf_name_conflict.c:16:41: note: forward declaration of 'struct\nva_list' 16 | int (vasprintf)(char **, char *, struct va_list[1]); | ^\n/tmp/tmpkah5xd8r/xasprintf_name_conflict.c:80:14: error: indirection requires pointer operand\n('int' invalid) 80 |     else if (*(__errno_location()) == 12) |\n^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static char *fieldcpy(char *dst, char *fld) {\n    while (*fld && *fld != ':')\n        fld++;\n    if (!*(fld++))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*fld))] & (unsigned short)_ISspace))\n        fld++;\n    return strcpy(dst, fld);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fieldcpy_name_conflict(char *a0, char *a1) {\n  char v1;          // al\n  char *v3;         // rbx, Other Possible Types: unsigned long\n  unsigned long v4; // rax\n\n  v1 = *(a1);\n  if (v1 && v1 != 58) {\n    do {\n      a1 += 1;\n      v1 = *((char *)a1);\n    } while (v1 && v1 != 58);\n  }\n  if (!v1)\n    return 0;\n  for (v3 = a1 + 1; (*((char *)(*((long long *)&__ctype_b_loc()) +\n                                (*((char *)v3) << 1) + 1)) &\n                     32);\n       v3 += 1)\n    ;\n  v4 = strcpy(a0, v3);\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprpdqnl5e/fieldcpy_name_conflict.c:34:50: error: cannot take the address of an rvalue\nof type 'int' 34 |     for (v3 = a1 + 1; (*((char *)(*((long long\n*)&__ctype_b_loc()) + (*((char *)v3) << 1) + 1)) & 32); v3 += 1); |\n^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static int dotranslatewgetpercent(int low, int high, int end, char *str) {\n    int ch;\n    int val, lastval;\n    lastval = val = 0;\n    while ((ch = getchar()) != (-1))\n        {\n            if (((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit)) {\n                val *= 10;\n                val += ch - '0';\n            } else if (ch == '%') {\n                float f = (float)val / 100. * (high - low) + low;\n                if (str) {\n                    printf(\"P: %d %d %s\\n\", (int)f, end, str);\n                } else {\n                    printf(\"P: %d %d\\n\", (int)f, end);\n                }\n                lastval = val;\n            } else {\n                val = 0;\n            }\n        }\n    return lastval == 100;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":1,"function":"static int luaO_int2fb(unsigned int x) {\n    int e = 0;\n    while (x >= 16)\n        {\n            x = (x + 1) >> 1;\n            e++;\n        }\n    if (x < 8)\n        return x;\n    else\n        return ((e + 1) << 3) | (((int)((x))) - 8);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long luaO_int2fb_name_conflict(unsigned long a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 <= 15) {\n    v1 = 0;\n  } else {\n    do {\n      v2 = a0 + 1;\n      a0 = v2 / 2;\n      v1 = 1;\n    } while ((unsigned int)v2 > 31);\n  }\n  if ((unsigned int)a0 > 7)\n    return (unsigned int)(v1 * 8 + 8) | (unsigned int)a0 - 8;\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int luaO_fb2int(int x) {\n    int e = (x >> 3) & 31;\n    if (e == 0)\n        return x;\n    else\n        return ((x & 7) + 8) << (e - 1);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int luaO_log2(unsigned int x) {\n    static const lu_byte log_2[256] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};\n    int l = -1;\n    while (x >= 256)\n        {\n            l += 8;\n            x >>= 8;\n        }\n    return l + log_2[x];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int computesizes(int nums[], int *narray) {\n    int i;\n    int twotoi;\n    int a = 0;\n    int na = 0;\n    int n = 0;\n    for (i = 0 , twotoi = 1; twotoi / 2 < *narray; i++ , twotoi *= 2) {\n        if (nums[i] > 0) {\n            a += nums[i];\n            if (a > twotoi / 2) {\n                n = twotoi;\n                na = a;\n            }\n        }\n        if (a == *narray)\n            break;\n    }\n    *narray = n;\n    return na;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static UnOpr getunopr(int op) {\n    switch (op) {\n      case TK_NOT:\n        return OPR_NOT;\n      case '-':\n        return OPR_MINUS;\n      case '#':\n        return OPR_LEN;\n      default:\n        return OPR_NOUNOPR;\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static BinOpr getbinopr(int op) {\n    switch (op) {\n      case '+':\n        return OPR_ADD;\n      case '-':\n        return OPR_SUB;\n      case '*':\n        return OPR_MUL;\n      case '/':\n        return OPR_DIV;\n      case '%':\n        return OPR_MOD;\n      case '^':\n        return OPR_POW;\n      case TK_CONCAT:\n        return OPR_CONCAT;\n      case TK_NE:\n        return OPR_NE;\n      case TK_EQ:\n        return OPR_EQ;\n      case '<':\n        return OPR_LT;\n      case TK_LE:\n        return OPR_LE;\n      case '>':\n        return OPR_GT;\n      case TK_GE:\n        return OPR_GE;\n      case TK_AND:\n        return OPR_AND;\n      case TK_OR:\n        return OPR_OR;\n      default:\n        return OPR_NOBINOPR;\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int block_follow(int token) {\n    switch (token) {\n      case TK_ELSE:\n      case TK_ELSEIF:\n      case TK_END:\n      case TK_UNTIL:\n      case TK_EOS:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static ptrdiff_t posrelat(ptrdiff_t pos, size_t len) {\n    if (pos < 0)\n        pos += (ptrdiff_t)len + 1;\n    return (pos >= 0) ? pos : 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int match_class(int c, int cl) {\n    int res;\n    switch (tolower(cl)) {\n      case 'a':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha);\n        break;\n      case 'c':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_IScntrl);\n        break;\n      case 'd':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit);\n        break;\n      case 'l':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower);\n        break;\n      case 'p':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISpunct);\n        break;\n      case 's':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISspace);\n        break;\n      case 'u':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper);\n        break;\n      case 'w':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum);\n        break;\n      case 'x':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISxdigit);\n        break;\n      case 'z':\n        res = (c == 0);\n        break;\n      default:\n        return (cl == c);\n    }\n    return (((*__ctype_b_loc())[(int)((cl))] & (unsigned short)_ISlower) ? res : !res);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_tolower_loc)();\n\nlong long match_class_name_conflict(unsigned short *a0, unsigned int *a1) {\n  unsigned long long v2; // rax\n  unsigned long v3;      // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)(a1 + 32) > 383)\n    return (unsigned int)a1 == (unsigned int)a0;\n  v2 = *((int *)(*((long long *)&__ctype_tolower_loc()) + a1 * 4)) - 97;\n  switch ((unsigned int)v2) {\n  case 0:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 0x400;\n    break;\n  case 2:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 2;\n    break;\n  case 3:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 0x800;\n    break;\n  case 11:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 0x200;\n    break;\n  case 15:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 4;\n    break;\n  case 18:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 0x2000;\n    break;\n  case 20:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 0x100;\n    break;\n  case 22:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 8;\n    break;\n  case 23:\n    v3 = *((short *)(*((long long *)&__ctype_b_loc()) + a0 * 2)) & 0x1000;\n    break;\n  case 25:\n    v3 = !(unsigned int)a0;\n    break;\n  default:\n    return (unsigned int)a1 == (unsigned int)a0;\n  }\n  if (!(*((char *)(*((long long *)&__ctype_b_loc()) + (a1 << 1) + 1)) & 2)) {\n    v3 = !(unsigned int)v3;\n    return v3;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:25:35: error: cannot take the address of an\nrvalue of type 'char *' 25 |     v2 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + a1 * 4)) - 97; | ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:25:64: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 25 |     v2 = *((int *)(*((long long\n*)&__ctype_tolower_loc()) + a1 * 4)) - 97; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:29:41: error: cannot take the address of an\nrvalue of type 'int' 29 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 0x400; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:29:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 29 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 0x400; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:32:41: error: cannot take the address of an\nrvalue of type 'int' 32 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 2; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:32:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 32 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 2; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:35:41: error: cannot take the address of an\nrvalue of type 'int' 35 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 0x800; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:35:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 35 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 0x800; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:38:41: error: cannot take the address of an\nrvalue of type 'int' 38 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 0x200; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:38:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 38 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 0x200; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:41:41: error: cannot take the address of an\nrvalue of type 'int' 41 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 4; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:41:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 41 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 4; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:44:41: error: cannot take the address of an\nrvalue of type 'int' 44 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 0x2000; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:44:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 44 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 0x2000; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:47:41: error: cannot take the address of an\nrvalue of type 'int' 47 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 0x100; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:47:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 47 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 0x100; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:50:41: error: cannot take the address of an\nrvalue of type 'int' 50 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 8; | ^~~~~~~~~~~~~~~~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:50:64: error: invalid operands to binary\nexpression ('unsigned short *' and 'int') 50 |         v3 = *((short *)(*((long\nlong *)&__ctype_b_loc()) + a0 * 2)) & 8; | ~~ ^ ~\n/tmp/tmphmjmmp2h/match_class_name_conflict.c:53:41: error: cannot take the address of an\nrvalue of type 'int' 53 |         v3 = *((short *)(*((long long\n*)&__ctype_b_loc()) + a0 * 2)) & 0x1000; | ^~~~~~~~~~~~~~~~ fatal error: too\nmany errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int matchbracketclass(int c, const char *p, const char *ec) {\n    int sig = 1;\n    if (*(p + 1) == '^') {\n        sig = 0;\n        p++;\n    }\n    while (++p < ec)\n        {\n            if (*p == '%') {\n                p++;\n                if (match_class(c, ((unsigned char)(*p))))\n                    return sig;\n            } else if ((*(p + 1) == '-') && (p + 2 < ec)) {\n                p += 2;\n                if (((unsigned char)(*(p - 2))) <= c && c <= ((unsigned char)(*p)))\n                    return sig;\n            } else if (((unsigned char)(*p)) == c)\n                return sig;\n        }\n    return !sig;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(match_class)(long long, long long);\n\nlong long matchbracketclass(unsigned long long a0, char a1[4],\n                            unsigned long a2) {\n  unsigned long long v1; // rbx\n  unsigned long v2;      // r12, Other Possible Types: unsigned long long\n  unsigned long long v3; // rax\n  char v6[4];            // rcx\n  char v7[4];            // rdx, Other Possible Types: unsigned long\n\n  v1 = a2;\n  v2 = 1;\n  if (a1[1] == 94) {\n    a1 = &a1[1];\n    v2 = 0;\n  }\n  v7 = a1 + 1;\n  if (v7 < v1) {\n    do {\n      v3 = *((char *)(a1 + 1));\n      if ((char)v3 == 37) {\n        if ((int)match_class(a0, *((char *)(a1 + 2))))\n          return v2;\n        a1 += 2;\n      } else if (*((char *)(a1 + 2)) != 45 || (v6 = a1 + 3, v6 >= v1)) {\n        if ((unsigned int)v3 != (unsigned int)a0)\n          a1 = v7;\n        else\n          return v2;\n      } else {\n        if ((unsigned int)v3 > (unsigned int)a0) {\n          a1 = v6;\n        } else if (*((char *)(a1 + 3)) < (unsigned int)a0) {\n          a1 = v6;\n        } else {\n          return v2;\n        }\n      }\n    } while ((v7 = a1 + 1, v7 < v1));\n  }\n  v2 = (unsigned int)v2 ^ 1;\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1c89t8su/matchbracketclass.c:33:8: error: array type 'char[4]' is not\nassignable 33 |     v7 = a1 + 1; |     ~~ ^\n/tmp/tmp1c89t8su/matchbracketclass.c:45:55: error: array type 'char[4]' is not\nassignable 45 |             else if (*((char *)(a1 + 2)) != 45 || (v6 = a1 + 3,\nv6 >= v1)) |                                                    ~~ ^\n/tmp/tmp1c89t8su/matchbracketclass.c:67:22: error: array type 'char[4]' is not\nassignable 67 |         } while ((v7 = a1 + 1, v7 < v1)); |                   ~~\n^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int singlematch(int c, const char *p, const char *ep) {\n    switch (*p) {\n      case '.':\n        return 1;\n      case '%':\n        return match_class(c, ((unsigned char)(*(p + 1))));\n      case '[':\n        return matchbracketclass(c, p, ep - 1);\n      default:\n        return (((unsigned char)(*p)) == c);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(matchbracketclass)(long long, long long, long long);\nlong long(match_class)(long long, long long);\n\nlong long singlematch_name_conflict(unsigned long long a0, char a1[2], unsigned long a2) {\n  unsigned long long v1; // rcx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = a1[0];\n  if ((char)v1 == 46) {\n    return 1;\n  } else if ((char)v1 == 91) {\n    v2 = matchbracketclass(a0, a1, a2 - 1);\n    return v2;\n  } else if ((char)v1 != 37) {\n    return (unsigned int)v1 == (unsigned int)a0;\n  } else {\n    v2 = match_class(a0, a1[1]);\n    return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static const char *lmemfind(const char *s1, size_t l1, const char *s2, size_t l2) {\n    if (l2 == 0)\n        return s1;\n    else if (l2 > l1)\n        return ((void *)0);\n    else {\n        const char *init;\n        l2--;\n        l1 = l1 - l2;\n        while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != ((void *)0))\n            {\n                init++;\n                if (memcmp(init, s2 + 1, l2) == 0)\n                    return init - 1;\n                else {\n                    l1 -= init - s1;\n                    s1 = init;\n                }\n            }\n        return ((void *)0);\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static inline char base64_encode_value(char value_in) {\n    static const char *encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    return value_in > 63 ? '=' : encoding[(int)value_in];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"size_t base64_encode_block(const char *plaintext_in, size_t length_in, char *code_out, base64_encodestate *state_in) {\n    const char *plainchar = plaintext_in;\n    const char *const plaintextend = plaintext_in + length_in;\n    char *codechar = code_out;\n    char result;\n    char fragment;\n    result = state_in->result;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_A:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_A;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)((fragment & 252) >> 2);\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 3) << 4);\n              case step_B:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_B;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 240) >> 4));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 15) << 2);\n              case step_C:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_C;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 192) >> 6));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 63) >> 0);\n                *codechar++ = base64_encode_value(result);\n                ++(state_in->stepcount);\n            }\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n  char padding_5[3];\n  unsigned int field_8;\n} struct_0;\n\nlong long base64_encode_block(char a0[2], unsigned long a1, char a2[2],\n                              struct_0 *a3) {\n  char v1[2];             // r8\n  struct_0 *v2;           // rdx\n  unsigned long long v3;  // rsi\n  unsigned int v4;        // eax\n  char v5[2];             // rax\n  unsigned long long v6;  // rdi\n  unsigned long v7;       // rcx, Other Possible Types: unsigned long long\n  char v8[2];             // rax, Other Possible Types: unsigned long\n  char v9[2];             // rax, Other Possible Types: unsigned long\n  char v10;               // cl\n  unsigned long v11;      // cl, Other Possible Types: char\n  char v12[2];            // r10, Other Possible Types: unsigned long\n  unsigned long v13;      // r9\n  unsigned long long v14; // rcx\n  char v15[2];            // r11, Other Possible Types: unsigned long\n  unsigned long long v16; // r9\n  unsigned long long v17; // rax\n  unsigned long long v18; // rcx\n  char v19;               // r10b\n  unsigned long long v20; // r9, Other Possible Types: unsigned long\n  unsigned long long v21; // r10\n  unsigned long long v22; // rdi\n  unsigned long v23;      // r11\n\n  v1 = a2;\n  v2 = a3;\n  v3 = &a0[a1];\n  v11 = a3->field_4;\n  v4 = v2->field_0;\n  if (v4 == 1) {\n    v15 = v1;\n  } else if (v4 != 2) {\n    if (!v4) {\n      v12 = v1;\n      goto LABEL_401339;\n    } else {\n      return 0;\n    }\n  } else {\n    if (a0 != v3) {\n      v5 = &a0[1];\n      v20 = a0[0];\n      v6 = v20;\n      *((char *)&v6) = (char)v6 >> 6;\n      v7 = (unsigned int)v11 | (unsigned int)v6;\n      if ((char)v7 <= 63) {\n        a0 = v5;\n        v9 = v1;\n        goto LABEL_401305;\n      } else {\n        a0 = v5;\n        v9 = v1;\n        v10 = 61;\n        goto LABEL_401315;\n      }\n    } else {\n      v8 = v1;\n    LABEL_4013af:\n      v2->field_4 = v11;\n      v2->field_0 = 2;\n      return v8 - (char *)v1;\n    }\n  }\n  while (true) {\n    if (a0 == v3) {\n      v2->field_4 = v11;\n      v2->field_0 = 1;\n      v23 = v15 - (char *)v1;\n      return v23;\n    }\n    v16 = *((char *)a0);\n    v17 = v16;\n    *((char *)&v17) = (char)v17 >> 4;\n    v18 = (unsigned int)v11 | (unsigned int)v17;\n    v8 = v15 + 1;\n    v19 = 61;\n    if ((char)v18 <= 63)\n      v19 = *((char *)(4202504 + (char)v18));\n    *((char *)v15) = v19;\n    v11 = (unsigned int)v16 * 4 & 60;\n    if (v3 == a0 + 1)\n      break;\n    v20 = *((char *)(a0 + 1));\n    v21 = v20;\n    *((char *)&v21) = (char)v21 >> 6;\n    v7 = (unsigned int)v11 | (unsigned int)v21;\n    v22 = a0 + 2;\n  LABEL_401305:\n    v10 = *((char *)(4202504 + (char)v7));\n  LABEL_401315:\n    *((char *)v9) = v10;\n    v11 = (unsigned int)v20 & 63;\n    v12 = v9 + 2;\n    v13 = (unsigned int)v20 & 63;\n    *((char *)(v9 + 1)) = *((char *)(4202504 + v13));\n    v2->field_8 = v2->field_8 + 1;\n  LABEL_401339:\n    if (a0 == v3) {\n      v2->field_4 = v11;\n      v2->field_0 = 0;\n      return v12 - (char *)v1;\n    }\n    v14 = *((char *)a0);\n    v15 = v12 + 1;\n    *((char *)v12) = *((char *)(4202504 + (v14 >> 2)));\n    v11 = (unsigned int)v14 * 16 & 48;\n    a0 += 1;\n  }\n  goto LABEL_4013af;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6b5sahwz/base64_encode_block.c:50:8: error: array type 'char[2]' is not\nassignable 50 |     v1 = a2; |     ~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:57:13: error: array type 'char[2]' is not\nassignable 57 |         v15 = v1; |         ~~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:63:17: error: array type 'char[2]' is not\nassignable 63 |             v12 = v1; |             ~~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:75:16: error: array type 'char[2]' is not\nassignable 75 |             v5 = &a0[1]; |             ~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:83:20: error: array type 'char[2]' is not\nassignable 83 |                 v9 = v1; |                 ~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:89:20: error: array type 'char[2]' is not\nassignable 89 |                 v9 = v1; |                 ~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:96:16: error: array type 'char[2]' is not\nassignable 96 |             v8 = v1; |             ~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:116:12: error: array type 'char[2]' is\nnot assignable 116 |         v8 = v15 + 1; |         ~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:134:13: error: array type 'char[2]' is\nnot assignable 134 |         v12 = v9 + 2; |         ~~~ ^\n/tmp/tmp6b5sahwz/base64_encode_block.c:146:13: error: array type 'char[2]' is\nnot assignable 146 |         v15 = v12 + 1; |         ~~~ ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":1,"function":"size_t base64_encode_blockend(char *code_out, base64_encodestate *state_in) {\n    char *codechar = code_out;\n    switch (state_in->step) {\n      case step_B:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        *codechar++ = '=';\n        break;\n      case step_C:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        break;\n      case step_A:\n        break;\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n} struct_0;\n\nlong long base64_encode_blockend_name_conflict(char a0[3], struct_0 *a1) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n  char v3;               // dl\n  unsigned long long v4; // rax\n  char v5;               // dl\n\n  v1 = a1->field_0;\n  if (v1 == 1) {\n    v2 = a1->field_4;\n    v3 = 61;\n    if ((char)v2 <= 63)\n      v3 = *((char *)(4202504 + (char)v2));\n    a0[0] = v3;\n    a0[1] = 61;\n    a0[2] = 61;\n    return a0 + 1 - a0;\n  } else if (v1 == 2) {\n    v4 = a1->field_4;\n    v5 = 61;\n    if ((char)v4 <= 63)\n      v5 = *((char *)(4202504 + (char)v4));\n    a0[0] = v5;\n    a0[1] = 61;\n    return &a0[2] - a0;\n  } else {\n    return a0 - a0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"static inline char base64_decode_value(char value_in) {\n    static const char decoding[] = {62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};\n    static const char decoding_size = (char)sizeof (decoding);\n    value_in -= 43;\n    return (value_in < 0 || value_in >= decoding_size) ? -1 : decoding[(int)value_in];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"size_t base64_decode_block(const char *code_in, size_t length_in, char *plaintext_out, base64_decodestate *state_in) {\n    const char *codechar = code_in;\n    char *plainchar = plaintext_out;\n    char fragment;\n    *plainchar = state_in->plainchar;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_a:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_a;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)((fragment & 63) << 2);\n              case step_b:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_b;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 48) >> 4));\n                ++plainchar;\n                *plainchar = (char)((fragment & 15) << 4);\n              case step_c:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_c;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 60) >> 2));\n                ++plainchar;\n                *plainchar = (char)((fragment & 3) << 6);\n              case step_d:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_d;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | (fragment & 63));\n                ++plainchar;\n            }\n    }\n    return (size_t)(plainchar - plaintext_out);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char field_4;\n} struct_0;\n\ntypedef struct struct_1 {\n  char field_ - 1;\n} struct_1;\n\nextern char decoding.0;\n\nlong long base64_decode_block(struct_1 *a0, unsigned long a1, char a2[2],\n                              struct_0 *a3) {\n  char v1[2];            // r8\n  struct_0 *v2;          // r9\n  unsigned long long v3; // rcx\n  struct_1 *v4;          // rdx, Other Possible Types: unsigned long\n  unsigned long long v5; // rcx\n  char v6;               // cl\n  char v7[2];            // rax, Other Possible Types: unsigned long\n  unsigned long v9;      // rcx\n  char v10[2];           // r10, Other Possible Types: unsigned long\n  unsigned long v12;     // rax\n  unsigned long v13;     // rcx\n  char v14[2];           // rax, Other Possible Types: unsigned long\n  unsigned long v16;     // rcx\n  char v17[2];           // rax\n\n  v1 = a2;\n  v2 = a3;\n  a2[0] = a3->field_4;\n  v3 = a3->field_0;\n  if ((unsigned int)v3 == 2) {\n    v10 = a2;\n    v4 = a0;\n    while (true) {\n    LABEL_4012fb:\n      do {\n        do {\n          if (v4 == &a0[a1]) {\n            v2->field_0 = 0;\n            v2->field_4 = *((char *)v7);\n            return v7 - (char *)v1;\n          }\n        } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      *((char *)v7) = v6 * 4;\n    LABEL_401257:\n      do {\n        do {\n          if (v4 == &a0[a1]) {\n            v2->field_0 = 1;\n            v2->field_4 = *((char *)v7);\n            return v7 - (char *)v1;\n          }\n        } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      *((char *)v7) = *((char *)v7) | (char)((unsigned int)(v9 >> 4) & 3);\n      v10 = v7 + 1;\n      *((char *)(v7 + 1)) = (char)v9 * 16;\n      do {\n        do {\n          if (v4 == &a0[a1]) {\n            v2->field_0 = 2;\n            v2->field_4 = *((char *)v10);\n            return v10 - (char *)v1;\n          }\n        } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      v13 = (char)v12;\n      *((char *)v10) = *((char *)v10) | (char)((unsigned int)(v13 >> 2) & 15);\n      v14 = v10 + 1;\n      *((char *)(v10 + 1)) = (char)v13 * 64;\n    LABEL_4012b3:\n      do {\n        do {\n          if (v4 == &a0[a1]) {\n            v2->field_0 = 3;\n            v2->field_4 = *((char *)v14);\n            return v14 - (char *)v1;\n          }\n        } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      *((char *)v14) = *((char *)v14) | (char)((unsigned int)v16 & 63);\n      v17 = v14 + 1;\n    }\n  } else {\n    if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rcx,\n                                             0x2 < 64 >, cc_ndep)) {\n      if (!(unsigned int)v3) {\n        v7 = a2;\n        v4 = a0;\n        goto LABEL_4012fb;\n      } else {\n        v7 = a2;\n        v4 = a0;\n        goto LABEL_401257;\n      }\n    }\n    v14 = a2;\n    v4 = a0;\n    if ((unsigned int)v3 == 3)\n      goto LABEL_4012b3;\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_ao1kzl6/base64_decode_block.c:23:16: error: expected ';' at end of\ndeclaration list 23 |     char field_-1; |                ^ |                ;\n/tmp/tmp_ao1kzl6/base64_decode_block.c:26:21: error: expected ';' after top\nlevel declarator 26 | extern char decoding.0; |                     ^ | ;\n/tmp/tmp_ao1kzl6/base64_decode_block.c:45:8: error: array type 'char[2]' is not\nassignable 45 |     v1 = a2; |     ~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:51:13: error: array type 'char[2]' is not\nassignable 51 |         v10 = a2; |         ~~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:66:42: error: expected ')'\n   66 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                          ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:66:32: note: to match this '('\n   66 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:67:38: error: expected ')'\n   67 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                      ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:67:28: note: to match this '('\n   67 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                            ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:80:42: error: expected ')'\n   80 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                          ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:80:32: note: to match this '('\n   80 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:81:38: error: expected ')'\n   81 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                      ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:81:28: note: to match this '('\n   81 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                            ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:83:17: error: array type 'char[2]' is not\nassignable 83 |             v10 = v7 + 1; |             ~~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:95:42: error: expected ')'\n   95 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                          ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:95:32: note: to match this '('\n   95 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:96:38: error: expected ')'\n   96 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                      ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:96:28: note: to match this '('\n   96 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                            ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:99:17: error: array type 'char[2]' is not\nassignable 99 |             v14 = v10 + 1; |             ~~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:112:42: error: expected ')'\n  112 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                          ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:112:32: note: to match this '('\n  112 |                 } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:113:38: error: expected ')'\n  113 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                                      ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:113:28: note: to match this '('\n  113 |             } while ((v6 = (&decoding.0)[(char)(char)v5], v6 < 0));\n      |                            ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:115:17: error: array type 'char[2]' is\nnot assignable 115 |             v17 = v14 + 1; |             ~~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:120:19: error: expected expression\n  120 |         if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rcx,\n0x2<64>, cc_ndep)) |                   ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:124:20: error: array type 'char[2]' is\nnot assignable 124 |                 v7 = a2; |                 ~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:130:20: error: array type 'char[2]' is\nnot assignable 130 |                 v7 = a2; |                 ~~ ^\n/tmp/tmp_ao1kzl6/base64_decode_block.c:135:13: error: array type 'char[2]' is\nnot assignable 135 |         v14 = a2; |         ~~~ ^ 19 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"static int argindex(int n) {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v1; // r13d\n  unsigned int v3; // r12d\n  struct struct_1 *\n      *v4;  // rbp, Other Possible Types: unsigned long, unsigned long long\n  char *v5; // rbx, Other Possible Types: unsigned long\n\n  if (!argv)\n    return 4294967295;\n  v1 = a0;\n  if (!argv->field_0)\n    return 4294967295;\n  v5 = argv->field_8;\n  if (!v5)\n    return 4294967295;\n  v4 = 1;\n  v3 = 0;\n  while (true) {\n    if (v3 || (*((char *)v5) - 43 & 253) && !strchr(v5, 61)) {\n      if (v1)\n        v1 -= 1;\n      else\n        return v4;\n    }\n    if (!strcmp(v5, \"--\"))\n      v3 = 1;\n    v4 += 1;\n    v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n    if (!v5)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxsqnvzco/argindex_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpxsqnvzco/argindex_name_conflict.c:21:8: error: declaration of anonymous struct must be\na definition /tmp/tmpxsqnvzco/argindex_name_conflict.c:33:16: error: member reference type\n'int' is not a pointer 33 |     if (!argv->field_0) |          ~~~~  ^\n/tmp/tmpxsqnvzco/argindex_name_conflict.c:35:16: error: member reference type 'int' is not a\npointer 35 |     v5 = argv->field_8; |          ~~~~  ^\n/tmp/tmpxsqnvzco/argindex_name_conflict.c:52:45: error: member reference type 'int' is not a\npointer 52 |         v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n      |                                       ~~~~  ^\n/tmp/tmpxsqnvzco/argindex_name_conflict.c:52:59: error: invalid operands to binary expression\n('int' and 'struct struct_1 **') 52 |         v5 = *((long long *)((char\n*)&argv->field_0 + 0x8 * v4)); | ~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_1 *field_ - 8;\n} struct_0;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\nextern struct_2 *argv;\n\nlong long OptNArgs_name_conflict() {\n  void *v1;     // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v2;     // rbp, Other Possible Types: unsigned long\n  struct_0 *v3; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned int v4; // r12d\n\n  v1 = 0;\n  if (!argv) {\n    return 0;\n  } else if (!argv->field_0) {\n    return 0;\n  } else {\n    v2 = argv->field_8;\n    if (!v2)\n      return 0;\n    v3 = argv + 1;\n    v4 = 0;\n    do {\n      if (v4 || (*((char *)v2) - 43 & 253) && !strchr(v2, 61))\n        v1 = (unsigned int)v1 + 1;\n      if (!strcmp(v2, \"--\"))\n        v4 = 1;\n      v3 += 8;\n      v2 = v3[1].field_ - 8;\n    } while (v2);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj8n6zifi/OptNArgs_name_conflict.c:18:28: error: expected ';' at end of declaration\nlist 18 |     struct struct_1 *field_-8; |                            ^ | ;\n/tmp/tmpj8n6zifi/OptNArgs_name_conflict.c:25:8: error: unknown type name 'struct_2'\n   25 | extern struct_2 *argv;\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *OptArg(int n) {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long long a0) {\n  unsigned long long *v1; // rax\n\n  v1 = argindex(a0);\n  if ((unsigned int)v1 >= 0)\n    return *((long long *)(argv + v1 * 8));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_puwg83k/OptArg_name_conflict.c:26:42: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 26 |         return *((long long *)(argv + v1\n* 8)); |                                       ~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *pathsearch(char *argv0, char *name, int modemask) {\n    const char *pathlist;\n    char *pathbufptr;\n    char *pathbuf;\n    char *path, *cp;\n    char c;\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(((int)strlen(argv0)) + ((int)strlen(name)) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        pathbuf = (char *)malloc(((int)strlen(pathlist)) + 1);\n        path = (char *)malloc(((int)strlen(pathlist)) + ((int)strlen(name)) + 2);\n        if ((pathbuf != 0) && (path != 0)) {\n            pathbufptr = pathbuf;\n            strcpy(pathbuf, pathlist);\n            while (*pathbuf)\n                {\n                    cp = strchr(pathbuf, ':');\n                    if (cp == 0)\n                        cp = &pathbuf[((int)strlen(pathbuf))];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathbuf, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathbuf[0] = 0;\n                    else\n                        pathbuf = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n            free(pathbufptr);\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char *v0;  // [bp-0x40]\n  char *v2;  // rax\n  char v4;   // r13b\n  char *v6;  // rbx, Other Possible Types: unsigned long\n  char *v7;  // rax\n  char *v8;  // r15\n  char *v9;  // r12, Other Possible Types: unsigned long\n  char *v10; // rbp, Other Possible Types: unsigned long, unsigned long long\n  char *v11; // rbx, Other Possible Types: unsigned long\n  char v12;  // r13b\n\n  v2 = strrchr(a0, 47);\n  if (v2) {\n    v4 = *(v2);\n    *(v2) = 0;\n    v9 = malloc(strlen(a0) + strlen(a1) + 2);\n    if (v9)\n      sprintf(v9, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v2) = v4;\n    return v9;\n  } else {\n    v6 = getenv(\"PATH\");\n    if (!v6)\n      v6 = \".:/bin:/usr/bin\";\n    v7 = malloc(strlen(v6) + 1);\n    v8 = v7;\n    v0 = v7;\n    v9 = malloc(strlen(v6) + strlen(a1) + 2);\n    if (!v8) {\n      return v9;\n    } else if (!v9) {\n      return v9;\n    } else {\n      v10 = v8;\n      strcpy(v8, v6);\n      while (*((char *)v10)) {\n        v11 = strchr(v10, 58);\n        if (!v11)\n          v11 = strlen(v10) + v10;\n        v12 = *((char *)v11);\n        *((char *)v11) = 0;\n        sprintf(v9, \"%s/%s\", (unsigned int)v10, (unsigned int)a1);\n        *((char *)v11) = v12;\n        if (v12)\n          v10 = v11 + 1;\n        else\n          *((char *)v10) = 0;\n        if (!access(v9, a2))\n          break;\n      }\n      free(v0);\n      return v9;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 < 0) {\n    if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n      return \"signed char\";\n    if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n      return \"int\";\n    return \"short\";\n  } else if ((unsigned int)a1 <= 255) {\n    return \"unsigned char\";\n  } else {\n    return ((unsigned int)a1 <= 65534 ? \"unsigned int\" : \"unsigned short int\");\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    s = (char *)calloc(size, 1);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  unsigned long long v1; // rax\n\n  v1 = calloc(size, 1);\n  if (!v1)\n    memory_error(); /* do not return */\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int SetUnion(char *s1, char *s2) {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rax, Other Possible Types: unsigned long\n  void *v2; // rcx, Other Possible Types: unsigned long, unsigned long long\n\n  if (size <= 0)\n    return 0;\n  v1 = 0;\n  v2 = 0;\n  do {\n    if (*((char *)(a1 + v1)) && !*((char *)(a0 + v1))) {\n      *((char *)(a0 + v1)) = 1;\n      v2 = 1;\n    }\n  } while ((v1 += 1, (unsigned long long)size != v1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int strhash(const char *x) {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  void *v2;              // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = 0;\n  do {\n    v3 = v2 + v2 * 12;\n    a0 += 1;\n    v2 = v3 + v1;\n    v1 = *((char *)a0);\n  } while ((char)v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa82fvl5f/strhash_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v3 = v2 + v2 * 12; |                   ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe(const char *y) {\n    const char *z;\n    char *cpy;\n    if (y == 0)\n        return 0;\n    z = Strsafe_find(y);\n    if (z == 0 && (cpy = (char *)malloc(((int)strlen(y)) + 1)) != 0) {\n        strcpy(cpy, y);\n        z = cpy;\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  unsigned long v1; // rbx\n\n  if (!a0)\n    return a0;\n  v1 = Strsafe_name_conflict_find(a0);\n  if (v1)\n    return v1;\n  v1 = malloc(strlen(a0) + 1);\n  if (v1) {\n    strcpy(v1, a0);\n    Strsafe_name_conflict_insert(v1);\n    return v1;\n  }\n  memory_error(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(const char *data) {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_1 {\n  char *field_0;\n  struct struct_1 *field_8;\n} struct_1;\n\ntypedef struct struct_2 {\n  char padding_0[16];\n  unsigned long long field_10;\n} struct_2;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned long long *v0;    // [bp-0x58]\n  unsigned long v1;          // [bp-0x50]\n  unsigned int v2;           // [bp-0x48]\n  unsigned int v3;           // [bp-0x44]\n  unsigned long v4;          // [bp-0x40]\n  unsigned long v6;          // rax\n  unsigned int v7;           // r14d\n  struct_1 *v8;              // r12, Other Possible Types: unsigned long\n  unsigned long v9;          // r14\n  unsigned long long *v10;   // rax, Other Possible Types: unsigned long\n  unsigned long long v11;    // rdx\n  unsigned long long v12;    // rcx\n  unsigned long long v13[2]; // r12, Other Possible Types: unsigned long\n  struct struct_2 **v15;     // rax\n  struct_2 *v16;             // rdx\n  struct struct_2 **v17;     // rax\n  unsigned long long v18;    // rdx\n  unsigned long long v19[3]; // rdx\n  struct_2 *v20;             // rsi\n\n  if (!x1a)\n    return 0;\n  v2 = strhash(a0);\n  v7 = x1a->field_0;\n  v8 = *((long long *)(x1a->field_10 + (v7 - 1 & v2) * 8));\n  if (v8) {\n    do {\n      (unsigned int)v6 = strcmp(*((long long *)v8), a0);\n      if (!(unsigned int)v6)\n        return v6;\n    } while ((v8 = *((long long *)(v8 + 8)), v8));\n  }\n  v3 = x1a->field_4;\n  if (v7 <= v3) {\n    v9 = v7 * 2;\n    v4 = malloc(v9 * 32);\n    if (!v4)\n      return 0;\n    v10 = v4 + v9 * 24;\n    v0 = v10;\n    if ((unsigned int)v9 > 0) {\n      v11 = &v10[v9];\n      do {\n        *((long long *)v10) = 0;\n        v10 += 8;\n      } while (v10 != v11);\n    }\n    if (x1a->field_4 > 0) {\n      v12 = v4;\n      v13 = v12 + 8;\n      v1 = -8 - v12;\n      do {\n        v15 = &v0[(unsigned int)v9 - 1 &\n                  (int)strhash(\n                      *((long long *)(v1 + v13 + (char *)x1a->field_8)))];\n        v16 = *(v15);\n        if (v16)\n          v16->field_10 = v13;\n      } while ((v8 = *((long long *)(v8 + 8)), v8));\n    }\n    free(x1a->field_8);\n    x1a->field_0 = v9;\n    x1a->field_4 = v3;\n    x1a->field_8 = v4;\n    x1a->field_10 = v0;\n  }\n  v17 = x1a->field_0 - 1 & v2;\n  v18 = x1a->field_4;\n  x1a->field_4 = (unsigned int)v18 + 1;\n  v19 = v18 * 24 + x1a->field_8;\n  v19[0] = a0;\n  v20 = *((long long *)(x1a->field_10 + v17 * 8));\n  if (v20)\n    v20->field_10 = &v19[1];\n  v19[1] = *((long long *)(x1a->field_10 + v17 * 8));\n  *((unsigned long long *[3])(x1a->field_10 + v17 * 8)) = v19;\n  v19[2] = v17 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:28:8: error: unknown type name 'struct_0'\n   28 | extern struct_0 *x1a;\n      |        ^\n/tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:61:13: error: assignment to cast is illegal,\nlvalue casts are not supported 61 |             (unsigned int)v6 =\nstrcmp(*((long long *)v8), a0); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:87:17: error: array type 'unsigned long\nlong[2]' is not assignable 87 |             v13 = v12 + 8; |             ~~~ ^\n/tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:91:88: error: invalid operands to binary\nexpression ('unsigned long long *' and 'char *') 91 |                 v15 =\n&v0[(unsigned int)v9 - 1 & (int)strhash(*((long long *)(v1 + v13 + (char\n*)x1a->field_8)))]; | ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:108:47: error: invalid operands to binary\nexpression ('struct struct_2 **' and 'int') 108 |     v20 = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                           ~~~ ^\n~ /tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:111:50: error: invalid operands to binary\nexpression ('struct struct_2 **' and 'int') 111 |     v19[1] = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                              ~~~\n^ ~ /tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:112:53: error: invalid operands to binary\nexpression ('struct struct_2 **' and 'int') 112 |     *((unsigned long long\n*[3])(x1a->field_10 + v17 * 8)) = v19; | ~~~ ^ ~\n/tmp/tmpipiyqryf/Strsafe_insert_name_conflict.c:113:18: error: invalid operands to binary\nexpression ('struct struct_2 **' and 'int') 113 |     v19[2] = v17 * 8 +\nx1a->field_10; |              ~~~ ^ ~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe_find(const char *key) {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  char padding_8[8];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned long v1;     // rbx\n  struct struct_0 **v2; // rax\n\n  if (!x1a)\n    return x1a;\n  v2 = (int)x1a->field_0 - 1 & (int)strhash(a0);\n  v1 = *((long long *)(x1a->field_10 + v2 * 8));\n  if (!v1)\n    return *((long long *)(x1a->field_10 + v2 * 8));\n  while (true) {\n    if (strcmp(*((long long *)v1), a0)) {\n      v1 = *((long long *)(v1 + 8));\n      if (!v1)\n        return v1;\n    } else {\n      v1 = *((long long *)v1);\n      return v1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpunuffdxc/Strsafe_find_name_conflict.c:34:45: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 34 |     v1 = *((long long\n*)(x1a->field_10 + v2 * 8)); |                                          ~~ ^ ~\n/tmp/tmpunuffdxc/Strsafe_find_name_conflict.c:36:51: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 36 |         return *((long long\n*)(x1a->field_10 + v2 * 8)); |                                                ~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if (x2a)\n    v1 = x2a->field_4;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxl3owbny/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmpxl3owbny/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpxl3owbny/Symbol_count_name_conflict.c:27:19: error: member\nreference type 'int' is not a pointer 27 |         v1 = x2a->field_4; | ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Configcmp(const char *_a, const char *_b) {\n    const struct config *a = (struct config *)_a;\n    const struct config *b = (struct config *)_b;\n    int x;\n    x = a->rp->index - b->rp->index;\n    if (x == 0)\n        x = a->dot - b->dot;\n    return x;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  struct struct_0 *field_0;\n  unsigned int field_8;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[72];\n  unsigned int field_48;\n} struct_0;\n\nlong long Configcmp_name_conflict(struct_1 *a0, struct_1 *a1) {\n  int tmp_17;            // tmp #17\n  struct_0 *v1;          // rdx\n  unsigned long long v2; // rax\n  unsigned long v3;      // rax, Other Possible Types: unsigned long long\n\n  v1 = a1->field_0;\n  v2 = a0->field_0->field_48;\n  tmp_17 = v2;\n  v3 = (unsigned int)v2 - v1->field_48;\n  if ((int)tmp_17 == v1->field_48)\n    v3 = a0->field_8 - a1->field_8;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long check_path_name_conflict(char *a0) {\n  if (a0)\n    return access(a0, 4) != -1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(check_path)(long long);\nchar *(getenv)(char *);\nchar *(getcwd)(char *, unsigned long);\nint(snprintf)(char *, unsigned long, char *, ...);\nvoid(perror)(char *);\n\nextern char g_40204f;\n\nlong long get_config_path_name_conflict(unsigned long long a0, char *a1, unsigned int a2) {\n  char v0;          // [bp-0x218]\n  unsigned long v2; // rbx\n\n  if ((int)check_path(a0))\n    return a0;\n  v2 = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if ((int)check_path(v2))\n    return v2;\n  snprintf(a1, a2, \"%s/%s\", (unsigned int)getcwd(&v0, 0x200), &g_40204f);\n  if ((int)check_path(a1))\n    return a1;\n  snprintf(a1, a2, \"%s/.proxychains/%s\", (unsigned int)getenv(\"HOME\"),\n           &g_40204f);\n  if ((int)check_path(a1)) {\n    return a1;\n  } else if ((int)check_path(\"/etc/proxychains.conf\")) {\n    return \"/etc/proxychains.conf\";\n  } else if (!(int)check_path(\"/etc/proxychains.conf\")) {\n    perror(\"couldnt find configuration file\");\n    exit(1); /* do not return */\n  } else {\n    return \"/etc/proxychains.conf\";\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfe5iwxgv/get_config_path_name_conflict.c:19:6: error: conflicting types for 'snprintf'\n   19 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpfe5iwxgv/get_config_path_name_conflict.c:20:7: error: conflicting types for 'perror'\n   20 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long check_path_name_conflict(char *a0) {\n  if (a0)\n    return access(a0, 4) != -1;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(check_path)(long long);\nchar *(getenv)(char *);\nchar *(getcwd)(char *, unsigned long);\nint(snprintf)(char *, unsigned long, char *, ...);\nvoid(perror)(char *);\n\nextern char g_402072;\n\nlong long get_config_path_name_conflict(unsigned long long a0, char *a1, unsigned int a2) {\n  char v0;          // [bp-0x218]\n  unsigned long v2; // rbx\n\n  if ((int)check_path(a0))\n    return a0;\n  v2 = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if ((int)check_path(v2))\n    return v2;\n  snprintf(a1, a2, \"%s/%s\", (unsigned int)getcwd(&v0, 0x200), &g_402072);\n  if ((int)check_path(a1))\n    return a1;\n  snprintf(a1, a2, \"%s/.proxychains/%s\", (unsigned int)getenv(\"HOME\"),\n           &g_402072);\n  if ((int)check_path(a1)) {\n    return a1;\n  } else if ((int)check_path(\"/etc/proxychains.conf\")) {\n    return \"/etc/proxychains.conf\";\n  } else if (!(int)check_path(\"/etc/proxychains.conf\")) {\n    perror(\"couldnt find configuration file\");\n    exit(1); /* do not return */\n  } else {\n    return \"/etc/proxychains.conf\";\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnsz5jcmo/get_config_path_name_conflict.c:19:6: error: conflicting types for 'snprintf'\n   19 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpnsz5jcmo/get_config_path_name_conflict.c:20:7: error: conflicting types for 'perror'\n   20 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"int info(int level, const char *fmt, ...) {\n    va_list ap;\n    int length;\n    if (level > verbose)\n        return 0;\n    __builtin_va_start(ap, fmt);\n    length = vfprintf(stdout, fmt, ap);\n    __builtin_va_end(ap);\n    return length;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\n\nextern FILE_t *stdout @GLIBC_2.2.5;\nextern unsigned int verbose;\n\nlong long info_name_conflict(unsigned long a0, char *a1) {\n  unsigned int v0;   // [bp-0xd0]\n  unsigned int v1;   // [bp-0xcc]\n  unsigned long v2;  // [bp-0xc8]\n  unsigned long v3;  // [bp-0xc0]\n  char v4;           // [bp-0xb8]\n  unsigned long v5;  // [bp-0xa8]\n  unsigned long v6;  // [bp-0xa0]\n  unsigned long v7;  // [bp-0x98]\n  unsigned long v8;  // [bp-0x90]\n  int v9;            // [bp-0x88]\n  int v10;           // [bp-0x78]\n  int v11;           // [bp-0x68]\n  int v12;           // [bp-0x58]\n  int v13;           // [bp-0x48]\n  int v14;           // [bp-0x38]\n  int v15;           // [bp-0x28]\n  int v16;           // [bp-0x18]\n  unsigned long v17; // [bp+0x8]\n  unsigned long v18; // rdx\n  unsigned long v19; // rcx\n  unsigned long v20; // r8\n  unsigned long v21; // r9\n  char v22;          // al\n  int v23;           // xmm0\n  int v24;           // xmm1\n  int v25;           // xmm2\n  int v26;           // xmm3\n  int v27;           // xmm4\n  int v28;           // xmm5\n  int v29;           // xmm6\n  int v30;           // xmm7\n\n  v5 = v18;\n  v6 = v19;\n  v7 = v20;\n  v8 = v21;\n  if (v22) {\n    v9 = v23;\n    v10 = v24;\n    v11 = v25;\n    v12 = v26;\n    v13 = v27;\n    v14 = v28;\n    v15 = v29;\n    v16 = v30;\n  }\n  if (verbose >= (unsigned int)a0) {\n    v0 = 16;\n    v1 = 48;\n    v2 = &v17;\n    v3 = &v4;\n    return vfprintf(stdout @GLIBC_2.2.5, a1, &v0);\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdu3wafa1/info_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:104:28: error: array has incomplete element type 'struct\nva_list' 104 | } *, char *, struct va_list[1]); |                            ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:104:21: note: forward declaration of 'struct va_list'\n  104 | } *, char *, struct va_list[1]);\n      |                     ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:106:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 106 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:106:22: error: expected ';' after top level declarator\n  106 | extern FILE_t *stdout@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpdu3wafa1/info_name_conflict.c:164:31: error: expected ')'\n  164 |         return vfprintf(stdout@GLIBC_2.2.5, a1, &v0);\n      |                               ^\n/tmp/tmpdu3wafa1/info_name_conflict.c:164:24: note: to match this '('\n  164 |         return vfprintf(stdout@GLIBC_2.2.5, a1, &v0);\n      |                        ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"unsigned short CALC_CRC1a(unsigned short crc, uint8_t byte) {\n    int i = 8;\n    unsigned short b = byte << 8;\n    while (i--)\n        {\n            crc = (crc << 1) ^ (((crc ^ b) & 32768) ? 4129 : 0);\n            b <<= 1;\n        }\n    return crc;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long CALC_CRC1a_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1;      // eax, Other Possible Types: unsigned long long\n  unsigned int v2;       // esi\n  unsigned int v3;       // edx\n  unsigned int v4;       // ecx\n  unsigned long long v5; // rax\n\n  v1 = (unsigned int)a0;\n  v2 = (unsigned int)a1 * 0x100;\n  v3 = 8;\n  do {\n    v4 = (unsigned int)v1 * 2;\n    v5 = (unsigned int)v1 ^ v2;\n    *((unsigned short *)&v5) = (short)((short)v5 >> 15) & 4129;\n    v1 = (unsigned int)v5 ^ v4;\n    v2 *= 2;\n    v3 -= 1;\n  } while (true);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *detokenize(uint8_t *src, int maxsize) {\n    static char buff[8192];\n    char *dst = buff;\n    int string = 0;\n    while (0 != *src && maxsize-- > 0)\n        {\n            if (string) {\n                if ('\"' == *src)\n                    string = 0;\n                if (*src >= 32 && *src < 127)\n                    *dst++ = *src;\n                else\n                    dst += sprintf(dst, \"\\\\%03o\", *src);\n            } else {\n                if (255 == *src) {\n                    src++;\n                    if (*src < 128 + 26)\n                        dst += sprintf(dst, \"%s\", token[*src]);\n                    else\n                        dst += sprintf(dst, \"<ff%02x>\", *src);\n                } else if (*src > 127) {\n                    dst += sprintf(dst, \"%s\", token[*src & 127]);\n                } else {\n                    *dst++ = *src;\n                    if ('\"' == *src)\n                        string = 1;\n                }\n            }\n            src++;\n        }\n    *dst = '\\x00';\n    return buff;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char buff.3;\nextern char token;\n\nlong long detokenize_name_conflict(char a0[2], unsigned long a1) {\n  unsigned long long *v1; // rdx, Other Possible Types: unsigned long\n  char *v2;   // rbx, Other Possible Types: unsigned long long, unsigned long\n  char v3[2]; // r12, Other Possible Types: unsigned long\n  unsigned long long *v4; // rdx\n  char v5[2];             // r15, Other Possible Types: unsigned long\n  unsigned int v6;        // r13d\n  unsigned long v7;       // rdx\n  unsigned int v10;       // ebp\n\n  v1 = a0[0];\n  v2 = &buff.3;\n  if (!(char)v1) {\n    *((char *)v2) = 0;\n    return &buff.3;\n  }\n  v3 = a0;\n  v10 = (unsigned int)a1 - 1;\n  if ((unsigned int)a1 > 0) {\n    v6 = 0;\n    do {\n      if (!v6) {\n        if ((char)v1 == 255) {\n          v5 = v3 + 1;\n          v4 = *((char *)(v3 + 1));\n          if ((char)v4 > 153) {\n            sprintf(v2, \"<ff%02x>\", (unsigned int)v4);\n            v2 += 6;\n          } else {\n            v2 += sprintf(v2, \"%s\", (int)*((long long *)(&token + 0x8 * v4)));\n          }\n        } else if ((char)v1 >= 0) {\n          *((char *)v2) = v1;\n          v6 = *((char *)v3) == 34;\n          v2 += 1;\n          v5 = v3;\n        } else {\n          v7 = (unsigned int)v1 & 127;\n          v2 += sprintf(v2, \"%s\", (int)*((long long *)&(&token)[8 * v7]));\n          v5 = v3;\n        }\n      } else {\n        if ((char)v1 == 34) {\n          *((char *)v2) = v1;\n        } else if (v1 - 32 <= 94) {\n          *((char *)v2) = v1;\n          v2 += 1;\n          v5 = v3;\n        } else {\n          sprintf(v2, \"\\\\%03o\", (unsigned int)v1);\n          v2 += 4;\n          v5 = v3;\n        }\n      }\n    } while ((v3 = v5 + 1, v1 = (unsigned long long)(char)*((char *)(v5 + 1)),\n              (char)v1 && (v10 -= 1, v10 != -1)));\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:17:17: error: expected ';' after top level\ndeclarator 17 | extern char buff.3; |                 ^ |                 ;\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:32:15: error: expected ';' after expression\n   32 |     v2 = &buff.3;\n      |               ^\n      |               ;\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:36:21: error: expected ';' after return statement\n   36 |         return &buff.3;\n      |                     ^\n      |                     ;\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:38:8: error: array type 'char[2]' is not\nassignable 38 |     v3 = a0; |     ~~ ^ /tmp/tmp4t19m3eu/detokenize_name_conflict.c:49:24:\nerror: array type 'char[2]' is not assignable 49 |                     v5 = v3 +\n1; |                     ~~ ^ /tmp/tmp4t19m3eu/detokenize_name_conflict.c:58:83: error:\ninvalid operands to binary expression ('int' and 'unsigned long long *') 58 | v2\n+= sprintf(v2, \"%s\", (int)*((long long *)(&token + 0x8 * v4))); | ~~~ ^ ~~\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:66:24: error: array type 'char[2]' is not\nassignable 66 |                     v5 = v3; |                     ~~ ^\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:72:24: error: array type 'char[2]' is not\nassignable 72 |                     v5 = v3; |                     ~~ ^\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:85:24: error: array type 'char[2]' is not\nassignable 85 |                     v5 = v3; |                     ~~ ^\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:91:24: error: array type 'char[2]' is not\nassignable 91 |                     v5 = v3; |                     ~~ ^\n/tmp/tmp4t19m3eu/detokenize_name_conflict.c:94:22: error: array type 'char[2]' is not\nassignable 94 |         } while ((v3 = v5 + 1, v1 = (unsigned long\nlong)(char)*((char *)(v5 + 1)), (char)v1 && (v10 -= 1, v10 != -1))); | ~~ ^ 11\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_scan_sectors(track_stat_t *ts) {\n    uint8_t *p;\n    int ip;\n    unsigned long dp;\n    unsigned long dd;\n    unsigned long len;\n    unsigned short crc, c;\n    dam_t *dam;\n    memset(ts, 0, sizeof (*ts));\n    for (ip = 0; ip < 128; ip += 2) {\n        p = dmk.track;\n        dam = &ts->sector[ip / 2];\n        dp = p[ip + 0] + 256 * p[ip + 1];\n        if (0 == dp)\n            break;\n        dd = dp & 32768;\n        dp = dp & ~32768;\n        info(1, \"#%02x @%04x\", ip / 2, dp);\n        crc = 65535;\n        if (32768 == dd) {\n            dam->flags |= 1;\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        if (p[dp] != 254) {\n            info(1, \" - not pointing to AM (0xfe)\\n\");\n            dam->flags |= 2;\n            ts->am_bad += 1;\n            continue;\n        }\n        ts->am_good += 1;\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->c = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->h = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->r = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->n = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        len = 1 << (7 + (dam->n & 3));\n        info(1, \" C:%02x H:%02x R:%02x N:%02x\", dam->c, dam->h, dam->r, dam->n);\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" AM-CRC:good\");\n            dam->flags &= ~4;\n        } else {\n            info(1, \" AM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 4;\n            ts->am_crc_bad += 1;\n        }\n        for (; dp < (256UL * dmk.trklen[1] + dmk.trklen[0]); dp++) {\n            if (p[dp] >= 248 && p[dp] <= 251)\n                break;\n        }\n        if (dp >= (256UL * dmk.trklen[1] + dmk.trklen[0])) {\n            info(1, \" no DAM!\\n\");\n            dam->flags |= 8;\n            ts->dam_missing += 1;\n            continue;\n        }\n        crc = 65535;\n        if (32768 == dd) {\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        switch (p[dp]) {\n          case 248:\n          case 249:\n          case 250:\n            dam->flags |= 32;\n            break;\n          case 251:\n            dam->flags &= ~32;\n            break;\n        }\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        info(1, \" DAM:%02x\", p[dp]);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->dp = dp;\n        dam->flags |= 128;\n        while (len-- > 0)\n            {\n                if (0 != (dam->flags & 128) && 229 != p[dp])\n                    dam->flags &= ~128;\n                crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n                dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n            }\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" DAM-CRC:good\");\n            dam->flags &= ~16;\n        } else {\n            info(1, \" DAM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 16;\n            ts->dam_crc_bad += 1;\n        }\n        if (dam->flags & 128)\n            info(1, \" empty\");\n        info(1, \"\\n\");\n    }\n    ts->sector_count = ip / 2;\n    info(1, \"\\n\");\n    if (0 == ts->am_bad && 0 == ts->am_crc_bad && 0 == ts->dam_crc_bad)\n        ts->perfect = 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint cx;  // add global variable by heuristics\nint rcx; // add global variable by heuristics\nint di;  // add global variable by heuristics\nint rdi; // add global variable by heuristics\nint r8w; // add global variable by heuristics\nint r8;  // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[1];\n  char field_2;\n  char padding_3[765];\n  unsigned long long field_300;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[8];\n  unsigned int field_8;\n  char padding_c[4];\n  char field_10;\n} struct_1;\n\nextern unsigned short crc16;\nextern char g_46a142;\nextern char g_46a143;\nextern char g_46a144;\nextern char g_46a150[2];\nextern char g_46a151;\nextern char g_46a152;\nextern char g_46a153;\nextern char g_46a154;\nextern char g_46a155;\n\nlong long dmk_scan_sectors_name_conflict(struct_0 *a0) {\n  unsigned int v0;        // [bp-0x5c]\n  char v1[2];             // [bp-0x58], Other Possible Types: unsigned long\n  unsigned short v2;      // [bp-0x4e]\n  unsigned int v3;        // [bp-0x4c]\n  unsigned long v4;       // [bp-0x48], Other Possible Types: unsigned long long\n  struct_0 *v5;           // [bp-0x40]\n  struct_0 *v7;           // r13\n  unsigned long long *v8; // rdi, Other Possible Types: unsigned long\n  unsigned long v9;       // rcx, Other Possible Types: unsigned long long\n  unsigned long v10;      // d\n  char v11[2];            // rax\n  char v14[4628822];      // rbp\n  char v15[4628822];      // rbx\n  unsigned long long v16; // rbp\n  unsigned long v17;      // rax, Other Possible Types: unsigned long long\n  char *v19;              // rcx\n  unsigned long long v20; // rax\n  unsigned long long v21; // rdx\n  unsigned long v22;      // rbx\n  unsigned long long v23; // rdi\n  char v24[16];           // rcx\n  unsigned long long v25; // r8\n  unsigned long long v27; // rax\n  unsigned long v28;      // rbx\n  unsigned long long v29; // r8\n  unsigned long long v30; // r9\n  unsigned long long v32; // rax\n  unsigned long v33;      // rbx\n  unsigned long long v34; // r8\n  unsigned long long v35; // r9\n  unsigned long long v37; // rax\n  unsigned long v38;      // rbx\n  unsigned long long v39; // r9\n  unsigned long long v40; // rcx\n  unsigned long v42;      // rbx\n  unsigned long long v43; // rsi\n  char v44[16];           // rcx\n  unsigned long long v45; // rdi\n  unsigned long long v47; // rax\n  unsigned long long v48; // rdi\n  unsigned long long v49; // r8\n  unsigned long long v51; // rax\n  unsigned long long v52; // r8\n  unsigned long long v53; // rdi\n  unsigned long long v55; // rax\n  unsigned long long v56; // r9\n  unsigned long long v57; // rcx\n  unsigned short v60;     // dx\n  unsigned short v61;     // cx\n  char v63[2];            // rax, Other Possible Types: unsigned long\n  unsigned short v64;     // dx\n  unsigned short v65;     // dx\n  unsigned long v66;      // rbx, Other Possible Types: unsigned long long\n  unsigned long v67;      // rbx\n  unsigned long long v70; // rdx\n  char *v71;              // rdx\n  char v72;               // al\n  unsigned long v77;      // rdx, Other Possible Types: unsigned long long\n  struct_1 *v78;          // rbx\n  unsigned long long v79; // rsi, Other Possible Types: unsigned long\n  char v80;               // dil\n  unsigned long long v81; // rax\n  unsigned long v82;      // rax\n  unsigned long long v83; // r12, Other Possible Types: unsigned long\n  unsigned long v84;      // rax, Other Possible Types: unsigned long long\n  unsigned long v85;      // rdx\n  unsigned short v86;     // cx\n  unsigned long v87;      // rax, Other Possible Types: unsigned long long\n  unsigned short v88;     // dx\n  void *v89;              // r14, Other Possible Types: unsigned long\n  struct_0 *v90;          // rbx\n\n  v7 = a0;\n  v5 = a0;\n  *((long long *)&a0->field_0) = 0;\n  a0->field_300 = 0;\n  v8 = &a0->padding_3[5] & -8;\n  for (v9 = (unsigned int)(v7 - v8) + 776 >> 3; v9; v8 += v10 * 8) {\n    v9 -= 1;\n    *((long long *)v8) = 0;\n  }\n  *((char **)&v1) = &g_46a150[0];\n  v89 = 0;\n  while (true) {\n    v0 = (v89 >> 31) + v89 >> 1;\n    v11 = v1;\n    v14 = v11[1] * 0x100 + v11[0];\n    v15 = v14;\n    if (!v14)\n      break;\n    v16 = (unsigned int)v14 & 0x8000;\n    v15[0] = v15[0] & 127;\n    info(1, \"#%02x @%04x\");\n    v17 = 4294967295;\n    if (v16 == 0x8000) {\n      v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] | 1;\n      v17 = 4294954420;\n    }\n    v19 = v15 + &g_46a150[0];\n    if (*(v19) != 254) {\n      info(1, \" - not pointing to AM (0xfe)\\n\");\n      v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] | 2;\n      v7->field_2 = v7->field_2 + 1;\n    } else {\n      v7->padding_1 = v7->padding_1 + 1;\n      v3 = (unsigned int)v17 / 0x100;\n      v20 = v17 * 0x100;\n      v83 = v20;\n      *((unsigned short *)&v20) =\n          (unsigned short)v20 ^ (&crc16)[(char)v3 ^ *(v19)];\n      if (v16) {\n        v43 = *((char *)(v15 + &g_46a151));\n        v44 = &(&v7->field_0)[12 * v0];\n        v44[12] = v43;\n        v45 = v20;\n        *((unsigned short *)&v20) = di<2> >> 8;\n        v47 = v20 * 0x100;\n        *((unsigned short *)&v47) =\n            (unsigned short)v47 ^ (&crc16)[(unsigned int)v43 ^ rdi];\n        v48 = *((char *)(&g_46a152 + v15));\n        v44[13] = v48;\n        v49 = v47;\n        *((unsigned short *)&v49) = r8w<2> >> 8;\n        v51 = v47 * 0x100;\n        *((unsigned short *)&v51) =\n            (unsigned short)v51 ^ (&crc16)[(unsigned int)v48 ^ r8];\n        v52 = *((char *)(v15 + &g_46a153));\n        v44[14] = v52;\n        v53 = v51;\n        *((unsigned short *)&v51) = di<2> >> 8;\n        v55 = v51 * 0x100;\n        *((unsigned short *)&v55) =\n            (unsigned short)v55 ^ (&crc16)[rdi ^ (unsigned int)v52];\n        v56 = *((char *)(&g_46a154 + v15));\n        v44[15] = v56;\n        v57 = v55;\n        *((unsigned short *)&v55) = cx<2> >> 8;\n        v2 = (unsigned short)v55 * 0x100 ^ (&crc16)[rcx ^ (unsigned int)v56];\n        v4 = 1 << ((char)(((unsigned int)v56 & 3) + 7) & 31);\n        info(1, \" C:%02x H:%02x R:%02x N:%02x\");\n        v61 = *((char *)(v15 + &g_46a155));\n        v63 = &v15[6];\n        v64 = *((char *)(&g_46a150[0] + v15 + 6));\n        v65 = v64 | v61 * 0x100;\n        v66 = 1;\n      } else {\n        v21 = g_46a144 & 64;\n        v22 = &v15[(!(unsigned int)v21) + 1];\n        v23 = g_46a150[v22];\n        v24 = &(&v7->field_0)[12 * v0];\n        v24[12] = v23;\n        v25 = v20;\n        *((unsigned short *)&v25) = r8w<2> >> 8;\n        v27 = v20 * 0x100;\n        *((unsigned short *)&v27) =\n            (unsigned short)v27 ^ (&crc16)[(unsigned int)v23 ^ r8];\n        v28 = v22 + 1 + ((char)v21 < 1);\n        v29 = g_46a150[v28];\n        v24[13] = v29;\n        v30 = v27;\n        *((unsigned short *)&v27) = r9w<2> >> 8;\n        v32 = v27 * 0x100;\n        *((unsigned short *)&v32) =\n            (unsigned short)v32 ^ (&crc16)[(unsigned int)v29 ^ r9];\n        v33 = v28 + 1 + ((char)v21 < 1);\n        v34 = g_46a150[v33];\n        v24[14] = v34;\n        v35 = v32;\n        *((unsigned short *)&v32) = r9w<2> >> 8;\n        v37 = v32 * 0x100;\n        *((unsigned short *)&v37) =\n            (unsigned short)v37 ^ (&crc16)[r9 ^ (unsigned int)v34];\n        v38 = v33 + 1 + ((char)v21 < 1);\n        v39 = g_46a150[v38];\n        v24[15] = v39;\n        v40 = v37;\n        *((unsigned short *)&v40) = cx<2> >> 8;\n        v2 = (unsigned short)v37 * 0x100 ^ (&crc16)[rcx ^ (unsigned int)v39];\n        v42 = v38 + 1 + ((char)v21 < 1);\n        v4 = 1 << ((char)(((unsigned int)v39 & 3) + 7) & 31);\n        info(1, \" C:%02x H:%02x R:%02x N:%02x\");\n        v60 = g_46a150[v42] * 0x100;\n        if (!(g_46a144 & 64)) {\n          v63 = v42 + 2;\n          v65 = v60 | g_46a150[2 + v42];\n          v66 = 2;\n        } else {\n          v63 = v42 + 1;\n          v65 = v60 | g_46a150[1 + v42];\n          v66 = 1;\n        }\n      }\n      v67 = v66 + v63;\n      if (v2 != v65) {\n        info(1, \" AM-CRC:bad (%04x != %04x)\");\n        v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] | 4;\n        v7->padding_3[0] = v7->padding_3[0] + 1;\n      } else {\n        info(1, \" AM-CRC:good\");\n        v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] & 251;\n      }\n      v70 = g_46a143 * 0x100 + g_46a142;\n      if (v67 < v70) {\n        do {\n          if (g_46a150[v67] + 8 <= 3) {\n            if (!(v67 < v70))\n              break;\n            v71 = &g_46a150[v67];\n            v72 = *(v71);\n            if (v72 > 250) {\n              if (v72 == 251)\n                v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] & 223;\n            } else {\n              if (v72 > 247)\n                v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] | 32;\n            }\n            *((unsigned short *)&v83) =\n                (unsigned short)v83 ^ (&crc16)[v3 ^ *(v71)];\n            info(1, \" DAM:%02x\");\n            v77 = 1;\n            if (!v16)\n              v77 = (!(g_46a144 & 64)) + 1;\n            v85 = v77 + v67;\n            v78 = &(&v7->field_0)[12 * v0];\n            v78->field_8 = v85;\n            v78->field_10 = v78->field_10 | 128;\n            v79 = v4 - 1;\n            v80 = g_46a144 & 64;\n            do {\n              v81 = v78->field_10;\n              if ((char)v81 < 0 && g_46a150[v85] != 229)\n                v78->field_10 = (unsigned int)v81 & 127;\n              v82 = (char)v83 / 0x100 ^ g_46a150[v85];\n              v83 *= 0x100;\n              *((unsigned short *)&v83) = (unsigned short)v83 ^ (&crc16)[v82];\n              v84 = 1 + (v80 < 1);\n              if (v16)\n                v84 = 1;\n              v85 += v84;\n              v79 -= 1;\n            } while (v79 != -1);\n            v86 = g_46a150[v85] * 0x100;\n            v87 = 1 + (v80 < 1);\n            if (v16)\n              v87 = 1;\n            v88 = g_46a150[v85 + v87];\n            if ((v88 | v86) == (unsigned short)v83) {\n              info(1, \" DAM-CRC:good\");\n              v78->field_10 = v78->field_10 & 239;\n            } else {\n              info(1, \" DAM-CRC:bad (%04x != %04x)\");\n              v78->field_10 = v78->field_10 | 16;\n              v7->padding_3[2] = v7->padding_3[2] + 1;\n            }\n            if (v78->field_10 < 0)\n              info(1, \" empty\");\n            info(1, \"\\n\");\n            goto LABEL_402ee1;\n          }\n        } while ((v67 += 1, v67 != v70));\n      }\n      info(1, \" no DAM!\\n\");\n      v7->padding_3[13 + 12 * v0] = v7->padding_3[13 + 12 * v0] | 8;\n      v7->padding_3[1] = v7->padding_3[1] + 1;\n    }\n  LABEL_402ee1:\n    v89 = (unsigned int)v89 + 2;\n    v1 += 2;\n    if ((unsigned int)v89 == 128)\n      break;\n  }\n  v90 = v5;\n  v90->padding_3[3] = (v89 >> 31) + v89 >> 1;\n  info(1, \"\\n\");\n  if (*((short *)&v90->field_2)) {\n    return 0;\n  } else if (v90->padding_3[2]) {\n    return 0;\n  } else {\n    v90->field_0 = 1;\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:128:28: error: invalid operands to binary\nexpression ('char *' and 'int') 128 |     v8 = &a0->padding_3[5] & -8; |\n~~~~~~~~~~~~~~~~~ ^ ~~ /tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:129:33: error:\n'struct_0 *' (aka 'struct struct_0 *') and 'unsigned long long *' are not\npointers to compatible types 129 |     for (v9 = (unsigned int)(v7 - v8) + 776\n>> 3; v9; v8 += v10 * 8) |                              ~~ ^ ~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:138:19: error: invalid operands to binary\nexpression ('void *' and 'int') 138 |         v0 = (v89 >> 31) + v89 >> 1; | ~~~\n^  ~~ /tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:139:13: error: array type 'char[2]' is\nnot assignable 139 |         v11 = v1; |         ~~~ ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:140:13: error: array type 'char[4628822]' is\nnot assignable 140 |         v14 = v11[1] * 0x100 + v11[0]; |         ~~~ ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:141:13: error: array type 'char[4628822]' is\nnot assignable 141 |         v15 = v14; |         ~~~ ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:153:19: error: invalid operands to binary\nexpression ('char[4628822]' and 'char *') 153 |         v19 = v15 +\n&g_46a150[0]; |               ~~~ ^ ~~~~~~~~~~~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:162:27: error: array type 'char[1]' is not\nassignable 162 |             v7->padding_1 = v7->padding_1 + 1; | ~~~~~~~~~~~~~\n^ /tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:169:38: error: invalid operands to binary\nexpression ('char[4628822]' and 'char *') 169 |                 v43 = *((char\n*)(v15 + &g_46a151)); |                                  ~~~ ^ ~~~~~~~~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:170:21: error: array type 'char[16]' is not\nassignable 170 |                 v44 = &(&v7->field_0)[12 * v0]; | ~~~ ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:173:51: error: expected expression\n  173 |                 *((unsigned short *)&v20) = di<2> >> 8;\n      |                                                   ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:176:44: error: invalid operands to binary\nexpression ('char *' and 'char[4628822]') 176 |                 v48 = *((char\n*)(&g_46a152 + v15)); |                                  ~~~~~~~~~ ^ ~~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:179:52: error: expected expression\n  179 |                 *((unsigned short *)&v49) = r8w<2> >> 8;\n      |                                                    ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:182:38: error: invalid operands to binary\nexpression ('char[4628822]' and 'char *') 182 |                 v52 = *((char\n*)(v15 + &g_46a153)); |                                  ~~~ ^ ~~~~~~~~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:185:51: error: expected expression\n  185 |                 *((unsigned short *)&v51) = di<2> >> 8;\n      |                                                   ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:188:44: error: invalid operands to binary\nexpression ('char *' and 'char[4628822]') 188 |                 v56 = *((char\n*)(&g_46a154 + v15)); |                                  ~~~~~~~~~ ^ ~~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:191:51: error: expected expression\n  191 |                 *((unsigned short *)&v55) = cx<2> >> 8;\n      |                                                   ^\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:195:38: error: invalid operands to binary\nexpression ('char[4628822]' and 'char *') 195 |                 v61 = *((char\n*)(v15 + &g_46a155)); |                                  ~~~ ^ ~~~~~~~~~\n/tmp/tmpxrf5ieqa/dmk_scan_sectors_name_conflict.c:196:21: error: array type 'char[2]' is not\nassignable 196 |                 v63 = &v15[6]; |                 ~~~ ^ fatal\nerror: too many errors emitted, stopping now [-ferror-limit=] 20 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_sort_by_sector(track_stat_t *ts) {\n    qsort(ts->sector, ts->sector_count, sizeof(dam_t), qsort_sector);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint qsort_sector; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[6];\n  char field_6;\n} struct_0;\n\nlong long dmk_sort_by_sector_name_conflict(struct_0 *a0) {\n  qsort(&a0[1].padding_0[1], a0->field_6, 12, qsort_sector);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *newdos_flags_str(newdos_dirent_t *de) {\n    static char flags[13];\n    flags[0] = de->fl0 & 64 ? 'S' : '.';\n    flags[1] = de->fl0 & 8 ? 'I' : '.';\n    flags[2] = de->fl0 & 16 ? 'U' : '.';\n    if (de->fl0 & 64) {\n        flags[3] = de->fl1 & 128 ? 'E' : '.';\n        flags[4] = de->fl1 & 64 ? 'C' : '.';\n        flags[5] = de->fl1 & 1 ? '0' : '.';\n        flags[6] = de->fl1 & 2 ? '1' : '.';\n        flags[7] = de->fl1 & 4 ? '2' : '.';\n        flags[8] = de->fl0 & 8 ? '3' : '.';\n        flags[9] = de->fl0 & 32 ? 'U' : '.';\n        flags[10] = de->fl0 & 64 ? 'A' : '.';\n    } else {\n        flags[3] = '.';\n        flags[4] = '.';\n        flags[5] = '.';\n        flags[6] = '.';\n        flags[7] = '.';\n        flags[8] = '.';\n        flags[9] = '.';\n        flags[10] = '.';\n    }\n    flags[11] = '0' + (de->fl0 & 7);\n    flags[12] = '\\x00';\n    return flags;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char flags.2;\nextern char g_472189;\nextern char g_47218a;\nextern char g_47218b;\nextern char g_47218c;\nextern char g_47218d;\nextern char g_47218e;\nextern char g_47218f;\nextern char g_472190;\nextern char g_472191;\nextern char g_472192;\nextern char g_472193;\nextern char g_472194;\n\nlong long newdos_flags_str_name_conflict(char a0[2]) {\n  unsigned long long v1; // rdx\n  char v2;               // dl\n\n  flags.2 = (-((a0[0] & 64) < 1) & -37) + 83;\n  g_472189 = (-((a0[0] & 8) < 1) & -27) + 73;\n  g_47218a = (-((a0[0] & 16) < 1) & -39) + 85;\n  if (!(a0[0] & 64)) {\n    g_47218b = 46;\n    g_47218c = 46;\n    g_47218d = 46;\n    g_47218e = 46;\n    g_47218f = 46;\n    g_472190 = 46;\n    g_472191 = 46;\n    v2 = 46;\n  } else {\n    v1 = a0[1];\n    *((char *)&v1) = (char)v1 >> 7;\n    g_47218b = ((unsigned int)v1 & 23) + 46;\n    g_47218c = (-((a0[1] & 64) < 1) & -21) + 67;\n    g_47218d = (-((a0[1] & 1) < 1) & -2) + 48;\n    g_47218e = (-((a0[1] & 2) < 1) & -3) + 49;\n    g_47218f = (-((a0[1] & 4) < 1) & -0x4) + 50;\n    g_472190 = (-((a0[0] & 8) < 1) & -5) + 51;\n    g_472191 = (-((a0[0] & 32) < 1) & -39) + 85;\n    v2 = (-((a0[0] & 64) < 1) & -19) + 65;\n  }\n  g_472192 = v2;\n  g_472193 = (a0[0] & 7) + 48;\n  g_472194 = 0;\n  return &flags.2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzohvbaqv/newdos_flags_str_name_conflict.c:17:18: error: expected ';' after top level\ndeclarator 17 | extern char flags.2; |                  ^ |                  ;\n/tmp/tmpzohvbaqv/newdos_flags_str_name_conflict.c:36:10: error: expected ';' after expression\n   36 |     flags.2 = (-((a0[0] & 64) < 1) & -37) + 83;\n      |          ^\n      |          ;\n/tmp/tmpzohvbaqv/newdos_flags_str_name_conflict.c:36:13: error: expression is not assignable\n   36 |     flags.2 = (-((a0[0] & 64) < 1) & -37) + 83;\n      |          ~~ ^\n/tmp/tmpzohvbaqv/newdos_flags_str_name_conflict.c:66:18: error: expected ';' after return\nstatement 66 |     return &flags.2; |                  ^ |                  ; 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *binstr(int val, int bits) {\n    static char buff[33];\n    int i;\n    if (bits > 32)\n        bits = 32;\n    for (i = 0; i < bits; i++ , val >>= 1)\n        buff[i] = '0' + (val & 1);\n    buff[bits] = '\\x00';\n    return buff;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char buff.1;\n\nlong long binstr_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long v1; // rcx\n  char *v2;         // rax, Other Possible Types: unsigned long\n\n  v1 = ((unsigned int)a1 <= 32 ? 32 : a1);\n  if ((unsigned int)a1 > 0) {\n    v2 = 0;\n    do {\n      (&buff.1)[v2] = ((unsigned int)a0 & 1) + 48;\n      a0 >>= 1;\n      v2 += 1;\n    } while ((unsigned int)v1 > (unsigned int)v2);\n  }\n  (&buff.1)[v1] = 0;\n  return &buff.1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpumufdd5o/binstr_name_conflict.c:17:17: error: expected ';' after top level declarator\n   17 | extern char buff.1;\n      |                 ^\n      |                 ;\n/tmp/tmpumufdd5o/binstr_name_conflict.c:30:19: error: expected ')'\n   30 |             (&buff.1)[v2] = ((unsigned int)a0 & 1) + 48;\n      |                   ^\n/tmp/tmpumufdd5o/binstr_name_conflict.c:30:13: note: to match this '('\n   30 |             (&buff.1)[v2] = ((unsigned int)a0 & 1) + 48;\n      |             ^\n/tmp/tmpumufdd5o/binstr_name_conflict.c:30:22: error: array subscript is not an integer\n   30 |             (&buff.1)[v2] = ((unsigned int)a0 & 1) + 48;\n      |                      ^~~\n/tmp/tmpumufdd5o/binstr_name_conflict.c:35:11: error: expected ')'\n   35 |     (&buff.1)[v1] = 0;\n      |           ^\n/tmp/tmpumufdd5o/binstr_name_conflict.c:35:5: note: to match this '('\n   35 |     (&buff.1)[v1] = 0;\n      |     ^\n/tmp/tmpumufdd5o/binstr_name_conflict.c:36:17: error: expected ';' after return statement\n   36 |     return &buff.1;\n      |                 ^\n      |                 ;\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *dmk_filename_ext(newdos_dirent_t *de, char delim) {\n    static char name[13];\n    char *dst, *src;\n    int i;\n    dst = name;\n    for (i = 0 , src = de->filename; i < 8; i++) {\n        if (*src == ' ')\n            break;\n        *dst++ = *src++;\n    }\n    if (*de->extension != ' ') {\n        *dst++ = delim;\n        for (i = 0 , src = de->extension; i < 3; i++) {\n            if (*src == ' ')\n                break;\n            *dst++ = *src++;\n        }\n    }\n    *dst = '\\x00';\n    return name;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[13];\n  char field_d;\n} struct_0;\n\nextern char g_472158;\nextern char name.0 [1];\n\nlong long dmk_filename_ext_name_conflict(struct_0 *a0, unsigned long a1) {\n  char *v1;   // rdx, Other Possible Types: unsigned long\n  char v2[1]; // rax, Other Possible Types: unsigned long\n  char v3;    // cl\n  char *v4;   // rdi, Other Possible Types: unsigned long\n  char v5;    // cl\n  char v6[1]; // rdx, Other Possible Types: unsigned long\n\n  v1 = &a0->padding_0[5];\n  v2 = &name.0 [0];\n  do {\n    v3 = *((char *)v1);\n  } while (v3 != 32 &&\n           (v1 += 1, v2 += 1, *((char *)(v2 - 1)) = v3, v2 != 4661592));\n  if (a0->field_d != 32) {\n    v6 = v2 + 1;\n    *((char *)v2) = a1;\n    v4 = &a0->field_d;\n    v2 += 4;\n    do {\n      v5 = *((char *)v4);\n      if (v5 == 32) {\n        v2 = v6;\n        break;\n      }\n    } while ((v4 += 1, v6 += 1, *((char *)(v6 - 1)) = v5, v2 != v6));\n  }\n  *((char *)v2) = 0;\n  return &name.0 [0];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:23:17: error: expected ';' after top level\ndeclarator 23 | extern char name.0[1]; |                 ^ |                 ;\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:35:8: error: array type 'char[1]' is not\nassignable 35 |     v2 = &name.0[0]; |     ~~ ^\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:35:15: error: expected ';' after expression\n   35 |     v2 = &name.0[0];\n      |               ^\n      |               ;\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:35:17: error: subscripted value is not an\narray, pointer, or vector 35 |     v2 = &name.0[0]; |               ~~^~\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:39:39: error: invalid operands to binary\nexpression ('char[1]' and 'int') 39 |     } while (v3 != 32 && (v1 += 1, v2 +=\n1, *((char *)(v2 - 1)) = v3, v2 != 4661592)); | ~~ ^  ~\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:42:12: error: array type 'char[1]' is not\nassignable 42 |         v6 = v2 + 1; |         ~~ ^\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:45:12: error: invalid operands to binary\nexpression ('char[1]' and 'int') 45 |         v2 += 4; |         ~~ ^  ~\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:51:20: error: array type 'char[1]' is not\nassignable 51 |                 v2 = v6; |                 ~~ ^\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:54:31: error: invalid operands to binary\nexpression ('char[1]' and 'int') 54 |         } while ((v4 += 1, v6 += 1,\n*((char *)(v6 - 1)) = v5, v2 != v6)); |                            ~~ ^  ~\n/tmp/tmpdxx9_098/dmk_filename_ext_name_conflict.c:57:17: error: expected ';' after return\nstatement 57 |     return &name.0[0]; |                 ^ |                 ; 10\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_bas(uint8_t *buff, int *psize) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    if (255 != *buff) {\n        info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\", *buff);\n        return -1;\n    }\n    info(2, \"*** verify BAS\\n\");\n    state = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr) {\n                if (offs + 1 < *psize) {\n                    info(1, \"  data after program (0x%x)\\n\", *psize - 1 - offs);\n                }\n                *psize = offs + 1;\n            }\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            state = 5;\n            info(2, \"  line %5d at 0x%04x\", line, addr);\n            blen = 0;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(2, \" - 0x%02x bytes\\n\", blen);\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    info(2, \"  %d lines\\n\", lcnt);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\n\nlong long verify_bas_name_conflict(char *a0, unsigned int *a1) {\n  unsigned int v0;       // [bp-0x40]\n  unsigned int v1;       // [bp-0x3c]\n  char *v3;              // rbx, Other Possible Types: unsigned long\n  void *v5;              // rsi, Other Possible Types: unsigned long\n  unsigned long long v6; // rbp\n\n  if (*(a0) != 255) {\n    info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\");\n    return 4294967295;\n  }\n  v3 = a0;\n  info(2, \"*** verify BAS\\n\");\n  if (*(a1) <= 0) {\n    v1 = 0;\n  } else {\n    v5 = 0;\n    v1 = 0;\n    v0 = 0;\n    while (true) {\n      v6 = v5 + 1;\n      v3 += 1;\n      if (*(a1) <= (unsigned int)v6)\n        break;\n      if (true)\n        goto 4294953833 + 4221600;\n      else\n        v5 = v6;\n    }\n  }\n  info(2, \"  %d lines\\n\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2lmaebtt/verify_bas_name_conflict.c:49:22: error: expected identifier\n   49 |                 goto 4294953833 + 4221600;\n      |                      ^\n/tmp/tmp2lmaebtt/verify_bas_name_conflict.c:50:13: error: expected expression\n   50 |             else\n      |             ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_cmd(uint8_t *buff, int *psize) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    info(2, \"*** verify CMD\\n\");\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                state = 1;\n                break;\n              case 2:\n                state = 2;\n                break;\n              default:\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  comment block type 0x%02x\\n\", buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  bogus entry block length (%02x)\\n\", blen);\n                blen = 2;\n                buff[offs] = 2;\n            }\n            break;\n          case 3:\n            blen = buff[offs];\n            state = 6;\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            break;\n          case 6:\n            if (--blen <= 0)\n                state = 0;\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            if (blen <= 0)\n                blen += 256;\n            if (addr != chain) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  data at %04x\", addr);\n            }\n            chain = addr;\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            if (chain)\n                info(2, \" - %04x\\n\", chain - 1);\n            chain = 0;\n            info(1, \"  entry point at 0x%04x\\n\", badr);\n            if (offs + 1 < *psize)\n                info(1, \"  data after entry point (0x%x)\\n\", *psize - 1 - offs);\n            *psize = offs + 1;\n            break;\n          case 9:\n            chain += 1;\n            if (--blen <= 0)\n                state = 0;\n            break;\n        }\n    }\n    if (chain)\n        info(2, \" - %04x\\n\", chain - 1);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\n\nextern unsigned long long g_4061ec;\n\nint verify_cmd_name_conflict() {\n  unsigned int v0;       // [bp-0x50]\n  unsigned int v1;       // [bp-0x4c]\n  unsigned long v2;      // [bp-0x48]\n  unsigned long v5;      // rdi\n  unsigned long long v6; // r12\n  unsigned int *v7;      // rsi\n  void *v10;             // rbx\n  unsigned int v11;      // ebp\n  unsigned int *v14;     // r15\n\n  v6 = v5;\n  v2 = v5;\n  v14 = v7;\n  info(2, \"*** verify CMD\\n\");\n  if (*(v7) <= 0)\n    return;\n  v1 = 0;\n  v0 = 0;\n  v11 = 0;\n  v10 = 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_txt(uint8_t *buff, int *psize) {\n    int offs;\n    uint8_t *dst;\n    dst = memchr(buff, '\\x03', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^C (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    dst = memchr(buff, '\\x00', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^@ (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\n\nlong long verify_txt_name_conflict(void *a0, unsigned int *a1) {\n  unsigned long v1;      // r12\n  unsigned long long v2; // rax\n  unsigned int v4;       // r13d\n  unsigned long v5;      // r12\n  unsigned long long v6; // rax\n  unsigned int v8;       // ebx\n\n  v1 = *(a1);\n  v2 = memchr(a0, 3, v1);\n  v4 = (!v2 ? v2 - a0 : v1) + 1;\n  if ((unsigned int)v1 > v4) {\n    info(1, \"  data after end-of-file code ^C (0x%x)\\n\");\n    *(a1) = v4;\n  }\n  v5 = *(a1);\n  v6 = memchr(a0, 0, v5);\n  v8 = (!v6 ? v6 - a0 : v5) + 1;\n  if ((unsigned int)v5 > v8) {\n    info(1, \"  data after end-of-file code ^@ (0x%x)\\n\");\n    *(a1) = v8;\n    return 0;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwd5ixxjo/verify_txt_name_conflict.c:29:20: error: invalid operands to binary\nexpression ('unsigned long long' and 'void *') 29 |     v4 = (!v2 ? v2 - a0 :\nv1) + 1; |                 ~~ ^ ~~ /tmp/tmpwd5ixxjo/verify_txt_name_conflict.c:37:20: error:\ninvalid operands to binary expression ('unsigned long long' and 'void *') 37 |\nv8 = (!v6 ? v6 - a0 : v5) + 1; |                 ~~ ^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_bas(uint8_t *buff, int size) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    state = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr)\n                offs = size;\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            info(0, \"%05x:(%04x) %5d\", offs, addr, line);\n            blen = 0;\n            state = 5;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(0, \" %s\\n\", detokenize(buff + offs - blen + 1, blen));\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\nlong long(detokenize)(long long, long long);\n\nextern unsigned long long g_40623a;\nextern unsigned long long g_40624a;\n\nint hexdump_bas_name_conflict() {\n  unsigned int v0;   // [bp-0x3c]\n  unsigned long v1;  // [bp-0x30]\n  unsigned long v2;  // [bp-0x28]\n  unsigned long v3;  // [bp-0x20]\n  unsigned long v4;  // [bp-0x18]\n  unsigned long v5;  // [bp-0x10]\n  unsigned long v6;  // [bp-0x8]\n  unsigned int v9;   // esi\n  unsigned long v10; // rdx\n  unsigned long v15; // r15\n  unsigned long v16; // r14\n  unsigned long v17; // r13\n  unsigned long v18; // r12\n  unsigned long v19; // rbx\n  unsigned int v20;  // r12d\n  unsigned int v21;  // ebx\n\n  if (v9 <= 0)\n    return;\n  v6 = v15;\n  v5 = v16;\n  v4 = v17;\n  v3 = v18;\n  *((int *)&v2) = rbp;\n  v1 = v19;\n  v20 = v9;\n  v0 = 0;\n  v21 = 0;\n  v10 = 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_cmd(uint8_t *buff, int size) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    int bcnt = 0;\n    int i;\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 1;\n                break;\n              case 2:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 2;\n                break;\n              default:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                blen = 2;\n            }\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 3:\n            blen = buff[offs];\n            bcnt = 0;\n            state = 6;\n            info(0, \" %02x (comment length %03x)\\n\", buff[offs], blen);\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 6:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15))\n                info(0, \"\\n\");\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15))\n                    info(0, \"\\n\");\n                state = 0;\n            }\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            bcnt = 0;\n            if (blen <= 0)\n                blen += 256;\n            info(0, \" %02x (data length %03x @ %04x)\\n\", buff[offs], blen, addr);\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            bcnt = 0;\n            info(0, \" %02x (entry point %04x)\\n\", buff[offs], badr);\n            offs = size;\n            break;\n          case 9:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, addr + bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15)) {\n                info(0, \" - \");\n                for (i = -15; i <= 0; i++)\n                    info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                info(0, \"\\n\");\n            }\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15)) {\n                    info(0, \"%-*s - \", 3 * (16 - (bcnt & 15)), \"\");\n                    for (i = -(bcnt & 15); i <= 0; i++)\n                        info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                    info(0, \"\\n\");\n                }\n                state = 0;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\n\nextern unsigned long long g_406101;\nextern unsigned long long g_406254;\nextern unsigned long long g_40625a;\nextern unsigned long long g_406277;\nextern unsigned long long g_406283;\nextern unsigned long long g_40629d;\nextern unsigned long long g_4062a0;\nextern unsigned long long g_4062a4;\nextern unsigned long long g_406758;\n\nint hexdump_cmd_name_conflict() {\n  unsigned long v0; // [bp-0x58]\n  unsigned int v1;  // [bp-0x50]\n  unsigned int v2;  // [bp-0x4c]\n  unsigned int v3;  // [bp-0x48]\n  unsigned long v9; // rdi\n  unsigned int v10; // esi\n  unsigned int v13; // ebx\n  void *v14;        // rbp\n  unsigned int v15; // r15d\n\n  v0 = v9;\n  if (v10 <= 0)\n    return;\n  v15 = v10;\n  v1 = 0;\n  v3 = 0;\n  v2 = 0;\n  v13 = 0;\n  v14 = 0;\n}\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_raw(uint8_t *buff, int size) {\n    int y, x;\n    for (y = 0; y < size; y += 16) {\n        info(0, \"%05x:\", y);\n        for (x = 0; x < 16; x++)\n            info(0, \" %02x\", buff[y + x]);\n        info(0, \" - \");\n        for (x = 0; x < 16; x++)\n            info(0, \"%c\", ((buff[y + x]) < 32 || (buff[y + x]) > 126 ? '.' : (buff[y + x])));\n        info(0, \"\\n\");\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(info)(long long, long long, ...);\n\nlong long hexdump_raw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x3c]\n  unsigned long v1;       // [bp-0x30]\n  unsigned long v2;       // [bp-0x28]\n  unsigned long v3;       // [bp-0x20]\n  unsigned long v4;       // [bp-0x18]\n  unsigned long v5;       // [bp-0x10]\n  unsigned long v6;       // [bp-0x8]\n  unsigned long v8;       // r15\n  unsigned long v9;       // r14\n  unsigned long v10;      // r13\n  unsigned long v11;      // r12\n  unsigned long v12;      // rbx\n  char *v14;              // rbp, Other Possible Types: unsigned long\n  char *v15;              // rbx, Other Possible Types: unsigned long\n  unsigned int v16;       // r15d\n  unsigned long v17;      // r12, Other Possible Types: unsigned long long\n  unsigned long long v18; // rbx\n  unsigned long long v19; // r12\n  unsigned long long v20; // r13\n  unsigned long long v21; // r14\n  unsigned long long v22; // r15\n\n  if ((unsigned int)a1 <= 0)\n    return 0;\n  v6 = v8;\n  v5 = v9;\n  v4 = v10;\n  v3 = v11;\n  *((int *)&v2) = rbp;\n  v1 = v12;\n  v17 = a0 + 16;\n  v0 = ((unsigned int)a1 - 1 & -0x10) + 16;\n  do {\n    info(0, \"%05x:\");\n    v15 = v17 - 16;\n    v14 = v15;\n    do {\n      info(0, \" %02x\");\n      v14 += 1;\n    } while (v14 != v17);\n    info(0, \" - \");\n    do {\n    } while ((info(0, \"%c\"), v15 += 1, v15 != v17));\n    info(0, \"\\n\");\n    v16 = 0 + 16;\n    v17 += 16;\n  } while (v16 != v0);\n  v18 = v1;\n  v19 = v3;\n  v20 = v4;\n  v21 = v5;\n  v22 = v6;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"unsigned long HTcopy(char *ul) {\n    unsigned long retval;\n    memcpy(&retval, ul, sizeof (retval));\n    return retval;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long HTcopy_name_conflict(unsigned long long *a0) { return *(a0); }\n","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long SparseMemory(u_long cBuckets, u_long cOccupied) {\n    return (cOccupied * sizeof(HTItem) + ((((cBuckets) - 1) >> (0 + 6)) + 1) * sizeof(SparseBin));\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long DenseMemory(u_long cBuckets, u_long cOccupied) {\n    return cBuckets * sizeof(HTItem);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long NextPow2(u_long x) {\n    if (((x << 1) >> 1) != x)\n        x >>= 1;\n    while ((x & (x - 1)) != 0)\n        x &= (x - 1);\n    return x << 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"int sendAll(SOCKET s, char *buf, int len) {\n    int total = 0;\n    int bytesleft = len;\n    int n = 0;\n    while (total < len)\n        {\n            n = send(s, buf + total, bytesleft, MSG_NOSIGNAL);\n            if (n == -1) {\n                break;\n            }\n            total += n;\n            bytesleft -= n;\n        }\n    return n == -1 ? 0 : total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\n\nlong long sendAll_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned long v2;      // rbp, Other Possible Types: unsigned long long\n  unsigned long v3;      // rdx\n  unsigned long long v4; // rax\n  void *v5;              // rbx, Other Possible Types: unsigned long\n\n  if ((unsigned int)a2 <= 0)\n    return 0;\n  v2 = a2;\n  v5 = 0;\n  while ((unsigned int)v4 != -1) {\n    v3 = v2;\n    a1 = v5 + a1;\n    v4 = send(a0, a1, v3, 0x4000);\n    v5 += v4;\n    v2 -= v4;\n    if ((unsigned int)a2 <= (unsigned int)v5)\n      return v5;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprh877hui/sendAll_name_conflict.c:32:17: error: invalid operands to binary expression\n('void *' and 'void *') 32 |         a1 = v5 + a1; |              ~~ ^ ~~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"int sendFileArg(char *filename) {\n    int i, f;\n    if ((f = open(filename, 0)) < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    i = read(f, buf, (2048));\n    while (i > 0)\n        {\n            sendChunk(i, 'L', buf);\n            i = read(f, buf, (2048));\n        }\n    if (i < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    sendChunk(0, 'L', buf);\n    close(f);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(read)(int, void *, unsigned long);\nlong long(sendChunk)(long long, long long, long long);\nint(close)(int);\n\nextern void buf;\n\nlong long sendFileArg_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long long v1; // rax\n  unsigned int v2;       // ebp\n  unsigned long v3;      // rdi, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = open(a0, 0, a2);\n  if ((unsigned int)v1 < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  v2 = v1;\n  v3 = read(v1, &buf, 0x800);\n  if ((unsigned int)v3 > 0) {\n    do {\n      sendChunk(v3, 76, &buf);\n      v3 = read(v2, &buf, 0x800);\n    } while ((unsigned int)v3 > 0);\n  }\n  if ((unsigned int)v3 < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  sendChunk(0, 76, &buf);\n  close(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxh1ngs88/sendFileArg_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpxh1ngs88/sendFileArg_name_conflict.c:30:5: error: assignment to cast is illegal,\nlvalue casts are not supported 30 |     (unsigned int)v1 = open(a0, 0, a2); |\n^~~~~~~~~~~~~~~~ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"unsigned long recvToBuffer(unsigned long len) {\n    unsigned long bytesRead = 0;\n    while (bytesRead < len)\n        {\n            int thisPass = recv(nailgunsocket, buf + bytesRead, len - bytesRead, MSG_WAITALL);\n            if (thisPass == 0 || thisPass == -1) {\n                perror(\"recv\");\n                handleSocketClose();\n            }\n            bytesRead += thisPass;\n        }\n    return bytesRead;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\nvoid(perror)(char *);\nlong long(handleSocketClose)();\n\nextern char buf;\nextern unsigned int nailgunsocket;\n\nlong long recvToBuffer_name_conflict(unsigned long a0) {\n  void *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n\n  if (!a0)\n    return a0;\n  v1 = 0;\n  while (true) {\n    v2 = recv(nailgunsocket, &(&buf)[v1], a0 - v1, 0x100);\n    if ((unsigned int)(v2 + 1) <= 1) {\n      perror(\"recv\");\n      handleSocketClose(); /* do not return */\n    }\n    v1 += v2;\n    if (v1 >= a0)\n      return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpihgnzgdp/recvToBuffer_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpihgnzgdp/recvToBuffer_name_conflict.c:33:41: error: array subscript is not an integer\n   33 |         v2 = recv(nailgunsocket, &(&buf)[v1], a0 - v1, 0x100);\n      |                                         ^~~\n/tmp/tmpihgnzgdp/recvToBuffer_name_conflict.c:33:50: error: invalid operands to binary\nexpression ('unsigned long' and 'void *') 33 |         v2 = recv(nailgunsocket,\n&(&buf)[v1], a0 - v1, 0x100); |                                               ~~\n^ ~~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"int processStdin() {\n    int bytesread = read(0, buf, (2048));\n    if (bytesread > 0) {\n        sendStdin(buf, bytesread);\n    } else if (bytesread == 0) {\n        processEof();\n    }\n    return (bytesread);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(sendStdin)(long long, long long);\nlong long(processEof)();\n\nextern void buf;\n\nlong long processStdin_name_conflict() {\n  unsigned long long v1; // rax\n\n  v1 = read(0, &buf, 0x800);\n  if ((unsigned int)v1 > 0) {\n    sendStdin(&buf, v1);\n    return v1;\n  } else if ((unsigned int)v1) {\n    return v1;\n  } else {\n    processEof();\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"int intervalMillis(struct timeval end, struct timeval start) {\n    return ((end.tv_sec - start.tv_sec) * 1000) + ((end.tv_usec - start.tv_usec) / 1000);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long intervalMillis(unsigned long a0, unsigned long a1, unsigned long a2,\n                         unsigned long a3) {\n  return ((unsigned int)a0 - (unsigned int)a2) * 1000 +\n         ((a1 - a3) * 2361183241434822607 >> 64 >> 7) - (a1 - a3 >> 63);\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"char *shortClientName(char *s) {\n    char *result = strrchr(s, '/');\n    return ((result == ((void *)0)) ? s : result + 1);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shortClientName_name_conflict(char *a0) {\n  unsigned long v0;      // [bp-0x8]\n  unsigned long v2;      // rbx\n  unsigned long long v3; // rax\n  unsigned long long v5; // rbx\n\n  v0 = v2;\n  v3 = strrchr(a0, 47);\n  v5 = v0;\n  return (v3 ? a0 : v3 + 1);\n}\n","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int isNailgunClientName(char *s) {\n    return (!(strcmp(s, \"ng\")));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isNailgunClientName_name_conflict(char *a0) { return !strcmp(a0, \"ng\"); }\n","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":0,"function":"pid_t do_driver(char *driver) {\n    pid_t child;\n    int pipe[2];\n    if (socketpair(1, SOCK_STREAM, 0, pipe) < 0)\n        err_sys(\"can't create socketpair\");\n    if ((child = fork()) < 0)\n        err_sys(\"fork error\");\n    else if (child == 0) {\n        close(pipe[1]);\n        if (dup2(1, 2) != 2)\n            err_sys(\"dup2 error to sterr\");\n        if (dup2(pipe[0], 0) != 0)\n            err_sys(\"dup2 error to stdin\");\n        if (dup2(pipe[0], 1) != 1)\n            err_sys(\"dup2 error to stdout\");\n        close(pipe[0]);\n        execlp(driver, driver, (char *)0);\n        err_sys(\"execlp error for: %s\", driver);\n    }\n    close(pipe[0]);\n    if (dup2(pipe[1], 0) != 0)\n        err_sys(\"dup2 error to stdin\");\n    if (dup2(pipe[1], 1) != 1)\n        err_sys(\"dup2 error to stdout\");\n    close(pipe[1]);\n    return child;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socketpair)(int, int, int, int(32 bits)[2]);\nlong long(err_sys)(...);\nint(fork)();\nint(close)(int);\nint(dup2)(int, int);\n\nlong long do_driver_name_conflict(char *a0) {\n  char v0;               // [bp-0x20]\n  char v1;               // [bp-0x1c]\n  unsigned long long v3; // rbx\n\n  if (socketpair(1, 1, 0, &v0) < 0)\n    err_sys(); /* do not return */\n  v3 = fork();\n  if ((unsigned int)v3 < 0) {\n    err_sys(); /* do not return */\n  } else if ((unsigned int)v3) {\n    close(*((int *)&v0));\n    if (dup2(*((int *)&v1), 0)) {\n      err_sys(); /* do not return */\n    } else if (dup2(*((int *)&v1), 1) != 1) {\n      err_sys(); /* do not return */\n    } else {\n      close(*((int *)&v1));\n      return v3;\n    }\n  } else {\n    close(*((int *)&v1));\n    if (dup2(1, 2) != 2) {\n      err_sys(); /* do not return */\n    } else if (dup2(*((int *)&v0), 0)) {\n      err_sys(); /* do not return */\n    } else if (dup2(*((int *)&v0), 1) != 1) {\n      err_sys(); /* do not return */\n    } else {\n      close(*((int *)&v0));\n      execlp(a0, a0);\n      err_sys(); /* do not return */\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa09_y_x3/do_driver_name_conflict.c:16:38: error: expected ')'\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                      ^\n/tmp/tmpa09_y_x3/do_driver_name_conflict.c:16:37: note: to match this '('\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                     ^\n/tmp/tmpa09_y_x3/do_driver_name_conflict.c:17:21: error: ISO C requires a named parameter\nbefore '...' 17 | long long (err_sys)(...); |                     ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/driver.c"}
{"compilable":0,"function":"int tty_cbreak(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = CBREAK;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t;  // add global variable by heuristics\nint int128_t;  // add global variable by heuristics\nint uint128_t; // add global variable by heuristics\nint uint128_t; // add global variable by heuristics\nint uint128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern uint128_t g_4051b0;\nextern uint128_t g_4051c0;\nextern uint128_t g_4051cc;\nextern termios save_termios;\nextern char ttysavefd;\nextern unsigned int ttystate;\n\nlong long tty_cbreak_name_conflict(unsigned long a0) {\n  termios v0;      // [bp-0x48]\n  unsigned int v1; // [bp-0x3c]\n  int v2;          // [bp-0x38]\n  char v3;         // [bp-0x32]\n  char v4;         // [bp-0x31]\n  int v5;          // [bp-0x28]\n  int v6;          // [bp-0x1c]\n\n  if (tcgetattr(a0, &save_termios.c_iflag) < 0)\n    return 4294967295;\n  *((int128_t *)&v0.c_iflag) = *((int128_t *)&save_termios.c_iflag);\n  *((uint128_t *)&v2) = g_4051b0;\n  *((uint128_t *)&v5) = g_4051c0;\n  *((uint128_t *)&v6) = g_4051cc;\n  *((char[4]) & v1) = v0.padding_c & -11;\n  v4 = 1;\n  v3 = 0;\n  if (tcsetattr(a0, 2, &v0) < 0)\n    return 4294967295;\n  ttystate = 2;\n  *((unsigned int *)&ttysavefd) = a0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:56:8: error: unknown type name 'uint128_t'\n   56 | extern uint128_t g_4051b0;\n      |        ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:57:8: error: unknown type name 'uint128_t'\n   57 | extern uint128_t g_4051c0;\n      |        ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:58:8: error: unknown type name 'uint128_t'\n   58 | extern uint128_t g_4051cc;\n      |        ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:75:18: error: expected expression\n   75 |     *((int128_t *)&v0.c_iflag) = *((int128_t *)&save_termios.c_iflag);\n      |                  ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:75:47: error: expected expression\n   75 |     *((int128_t *)&v0.c_iflag) = *((int128_t *)&save_termios.c_iflag);\n      |                                               ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:76:19: error: expected expression\n   76 |     *((uint128_t *)&v2) = g_4051b0;\n      |                   ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:77:19: error: expected expression\n   77 |     *((uint128_t *)&v5) = g_4051c0;\n      |                   ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:78:19: error: expected expression\n   78 |     *((uint128_t *)&v6) = g_4051cc;\n      |                   ^\n/tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:79:7: error: used type 'char[4]' where arithmetic\nor pointer type is required 79 |     *((char [4])&v1) = v0.padding_c & -11; | ^\n~~~ /tmp/tmpmc3vcre5/tty_cbreak_name_conflict.c:79:37: error: invalid operands to binary\nexpression ('char[4]' and 'int') 79 |     *((char [4])&v1) = v0.padding_c & -11;\n      |                        ~~~~~~~~~~~~ ^ ~~~\n10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"int tty_raw(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2 | 32768 | 1);\n    buf.c_iflag &= ~(2 | 256 | 16 | 32 | 1024);\n    buf.c_cflag &= ~(48 | 256);\n    buf.c_cflag |= 48;\n    buf.c_oflag &= ~(1);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = RAW;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t;  // add global variable by heuristics\nint int128_t;  // add global variable by heuristics\nint uint128_t; // add global variable by heuristics\nint uint128_t; // add global variable by heuristics\nint uint128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern uint128_t g_4051b0;\nextern uint128_t g_4051c0;\nextern uint128_t g_4051cc;\nextern termios save_termios;\nextern char ttysavefd;\nextern unsigned int ttystate;\n\nlong long tty_raw_name_conflict(unsigned long a0) {\n  termios v0;      // [bp-0x48], Other Possible Types: unsigned int\n  int tmp_14;      // tmp #14\n  int tmp_65;      // tmp #65\n  int tmp_26;      // tmp #26\n  unsigned int v1; // [bp-0x44]\n  unsigned int v2; // [bp-0x40]\n  unsigned int v3; // [bp-0x3c]\n  int v4;          // [bp-0x38]\n  char v5;         // [bp-0x32]\n  char v6;         // [bp-0x31]\n  int v7;          // [bp-0x28]\n  int v8;          // [bp-0x1c]\n\n  if (tcgetattr(a0, &save_termios.c_iflag) < 0)\n    return 4294967295;\n  *((int128_t *)&v0.c_iflag) = *((int128_t *)&save_termios.c_iflag);\n  *((uint128_t *)&v4) = g_4051b0;\n  *((uint128_t *)&v7) = g_4051c0;\n  *((uint128_t *)&v8) = g_4051cc;\n  *((char[4]) & v3) = v0.padding_c & -32780;\n  tmp_14 = v0.c_iflag;\n  v0 = tmp_14 & -1331;\n  tmp_65 = v0.c_oflag;\n  v2 = tmp_65 & -305 | 48;\n  tmp_26 = v0.padding_4;\n  v1 = tmp_26 & -2;\n  v6 = 1;\n  v5 = 0;\n  if (tcsetattr(a0, 2, &v0) < 0)\n    return 4294967295;\n  ttystate = 1;\n  *((unsigned int *)&ttysavefd) = a0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:56:8: error: unknown type name 'uint128_t'\n   56 | extern uint128_t g_4051b0;\n      |        ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:57:8: error: unknown type name 'uint128_t'\n   57 | extern uint128_t g_4051c0;\n      |        ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:58:8: error: unknown type name 'uint128_t'\n   58 | extern uint128_t g_4051cc;\n      |        ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:80:18: error: expected expression\n   80 |     *((int128_t *)&v0.c_iflag) = *((int128_t *)&save_termios.c_iflag);\n      |                  ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:80:47: error: expected expression\n   80 |     *((int128_t *)&v0.c_iflag) = *((int128_t *)&save_termios.c_iflag);\n      |                                               ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:81:19: error: expected expression\n   81 |     *((uint128_t *)&v4) = g_4051b0;\n      |                   ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:82:19: error: expected expression\n   82 |     *((uint128_t *)&v7) = g_4051c0;\n      |                   ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:83:19: error: expected expression\n   83 |     *((uint128_t *)&v8) = g_4051cc;\n      |                   ^\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:84:7: error: used type 'char[4]' where arithmetic or\npointer type is required 84 |     *((char [4])&v3) = v0.padding_c & -32780; | ^\n~~~ /tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:84:37: error: invalid operands to binary\nexpression ('char[4]' and 'int') 84 |     *((char [4])&v3) = v0.padding_c &\n-32780; |                        ~~~~~~~~~~~~ ^ ~~~~~~\n/tmp/tmp4v3cf7_a/tty_raw_name_conflict.c:86:8: error: assigning to 'termios' (aka 'struct\ntermios') from incompatible type 'int' 86 |     v0 = tmp_14 & -1331; |        ^\n~~~~~~~~~~~~~~ 11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"int tty_reset(int fd) {\n    if (ttystate != CBREAK && ttystate != RAW)\n        return (0);\n    if (tcsetattr(fd, 2, &save_termios) < 0)\n        return (-1);\n    ttystate = RESET;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\nextern termios save_termios;\nextern unsigned int ttystate;\n\nlong long tty_reset_name_conflict(unsigned long a0) {\n  if (ttystate - 1 > 1) {\n    return 0;\n  } else if (tcsetattr(a0, 2, &save_termios.c_iflag) >= 0) {\n    ttystate = 0;\n    return 0;\n  } else {\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpea2u209d/tty_reset_name_conflict.c:26:8: error: unknown type name 'termios'\n   26 | extern termios save_termios;\n      |        ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"struct termios *tty_termios(void) {\n    return (&save_termios);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char save_termios;\n\nlong long tty_termios_name_conflict() { return &save_termios; }\n","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long func1_name_conflict() { return 42; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/exclusion/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hello2_name_conflict() {\n  puts(\"Hello, two!\");\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int asm_function() {\n    return 41;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long asm_function_name_conflict() { return 41; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/rules/src/subdir4/program.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long func1_name_conflict() { return 42; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/product/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hello2_name_conflict() {\n  puts(\"Hello, two!\");\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int funcB() {\n    return 3;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long funcB_name_conflict() { return 3; }\n","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/b/b3.c"}
{"compilable":0,"function":"int funcA() {\n    return funcB();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(funcB)();\n\nlong long funcA_name_conflict() { return funcB(); }\n","pass":0,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/a.c"}
{"compilable":0,"function":"char *create_pkt(char *ip) {\n    char *ptr;\n    char *adr;\n    char *token;\n    int fd;\n    int arp_proto = htons(2054);\n    int hw_tp = htons(1);\n    int pro_type = htons(2048);\n    int hw_size = 6;\n    int pr_size = 4;\n    int opcode = htons(1);\n    int i;\n    unsigned char seq;\n    struct ifreq buffer;\n    struct sockaddr_in *ipadd;\n    ptr = malloc(sizeof(char[44]));\n    memset(ptr, 0, sizeof(char[44]));\n    fd = socket(2, SOCK_DGRAM, IPPROTO_IP);\n    memset(&buffer, 0, sizeof (buffer));\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    ioctl(fd, 35111, &buffer);\n    close(fd);\n    memcpy(ptr, \"\\377\\377\\377\\377\\377\\377\", 6);\n    memcpy(ptr + 6, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memcpy(ptr + (2 * 6), &arp_proto, 2);\n    memcpy(ptr + 14, &hw_tp, 2);\n    memcpy(ptr + 14 + 2, &pro_type, 2);\n    memcpy(ptr + 14 + 4, &hw_size, 1);\n    memcpy(ptr + 14 + 5, &pr_size, 1);\n    memcpy(ptr + 14 + 6, &opcode, 2);\n    memcpy(ptr + 14 + 8, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memset(&buffer, 0, sizeof buffer);\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    fd = socket(2, SOCK_DGRAM, 0);\n    if (ioctl(fd, 35093, &buffer) == -1)\n        printf(\"ioctl ip checking error\\n\");\n    close(fd);\n    ipadd = (struct sockaddr_in *)&(buffer.ifr_ifru.ifru_addr);\n    adr = inet_ntoa(ipadd->sin_addr);\n    printf(\"alamat ipmu adalah : %s\\n\", adr);\n    token = strtok(adr, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + 6 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    i = 0;\n    token = strtok(ip, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + (2 * 6) + 4 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    return ptr;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint eax;      // add global variable by heuristics\nint eax;      // add global variable by heuristics\nint eax;      // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(close)(int);\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nchar *(strtok)(char *, char *);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[12];\n  unsigned short field_10;\n} struct_0;\n\nlong long create_pkt(unsigned long a0) {\n  char v0;                // [bp-0x58]\n  unsigned short v1;      // [bp-0x54]\n  int v2;                 // [bp-0x52]\n  int v3;                 // [bp-0x42]\n  unsigned short v4;      // [bp-0x32]\n  struct_0 *v7;           // rbp\n  unsigned int v8;        // edx\n  unsigned int v9;        // esi\n  unsigned int v10;       // edi\n  unsigned long long v11; // rax\n  unsigned int v12;       // esi\n  unsigned int v13;       // edi\n  unsigned long long v14; // rdx\n  unsigned short v15;     // ax\n  unsigned int v16;       // ebx\n  char *v17;              // rax\n  char *v18;              // rdi, Other Possible Types: unsigned long\n  void *v19;              // rbx, Other Possible Types: unsigned long\n  char *v20;              // rdi, Other Possible Types: unsigned long\n  char *v21;              // rbx, Other Possible Types: unsigned long\n\n  v7 = malloc(44);\n  *((int128_t *)&v7->field_0) = 0;\n  *((int128_t *)&v7->field_10) = 0;\n  *((int128_t *)&v7[1].padding_4[6]) = 0;\n  v8 = 0;\n  v9 = 2;\n  v10 = 2;\n  (unsigned int)v11 = socket(2, 2, 0);\n  *((int128_t *)&v2) = 0;\n  *((int128_t *)&v3) = 0;\n  v4 = 0;\n  strncpy(&v0, \"wlan\", 4);\n  v1 = 48;\n  v12 = 35111;\n  ioctl(eax<4>, 35111);\n  v13 = eax<4>;\n  close(eax<4>);\n  v7->field_0 = -1;\n  *((short *)&v7->padding_4[0]) = 65535;\n  v14 = (int)(&v2)[12];\n  *((unsigned int *)&v7->padding_4[2]) = v14;\n  v15 = (short)v3;\n  *((unsigned short *)&v7->padding_4[6]) = v15;\n  *((short *)&v7->padding_4[8]) = 1544;\n  *((short *)&v7->padding_4[10]) = 0x100;\n  v7->field_10 = 8;\n  *((char *)&v7[1].field_0) = 6;\n  *((char *)&v7[1].field_0 + 1) = 4;\n  *((short *)((char *)&v7[1].field_0 + 2)) = 0x100;\n  *((unsigned int *)&v7[1].padding_4[0]) = v14;\n  *((unsigned short *)&v7[1].padding_4[4]) = v15;\n  *((int128_t *)&v2) = 0;\n  *((int128_t *)&v3) = 0;\n  v4 = 0;\n  strncpy(&v0, \"wlan\", 4);\n  v1 = 48;\n  v16 = socket(2, 2, 0);\n  if (ioctl(v16, 35093) == -1)\n    puts(\"ioctl ip checking error\");\n  close(v16);\n  v17 = inet_ntoa();\n  printf(\"alamat ipmu adalah : %s\\n\", (unsigned int)v17);\n  v18 = strtok(v17, \".\");\n  if (v18) {\n    v19 = 0;\n    do {\n      v7[1].padding_4[6 + v19] = strtol(v18, NULL, 10);\n      v18 = strtok(NULL, \".\");\n      v19 += 1;\n    } while (v18);\n  }\n  v20 = strtok(a0, \".\");\n  if (!v20)\n    return v7;\n  v21 = (char *)&v7[2].field_0 + 2;\n  do {\n    *((char *)v21) = strtol(v20, NULL, 10);\n    v20 = strtok(NULL, \".\");\n    v21 += 1;\n  } while (v20);\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpggcrr5z0/create_pkt.c:62:18: error: expected expression\n   62 |     *((int128_t *)&v7->field_0) = 0;\n      |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:63:18: error: expected expression\n   63 |     *((int128_t *)&v7->field_10) = 0;\n      |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:64:18: error: expected expression\n   64 |     *((int128_t *)&v7[1].padding_4[6]) = 0;\n      |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:68:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 68 |     (unsigned int)v11 = socket(2, 2, 0); |\n^~~~~~~~~~~~~~~~~ ~ /tmp/tmpggcrr5z0/create_pkt.c:69:18: error: expected\nexpression 69 |     *((int128_t *)&v2) = 0; |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:70:18: error: expected expression\n   70 |     *((int128_t *)&v3) = 0;\n      |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:75:17: error: expected expression\n   75 |     ioctl(eax<4>, 35111);\n      |                 ^\n/tmp/tmpggcrr5z0/create_pkt.c:76:17: error: expected expression\n   76 |     v13 = eax<4>;\n      |                 ^\n/tmp/tmpggcrr5z0/create_pkt.c:77:17: error: expected expression\n   77 |     close(eax<4>);\n      |                 ^\n/tmp/tmpggcrr5z0/create_pkt.c:92:18: error: expected expression\n   92 |     *((int128_t *)&v2) = 0;\n      |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:93:18: error: expected expression\n   93 |     *((int128_t *)&v3) = 0;\n      |                  ^\n/tmp/tmpggcrr5z0/create_pkt.c:101:21: error: too few arguments to function call,\nexpected 1, have 0 101 |     v17 = inet_ntoa(); |           ~~~~~~~~~ ^\n/tmp/tmpggcrr5z0/create_pkt.c:27:8: note: 'inet_ntoa' declared here\n   27 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n/tmp/tmpggcrr5z0/create_pkt.c:109:28: error: array subscript is not an integer\n  109 |             v7[1].padding_4[6 + v19] = strtol(v18, NULL, 10);\n      |                            ^~~~~~~~\n13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int are_equal(const unsigned char *str1, const unsigned char *str2, int len) {\n    int i;\n    for (i = 0; i < len; i++) {\n        if (!(*(str1 + i) & *(str2 + i)))\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long are_equal_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char *v1; // rax, Other Possible Types: unsigned long\n\n  if ((unsigned int)a2 <= 0)\n    return 1;\n  v1 = 0;\n  while ((*((char *)(a0 + v1)) & *((char *)(a1 + v1)))) {\n    v1 += 1;\n    if (v1 == a2)\n      return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"int create_socket() {\n    int fd;\n    fd = socket(17, SOCK_RAW, htons(2054));\n    if (fd == -1)\n        printf(\"socket error\\n\");\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\n\nlong long create_socket_name_conflict() {\n  unsigned long long v1; // rax\n\n  (unsigned int)v1 = socket(17, 3, 1544);\n  if ((unsigned int)v1 == -1) {\n    puts(\"socket error\");\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4ovbkqg1/create_socket_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v1 = socket(17, 3, 1544);\n      |     ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"int examine_addr(char *addr) {\n    char *ex;\n    char sec_addr[3];\n    char *token;\n    unsigned int tes;\n    int chk_ip = 0;\n    ex = strchr(addr, ' ');\n    if (ex != ((void *)0)) {\n        printf(\"alamat yang di masukkan salah, mohon jangan ada spasi\\n\");\n        return 0;\n    }\n    token = strtok(addr, \".\");\n    while (token != ((void *)0))\n        {\n            chk_ip++;\n            tes = atoi(token);\n            if (tes > 255) {\n                printf(\"alamat ip tidak ada yang lebih dari 255\\n\");\n                return 0;\n            }\n            token = strtok(((void *)0), \".\");\n        }\n    if (chk_ip != 4) {\n        printf(\"alamat tidak valid\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok)(char *, char *);\n\nlong long examine_addr_name_conflict(char *a0) {\n  char *v2; // rdi, Other Possible Types: unsigned long\n\n  if (strchr(a0, 32)) {\n    puts(\"alamat yang di masukkan salah, mohon jangan ada spasi\");\n    return 0;\n  }\n  v2 = strtok(a0, \".\");\n  if (v2) {\n    do {\n      if ((int)strtol(v2, NULL, 10) > 255) {\n        puts(\"alamat ip tidak ada yang lebih dari 255\");\n        return 0;\n      }\n    } while ((v2 = strtok(NULL, \".\"), v2));\n    if (false)\n      return 1;\n  }\n  puts(\"alamat tidak valid\");\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"static int make_user_test(void) {\n    struct user *user = psylbm_make_user();\n    psylbm_free_user(user);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int make_bookmark_test(void) {\n    struct bookmark *bookmark = psylbm_make_bookmark();\n    psylbm_free_bookmark(bookmark);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int parse_insert_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_INSERT;\n    const char *curr = &buffer[4];\n    {\n        char *dst = &message->message.insert.name[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.title[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.volume_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.chapter_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.page_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.token[0];\n        while (*curr != 0 && *curr != '|')\n            *(dst++) = *(curr++);\n    }\n    if (*curr != 0) {\n        curr++;\n        char *dst = &message->message.insert.book_id_str[0];\n        while (*curr != 0)\n            *(dst++) = *(curr++);\n    }\n    message->message.insert.volume = atoi(message->message.insert.volume_str);\n    message->message.insert.chapter = atoi(message->message.insert.chapter_str);\n    message->message.insert.page = atoi(message->message.insert.page_str);\n    message->message.insert.book_id = atoi(message->message.insert.book_id_str);\n    return 0;\n  error:\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_auth_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_AUTH;\n    const char *curr = &buffer[5];\n    char *username = &message->message.auth.username[0];\n    while (*curr != '|')\n        *(username++) = *(curr++);\n    curr++;\n    char *password = &message->message.auth.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_register_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_REGISTER;\n    struct received_message recv_mess = {0};\n    const size_t max_username_len = sizeof (recv_mess.message.regist.username) - 1;\n    const char *curr = &buffer[4];\n    char *username = &message->message.regist.username[0];\n    size_t count = 0;\n    while (*curr != '|')\n        {\n            if (count == max_username_len)\n                break;\n            *(username++) = *(curr++);\n            count++;\n        }\n    curr++;\n    char *password = &message->message.regist.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_delete_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_DELETE;\n    const char *curr = &buffer[4];\n    char *bookmark_id_str = &message->message.delete.bookmark_id_str[0];\n    while (*curr != '|')\n        *(bookmark_id_str++) = *(curr++);\n    curr++;\n    char *token = &message->message.delete.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    message->message.delete.bookmark_id = atoi(message->message.delete.bookmark_id_str);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_purge_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_PURGE;\n    const char *curr = &buffer[6];\n    char *token = &message->message.purge.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_sync_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNC;\n    const char *curr = &buffer[5];\n    char *token = &message->message.sync.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_syncdata_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNCDATA;\n    const char *curr = &buffer[9];\n    char *token = &message->message.syncdata.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"char *psylbm_strndup(const unsigned char *src, size_t len) {\n    const size_t c_str_len = len + 1;\n    char *ret = calloc(1, sizeof(char) * c_str_len);\n    memcpy(ret, src, len);\n    ret[len] = 0;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long psylbm_strndup_name_conflict(void *a0, char *a1) {\n  char *v1;         // rbp\n  unsigned long v3; // rbx\n\n  v1 = a1;\n  v3 = calloc(1, a1 + 1);\n  v1[v3] = 0;\n  return memcpy(v3, a0, v1);\n}\n","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/common.c"}
{"compilable":0,"function":"char *get_executable() {\n    char buffer[4096];\n    snprintf(buffer, 4096, \"/proc/%u/exe\", getpid());\n    char *filename = malloc(4096);\n    ssize_t len = readlink(buffer, filename, 4096);\n    if (len == -1) {\n        fprintf(stderr, \"Can't get executable name from %s - %s\\n\", buffer, strerror((*__errno_location())));\n        exit(-1);\n    } else if (len >= 4096) {\n        fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\", 4096, filename, 4096);\n        exit(-1);\n    }\n    filename[len] = '\\x00';\n    return filename;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nlong(readlink)(char *, char *, unsigned long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_executable_name_conflict() {\n  char v0;          // [bp-0x1018]\n  char *v2;         // rbx\n  unsigned long v3; // rax\n\n  snprintf(&v0, 0x1000, \"/proc/%u/exe\", getpid());\n  v2 = malloc(0x1000);\n  v3 = readlink(&v0, v2, 0x1000);\n  if (v3 == -1) {\n    fprintf(stderr @GLIBC_2.2.5, \"Can't get executable name from %s - %s\\n\",\n            (unsigned int)&v0, (unsigned int)strerror(*(__errno_location())));\n    exit(-1); /* do not return */\n  } else if (v3 <= 4095) {\n    v2[v3] = 0;\n    return v2;\n  } else {\n    fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\",\n            0x1000, (unsigned int)v2);\n    exit(-1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj8tvwfd2/get_executable_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpj8tvwfd2/get_executable_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 20 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpj8tvwfd2/get_executable_name_conflict.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpj8tvwfd2/get_executable_name_conflict.c:21:22: error: expected ';' after top level\ndeclarator 21 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpj8tvwfd2/get_executable_name_conflict.c:34:23: error: expected ')'\n   34 |         fprintf(stderr@GLIBC_2.2.5, \"Can't get executable name from %s -\n%s\\n\", (unsigned int)&v0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpj8tvwfd2/get_executable_name_conflict.c:34:16: note: to match this '('\n   34 |         fprintf(stderr@GLIBC_2.2.5, \"Can't get executable name from %s -\n%s\\n\", (unsigned int)&v0, (unsigned int)strerror(*(__errno_location()))); | ^ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int check_taskcontroller_permissions(char *executable_file) {\n    (*__errno_location()) = 0;\n    char *resolved_path = realpath(executable_file, ((void *)0));\n    if (resolved_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Error resolving the canonical name for the executable : %s!\", strerror((*__errno_location())));\n        return -1;\n    }\n    struct stat filestat;\n    (*__errno_location()) = 0;\n    if (stat(resolved_path, &filestat) != 0) {\n        fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\", strerror((*__errno_location())));\n        return -1;\n    }\n    uid_t binary_euid = filestat.st_uid;\n    gid_t binary_gid = filestat.st_gid;\n    if (binary_euid != 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be user-owned by root.\\n\");\n        return -1;\n    }\n    if (binary_gid != getgid()) {\n        fprintf(LOGFILE, \"The configured tasktracker group %d is different from the group of the executable %d\\n\", getgid(), binary_gid);\n        return -1;\n    }\n    if ((filestat.st_mode & ((256 >> 3) >> 3)) == ((256 >> 3) >> 3) || (filestat.st_mode & ((128 >> 3) >> 3)) == ((128 >> 3) >> 3) || (filestat.st_mode & ((64 >> 3) >> 3)) == ((64 >> 3) >> 3)) {\n        fprintf(LOGFILE, \"The task-controller binary should not have read or write or execute for others.\\n\");\n        return -1;\n    }\n    if ((filestat.st_mode & 2048) == 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be set setuid.\\n\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(realpath)(char *, char *);\nchar *(strerror)(int);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nunsigned int(getgid)();\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern FILE_t *LOGFILE;\n\nlong long check_taskcontroller_permissions_name_conflict(char *a0) {\n  stat v0;               // [bp-0xa8]\n  char v1;               // [bp-0x90]\n  char v2;               // [bp-0x8c]\n  char v3;               // [bp-0x88]\n  unsigned int *v5;      // rbp\n  char *v6;              // rax\n  unsigned int v7;       // ebp\n  unsigned long long v8; // rax\n  unsigned long v9;      // rbx, Other Possible Types: unsigned long long\n\n  v5 = __errno_location();\n  *(v5) = 0;\n  v6 = realpath(a0, NULL);\n  if (!v6) {\n    fprintf(LOGFILE,\n            \"Error resolving the canonical name for the executable : %s!\",\n            (unsigned int)strerror(*(v5)));\n    return 4294967295;\n  }\n  *(v5) = 0;\n  v9 = stat(v6, &v0);\n  if ((unsigned int)v9) {\n    fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\",\n            (unsigned int)strerror(*(v5)));\n    return 4294967295;\n  }\n  v7 = *((int *)&v3);\n  if (*((int *)&v2)) {\n    fwrite(\"The task-controller binary should be user-owned by root.\\n\", 1, 57,\n           LOGFILE);\n    return 4294967295;\n  }\n  (unsigned int)v8 = getgid();\n  if ((unsigned int)v8 != v7) {\n    fprintf(LOGFILE,\n            \"The configured tasktracker group %d is different from the group \"\n            \"of the executable %d\\n\",\n            getgid(), v7);\n    return 4294967295;\n  } else if (((char)*((int *)&v1) & 7)) {\n    fwrite(\"The task-controller binary should not have read or write or \"\n           \"execute for others.\\n\",\n           1, 80, LOGFILE);\n    return 4294967295;\n  } else if (((char)v8 & 8)) {\n    return v9;\n  } else {\n    fwrite(\"The task-controller binary should be set setuid.\\n\", 1, 49,\n           LOGFILE);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmph6s07vip/check_taskcontroller_permissions_name_conflict.c:50:3: error: redefinition of\n'stat' as different kind of symbol 50 | } stat; |   ^\n/tmp/tmph6s07vip/check_taskcontroller_permissions_name_conflict.c:18:6: note: previous\ndefinition is here 18 | int (stat)(char *, struct stat { |      ^\n/tmp/tmph6s07vip/check_taskcontroller_permissions_name_conflict.c:52:8: error: unknown type\nname 'FILE_t'; did you mean 'FILE'? 52 | extern FILE_t *LOGFILE; |        ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmph6s07vip/check_taskcontroller_permissions_name_conflict.c:56:5: error: must use\n'struct' tag to refer to type 'stat' 56 |     stat v0;  // [bp-0xa8] |     ^ |\nstruct /tmp/tmph6s07vip/check_taskcontroller_permissions_name_conflict.c:18:6: note: struct\n'stat' is hidden by a non-type declaration of 'stat' here 18 | int (stat)(char\n*, struct stat { |      ^\n/tmp/tmph6s07vip/check_taskcontroller_permissions_name_conflict.c:87:5: error: assignment to\ncast is illegal, lvalue casts are not supported 87 |     (unsigned int)v8 =\ngetgid(); |     ^~~~~~~~~~~~~~~~ ~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_effective_user(uid_t user, gid_t group) {\n    if (geteuid() == user) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        return -1;\n    }\n    if (setegid(group) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", group, strerror((*__errno_location())));\n        return -1;\n    }\n    if (seteuid(user) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", user, strerror((*__errno_location())));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nint(seteuid)(unsigned int);\nint(setegid)(unsigned int);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\n\nlong long change_effective_user_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1; // rax\n\n  if (geteuid() == (unsigned int)a0) {\n    return 0;\n  } else if (seteuid(0)) {\n    return 4294967295;\n  } else if (setegid(a1)) {\n    fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\",\n            (unsigned int)a1, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    (unsigned int)v1 = seteuid(a0);\n    if ((unsigned int)v1) {\n      fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\",\n              (unsigned int)a0, (unsigned int)strerror(*(__errno_location())));\n      return 4294967295;\n    }\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmparavad3b/change_effective_user_name_conflict.c:21:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmparavad3b/change_effective_user_name_conflict.c:37:113: error: indirection requires\npointer operand ('int' invalid) 37 |         fprintf(LOGFILE, \"Failed to set\neffective group id %d - %s\\n\", (unsigned int)a1, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmparavad3b/change_effective_user_name_conflict.c:42:9: error: assignment to cast is\nillegal, lvalue casts are not supported 42 |         (unsigned int)v1 =\nseteuid(a0); |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmparavad3b/change_effective_user_name_conflict.c:45:116: error: indirection requires\npointer operand ('int' invalid) 45 |             fprintf(LOGFILE, \"Failed to set\neffective user id %d - %s\\n\", (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int change_user(uid_t user, gid_t group) {\n    if (user == getuid() && user == geteuid() && group == getgid() && group == getegid()) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        fprintf(LOGFILE, \"unable to reacquire root - %s\\n\", strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setgid(group) != 0) {\n        fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", group, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setuid(user) != 0) {\n        fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", user, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(getuid)();\nunsigned int(geteuid)();\nint(seteuid)(unsigned int);\nunsigned int(getgid)();\nint(setgid)(unsigned int);\nchar *(strerror)(int);\nunsigned int(getegid)();\nint(setuid)(unsigned int);\n\nextern FILE_t *LOGFILE;\n\nlong long change_user_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1; // rax\n\n  if (getuid() == (unsigned int)a0 && geteuid() == (unsigned int)a0 &&\n      getgid() == (unsigned int)a1 && getegid() == (unsigned int)a1)\n    return 0;\n  if (seteuid(0)) {\n    fprintf(LOGFILE, \"unable to reacquire root - %s\\n\",\n            (unsigned int)strerror(*(__errno_location())));\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  } else if (setgid(a1)) {\n    fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", (unsigned int)a1,\n            (unsigned int)strerror(*(__errno_location())));\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  } else {\n    (unsigned int)v1 = setuid(a0);\n    if ((unsigned int)v1) {\n      fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", (unsigned int)a0,\n              (unsigned int)strerror(*(__errno_location())));\n      fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n              geteuid(), getegid());\n      return 6;\n    }\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp43mqa9jw/change_user_name_conflict.c:25:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 25 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp43mqa9jw/change_user_name_conflict.c:35:84: error: indirection requires pointer\noperand ('int' invalid) 35 |         fprintf(LOGFILE, \"unable to reacquire root\n- %s\\n\", (unsigned int)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp43mqa9jw/change_user_name_conflict.c:41:103: error: indirection requires pointer\noperand ('int' invalid) 41 |         fprintf(LOGFILE, \"unable to set group to %d\n- %s\\n\", (unsigned int)a1, (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp43mqa9jw/change_user_name_conflict.c:47:9: error: assignment to\ncast is illegal, lvalue casts are not supported 47 |         (unsigned int)v1 =\nsetuid(a0); |         ^~~~~~~~~~~~~~~~ ~ /tmp/tmp43mqa9jw/change_user_name_conflict.c:50:106:\nerror: indirection requires pointer operand ('int' invalid) 50 |\nfprintf(LOGFILE, \"unable to set user to %d - %s\\n\", (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char **get_mapred_local_dirs(const char *good_local_dirs) {\n    return extract_values(strdup(good_local_dirs));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(extract_values)(long long);\n\nlong long get_mapred_local_dirs_name_conflict(char *a0) { return extract_values(strdup(a0)); }\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *concatenate(char *concat_pattern, char *return_path_name, int numArgs, ...) {\n    va_list ap;\n    __builtin_va_start(ap, numArgs);\n    int strlen_args = 0;\n    char *arg = ((void *)0);\n    int j;\n    for (j = 0; j < numArgs; j++) {\n        arg = __builtin_va_arg(ap, char *);\n        if (arg == ((void *)0)) {\n            fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\", return_path_name);\n            return ((void *)0);\n        }\n        strlen_args += strlen(arg);\n    }\n    __builtin_va_end(ap);\n    char *return_path = ((void *)0);\n    int str_len = strlen(concat_pattern) + strlen_args + 1;\n    return_path = (char *)malloc(str_len);\n    if (return_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", return_path_name);\n        return ((void *)0);\n    }\n    __builtin_va_start(ap, numArgs);\n    vsnprintf(return_path, str_len, concat_pattern, ap);\n    __builtin_va_end(ap);\n    return return_path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vsnprintf)(char *, unsigned long, char *, struct va_list[1]);\n\nextern FILE_t *LOGFILE;\n\nlong long concatenate_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;         // [bp-0x100]\n  unsigned int v1;         // [bp-0xfc]\n  unsigned long long *v2;  // [bp-0xf8], Other Possible Types: unsigned long\n  unsigned long v3;        // [bp-0xf0]\n  char v4;                 // [bp-0xe8]\n  unsigned long v5;        // [bp-0xd0]\n  unsigned long v6;        // [bp-0xc8]\n  unsigned long v7;        // [bp-0xc0]\n  int v8;                  // [bp-0xb8]\n  int v9;                  // [bp-0xa8]\n  int v10;                 // [bp-0x98]\n  int v11;                 // [bp-0x88]\n  int v12;                 // [bp-0x78]\n  int v13;                 // [bp-0x68]\n  int v14;                 // [bp-0x58]\n  int v15;                 // [bp-0x48]\n  unsigned long v16;       // [bp+0x8]\n  unsigned long v18;       // rcx\n  unsigned long v19;       // r8\n  unsigned long v20;       // r9\n  char v21;                // al\n  int v22;                 // xmm0\n  int v23;                 // xmm1\n  int v24;                 // xmm2\n  int v25;                 // xmm3\n  int v26;                 // xmm4\n  int v27;                 // xmm5\n  int v28;                 // xmm6\n  int v29;                 // xmm7\n  void *v30;               // r12, Other Possible Types: unsigned long\n  unsigned long long v31;  // rax\n  unsigned long long *v32; // rdx, Other Possible Types: unsigned long\n  char *v33;               // rbx, Other Possible Types: unsigned long\n  unsigned long v34;       // rbp\n\n  v5 = v18;\n  v6 = v19;\n  v7 = v20;\n  if (v21) {\n    v8 = v22;\n    v9 = v23;\n    v10 = v24;\n    v11 = v25;\n    v12 = v26;\n    v13 = v27;\n    v14 = v28;\n    v15 = v29;\n  }\n  v0 = 24;\n  v1 = 48;\n  v2 = &v16;\n  v3 = &v4;\n  if ((unsigned int)a2 <= 0) {\n    v30 = 0;\n  } else {\n    v30 = 0;\n    do {\n      v31 = v0;\n      if ((unsigned int)v31 > 47) {\n        v32 = v2;\n        v2 = v32 + 1;\n      } else {\n        v32 = &(&v4)[v31];\n        v0 = (unsigned int)v31 + 8;\n      }\n      v33 = *((long long *)v32);\n      if (!v33) {\n        fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\",\n                (unsigned int)a1);\n        return *((long long *)v32);\n      }\n      v30 += strlen(v33);\n    } while ((unsigned int)a2 != 1);\n  }\n  v34 = v30 + strlen(a0) + 1;\n  v33 = malloc(v34);\n  if (v33) {\n    v0 = 24;\n    v1 = 48;\n    v2 = &v16;\n    v3 = &v4;\n    vsnprintf(v33, v34, a0, &v0);\n    return v33;\n  }\n  fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", (unsigned int)a1);\n  return v33;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6otb3m5h/concatenate_name_conflict.c:16:62: error: array has incomplete element type\n'struct va_list' 16 | int (vsnprintf)(char *, unsigned long, char *, struct\nva_list[1]); |                                                              ^\n/tmp/tmp6otb3m5h/concatenate_name_conflict.c:16:55: note: forward declaration of 'struct\nva_list' 16 | int (vsnprintf)(char *, unsigned long, char *, struct va_list[1]);\n      |                                                       ^\n/tmp/tmp6otb3m5h/concatenate_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 18 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_directory(const char *tt_root, const char *user, const char *jobid) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3, tt_root, user, jobid);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, ...);\n\nlong long get_job_directory(unsigned long a0, unsigned long a1,\n                            unsigned long a2) {\n  return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_directory(const char *tt_root, const char *user) {\n    return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2, tt_root, user);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, ...);\n\nlong long get_user_directory_name_conflict(unsigned long a0, unsigned long a1) {\n  return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_work_directory(const char *job_dir) {\n    return concatenate(\"%s/work\", \"job work\", 1, job_dir);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, ...);\n\nlong long get_job_work_directory_name_conflict(unsigned long a0) {\n  return concatenate(\"%s/work\", \"job work\", 1);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_attempt_work_directory(const char *tt_root, const char *user, const char *job_id, const char *attempt_id) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\", \"attempt_dir_path\", 4, tt_root, user, job_id, attempt_id);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, ...);\n\nlong long get_attempt_work_directory(unsigned long a0, unsigned long a1,\n                                     unsigned long a2, unsigned long a3) {\n  unsigned long v0; // [bp-0x18]\n\n  v0 = a3;\n  return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\",\n                     \"attempt_dir_path\", 4);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_task_launcher_file(const char *work_dir) {\n    return concatenate(\"%s/%s\", \"task launcher\", 2, work_dir, \"taskjvm.sh\");\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenate)(long long, long long, long long, ...);\n\nlong long get_task_launcher_file_name_conflict(unsigned long a0) {\n  return concatenate(\"%s/%s\", \"task launcher\", 2);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_log_directory(const char *jobid) {\n    char *log_dir = get_value(\"hadoop.log.dir\");\n    if (log_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n        return ((void *)0);\n    }\n    char *result = concatenate(\"%s/userlogs/%s\", \"job log dir\", 2, log_dir, jobid);\n    if (result == ((void *)0)) {\n        fprintf(LOGFILE, \"failed to get memory in get_job_log_directory for %s and %s\\n\", log_dir, jobid);\n    }\n    free(log_dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_408f17; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_value)(long long);\nlong long(concatenate)(long long, long long, long long, ...);\n\nextern FILE_t *LOGFILE;\n\nlong long get_job_log_directory_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rax\n  void *v2;              // rbx\n  unsigned long long v3; // rbp, Other Possible Types: unsigned long\n\n  v1 = get_value(\"hadoop.log.dir\");\n  v2 = v1;\n  if (!v1) {\n    fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", &g_408f17);\n    return v1;\n  }\n  v3 = concatenate(\"%s/userlogs/%s\", \"job log dir\", 2);\n  if (!v3)\n    fprintf(LOGFILE,\n            \"failed to get memory in get_job_log_directory_name_conflict for %s and %s\\n\",\n            (unsigned int)v2, (unsigned int)a0);\n  free(v2);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp12zki2ns/get_job_log_directory_name_conflict.c:20:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 20 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_subdirectory(const char *tt_root, const char *user, const char *subdir) {\n    char *user_dir = get_user_directory(tt_root, user);\n    char *result = concatenate(\"%s/%s\", \"user subdir\", 2, user_dir, subdir);\n    free(user_dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_user_directory)(long long, long long);\nlong long(concatenate)(long long, long long, long long, ...);\n\nlong long get_user_subdirectory(unsigned long long a0, unsigned long long a1,\n                                unsigned long a2) {\n  free(get_user_directory(a0, a1));\n  return concatenate(\"%s/%s\", \"user subdir\", 2);\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int mkdirs(const char *path, mode_t perm) {\n    char *buffer = strdup(path);\n    char *token;\n    int cwd = open(\"/\", 0);\n    if (cwd == -1) {\n        fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", path, strerror((*__errno_location())));\n        free(buffer);\n        return -1;\n    }\n    for (token = strtok(buffer, \"/\"); token != ((void *)0); token = strtok(((void *)0), \"/\")) {\n        if (mkdirat(cwd, token, perm) != 0) {\n            if ((*__errno_location()) != 17) {\n                fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n                close(cwd);\n                free(buffer);\n                return -1;\n            }\n        }\n        int new_dir = openat(cwd, token, 0);\n        close(cwd);\n        cwd = new_dir;\n        if (cwd == -1) {\n            fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n            free(buffer);\n            return -1;\n        }\n    }\n    free(buffer);\n    close(cwd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nint(open)(char *, int, unsigned short);\nchar *(strtok)(char *, char *);\nchar *(strerror)(int);\nint(close)(int);\n\nextern FILE_t *LOGFILE;\n\nlong long mkdirs_name_conflict(unsigned long a0, unsigned long long a1, unsigned long a2) {\n  void *v1;              // r15\n  unsigned long v2;      // r12\n  unsigned long long v3; // rax\n  unsigned long v4;      // rbx, Other Possible Types: unsigned long long\n  unsigned long v5;      // rbp, Other Possible Types: unsigned long long\n\n  v1 = strdup(a0);\n  v2 = open(\"/\", 0, a2);\n  if ((unsigned int)v2 == -1) {\n    fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", (unsigned int)a0,\n            (unsigned int)strerror(*(__errno_location())));\n    free(v1);\n    return v2;\n  }\n  v4 = strtok(v1, \"/\");\n  if (!v4) {\n    v5 = (unsigned int)v2;\n  } else {\n    while (true) {\n      if (mkdirat(v2, v4, a1)) {\n        a0 = *(__errno_location());\n        if (a0 != 17) {\n          fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\",\n                  (unsigned int)v4, (unsigned int)a0,\n                  (unsigned int)strerror(a0));\n          close(v2);\n          free(v1);\n          return 4294967295;\n        }\n      }\n      (unsigned int)v3 = openat(v2, v4, 0);\n      v5 = v3;\n      close(v2);\n      if ((unsigned int)v3 == -1) {\n        fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", (unsigned int)v4,\n                (unsigned int)a0,\n                (unsigned int)strerror(*(__errno_location())));\n        free(v1);\n        return v3;\n      }\n      v4 = strtok(NULL, \"/\");\n      if (!v4)\n        break;\n      v2 = v5;\n    }\n  }\n  free(v1);\n  close(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2u8nwrt9/mkdirs_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp2u8nwrt9/mkdirs_name_conflict.c:36:96: error: indirection requires pointer operand\n('int' invalid) 36 |         fprintf(LOGFILE, \"Can't open / in %s - %s\\n\",\n(unsigned int)a0, (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp2u8nwrt9/mkdirs_name_conflict.c:51:22: error: indirection\nrequires pointer operand ('int' invalid) 51 |                 a0 =\n*(__errno_location()); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2u8nwrt9/mkdirs_name_conflict.c:60:13: error: assignment to cast is illegal, lvalue\ncasts are not supported 60 |             (unsigned int)v3 = openat(v2, v4, 0);\n      |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp2u8nwrt9/mkdirs_name_conflict.c:65:123: error: indirection requires pointer operand\n('int' invalid) 65 |                 fprintf(LOGFILE, \"Can't open %s in %s -\n%s\\n\", (unsigned int)v4, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static short get_current_local_dir_count(char **local_dir) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        ++count;\n    }\n    return count;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_nth_local_dir(char **local_dir, int nth) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        if (count == nth) {\n            return strdup(*local_dir_ptr);\n        }\n        ++count;\n    }\n    fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\", nth, count);\n    return ((void *)0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_random_local_dir(char **local_dir) {\n    struct timeval tv;\n    short nth;\n    gettimeofday(&tv, ((void *)0));\n    srand((long)tv.tv_sec * 1000000 + tv.tv_usec);\n    short cnt = get_current_local_dir_count(local_dir);\n    if (cnt == 0) {\n        fprintf(LOGFILE, \"No valid local directories\\n\");\n        return ((void *)0);\n    }\n    nth = rand() % cnt;\n    return get_nth_local_dir(local_dir, nth);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_attempt_directories(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id) {\n    const mode_t perms = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    if (job_id == ((void *)0) || task_id == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either task_id is null or the user passed is null.\\n\");\n        return -1;\n    }\n    int result = 0;\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could not be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *task_dir = get_attempt_work_directory(*local_dir_ptr, user, job_id, task_id);\n        if (task_dir == ((void *)0)) {\n            free_values(local_dir);\n            return -1;\n        }\n        if (mkdirs(task_dir, perms) != 0) {\n            free(task_dir);\n        } else {\n            free(task_dir);\n        }\n    }\n    char *job_task_name = malloc(strlen(job_id) + strlen(task_id) + 2);\n    char *real_task_dir = ((void *)0);\n    char *real_job_dir = ((void *)0);\n    char *random_local_dir = ((void *)0);\n    char *link_task_log_dir = ((void *)0);\n    if (job_task_name == ((void *)0)) {\n        fprintf(LOGFILE, \"Malloc of job task name failed\\n\");\n        result = -1;\n    } else {\n        sprintf(job_task_name, \"%s/%s\", job_id, task_id);\n        link_task_log_dir = get_job_log_directory(job_task_name);\n        random_local_dir = get_random_local_dir(local_dir);\n        if (random_local_dir == ((void *)0)) {\n            result = -1;\n            goto cleanup;\n        }\n        real_job_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + 3);\n        if (real_job_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real job directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        real_task_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + strlen(task_id) + 4);\n        if (real_task_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real task directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_job_dir, \"%s/userlogs/%s\", random_local_dir, job_id);\n        result = create_directory_for_user(real_job_dir);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_task_dir, \"%s/userlogs/%s/%s\", random_local_dir, job_id, task_id);\n        result = mkdirs(real_task_dir, perms);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        result = symlink(real_task_dir, link_task_log_dir);\n        if (result != 0) {\n            fprintf(LOGFILE, \"Failed to create symlink %s to %s - %s\\n\", link_task_log_dir, real_task_dir, strerror((*__errno_location())));\n            result = -1;\n        }\n    }\n  cleanup:\n    free(random_local_dir);\n    free(job_task_name);\n    free(link_task_log_dir);\n    free(real_job_dir);\n    free(real_task_dir);\n    free_values(local_dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_mapred_local_dirs)(long long);\nlong long(get_attempt_work_directory)(long long, long long, long long,\n                                      long long);\nlong long(free_values)(long long);\nlong long(mkdirs)(long long, long long, long long);\nlong long(get_job_log_directory)(long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nvoid(srand)(unsigned int);\nint(rand)();\nchar *(strdup)(char *);\nlong long(create_directory_for_user)(long long);\nint(symlink)(char *, char *);\nchar *(strerror)(int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern FILE_t *LOGFILE;\n\nlong long create_attempt_directories(unsigned long a0, unsigned long long a1,\n                                     char *a2, char *a3) {\n  unsigned int v0;         // [bp-0x60], Other Possible Types: unsigned long\n  void *v1;                // [bp-0x58], Other Possible Types: unsigned long\n  char *v2;                // [bp-0x50], Other Possible Types: unsigned long\n  timeval v3;              // [bp-0x48]\n  char v4;                 // [bp-0x40]\n  char *v7;                // rbx\n  char *v8;                // rbp\n  unsigned long long *v9;  // rax\n  unsigned long long *v10; // r12\n  void *v11;               // r13\n  unsigned long v12;       // rdi, Other Possible Types: unsigned long long\n  unsigned long long *v13; // r14, Other Possible Types: unsigned long\n  char *v14;               // rax\n  void *v16;               // r13, Other Possible Types: unsigned long\n  void *v17;               // r15, Other Possible Types: unsigned long\n  unsigned long long *v18; // rax, Other Possible Types: unsigned long\n  void *v19;               // rdx, Other Possible Types: unsigned long\n  unsigned long long v20;  // r13\n  unsigned long long v21;  // rax\n  unsigned int v22;        // edx\n  char *v23;               // rdi, Other Possible Types: unsigned long\n  unsigned long v24;       // ecx, Other Possible Types: unsigned int\n  unsigned long long *v25; // rsi, Other Possible Types: unsigned long\n  char *v26;               // rax\n  unsigned int v27;        // edx\n\n  v7 = a2;\n  if (a3 && a0) {\n    v8 = a3;\n    if (a2) {\n      v9 = get_mapred_local_dirs(a1);\n      v10 = v9;\n      if (!v9) {\n        fwrite(\"Good mapred local directories could not be obtained.\\n\", 1, 53,\n               LOGFILE);\n        v0 = 5;\n        return v0;\n      }\n      v12 = *(v9);\n      v13 = v9;\n      if (v12) {\n        do {\n          v11 = get_attempt_work_directory(v12, a0, a2, a3);\n          if (!v11) {\n            free_values(v10);\n            v0 = -1;\n            return v0;\n          }\n          if ((int)mkdirs(v11, 488, a2))\n            free(v11);\n          else\n            free(v11);\n          v13 += 8;\n          v12 = *(v13);\n        } while (v12);\n      }\n      v14 = malloc(strlen(a2) + strlen(a3) + 2);\n      if (!v14) {\n        fwrite(\"Malloc of job task name failed\\n\", 1, 31, LOGFILE);\n        v2 = v14;\n        v16 = v14;\n        v1 = v14;\n        v17 = v14;\n        v0 = -1;\n      LABEL_405cd9:\n        free(v16);\n        free(v14);\n        free(v2);\n        free(v1);\n        free(v17);\n        free_values(v10);\n        return v0;\n      }\n      sprintf(v14, \"%s/%s\", (unsigned int)a2, (unsigned int)a3);\n      v2 = get_job_log_directory(v14);\n      gettimeofday(&v3, NULL);\n      srand(v3.tv_sec * 1000000 + *((int *)&v4));\n      if (!*(v10)) {\n        fwrite(\"No valid local directories\\n\", 1, 27, LOGFILE);\n        v1 = 0;\n        v0 = -1;\n        goto LABEL_405cd9;\n      }\n      v18 = v10;\n      v19 = 0;\n      do {\n        v20 = v19 + 1;\n        v19 = v20;\n        v18 += 8;\n      } while (*((long long *)v18));\n      if (!(unsigned short)v20)\n        fwrite(\"No valid local directories\\n\", 1, 27, LOGFILE);\n      (unsigned int)v21 = rand();\n      v22 = ((unsigned int)v21 >> 31 CONCAT(unsigned int) v21) / m(unsigned int)\n                                                                     v20 >>\n            32;\n      v23 = *(v10);\n      if (!v23) {\n        v24 = 0;\n      } else if (v22) {\n        v25 = v10;\n        v24 = 0;\n        while (true) {\n          v24 += 1;\n          v25 += 8;\n          v23 = *((long long *)v25);\n          if (!v23)\n            break;\n          if (v22 == (unsigned int)v24)\n            strdup(v23);\n        }\n      } else {\n        v26 = strdup(v23);\n        v16 = v26;\n        if (!v26) {\n          v1 = v26;\n          v0 = -1;\n        LABEL_405cd9:\n          free(v26);\n        }\n        v1 = malloc(strlen(v26) + strlen(v7) + 11);\n        if (!v1) {\n          fwrite(\"Malloc of real job directory failed\\n\", 1, 36, LOGFILE);\n          v0 = -1;\n        LABEL_405cd9:\n          free(v26);\n        }\n        v0 = strlen(v26);\n        v17 = malloc(v0 + strlen(v7) + 12 + strlen(v8));\n        if (!v17) {\n          fwrite(\"Malloc of real task directory failed\\n\", 1, 37, LOGFILE);\n          v0 = -1;\n        LABEL_405cd9:\n          free(v16);\n        }\n        sprintf(v1, \"%s/userlogs/%s\", (unsigned int)v16, (unsigned int)v7);\n        v0 = -1;\n        if (!(int)create_directory_for_user(v1)) {\n          v27 = v16;\n          sprintf(v17, \"%s/userlogs/%s/%s\", v27, (unsigned int)v7,\n                  (unsigned int)v8);\n          v0 = -1;\n          if (!(int)mkdirs(v17, 488, *((unsigned long long *)&v27))) {\n            v0 = symlink(v17, v2);\n            if (v0) {\n              fprintf(LOGFILE, \"Failed to create symlink %s to %s - %s\\n\",\n                      (unsigned int)v2, (unsigned int)v17,\n                      (unsigned int)strerror(*(__errno_location())));\n              v0 = -1;\n            LABEL_405cd9:\n              free(v16);\n            }\n          }\n        }\n        goto LABEL_405cd9;\n      }\n      fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\", v22,\n              (unsigned int)v24);\n      v1 = 0;\n      v0 = -1;\n    LABEL_405cd9:\n      free(NULL);\n    }\n  }\n  fwrite(\"Either task_id is null or the user passed is null.\\n\", 1, 51,\n         LOGFILE);\n  v0 = -1;\n  return v0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2__pm9zv/create_attempt_directories.c:41:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 41 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:145:13: error: assignment to cast\nis illegal, lvalue casts are not supported 145 |             (unsigned int)v21 =\nrand(); |             ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmp2__pm9zv/create_attempt_directories.c:146:44: error: expected ')'\n  146 |             v22 = ((unsigned int)v21 >> 31 CONCAT (unsigned int)v21) /m\n(unsigned int)v20 >> 32; |                                            ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:146:19: note: to match this '('\n  146 |             v22 = ((unsigned int)v21 >> 31 CONCAT (unsigned int)v21) /m\n(unsigned int)v20 >> 32; |                   ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:146:74: error: expected expression\n  146 |             v22 = ((unsigned int)v21 >> 31 CONCAT (unsigned int)v21) /m\n(unsigned int)v20 >> 32; | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:175:1: error: redefinition of\nlabel 'LABEL_405cd9' 175 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:115:1: note: previous definition\nis here 115 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:183:1: error: redefinition of\nlabel 'LABEL_405cd9' 183 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:115:1: note: previous definition\nis here 115 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:192:1: error: redefinition of\nlabel 'LABEL_405cd9' 192 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:115:1: note: previous definition\nis here 115 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:207:150: error: indirection\nrequires pointer operand ('int' invalid) 207 | fprintf(LOGFILE, \"Failed to\ncreate symlink %s to %s - %s\\n\", (unsigned int)v2, (unsigned int)v17, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2__pm9zv/create_attempt_directories.c:209:1: error: redefinition of\nlabel 'LABEL_405cd9' 209 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:115:1: note: previous definition\nis here 115 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:219:1: error: redefinition of\nlabel 'LABEL_405cd9' 219 | LABEL_405cd9: | ^\n/tmp/tmp2__pm9zv/create_attempt_directories.c:115:1: note: previous definition\nis here 115 | LABEL_405cd9: | ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int set_user(const char *user) {\n    if (user_detail != ((void *)0)) {\n        free(user_detail);\n        user_detail = ((void *)0);\n    }\n    user_detail = check_user(user);\n    if (user_detail == ((void *)0)) {\n        return -1;\n    }\n    return change_effective_user(user_detail->pw_uid, user_detail->pw_gid);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(check_user)(long long);\nlong long(change_effective_user)(long long, long long);\n\nextern struct_0 *user_detail;\n\nlong long set_user_name_conflict(unsigned long long a0) {\n  if (user_detail) {\n    free(user_detail);\n    user_detail = 0;\n  }\n  user_detail = check_user(a0);\n  if (user_detail)\n    return change_effective_user(user_detail->field_10, user_detail->field_14);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnypv9woy/set_user_name_conflict.c:26:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 26 | extern struct_0 *user_detail; |        ^~~~~~~~ | struct\n/tmp/tmpnypv9woy/set_user_name_conflict.c:26:8: error: declaration of anonymous struct must be\na definition /tmp/tmpnypv9woy/set_user_name_conflict.c:37:51: error: member reference type\n'int' is not a pointer 37 |         return\nchange_effective_user(user_detail->field_10, user_detail->field_14); |\n~~~~~~~~~~~  ^ /tmp/tmpnypv9woy/set_user_name_conflict.c:37:74: error: member reference type\n'int' is not a pointer 37 |         return\nchange_effective_user(user_detail->field_10, user_detail->field_14); |\n~~~~~~~~~~~  ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_owner(const char *path, uid_t user, gid_t group) {\n    if (geteuid() == user && getegid() == group) {\n        return 0;\n    } else {\n        uid_t old_user = geteuid();\n        gid_t old_group = getegid();\n        if (change_effective_user(0, group) != 0) {\n            return -1;\n        }\n        if (chown(path, user, group) != 0) {\n            fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", path, user, group, strerror((*__errno_location())));\n            return -1;\n        }\n        return change_effective_user(old_user, old_group);\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_directory_for_user(const char *path) {\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3) | 1024;\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    int ret = 0;\n    uid_t root = 0;\n    if (getuid() == root) {\n        ret = change_effective_user(root, tt_gid);\n    }\n    if (ret == 0) {\n        if (mkdir(path, permissions) == 0 || (*__errno_location()) == 17) {\n            if (chmod(path, permissions) != 0) {\n                fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\", path, strerror((*__errno_location())));\n                ret = -1;\n            } else if (change_owner(path, user, tt_gid) != 0) {\n                ret = -1;\n            }\n        } else {\n            fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user, group) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nunsigned int(getegid)();\nunsigned int(getuid)();\nlong long(change_effective_user)(long long, long long);\nint(chmod)(char *, unsigned short);\nchar *(strerror)(int);\nint(chown)(char *, unsigned int, unsigned int);\n\nextern FILE_t *LOGFILE;\nextern unsigned int tt_gid;\n\nlong long create_directory_for_user_name_conflict(unsigned long a0) {\n  unsigned long v0;       // [bp-0x30]\n  unsigned long v1;       // [bp-0x20]\n  unsigned long v2;       // [bp-0x18]\n  unsigned long v3;       // [bp-0x10]\n  unsigned long v4;       // [bp-0x8]\n  unsigned long v6;       // r15\n  unsigned long v7;       // r14\n  unsigned long v8;       // r13\n  unsigned long v9;       // r12\n  unsigned long v10;      // rbx\n  unsigned long long v11; // r12\n  unsigned long long v13; // rbx, Other Possible Types: unsigned long\n\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  v1 = v9;\n  v0 = v10;\n  v11 = geteuid();\n  if (getuid() || (v13 = change_effective_user(0, (unsigned long long)tt_gid),\n                   !(unsigned int)v13)) {\n    if (!mkdir(a0, 1512) || (a0 = *(__errno_location()), a0 == 17)) {\n      v13 = chmod(a0, 1512);\n      if ((unsigned int)v13) {\n        fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\",\n                (unsigned int)a0,\n                (unsigned int)strerror(*(__errno_location())));\n        v13 = 4294967295;\n      } else if ((unsigned int)v11 != geteuid() || tt_gid != getegid()) {\n        if (!(int)change_effective_user(0, tt_gid)) {\n          if (chown(a0, v11, tt_gid))\n            fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", (unsigned int)a0,\n                    (unsigned int)v11, tt_gid,\n                    (unsigned int)strerror(*(__errno_location())));\n          else\n            v13 = -(0 < (int)change_effective_user(geteuid(), getegid()));\n        }\n        v13 = 4294967295;\n      }\n    } else {\n      fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", (unsigned int)a0,\n              (unsigned int)strerror(a0));\n      v13 = 4294967295;\n    }\n  }\n  if ((int)change_effective_user(v11, getegid()))\n    v13 = 4294967295;\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4162r3vk/create_directory_for_user_name_conflict.c:24:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 24 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp4162r3vk/create_directory_for_user_name_conflict.c:50:39: error: indirection requires\npointer operand ('int' invalid) 50 |         if (!mkdir(a0, 1512) || (a0 =\n*(__errno_location()), a0 == 17)) | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4162r3vk/create_directory_for_user_name_conflict.c:55:122: error: indirection requires\npointer operand ('int' invalid) 55 |                 fprintf(LOGFILE, \"Can't\nchmod %s to add the sticky bit - %s\\n\", (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4162r3vk/create_directory_for_user_name_conflict.c:63:144: error: indirection requires\npointer operand ('int' invalid) 63 |                         fprintf(LOGFILE,\n\"Can't chown %s to %d:%d - %s\\n\", (unsigned int)a0, (unsigned int)v11, tt_gid,\n(unsigned int)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int open_file_as_task_tracker(const char *filename) {\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    if (change_effective_user(tt_uid, tt_gid) != 0) {\n        return -1;\n    }\n    int result = open(filename, 0);\n    if (result == -1) {\n        fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\", filename, strerror((*__errno_location())));\n    }\n    if (change_effective_user(user, group)) {\n        result = -1;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(geteuid)();\nunsigned int(getegid)();\nlong long(change_effective_user)(long long, long long);\nint(open)(char *, int, unsigned short);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern unsigned int tt_gid;\nextern unsigned int tt_uid;\n\nlong long open_file_as_task_tracker(char *a0, unsigned long a1,\n                                    unsigned long a2) {\n  unsigned long v3; // rbx\n\n  if ((int)change_effective_user(tt_uid, tt_gid))\n    return 4294967295;\n  v3 = open(a0, 0, a2);\n  if ((unsigned int)v3 == -1)\n    fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\",\n            (unsigned int)a0, (unsigned int)strerror(*(__errno_location())));\n  if (!(int)change_effective_user(geteuid(), getegid()))\n    return v3;\n  return 4294967295;\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdqg1a3ii/open_file_as_task_tracker.c:22:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpdqg1a3ii/open_file_as_task_tracker.c:34:112: error: indirection requires\npointer operand ('int' invalid) 34 |         fprintf(LOGFILE, \"Can't open file\n%s as task tracker - %s\\n\", (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int copy_file(int input, const char *in_filename, const char *out_filename, mode_t perm) {\n    const int buffer_size = 128 * 1024;\n    char buffer[buffer_size];\n    int out_fd = open(out_filename, 1 | 64 | 128 | 131072, perm);\n    if (out_fd == -1) {\n        fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    ssize_t len = read(input, buffer, buffer_size);\n    while (len > 0)\n        {\n            ssize_t pos = 0;\n            while (pos < len)\n                {\n                    ssize_t write_result = write(out_fd, buffer + pos, len - pos);\n                    if (write_result <= 0) {\n                        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", out_filename, strerror((*__errno_location())));\n                        close(out_fd);\n                        return -1;\n                    }\n                    pos += write_result;\n                }\n            len = read(input, buffer, buffer_size);\n        }\n    if (len < 0) {\n        fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", in_filename, strerror((*__errno_location())));\n        close(out_fd);\n        return -1;\n    }\n    if (close(out_fd) != 0) {\n        fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    close(input);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nlong(read)(int, void *, unsigned long);\nchar *(strerror)(int);\nint(close)(int);\nlong(write)(int, void *, unsigned long);\n\nextern FILE_t *LOGFILE;\n\nlong long copy_file(unsigned long a0, unsigned long a1, char *a2,\n                    unsigned long a3) {\n  char v0;               // [bp-0x20048]\n  unsigned long v2;      // r13, Other Possible Types: unsigned long long\n  unsigned long v3;      // r12, Other Possible Types: unsigned long long\n  void *v4;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v5; // rax\n\n  v2 = open(a2, 131265, a3);\n  if ((unsigned int)v2 == -1) {\n    fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", (unsigned int)a2,\n            (unsigned int)strerror(*(__errno_location())));\n    return v2;\n  }\n  v3 = read(a0, &v0, 0x20000);\n  if (v3 > 0) {\n    do {\n      v4 = 0;\n      if (v3 > 0) {\n        do {\n          v5 = write(v2, &(&v0)[v4], v3 - v4);\n          if (v5 <= 0) {\n            fprintf(LOGFILE, \"Error writing to %s - %s\\n\", (unsigned int)a2,\n                    (unsigned int)strerror(*(__errno_location())));\n            close(v2);\n            return 4294967295;\n          }\n        } while ((v3 = read((unsigned int)a0, &v0, 0x20000), v3 > 0));\n      }\n    } while ((v3 = read((unsigned int)a0, &v0, 0x20000), v3 > 0));\n  }\n  if (v3 < 0) {\n    fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", (unsigned int)a1,\n            (unsigned int)strerror(*(__errno_location())));\n    close(v2);\n    return 4294967295;\n  }\n  v2 = close(v2);\n  if (!(unsigned int)v2) {\n    close(a0);\n    return v2;\n  }\n  fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", (unsigned int)a2,\n          (unsigned int)strerror(*(__errno_location())));\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqbb1opfn/copy_file.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqbb1opfn/copy_file.c:35:102: error: indirection requires pointer operand\n('int' invalid) 35 |         fprintf(LOGFILE, \"Can't open %s for output - %s\\n\",\n(unsigned int)a2, (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpqbb1opfn/copy_file.c:48:42: error: array subscript\nis not an integer 48 |                     v5 = write(v2, &(&v0)[v4], v3 - v4);\n      |                                          ^~~\n/tmp/tmpqbb1opfn/copy_file.c:48:51: error: invalid operands to binary expression\n('unsigned long' and 'void *') 48 |                     v5 = write(v2,\n&(&v0)[v4], v3 - v4); |                                                ~~ ^ ~~\n/tmp/tmpqbb1opfn/copy_file.c:51:113: error: indirection requires pointer operand\n('int' invalid) 51 |                         fprintf(LOGFILE, \"Error writing to\n%s - %s\\n\", (unsigned int)a2, (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpqbb1opfn/copy_file.c:61:100: error: indirection\nrequires pointer operand ('int' invalid) 61 |         fprintf(LOGFILE, \"Failed\nto read file %s - %s\\n\", (unsigned int)a1, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqbb1opfn/copy_file.c:71:97: error: indirection requires pointer operand\n('int' invalid) 71 |     fprintf(LOGFILE, \"Failed to close file %s - %s\\n\",\n(unsigned int)a2, (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_user(const char *user, const char *good_local_dirs) {\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char *user_dir;\n    char **local_dir_ptr = local_dir;\n    int failed = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != 0; ++local_dir_ptr) {\n        user_dir = get_user_directory(*local_dir_ptr, user);\n        if (user_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\", user);\n            failed = 1;\n            break;\n        }\n        if (create_directory_for_user(user_dir) != 0) {\n            failed = 1;\n        }\n        free(user_dir);\n    }\n    free_values(local_dir);\n    return failed ? INITIALIZE_USER_FAILED : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_mapred_local_dirs)(long long);\nlong long(free_values)(long long);\nlong long(get_user_directory)(long long, long long);\nlong long(create_directory_for_user)(long long);\n\nextern FILE_t *LOGFILE;\n\nlong long initialize_user_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned long long v1;  // r13\n  unsigned long long *v2; // rax\n  unsigned long long *v3; // r15\n  void *v4;               // rbx\n  unsigned long v5;       // rdi, Other Possible Types: unsigned long long\n  unsigned long long *v6; // rbp, Other Possible Types: unsigned long\n  unsigned long v7;       // r12, Other Possible Types: unsigned long long\n\n  v1 = a0;\n  v2 = get_mapred_local_dirs(a1);\n  if (!v2) {\n    fwrite(\"Good mapred local directories could ot be obtained.\\n\", 1, 52,\n           LOGFILE);\n    return 5;\n  }\n  v3 = v2;\n  v5 = *(v2);\n  v6 = v2;\n  v7 = 0;\n  if (!v5) {\n    free_values(v2);\n    return 0;\n  }\n  do {\n    v4 = get_user_directory(v5, v1);\n    if (!v4) {\n      fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\",\n              (unsigned int)v1);\n      free_values(v3);\n      return 20;\n    }\n    if ((int)create_directory_for_user(v4))\n      v7 = 1;\n    free(v4);\n    v6 += 8;\n    v5 = *(v6);\n  } while (v5);\n  free_values(v3);\n  if ((unsigned int)v7)\n    return 20;\n  return v7;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpeyi1pjux/initialize_user_name_conflict.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_job(const char *user, const char *good_local_dirs, const char *jobid, const char *credentials, const char *job_xml, char *const *args) {\n    if (jobid == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either jobid is null or the user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    int result = initialize_user(user, good_local_dirs);\n    if (result != 0) {\n        return result;\n    }\n    char *job_log_dir = get_job_log_directory(jobid);\n    if (job_log_dir == ((void *)0)) {\n        return -1;\n    }\n    result = create_directory_for_user(job_log_dir);\n    free(job_log_dir);\n    if (result != 0) {\n        return -1;\n    }\n    int cred_file = open_file_as_task_tracker(credentials);\n    if (cred_file == -1) {\n        return -1;\n    }\n    int job_file = open_file_as_task_tracker(job_xml);\n    if (job_file == -1) {\n        return -1;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    if (tt_roots == ((void *)0)) {\n        return INVALID_TT_ROOT;\n    }\n    char **tt_root;\n    char *primary_job_dir = ((void *)0);\n    for (tt_root = tt_roots; *tt_root != ((void *)0); ++tt_root) {\n        char *job_dir = get_job_directory(*tt_root, user, jobid);\n        if (job_dir == ((void *)0)) {\n        } else if (mkdirs(job_dir, permissions) != 0) {\n            free(job_dir);\n        } else if (primary_job_dir == ((void *)0)) {\n            primary_job_dir = job_dir;\n        } else {\n            free(job_dir);\n        }\n    }\n    free_values(tt_roots);\n    if (primary_job_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Did not create any job directories\\n\");\n        return -1;\n    }\n    char *cred_file_name = concatenate(\"%s/%s\", \"cred file\", 2, primary_job_dir, \"jobToken\");\n    if (cred_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(cred_file, credentials, cred_file_name, 256 | 128) != 0) {\n        return -1;\n    }\n    char *job_file_name = concatenate(\"%s/%s\", \"job file\", 2, primary_job_dir, \"job.xml\");\n    if (job_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(job_file, job_xml, job_file_name, 256 | 128 | (256 >> 3)) != 0) {\n        return -1;\n    }\n    fclose(stdin);\n    fflush(LOGFILE);\n    if (LOGFILE != stdout) {\n        fclose(stdout);\n    }\n    fclose(stderr);\n    chdir(primary_job_dir);\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec job initialization process - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(initialize_user)(long long, long long);\nlong long(get_job_log_directory)(long long);\nlong long(create_directory_for_user)(long long);\nlong long(open_file_as_task_tracker)(long long, long long, long long);\nlong long(change_user)(long long, long long);\nlong long(get_mapred_local_dirs)(long long);\nlong long(free_values)(long long);\nlong long(get_job_directory)(long long, long long, long long);\nlong long(mkdirs)(long long, long long, long long);\nlong long(concatenate)(long long, long long, long long, ...);\nlong long(copy_file)(long long, long long, long long, long long);\nint(chdir)(char *);\nint(execvp)(char *, char *[0]);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern FILE_t *__TMC_END__;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern FILE_t *stdin @GLIBC_2.2.5;\nextern struct_0 *user_detail;\n\nlong long initialize_job(unsigned long long a0, unsigned long long a1,\n                         unsigned long long a2, unsigned long long a3,\n                         unsigned long long a4, char **a5) {\n  unsigned int v0;        // [bp-0x44]\n  unsigned long long *v1; // [bp-0x40]\n  unsigned long v4;       // r14, Other Possible Types: unsigned long long\n  void *v5;               // rbp\n  unsigned long long *v7; // rax\n  unsigned long long *v8; // rbp, Other Possible Types: unsigned long\n  unsigned long v9;       // rdi, Other Possible Types: unsigned long long\n  void *v10;              // r15, Other Possible Types: unsigned long\n  void *v11;              // rbx\n  unsigned long long v12; // rax\n  unsigned long long v13; // rax\n\n  if (a2 && a0) {\n    v4 = initialize_user(a0, a1);\n    if ((unsigned int)v4)\n      return v4;\n    v5 = get_job_log_directory(a2);\n    if (!v5)\n      return 4294967295;\n    free(v5);\n    if ((int)create_directory_for_user(v5))\n      return 4294967295;\n    v4 = open_file_as_task_tracker(a3, a1, a2);\n    if ((unsigned int)v4 == -1)\n      return v4;\n    v0 = open_file_as_task_tracker(a4, a1, a2);\n    if (v0 == -1) {\n      return v0;\n    } else if (!(int)change_user(user_detail->field_10,\n                                 user_detail->field_14)) {\n      v7 = get_mapred_local_dirs(a1);\n      v8 = v7;\n      v1 = v7;\n      if (!v7)\n        return 5;\n      v9 = *(v7);\n      if (!v9) {\n        free_values(v1);\n      } else {\n        v10 = 0;\n        do {\n          v11 = get_job_directory(v9, a0, a2);\n          if (v11) {\n            if ((int)mkdirs(v11, 488, a2)) {\n              free(v11);\n            } else if (!v10) {\n              v10 = v11;\n            } else {\n              free(v11);\n            }\n          }\n        } while ((v8 += 8, v9 = *(v8), v9));\n        free_values(v1);\n        if (v10) {\n          v12 = concatenate(\"%s/%s\", \"cred file\", 2);\n          if (!v12) {\n            return 4294967295;\n          } else if (!(int)copy_file(v4, a3, v12, 384)) {\n            v13 = concatenate(\"%s/%s\", \"job file\", 2);\n            if (!v13) {\n              return 4294967295;\n            } else if ((int)copy_file(v0, a4, v13, 416)) {\n              return 4294967295;\n            } else {\n              fclose(stdin @GLIBC_2.2.5);\n              fflush(LOGFILE);\n              if (LOGFILE != __TMC_END__)\n                fclose(__TMC_END__);\n              fclose(stderr @GLIBC_2.2.5);\n              chdir(v10);\n              execvp(*(a5), a5);\n              fprintf(LOGFILE,\n                      \"Failure to exec job initialization process - %s\\n\",\n                      (unsigned int)strerror(*(__errno_location())));\n              return 4294967295;\n            }\n          } else {\n            return 4294967295;\n          }\n        }\n      }\n      fwrite(\"Did not create any job directories\\n\", 1, 35, LOGFILE);\n      return 4294967295;\n    } else {\n      return 4294967295;\n    }\n  }\n  fwrite(\"Either jobid is null or the user passed is null.\\n\", 1, 49, LOGFILE);\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdg8881im/initialize_job.c:33:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 33 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdg8881im/initialize_job.c:34:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 34 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdg8881im/initialize_job.c:35:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 35 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdg8881im/initialize_job.c:35:22: error: expected ';' after top level\ndeclarator 35 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpdg8881im/initialize_job.c:36:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 36 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpdg8881im/initialize_job.c:36:21: error: expected ';' after top level\ndeclarator 36 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmpdg8881im/initialize_job.c:37:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 37 | extern struct_0 *user_detail; |        ^~~~~~~~ | struct\n/tmp/tmpdg8881im/initialize_job.c:37:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpdg8881im/initialize_job.c:72:49: error: member\nreference type 'int' is not a pointer 72 |         else if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmpdg8881im/initialize_job.c:72:72: error: member reference type 'int' is\nnot a pointer 72 |         else if (!(int)change_user(user_detail->field_10,\nuser_detail->field_14)) | ~~~~~~~~~~~  ^\n/tmp/tmpdg8881im/initialize_job.c:127:41: error: expected ')'\n  127 |                             fclose(stdin@GLIBC_2.2.5);\n      |                                         ^\n/tmp/tmpdg8881im/initialize_job.c:127:35: note: to match this '('\n  127 |                             fclose(stdin@GLIBC_2.2.5);\n      |                                   ^\n/tmp/tmpdg8881im/initialize_job.c:131:42: error: expected ')'\n  131 |                             fclose(stderr@GLIBC_2.2.5);\n      |                                          ^\n/tmp/tmpdg8881im/initialize_job.c:131:35: note: to match this '('\n  131 |                             fclose(stderr@GLIBC_2.2.5);\n      |                                   ^\n/tmp/tmpdg8881im/initialize_job.c:134:122: error: indirection requires pointer\noperand ('int' invalid) 134 |                             fprintf(LOGFILE,\n\"Failure to exec job initialization process - %s\\n\", (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_task_as_user(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id, const char *work_dir, const char *script_name) {\n    int exit_code = -1;\n    char *task_script_path = ((void *)0);\n    if (create_attempt_directories(user, good_local_dirs, job_id, task_id) != 0) {\n        goto cleanup;\n    }\n    int task_file_source = open_file_as_task_tracker(script_name);\n    if (task_file_source == -1) {\n        goto cleanup;\n    }\n    task_script_path = get_task_launcher_file(work_dir);\n    if (task_script_path == ((void *)0)) {\n        exit_code = OUT_OF_MEMORY;\n        goto cleanup;\n    }\n    if (copy_file(task_file_source, script_name, task_script_path, (256 | 128 | 64)) != 0) {\n        goto cleanup;\n    }\n    fcloseall();\n    umask(23);\n    if (chdir(work_dir) != 0) {\n        fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", work_dir, strerror((*__errno_location())));\n        goto cleanup;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        exit_code = SETUID_OPER_FAILED;\n        goto cleanup;\n    }\n    if (execlp(task_script_path, task_script_path, ((void *)0)) != 0) {\n        fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\", task_script_path, strerror((*__errno_location())));\n        exit_code = UNABLE_TO_EXECUTE_TASK_SCRIPT;\n        goto cleanup;\n    }\n    exit_code = 0;\n  cleanup:\n    free(task_script_path);\n    return exit_code;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(create_attempt_directories)(long long, long long, long long,\n                                      long long);\nlong long(open_file_as_task_tracker)(long long, long long, long long);\nlong long(get_task_launcher_file)(long long);\nlong long(copy_file)(long long, long long, long long, long long);\nint(fcloseall)();\nunsigned short(umask)(unsigned short);\nint(chdir)(char *);\nlong long(change_user)(long long, long long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern struct_0 *user_detail;\n\nlong long run_task_as_user(unsigned long long a0, unsigned long long a1,\n                           unsigned long long a2, unsigned long long a3,\n                           char *a4, unsigned long long a5) {\n  void *v1;         // rbp, Other Possible Types: unsigned long\n  unsigned long v2; // rbx, Other Possible Types: unsigned long long\n\n  if ((int)create_attempt_directories(a0, a1, a2, a3)) {\n    v1 = 0;\n    v2 = 4294967295;\n  } else {\n    v2 = open_file_as_task_tracker(a5, a1, a2);\n    if ((unsigned int)v2 == -1) {\n      v1 = 0;\n    } else {\n      v1 = get_task_launcher_file(a4);\n      if (!v1) {\n        v2 = 18;\n      } else if ((int)copy_file(v2, a5, v1, 448)) {\n        v2 = 4294967295;\n      } else {\n        fcloseall();\n        umask(23);\n        if (chdir(a4)) {\n          fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\",\n                  (unsigned int)a4,\n                  (unsigned int)strerror(*(__errno_location())));\n          v2 = 4294967295;\n        } else {\n          v2 = 6;\n          if (!(int)change_user(user_detail->field_10, user_detail->field_14)) {\n            v2 = execlp(v1, v1);\n            if ((unsigned int)v2) {\n              fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\",\n                      (unsigned int)v1,\n                      (unsigned int)strerror(*(__errno_location())));\n              v2 = 7;\n            }\n          }\n        }\n      }\n    }\n  }\n  free(v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0ugp6t2x/run_task_as_user.c:28:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 28 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp0ugp6t2x/run_task_as_user.c:29:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 29 | extern struct_0 *user_detail; |        ^~~~~~~~ |\nstruct /tmp/tmp0ugp6t2x/run_task_as_user.c:29:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmp0ugp6t2x/run_task_as_user.c:65:117: error:\nindirection requires pointer operand ('int' invalid) 65 | fprintf(LOGFILE,\n\"Can't change directory to %s -%s\\n\", (unsigned int)a4, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0ugp6t2x/run_task_as_user.c:71:56: error: member reference type 'int' is\nnot a pointer 71 |                     if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmp0ugp6t2x/run_task_as_user.c:71:79: error: member reference type 'int'\nis not a pointer 71 |                     if\n(!(int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~\n^ /tmp/tmp0ugp6t2x/run_task_as_user.c:76:133: error: indirection requires\npointer operand ('int' invalid) 76 | fprintf(LOGFILE, \"Couldn't execute the task\njvm file %s - %s\", (unsigned int)v1, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 7 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int signal_user_task(const char *user, int pid, int sig) {\n    if (pid <= 0) {\n        return INVALID_TASK_PID;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return SETUID_OPER_FAILED;\n    }\n    int has_group = 1;\n    if (kill(-pid, 0) < 0) {\n        if (kill(pid, 0) < 0) {\n            if ((*__errno_location()) == 3) {\n                return INVALID_TASK_PID;\n            }\n            fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\", pid, sig, strerror((*__errno_location())));\n            return -1;\n        } else {\n            has_group = 0;\n        }\n    }\n    if (kill((has_group ? -1 : 1) * pid, sig) < 0) {\n        if ((*__errno_location()) != 3) {\n            fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\", -pid, sig, strerror((*__errno_location())));\n            return UNABLE_TO_KILL_TASK;\n        } else {\n            return INVALID_TASK_PID;\n        }\n    }\n    fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", (has_group ? \"group \" : \"\"), pid, sig);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(change_user)(long long, long long);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern char g_409026;\nextern char g_40907d;\nextern struct_0 *user_detail;\n\nlong long signal_user_task(unsigned long a0, unsigned long a1,\n                           unsigned long a2) {\n  unsigned long v1; // rbx\n  unsigned int v2;  // r13d\n  unsigned int v4;  // edi\n  unsigned int v5;  // edi\n  unsigned int v6;  // edx\n\n  if ((unsigned int)a1 <= 0)\n    return 9;\n  v1 = change_user(user_detail->field_10, user_detail->field_14);\n  if ((unsigned int)v1)\n    return 6;\n  v2 = -((unsigned int)a1);\n  if (kill(v2, 0) >= 0) {\n    v6 = &g_409026;\n    if (kill(v2, a2) >= 0) {\n      fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", v6, (unsigned int)a1,\n              (unsigned int)a2);\n      return v1;\n    }\n  } else if (kill(a1, 0) < 0) {\n    v4 = *(__errno_location());\n    if (v4 != 3) {\n      fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\",\n              (unsigned int)a1, (unsigned int)a2, (unsigned int)strerror(v4));\n      return 4294967295;\n    }\n    return 9;\n  } else if (kill(a1, a2) >= 0) {\n    v6 = &g_40907d;\n    fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", v6, (unsigned int)a1,\n            (unsigned int)a2);\n    return v1;\n  }\n  v5 = *(__errno_location());\n  if (v5 != 3) {\n    fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\",\n            v2, &g_409026, (unsigned int)strerror(v5));\n    return 8;\n  }\n  return 9;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0cv41org/signal_user_task.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp0cv41org/signal_user_task.c:24:8: error: unknown type name 'struct_0';\ndid you mean 'struct'? 24 | extern struct_0 *user_detail; |        ^~~~~~~~ |\nstruct /tmp/tmp0cv41org/signal_user_task.c:24:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmp0cv41org/signal_user_task.c:36:35: error:\nmember reference type 'int' is not a pointer 36 |     v1 =\nchange_user(user_detail->field_10, user_detail->field_14); | ~~~~~~~~~~~  ^\n/tmp/tmp0cv41org/signal_user_task.c:36:58: error: member reference type 'int' is\nnot a pointer 36 |     v1 = change_user(user_detail->field_10,\nuser_detail->field_14); | ~~~~~~~~~~~  ^\n/tmp/tmp0cv41org/signal_user_task.c:51:14: error: indirection requires pointer\noperand ('int' invalid) 51 |         v4 = *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp0cv41org/signal_user_task.c:65:10: error:\nindirection requires pointer operand ('int' invalid) 65 |     v5 =\n*(__errno_location()); |          ^~~~~~~~~~~~~~~~~~~~~ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int rmdir_as_tasktracker(const char *path) {\n    int user_uid = geteuid();\n    int user_gid = getegid();\n    int ret = change_effective_user(tt_uid, tt_gid);\n    if (ret == 0) {\n        if (rmdir(path) != 0) {\n            fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user_uid, user_gid) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int delete_path(const char *full_path, int needs_tt_user) {\n    int exit_code = 0;\n    if (full_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Path is null\\n\");\n        exit_code = UNABLE_TO_BUILD_PATH;\n    } else {\n        char *(paths[]) = {strdup(full_path), 0};\n        if (paths[0] == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc failed in delete_path\\n\");\n            return -1;\n        }\n        if (access(full_path, 0) != 0) {\n            if ((*__errno_location()) == 2) {\n                free(paths[0]);\n                return 0;\n            }\n        }\n        FTS *tree = fts_open(paths, 16 | 64, ((void *)0));\n        FTSENT *entry = ((void *)0);\n        int ret = 0;\n        if (tree == ((void *)0)) {\n            fprintf(LOGFILE, \"Cannot open file traversal structure for the path %s:%s.\\n\", full_path, strerror((*__errno_location())));\n            free(paths[0]);\n            return -1;\n        }\n        while (((entry = fts_read(tree)) != ((void *)0)) && exit_code == 0)\n            {\n                switch (entry->fts_info) {\n                  case 6:\n                    if (!needs_tt_user || strcmp(entry->fts_path, full_path) != 0) {\n                        if (rmdir(entry->fts_accpath) != 0) {\n                            fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                            exit_code = -1;\n                        }\n                    }\n                    break;\n                  case 8:\n                  case 12:\n                  case 13:\n                  case 3:\n                    if (unlink(entry->fts_accpath) != 0) {\n                        fprintf(LOGFILE, \"Couldn't delete file %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                        exit_code = -1;\n                    }\n                    break;\n                  case 4:\n                    fprintf(LOGFILE, \"Unreadable directory %s. Skipping..\\n\", entry->fts_path);\n                    break;\n                  case 1:\n                    if ((entry->fts_statp->st_mode & 128) == 0) {\n                        fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\", entry->fts_path);\n                        if (chmod(entry->fts_accpath, 448) != 0) {\n                            fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\", entry->fts_path, strerror((*__errno_location())));\n                        }\n                    }\n                    break;\n                  case 10:\n                    fprintf(LOGFILE, \"Directory not found %s\\n\", entry->fts_path);\n                    break;\n                  case 2:\n                  case 5:\n                  case 11:\n                    break;\n                  case 7:\n                    fprintf(LOGFILE, \"Error traversing directory %s - %s\\n\", entry->fts_path, strerror(entry->fts_errno));\n                    exit_code = -1;\n                    break;\n                    break;\n                  default:\n                    exit_code = -1;\n                    break;\n                }\n            }\n        ret = fts_close(tree);\n        if (exit_code == 0 && ret != 0) {\n            fprintf(LOGFILE, \"Error in fts_close while deleting %s\\n\", full_path);\n            exit_code = -1;\n        }\n        if (needs_tt_user) {\n            exit_code = rmdir_as_tasktracker(full_path);\n        }\n        free(paths[0]);\n    }\n    return exit_code;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nint(access)(char *, int);\nchar *(strerror)(int);\nunsigned int(geteuid)();\nint(unlink)(char *);\nunsigned int(getegid)();\nint(rmdir)(char *);\nlong long(change_effective_user)(long long, long long);\nint(chmod)(char *, unsigned short);\n\ntypedef struct struct_2 {\n  char padding_0[40];\n  unsigned long long field_28;\n  unsigned long long field_30;\n  unsigned int field_38;\n  char padding_3c[38];\n  unsigned short field_62;\n  char padding_64[4];\n  struct struct_0 *field_68;\n} struct_2;\n\ntypedef struct struct_1 {\n  char padding_0[40];\n  char *field_28;\n  char *field_30;\n  unsigned int field_38;\n  char padding_3c[38];\n  unsigned short field_62;\n  char padding_64[4];\n  struct struct_0 *field_68;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[24];\n  char field_18;\n} struct_0;\n\nextern FILE_t *LOGFILE;\nextern unsigned int tt_gid;\nextern unsigned int tt_uid;\n\nlong long delete_path_name_conflict(char *a0, unsigned long a1) {\n  void *v0;              // [bp-0x48]\n  void *v1;              // [bp-0x40]\n  unsigned long v3;      // rbp, Other Possible Types: unsigned long long\n  unsigned long long v4; // r14\n  struct_2 *v5;          // rax\n  struct_1 *v6;          // rbx\n  char v7;               // r12b\n\n  if (!a0) {\n    fwrite(\"Path is null\\n\", 1, 13, LOGFILE);\n    return 21;\n  }\n  v0 = strdup(a0);\n  v1 = 0;\n  if (!v0) {\n    fwrite(\"Malloc failed in delete_path_name_conflict\\n\", 1, 29, LOGFILE);\n    return 4294967295;\n  }\n  if (access(a0, 0) && *(__errno_location()) == 2) {\n    free(v0);\n    return 0;\n  }\n  v4 = fts_open(&v0, 80, 0);\n  v3 = 0;\n  if (!v4) {\n    fprintf(LOGFILE,\n            \"Cannot open file traversal structure for the path %s:%s.\\n\",\n            (unsigned int)a0, (unsigned int)strerror(*(__errno_location())));\n    free(v0);\n    return 4294967295;\n  }\n  while (true) {\n    (unsigned int)v5 = fts_read(v4);\n    v6 = v5;\n    v7 = !(unsigned int)v3;\n    if (!v5 || !v7)\n      break;\n    switch (v5->field_62 << 48) {\n    case 1:\n      v3 = 0;\n      if (!(v6->field_68->field_18 & 128)) {\n        fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\",\n                (unsigned int)v6->field_30);\n        v3 = chmod(v6->field_28, 448);\n        if ((unsigned int)v3) {\n          fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\",\n                  (unsigned int)v6->field_30,\n                  (unsigned int)strerror(*(__errno_location())));\n          v3 = 0;\n          break;\n        }\n      }\n    case 2:\n    case 5:\n    case 11:\n      v3 = 0;\n      break;\n    case 3:\n    case 8:\n    case 12:\n    case 13:\n      v3 = unlink(v6->field_28);\n      if ((unsigned int)v3) {\n        fprintf(LOGFILE, \"Couldn't delete file %s - %s\\n\",\n                (unsigned int)v6->field_30,\n                (unsigned int)strerror(*(__errno_location())));\n        v3 = 4294967295;\n        break;\n      }\n    case 4:\n      fprintf(LOGFILE, \"Unreadable directory %s. Skipping..\\n\",\n              (unsigned int)v6->field_30);\n      v3 = 0;\n      break;\n    case 6:\n      if (!(unsigned int)a1 ||\n          (v3 = (unsigned long long)(unsigned int)strcmp(v6->field_30, a0),\n           (unsigned int)v3)) {\n        v3 = rmdir(v6->field_28);\n        if ((unsigned int)v3) {\n          fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\",\n                  (unsigned int)v6->field_30,\n                  (unsigned int)strerror(*(__errno_location())));\n          v3 = 4294967295;\n          break;\n        }\n      }\n    case 7:\n      fprintf(LOGFILE, \"Error traversing directory %s - %s\\n\",\n              (unsigned int)v6->field_30, (unsigned int)strerror(v6->field_38));\n      v3 = 4294967295;\n      break;\n    case 10:\n      fprintf(LOGFILE, \"Directory not found %s\\n\", (unsigned int)v6->field_30);\n      v3 = 0;\n      break;\n    default:\n      v3 = 4294967295;\n      break;\n    }\n  }\n  if (fts_close(v4) && v7) {\n    fprintf(LOGFILE, \"Error in fts_close while deleting %s\\n\",\n            (unsigned int)a0);\n    v3 = 4294967295;\n  }\n  if ((unsigned int)a1) {\n    v3 = change_effective_user(tt_uid, tt_gid);\n    if (!(unsigned int)v3) {\n      v3 = rmdir(a0);\n      if ((unsigned int)v3) {\n        fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", (unsigned int)a0,\n                (unsigned int)strerror(*(__errno_location())));\n        v3 = 4294967295;\n      }\n    }\n    if ((int)change_effective_user(geteuid(), getegid()))\n      v3 = 4294967295;\n  }\n  free(v0);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:53:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 53 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:79:26: error: indirection requires pointer\noperand ('int' invalid) 79 |     if (access(a0, 0) && *(__errno_location()) ==\n2) |                          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:88:129: error: indirection requires pointer\noperand ('int' invalid) 88 |         fprintf(LOGFILE, \"Cannot open file\ntraversal structure for the path %s:%s.\\n\", (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:94:9: error: assignment to cast is illegal,\nlvalue casts are not supported 94 |         (unsigned int)v5 = fts_read(v4); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpw74m7trq/delete_path_name_conflict.c:109:129: error: indirection\nrequires pointer operand ('int' invalid) 109 | fprintf(LOGFILE, \"Error chmoding\n%s - %s, continuing\\n\", (unsigned int)v6->field_30, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:121:119: error: indirection requires pointer\noperand ('int' invalid) 121 |                 fprintf(LOGFILE, \"Couldn't delete\nfile %s - %s\\n\", (unsigned int)v6->field_30, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:135:128: error: indirection requires pointer\noperand ('int' invalid) 135 |                     fprintf(LOGFILE, \"Couldn't\ndelete directory %s - %s\\n\", (unsigned int)v6->field_30, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw74m7trq/delete_path_name_conflict.c:166:104: error: indirection requires pointer\noperand ('int' invalid) 166 |                 fprintf(LOGFILE, \"rmdir of %s\nfailed - %s\\n\", (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 8 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_as_user(const char *user, const char *good_local_dirs, const char *subdir) {\n    int ret = 0;\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    char **ptr;\n    if (tt_roots == ((void *)0) || *tt_roots == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    for (ptr = tt_roots; *ptr != ((void *)0); ++ptr) {\n        char *full_path = get_user_subdirectory(*ptr, user, subdir);\n        if (full_path == ((void *)0)) {\n            return -1;\n        }\n        int this_ret = delete_path(full_path, strlen(subdir) == 0);\n        free(full_path);\n        if (this_ret != 0) {\n            ret = this_ret;\n        }\n    }\n    free_values(tt_roots);\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_mapred_local_dirs)(long long);\nlong long(get_user_subdirectory)(long long, long long, long long);\nlong long(delete_path)(long long, long long);\nlong long(free_values)(long long);\n\nextern FILE_t *LOGFILE;\n\nlong long delete_as_user_name_conflict(unsigned long a0, unsigned long long a1, char *a2) {\n  unsigned long long *v0; // [bp-0x40]\n  unsigned long long *v3; // rax\n  void *v4;               // rbx\n  unsigned long long v5;  // rax\n  unsigned long v6;       // rdi, Other Possible Types: unsigned long long\n  unsigned long long *v7; // r12, Other Possible Types: unsigned long\n  void *v8; // r14, Other Possible Types: unsigned long, unsigned long long\n\n  v3 = get_mapred_local_dirs(a1);\n  v0 = v3;\n  if (v3) {\n    v7 = v3;\n    v6 = *(v3);\n    v8 = 0;\n    if (v6) {\n      while (v4) {\n        v4 = get_user_subdirectory(v6, a0, a2);\n        v5 = delete_path(v4, !*(a2));\n        free(v4);\n        if ((unsigned int)v5)\n          v8 = v5;\n        v7 += 8;\n        v6 = *(v7);\n        if (!v6) {\n          free_values(v0);\n          return v8;\n        }\n      }\n      return 4294967295;\n    }\n  }\n  fwrite(\"Good mapred local directories could ot be obtained.\\n\", 1, 52,\n         LOGFILE);\n  return 5;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptlzfxx9q/delete_as_user_name_conflict.c:21:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 21 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_log_directory(const char *subdir, const char *good_local_dirs) {\n    char *job_log_dir = get_job_log_directory(subdir);\n    int ret = -1;\n    if (job_log_dir == ((void *)0))\n        return ret;\n    delete_path(job_log_dir, 1);\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *mapred_local_log_dir = concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2, *local_dir_ptr, subdir);\n        if (mapred_local_log_dir != ((void *)0)) {\n            delete_path(mapred_local_log_dir, 1);\n            free(mapred_local_log_dir);\n        } else\n            fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\", subdir);\n    }\n    free(job_log_dir);\n    free_values(local_dir);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_job_log_directory)(long long);\nlong long(delete_path)(long long, long long);\nlong long(get_mapred_local_dirs)(long long);\nlong long(free_values)(long long);\nlong long(concatenate)(long long, long long, long long, ...);\n\nextern FILE_t *LOGFILE;\n\nlong long delete_log_directory_name_conflict(unsigned long long a0, unsigned long long a1) {\n  void *v0;               // [bp-0x40]\n  unsigned long long *v3; // rax\n  unsigned long long *v5; // rbp, Other Possible Types: unsigned long\n  void *v6;               // rax\n\n  v0 = get_job_log_directory(a0);\n  if (!v0)\n    return 4294967295;\n  delete_path(v0, 1);\n  v3 = get_mapred_local_dirs(a1);\n  if (*(v3)) {\n    v5 = v3;\n    do {\n      v6 = concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2);\n      if (!v6) {\n        fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\",\n                (unsigned int)a0);\n      } else {\n        delete_path(v6, 1);\n        free(v6);\n      }\n    } while ((v5 += 8, *(v5)));\n  }\n  free(v0);\n  free_values(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6sq9dh_o/delete_log_directory_name_conflict.c:22:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_command_as_user(const char *user, char *const *args) {\n    if (user == ((void *)0)) {\n        fprintf(LOGFILE, \"The user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint user_detail; // add global variable by heuristics\nint user_detail; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(change_user)(long long, long long);\nint(execvp)(char *, char *[0]);\nchar *(strerror)(int);\n\nextern FILE_t *LOGFILE;\nextern struct_0 *user_detail;\n\nlong long run_command_as_user_name_conflict(unsigned long a0, char **a1) {\n  if (!a0) {\n    fwrite(\"The user passed is null.\\n\", 1, 25, LOGFILE);\n    return 1;\n  } else if ((int)change_user(user_detail->field_10, user_detail->field_14)) {\n    return 4294967295;\n  } else {\n    execvp(*(a1), a1);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\",\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa6ofzojp/run_command_as_user_name_conflict.c:22:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 22 | extern FILE_t *LOGFILE; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpa6ofzojp/run_command_as_user_name_conflict.c:23:8: error: unknown type name\n'struct_0'; did you mean 'struct'? 23 | extern struct_0 *user_detail; | ^~~~~~~~\n      |        struct\n/tmp/tmpa6ofzojp/run_command_as_user_name_conflict.c:23:8: error: declaration of anonymous\nstruct must be a definition /tmp/tmpa6ofzojp/run_command_as_user_name_conflict.c:32:44: error:\nmember reference type 'int' is not a pointer 32 |     else if\n((int)change_user(user_detail->field_10, user_detail->field_14)) | ~~~~~~~~~~~ ^\n/tmp/tmpa6ofzojp/run_command_as_user_name_conflict.c:32:67: error: member reference type 'int'\nis not a pointer 32 |     else if ((int)change_user(user_detail->field_10,\nuser_detail->field_14)) | ~~~~~~~~~~~  ^\n/tmp/tmpa6ofzojp/run_command_as_user_name_conflict.c:39:83: error: indirection requires\npointer operand ('int' invalid) 39 |         fprintf(LOGFILE, \"Failure to exec\ncommand - %s\\n\", (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int is_only_root_writable(const char *file) {\n    struct stat file_stat;\n    if (stat(file, &file_stat) != 0) {\n        fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", file, strerror((*__errno_location())));\n        return 0;\n    }\n    if (file_stat.st_uid != 0) {\n        fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\", file, file_stat.st_uid);\n        return 0;\n    }\n    if ((file_stat.st_mode & ((128 >> 3) | ((128 >> 3) >> 3))) != 0) {\n        fprintf(LOGFILE, \"File %s must not be world or group writable, but is %03o\\n\", file, file_stat.st_mode & (~61440));\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int check_configuration_permissions(const char *file_name) {\n    char *dir = strdup(file_name);\n    char *buffer = dir;\n    do {\n        if (!is_only_root_writable(dir)) {\n            free(buffer);\n            return -1;\n        }\n        dir = dirname(dir);\n    } while (strcmp(dir, \"/\") != 0);\n    free(buffer);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nchar *(strerror)(int);\nchar *(dirname)(char *);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nextern FILE_t *LOGFILE;\n\nlong long check_configuration_permissions_name_conflict(char *a0) {\n  stat v0;               // [bp-0xb8]\n  char v1;               // [bp-0xa0]\n  char v2;               // [bp-0x9c]\n  unsigned long long v4; // rax\n  void *v5;              // r13\n  char *v6;              // rbx, Other Possible Types: unsigned long\n  unsigned int v7;       // ecx\n  unsigned long long v8; // rcx\n  unsigned long v9;      // rbp, Other Possible Types: unsigned long long\n\n  v4 = strdup(a0);\n  v5 = v4;\n  v6 = v4;\n  while (true) {\n    if (stat(v6, &v0)) {\n      fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", (unsigned int)v6,\n              (unsigned int)strerror(*(__errno_location())));\n      break;\n    } else {\n      v7 = *((int *)&v2);\n      if (v7) {\n        fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\",\n                (unsigned int)v6, v7);\n        break;\n      } else {\n        v8 = *((int *)&v1);\n        if (!((char)v8 & 18)) {\n          v6 = dirname(v6);\n          v9 = strcmp(v6, \"/\");\n          if (!(unsigned int)v9) {\n            free(v5);\n            return v9;\n          }\n        } else {\n          fprintf(LOGFILE,\n                  \"File %s must not be world or group writable, but is %03o\\n\",\n                  (unsigned int)v6, (unsigned int)v8);\n          break;\n        }\n      }\n    }\n  }\n  free(v5);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxelbluct/check_configuration_permissions_name_conflict.c:50:3: error: redefinition of\n'stat' as different kind of symbol 50 | } stat; |   ^\n/tmp/tmpxelbluct/check_configuration_permissions_name_conflict.c:17:6: note: previous\ndefinition is here 17 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpxelbluct/check_configuration_permissions_name_conflict.c:52:8: error: unknown type\nname 'FILE_t'; did you mean 'FILE'? 52 | extern FILE_t *LOGFILE; |        ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpxelbluct/check_configuration_permissions_name_conflict.c:56:5: error: must use\n'struct' tag to refer to type 'stat' 56 |     stat v0;  // [bp-0xb8] |     ^ |\nstruct /tmp/tmpxelbluct/check_configuration_permissions_name_conflict.c:17:6: note: struct\n'stat' is hidden by a non-type declaration of 'stat' here 17 | int (stat)(char\n*, struct stat { |      ^\n/tmp/tmpxelbluct/check_configuration_permissions_name_conflict.c:73:100: error: indirection\nrequires pointer operand ('int' invalid) 73 |             fprintf(LOGFILE,\n\"Can't stat file %s - %s\\n\", (unsigned int)v6, (unsigned\nint)strerror(*(__errno_location()))); | ^~~~~~~~~~~~~~~~~~~~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char *get_value(const char *key) {\n    int count;\n    for (count = 0; count < config.size; count++) {\n        if (strcmp(config.confdetails[count]->key, key) == 0) {\n            return strdup(config.confdetails[count]->value);\n        }\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp;      // add global variable by heuristics\nint g_40c2f8; // add global variable by heuristics\nint g_40c2f8; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\n\nextern unsigned int config;\nextern struct_1 *g_40c2f8;\n\nlong long get_value_name_conflict(char *a0) {\n  unsigned long v0;     // [bp-0x20]\n  unsigned long v1;     // [bp-0x18]\n  unsigned long v2;     // [bp-0x10]\n  unsigned long v3;     // [bp-0x8]\n  unsigned long v5;     // r13\n  unsigned long v6;     // r12\n  unsigned long v7;     // rbx\n  struct struct_0 **v8; // rbx, Other Possible Types: unsigned long\n  char *v9[2];          // rbp\n\n  if (config <= 0)\n    return 0;\n  v3 = v5;\n  v2 = v6;\n  *((int *)&v1) = rbp;\n  v0 = v7;\n  v8 = g_40c2f8;\n  while (strcmp(v9[0], a0)) {\n    v9 = *((long long *)v8);\n    v8 += 8;\n    if (v8 == &g_40c2f8[config])\n      return 0;\n  }\n  return strdup(v9[1]);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkqv2y6s9/get_value_name_conflict.c:22:8: error: unknown type name 'struct_1'; did you\nmean 'struct'? 22 | extern struct_1 *g_40c2f8; |        ^~~~~~~~ |        struct\n/tmp/tmpkqv2y6s9/get_value_name_conflict.c:22:8: error: declaration of anonymous struct must\nbe a definition /tmp/tmpkqv2y6s9/get_value_name_conflict.c:45:12: error: array type 'char\n*[2]' is not assignable 45 |         v9 = *((long long *)v8); |         ~~ ^\n/tmp/tmpkqv2y6s9/get_value_name_conflict.c:47:28: error: subscripted value is not an array,\npointer, or vector 47 |         if (v8 == &g_40c2f8[config]) | ~~~~~~~~^~~~~~~\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **get_values(const char *key) {\n    char *value = get_value(key);\n    return extract_values(value);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_value)(long long);\nlong long(extract_values)(long long);\n\nlong long get_values_name_conflict(unsigned long long a0) {\n  return extract_values(get_value(a0));\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **extract_values(char *value) {\n    char **toPass = ((void *)0);\n    char *tempTok = ((void *)0);\n    char *tempstr = ((void *)0);\n    int size = 0;\n    int toPassSize = 10;\n    if (value != ((void *)0)) {\n        toPass = (char **)malloc(sizeof(char *) * toPassSize);\n        tempTok = strtok_r((char *)value, \",\", &tempstr);\n        while (tempTok != ((void *)0))\n            {\n                toPass[size++] = tempTok;\n                if (size == toPassSize) {\n                    toPassSize += 10;\n                    toPass = (char **)realloc(toPass, (sizeof(char *) * (10 * toPassSize)));\n                }\n                tempTok = strtok_r(((void *)0), \",\", &tempstr);\n            }\n    }\n    if (size > 0) {\n        toPass[size] = ((void *)0);\n    }\n    return toPass;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strtok_r)(char *, char *, char **);\nvoid *(realloc)(void *, unsigned long);\n\nlong long extract_values_name_conflict(unsigned long long *a0) {\n  void *v0;         // [bp-0x30]\n  unsigned long v2; // rbp\n  unsigned long v3; // r12\n  unsigned long v4; // rax, Other Possible Types: unsigned long long\n  unsigned long v5; // rbx\n  unsigned long long\n      v6; // r13, Other Possible Types: unsigned long, unsigned int\n\n  v0 = 0;\n  if (!a0)\n    return a0;\n  v2 = malloc(80);\n  v4 = strtok_r(a0, \",\", &v0);\n  if (!v4)\n    return v2;\n  v5 = 0;\n  v6 = 10;\n  do {\n    v3 = v5 + 1;\n    *((unsigned long *)(v2 + v5 * 8)) = v4;\n    if ((unsigned int)v3 == (unsigned int)v6) {\n      v6 = (unsigned int)v6 + 10;\n      v2 = realloc(v2, (unsigned int)v6 * 10 * 8);\n    }\n  } while ((v4 = strtok_r(NULL, \",\", &v0), v5 += 1, v4));\n  if ((unsigned int)v3 <= 0)\n    return v2;\n  *((long long *)(v2 + v3 * 8)) = 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int write_config_file(char *file_name) {\n    FILE *file;\n    file = fopen(file_name, \"w\");\n    if (file == ((void *)0)) {\n        printf(\"Failed to open %s.\\n\", file_name);\n        return 1;\n    }\n    fprintf(file, \"mapred.local.dir=/tmp/test-task-controller/local-1\");\n    int i;\n    for (i = 2; i < 5; ++i) {\n        fprintf(file, \",/tmp/test-task-controller/local-%d\", i);\n    }\n    fprintf(file, \"\\n\");\n    fprintf(file, \"hadoop.log.dir=/tmp/test-task-controller/logs\\n\");\n    fclose(file);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long write_config_file_name_conflict(char *a0) {\n  FILE_t *v2; // rax\n\n  v2 = fopen(a0, \"w\");\n  if (!v2) {\n    printf(\"Failed to open %s.\\n\", (unsigned int)a0);\n    return 1;\n  }\n  fwrite(\"mapred.local.dir=/tmp/test-task-controller/local-1\", 1, 50, v2);\n  fprintf(v2, \",/tmp/test-task-controller/local-%d\", 2);\n  fprintf(v2, \",/tmp/test-task-controller/local-%d\", 3);\n  fprintf(v2, \",/tmp/test-task-controller/local-%d\", 4);\n  fputc(10, v2);\n  fwrite(\"hadoop.log.dir=/tmp/test-task-controller/logs\\n\", 1, 46, v2);\n  fclose(v2);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:16:6: error: conflicting types for 'fputc'\n   16 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:141:16: error: redefinition of '_IO_marker'\n  141 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:147:16: error: redefinition of\n'_IO_codecvt' 147 | typedef struct _IO_codecvt { |                ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:151:16: error: redefinition of\n'_IO_wide_data' 151 | typedef struct _IO_wide_data { |                ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpbe0rduh2/write_config_file_name_conflict.c:174:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 174 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/test/test-task-controller.c"}
{"compilable":1,"function":"int edgecmp(Fibnode *a, Fibnode *b) {\n    Edge *e, *f;\n    e = (Edge *)a;\n    f = (Edge *)b;\n    if (e->dist < f->dist)\n        return -1;\n    if (e->dist > f->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned int field_38;\n} struct_0;\n\nlong long edgecmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  unsigned int v1;  // ecx\n  unsigned int v2;  // edx\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0->field_38;\n  v2 = a1->field_38;\n  v3 = 4294967295;\n  if (v1 >= v2)\n    v3 = v1 > v2;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":0,"function":"int prim(int start) {\n    Fibheap pq;\n    Node *n;\n    Edge *e;\n    int primsum;\n    fibinit(&pq, edgecmp);\n    n = nodedata(start);\n    n->intree = 1;\n    primsum = 0;\n    insertedges(&pq, n);\n    while (pq.min != ((void *)0))\n        {\n            e = (Edge *)pq.min;\n            if (fibdeletemin(&pq) < 0)\n                sysfatal(\"deletion failed\");\n            n = e->node;\n            if (n->intree)\n                continue;\n            n->intree = 1;\n            primsum += e->dist;\n            insertedges(&pq, n);\n        }\n    fibfree(&pq);\n    return primsum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint edgecmp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nodedata)(long long);\nlong long(insertedges)(long long, long long);\nlong long(fibfree)(long long);\nlong long(fibdeletemin)(long long);\nlong long(sysfatal)(...);\n\ntypedef struct struct_1 {\n  char padding_0[48];\n  struct struct_0 *field_30;\n  unsigned int field_38;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long prim_name_conflict(unsigned long long a0) {\n  unsigned long v0; // [bp-0x38]\n  struct_1 *v1;     // [bp-0x30]\n  void *v2;         // [bp-0x28]\n  unsigned int v3;  // [bp-0x20]\n  struct_0 *v5;     // rax\n  void *v6;         // r12, Other Possible Types: unsigned long\n  struct_1 *v7;     // rbx\n  struct_0 *v8;     // rsi\n\n  v0 = edgecmp;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v5 = nodedata(a0);\n  v5->field_10 = 1;\n  insertedges(&v0, v5);\n  v6 = 0;\n  while (v7) {\n    v7 = v1;\n    if ((int)fibdeletemin(&v0) < 0)\n      sysfatal(); /* do not return */\n    v8 = v7->field_30;\n    if (!v8->field_10) {\n      v8->field_10 = 1;\n      v6 = (unsigned int)v6 + v7->field_38;\n      insertedges(&v0, v8);\n    }\n  }\n  fibfree(&v0);\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6krek8rm/prim_name_conflict.c:21:22: error: ISO C requires a named parameter before\n'...' 21 | long long (sysfatal)(...); |                      ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":1,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[40];\n  unsigned int field_28;\n} struct_0;\n\nlong long intcmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  unsigned int v1;  // ecx\n  unsigned int v2;  // edx\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0->field_28;\n  v2 = a1->field_28;\n  v3 = 4294967295;\n  if (v1 >= v2)\n    v3 = v1 > v2;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/fibheaptest.c"}
{"compilable":1,"function":"int nodecmp(Fibnode *a, Fibnode *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    if (m->dist < n->dist)\n        return -1;\n    if (m->dist > n->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned int field_38;\n} struct_0;\n\nlong long nodecmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  unsigned int v1;  // ecx\n  unsigned int v2;  // edx\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0->field_38;\n  v2 = a1->field_38;\n  v3 = 4294967295;\n  if (v1 >= v2)\n    v3 = v1 > v2;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/dijkstra.c"}
{"compilable":1,"function":"int Intcmp(Avl *a, Avl *b) {\n    Int *ai, *bi;\n    ai = (Int *)a;\n    bi = (Int *)b;\n    if (ai->i < bi->i)\n        return -1;\n    if (ai->i > bi->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[32];\n  unsigned int field_20;\n} struct_0;\n\nlong long Intcmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  unsigned int v1;  // ecx\n  unsigned int v2;  // edx\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0->field_20;\n  v2 = a1->field_20;\n  v3 = 4294967295;\n  if (v1 >= v2)\n    v3 = v1 > v2;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int depth(Avl *n) {\n    int dl, dr, d;\n    if (n == ((void *)0))\n        return 0;\n    dl = depth(n->c[0]);\n    dr = depth(n->c[1]);\n    d = dl > dr ? dl : dr;\n    return d + 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(depth_name_conflict)(unsigned long long[2]);\n\nlong long depth_name_conflict(unsigned long long a0[2]) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v1;      // [bp-0x8]\n  unsigned long v3;      // rbx\n  unsigned int v4;       // ebx\n  unsigned long v5;      // rax, Other Possible Types: unsigned int\n  unsigned long long v6; // rax\n\n  if (!a0)\n    return 0;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  v4 = depth_name_conflict(a0[0]);\n  (unsigned int)v5 = depth_name_conflict(a0[1]);\n  if ((unsigned int)v5 > v4) {\n    v6 = (unsigned int)v5 + 1;\n    return v6;\n  }\n  v5 = v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcfpxqiw5/depth_name_conflict.c:33:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 33 |     (unsigned int)v5 = depth_name_conflict(a0[1]); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int nodecmp(Avl *a, Avl *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    return strcmp(m->key, n->key);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_1 {\n  char padding_0[32];\n  unsigned long long field_20;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[32];\n  char *field_20;\n} struct_0;\n\nlong long nodecmp_name_conflict(struct_0 *a0, struct_1 *a1) {\n  return strcmp(a0->field_20, a1->field_20);\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/avlexample.c"}
{"compilable":1,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[40];\n  unsigned int field_28;\n} struct_0;\n\nlong long intcmp_name_conflict(struct_0 *a0, struct_0 *a1) {\n  unsigned int v1;  // ecx\n  unsigned int v2;  // edx\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0->field_28;\n  v2 = a1->field_28;\n  v3 = 4294967295;\n  if (v1 >= v2)\n    v3 = v1 > v2;\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/fibheaptest.c"}
{"compilable":1,"function":"uint32_t pcg32_random_r(pcg32_random_t *rng) {\n    uint64_t oldstate = rng->state;\n    rng->state = oldstate * 6364136223846793005ULL + rng->inc;\n    uint32_t xorshifted = ((oldstate >> 18U) ^ oldstate) >> 27U;\n    uint32_t rot = oldstate >> 59U;\n    return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pcg32_random_r_name_conflict(unsigned long long a0[2]) {\n  unsigned long long v1; // rcx\n\n  v1 = a0[0];\n  a0[0] = v1 * 6364136223846793005 + a0[1];\n  return (unsigned int)((v1 / 0x40000 ^ v1) >> 27) >>\n             ((char)v1 / 0x800000000000000 & 31 & 31) |\n         (unsigned int)((v1 / 0x40000 ^ v1) >> 27)\n             << 32 - ((char)v1 / 0x800000000000000 & 31 & 31);\n}\n","pass":1,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_random() {\n    return pcg32_random_r(&pcg32_global);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pcg32_random_name_conflict_r)(long long);\n\nextern unsigned long long pcg32_global;\n\nlong long pcg32_random_name_conflict() { return pcg32_random_name_conflict_r(&pcg32_global); }\n","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_boundedrand_r(pcg32_random_t *rng, uint32_t bound) {\n    uint32_t threshold = -bound % bound;\n    for (;;) {\n        uint32_t r = pcg32_random_r(rng);\n        if (r >= threshold)\n            return r % bound;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pcg32_random_r)(long long);\n\nlong long pcg32_boundedrand_r_name_conflict(unsigned long long a0, unsigned long a1) {\n  unsigned long long v1; // rax\n\n  do {\n    (unsigned int)v1 = pcg32_random_r(a0);\n  } while ((unsigned int)v1 <\n           (0 CONCAT - ((unsigned int)a1)) / m(unsigned int) a1 >> 32);\n  return (0 CONCAT(unsigned int) v1) / m(unsigned int) a1 >> 32;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:24:9: error: assignment to cast is\nillegal, lvalue casts are not supported 24 |         (unsigned int)v1 =\npcg32_random_r(a0); |         ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:25:36: error: expected ')'\n   25 |     } while ((unsigned int)v1 < (0 CONCAT -((unsigned int)a1)) /m\n(unsigned int)a1 >> 32); |                                    ^\n/tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:25:33: note: to match this '('\n   25 |     } while ((unsigned int)v1 < (0 CONCAT -((unsigned int)a1)) /m\n(unsigned int)a1 >> 32); |                                 ^\n/tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:25:68: error: expected expression\n   25 |     } while ((unsigned int)v1 < (0 CONCAT -((unsigned int)a1)) /m\n(unsigned int)a1 >> 32); | ^ /tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:26:15:\nerror: expected ')' 26 |     return (0 CONCAT (unsigned int)v1) /m (unsigned\nint)a1 >> 32; |               ^ /tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:26:12:\nnote: to match this '(' 26 |     return (0 CONCAT (unsigned int)v1) /m (unsigned\nint)a1 >> 32; |            ^ /tmp/tmpd2s01c25/pcg32_boundedrand_r_name_conflict.c:26:44:\nerror: expected expression 26 |     return (0 CONCAT (unsigned int)v1) /m\n(unsigned int)a1 >> 32; |                                            ^ 5 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_boundedrand(uint32_t bound) {\n    return pcg32_boundedrand_r(&pcg32_global, bound);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pcg32_boundedrand_name_conflict_r)(long long, long long);\n\nextern unsigned long long pcg32_global;\n\nlong long pcg32_boundedrand_name_conflict(unsigned long long a0) {\n  return pcg32_boundedrand_name_conflict_r(&pcg32_global, a0);\n}\n","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_402004;\nextern char g_402019;\nextern char g_402020;\nextern char g_402024;\nextern char g_40202e;\nextern char g_402031;\nextern char g_402034;\nextern char g_402037;\nextern char g_40203a;\nextern char g_40203d;\nextern char g_402040;\nextern char g_402043;\nextern char g_402046;\nextern char g_402049;\nextern char g_40204d;\nextern char g_402051;\nextern char g_402055;\nextern char g_402059;\nextern char g_40205d;\nextern char g_402061;\nextern char g_402065;\nextern char g_40206c;\nextern char g_402075;\nextern char g_40207f;\nextern char g_402088;\nextern char g_40208f;\nextern char g_402094;\nextern char g_40209b;\nextern char g_4020a4;\nextern char g_4020a8;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  v2 = a0 - 0x561f0000;\n  if ((unsigned int)v2 > 56)\n    return \"unknown\";\n  if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rax,\n                                           0x38 < 64 >, cc_ndep))\n    goto LABEL_0x4011b1;\n  else\n    goto LABEL_0x4011cb;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjrswcu5z/get_key_name_name_conflict.c:57:15: error: expected expression\n   57 |     if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rax,\n0x38<64>, cc_ndep)) |               ^ /tmp/tmpjrswcu5z/get_key_name_name_conflict.c:58:14:\nerror: use of undeclared label 'LABEL_0x4011b1' 58 |         goto\nLABEL_0x4011b1; |              ^ /tmp/tmpjrswcu5z/get_key_name_name_conflict.c:60:14: error:\nuse of undeclared label 'LABEL_0x4011cb' 60 |         goto LABEL_0x4011cb; | ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long long v2;  // rbx\n  unsigned long long v7;  // rbx\n  unsigned long long v8;  // rbp\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  unsigned long long v12; // rbx\n  unsigned long long v14; // rbx\n  unsigned long long v15; // rbp\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  v2 = v1;\n  if ((char)((unsigned int)v1 & -8) == 240) {\n    v12 = ((unsigned int)v1 & 15) * 0x40000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v14 = v12 + (getc(stdin @GLIBC_2.2.5) & 127) * 64;\n    v15 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v14 + v15 * 0x1000;\n    if ((unsigned int)v9 <= 65535)\n      return 4294967295;\n    return v14 + v15 * 0x1000;\n  } else if ((char)((unsigned int)v1 & -0x10) == 224) {\n    v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v8 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v7 + v8 * 64;\n    if ((unsigned int)v9 <= 2047)\n      return 4294967295;\n    return v7 + v8 * 64;\n  } else if ((char)((unsigned int)v1 & -32) == 192) {\n    v9 = (getc(stdin @GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) * 64;\n    if ((unsigned int)v9 <= 127)\n      return 4294967295;\n    return v9;\n  } else {\n    v9 = ((char)v2 < 0 ? (char)v2 : 4294967295);\n    return v9;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:119:34: error: expected ')'\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:119:28: note: to match this '('\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:123:62: error: expected ')'\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:123:56: note: to match this '('\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:124:32: error: expected ')'\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                                ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:124:26: note: to match this '('\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                          ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:125:25: error: expected ')'\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                         ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:125:19: note: to match this '('\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                   ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:133:60: error: expected ')'\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                            ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:133:54: note: to match this '('\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                      ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:134:24: error: expected ')'\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                        ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:134:18: note: to match this '('\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                  ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:142:25: error: expected ')'\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                         ^\n/tmp/tmpck3fyl50/decode_regular_key_pressed.c:142:19: note: to match this '('\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long v2;       // rbx, Other Possible Types: unsigned long long\n  unsigned long long v4;  // rax\n  unsigned long long v5;  // rax\n  unsigned long long v7;  // rax\n  unsigned int v8;        // ebx\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  if ((unsigned int)v1 == 10)\n    return 1444872238;\n  v2 = v1;\n  if ((unsigned int)v1 > 27) {\n    if ((unsigned int)v1 != 127)\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    else\n      return 1444872240;\n  } else {\n    if ((unsigned int)v1 < -1) {\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    } else {\n      switch ((unsigned int)v1) {\n      case -1:\n        return 4;\n      case 0:\n        return 1444872243;\n      case 8:\n        return 1444872241;\n      case 9:\n        return 0x561f0000;\n      case 23:\n        return 1444872242;\n      case 27:\n        (unsigned int)v4 = getc(stdin @GLIBC_2.2.5);\n        if ((unsigned int)v4 == 79) {\n          (unsigned int)v5 = getc(stdin @GLIBC_2.2.5);\n          v2 = ((unsigned int)(v5 - 80) <= 3 ? 4294967295 : v5 + 1444872114);\n          return v2;\n        } else if ((unsigned int)v4 == 91) {\n          switch (getc(stdin @GLIBC_2.2.5)) {\n          case 49:\n            v8 = getc(stdin @GLIBC_2.2.5);\n            (unsigned int)v9 = getc(stdin @GLIBC_2.2.5);\n            if (v8 == 59 && (unsigned int)v9 == 53) {\n              (char)v10 = getc(stdin @GLIBC_2.2.5);\n              if ((char)v10 == 67) {\n                return 1444872236;\n              } else if ((char)v10 > 67) {\n                v2 = ((char)v10 != 68 ? 1444872237 : 4294967295);\n                return v2;\n              } else if ((char)v10 == 65) {\n                return 1444872234;\n              } else {\n                v2 = ((char)v10 != 66 ? 1444872235 : 4294967295);\n                return v2;\n              }\n            }\n            if (!(v8 != 54 && (unsigned int)v9 == 126 && v8 <= 57))\n              return 4294967295;\n            v2 = v8 - (54 < v8) + 1444872145;\n            return v2;\n          case 50:\n            (unsigned int)v7 = getc(stdin @GLIBC_2.2.5);\n            if ((unsigned int)v7 == 126)\n              return 1444872244;\n            if (!((unsigned int)v7 <= 52 && (unsigned int)v7 != 50))\n              return 4294967295;\n            v2 = (unsigned int)v7 - ((unsigned int)v7 > 50) + 1444872154;\n            if (getc(stdin @GLIBC_2.2.5) != 126) {\n              v2 = 4294967295;\n              break;\n            } else {\n              break;\n            }\n            return v2;\n          case 51:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872239 : 4294967295);\n            return v2;\n          case 53:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872246 : 4294967295);\n            return v2;\n          case 54:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872247 : 4294967295);\n            return v2;\n          case 55:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872245 : 4294967295);\n            return v2;\n          case 56:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872248 : 4294967295);\n            return v2;\n          case 65:\n            return 1444872230;\n          case 66:\n            return 1444872231;\n          case 67:\n            return 1444872232;\n          case 68:\n            return 1444872233;\n          case 70:\n            return 1444872248;\n          case 72:\n            return 1444872245;\n          default:\n            return 4294967295;\n          }\n        } else {\n          ungetc(v4, stdin @GLIBC_2.2.5);\n          return v2;\n        }\n      default:\n        ungetc(v2, stdin @GLIBC_2.2.5);\n      }\n    }\n  }\n  v2 = decode_regular_key_pressed();\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:196:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 196 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:196:21: error: expected ';' after top\nlevel declarator 196 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:209:34: error: expected ')'\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:209:28: note: to match this '('\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:216:29: error: expected ')'\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:216:19: note: to match this '('\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:224:29: error: expected ')'\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:224:19: note: to match this '('\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:241:46: error: expected ')'\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                              ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:241:40: note: to match this '('\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                        ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:244:50: error: expected ')'\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                                  ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:244:44: note: to match this '('\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                            ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:250:39: error: expected ')'\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                       ^\n/tmp/tmpk1nzf8gg/decode_key_pressed.c:250:33: note: to match this '('\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                 ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  v1 = 1;\n  if ((unsigned int)a0 > 31)\n    v1 = ((unsigned int)a0 & 0x56000000) == 0x56000000;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_403007;\nextern char g_40301c;\nextern char g_403023;\nextern char g_403027;\nextern char g_403031;\nextern char g_403034;\nextern char g_403037;\nextern char g_40303a;\nextern char g_40303d;\nextern char g_403040;\nextern char g_403043;\nextern char g_403046;\nextern char g_403049;\nextern char g_40304c;\nextern char g_403050;\nextern char g_403054;\nextern char g_403058;\nextern char g_40305c;\nextern char g_403060;\nextern char g_403064;\nextern char g_403068;\nextern char g_40306f;\nextern char g_403078;\nextern char g_403082;\nextern char g_40308b;\nextern char g_403092;\nextern char g_403097;\nextern char g_40309e;\nextern char g_4030a7;\nextern char g_4030ab;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  v2 = a0 - 0x561f0000;\n  if ((unsigned int)v2 > 56)\n    return \"unknown\";\n  if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rax,\n                                           0x38 < 64 >, cc_ndep))\n    goto LABEL_0x4012f5;\n  else\n    goto LABEL_0x40130f;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbg722k72/get_key_name_name_conflict.c:57:15: error: expected expression\n   57 |     if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rax,\n0x38<64>, cc_ndep)) |               ^ /tmp/tmpbg722k72/get_key_name_name_conflict.c:58:14:\nerror: use of undeclared label 'LABEL_0x4012f5' 58 |         goto\nLABEL_0x4012f5; |              ^ /tmp/tmpbg722k72/get_key_name_name_conflict.c:60:14: error:\nuse of undeclared label 'LABEL_0x40130f' 60 |         goto LABEL_0x40130f; | ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long long v2;  // rbx\n  unsigned long long v7;  // rbx\n  unsigned long long v8;  // rbp\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  unsigned long long v12; // rbx\n  unsigned long long v14; // rbx\n  unsigned long long v15; // rbp\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  v2 = v1;\n  if ((char)((unsigned int)v1 & -8) == 240) {\n    v12 = ((unsigned int)v1 & 15) * 0x40000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v14 = v12 + (getc(stdin @GLIBC_2.2.5) & 127) * 64;\n    v15 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v14 + v15 * 0x1000;\n    if ((unsigned int)v9 <= 65535)\n      return 4294967295;\n    return v14 + v15 * 0x1000;\n  } else if ((char)((unsigned int)v1 & -0x10) == 224) {\n    v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v8 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v7 + v8 * 64;\n    if ((unsigned int)v9 <= 2047)\n      return 4294967295;\n    return v7 + v8 * 64;\n  } else if ((char)((unsigned int)v1 & -32) == 192) {\n    v9 = (getc(stdin @GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) * 64;\n    if ((unsigned int)v9 <= 127)\n      return 4294967295;\n    return v9;\n  } else {\n    v9 = ((char)v2 < 0 ? (char)v2 : 4294967295);\n    return v9;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:119:34: error: expected ')'\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:119:28: note: to match this '('\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:123:62: error: expected ')'\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:123:56: note: to match this '('\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:124:32: error: expected ')'\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                                ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:124:26: note: to match this '('\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                          ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:125:25: error: expected ')'\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                         ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:125:19: note: to match this '('\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                   ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:133:60: error: expected ')'\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                            ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:133:54: note: to match this '('\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                      ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:134:24: error: expected ')'\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                        ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:134:18: note: to match this '('\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                  ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:142:25: error: expected ')'\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                         ^\n/tmp/tmp4no4gnhu/decode_regular_key_pressed.c:142:19: note: to match this '('\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long v2;       // rbx, Other Possible Types: unsigned long long\n  unsigned long long v4;  // rax\n  unsigned long long v5;  // rax\n  unsigned long long v7;  // rax\n  unsigned int v8;        // ebx\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  if ((unsigned int)v1 == 10)\n    return 1444872238;\n  v2 = v1;\n  if ((unsigned int)v1 > 27) {\n    if ((unsigned int)v1 != 127)\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    else\n      return 1444872240;\n  } else {\n    if ((unsigned int)v1 < -1) {\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    } else {\n      switch ((unsigned int)v1) {\n      case -1:\n        return 4;\n      case 0:\n        return 1444872243;\n      case 8:\n        return 1444872241;\n      case 9:\n        return 0x561f0000;\n      case 23:\n        return 1444872242;\n      case 27:\n        (unsigned int)v4 = getc(stdin @GLIBC_2.2.5);\n        if ((unsigned int)v4 == 79) {\n          (unsigned int)v5 = getc(stdin @GLIBC_2.2.5);\n          v2 = ((unsigned int)(v5 - 80) <= 3 ? 4294967295 : v5 + 1444872114);\n          return v2;\n        } else if ((unsigned int)v4 == 91) {\n          switch (getc(stdin @GLIBC_2.2.5)) {\n          case 49:\n            v8 = getc(stdin @GLIBC_2.2.5);\n            (unsigned int)v9 = getc(stdin @GLIBC_2.2.5);\n            if (v8 == 59 && (unsigned int)v9 == 53) {\n              (char)v10 = getc(stdin @GLIBC_2.2.5);\n              if ((char)v10 == 67) {\n                return 1444872236;\n              } else if ((char)v10 > 67) {\n                v2 = ((char)v10 != 68 ? 1444872237 : 4294967295);\n                return v2;\n              } else if ((char)v10 == 65) {\n                return 1444872234;\n              } else {\n                v2 = ((char)v10 != 66 ? 1444872235 : 4294967295);\n                return v2;\n              }\n            }\n            if (!(v8 != 54 && (unsigned int)v9 == 126 && v8 <= 57))\n              return 4294967295;\n            v2 = v8 - (54 < v8) + 1444872145;\n            return v2;\n          case 50:\n            (unsigned int)v7 = getc(stdin @GLIBC_2.2.5);\n            if ((unsigned int)v7 == 126)\n              return 1444872244;\n            if (!((unsigned int)v7 <= 52 && (unsigned int)v7 != 50))\n              return 4294967295;\n            v2 = (unsigned int)v7 - ((unsigned int)v7 > 50) + 1444872154;\n            if (getc(stdin @GLIBC_2.2.5) != 126) {\n              v2 = 4294967295;\n              break;\n            } else {\n              break;\n            }\n            return v2;\n          case 51:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872239 : 4294967295);\n            return v2;\n          case 53:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872246 : 4294967295);\n            return v2;\n          case 54:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872247 : 4294967295);\n            return v2;\n          case 55:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872245 : 4294967295);\n            return v2;\n          case 56:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872248 : 4294967295);\n            return v2;\n          case 65:\n            return 1444872230;\n          case 66:\n            return 1444872231;\n          case 67:\n            return 1444872232;\n          case 68:\n            return 1444872233;\n          case 70:\n            return 1444872248;\n          case 72:\n            return 1444872245;\n          default:\n            return 4294967295;\n          }\n        } else {\n          ungetc(v4, stdin @GLIBC_2.2.5);\n          return v2;\n        }\n      default:\n        ungetc(v2, stdin @GLIBC_2.2.5);\n      }\n    }\n  }\n  v2 = decode_regular_key_pressed();\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdts844tr/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpdts844tr/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpdts844tr/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpdts844tr/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpdts844tr/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpdts844tr/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpdts844tr/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpdts844tr/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmpdts844tr/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpdts844tr/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmpdts844tr/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpdts844tr/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpdts844tr/decode_key_pressed.c:196:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 196 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpdts844tr/decode_key_pressed.c:196:21: error: expected ';' after top\nlevel declarator 196 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmpdts844tr/decode_key_pressed.c:209:34: error: expected ')'\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpdts844tr/decode_key_pressed.c:209:28: note: to match this '('\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpdts844tr/decode_key_pressed.c:216:29: error: expected ')'\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmpdts844tr/decode_key_pressed.c:216:19: note: to match this '('\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmpdts844tr/decode_key_pressed.c:224:29: error: expected ')'\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmpdts844tr/decode_key_pressed.c:224:19: note: to match this '('\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmpdts844tr/decode_key_pressed.c:241:46: error: expected ')'\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                              ^\n/tmp/tmpdts844tr/decode_key_pressed.c:241:40: note: to match this '('\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                        ^\n/tmp/tmpdts844tr/decode_key_pressed.c:244:50: error: expected ')'\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                                  ^\n/tmp/tmpdts844tr/decode_key_pressed.c:244:44: note: to match this '('\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                            ^\n/tmp/tmpdts844tr/decode_key_pressed.c:250:39: error: expected ')'\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                       ^\n/tmp/tmpdts844tr/decode_key_pressed.c:250:33: note: to match this '('\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                 ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  v1 = 1;\n  if ((unsigned int)a0 > 31)\n    v1 = ((unsigned int)a0 & 0x56000000) == 0x56000000;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(compute_completion_ranges)(long long, long long, long long,\n                                     long long);\n\nextern char completions;\nextern unsigned long long current_num_completions;\nextern char line.1;\n\nlong long search_completion_name_conflict(unsigned long long a0, unsigned long long a1) {\n  char v0;               // [bp-0x18]\n  int tmp_27;            // tmp #27\n  int tmp_23;            // tmp #23\n  char v1;               // [bp-0x10]\n  unsigned long long v3; // rbx\n  unsigned int *v4;      // rcx\n  unsigned long long v5; // rdx\n  unsigned long long v6; // rdx\n  unsigned long long v8; // rax\n  unsigned long v9;      // rax, Other Possible Types: unsigned long long\n  unsigned int *v10;     // rsi\n  unsigned int *v11;     // rax, Other Possible Types: unsigned long\n  unsigned int v12;      // edx\n\n  v3 = a1;\n  compute_completion_ranges(a0, a1, &v1, &v0);\n  v4 = *((long long *)&v1);\n  if (!((unsigned int)v3 && v4))\n    return 0;\n  v5 = v4 - &completions;\n  tmp_27 = v5 >> 1;\n  v6 = v5 >> 2;\n  if (((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x24 < 64 >, rdx, t27,\n                                            cc_ndep)\n           ? v6\n           : v6 + 4095) >>\n          12 ==\n      current_num_completions - 1)\n    return &v4[v3];\n  v11 = *(v4);\n  if ((unsigned int)v11) {\n    v8 = *((long long *)&v0) - (char *)v4;\n    tmp_23 = v8 >> 1;\n    v9 = v8 >> 2;\n    if ((char)[D] amd64g_calculate_condition(0x8 < 64 >, 0x24 < 64 >, rax, t23,\n                                             cc_ndep))\n      v9 += 4095;\n    v10 = &v4[0x1000 + (v9 & -0x1000) + v3];\n    v11 = 0;\n    while (true) {\n      v12 = v4[v11 + v3];\n      if (v12 != v10[v11])\n        break;\n      *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      if (v4[1 + v11]) {\n        v11 += 1;\n      } else {\n        v11 = (unsigned int)v11 + 1;\n        break;\n      }\n    }\n  }\n  *((int *)&(&line.1)[4 * v11]) = 0;\n  return &line.1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:20:17: error: expected ';' after top level\ndeclarator 20 | extern char line.1; |                 ^ |                 ;\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:43:13: error: 'unsigned int *' and 'char *'\nare not pointers to compatible types 43 |     v5 = v4 - &completions; | ~~ ^\n~~~~~~~~~~~~ /tmp/tmpbd6m4b4y/search_completion_name_conflict.c:46:16: error: expected\nexpression 46 |     if (((char)[D] amd64g_calculate_condition(0x9<64>, 0x24<64>,\nrdx, t27, cc_ndep) ? v6 : v6 + 4095) >> 12 == current_num_completions - 1) | ^\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:51:34: error: invalid operands to binary\nexpression ('long long' and 'char *') 51 |         v8 = *((long long *)&v0) -\n(char *)v4; |              ~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:54:19: error: expected expression\n   54 |         if ((char)[D] amd64g_calculate_condition(0x8<64>, 0x24<64>, rax,\nt23, cc_ndep)) |                   ^ /tmp/tmpbd6m4b4y/search_completion_name_conflict.c:60:21:\nerror: array subscript is not an integer 60 |             v12 = v4[v11 + v3]; |\n^~~~~~~~~ /tmp/tmpbd6m4b4y/search_completion_name_conflict.c:61:27: error: array subscript is\nnot an integer 61 |             if (v12 != v10[v11]) | ^~~~\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:63:38: error: expected ')'\n   63 |             *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      |                                      ^\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:63:32: note: to match this '('\n   63 |             *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      |                                ^\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:63:44: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 63 |             *((unsigned int\n*)&(&line.1)[4 * v11]) = v12; |                                          ~ ^ ~~~\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:64:19: error: array subscript is not an\ninteger 64 |             if (v4[1 + v11]) |                   ^~~~~~~~\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:75:21: error: expected ')'\n   75 |     *((int *)&(&line.1)[4 * v11]) = 0;\n      |                     ^\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:75:15: note: to match this '('\n   75 |     *((int *)&(&line.1)[4 * v11]) = 0;\n      |               ^\n/tmp/tmpbd6m4b4y/search_completion_name_conflict.c:75:27: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 75 |     *((int *)&(&line.1)[4 * v11]) =\n0; |                         ~ ^ ~~~ /tmp/tmpbd6m4b4y/search_completion_name_conflict.c:76:17:\nerror: expected ';' after return statement 76 |     return &line.1; | ^ | ; 13\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_stopkey_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  v2 = ((unsigned int)(a0 - 32) <= 59\n            ? 0\n            : (int)(576460752303472641 >> ((char)(a0 - 32) & 63)) & 1) &\n       1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sighandler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(echo_disable)();\nlong long(print_prompt)(long long);\nlong long(decode_key_pressed)();\nlong long(is_special)(long long);\nlong long(echo_enable)();\nlong long(putc_utf8)(long long);\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(is_stopkey)(long long);\nlong long(trans_utf8)(long long, long long);\nlong long(search_completion)(long long, long long);\nlong long(print_all_completions)(long long, long long);\n\nextern unsigned int cursorpos;\nextern char g_4032b8;\nextern char g_4032c8;\nextern char g_4032e6;\nextern char g_4032ec;\nextern char g_4032f2;\nextern char g_403311;\nextern char g_40331b;\nextern char g_40a13c;\nextern void *gprompt;\nextern char history;\nextern unsigned int last_history_entry;\nextern unsigned int line;\nextern unsigned int line_len;\nextern unsigned long long line_t.0;\nextern unsigned long long total_history_entries;\n\nlong long getline_complete_name_conflict(unsigned long a0) {\n  int tmp_22;             // tmp #22\n  unsigned int *v0;       // [bp-0x58]\n  int tmp_19;             // tmp #19\n  int tmp_21;             // tmp #21\n  int tmp_34;             // tmp #34\n  int tmp_18;             // tmp #18\n  unsigned long long v1;  // [bp-0x50]\n  unsigned int v2;        // [bp-0x44]\n  unsigned int v3;        // [bp-0x40]\n  unsigned int v4;        // [bp-0x3c]\n  unsigned long long v6;  // r14\n  unsigned long long v8;  // r15\n  unsigned long v9;       // rbx\n  unsigned int *v10;      // rax\n  unsigned int v11;       // r12d\n  char v13;               // al\n  unsigned int v14;       // ecx\n  unsigned long v15;      // rbx\n  unsigned long v16;      // rbx\n  char v17;               // al\n  unsigned int v18;       // esi\n  unsigned long long v19; // rax\n  unsigned int *v20; // rbx, Other Possible Types: unsigned int, unsigned long\n  unsigned int *v21; // rbp, Other Possible Types: unsigned long\n  unsigned long v22; // rbx\n  char v23;          // al\n  unsigned int *v24; // rcx\n  unsigned long v25; // rbx\n  char v26;          // al\n  unsigned int *v27; // rcx\n  unsigned int *v28; // rbx\n  unsigned int v29;  // eax\n  unsigned int v30;  // ebx\n  unsigned int *v31; // rbp, Other Possible Types: unsigned long\n  unsigned long long v32; // rcx\n  unsigned long v33;      // rdx, Other Possible Types: unsigned long long\n  unsigned int *v35;      // rax, Other Possible Types: unsigned long\n  unsigned int *v36;      // rdi\n  unsigned int v37;       // eax\n  unsigned int *v38;      // rax\n  unsigned int *v39;      // rbp, Other Possible Types: unsigned long\n  unsigned long v40;      // rdi, Other Possible Types: unsigned long long\n  unsigned long v41;      // rbx\n  unsigned int *v42;      // rax\n  unsigned int *v43;      // rax\n  void *v44; // r13, Other Possible Types: unsigned long, unsigned long long,\n             // unsigned int *\n  unsigned int v45;       // ebx\n  unsigned int *v46;      // rbx, Other Possible Types: unsigned long\n  unsigned long v47;      // rdi, Other Possible Types: unsigned long long\n  unsigned int *v48;      // rbp, Other Possible Types: unsigned long\n  unsigned int v49;       // ebx\n  unsigned long v50;      // rax\n  unsigned int *v51;      // rdi\n  unsigned int v52;       // ebx\n  unsigned int *v53;      // rbp, Other Possible Types: unsigned long\n  unsigned int *v54;      // rbp, Other Possible Types: unsigned long\n  void *v55;              // rax, Other Possible Types: unsigned long\n  unsigned long long v56; // rbp\n  unsigned long long v57; // rax\n  void *v58;              // rbp\n\n  v1 = a0;\n  memset(&line, 0, 0x4000);\n  gprompt = a0;\n  v6 = __sysv_signal(2, sighandler);\n  line_len = 0;\n  cursorpos = 0;\n  v2 = ((unsigned int)v6 < 200 ? 0 : last_history_entry + 1);\n  echo_disable();\n  printf(&g_4032c8);\n  print_prompt(gprompt);\n  v44 = 0;\n  while (true) {\n    v8 = decode_key_pressed();\n    if ((unsigned int)v8 == -1) {\n      puts(\"\\nInvalid input sequence!\");\n      printf(&g_403311);\n    }\n    if (!(char)is_special(v8)) {\n      putc_utf8(v8);\n      v9 = cursorpos;\n      v10 = cursorpos * 4;\n      memmove(&line + v10 + 4, v10 + &line, (line_len - cursorpos) * 4);\n      (&line)[v9] = v8;\n      cursorpos = (unsigned int)v9 + 1;\n      line_len = line_len + 1;\n      goto LABEL_40222f;\n    }\n    if ((unsigned int)v8 == 1444872237) {\n      v11 = cursorpos;\n      if (cursorpos) {\n        v15 = cursorpos - 1;\n        do {\n          v13 = (char)is_stopkey((&line)[v15]) ^ 1;\n          tmp_22 = (unsigned int)v15;\n          v14 = v15;\n          v15 -= 1;\n        } while ((tmp_22 & v13));\n        cursorpos = v14;\n        printf(&g_4032e6, v11 - cursorpos);\n        goto LABEL_4020bf;\n      }\n    } else if ((unsigned int)v8 == 1444872236) {\n      if (cursorpos < line_len) {\n        v16 = cursorpos + 1;\n        *((unsigned int *)&v0) = v44;\n        do {\n          tmp_19 = (unsigned int)v16 < line_len;\n          v17 = (char)is_stopkey((&line)[v16]) ^ 1;\n          v18 = v16;\n          v16 += 1;\n        } while ((v17 & tmp_19));\n        v44 = (int)v0;\n        cursorpos = v18;\n        printf(&g_4032ec, 1);\n      }\n      if ((unsigned int)v8 == 1444872245 && cursorpos) {\n        printf(&g_4032e6, cursorpos);\n        cursorpos = 0;\n        goto LABEL_4022ba;\n      }\n    LABEL_4021e5:\n      if ((unsigned int)v8 == 1444872248 && cursorpos != line_len) {\n        printf(&g_4032ec, line_len - cursorpos);\n        cursorpos = line_len;\n        goto LABEL_402206;\n      }\n    LABEL_4020de:\n      if ((unsigned int)v8 == 1444872240) {\n        if (!cursorpos)\n          goto LABEL_402206;\n        line_len = line_len - 1;\n        cursorpos = cursorpos - 1;\n        printf(&g_4032e6, 1);\n      } else {\n        if (!((unsigned int)v8 == 1444872239))\n          goto LABEL_4022ba;\n        if (cursorpos < line_len) {\n          line_len = line_len - 1;\n        } else {\n        LABEL_402222:\n          if ((unsigned int)v8 == 0x561f0000) {\n            if (!cursorpos) {\n              v44 = (unsigned int)v44 + 1;\n            } else {\n              v35 = cursorpos;\n              do {\n                tmp_21 = *((int *)&(&g_40a13c)[4 * v35]) != 32;\n                v36 = v35;\n                v35 -= 1;\n              } while ((cursorpos & tmp_21));\n              v38 = search_completion((char *)&line + 0x4 * v36,\n                                      cursorpos - (char *)v36);\n              v39 = v38;\n              if (v38) {\n                printf(&g_4032f2);\n                v40 = *(v38);\n                if ((unsigned int)v40) {\n                  *((unsigned int *)&v0) = v44;\n                  do {\n                    putc_utf8(v40);\n                    v41 = cursorpos;\n                    v42 = cursorpos * 4;\n                    memmove(&line + v42 + 4, v42 + &line,\n                            (line_len - cursorpos) * 4);\n                    (&line)[v41] = *((int *)v39);\n                    cursorpos = (unsigned int)v41 + 1;\n                    line_len = line_len + 1;\n                    v39 += 4;\n                    v40 = *((int *)v39);\n                  } while ((unsigned int)v40);\n                  v44 = (int)v0;\n                }\n                v45 = cursorpos;\n                if (cursorpos != line_len) {\n                  v48 = &(&line)[cursorpos];\n                  do {\n                    putc_utf8(*((int *)v48));\n                    v45 += 1;\n                    v48 += 4;\n                  } while (line_len != v45);\n                  printf(&g_4032e6, v45 - cursorpos);\n                }\n              }\n              v44 = (unsigned int)v44 + 1;\n            }\n            if ((unsigned int)v44 > 1) {\n              printf(&g_4032b8, 1);\n              puts(\"\\npossible completions are:\");\n              printf(&g_4032b8, 0);\n              v49 = cursorpos;\n              v50 = cursorpos;\n              if (!cursorpos) {\n                print_all_completions(&line, 0);\n                print_prompt(v1);\n                if (!line_len) {\n                  v49 = line_len;\n                } else {\n                  v53 = &line;\n                  do {\n                    putc_utf8(*((int *)v53));\n                    v49 += 1;\n                    v53 += 4;\n                  } while (line_len != v49);\n                }\n                if (cursorpos != v49) {\n                  printf(&g_4032e6, v49 - cursorpos);\n                  continue;\n                }\n              } else {\n                do {\n                  tmp_22 = *((int *)&(&g_40a13c)[4 * v50]) != 32;\n                  tmp_34 = (unsigned int)v50;\n                  v51 = v50;\n                  v50 -= 1;\n                } while ((tmp_34 & tmp_22));\n                print_all_completions((char *)&line + 0x4 * v51,\n                                      cursorpos - (char *)v51);\n                print_prompt(v1);\n                v52 = line_len;\n                if (line_len) {\n                  v54 = &line;\n                  do {\n                    putc_utf8(*((int *)v54));\n                    v52 = 1;\n                    v54 += 4;\n                  } while (line_len != 1);\n                }\n                if (cursorpos != v52)\n                  printf(&g_4032e6, v52 - cursorpos);\n              }\n            }\n            continue;\n          }\n          goto LABEL_40222f;\n        }\n      }\n      v19 = (cursorpos + 1) * 4;\n      memmove(-4 + (char *)&line + v19, v19 + (char *)&line,\n              (line_len - cursorpos) * 4);\n      printf(&g_4032f2);\n      v20 = cursorpos;\n      if (cursorpos == line_len) {\n      LABEL_402206:\n        if (!(total_history_entries) || !((unsigned int)(v8 - 1444872230) <= 1))\n          goto LABEL_402222;\n        v32 = v2;\n        v33 = v32 - 1;\n        if ((unsigned int)v8 != 1444872230)\n          v33 = (unsigned int)v32 + 1;\n        if ((unsigned int)v33 >= (unsigned int)total_history_entries) {\n          v2 = 0;\n        } else {\n          v37 = (unsigned int)total_history_entries - 1;\n          if ((char)(v33 >> 31 & 1 ^ 1))\n            v37 = v33;\n          v2 = v37;\n        }\n        if (cursorpos)\n          printf(&g_4032e6, cursorpos);\n        printf(&g_4032f2);\n        cursorpos = 0;\n        line_len = 0;\n        v43 = v2 * 0x4000;\n        v44 = *((int *)(&history + v43));\n        if (!(unsigned int)v44)\n          continue;\n        v46 = v43 + &history;\n        v47 = v44;\n        do {\n          putc_utf8(v47);\n          (&line)[cursorpos] = *((int *)v46);\n          cursorpos = cursorpos + 1;\n          line_len = line_len + 1;\n          v46 += 4;\n          v47 = *((int *)v46);\n        } while ((unsigned int)v47);\n      LABEL_40222f:\n        if ((unsigned int)v8 == 4 || (unsigned int)v8 == 1444872238) {\n          puts(&g_40331b);\n          printf(&g_403311);\n          echo_enable();\n          __sysv_signal(2, v6);\n          memset(&(&line)[line_len], 0, (0x1000 - line_len) * 4);\n          if (memcmp(&line,\n                     &(&history)[0x4000 * *((long long *)&last_history_entry)],\n                     0x4000)) {\n            v55 = *((long long *)&last_history_entry) + 1;\n            if (*((long long *)&last_history_entry) == 199)\n              v55 = 0;\n            *((unsigned long *)&last_history_entry) = v55;\n            v56 = v55;\n            v57 = v55 + 1;\n            if (total_history_entries < total_history_entries)\n              total_history_entries = v57;\n            v58 = &(&history)[0x4000 * v56];\n            memset(v58, 0, 0x4000);\n            memcpy(v58, &line, line_len * 4);\n            break;\n          }\n        } else {\n          v44 = 0;\n        }\n      } else {\n        v21 = (char *)&line + 0x4 * v20;\n        do {\n          putc_utf8(*((int *)v21));\n          v20 = (unsigned int)v20 + 1;\n          v21 += 4;\n        } while (line_len != v20);\n        printf(&g_4032e6, v20 - cursorpos);\n      LABEL_4022ba:\n        if ((unsigned int)v8 == 1444872242) {\n          v4 = cursorpos;\n          v3 = line_len;\n          v22 = cursorpos;\n          do {\n            tmp_18 = (unsigned int)v22;\n            v23 = (char)is_stopkey((&line)[v22]) ^ 1;\n            v24 = v22;\n            v22 -= 1;\n          } while ((v23 & tmp_18));\n          v0 = v24;\n          v25 = cursorpos + (line_len != cursorpos);\n          do {\n            tmp_19 = (unsigned int)v25 < v3;\n            v26 = (char)is_stopkey((&line)[v25]) ^ 1;\n            v27 = v25;\n            v25 += 1;\n          } while ((v26 & tmp_19));\n          v28 = v0;\n          memmove((char *)&line + 0x4 * v28, (char *)&line + 0x4 * v27,\n                  (v3 - (char *)v27) * 4);\n          v29 = v4;\n          if ((unsigned int)v28 < v29) {\n            printf(&g_4032e6, v29 - cursorpos);\n            cursorpos = (unsigned int)v0;\n          }\n          line_len = line_len - ((unsigned int)v27 - (int)v0);\n          printf(&g_4032f2);\n          v30 = cursorpos;\n          if (cursorpos != line_len) {\n            v31 = &(&line)[cursorpos];\n            do {\n              putc_utf8(*((int *)v31));\n              v30 += 1;\n              v31 += 4;\n            } while (line_len != v30);\n            printf(&g_4032e6, v30 - cursorpos);\n            goto LABEL_402206;\n          }\n        }\n      }\n    } else {\n      if ((unsigned int)v8 == 1444872233 && cursorpos) {\n        printf(&g_4032e6, 1);\n        cursorpos = cursorpos - 1;\n        goto LABEL_4021e5;\n      }\n    LABEL_4020bf:\n      if ((unsigned int)v8 == 1444872232 && cursorpos < line_len) {\n        printf(&g_4032ec, 1);\n        cursorpos = cursorpos + 1;\n        goto LABEL_4020de;\n      }\n    }\n  }\n  if ((unsigned int)v8 == 4 && !line_len) {\n    __sysv_signal(2, v6);\n    gprompt = 0;\n    return 0;\n  }\n  gprompt = 0;\n  trans_utf8(&line_t.0, &line);\n  return &line_t.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:43:33: error: expected ';' after top level\ndeclarator 43 | extern unsigned long long line_t.0; | ^ | ;\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:133:27: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 133 | memmove(&line + v10 +\n4, v10 + &line, (line_len - cursorpos) * 4); |                     ~~~~~ ^ ~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:133:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 133 | memmove(&line + v10 +\n4, v10 + &line, (line_len - cursorpos) * 4); | ~~~ ^ ~~~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:218:66: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 218 | tmp_21 = *((int *)&(&g_40a13c)[4 *\nv35]) != 32; |                                                                ~\n^ ~~~ /tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:222:73: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 222 | v38 =\nsearch_completion((char *)&line + 0x4 * v36, cursorpos - (char *)v36); | ~~~ ^\n~~~ /tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:222:90: error: invalid operands to\nbinary expression ('unsigned int' and 'char *') 222 | v38 =\nsearch_completion((char *)&line + 0x4 * v36, cursorpos - (char *)v36); |\n~~~~~~~~~ ^ ~~~~~~~~~~~ /tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:236:55: error:\ninvalid operands to binary expression ('unsigned int *' and 'unsigned int *')\n  236 |                                         memmove(&line + v42 + 4, v42 +\n&line, (line_len - cursorpos) * 4); | ~~~~~ ^ ~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:236:70: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 236 | memmove(&line + v42 +\n4, v42 + &line, (line_len - cursorpos) * 4); | ~~~ ^ ~~~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:300:75: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 300 | print_all_completions((char\n*)&line + 0x4 * v51, cursorpos - (char *)v51); | ~~~ ^ ~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:300:92: error: invalid operands to binary\nexpression ('unsigned int' and 'char *') 300 | print_all_completions((char\n*)&line + 0x4 * v51, cursorpos - (char *)v51); | ~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:352:42: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 352 |                 v44 = *((int\n*)(&history + v43)); |                                 ~~~~~~~~ ^ ~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:355:27: error: invalid operands to binary\nexpression ('unsigned int *' and 'char *') 355 |                 v46 = v43 +\n&history; |                       ~~~ ^ ~~~~~~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:397:43: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 397 |                 v21 = (char\n*)&line + 0x4 * v20; |                                       ~~~ ^ ~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:428:49: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 428 |                     memmove((char\n*)&line + 0x4 * v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~~ ^\n~~~ /tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:428:76: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 428 | memmove((char *)&line + 0x4\n* v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~~ ^ ~~~\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:428:87: error: invalid operands to binary\nexpression ('unsigned int' and 'char *') 428 |                     memmove((char\n*)&line + 0x4 * v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~ ^\n~~~~~~~~~~~ /tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:477:23: error: expected ')' 477\n|     trans_utf8(&line_t.0, &line); |                       ^\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:477:15: note: to match this '('\n  477 |     trans_utf8(&line_t.0, &line);\n      |               ^\n/tmp/tmp4g3t7ilr/getline_complete_name_conflict.c:478:19: error: expected ';' after return\nstatement 478 |     return &line_t.0; |                   ^ | ; 18 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int completions;\nextern unsigned long long current_num_completions;\n\nlong long init_completion_name_conflict(char a0[2]) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  unsigned long v2; // rax\n  void *v3;         // rcx\n\n  if (current_num_completions == 0x800)\n    return 1;\n  v1 = a0[0];\n  v2 = 0;\n  if (!(char)v1) {\n    (&completions)[0x1000 * current_num_completions + v2] = 0;\n    current_num_completions = current_num_completions + 1;\n    return 0;\n  }\n  v3 = &(&completions)[0x1000 * current_num_completions];\n  v2 = 1;\n  while (true) {\n    *((unsigned int *)(-4 + (char *)v3 + 4 * v2)) = v1;\n    v1 = a0[v2];\n    if (!(char)v1)\n      break;\n    v2 += 1;\n    if (v2 == 0x1000) {\n      memset(v3, 0, 0x4000);\n      return 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint compl_eqcompar; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern unsigned long long completions;\nextern unsigned long long current_num_completions;\nextern struct_0 *memsize;\n\nlong long completion_exists_name_conflict(struct_0 *a0) {\n  int tmp_37;       // tmp #37\n  char v0;          // [bp-0x400c]\n  unsigned int v1;  // [bp-0x4008]\n  unsigned long v3; // rdx, Other Possible Types: unsigned long long\n  unsigned long v4; // rax\n  struct_0 *v5;     // rax, Other Possible Types: unsigned long\n  struct_0 *v6;     // r8, Other Possible Types: unsigned long\n\n  v3 = a0->field_0;\n  if (!(char)v3) {\n    v5 = 0;\n    v6 = 0;\n  } else {\n    v4 = 1;\n    do {\n      *((unsigned int *)&(&v0)[4 * v4]) = v3;\n      v3 = a0[v4].field_0;\n      tmp_37 = (unsigned int)v4 == 4095;\n      v6 = v4;\n      v4 += 1;\n    } while (!tmp_37 && (char)v3);\n    v5 = v6;\n  }\n  (&v1)[v5] = 0;\n  memsize = v6;\n  return lfind(&v1, &completions, &current_num_completions, 0x4000,\n               compl_eqcompar);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvh0wug4g/completion_exists_name_conflict.c:55:10: error: array subscript is not an\ninteger 55 |     (&v1)[v5] = 0; |          ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_403004;\nextern char g_403019;\nextern char g_403020;\nextern char g_403024;\nextern char g_40302e;\nextern char g_403031;\nextern char g_403034;\nextern char g_403037;\nextern char g_40303a;\nextern char g_40303d;\nextern char g_403040;\nextern char g_403043;\nextern char g_403046;\nextern char g_403049;\nextern char g_40304d;\nextern char g_403051;\nextern char g_403055;\nextern char g_403059;\nextern char g_40305d;\nextern char g_403061;\nextern char g_403065;\nextern char g_40306c;\nextern char g_403075;\nextern char g_40307f;\nextern char g_403088;\nextern char g_40308f;\nextern char g_403094;\nextern char g_40309b;\nextern char g_4030a4;\nextern char g_4030a8;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  v2 = a0 - 0x561f0000;\n  if ((unsigned int)v2 > 56)\n    return \"unknown\";\n  if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rax,\n                                           0x38 < 64 >, cc_ndep))\n    goto LABEL_0x401300;\n  else\n    goto LABEL_0x40131a;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx622wd7a/get_key_name_name_conflict.c:57:15: error: expected expression\n   57 |     if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rax,\n0x38<64>, cc_ndep)) |               ^ /tmp/tmpx622wd7a/get_key_name_name_conflict.c:58:14:\nerror: use of undeclared label 'LABEL_0x401300' 58 |         goto\nLABEL_0x401300; |              ^ /tmp/tmpx622wd7a/get_key_name_name_conflict.c:60:14: error:\nuse of undeclared label 'LABEL_0x40131a' 60 |         goto LABEL_0x40131a; | ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long long v2;  // rbx\n  unsigned long long v7;  // rbx\n  unsigned long long v8;  // rbp\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  unsigned long long v12; // rbx\n  unsigned long long v14; // rbx\n  unsigned long long v15; // rbp\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  v2 = v1;\n  if ((char)((unsigned int)v1 & -8) == 240) {\n    v12 = ((unsigned int)v1 & 15) * 0x40000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v14 = v12 + (getc(stdin @GLIBC_2.2.5) & 127) * 64;\n    v15 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v14 + v15 * 0x1000;\n    if ((unsigned int)v9 <= 65535)\n      return 4294967295;\n    return v14 + v15 * 0x1000;\n  } else if ((char)((unsigned int)v1 & -0x10) == 224) {\n    v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v8 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v7 + v8 * 64;\n    if ((unsigned int)v9 <= 2047)\n      return 4294967295;\n    return v7 + v8 * 64;\n  } else if ((char)((unsigned int)v1 & -32) == 192) {\n    v9 = (getc(stdin @GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) * 64;\n    if ((unsigned int)v9 <= 127)\n      return 4294967295;\n    return v9;\n  } else {\n    v9 = ((char)v2 < 0 ? (char)v2 : 4294967295);\n    return v9;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:119:34: error: expected ')'\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:119:28: note: to match this '('\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:123:62: error: expected ')'\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:123:56: note: to match this '('\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:124:32: error: expected ')'\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                                ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:124:26: note: to match this '('\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                          ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:125:25: error: expected ')'\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                         ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:125:19: note: to match this '('\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                   ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:133:60: error: expected ')'\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                            ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:133:54: note: to match this '('\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                      ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:134:24: error: expected ')'\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                        ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:134:18: note: to match this '('\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                  ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:142:25: error: expected ')'\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                         ^\n/tmp/tmpoq13y1vq/decode_regular_key_pressed.c:142:19: note: to match this '('\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long v2;       // rbx, Other Possible Types: unsigned long long\n  unsigned long long v4;  // rax\n  unsigned long long v5;  // rax\n  unsigned long long v7;  // rax\n  unsigned int v8;        // ebx\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  if ((unsigned int)v1 == 10)\n    return 1444872238;\n  v2 = v1;\n  if ((unsigned int)v1 > 27) {\n    if ((unsigned int)v1 != 127)\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    else\n      return 1444872240;\n  } else {\n    if ((unsigned int)v1 < -1) {\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    } else {\n      switch ((unsigned int)v1) {\n      case -1:\n        return 4;\n      case 0:\n        return 1444872243;\n      case 8:\n        return 1444872241;\n      case 9:\n        return 0x561f0000;\n      case 23:\n        return 1444872242;\n      case 27:\n        (unsigned int)v4 = getc(stdin @GLIBC_2.2.5);\n        if ((unsigned int)v4 == 79) {\n          (unsigned int)v5 = getc(stdin @GLIBC_2.2.5);\n          v2 = ((unsigned int)(v5 - 80) <= 3 ? 4294967295 : v5 + 1444872114);\n          return v2;\n        } else if ((unsigned int)v4 == 91) {\n          switch (getc(stdin @GLIBC_2.2.5)) {\n          case 49:\n            v8 = getc(stdin @GLIBC_2.2.5);\n            (unsigned int)v9 = getc(stdin @GLIBC_2.2.5);\n            if (v8 == 59 && (unsigned int)v9 == 53) {\n              (char)v10 = getc(stdin @GLIBC_2.2.5);\n              if ((char)v10 == 67) {\n                return 1444872236;\n              } else if ((char)v10 > 67) {\n                v2 = ((char)v10 != 68 ? 1444872237 : 4294967295);\n                return v2;\n              } else if ((char)v10 == 65) {\n                return 1444872234;\n              } else {\n                v2 = ((char)v10 != 66 ? 1444872235 : 4294967295);\n                return v2;\n              }\n            }\n            if (!(v8 != 54 && (unsigned int)v9 == 126 && v8 <= 57))\n              return 4294967295;\n            v2 = v8 - (54 < v8) + 1444872145;\n            return v2;\n          case 50:\n            (unsigned int)v7 = getc(stdin @GLIBC_2.2.5);\n            if ((unsigned int)v7 == 126)\n              return 1444872244;\n            if (!((unsigned int)v7 <= 52 && (unsigned int)v7 != 50))\n              return 4294967295;\n            v2 = (unsigned int)v7 - ((unsigned int)v7 > 50) + 1444872154;\n            if (getc(stdin @GLIBC_2.2.5) != 126) {\n              v2 = 4294967295;\n              break;\n            } else {\n              break;\n            }\n            return v2;\n          case 51:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872239 : 4294967295);\n            return v2;\n          case 53:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872246 : 4294967295);\n            return v2;\n          case 54:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872247 : 4294967295);\n            return v2;\n          case 55:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872245 : 4294967295);\n            return v2;\n          case 56:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872248 : 4294967295);\n            return v2;\n          case 65:\n            return 1444872230;\n          case 66:\n            return 1444872231;\n          case 67:\n            return 1444872232;\n          case 68:\n            return 1444872233;\n          case 70:\n            return 1444872248;\n          case 72:\n            return 1444872245;\n          default:\n            return 4294967295;\n          }\n        } else {\n          ungetc(v4, stdin @GLIBC_2.2.5);\n          return v2;\n        }\n      default:\n        ungetc(v2, stdin @GLIBC_2.2.5);\n      }\n    }\n  }\n  v2 = decode_regular_key_pressed();\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:196:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 196 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:196:21: error: expected ';' after top\nlevel declarator 196 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:209:34: error: expected ')'\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:209:28: note: to match this '('\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:216:29: error: expected ')'\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:216:19: note: to match this '('\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:224:29: error: expected ')'\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:224:19: note: to match this '('\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:241:46: error: expected ')'\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                              ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:241:40: note: to match this '('\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                        ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:244:50: error: expected ')'\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                                  ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:244:44: note: to match this '('\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                            ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:250:39: error: expected ')'\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                       ^\n/tmp/tmp_bzvhjkm/decode_key_pressed.c:250:33: note: to match this '('\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                 ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  v1 = 1;\n  if ((unsigned int)a0 > 31)\n    v1 = ((unsigned int)a0 & 0x56000000) == 0x56000000;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(compute_completion_ranges)(long long, long long, long long,\n                                     long long);\n\nextern char completions;\nextern unsigned long long current_num_completions;\nextern char line.1;\n\nlong long search_completion_name_conflict(unsigned long long a0, unsigned long long a1) {\n  char v0;               // [bp-0x18]\n  int tmp_27;            // tmp #27\n  int tmp_23;            // tmp #23\n  char v1;               // [bp-0x10]\n  unsigned long long v3; // rbx\n  unsigned int *v4;      // rcx\n  unsigned long long v5; // rdx\n  unsigned long long v6; // rdx\n  unsigned long long v8; // rax\n  unsigned long v9;      // rax, Other Possible Types: unsigned long long\n  unsigned int *v10;     // rsi\n  unsigned int *v11;     // rax, Other Possible Types: unsigned long\n  unsigned int v12;      // edx\n\n  v3 = a1;\n  compute_completion_ranges(a0, a1, &v1, &v0);\n  v4 = *((long long *)&v1);\n  if (!((unsigned int)v3 && v4))\n    return 0;\n  v5 = v4 - &completions;\n  tmp_27 = v5 >> 1;\n  v6 = v5 >> 2;\n  if (((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x24 < 64 >, rdx, t27,\n                                            cc_ndep)\n           ? v6\n           : v6 + 4095) >>\n          12 ==\n      current_num_completions - 1)\n    return &v4[v3];\n  v11 = *(v4);\n  if ((unsigned int)v11) {\n    v8 = *((long long *)&v0) - (char *)v4;\n    tmp_23 = v8 >> 1;\n    v9 = v8 >> 2;\n    if ((char)[D] amd64g_calculate_condition(0x8 < 64 >, 0x24 < 64 >, rax, t23,\n                                             cc_ndep))\n      v9 += 4095;\n    v10 = &v4[0x1000 + (v9 & -0x1000) + v3];\n    v11 = 0;\n    while (true) {\n      v12 = v4[v11 + v3];\n      if (v12 != v10[v11])\n        break;\n      *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      if (v4[1 + v11]) {\n        v11 += 1;\n      } else {\n        v11 = (unsigned int)v11 + 1;\n        break;\n      }\n    }\n  }\n  *((int *)&(&line.1)[4 * v11]) = 0;\n  return &line.1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:20:17: error: expected ';' after top level\ndeclarator 20 | extern char line.1; |                 ^ |                 ;\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:43:13: error: 'unsigned int *' and 'char *'\nare not pointers to compatible types 43 |     v5 = v4 - &completions; | ~~ ^\n~~~~~~~~~~~~ /tmp/tmp4b3_4j_g/search_completion_name_conflict.c:46:16: error: expected\nexpression 46 |     if (((char)[D] amd64g_calculate_condition(0x9<64>, 0x24<64>,\nrdx, t27, cc_ndep) ? v6 : v6 + 4095) >> 12 == current_num_completions - 1) | ^\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:51:34: error: invalid operands to binary\nexpression ('long long' and 'char *') 51 |         v8 = *((long long *)&v0) -\n(char *)v4; |              ~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:54:19: error: expected expression\n   54 |         if ((char)[D] amd64g_calculate_condition(0x8<64>, 0x24<64>, rax,\nt23, cc_ndep)) |                   ^ /tmp/tmp4b3_4j_g/search_completion_name_conflict.c:60:21:\nerror: array subscript is not an integer 60 |             v12 = v4[v11 + v3]; |\n^~~~~~~~~ /tmp/tmp4b3_4j_g/search_completion_name_conflict.c:61:27: error: array subscript is\nnot an integer 61 |             if (v12 != v10[v11]) | ^~~~\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:63:38: error: expected ')'\n   63 |             *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      |                                      ^\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:63:32: note: to match this '('\n   63 |             *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      |                                ^\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:63:44: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 63 |             *((unsigned int\n*)&(&line.1)[4 * v11]) = v12; |                                          ~ ^ ~~~\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:64:19: error: array subscript is not an\ninteger 64 |             if (v4[1 + v11]) |                   ^~~~~~~~\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:75:21: error: expected ')'\n   75 |     *((int *)&(&line.1)[4 * v11]) = 0;\n      |                     ^\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:75:15: note: to match this '('\n   75 |     *((int *)&(&line.1)[4 * v11]) = 0;\n      |               ^\n/tmp/tmp4b3_4j_g/search_completion_name_conflict.c:75:27: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 75 |     *((int *)&(&line.1)[4 * v11]) =\n0; |                         ~ ^ ~~~ /tmp/tmp4b3_4j_g/search_completion_name_conflict.c:76:17:\nerror: expected ';' after return statement 76 |     return &line.1; | ^ | ; 13\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_stopkey_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  v2 = ((unsigned int)(a0 - 32) <= 59\n            ? 0\n            : (int)(576460752303472641 >> ((char)(a0 - 32) & 63)) & 1) &\n       1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sighandler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(echo_disable)();\nlong long(print_prompt)(long long);\nlong long(decode_key_pressed)();\nlong long(is_special)(long long);\nlong long(echo_enable)();\nlong long(putc_utf8)(long long);\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(is_stopkey)(long long);\nlong long(trans_utf8)(long long, long long);\nlong long(search_completion)(long long, long long);\nlong long(print_all_completions)(long long, long long);\n\nextern unsigned int cursorpos;\nextern char g_4032b8;\nextern char g_4032c8;\nextern char g_4032e6;\nextern char g_4032ec;\nextern char g_4032f2;\nextern char g_403311;\nextern char g_40331b;\nextern char g_40a11c;\nextern void *gprompt;\nextern char history;\nextern unsigned int last_history_entry;\nextern unsigned int line;\nextern unsigned int line_len;\nextern unsigned long long line_t.0;\nextern unsigned long long total_history_entries;\n\nlong long getline_complete_name_conflict(unsigned long a0) {\n  int tmp_22;             // tmp #22\n  unsigned int *v0;       // [bp-0x58]\n  int tmp_19;             // tmp #19\n  int tmp_21;             // tmp #21\n  int tmp_34;             // tmp #34\n  int tmp_18;             // tmp #18\n  unsigned long long v1;  // [bp-0x50]\n  unsigned int v2;        // [bp-0x44]\n  unsigned int v3;        // [bp-0x40]\n  unsigned int v4;        // [bp-0x3c]\n  unsigned long long v6;  // r14\n  unsigned long long v8;  // r15\n  unsigned long v9;       // rbx\n  unsigned int *v10;      // rax\n  unsigned int v11;       // r12d\n  char v13;               // al\n  unsigned int v14;       // ecx\n  unsigned long v15;      // rbx\n  unsigned long v16;      // rbx\n  char v17;               // al\n  unsigned int v18;       // esi\n  unsigned long long v19; // rax\n  unsigned int *v20; // rbx, Other Possible Types: unsigned long, unsigned int\n  unsigned int *v21; // rbp, Other Possible Types: unsigned long\n  unsigned long v22; // rbx\n  char v23;          // al\n  unsigned int *v24; // rcx\n  unsigned long v25; // rbx\n  char v26;          // al\n  unsigned int *v27; // rcx\n  unsigned int *v28; // rbx\n  unsigned int v29;  // eax\n  unsigned int v30;  // ebx\n  unsigned int *v31; // rbp, Other Possible Types: unsigned long\n  unsigned long long v32; // rcx\n  unsigned long v33;      // rdx, Other Possible Types: unsigned long long\n  unsigned int *v35;      // rax, Other Possible Types: unsigned long\n  unsigned int *v36;      // rdi\n  unsigned int v37;       // eax\n  unsigned int *v38;      // rax\n  unsigned int *v39;      // rbp, Other Possible Types: unsigned long\n  unsigned long v40;      // rdi, Other Possible Types: unsigned long long\n  unsigned long v41;      // rbx\n  unsigned int *v42;      // rax\n  unsigned int *v43;      // rax\n  unsigned int *v44; // r13, Other Possible Types: unsigned long, unsigned long\n                     // long, void*\n  unsigned int v45;  // ebx\n  unsigned int *v46; // rbx, Other Possible Types: unsigned long\n  unsigned long v47; // rdi, Other Possible Types: unsigned long long\n  unsigned int *v48; // rbp, Other Possible Types: unsigned long\n  unsigned int v49;  // ebx\n  unsigned long v50; // rax\n  unsigned int *v51; // rdi\n  unsigned int v52;  // ebx\n  unsigned int *v53; // rbp, Other Possible Types: unsigned long\n  unsigned int *v54; // rbp, Other Possible Types: unsigned long\n  void *v55;         // rax, Other Possible Types: unsigned long\n  unsigned long long v56; // rbp\n  unsigned long long v57; // rax\n  void *v58;              // rbp\n\n  v1 = a0;\n  memset(&line, 0, 0x4000);\n  gprompt = a0;\n  v6 = __sysv_signal(2, sighandler);\n  line_len = 0;\n  cursorpos = 0;\n  v2 = ((unsigned int)v6 < 200 ? 0 : last_history_entry + 1);\n  echo_disable();\n  printf(&g_4032c8);\n  print_prompt(gprompt);\n  v44 = 0;\n  while (true) {\n    v8 = decode_key_pressed();\n    if ((unsigned int)v8 == -1) {\n      puts(\"\\nInvalid input sequence!\");\n      printf(&g_403311);\n    }\n    if (!(char)is_special(v8)) {\n      putc_utf8(v8);\n      v9 = cursorpos;\n      v10 = cursorpos * 4;\n      memmove(&line + v10 + 4, v10 + &line, (line_len - cursorpos) * 4);\n      (&line)[v9] = v8;\n      cursorpos = (unsigned int)v9 + 1;\n      line_len = line_len + 1;\n      goto LABEL_40223a;\n    }\n    if ((unsigned int)v8 == 1444872237) {\n      v11 = cursorpos;\n      if (cursorpos) {\n        v15 = cursorpos - 1;\n        do {\n          v13 = (char)is_stopkey((&line)[v15]) ^ 1;\n          tmp_22 = (unsigned int)v15;\n          v14 = v15;\n          v15 -= 1;\n        } while ((tmp_22 & v13));\n        cursorpos = v14;\n        printf(&g_4032e6, v11 - cursorpos);\n        goto LABEL_4020ca;\n      }\n    } else if ((unsigned int)v8 == 1444872236) {\n      if (cursorpos < line_len) {\n        v16 = cursorpos + 1;\n        *((unsigned int *)&v0) = v44;\n        do {\n          tmp_19 = (unsigned int)v16 < line_len;\n          v17 = (char)is_stopkey((&line)[v16]) ^ 1;\n          v18 = v16;\n          v16 += 1;\n        } while ((v17 & tmp_19));\n        v44 = (int)v0;\n        cursorpos = v18;\n        printf(&g_4032ec, 1);\n      }\n      if ((unsigned int)v8 == 1444872245 && cursorpos) {\n        printf(&g_4032e6, cursorpos);\n        cursorpos = 0;\n        goto LABEL_4022c5;\n      }\n    LABEL_4021f0:\n      if ((unsigned int)v8 == 1444872248 && cursorpos != line_len) {\n        printf(&g_4032ec, line_len - cursorpos);\n        cursorpos = line_len;\n        goto LABEL_402211;\n      }\n    LABEL_4020e9:\n      if ((unsigned int)v8 == 1444872240) {\n        if (!cursorpos)\n          goto LABEL_402211;\n        line_len = line_len - 1;\n        cursorpos = cursorpos - 1;\n        printf(&g_4032e6, 1);\n      } else {\n        if (!((unsigned int)v8 == 1444872239))\n          goto LABEL_4022c5;\n        if (cursorpos < line_len) {\n          line_len = line_len - 1;\n        } else {\n        LABEL_40222d:\n          if ((unsigned int)v8 == 0x561f0000) {\n            if (!cursorpos) {\n              v44 = (unsigned int)v44 + 1;\n            } else {\n              v35 = cursorpos;\n              do {\n                tmp_21 = *((int *)&(&g_40a11c)[4 * v35]) != 32;\n                v36 = v35;\n                v35 -= 1;\n              } while ((cursorpos & tmp_21));\n              v38 = search_completion((char *)&line + 0x4 * v36,\n                                      cursorpos - (char *)v36);\n              v39 = v38;\n              if (v38) {\n                printf(&g_4032f2);\n                v40 = *(v38);\n                if ((unsigned int)v40) {\n                  *((unsigned int *)&v0) = v44;\n                  do {\n                    putc_utf8(v40);\n                    v41 = cursorpos;\n                    v42 = cursorpos * 4;\n                    memmove(&line + v42 + 4, v42 + &line,\n                            (line_len - cursorpos) * 4);\n                    (&line)[v41] = *((int *)v39);\n                    cursorpos = (unsigned int)v41 + 1;\n                    line_len = line_len + 1;\n                    v39 += 4;\n                    v40 = *((int *)v39);\n                  } while ((unsigned int)v40);\n                  v44 = (int)v0;\n                }\n                v45 = cursorpos;\n                if (cursorpos != line_len) {\n                  v48 = &(&line)[cursorpos];\n                  do {\n                    putc_utf8(*((int *)v48));\n                    v45 += 1;\n                    v48 += 4;\n                  } while (line_len != v45);\n                  printf(&g_4032e6, v45 - cursorpos);\n                }\n              }\n              v44 = (unsigned int)v44 + 1;\n            }\n            if ((unsigned int)v44 > 1) {\n              printf(&g_4032b8, 1);\n              puts(\"\\npossible completions are:\");\n              printf(&g_4032b8, 0);\n              v49 = cursorpos;\n              v50 = cursorpos;\n              if (!cursorpos) {\n                print_all_completions(&line, 0);\n                print_prompt(v1);\n                if (!line_len) {\n                  v49 = line_len;\n                } else {\n                  v53 = &line;\n                  do {\n                    putc_utf8(*((int *)v53));\n                    v49 += 1;\n                    v53 += 4;\n                  } while (line_len != v49);\n                }\n                if (cursorpos != v49) {\n                  printf(&g_4032e6, v49 - cursorpos);\n                  continue;\n                }\n              } else {\n                do {\n                  tmp_22 = *((int *)&(&g_40a11c)[4 * v50]) != 32;\n                  tmp_34 = (unsigned int)v50;\n                  v51 = v50;\n                  v50 -= 1;\n                } while ((tmp_34 & tmp_22));\n                print_all_completions((char *)&line + 0x4 * v51,\n                                      cursorpos - (char *)v51);\n                print_prompt(v1);\n                v52 = line_len;\n                if (line_len) {\n                  v54 = &line;\n                  do {\n                    putc_utf8(*((int *)v54));\n                    v52 = 1;\n                    v54 += 4;\n                  } while (line_len != 1);\n                }\n                if (cursorpos != v52)\n                  printf(&g_4032e6, v52 - cursorpos);\n              }\n            }\n            continue;\n          }\n          goto LABEL_40223a;\n        }\n      }\n      v19 = (cursorpos + 1) * 4;\n      memmove(-4 + (char *)&line + v19, v19 + (char *)&line,\n              (line_len - cursorpos) * 4);\n      printf(&g_4032f2);\n      v20 = cursorpos;\n      if (cursorpos == line_len) {\n      LABEL_402211:\n        if (!(total_history_entries) || !((unsigned int)(v8 - 1444872230) <= 1))\n          goto LABEL_40222d;\n        v32 = v2;\n        v33 = v32 - 1;\n        if ((unsigned int)v8 != 1444872230)\n          v33 = (unsigned int)v32 + 1;\n        if ((unsigned int)v33 >= (unsigned int)total_history_entries) {\n          v2 = 0;\n        } else {\n          v37 = (unsigned int)total_history_entries - 1;\n          if ((char)(v33 >> 31 & 1 ^ 1))\n            v37 = v33;\n          v2 = v37;\n        }\n        if (cursorpos)\n          printf(&g_4032e6, cursorpos);\n        printf(&g_4032f2);\n        cursorpos = 0;\n        line_len = 0;\n        v43 = v2 * 0x4000;\n        v44 = *((int *)(&history + v43));\n        if (!(unsigned int)v44)\n          continue;\n        v46 = v43 + &history;\n        v47 = v44;\n        do {\n          putc_utf8(v47);\n          (&line)[cursorpos] = *((int *)v46);\n          cursorpos = cursorpos + 1;\n          line_len = line_len + 1;\n          v46 += 4;\n          v47 = *((int *)v46);\n        } while ((unsigned int)v47);\n      LABEL_40223a:\n        if ((unsigned int)v8 == 4 || (unsigned int)v8 == 1444872238) {\n          puts(&g_40331b);\n          printf(&g_403311);\n          echo_enable();\n          __sysv_signal(2, v6);\n          memset(&(&line)[line_len], 0, (0x1000 - line_len) * 4);\n          if (memcmp(&line,\n                     &(&history)[0x4000 * *((long long *)&last_history_entry)],\n                     0x4000)) {\n            v55 = *((long long *)&last_history_entry) + 1;\n            if (*((long long *)&last_history_entry) == 199)\n              v55 = 0;\n            *((unsigned long *)&last_history_entry) = v55;\n            v56 = v55;\n            v57 = v55 + 1;\n            if (total_history_entries < total_history_entries)\n              total_history_entries = v57;\n            v58 = &(&history)[0x4000 * v56];\n            memset(v58, 0, 0x4000);\n            memcpy(v58, &line, line_len * 4);\n            break;\n          }\n        } else {\n          v44 = 0;\n        }\n      } else {\n        v21 = (char *)&line + 0x4 * v20;\n        do {\n          putc_utf8(*((int *)v21));\n          v20 = (unsigned int)v20 + 1;\n          v21 += 4;\n        } while (line_len != v20);\n        printf(&g_4032e6, v20 - cursorpos);\n      LABEL_4022c5:\n        if ((unsigned int)v8 == 1444872242) {\n          v4 = cursorpos;\n          v3 = line_len;\n          v22 = cursorpos;\n          do {\n            tmp_18 = (unsigned int)v22;\n            v23 = (char)is_stopkey((&line)[v22]) ^ 1;\n            v24 = v22;\n            v22 -= 1;\n          } while ((v23 & tmp_18));\n          v0 = v24;\n          v25 = cursorpos + (line_len != cursorpos);\n          do {\n            tmp_19 = (unsigned int)v25 < v3;\n            v26 = (char)is_stopkey((&line)[v25]) ^ 1;\n            v27 = v25;\n            v25 += 1;\n          } while ((v26 & tmp_19));\n          v28 = v0;\n          memmove((char *)&line + 0x4 * v28, (char *)&line + 0x4 * v27,\n                  (v3 - (char *)v27) * 4);\n          v29 = v4;\n          if ((unsigned int)v28 < v29) {\n            printf(&g_4032e6, v29 - cursorpos);\n            cursorpos = (unsigned int)v0;\n          }\n          line_len = line_len - ((unsigned int)v27 - (int)v0);\n          printf(&g_4032f2);\n          v30 = cursorpos;\n          if (cursorpos != line_len) {\n            v31 = &(&line)[cursorpos];\n            do {\n              putc_utf8(*((int *)v31));\n              v30 += 1;\n              v31 += 4;\n            } while (line_len != v30);\n            printf(&g_4032e6, v30 - cursorpos);\n            goto LABEL_402211;\n          }\n        }\n      }\n    } else {\n      if ((unsigned int)v8 == 1444872233 && cursorpos) {\n        printf(&g_4032e6, 1);\n        cursorpos = cursorpos - 1;\n        goto LABEL_4021f0;\n      }\n    LABEL_4020ca:\n      if ((unsigned int)v8 == 1444872232 && cursorpos < line_len) {\n        printf(&g_4032ec, 1);\n        cursorpos = cursorpos + 1;\n        goto LABEL_4020e9;\n      }\n    }\n  }\n  if ((unsigned int)v8 == 4 && !line_len) {\n    __sysv_signal(2, v6);\n    gprompt = 0;\n    return 0;\n  }\n  gprompt = 0;\n  trans_utf8(&line_t.0, &line);\n  return &line_t.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:43:33: error: expected ';' after top level\ndeclarator 43 | extern unsigned long long line_t.0; | ^ | ;\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:133:27: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 133 | memmove(&line + v10 +\n4, v10 + &line, (line_len - cursorpos) * 4); |                     ~~~~~ ^ ~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:133:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 133 | memmove(&line + v10 +\n4, v10 + &line, (line_len - cursorpos) * 4); | ~~~ ^ ~~~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:218:66: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 218 | tmp_21 = *((int *)&(&g_40a11c)[4 *\nv35]) != 32; |                                                                ~\n^ ~~~ /tmp/tmpb9aioonh/getline_complete_name_conflict.c:222:73: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 222 | v38 =\nsearch_completion((char *)&line + 0x4 * v36, cursorpos - (char *)v36); | ~~~ ^\n~~~ /tmp/tmpb9aioonh/getline_complete_name_conflict.c:222:90: error: invalid operands to\nbinary expression ('unsigned int' and 'char *') 222 | v38 =\nsearch_completion((char *)&line + 0x4 * v36, cursorpos - (char *)v36); |\n~~~~~~~~~ ^ ~~~~~~~~~~~ /tmp/tmpb9aioonh/getline_complete_name_conflict.c:236:55: error:\ninvalid operands to binary expression ('unsigned int *' and 'unsigned int *')\n  236 |                                         memmove(&line + v42 + 4, v42 +\n&line, (line_len - cursorpos) * 4); | ~~~~~ ^ ~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:236:70: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 236 | memmove(&line + v42 +\n4, v42 + &line, (line_len - cursorpos) * 4); | ~~~ ^ ~~~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:300:75: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 300 | print_all_completions((char\n*)&line + 0x4 * v51, cursorpos - (char *)v51); | ~~~ ^ ~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:300:92: error: invalid operands to binary\nexpression ('unsigned int' and 'char *') 300 | print_all_completions((char\n*)&line + 0x4 * v51, cursorpos - (char *)v51); | ~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:352:42: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 352 |                 v44 = *((int\n*)(&history + v43)); |                                 ~~~~~~~~ ^ ~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:355:27: error: invalid operands to binary\nexpression ('unsigned int *' and 'char *') 355 |                 v46 = v43 +\n&history; |                       ~~~ ^ ~~~~~~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:397:43: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 397 |                 v21 = (char\n*)&line + 0x4 * v20; |                                       ~~~ ^ ~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:428:49: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 428 |                     memmove((char\n*)&line + 0x4 * v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~~ ^\n~~~ /tmp/tmpb9aioonh/getline_complete_name_conflict.c:428:76: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 428 | memmove((char *)&line + 0x4\n* v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~~ ^ ~~~\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:428:87: error: invalid operands to binary\nexpression ('unsigned int' and 'char *') 428 |                     memmove((char\n*)&line + 0x4 * v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~ ^\n~~~~~~~~~~~ /tmp/tmpb9aioonh/getline_complete_name_conflict.c:477:23: error: expected ')' 477\n|     trans_utf8(&line_t.0, &line); |                       ^\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:477:15: note: to match this '('\n  477 |     trans_utf8(&line_t.0, &line);\n      |               ^\n/tmp/tmpb9aioonh/getline_complete_name_conflict.c:478:19: error: expected ';' after return\nstatement 478 |     return &line_t.0; |                   ^ | ; 18 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int completions;\nextern unsigned long long current_num_completions;\n\nlong long init_completion_name_conflict(char a0[2]) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  unsigned long v2; // rax\n  void *v3;         // rcx\n\n  if (current_num_completions == 0x800)\n    return 1;\n  v1 = a0[0];\n  v2 = 0;\n  if (!(char)v1) {\n    (&completions)[0x1000 * current_num_completions + v2] = 0;\n    current_num_completions = current_num_completions + 1;\n    return 0;\n  }\n  v3 = &(&completions)[0x1000 * current_num_completions];\n  v2 = 1;\n  while (true) {\n    *((unsigned int *)(-4 + (char *)v3 + 4 * v2)) = v1;\n    v1 = a0[v2];\n    if (!(char)v1)\n      break;\n    v2 += 1;\n    if (v2 == 0x1000) {\n      memset(v3, 0, 0x4000);\n      return 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint compl_eqcompar; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern unsigned long long completions;\nextern unsigned long long current_num_completions;\nextern struct_0 *memsize;\n\nlong long completion_exists_name_conflict(struct_0 *a0) {\n  int tmp_37;       // tmp #37\n  char v0;          // [bp-0x400c]\n  unsigned int v1;  // [bp-0x4008]\n  unsigned long v3; // rdx, Other Possible Types: unsigned long long\n  unsigned long v4; // rax\n  struct_0 *v5;     // rax, Other Possible Types: unsigned long\n  struct_0 *v6;     // r8, Other Possible Types: unsigned long\n\n  v3 = a0->field_0;\n  if (!(char)v3) {\n    v5 = 0;\n    v6 = 0;\n  } else {\n    v4 = 1;\n    do {\n      *((unsigned int *)&(&v0)[4 * v4]) = v3;\n      v3 = a0[v4].field_0;\n      tmp_37 = (unsigned int)v4 == 4095;\n      v6 = v4;\n      v4 += 1;\n    } while (!tmp_37 && (char)v3);\n    v5 = v6;\n  }\n  (&v1)[v5] = 0;\n  memsize = v6;\n  return lfind(&v1, &completions, &current_num_completions, 0x4000,\n               compl_eqcompar);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe2p6tg1r/completion_exists_name_conflict.c:55:10: error: array subscript is not an\ninteger 55 |     (&v1)[v5] = 0; |          ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_4032ac;\nextern char g_4032c1;\nextern char g_4032c8;\nextern char g_4032cc;\nextern char g_4032d6;\nextern char g_4032d9;\nextern char g_4032dc;\nextern char g_4032df;\nextern char g_4032e2;\nextern char g_4032e5;\nextern char g_4032e8;\nextern char g_4032eb;\nextern char g_4032ee;\nextern char g_4032f1;\nextern char g_4032f5;\nextern char g_4032f9;\nextern char g_4032fd;\nextern char g_403301;\nextern char g_403305;\nextern char g_403309;\nextern char g_40330d;\nextern char g_403314;\nextern char g_40331d;\nextern char g_403327;\nextern char g_403330;\nextern char g_403337;\nextern char g_40333c;\nextern char g_403343;\nextern char g_40334c;\nextern char g_403350;\n\nlong long get_key_name_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  if ((unsigned int)a0 == 27)\n    return \"Escape\";\n  v2 = a0 - 0x561f0000;\n  if ((unsigned int)v2 > 56)\n    return \"unknown\";\n  if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rax,\n                                           0x38 < 64 >, cc_ndep))\n    goto LABEL_0x401512;\n  else\n    goto LABEL_0x40152c;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkqsdk30u/get_key_name_name_conflict.c:57:15: error: expected expression\n   57 |     if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rax,\n0x38<64>, cc_ndep)) |               ^ /tmp/tmpkqsdk30u/get_key_name_name_conflict.c:58:14:\nerror: use of undeclared label 'LABEL_0x401512' 58 |         goto\nLABEL_0x401512; |              ^ /tmp/tmpkqsdk30u/get_key_name_name_conflict.c:60:14: error:\nuse of undeclared label 'LABEL_0x40152c' 60 |         goto LABEL_0x40152c; | ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_regular_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long long v2;  // rbx\n  unsigned long long v7;  // rbx\n  unsigned long long v8;  // rbp\n  unsigned long v9;       // rax, Other Possible Types: unsigned long long\n  unsigned long long v12; // rbx\n  unsigned long long v14; // rbx\n  unsigned long long v15; // rbp\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  v2 = v1;\n  if ((char)((unsigned int)v1 & -8) == 240) {\n    v12 = ((unsigned int)v1 & 15) * 0x40000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v14 = v12 + (getc(stdin @GLIBC_2.2.5) & 127) * 64;\n    v15 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v14 + v15 * 0x1000;\n    if ((unsigned int)v9 <= 65535)\n      return 4294967295;\n    return v14 + v15 * 0x1000;\n  } else if ((char)((unsigned int)v1 & -0x10) == 224) {\n    v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin @GLIBC_2.2.5) & 127);\n    v8 = getc(stdin @GLIBC_2.2.5) & 127;\n    v9 = v7 + v8 * 64;\n    if ((unsigned int)v9 <= 2047)\n      return 4294967295;\n    return v7 + v8 * 64;\n  } else if ((char)((unsigned int)v1 & -32) == 192) {\n    v9 = (getc(stdin @GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) * 64;\n    if ((unsigned int)v9 <= 127)\n      return 4294967295;\n    return v9;\n  } else {\n    v9 = ((char)v2 < 0 ? (char)v2 : 4294967295);\n    return v9;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:30:16: error: nested redefinition\nof '_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:29:12: note: previous definition\nis here 29 |     struct _IO_marker { |            ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:16:6: error: conflicting types for\n'getc' 16 | int (getc)(struct FILE_t { |      ^ /usr/include/stdio.h:514:12:\nnote: previous declaration is here 514 | extern int getc (FILE *__stream); | ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:106:8: error: unknown type name\n'FILE_t'; did you mean 'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^~~~~~\n      |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:106:21: error: expected ';' after\ntop level declarator 106 | extern FILE_t *stdin@GLIBC_2.2.5; | ^ | ;\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:119:34: error: expected ')'\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:119:28: note: to match this '('\n  119 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:123:62: error: expected ')'\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:123:56: note: to match this '('\n  123 |         v12 = ((unsigned int)v1 & 15) * 0x40000 +\n(getc(stdin@GLIBC_2.2.5) & 127); | ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:124:32: error: expected ')'\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                                ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:124:26: note: to match this '('\n  124 |         v14 = v12 + (getc(stdin@GLIBC_2.2.5) & 127) * 64;\n      |                          ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:125:25: error: expected ')'\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                         ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:125:19: note: to match this '('\n  125 |         v15 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                   ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:133:60: error: expected ')'\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                            ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:133:54: note: to match this '('\n  133 |         v7 = ((unsigned int)v1 & 31) * 0x1000 + (getc(stdin@GLIBC_2.2.5)\n& 127); |                                                      ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:134:24: error: expected ')'\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                        ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:134:18: note: to match this '('\n  134 |         v8 = getc(stdin@GLIBC_2.2.5) & 127;\n      |                  ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:142:25: error: expected ')'\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                         ^\n/tmp/tmpqpjnx35k/decode_regular_key_pressed.c:142:19: note: to match this '('\n  142 |         v9 = (getc(stdin@GLIBC_2.2.5) & 127) + ((unsigned int)v1 & 63) *\n64; |                   ^ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nint(ungetc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nlong long(decode_regular_key_pressed)();\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long decode_key_pressed() {\n  unsigned long long v1;  // rax\n  unsigned long v2;       // rbx, Other Possible Types: unsigned long long\n  unsigned long long v4;  // rax\n  unsigned long long v5;  // rax\n  unsigned long long v7;  // rax\n  unsigned int v8;        // ebx\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n\n  (unsigned int)v1 = getc(stdin @GLIBC_2.2.5);\n  if ((unsigned int)v1 == 10)\n    return 1444872238;\n  v2 = v1;\n  if ((unsigned int)v1 > 27) {\n    if ((unsigned int)v1 != 127)\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    else\n      return 1444872240;\n  } else {\n    if ((unsigned int)v1 < -1) {\n      ungetc(v2, stdin @GLIBC_2.2.5);\n    } else {\n      switch ((unsigned int)v1) {\n      case -1:\n        return 4;\n      case 0:\n        return 1444872243;\n      case 8:\n        return 1444872241;\n      case 9:\n        return 0x561f0000;\n      case 23:\n        return 1444872242;\n      case 27:\n        (unsigned int)v4 = getc(stdin @GLIBC_2.2.5);\n        if ((unsigned int)v4 == 79) {\n          (unsigned int)v5 = getc(stdin @GLIBC_2.2.5);\n          v2 = ((unsigned int)(v5 - 80) <= 3 ? 4294967295 : v5 + 1444872114);\n          return v2;\n        } else if ((unsigned int)v4 == 91) {\n          switch (getc(stdin @GLIBC_2.2.5)) {\n          case 49:\n            v8 = getc(stdin @GLIBC_2.2.5);\n            (unsigned int)v9 = getc(stdin @GLIBC_2.2.5);\n            if (v8 == 59 && (unsigned int)v9 == 53) {\n              (char)v10 = getc(stdin @GLIBC_2.2.5);\n              if ((char)v10 == 67) {\n                return 1444872236;\n              } else if ((char)v10 > 67) {\n                v2 = ((char)v10 != 68 ? 1444872237 : 4294967295);\n                return v2;\n              } else if ((char)v10 == 65) {\n                return 1444872234;\n              } else {\n                v2 = ((char)v10 != 66 ? 1444872235 : 4294967295);\n                return v2;\n              }\n            }\n            if (!(v8 != 54 && (unsigned int)v9 == 126 && v8 <= 57))\n              return 4294967295;\n            v2 = v8 - (54 < v8) + 1444872145;\n            return v2;\n          case 50:\n            (unsigned int)v7 = getc(stdin @GLIBC_2.2.5);\n            if ((unsigned int)v7 == 126)\n              return 1444872244;\n            if (!((unsigned int)v7 <= 52 && (unsigned int)v7 != 50))\n              return 4294967295;\n            v2 = (unsigned int)v7 - ((unsigned int)v7 > 50) + 1444872154;\n            if (getc(stdin @GLIBC_2.2.5) != 126) {\n              v2 = 4294967295;\n              break;\n            } else {\n              break;\n            }\n            return v2;\n          case 51:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872239 : 4294967295);\n            return v2;\n          case 53:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872246 : 4294967295);\n            return v2;\n          case 54:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872247 : 4294967295);\n            return v2;\n          case 55:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872245 : 4294967295);\n            return v2;\n          case 56:\n            v2 = (getc(stdin @GLIBC_2.2.5) != 126 ? 1444872248 : 4294967295);\n            return v2;\n          case 65:\n            return 1444872230;\n          case 66:\n            return 1444872231;\n          case 67:\n            return 1444872232;\n          case 68:\n            return 1444872233;\n          case 70:\n            return 1444872248;\n          case 72:\n            return 1444872245;\n          default:\n            return 4294967295;\n          }\n        } else {\n          ungetc(v4, stdin @GLIBC_2.2.5);\n          return v2;\n        }\n      default:\n        ungetc(v2, stdin @GLIBC_2.2.5);\n      }\n    }\n  }\n  v2 = decode_regular_key_pressed();\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpny45sywu/decode_key_pressed.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmpny45sywu/decode_key_pressed.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpny45sywu/decode_key_pressed.c:73:13: error: declaration of anonymous\nunion must be a definition 73 |             union <anon> { |             ^\n/tmp/tmpny45sywu/decode_key_pressed.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmpny45sywu/decode_key_pressed.c:80:13: error: declaration of anonymous\nunion must be a definition 80 |             union <anon> { |             ^\n/tmp/tmpny45sywu/decode_key_pressed.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmpny45sywu/decode_key_pressed.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpny45sywu/decode_key_pressed.c:162:13: error: declaration of anonymous\nunion must be a definition 162 |             union <anon> { |             ^\n/tmp/tmpny45sywu/decode_key_pressed.c:165:22: error: type name requires a\nspecifier or qualifier 165 |             } __value; |                      ^\n/tmp/tmpny45sywu/decode_key_pressed.c:169:13: error: declaration of anonymous\nunion must be a definition 169 |             union <anon> { |             ^\n/tmp/tmpny45sywu/decode_key_pressed.c:172:22: error: type name requires a\nspecifier or qualifier 172 |             } __value; |                      ^\n/tmp/tmpny45sywu/decode_key_pressed.c:105:6: error: conflicting types for\n'ungetc' 105 | int (ungetc)(int, struct FILE_t { |      ^\n/usr/include/stdio.h:668:12: note: previous declaration is here\n  668 | extern int ungetc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpny45sywu/decode_key_pressed.c:196:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 196 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |\nFILE /usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared\nhere 7 | typedef struct _IO_FILE FILE; |                         ^\n/tmp/tmpny45sywu/decode_key_pressed.c:196:21: error: expected ';' after top\nlevel declarator 196 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^\n      |                     ;\n/tmp/tmpny45sywu/decode_key_pressed.c:209:34: error: expected ')'\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                                  ^\n/tmp/tmpny45sywu/decode_key_pressed.c:209:28: note: to match this '('\n  209 |     (unsigned int)v1 = getc(stdin@GLIBC_2.2.5);\n      |                            ^\n/tmp/tmpny45sywu/decode_key_pressed.c:216:29: error: expected ')'\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmpny45sywu/decode_key_pressed.c:216:19: note: to match this '('\n  216 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmpny45sywu/decode_key_pressed.c:224:29: error: expected ')'\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                             ^\n/tmp/tmpny45sywu/decode_key_pressed.c:224:19: note: to match this '('\n  224 |             ungetc(v2, stdin@GLIBC_2.2.5);\n      |                   ^\n/tmp/tmpny45sywu/decode_key_pressed.c:241:46: error: expected ')'\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                              ^\n/tmp/tmpny45sywu/decode_key_pressed.c:241:40: note: to match this '('\n  241 |                 (unsigned int)v4 = getc(stdin@GLIBC_2.2.5);\n      |                                        ^\n/tmp/tmpny45sywu/decode_key_pressed.c:244:50: error: expected ')'\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                                  ^\n/tmp/tmpny45sywu/decode_key_pressed.c:244:44: note: to match this '('\n  244 |                     (unsigned int)v5 = getc(stdin@GLIBC_2.2.5);\n      |                                            ^\n/tmp/tmpny45sywu/decode_key_pressed.c:250:39: error: expected ')'\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                       ^\n/tmp/tmpny45sywu/decode_key_pressed.c:250:33: note: to match this '('\n  250 |                     switch (getc(stdin@GLIBC_2.2.5))\n      |                                 ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_special_name_conflict(unsigned long a0) {\n  unsigned int v1;       // eax\n  unsigned long long v2; // rax\n\n  v1 = 1;\n  if ((unsigned int)a0 > 31)\n    v1 = ((unsigned int)a0 & 0x56000000) == 0x56000000;\n  v2 = v1 & 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(compute_completion_ranges)(long long, long long, long long,\n                                     long long);\n\nextern char completions;\nextern unsigned long long current_num_completions;\nextern char line.1;\n\nlong long search_completion_name_conflict(unsigned long long a0, unsigned long long a1) {\n  char v0;               // [bp-0x18]\n  int tmp_27;            // tmp #27\n  int tmp_23;            // tmp #23\n  char v1;               // [bp-0x10]\n  unsigned long long v3; // rbx\n  unsigned int *v4;      // rcx\n  unsigned long long v5; // rdx\n  unsigned long long v6; // rdx\n  unsigned long long v8; // rax\n  unsigned long v9;      // rax, Other Possible Types: unsigned long long\n  unsigned int *v10;     // rsi\n  unsigned int *v11;     // rax, Other Possible Types: unsigned long\n  unsigned int v12;      // edx\n\n  v3 = a1;\n  compute_completion_ranges(a0, a1, &v1, &v0);\n  v4 = *((long long *)&v1);\n  if (!((unsigned int)v3 && v4))\n    return 0;\n  v5 = v4 - &completions;\n  tmp_27 = v5 >> 1;\n  v6 = v5 >> 2;\n  if (((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x24 < 64 >, rdx, t27,\n                                            cc_ndep)\n           ? v6\n           : v6 + 4095) >>\n          12 ==\n      current_num_completions - 1)\n    return &v4[v3];\n  v11 = *(v4);\n  if ((unsigned int)v11) {\n    v8 = *((long long *)&v0) - (char *)v4;\n    tmp_23 = v8 >> 1;\n    v9 = v8 >> 2;\n    if ((char)[D] amd64g_calculate_condition(0x8 < 64 >, 0x24 < 64 >, rax, t23,\n                                             cc_ndep))\n      v9 += 4095;\n    v10 = &v4[0x1000 + (v9 & -0x1000) + v3];\n    v11 = 0;\n    while (true) {\n      v12 = v4[v11 + v3];\n      if (v12 != v10[v11])\n        break;\n      *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      if (v4[1 + v11]) {\n        v11 += 1;\n      } else {\n        v11 = (unsigned int)v11 + 1;\n        break;\n      }\n    }\n  }\n  *((int *)&(&line.1)[4 * v11]) = 0;\n  return &line.1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp58fig6re/search_completion_name_conflict.c:20:17: error: expected ';' after top level\ndeclarator 20 | extern char line.1; |                 ^ |                 ;\n/tmp/tmp58fig6re/search_completion_name_conflict.c:43:13: error: 'unsigned int *' and 'char *'\nare not pointers to compatible types 43 |     v5 = v4 - &completions; | ~~ ^\n~~~~~~~~~~~~ /tmp/tmp58fig6re/search_completion_name_conflict.c:46:16: error: expected\nexpression 46 |     if (((char)[D] amd64g_calculate_condition(0x9<64>, 0x24<64>,\nrdx, t27, cc_ndep) ? v6 : v6 + 4095) >> 12 == current_num_completions - 1) | ^\n/tmp/tmp58fig6re/search_completion_name_conflict.c:51:34: error: invalid operands to binary\nexpression ('long long' and 'char *') 51 |         v8 = *((long long *)&v0) -\n(char *)v4; |              ~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp58fig6re/search_completion_name_conflict.c:54:19: error: expected expression\n   54 |         if ((char)[D] amd64g_calculate_condition(0x8<64>, 0x24<64>, rax,\nt23, cc_ndep)) |                   ^ /tmp/tmp58fig6re/search_completion_name_conflict.c:60:21:\nerror: array subscript is not an integer 60 |             v12 = v4[v11 + v3]; |\n^~~~~~~~~ /tmp/tmp58fig6re/search_completion_name_conflict.c:61:27: error: array subscript is\nnot an integer 61 |             if (v12 != v10[v11]) | ^~~~\n/tmp/tmp58fig6re/search_completion_name_conflict.c:63:38: error: expected ')'\n   63 |             *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      |                                      ^\n/tmp/tmp58fig6re/search_completion_name_conflict.c:63:32: note: to match this '('\n   63 |             *((unsigned int *)&(&line.1)[4 * v11]) = v12;\n      |                                ^\n/tmp/tmp58fig6re/search_completion_name_conflict.c:63:44: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 63 |             *((unsigned int\n*)&(&line.1)[4 * v11]) = v12; |                                          ~ ^ ~~~\n/tmp/tmp58fig6re/search_completion_name_conflict.c:64:19: error: array subscript is not an\ninteger 64 |             if (v4[1 + v11]) |                   ^~~~~~~~\n/tmp/tmp58fig6re/search_completion_name_conflict.c:75:21: error: expected ')'\n   75 |     *((int *)&(&line.1)[4 * v11]) = 0;\n      |                     ^\n/tmp/tmp58fig6re/search_completion_name_conflict.c:75:15: note: to match this '('\n   75 |     *((int *)&(&line.1)[4 * v11]) = 0;\n      |               ^\n/tmp/tmp58fig6re/search_completion_name_conflict.c:75:27: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 75 |     *((int *)&(&line.1)[4 * v11]) =\n0; |                         ~ ^ ~~~ /tmp/tmp58fig6re/search_completion_name_conflict.c:76:17:\nerror: expected ';' after return statement 76 |     return &line.1; | ^ | ; 13\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long is_stopkey_name_conflict(unsigned long a0) {\n  unsigned long long v2; // rax\n\n  v2 = ((unsigned int)(a0 - 32) <= 59\n            ? 0\n            : (int)(576460752303472641 >> ((char)(a0 - 32) & 63)) & 1) &\n       1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sighandler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(echo_disable)();\nlong long(print_prompt)(long long);\nlong long(decode_key_pressed)();\nlong long(is_special)(long long);\nlong long(echo_enable)();\nlong long(putc_utf8)(long long);\nvoid *(memmove)(void *, void *, unsigned long);\nlong long(is_stopkey)(long long);\nlong long(trans_utf8)(long long, long long);\nlong long(search_completion)(long long, long long);\nlong long(print_all_completions)(long long, long long);\n\nextern unsigned int cursorpos;\nextern char g_4031d1;\nextern char g_403560;\nextern char g_403570;\nextern char g_40358e;\nextern char g_403594;\nextern char g_40359a;\nextern char g_4035b9;\nextern char g_40a13c;\nextern void *gprompt;\nextern char history;\nextern unsigned int last_history_entry;\nextern unsigned int line;\nextern unsigned int line_len;\nextern unsigned long long line_t.0;\nextern unsigned long long total_history_entries;\n\nlong long getline_complete_name_conflict(unsigned long a0) {\n  int tmp_22;             // tmp #22\n  unsigned int *v0;       // [bp-0x58]\n  int tmp_19;             // tmp #19\n  int tmp_21;             // tmp #21\n  int tmp_34;             // tmp #34\n  int tmp_18;             // tmp #18\n  unsigned long long v1;  // [bp-0x50]\n  unsigned int v2;        // [bp-0x44]\n  unsigned int v3;        // [bp-0x40]\n  unsigned int v4;        // [bp-0x3c]\n  unsigned long long v6;  // r14\n  unsigned long long v8;  // r15\n  unsigned long v9;       // rbx\n  unsigned int *v10;      // rax\n  unsigned int v11;       // r12d\n  char v13;               // al\n  unsigned int v14;       // ecx\n  unsigned long v15;      // rbx\n  unsigned long v16;      // rbx\n  char v17;               // al\n  unsigned int v18;       // esi\n  unsigned long long v19; // rax\n  unsigned int *v20; // rbx, Other Possible Types: unsigned long, unsigned int\n  unsigned int *v21; // rbp, Other Possible Types: unsigned long\n  unsigned long v22; // rbx\n  char v23;          // al\n  unsigned int *v24; // rcx\n  unsigned long v25; // rbx\n  char v26;          // al\n  unsigned int *v27; // rcx\n  unsigned int *v28; // rbx\n  unsigned int v29;  // eax\n  unsigned int v30;  // ebx\n  unsigned int *v31; // rbp, Other Possible Types: unsigned long\n  unsigned long long v32; // rcx\n  unsigned long v33;      // rdx, Other Possible Types: unsigned long long\n  unsigned int *v35;      // rax, Other Possible Types: unsigned long\n  unsigned int *v36;      // rdi\n  unsigned int v37;       // eax\n  unsigned int *v38;      // rax\n  unsigned int *v39;      // rbp, Other Possible Types: unsigned long\n  unsigned long v40;      // rdi, Other Possible Types: unsigned long long\n  unsigned long v41;      // rbx\n  unsigned int *v42;      // rax\n  unsigned int *v43;      // rax\n  unsigned int *v44; // r13, Other Possible Types: unsigned long, unsigned long\n                     // long, void*\n  unsigned int v45;  // ebx\n  unsigned int *v46; // rbx, Other Possible Types: unsigned long\n  unsigned long v47; // rdi, Other Possible Types: unsigned long long\n  unsigned int *v48; // rbp, Other Possible Types: unsigned long\n  unsigned int v49;  // ebx\n  unsigned long v50; // rax\n  unsigned int *v51; // rdi\n  unsigned int v52;  // ebx\n  unsigned int *v53; // rbp, Other Possible Types: unsigned long\n  unsigned int *v54; // rbp, Other Possible Types: unsigned long\n  void *v55;         // rax, Other Possible Types: unsigned long\n  unsigned long long v56; // rbp\n  unsigned long long v57; // rax\n  void *v58;              // rbp\n\n  v1 = a0;\n  memset(&line, 0, 0x4000);\n  gprompt = a0;\n  v6 = __sysv_signal(2, sighandler);\n  line_len = 0;\n  cursorpos = 0;\n  v2 = ((unsigned int)v6 < 200 ? 0 : last_history_entry + 1);\n  echo_disable();\n  printf(&g_403570);\n  print_prompt(gprompt);\n  v44 = 0;\n  while (true) {\n    v8 = decode_key_pressed();\n    if ((unsigned int)v8 == -1) {\n      puts(\"\\nInvalid input sequence!\");\n      printf(&g_4035b9);\n    }\n    if (!(char)is_special(v8)) {\n      putc_utf8(v8);\n      v9 = cursorpos;\n      v10 = cursorpos * 4;\n      memmove(&line + v10 + 4, v10 + &line, (line_len - cursorpos) * 4);\n      (&line)[v9] = v8;\n      cursorpos = (unsigned int)v9 + 1;\n      line_len = line_len + 1;\n      goto LABEL_40244c;\n    }\n    if ((unsigned int)v8 == 1444872237) {\n      v11 = cursorpos;\n      if (cursorpos) {\n        v15 = cursorpos - 1;\n        do {\n          v13 = (char)is_stopkey((&line)[v15]) ^ 1;\n          tmp_22 = (unsigned int)v15;\n          v14 = v15;\n          v15 -= 1;\n        } while ((tmp_22 & v13));\n        cursorpos = v14;\n        printf(&g_40358e, v11 - cursorpos);\n        goto LABEL_4022dc;\n      }\n    } else if ((unsigned int)v8 == 1444872236) {\n      if (cursorpos < line_len) {\n        v16 = cursorpos + 1;\n        *((unsigned int *)&v0) = v44;\n        do {\n          tmp_19 = (unsigned int)v16 < line_len;\n          v17 = (char)is_stopkey((&line)[v16]) ^ 1;\n          v18 = v16;\n          v16 += 1;\n        } while ((v17 & tmp_19));\n        v44 = (int)v0;\n        cursorpos = v18;\n        printf(&g_403594, 1);\n      }\n      if ((unsigned int)v8 == 1444872245 && cursorpos) {\n        printf(&g_40358e, cursorpos);\n        cursorpos = 0;\n        goto LABEL_4024d7;\n      }\n    LABEL_402402:\n      if ((unsigned int)v8 == 1444872248 && cursorpos != line_len) {\n        printf(&g_403594, line_len - cursorpos);\n        cursorpos = line_len;\n        goto LABEL_402423;\n      }\n    LABEL_4022fb:\n      if ((unsigned int)v8 == 1444872240) {\n        if (!cursorpos)\n          goto LABEL_402423;\n        line_len = line_len - 1;\n        cursorpos = cursorpos - 1;\n        printf(&g_40358e, 1);\n      } else {\n        if (!((unsigned int)v8 == 1444872239))\n          goto LABEL_4024d7;\n        if (cursorpos < line_len) {\n          line_len = line_len - 1;\n        } else {\n        LABEL_40243f:\n          if ((unsigned int)v8 == 0x561f0000) {\n            if (!cursorpos) {\n              v44 = (unsigned int)v44 + 1;\n            } else {\n              v35 = cursorpos;\n              do {\n                tmp_21 = *((int *)&(&g_40a13c)[4 * v35]) != 32;\n                v36 = v35;\n                v35 -= 1;\n              } while ((cursorpos & tmp_21));\n              v38 = search_completion((char *)&line + 0x4 * v36,\n                                      cursorpos - (char *)v36);\n              v39 = v38;\n              if (v38) {\n                printf(&g_40359a);\n                v40 = *(v38);\n                if ((unsigned int)v40) {\n                  *((unsigned int *)&v0) = v44;\n                  do {\n                    putc_utf8(v40);\n                    v41 = cursorpos;\n                    v42 = cursorpos * 4;\n                    memmove(&line + v42 + 4, v42 + &line,\n                            (line_len - cursorpos) * 4);\n                    (&line)[v41] = *((int *)v39);\n                    cursorpos = (unsigned int)v41 + 1;\n                    line_len = line_len + 1;\n                    v39 += 4;\n                    v40 = *((int *)v39);\n                  } while ((unsigned int)v40);\n                  v44 = (int)v0;\n                }\n                v45 = cursorpos;\n                if (cursorpos != line_len) {\n                  v48 = &(&line)[cursorpos];\n                  do {\n                    putc_utf8(*((int *)v48));\n                    v45 += 1;\n                    v48 += 4;\n                  } while (line_len != v45);\n                  printf(&g_40358e, v45 - cursorpos);\n                }\n              }\n              v44 = (unsigned int)v44 + 1;\n            }\n            if ((unsigned int)v44 > 1) {\n              printf(&g_403560, 1);\n              puts(\"\\npossible completions are:\");\n              printf(&g_403560, 0);\n              v49 = cursorpos;\n              v50 = cursorpos;\n              if (!cursorpos) {\n                print_all_completions(&line, 0);\n                print_prompt(v1);\n                if (!line_len) {\n                  v49 = line_len;\n                } else {\n                  v53 = &line;\n                  do {\n                    putc_utf8(*((int *)v53));\n                    v49 += 1;\n                    v53 += 4;\n                  } while (line_len != v49);\n                }\n                if (cursorpos != v49) {\n                  printf(&g_40358e, v49 - cursorpos);\n                  continue;\n                }\n              } else {\n                do {\n                  tmp_22 = *((int *)&(&g_40a13c)[4 * v50]) != 32;\n                  tmp_34 = (unsigned int)v50;\n                  v51 = v50;\n                  v50 -= 1;\n                } while ((tmp_34 & tmp_22));\n                print_all_completions((char *)&line + 0x4 * v51,\n                                      cursorpos - (char *)v51);\n                print_prompt(v1);\n                v52 = line_len;\n                if (line_len) {\n                  v54 = &line;\n                  do {\n                    putc_utf8(*((int *)v54));\n                    v52 = 1;\n                    v54 += 4;\n                  } while (line_len != 1);\n                }\n                if (cursorpos != v52)\n                  printf(&g_40358e, v52 - cursorpos);\n              }\n            }\n            continue;\n          }\n          goto LABEL_40244c;\n        }\n      }\n      v19 = (cursorpos + 1) * 4;\n      memmove(-4 + (char *)&line + v19, v19 + (char *)&line,\n              (line_len - cursorpos) * 4);\n      printf(&g_40359a);\n      v20 = cursorpos;\n      if (cursorpos == line_len) {\n      LABEL_402423:\n        if (!(total_history_entries) || !((unsigned int)(v8 - 1444872230) <= 1))\n          goto LABEL_40243f;\n        v32 = v2;\n        v33 = v32 - 1;\n        if ((unsigned int)v8 != 1444872230)\n          v33 = (unsigned int)v32 + 1;\n        if ((unsigned int)v33 >= (unsigned int)total_history_entries) {\n          v2 = 0;\n        } else {\n          v37 = (unsigned int)total_history_entries - 1;\n          if ((char)(v33 >> 31 & 1 ^ 1))\n            v37 = v33;\n          v2 = v37;\n        }\n        if (cursorpos)\n          printf(&g_40358e, cursorpos);\n        printf(&g_40359a);\n        cursorpos = 0;\n        line_len = 0;\n        v43 = v2 * 0x4000;\n        v44 = *((int *)(&history + v43));\n        if (!(unsigned int)v44)\n          continue;\n        v46 = v43 + &history;\n        v47 = v44;\n        do {\n          putc_utf8(v47);\n          (&line)[cursorpos] = *((int *)v46);\n          cursorpos = cursorpos + 1;\n          line_len = line_len + 1;\n          v46 += 4;\n          v47 = *((int *)v46);\n        } while ((unsigned int)v47);\n      LABEL_40244c:\n        if ((unsigned int)v8 == 4 || (unsigned int)v8 == 1444872238) {\n          puts(&g_4031d1);\n          printf(&g_4035b9);\n          echo_enable();\n          __sysv_signal(2, v6);\n          memset(&(&line)[line_len], 0, (0x1000 - line_len) * 4);\n          if (memcmp(&line,\n                     &(&history)[0x4000 * *((long long *)&last_history_entry)],\n                     0x4000)) {\n            v55 = *((long long *)&last_history_entry) + 1;\n            if (*((long long *)&last_history_entry) == 199)\n              v55 = 0;\n            *((unsigned long *)&last_history_entry) = v55;\n            v56 = v55;\n            v57 = v55 + 1;\n            if (total_history_entries < total_history_entries)\n              total_history_entries = v57;\n            v58 = &(&history)[0x4000 * v56];\n            memset(v58, 0, 0x4000);\n            memcpy(v58, &line, line_len * 4);\n            break;\n          }\n        } else {\n          v44 = 0;\n        }\n      } else {\n        v21 = (char *)&line + 0x4 * v20;\n        do {\n          putc_utf8(*((int *)v21));\n          v20 = (unsigned int)v20 + 1;\n          v21 += 4;\n        } while (line_len != v20);\n        printf(&g_40358e, v20 - cursorpos);\n      LABEL_4024d7:\n        if ((unsigned int)v8 == 1444872242) {\n          v4 = cursorpos;\n          v3 = line_len;\n          v22 = cursorpos;\n          do {\n            tmp_18 = (unsigned int)v22;\n            v23 = (char)is_stopkey((&line)[v22]) ^ 1;\n            v24 = v22;\n            v22 -= 1;\n          } while ((v23 & tmp_18));\n          v0 = v24;\n          v25 = cursorpos + (line_len != cursorpos);\n          do {\n            tmp_19 = (unsigned int)v25 < v3;\n            v26 = (char)is_stopkey((&line)[v25]) ^ 1;\n            v27 = v25;\n            v25 += 1;\n          } while ((v26 & tmp_19));\n          v28 = v0;\n          memmove((char *)&line + 0x4 * v28, (char *)&line + 0x4 * v27,\n                  (v3 - (char *)v27) * 4);\n          v29 = v4;\n          if ((unsigned int)v28 < v29) {\n            printf(&g_40358e, v29 - cursorpos);\n            cursorpos = (unsigned int)v0;\n          }\n          line_len = line_len - ((unsigned int)v27 - (int)v0);\n          printf(&g_40359a);\n          v30 = cursorpos;\n          if (cursorpos != line_len) {\n            v31 = &(&line)[cursorpos];\n            do {\n              putc_utf8(*((int *)v31));\n              v30 += 1;\n              v31 += 4;\n            } while (line_len != v30);\n            printf(&g_40358e, v30 - cursorpos);\n            goto LABEL_402423;\n          }\n        }\n      }\n    } else {\n      if ((unsigned int)v8 == 1444872233 && cursorpos) {\n        printf(&g_40358e, 1);\n        cursorpos = cursorpos - 1;\n        goto LABEL_402402;\n      }\n    LABEL_4022dc:\n      if ((unsigned int)v8 == 1444872232 && cursorpos < line_len) {\n        printf(&g_403594, 1);\n        cursorpos = cursorpos + 1;\n        goto LABEL_4022fb;\n      }\n    }\n  }\n  if ((unsigned int)v8 == 4 && !line_len) {\n    __sysv_signal(2, v6);\n    gprompt = 0;\n    return 0;\n  }\n  gprompt = 0;\n  trans_utf8(&line_t.0, &line);\n  return &line_t.0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:43:33: error: expected ';' after top level\ndeclarator 43 | extern unsigned long long line_t.0; | ^ | ;\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:133:27: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 133 | memmove(&line + v10 +\n4, v10 + &line, (line_len - cursorpos) * 4); |                     ~~~~~ ^ ~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:133:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 133 | memmove(&line + v10 +\n4, v10 + &line, (line_len - cursorpos) * 4); | ~~~ ^ ~~~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:218:66: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 218 | tmp_21 = *((int *)&(&g_40a13c)[4 *\nv35]) != 32; |                                                                ~\n^ ~~~ /tmp/tmp1hz24qo6/getline_complete_name_conflict.c:222:73: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 222 | v38 =\nsearch_completion((char *)&line + 0x4 * v36, cursorpos - (char *)v36); | ~~~ ^\n~~~ /tmp/tmp1hz24qo6/getline_complete_name_conflict.c:222:90: error: invalid operands to\nbinary expression ('unsigned int' and 'char *') 222 | v38 =\nsearch_completion((char *)&line + 0x4 * v36, cursorpos - (char *)v36); |\n~~~~~~~~~ ^ ~~~~~~~~~~~ /tmp/tmp1hz24qo6/getline_complete_name_conflict.c:236:55: error:\ninvalid operands to binary expression ('unsigned int *' and 'unsigned int *')\n  236 |                                         memmove(&line + v42 + 4, v42 +\n&line, (line_len - cursorpos) * 4); | ~~~~~ ^ ~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:236:70: error: invalid operands to binary\nexpression ('unsigned int *' and 'unsigned int *') 236 | memmove(&line + v42 +\n4, v42 + &line, (line_len - cursorpos) * 4); | ~~~ ^ ~~~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:300:75: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 300 | print_all_completions((char\n*)&line + 0x4 * v51, cursorpos - (char *)v51); | ~~~ ^ ~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:300:92: error: invalid operands to binary\nexpression ('unsigned int' and 'char *') 300 | print_all_completions((char\n*)&line + 0x4 * v51, cursorpos - (char *)v51); | ~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:352:42: error: invalid operands to binary\nexpression ('char *' and 'unsigned int *') 352 |                 v44 = *((int\n*)(&history + v43)); |                                 ~~~~~~~~ ^ ~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:355:27: error: invalid operands to binary\nexpression ('unsigned int *' and 'char *') 355 |                 v46 = v43 +\n&history; |                       ~~~ ^ ~~~~~~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:397:43: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 397 |                 v21 = (char\n*)&line + 0x4 * v20; |                                       ~~~ ^ ~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:428:49: error: invalid operands to binary\nexpression ('int' and 'unsigned int *') 428 |                     memmove((char\n*)&line + 0x4 * v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~~ ^\n~~~ /tmp/tmp1hz24qo6/getline_complete_name_conflict.c:428:76: error: invalid operands to\nbinary expression ('int' and 'unsigned int *') 428 | memmove((char *)&line + 0x4\n* v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~~ ^ ~~~\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:428:87: error: invalid operands to binary\nexpression ('unsigned int' and 'char *') 428 |                     memmove((char\n*)&line + 0x4 * v28, (char *)&line + 0x4 * v27, (v3 - (char *)v27) * 4); | ~~ ^\n~~~~~~~~~~~ /tmp/tmp1hz24qo6/getline_complete_name_conflict.c:477:23: error: expected ')' 477\n|     trans_utf8(&line_t.0, &line); |                       ^\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:477:15: note: to match this '('\n  477 |     trans_utf8(&line_t.0, &line);\n      |               ^\n/tmp/tmp1hz24qo6/getline_complete_name_conflict.c:478:19: error: expected ';' after return\nstatement 478 |     return &line_t.0; |                   ^ | ; 18 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int completions;\nextern unsigned long long current_num_completions;\n\nlong long init_completion_name_conflict(char a0[2]) {\n  unsigned long v1; // rdx, Other Possible Types: unsigned long long\n  unsigned long v2; // rax\n  void *v3;         // rcx\n\n  if (current_num_completions == 0x800)\n    return 1;\n  v1 = a0[0];\n  v2 = 0;\n  if (!(char)v1) {\n    (&completions)[0x1000 * current_num_completions + v2] = 0;\n    current_num_completions = current_num_completions + 1;\n    return 0;\n  }\n  v3 = &(&completions)[0x1000 * current_num_completions];\n  v2 = 1;\n  while (true) {\n    *((unsigned int *)(-4 + (char *)v3 + 4 * v2)) = v1;\n    v1 = a0[v2];\n    if (!(char)v1)\n      break;\n    v2 += 1;\n    if (v2 == 0x1000) {\n      memset(v3, 0, 0x4000);\n      return 1;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint compl_eqcompar; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern unsigned long long completions;\nextern unsigned long long current_num_completions;\nextern struct_0 *memsize;\n\nlong long completion_exists_name_conflict(struct_0 *a0) {\n  int tmp_37;       // tmp #37\n  char v0;          // [bp-0x400c]\n  unsigned int v1;  // [bp-0x4008]\n  unsigned long v3; // rdx, Other Possible Types: unsigned long long\n  unsigned long v4; // rax\n  struct_0 *v5;     // rax, Other Possible Types: unsigned long\n  struct_0 *v6;     // r8, Other Possible Types: unsigned long\n\n  v3 = a0->field_0;\n  if (!(char)v3) {\n    v5 = 0;\n    v6 = 0;\n  } else {\n    v4 = 1;\n    do {\n      *((unsigned int *)&(&v0)[4 * v4]) = v3;\n      v3 = a0[v4].field_0;\n      tmp_37 = (unsigned int)v4 == 4095;\n      v6 = v4;\n      v4 += 1;\n    } while (!tmp_37 && (char)v3);\n    v5 = v6;\n  }\n  (&v1)[v5] = 0;\n  memsize = v6;\n  return lfind(&v1, &completions, &current_num_completions, 0x4000,\n               compl_eqcompar);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw4ozo5ut/completion_exists_name_conflict.c:55:10: error: array subscript is not an\ninteger 55 |     (&v1)[v5] = 0; |          ^~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/sergiobenrocha2_mgba/src/third-party/zlib/examples/enough.c"}
{"compilable":0,"function":"int unique_chars(char str[]) {\n    char c;\n    int i, j, len = strlen(str);\n    for (i = 0; i < len; i++) {\n        c = str[i];\n        for (j = i + 1; j < len; j++) {\n            if (str[j] == c)\n                return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long unique_chars_name_conflict(char *a0) {\n  char *v1;              // rbx\n  unsigned long long v2; // rax\n  unsigned long long v3; // rdx\n  char v7;               // dl\n  char *v8;              // rsi\n  unsigned long long v9; // rcx\n  char *v10;             // rax, Other Possible Types: unsigned long\n  char *v11;             // rcx, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = strlen(a0);\n  if ((unsigned int)v2 <= 0)\n    return 1;\n  v3 = v2 - 1;\n  v11 = v1;\n  while (true) {\n    v7 = *((char *)v11);\n    if (v11 == &v1[v3])\n      return 1;\n    v8 = v11 + 1;\n    v9 = &v1[v2 + 2 + -1 * v11 + v11 + 2];\n    v10 = v8;\n    do {\n      if (*((char *)v10) == v7)\n        return 0;\n    } while ((v10 += 1, v10 != v9));\n    if (&v1[v3 + 1] == v8)\n      return 1;\n    v11 = v8;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx1cos6ge/unique_chars_name_conflict.c:40:30: error: invalid operands to binary\nexpression ('int' and 'char *') 40 |         v9 = &v1[v2 + 2 + -1 * v11 + v11 +\n2]; |                           ~~ ^ ~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":0,"function":"int unique_chars2(char str[]) {\n    char freq[26];\n    int i, len = strlen(str);\n    for (i = 0; i < 26; i++)\n        freq[i] = 0;\n    for (i = 0; i < len; i++)\n        freq[tolower(str[i]) - 'a']++;\n    for (i = 0; i < 26; i++)\n        if (freq[i] > 1)\n            return 0;\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":0,"function":"int *shuffle(int n) {\n    int *shuffled = (int *)calloc(n, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        shuffled[i] = i;\n    }\n    int temp;\n    for (int i = n - 1; i >= 0; i--) {\n        int pos = rand() % (i + 1);\n        temp = shuffled[i];\n        shuffled[i] = shuffled[pos];\n        shuffled[pos] = temp;\n    }\n    return shuffled;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long shuffle_name_conflict(unsigned int a0) {\n  unsigned int *v1;      // rbp\n  unsigned long v2;      // rax\n  unsigned long long v3; // rax\n  unsigned int v4;       // esi\n  unsigned int *v5;      // rax\n  unsigned long v6;      // rbx\n\n  v1 = calloc(a0, 4);\n  if (a0 > 0) {\n    v2 = 0;\n    do {\n      v1[v2] = v2;\n      v2 += 1;\n    } while (a0 != v2);\n    v6 = a0 - 1;\n  } else {\n    v6 = a0 - 1;\n    if ((int)(a0 - 1) < 0)\n      return v1;\n  }\n  do {\n    (unsigned int)v3 = rand();\n    v4 = v1[v6];\n    v5 = &v1[((unsigned int)v3 >> 31 CONCAT(unsigned int) v3) /\n                 m((unsigned int)v6 + 1) >>\n             32];\n    v1[v6] = *(v5);\n    *(v5) = v4;\n    v6 -= 1;\n  } while ((unsigned int)v6 >= 0);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmdev1p5k/shuffle_name_conflict.c:46:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 46 |         (unsigned int)v3 = rand(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpmdev1p5k/shuffle_name_conflict.c:48:42: error: expected ')' 48 | v5\n= &v1[((unsigned int)v3 >> 31 CONCAT (unsigned int)v3) /m ((unsigned int)v6 + 1)\n>> 32]; |                                          ^\n/tmp/tmpmdev1p5k/shuffle_name_conflict.c:48:18: note: to match this '('\n   48 |         v5 = &v1[((unsigned int)v3 >> 31 CONCAT (unsigned int)v3) /m\n((unsigned int)v6 + 1) >> 32]; |                  ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"int check_prefix(const char *prefix, const char *str) {\n    return strncmp(prefix, str, strlen(prefix)) == 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long check_prefix_name_conflict(char *a0, char *a1) {\n  return !strncmp(a0, a1, strlen(a0));\n}\n","pass":1,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":0,"function":"int read_labels(int **vector, int out_instances, int out_nodes, char *filename) {\n    FILE *labelset = fopen(filename, \"r\");\n    int bufflen = 20;\n    char *line = (char *)calloc(bufflen, sizeof(char));\n    int i = 0;\n    int min = 2147483647;\n    int max = (-2147483647 - 1);\n    while (fgets(line, bufflen, labelset))\n        {\n            (*vector)[i] = atoi(line);\n            if ((*vector)[i] < min)\n                min = (*vector)[i];\n            if ((*vector)[i] > max)\n                max = (*vector)[i];\n            i++;\n            if (i > out_instances) {\n                fprintf(stderr, \"ERROR: Too few allocated out rows!\\n\");\n                exit(1);\n            }\n        }\n    if (pow(2., out_nodes) < (max - min)) {\n        fprintf(stderr, \"ERROR: Too few nodes to represent the outputs!\\n\");\n        exit(1);\n    }\n    if (min != 0) {\n        for (int i = 0; i < out_instances; i++)\n            (*vector)[i] -= min;\n    }\n    free(line);\n    fclose(labelset);\n    return min;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\ndouble(pow)(double, double);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_labels(struct struct_0 **a0, unsigned long a1, unsigned long a2,\n                      char *a3) {\n  FILE_t *v0;            // [bp-0x48]\n  unsigned int v1;       // [bp-0x3c]\n  char *v3;              // r14\n  unsigned int *v4;      // rbx, Other Possible Types: unsigned long\n  unsigned long long v5; // rax\n  unsigned long long v6; // rbp, Other Possible Types: unsigned long\n  unsigned long long v7; // r12, Other Possible Types: unsigned long\n  unsigned long long v8; // r12\n  unsigned long v9;      // rax\n  void *v11;             // rdx, Other Possible Types: unsigned long\n  unsigned int *v12;     // rcx\n\n  v1 = a2;\n  v0 = &fopen(a3, \"r\")->_flags;\n  v3 = calloc(20, 1);\n  v4 = 0;\n  v7 = 0x80000000;\n  v6 = 2147483647;\n  while (fgets(v3, 20, v0)) {\n    (*(a0))[v4].field_0 = strtol(v3, NULL, 10);\n    v5 = (*(a0))[v4].field_0;\n    if ((unsigned int)v5 < (unsigned int)v6)\n      v6 = v5;\n    if ((unsigned int)v7 < (unsigned int)v5)\n      v7 = v5;\n    v4 += 1;\n    if ((unsigned int)a1 < (unsigned int)v4) {\n      fwrite(\"ERROR: Too few allocated out rows!\\n\", 1, 35,\n             stderr @GLIBC_2.2.5);\n      exit(1); /* do not return */\n    }\n  }\n  pow(0x4000000000000000, v1);\n  v8 = v7 - v6;\n  if ((((char)(CmpF(v8, 0x4000000000000000) & 69) |\n        (char)((CmpF(v8, 0x4000000000000000) & 69) >> 6)) &\n       1) != 1) {\n    fwrite(\"ERROR: Too few nodes to represent the outputs!\\n\", 1, 47,\n           stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n  if (!(unsigned int)v6) {\n    free(v3);\n    fclose(v0);\n    return v6;\n  }\n  v9 = (unsigned int)a1;\n  if ((unsigned int)v9 > 0) {\n    v11 = 0;\n    do {\n      v12 = v11 + (char *)*(a0);\n      *(v12) = *(v12) - (unsigned int)v6;\n      v11 += 4;\n    } while (v11 != v9 * 4);\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn20lt_hf/read_labels.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpn20lt_hf/read_labels.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpn20lt_hf/read_labels.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmpn20lt_hf/read_labels.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpn20lt_hf/read_labels.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmpn20lt_hf/read_labels.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpn20lt_hf/read_labels.c:16:8: error: conflicting types for 'fgets'\n   16 | char *(fgets)(char *, int, struct FILE_t {\n      |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmpn20lt_hf/read_labels.c:142:16: error:\nredefinition of '_IO_marker' 142 | typedef struct _IO_marker { | ^\n/tmp/tmpn20lt_hf/read_labels.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpn20lt_hf/read_labels.c:148:16: error: redefinition of '_IO_codecvt'\n  148 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpn20lt_hf/read_labels.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpn20lt_hf/read_labels.c:152:16: error: redefinition of '_IO_wide_data'\n  152 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpn20lt_hf/read_labels.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpn20lt_hf/read_labels.c:175:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 175 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpn20lt_hf/read_labels.c:177:16: error: redeclaration of 'stderr' with a\ndifferent type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka 'struct\n_IO_FILE *') 177 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpn20lt_hf /\n        read_labels.c : 177 : 22 : error\n    : expected ';' after top level declarator 177 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpn20lt_hf /\n        read_labels.c : 201 : 16 : error\n    : array subscript is not an integer 201 |\n    (*(a0))[v4].field_0 = strtol(v3, NULL, 10);\n|\n    ^~~/ tmp / tmpn20lt_hf /\n        read_labels.c : 202 : 21 : error\n    : array subscript is not an integer 202 |\n    v5 = (*(a0))[v4].field_0;\n| ^~~/ tmp / tmpn20lt_hf / read_labels.c : 210 : 73 : error : expected ')' 210 |\n    fwrite(\"ERROR: Too few allocated out rows!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpn20lt_hf /\n        read_labels.c : 210 : 19 : note : to match this '(' 210 |\n    fwrite(\"ERROR: Too few allocated out rows!\\n\", 1, 35, stderr @GLIBC_2.2.5);\n| ^/ tmp / tmpn20lt_hf / read_labels.c : 218 : 81 : error : expected ')' 218 |\n    fwrite(\"ERROR: Too few nodes to represent the outputs!\\n\", 1, 47,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpn20lt_hf /\n        read_labels.c : 218 : 15 : note : to match this '(' 218 |\n    fwrite(\"ERROR: Too few nodes to represent the outputs!\\n\", 1, 47,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpn20lt_hf /\n        read_labels.c : 233 : 23 : error\n    : invalid operands to binary expression('void *' and 'char *') 233 |\n    v12 = v11 + (char *)*(a0);\n| ~~~^~~~~~~~~~~~~~17 errors generated.\n\n                       * /\n","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":0,"function":"char *remove_whitespace(char *str) {\n    char *end;\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISspace))\n        str++;\n    if (*str == 0)\n        return str;\n    end = str + strlen(str) - 1;\n    while (end > str && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        end--;\n    *(end + 1) = 0;\n    return str;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long remove_whitespace_name_conflict(char *a0) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v2; // rbp\n  unsigned long long v3; // rax\n  char v4[2];            // rax, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = *((long long *)&__ctype_b_loc());\n  while (true) {\n    v3 = *((char *)v1);\n    if (!(*((char *)(v2 + ((char)v3 << 1) + 1)) & 32))\n      break;\n    v1 += 1;\n  }\n  if (!(char)v3)\n    return v1;\n  v4 = v1 + strlen(v1) - 1;\n  if (v1 < v4) {\n    while ((*((char *)(v2 + (*((char *)v4) << 1) + 1)) & 32) &&\n           (v4 -= 1, v1 != v4))\n      ;\n  }\n  *((char *)(v4 + 1)) = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkgqqnv_p/remove_whitespace_name_conflict.c:25:25: error: cannot take the address of an\nrvalue of type 'int' 25 |     v2 = *((long long *)&__ctype_b_loc()); |\n^~~~~~~~~~~~~~~~ /tmp/tmpkgqqnv_p/remove_whitespace_name_conflict.c:35:8: error: array type\n'char[2]' is not assignable 35 |     v4 = v1 + strlen(v1) - 1; |     ~~ ^\n/tmp/tmpkgqqnv_p/remove_whitespace_name_conflict.c:38:73: error: invalid operands to binary\nexpression ('char[2]' and 'int') 38 |         while ((*((char *)(v2 + (*((char\n*)v4) << 1) + 1)) & 32) && (v4 -= 1, v1 != v4)) | ~~ ^  ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kevinvandervlist_kesh/tokenize.c"}
{"compilable":0,"function":"int p(z)\n    int z;\n {\n    putchar(\"UniBwM\"[z % 6]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntyp_name_conflictedef unsigned int BOT;\ntyp_name_conflictedef unsigned int uint;\ntyp_name_conflictedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntyp_name_conflictedef unsigned int BOT;\ntyp_name_conflictedef unsigned int uint;\ntyp_name_conflictedef unsigned long ulong;\n\nint(p_name_conflictutchar)(int);\n\nlong long p_name_conflict(unsigned long a0) {\n  return p_name_conflictutchar(*((char *)(4202500 + a0 + -6 * a0 / 6 + 6 * (a0 >> 31))));\n}\n","pass":0,"source_file":"C_COMPILE/florianl_stander/stander.c"}
{"compilable":0,"function":"unsigned int get_baud(unsigned int baud_rate) {\n    unsigned int BAUD = 0;\n    switch (baud_rate) {\n      case 921600:\n        BAUD = 4103;\n        break;\n      case 460800:\n        BAUD = 4100;\n        break;\n      case 230400:\n        BAUD = 4099;\n        break;\n      case 115200:\n        BAUD = 4098;\n        break;\n      default:\n        printf(\"Baud rate not recognized, using default B57600\\n\");\n      case 57600:\n        BAUD = 4097;\n        break;\n      case 38400:\n        BAUD = 15;\n        break;\n      case 19200:\n        BAUD = 14;\n        break;\n      case 9600:\n        BAUD = 13;\n        break;\n      case 4800:\n        BAUD = 12;\n        break;\n      case 2400:\n        BAUD = 11;\n        break;\n      case 1800:\n        BAUD = 10;\n        break;\n      case 1200:\n        BAUD = 9;\n        break;\n      case 600:\n        BAUD = 8;\n        break;\n      case 300:\n        BAUD = 7;\n        break;\n      case 200:\n        BAUD = 6;\n        break;\n      case 150:\n        BAUD = 5;\n        break;\n      case 134:\n        BAUD = 4;\n        break;\n      case 110:\n        BAUD = 3;\n        break;\n      case 75:\n        BAUD = 2;\n        break;\n      case 50:\n        BAUD = 1;\n        break;\n    }\n    return BAUD;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long get_baud_name_conflict(unsigned long a0) {\n  if ((unsigned int)a0 == 2400)\n    return 11;\n  if (!((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rdi,\n                                             0x960 < 64 >, cc_ndep))) {\n    if ((unsigned int)a0 == 0xe100) {\n      return 4097;\n    } else if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rdi,\n                                                    0x960 < 64 >, cc_ndep)) {\n      if ((unsigned int)a0 == 0x4b00) {\n        return 14;\n      } else if ((char)[D] amd64g_calculate_condition(\n                     0x6 < 64 >, 0x7 < 64 >, rdi, 0x960 < 64 >, cc_ndep)) {\n        if ((unsigned int)a0 == 4800) {\n          return 12;\n        } else if ((unsigned int)a0 == 9600) {\n          return 13;\n        }\n      } else {\n        if ((unsigned int)a0 == 0x9600)\n          return 15;\n      }\n    } else {\n      if ((unsigned int)a0 == 0x70800) {\n        return 4100;\n      } else if ((char)[D] amd64g_calculate_condition(\n                     0x6 < 64 >, 0x7 < 64 >, rdi, 0x960 < 64 >, cc_ndep)) {\n        if ((unsigned int)a0 == 0x1c200) {\n          return 4098;\n        } else if ((unsigned int)a0 == 0x38400) {\n          return 4099;\n        }\n      } else {\n        if ((unsigned int)a0 == 0xe1000)\n          return 4103;\n      }\n    }\n  } else {\n    if ((unsigned int)a0 == 200) {\n      return 6;\n    } else if ((char)[D] amd64g_calculate_condition(0x6 < 64 >, 0x7 < 64 >, rdi,\n                                                    0x960 < 64 >, cc_ndep)) {\n      if ((unsigned int)a0 == 110) {\n        return 3;\n      } else if ((char)[D] amd64g_calculate_condition(\n                     0x6 < 64 >, 0x7 < 64 >, rdi, 0x960 < 64 >, cc_ndep)) {\n        if ((unsigned int)a0 == 50) {\n          return 1;\n        } else if ((unsigned int)a0 == 75) {\n          return 2;\n        }\n      } else {\n        if ((unsigned int)a0 == 134) {\n          return 4;\n        } else if ((unsigned int)a0 == 150) {\n          return 5;\n        }\n      }\n    } else {\n      if ((unsigned int)a0 == 1200) {\n        return 9;\n      } else if ((char)[D] amd64g_calculate_condition(\n                     0x6 < 64 >, 0x7 < 64 >, rdi, 0x960 < 64 >, cc_ndep)) {\n        if ((unsigned int)a0 == 300) {\n          return 7;\n        } else if ((unsigned int)a0 == 600) {\n          return 8;\n        }\n      } else {\n        if ((unsigned int)a0 == 1800)\n          return 10;\n      }\n    }\n  }\n  puts(\"Baud rate not recognized, using default B57600\");\n  return 4097;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp59kx3_de/get_baud_name_conflict.c:21:17: error: expected expression\n   21 |     if (!((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>, rdi,\n0x960<64>, cc_ndep))) |                 ^ /tmp/tmp59kx3_de/get_baud_name_conflict.c:27:24:\nerror: expected expression 27 |         else if ((char)[D]\namd64g_calculate_condition(0x6<64>, 0x7<64>, rdi, 0x960<64>, cc_ndep)) | ^\n/tmp/tmp59kx3_de/get_baud_name_conflict.c:33:28: error: expected expression\n   33 |             else if ((char)[D] amd64g_calculate_condition(0x6<64>,\n0x7<64>, rdi, 0x960<64>, cc_ndep)) |                            ^\n/tmp/tmp59kx3_de/get_baud_name_conflict.c:56:28: error: expected expression\n   56 |             else if ((char)[D] amd64g_calculate_condition(0x6<64>,\n0x7<64>, rdi, 0x960<64>, cc_ndep)) |                            ^\n/tmp/tmp59kx3_de/get_baud_name_conflict.c:80:24: error: expected expression\n   80 |         else if ((char)[D] amd64g_calculate_condition(0x6<64>, 0x7<64>,\nrdi, 0x960<64>, cc_ndep)) |                        ^\n/tmp/tmp59kx3_de/get_baud_name_conflict.c:86:28: error: expected expression\n   86 |             else if ((char)[D] amd64g_calculate_condition(0x6<64>,\n0x7<64>, rdi, 0x960<64>, cc_ndep)) |                            ^\n/tmp/tmp59kx3_de/get_baud_name_conflict.c:115:28: error: expected expression\n  115 |             else if ((char)[D] amd64g_calculate_condition(0x6<64>,\n0x7<64>, rdi, 0x960<64>, cc_ndep)) |                            ^ 7 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"int serial_init(char *port_name, unsigned int baud) {\n    struct termios orig_termios, cur_termios;\n    int br = get_baud(baud);\n    fd = open(port_name, 2 | 256 | 2048);\n    if (fd == -1) {\n        printf(\"opening modem serial device : fd < 0\\n\");\n        return -1;\n    }\n    if (tcgetattr(fd, &orig_termios)) {\n        printf(\"getting modem serial device attr\\n\");\n        return -2;\n    }\n    cur_termios = orig_termios;\n    cur_termios.c_iflag &= ~(1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 1024 | 2048 | 4096 | 8192);\n    cur_termios.c_iflag |= 2;\n    cur_termios.c_oflag &= ~(1 | 4 | 8 | 16 | 32);\n    cur_termios.c_cflag &= ~(48 | 64 | 128 | 256 | 512 | 1024 | 2048);\n    cur_termios.c_cflag |= 128 | 48 | 2048;\n    cur_termios.c_cflag &= ~(2147483648U);\n    cur_termios.c_lflag &= ~(1 | 2 | 32768 | 8 | 4096 | 16384);\n    cur_termios.c_lflag |= 128;\n    if (cfsetspeed(&cur_termios, br)) {\n        printf(\"setting modem serial device speed\\n\");\n        return -3;\n    }\n    if (tcsetattr(fd, 1, &cur_termios)) {\n        printf(\"setting modem serial device attr\\n\");\n        return -4;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get_baud)(long long);\nint(open)(char *, int, unsigned short);\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(cfsetspeed)(\n    struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *,\n    unsigned int);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern unsigned int fd;\n\nlong long serial_init_name_conflict(char *a0, unsigned long long a1, unsigned long a2) {\n  termios v0;             // [bp-0x98], Other Possible Types: unsigned long long\n  int tmp_19;             // tmp #19\n  int tmp_110;            // tmp #110\n  unsigned int v1;        // [bp-0x94]\n  unsigned int v2;        // [bp-0x90], Other Possible Types: unsigned long long\n  unsigned int v3;        // [bp-0x8c]\n  int v4;                 // [bp-0x88]\n  int v5;                 // [bp-0x78]\n  int v6;                 // [bp-0x6c]\n  termios v7;             // [bp-0x58]\n  char v8;                // [bp-0x50]\n  char v9;                // [bp-0x48]\n  char v10;               // [bp-0x38]\n  int v11;                // [bp-0x2c]\n  unsigned long v14;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v16; // rax\n\n  v14 = open(a0, 2306, a2);\n  fd = v14;\n  if ((unsigned int)v14 == -1) {\n    puts(\"opening modem serial device : fd < 0\");\n    return v14;\n  } else if (!tcgetattr(v14, &v7)) {\n    v0 = *((long long *)&v7.c_iflag);\n    v2 = *((long long *)&v8);\n    *((int128_t *)&v4) = *((int128_t *)&v9);\n    *((int128_t *)&v5) = *((int128_t *)&v10);\n    *((int128_t *)&v6) = (int128_t)v11;\n    v0.c_iflag = (unsigned int)v0 & -0x3e00 | 2;\n    tmp_19 = *((int *)((char *)&v0 + 4));\n    v1 = tmp_19 & -62;\n    v2 = (int)v2 & 2147479567 | 2224;\n    tmp_110 = *((int *)((char *)&v2 + 4));\n    v16 = tmp_110 & -53260;\n    *((char *)&v16) = (char)v16 | 128;\n    v3 = v16;\n    if (cfsetspeed(&v0, get_baud(a1))) {\n      puts(\"setting modem serial device speed\");\n      return 4294967293;\n    }\n    v14 = tcsetattr(fd, 1, &v0);\n    if ((unsigned int)v14) {\n      puts(\"setting modem serial device attr\");\n      return 0xfffffffc;\n    }\n    return v14;\n  } else {\n    puts(\"getting modem serial device attr\");\n    return 4294967294;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:98:12: error: assigning to 'termios' (aka 'struct\ntermios') from incompatible type 'long long' 98 |         v0 = *((long long\n*)&v7.c_iflag); |            ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:100:22: error: expected expression\n  100 |         *((int128_t *)&v4) = *((int128_t *)&v9);\n      |                      ^\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:100:43: error: expected expression\n  100 |         *((int128_t *)&v4) = *((int128_t *)&v9);\n      |                                           ^\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:101:22: error: expected expression\n  101 |         *((int128_t *)&v5) = *((int128_t *)&v10);\n      |                      ^\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:101:43: error: expected expression\n  101 |         *((int128_t *)&v5) = *((int128_t *)&v10);\n      |                                           ^\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:102:22: error: expected expression\n  102 |         *((int128_t *)&v6) = (int128_t)v11;\n      |                      ^\n/tmp/tmpwqrn7f25/serial_init_name_conflict.c:103:36: error: operand of type 'termios' (aka\n'struct termios') where arithmetic or pointer type is required 103 | v0.c_iflag\n= (unsigned int)v0 & -0x3e00 | 2; |                                    ^~ 7\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"bool in_download_range(int download_id) {\n    if (download_id <= log_index.last_completed_log && download_id > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_4051c4;\n\nlong long in_download_range(unsigned long a0, unsigned long a1,\n                            unsigned long a2) {\n  return (unsigned int)a0 <= g_4051c4 & (unsigned int)a0 > 0;\n}\n","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long uri_decode_name_conflict(char *a0) {\n  struct_0 *v0;     // [bp-0x58]\n  char *v1;         // [bp-0x50]\n  char v2;          // [bp-0x3c]\n  char v3;          // [bp-0x3b]\n  char *v5;         // r13, Other Possible Types: unsigned long\n  unsigned int v6;  // r14d\n  unsigned long v7; // rbx, Other Possible Types: unsigned int\n  char v8;          // al\n\n  v1 = malloc(strlen(a0));\n  v5 = v1;\n  v6 = 1;\n  v7 = 0;\n  for (v0 = &v2; v7 < strlen(a0); v5 += 1) {\n    v8 = a0[v7];\n    if (v8 == 37) {\n      sprintf(&v3, \"%c%c\", a0[1 + v7], a0[2 + v7]);\n      v7 = (unsigned int)v7 + 2;\n      __isoc99_sscanf(&v3, \"%x\", (unsigned int)v0);\n      *((char *)v5) = v2;\n    } else if (v8 != 43) {\n      *((char *)v5) = v8;\n    } else {\n      *((char *)v5) = 32;\n    }\n    v7 = (unsigned int)v7 + 1;\n    v6 += 1;\n  }\n  v1[1 + v6] = 0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/certego_webshell/fuzzdb-webshell/c/cmd.c"}
{"compilable":0,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long uri_decode_name_conflict(char *a0) {\n  struct_0 *v0;     // [bp-0x58]\n  char *v1;         // [bp-0x50]\n  char v2;          // [bp-0x3c]\n  char v3;          // [bp-0x3b]\n  char *v5;         // r13, Other Possible Types: unsigned long\n  unsigned int v6;  // r14d\n  unsigned long v7; // rbx, Other Possible Types: unsigned int\n  char v8;          // al\n\n  v1 = malloc(strlen(a0));\n  v5 = v1;\n  v6 = 1;\n  v7 = 0;\n  for (v0 = &v2; v7 < strlen(a0); v5 += 1) {\n    v8 = a0[v7];\n    if (v8 == 37) {\n      sprintf(&v3, \"%c%c\", a0[1 + v7], a0[2 + v7]);\n      v7 = (unsigned int)v7 + 2;\n      __isoc99_sscanf(&v3, \"%x\", (unsigned int)v0);\n      *((char *)v5) = v2;\n    } else if (v8 != 43) {\n      *((char *)v5) = v8;\n    } else {\n      *((char *)v5) = 32;\n    }\n    v7 = (unsigned int)v7 + 1;\n    v6 += 1;\n  }\n  v1[1 + v6] = 0;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/certego_webshell/web-malware-collection-13-06-2012/Other/cmd.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isAlphanum_name_conflict(unsigned long a0) {\n  unsigned long long v0; // [bp-0x120]\n  unsigned int v2;       // eax\n  unsigned int v3;       // edx\n  unsigned long long v4; // rax\n\n  if ((unsigned int)(a0 - 97) > 25) {\n    v2 = (unsigned int)a0 - 48;\n    if (v2 > 9) {\n      v3 = (unsigned int)a0 - 36;\n      if (v3 > 59) {\n        *((char *)&v2) = (unsigned int)a0 == 92;\n        *((char *)&v3) = 126 < (unsigned int)a0;\n        v4 = v2 | v3;\n        return v4;\n      }\n      v2 = 1;\n      v0 = 612489548785516545;\n      if (((char)(*((char *)&v0 + ((a0 - 36 & 63) >> 3)) >>\n                  (char)(a0 - 36 & 63 & 7)) &\n           1))\n        return 1;\n    }\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *stdin @GLIBC_2.2.5;\nextern unsigned int theLookahead;\n\nlong long get() {\n  unsigned long long v1; // rax\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n\n  v1 = theLookahead;\n  theLookahead = -1;\n  if ((unsigned int)v1 == -1) {\n    (unsigned int)v2 = getc(stdin @GLIBC_2.2.5);\n    if (!(31 >= (unsigned int)v2) || !((unsigned int)v2 != 10)) {\n      return v2;\n    } else if ((unsigned int)v2 == -1) {\n      return v2;\n    } else {\n      v2 = ((unsigned int)v2 != 13 ? 10 : 32);\n      return v2;\n    }\n  }\n  if (!(31 >= (unsigned int)v1) || !((unsigned int)v1 != 10))\n    return v1;\n  if ((unsigned int)v1 == -1)\n    goto LABEL_0x401233;\n  else\n    goto LABEL_0x4011e8;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnhk5uu9b/get.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpnhk5uu9b/get.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpnhk5uu9b/get.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpnhk5uu9b/get.c:76:22: error: type name requires a specifier or qualifier\n   76 |             } __value;\n      |                      ^\n/tmp/tmpnhk5uu9b/get.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpnhk5uu9b/get.c:83:22: error: type name requires a specifier or qualifier\n   83 |             } __value;\n      |                      ^\n/tmp/tmpnhk5uu9b/get.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpnhk5uu9b/get.c:106:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 106 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpnhk5uu9b/get.c:106:21: error: expected ';' after top level declarator\n  106 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmpnhk5uu9b/get.c:118:38: error: expected ')'\n  118 |         (unsigned int)v2 = getc(stdin@GLIBC_2.2.5);\n      |                                      ^\n/tmp/tmpnhk5uu9b/get.c:118:32: note: to match this '('\n  118 |         (unsigned int)v2 = getc(stdin@GLIBC_2.2.5);\n      |                                ^\n/tmp/tmpnhk5uu9b/get.c:136:14: error: use of undeclared label 'LABEL_0x401233'\n  136 |         goto LABEL_0x401233;\n      |              ^\n/tmp/tmpnhk5uu9b/get.c:138:14: error: use of undeclared label 'LABEL_0x4011e8'\n  138 |         goto LABEL_0x4011e8;\n      |              ^\n11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(get)();\n\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int theLookahead;\n\nlong long next_name_conflict() {\n  unsigned long v1;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v2; // rax\n\n  v1 = get();\n  if ((unsigned int)v1 != 47)\n    return v1;\n  theLookahead = get();\n  if (theLookahead == 42) {\n    get();\n    do {\n      do {\n        (unsigned int)v2 = get();\n        if ((unsigned int)v2 == -1) {\n          fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35,\n                 stderr @GLIBC_2.2.5);\n          exit(1); /* do not return */\n        }\n      } while ((unsigned int)v2 != 42);\n    } while ((theLookahead = (unsigned int)(int)get(), theLookahead != 47));\n    get();\n    return 32;\n  } else if (theLookahead != 47) {\n    return v1;\n  } else {\n    do {\n      v1 = get();\n    } while ((unsigned int)v1 > 10);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpofqedlkw/next_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpofqedlkw/next_name_conflict.c:18:22: error: expected ';' after top level declarator\n   18 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpofqedlkw/next_name_conflict.c:37:17: error: assignment to cast is illegal, lvalue\ncasts are not supported 37 |                 (unsigned int)v2 = get(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpofqedlkw/next_name_conflict.c:40:81: error: expected ')' 40 |\nfwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpofqedlkw/next_name_conflict.c:40:27: note: to match this '('\n   40 |                     fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1,\n35, stderr@GLIBC_2.2.5); |                           ^ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"int readNlSock(int sockFd, char *bufPtr, size_t buf_size, int seqNum, int pId) {\n    struct nlmsghdr *nlHdr;\n    int readLen = 0, msgLen = 0;\n    do {\n        if ((readLen = recv(sockFd, bufPtr, buf_size - msgLen, 0)) < 0) {\n            perror(\"SOCK READ: \");\n            return -1;\n        }\n        nlHdr = (struct nlmsghdr *)bufPtr;\n        if ((((readLen) >= (int)sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len <= (readLen)) == 0) || (nlHdr->nlmsg_type == 2)) {\n            perror(\"Error in recieved packet\");\n            return -1;\n        }\n        if (nlHdr->nlmsg_type == 3) {\n            break;\n        } else {\n            bufPtr += readLen;\n            msgLen += readLen;\n        }\n        if ((nlHdr->nlmsg_flags & 2) == 0) {\n            break;\n        }\n    } while ((nlHdr->nlmsg_seq != seqNum) || (nlHdr->nlmsg_pid != pId));\n    return msgLen;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\nvoid(perror)(char *);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char field_6;\n  char padding_7[1];\n  unsigned int field_8;\n  unsigned int field_c;\n} struct_0;\n\nlong long readNlSock(unsigned long a0, struct_0 *a1, unsigned short a2,\n                     unsigned long a3, unsigned long a4) {\n  struct_0 *v1;          // rbx, Other Possible Types: unsigned long\n  unsigned long v2;      // rbp, Other Possible Types: unsigned long long\n  unsigned long long v3; // rax\n  unsigned int v4;       // edx\n\n  v1 = a1;\n  v2 = 0;\n  while (true) {\n    v3 = recv(a0, v1, a2 - v2, 0);\n    if ((unsigned int)v3 < 0) {\n      perror(\"SOCK READ: \");\n      return 4294967295;\n    }\n    if (!((unsigned int)v3 > 15) || !(v4 > 15) || !((unsigned int)v3 >= v4) ||\n        !((a2 = *((short *)(v1 + 4)), a2 != 2)))\n      break;\n    if (a2 == 3)\n      return v2;\n    v2 += v3;\n    if (!(*((char *)(v1 + 6)) & 2))\n      return v2;\n    if (*((int *)(v1 + 8)) == (unsigned int)a3 &&\n        *((int *)(v1 + 12)) == (unsigned int)a4)\n      return v2;\n    v1 = v3 + v1;\n  }\n  perror(\"Error in recieved packet\");\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2sjggmnr/readNlSock.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int parseRoutes(struct nlmsghdr *nlHdr, struct route_info *rtInfo) {\n    struct rtmsg *rtMsg;\n    struct rtattr *rtAttr;\n    int rtLen;\n    rtMsg = (struct rtmsg *)((void *)(((char *)nlHdr) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    if ((rtMsg->rtm_family != 2) || (rtMsg->rtm_table != RT_TABLE_MAIN))\n        return -1;\n    rtAttr = (struct rtattr *)((struct rtattr *)(((char *)(rtMsg)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1))));\n    rtLen = ((nlHdr)->nlmsg_len - ((((((sizeof(struct rtmsg))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    for (; ((rtLen) >= (int)sizeof(struct rtattr) && (rtAttr)->rta_len >= sizeof(struct rtattr) && (rtAttr)->rta_len <= (rtLen)); rtAttr = ((rtLen) -= ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rtAttr)) + ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1))))) {\n        switch (rtAttr->rta_type) {\n          case RTA_OIF:\n            if_indextoname(*(int *)((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), rtInfo->ifName);\n            break;\n          case RTA_GATEWAY:\n            memcpy(&rtInfo->gateWay, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->gateWay));\n            break;\n          case RTA_PREFSRC:\n            memcpy(&rtInfo->srcAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->srcAddr));\n            break;\n          case RTA_DST:\n            memcpy(&rtInfo->dstAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->dstAddr));\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(if_indextoname)(unsigned int, char *);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[12];\n  char field_10;\n  char padding_11[3];\n  char field_14;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_1;\n\nlong long parseRoutes_name_conflict(struct_0 *a0, unsigned int a1[3]) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned long v1;       // [bp-0x18]\n  unsigned long v2;       // [bp-0x10]\n  unsigned long v3;       // [bp-0x8]\n  unsigned long v5;       // r13\n  unsigned long v6;       // r12\n  unsigned long v7;       // rbx\n  unsigned long long v8;  // rax\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n  unsigned long v11;      // rbp, Other Possible Types: unsigned long long\n  struct_1 *v12;          // rbx, Other Possible Types: unsigned long\n  unsigned long v13;      // rax, Other Possible Types: unsigned long long\n\n  if (a0->field_10 != 2)\n    return 4294967295;\n  v3 = v5;\n  v2 = v6;\n  *((int *)&v1) = rbp;\n  v0 = v7;\n  if (a0->field_14 != 254) {\n    v13 = 4294967295;\n    goto LABEL_401379;\n  } else {\n    v12 = &a0[1].padding_4[3];\n    v11 = a0->field_0 - 28;\n    v13 = 0;\n    if ((unsigned int)v11 > 3) {\n      do {\n        v8 = *((short *)v12);\n        if ((unsigned short)v8 << 48 <= 0x3000000000000) {\n        LABEL_401379:\n          return 0;\n        }\n        if ((unsigned int)v8 > (unsigned int)v11)\n          return 0;\n        v9 = *((short *)(v12 + 2));\n        if ((unsigned short)v9 == 5) {\n          *((int *)(a1 + 8)) = *((int *)(v12 + 4));\n        } else if ((unsigned short)v9 << 48 > 0x5000000000000) {\n          if ((unsigned short)v9 == 7)\n            *((int *)(a1 + 4)) = *((int *)(v12 + 4));\n        } else {\n          if ((unsigned short)v9 == 1) {\n            *((int *)a1) = *((int *)(v12 + 4));\n          } else if ((unsigned short)v9 == 4) {\n            a1 += 12;\n            if_indextoname(*((int *)(v12 + 4)), a1);\n          }\n        }\n        v10 = *((short *)v12) + 3 & 0xfffffffc;\n        v11 -= v10;\n        v12 += v10;\n      } while ((unsigned int)v11 > 3);\n      v13 = 0;\n      goto LABEL_401379;\n    }\n  }\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int get_gatewayip(char *gatewayip, socklen_t size) {\n    int found_gatewayip = 0;\n    struct nlmsghdr *nlMsg;\n    struct route_info route_info;\n    char msgBuf[8192];\n    int sock, len, msgSeq = 0;\n    if ((sock = socket(16, SOCK_DGRAM, 0)) < 0) {\n        perror(\"Socket Creation: \");\n        return (-1);\n    }\n    memset(msgBuf, 0, sizeof (msgBuf));\n    nlMsg = (struct nlmsghdr *)msgBuf;\n    nlMsg->nlmsg_len = ((sizeof(struct rtmsg)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n    nlMsg->nlmsg_type = RTM_GETROUTE;\n    nlMsg->nlmsg_flags = (256 | 512) | 1;\n    nlMsg->nlmsg_seq = msgSeq++;\n    nlMsg->nlmsg_pid = getpid();\n    if (send(sock, nlMsg, nlMsg->nlmsg_len, 0) < 0) {\n        fprintf(stderr, \"Write To Socket Failed...\\n\");\n        return -1;\n    }\n    if ((len = readNlSock(sock, msgBuf, sizeof (msgBuf), msgSeq, getpid())) < 0) {\n        fprintf(stderr, \"Read From Socket Failed...\\n\");\n        return -1;\n    }\n    for (; ((len) >= (int)sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len <= (len)); nlMsg = ((len) -= ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlMsg)) + ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n        memset(&route_info, 0, sizeof (route_info));\n        if (parseRoutes(nlMsg, &route_info) < 0)\n            continue;\n        if (strstr((char *)inet_ntoa(route_info.dstAddr), \"0.0.0.0\")) {\n            inet_ntop(2, &route_info.gateWay, gatewayip, size);\n            found_gatewayip = 1;\n            break;\n        }\n    }\n    close(sock);\n    return found_gatewayip;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nvoid(perror)(char *);\nlong(send)(int, void *, unsigned long, int);\nlong long(readNlSock)(long long, long long, long long, long long, long long);\nint(close)(int);\nlong long(parseRoutes)(long long, long long);\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\nchar *(inet_ntop)(int, void *, char *, int);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_gatewayip(unsigned long a0, unsigned long a1) {\n  char v0;                // [bp-0x2058], Other Possible Types: unsigned int\n  unsigned short v1;      // [bp-0x2054]\n  unsigned short v2;      // [bp-0x2052]\n  unsigned int v3;        // [bp-0x204c]\n  int v4;                 // [bp-0x58]\n  int v5;                 // [bp-0x4c]\n  unsigned long long v8;  // rax\n  unsigned int v9;        // r12d\n  unsigned long v10;      // rcx, Other Possible Types: unsigned long long\n  struct_0 *v11;          // rdi, Other Possible Types: unsigned long\n  unsigned long v12;      // d\n  void *v13;              // rbx, Other Possible Types: unsigned long\n  unsigned long v14;      // rax, Other Possible Types: unsigned long long\n  struct_0 *v15;          // rbx, Other Possible Types: unsigned long\n  unsigned int v16;       // edx\n  unsigned long long v17; // rdx\n\n  (unsigned int)v8 = socket(16, 2, 0);\n  if ((unsigned int)v8 < 0) {\n    perror(\"Socket Creation: \");\n    return 4294967295;\n  }\n  v9 = v8;\n  v10 = 0x400;\n  for (v11 = &v0; v10; v11 += v12 * 8) {\n    v10 -= 1;\n    *((long long *)v11) = 0;\n  }\n  v0 = 28;\n  v1 = 26;\n  v2 = 769;\n  v3 = getpid();\n  if (send(v8, &v0, v0, 0) < 0) {\n    fwrite(\"Write To Socket Failed...\\n\", 1, 26, stderr @GLIBC_2.2.5);\n    return 4294967295;\n  }\n  v14 = readNlSock(v8, &v0, 0x2000, 1, getpid());\n  if ((unsigned int)v14 < 0) {\n    fwrite(\"Read From Socket Failed...\\n\", 1, 27, stderr @GLIBC_2.2.5);\n    return 4294967295;\n  }\n  v15 = &v0;\n  if ((unsigned int)v14 <= 15) {\n    v13 = 0;\n    goto LABEL_40153e;\n  } else {\n    do {\n      v16 = *((int *)v15);\n      if (v16 <= 15) {\n      LABEL_40153e:\n        close(v9);\n        return 0;\n      }\n      if ((unsigned int)v14 < v16) {\n        close(v9);\n        return 0;\n      }\n      *((int128_t *)&v4) = 0;\n      *((int128_t *)&v5) = 0;\n      if ((int)parseRoutes(v15, &v4) >= 0 && strstr(inet_ntoa(), \"0.0.0.0\")) {\n        inet_ntop(2, &v4, a0, a1);\n        close(v9);\n        return 1;\n      }\n      v17 = *((int *)v15) + 3 & -0x4;\n      v14 -= v17;\n      v15 += v17;\n    } while ((unsigned int)v14 > 15);\n    v13 = 0;\n    goto LABEL_40153e;\n  }\n  close(v9);\n  return v13;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4fv5dnbh/get_gatewayip.c:19:7: error: conflicting types for 'perror'\n   19 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp4fv5dnbh/get_gatewayip.c:33:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 33 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp4fv5dnbh/get_gatewayip.c:33:22: error: expected ';' after top level\ndeclarator 33 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp4fv5dnbh/get_gatewayip.c:54:5: error: assignment to cast is illegal,\nlvalue casts are not supported 54 |     (unsigned int)v8 = socket(16, 2, 0); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmp4fv5dnbh/get_gatewayip.c:73:60: error: expected ')'\n   73 |         fwrite(\"Write To Socket Failed...\\n\", 1, 26,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp4fv5dnbh/get_gatewayip.c:73:15: note: to match\nthis '(' 73 |         fwrite(\"Write To Socket Failed...\\n\", 1, 26,\nstderr@GLIBC_2.2.5); |               ^ /tmp/tmp4fv5dnbh/get_gatewayip.c:79:61:\nerror: expected ')' 79 |         fwrite(\"Read From Socket Failed...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp4fv5dnbh/get_gatewayip.c:79:15: note: to match\nthis '(' 79 |         fwrite(\"Read From Socket Failed...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); |               ^ /tmp/tmp4fv5dnbh/get_gatewayip.c:104:26:\nerror: expected expression 104 |             *((int128_t *)&v4) = 0; | ^\n/tmp/tmp4fv5dnbh/get_gatewayip.c:105:26: error: expected expression\n  105 |             *((int128_t *)&v5) = 0;\n      |                          ^\n/tmp/tmp4fv5dnbh/get_gatewayip.c:106:69: error: too few arguments to function\ncall, expected 1, have 0 106 |             if ((int)parseRoutes(v15, &v4) >= 0\n&& strstr(inet_ntoa(), \"0.0.0.0\")) | ~~~~~~~~~ ^\n/tmp/tmp4fv5dnbh/get_gatewayip.c:24:8: note: 'inet_ntoa' declared here\n   24 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":1,"function":"int compare_mac(MAC *m1, MAC *m2) {\n    return memcmp(m1, m2, 6);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long compare_mac_name_conflict(void *a0, void *a1) { return memcmp(a0, a1, 6); }\n","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":1,"function":"int compare_ip(IP *ip1, IP *ip2) {\n    return memcmp(ip1, ip2, 4);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long compare_ip_name_conflict(void *a0, void *a1) { return memcmp(a0, a1, 4); }\n","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  char *v4;         // rax\n\n  for (v2 = 1; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 0x100) * 19342813113834067 >> 64 >> 11) * 0x1dcd6500;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 << 4) + 8)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa87d9wo8/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpa87d9wo8/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpa87d9wo8/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500; | ~~~~~~ ^  ~\n/tmp/tmpa87d9wo8/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpa87d9wo8/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[2]; // rbx\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *((long long *)&vocab_size) * 16 + vocab;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (60 < (unsigned int)v2)\n    v2 = 60;\n  v3 = calloc(v2, 1);\n  v1[1] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpztyu28q3/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[2]' is not assignable 33 |     v1 = *((long long *)&vocab_size) * 16 +\nvocab; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  void *v2; // rcx, Other Possible Types: unsigned long\n  char *v4; // rax\n\n  for (v2 = 0; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpprs37qg7/GetWordHash_name_conflict.c:27:22: error: invalid operands to binary\nexpression ('void *' and 'int') 27 |         v2 = v2 + v2 * 0x100 + *((char\n*)rax); |                   ~~ ^ ~~~~~ /tmp/tmpprs37qg7/GetWordHash_name_conflict.c:29:22:\nerror: invalid operands to binary expression ('void *' and 'int') 29 | return v2\n- ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000; | ~~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 + (v4 << 2) << 3) + 16)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfaz6uwjg/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpfaz6uwjg/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpfaz6uwjg/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000; | ~~~~~~ ^  ~\n/tmp/tmpfaz6uwjg/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpfaz6uwjg/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[3]; // rbp\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = vocab + *((long long *)&vocab_size) * 40;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (100 < (unsigned int)v2)\n    v2 = 100;\n  v3 = calloc(v2, 1);\n  v1[2] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 7) * 18764999 >> 42) * 30000000;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaggybx3d/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[3]' is not assignable 33 |     v1 = vocab + *((long long *)&vocab_size) *\n40; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":0,"function":"char *rat(char *message) {\n    char *cyphertext = (char *)malloc(sizeof(char) * strlen(message));\n    int i;\n    for (i = 0; i < strlen(message); i++) {\n        cyphertext[i] = (isalpha(message[i])) ? (((message[i] + 13 - 'a') % 26) + 'a') : message[i];\n    }\n    return cyphertext;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(isalpha)(int);\n\nlong long rat_name_conflict(char *a0) {\n  unsigned long v1; // rax\n  unsigned long v2; // rbp\n  unsigned int v3;  // ebx\n\n  v1 = malloc(strlen(a0));\n  for (v2 = 0; v2 < strlen(a0); v2 += 1) {\n    v3 = a0[v2];\n    *((char *)(v1 + v2)) = v3 - 84 - (unsigned int)((v3 - 84) / 26) * 26 + 97;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/chamoysvoice_rat13/rat13.c"}
{"compilable":1,"function":"int is_delimeter(char c) {\n    int ii = 0;\n    char dlms[] = \"\\t\\r\\n (){}[]+-*/%\\\"'&|^~:;<>.,\";\n    while (dlms[ii])\n        {\n            if (c == dlms[ii++])\n                return 1;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long is_delimeter_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x28]\n  char v1;               // [bp-0x27]\n  char v2;               // [bp-0x1c]\n  unsigned long long v4; // rdx\n  struct_0 *v5;          // rax, Other Possible Types: unsigned long\n  char v6;               // dl\n\n  strncpy(&v0, \"\\t\\r\\n (){}[]+-*/%\\\"\", 16);\n  v4 = 12435743808633470;\n  strncpy(&v2, \"*/%\\\"\\'&|^~:;<>.,\", 15);\n  v5 = &v0;\n  while (v6) {\n    v6 = *((char *)v5);\n    v5 = &v1;\n    if (v6 == (char)a0)\n      return 1;\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":0,"function":"int is_keyword(char *str) {\n    char *kwords[] = {\"asm\", \"auto\", \"break\", \"case\", \"cdecl\", \"char\", \"class\", \"const\", \"continue\", \"default\", \"delete\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"far\", \"float\", \"for\", \"friend\", \"goto\", \"huge\", \"if\", \"inline\", \"int\", \"interrupt\", \"long\", \"near\", \"new\", \"operator\", \"pascal\", \"private\", \"protected\", \"public\", \"register\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"template\", \"this\", \"typedef\", \"union\", \"unsigned\", \"virtual\", \"void\", \"volatile\", \"while\", ((void *)0)};\n    int ii = 0;\n    int jj;\n    int check;\n    while (kwords[ii])\n        {\n            jj = 0;\n            check = 1;\n            while (kwords[ii][jj] && check)\n                {\n                    if (str[jj] != kwords[ii][jj]) {\n                        check = 0;\n                    }\n                    jj++;\n                }\n            if (check)\n                return 1;\n            ii++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_404080; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *g_404080;\n\nlong long is_keyword_name_conflict(char a0[2]) {\n  char v0[2];             // [bp-0x1a8], Other Possible Types: unsigned long\n  char v1;                // [bp-0x1a0]\n  char v2;                // [bp-0x198]\n  struct struct_0 **v5;   // rdi, Other Possible Types: unsigned long\n  struct struct_0 **v6;   // rsi, Other Possible Types: unsigned long\n  unsigned long v7;       // rcx, Other Possible Types: unsigned long long\n  unsigned long v8;       // d\n  unsigned long v9;       // rcx\n  unsigned long long v10; // rsi\n  char v12;               // dl\n  unsigned long v13;      // rax\n  unsigned long long v14; // rsi\n\n  v5 = v0;\n  v6 = &g_404080;\n  for (v7 = 52; v7; v6 += v8 * 8) {\n    v7 -= 1;\n    *((long long *)v5) = *((long long *)v6);\n    v5 += v8 * 8;\n  }\n  v9 = v0;\n  if (!v9)\n    return 0;\n  v10 = &v1;\n  while (true) {\n    v12 = *((char *)v9);\n    if (!v12)\n      return 1;\n    v13 = 0;\n    while (a0[v13] == v12) {\n      v13 += 1;\n      v12 = *((char *)(v9 + v13));\n      if (!v12)\n        return 1;\n    }\n    v14 = &v2;\n    v9 = *((long long *)&v1);\n    if (!v9)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpntakkjvg/is_keyword_name_conflict.c:18:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 18 | extern struct_0 *g_404080; |        ^~~~~~~~ |        struct\n/tmp/tmpntakkjvg/is_keyword_name_conflict.c:18:8: error: declaration of anonymous struct must\nbe a definition 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":0,"function":"static int load_uca_file(MY_UCA *uca, size_t maxchar, int *pageloaded) {\n    char str[512];\n    size_t lineno, out_of_range_chars = 0;\n    char *weights[64];\n    for (lineno = 0; fgets(str, sizeof (str), stdin); lineno++) {\n        char *comment;\n        char *weight;\n        char *s, *ch[6];\n        size_t codenum, i, code;\n        MY_UCA_ITEM *item = ((void *)0);\n        if (*str == '\\r' || *str == '\\n' || *str == '#')\n            continue;\n        if (*str == '@' && !strncmp(str, \"@version \", 9)) {\n            const char *value;\n            if (strtok(str, \" \\r\\n\\t\") && (value = strtok(((void *)0), \" \\r\\n\\t\")))\n                snprintf(uca->version, 32, value);\n            continue;\n        }\n        if ((code = strtol(str, ((void *)0), 16)) > maxchar) {\n            out_of_range_chars++;\n            continue;\n        }\n        if ((comment = strchr(str, '#'))) {\n            *comment++ = '\\x00';\n            for (; *comment == ' '; comment++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n'%s'\\n\", lineno, str);\n            continue;\n        }\n        if ((weight = strchr(str, ';'))) {\n            *weight++ = '\\x00';\n            for (; *weight == ' '; weight++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n%s\\n\", lineno, str);\n            continue;\n        }\n        for (codenum = 0 , s = strtok(str, \" \\t\"); s; codenum++ , s = strtok(((void *)0), \" \\t\")) {\n            if (codenum == 6) {\n                fprintf(stderr, \"Contraction length is too long (%d) line #%d\", codenum, lineno);\n                exit(1);\n            }\n            ch[codenum] = s;\n            ch[codenum + 1] = 0;\n        }\n        if (codenum > 1) {\n            MY_UCA_CONTRACTION *c = &uca->contraction[uca->ncontractions++];\n            size_t i;\n            if (uca->ncontractions >= 1024) {\n                fprintf(stderr, \"Too many contractions (%d) at line #%d\\nRebuild with a bigger MY_UCA_MAXCONTRACTIONS value\\n\", uca->ncontractions, lineno);\n                exit(1);\n            }\n            for (i = 0; i < 6; i++) {\n                c->ch[i] = (i < codenum) ? (uint)strtol(ch[i], ((void *)0), 16) : 0;\n            }\n            if (uca->debug)\n                fprintf(stderr, \"Contraction: %04X-%04X-%04X\\n\", c->ch[0], c->ch[1], c->ch[2]);\n            item = &c->item;\n        } else {\n            item = &uca->item[code];\n        }\n        item->num = 0;\n        s = strtok(weight, \" []\");\n        while (s)\n            {\n                if (item->num >= 64) {\n                    fprintf(stderr, \"Line #%d has more than %d weights\\n\", lineno, 64);\n                    fprintf(stderr, \"Can't continue.\\n\");\n                    exit(1);\n                }\n                weights[item->num] = s;\n                s = strtok(((void *)0), \" []\");\n                item->num++;\n            }\n        for (i = 0; i < item->num; i++) {\n            size_t level = 0;\n            if (i >= 8) {\n                fprintf(stderr, \"Warning: at line %d: character %04X has more than %d many weights (%d). Skipping the extra weights.\\n\", lineno, code, 8, item->num);\n                item->num = 8;\n                break;\n            }\n            for (s = weights[i]; *s;) {\n                char *endptr;\n                size_t part = strtol(s + 1, &endptr, 16);\n                if (i < 8) {\n                    item->weight[level][i] = part;\n                } else {\n                    fprintf(stderr, \"Too many weights (%d) at line %d\\n\", i, lineno);\n                    exit(1);\n                }\n                s = endptr;\n                level++;\n            }\n        }\n        pageloaded[code >> 8]++;\n    }\n    if (out_of_range_chars)\n        fprintf(stderr, \"%d out-of-range characters skipped\\n\", out_of_range_chars);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *prefix_name(MY_UCA *uca) {\n    static char prefix[32];\n    char *s, *d;\n    strcpy(prefix, \"uca\");\n    for (s = uca->version , d = prefix + strlen(prefix); *s; s++) {\n        if ((*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'z'))\n            *d++ = *s;\n    }\n    *d = '\\x00';\n    return prefix;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_616375;\nextern unsigned int prefix.1;\n\nlong long prefix_name_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n  char *v2; // rdx, Other Possible Types: unsigned long, unsigned long long\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  *((char **)&prefix.1) = &g_616375;\n  v1 = a0;\n  v2 = (char *)&prefix.1 + strlen(&prefix.1);\n  v3 = *(a0);\n  if ((char)v3) {\n    do {\n      if (v3 - 48 <= 9 || v3 - 97 <= 25) {\n        *((char *)v2) = v3;\n        v2 += 1;\n      }\n    } while ((v1 += 1, v3 = (unsigned long long)*(v1), (char)v3));\n  }\n  *((char *)v2) = 0;\n  return &prefix.1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:18:27: error: expected ';' after top level\ndeclarator 18 | extern unsigned int prefix.1; |                           ^ | ;\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:26:23: error: expected ')'\n   26 |     *((char **)&prefix.1) = &g_616375;\n      |                       ^\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:26:6: note: to match this '('\n   26 |     *((char **)&prefix.1) = &g_616375;\n      |      ^\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:28:25: error: expected ';' after expression\n   28 |     v2 = (char *)&prefix.1 + strlen(&prefix.1);\n      |                         ^\n      |                         ;\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:28:44: error: expected ')'\n   28 |     v2 = (char *)&prefix.1 + strlen(&prefix.1);\n      |                                            ^\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:28:36: note: to match this '('\n   28 |     v2 = (char *)&prefix.1 + strlen(&prefix.1);\n      |                                    ^\n/tmp/tmpa1wj159x/prefix_name_name_conflict.c:42:19: error: expected ';' after return statement\n   42 |     return &prefix.1;\n      |                   ^\n      |                   ;\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *page_name(MY_UCA *uca, size_t page, size_t level) {\n    static char page_name_buf[120];\n    snprintf(page_name_buf, sizeof (page_name_buf), \"%s_p%03X%s\", prefix_name(uca), page, pname[level]);\n    return page_name_buf;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static size_t normalize_weight(MY_UCA_ITEM *item, size_t level, uint16 *weight, size_t weight_elements) {\n    size_t num, i;\n    memset(weight, 0, weight_elements * sizeof (*weight));\n    for (num = 0 , i = 0; i < item->num && i < 8; i++) {\n        if (item->weight[level][i]) {\n            weight[num] = item->weight[level][i];\n            num++;\n        }\n    }\n    return num;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long normalize_weight(char *a0, unsigned long a1, void *a2,\n                           unsigned int a3) {\n  void *v2;          // rax, Other Possible Types: unsigned long\n  unsigned short v3; // dx\n  unsigned short\n      *v4; // rsi, Other Possible Types: unsigned long, unsigned long long\n\n  memset(a2, 0, a3 * 2);\n  if (!*(a0))\n    return 0;\n  v2 = 0;\n  v4 = 0;\n  while (true) {\n    v3 = *((short *)&a0[2 + 16 * a1 + 2 * v2]);\n    if (v3) {\n      *((unsigned short *)((char *)a2 + 2 * v4)) = v3;\n      v4 += 1;\n    }\n    v2 += 1;\n    if (v2 >= *(a0)) {\n      return v4;\n    } else if (v2 > 7) {\n      return v4;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_a9laenh/normalize_weight.c:30:45: error: invalid operands to binary\nexpression ('int' and 'void *') 30 |         v3 = *((short *)&a0[2 + 16 * a1 + 2\n* v2]); |                                           ~ ^ ~~\n/tmp/tmp_a9laenh/normalize_weight.c:33:49: error: invalid operands to binary\nexpression ('int' and 'unsigned short *') 33 |             *((unsigned short\n*)((char *)a2 + 2 * v4)) = v3; |                                               ~\n^ ~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static int weight_cmp(uint16 *w1, uint16 *w2, size_t len) {\n    size_t i;\n    for (i = 0; i < len; i++) {\n        if (w1[i] != w2[i])\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static int get_int_option(const char *str, const char *name, int *num) {\n    size_t namelen = strlen(name);\n    if (!strncmp(str, name, namelen)) {\n        *num = atoi(str + namelen);\n        if (*num == 0 && str[namelen] != '0') {\n            fprintf(stderr, \"\\nBad numeric option value: %s\\n\\n\", str);\n            usage(stderr, 1);\n        }\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(usage)(long long, long long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_int_option_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v1;      // rbx\n  unsigned int *v2;      // edx\n  char *v4;              // rbx\n  unsigned long long v5; // rax\n\n  v1 = strlen(a1);\n  v2 = strncmp(a0, a1, v1);\n  if (v2)\n    return 0;\n  v4 = &a0[v1];\n  (unsigned int)v5 = strtol(v4, NULL, 10);\n  *(v2) = v5;\n  if ((unsigned int)v5) {\n    return 1;\n  } else if (*(v4) != 48) {\n    fprintf(stderr @GLIBC_2.2.5, \"\\nBad numeric option value: %s\\n\\n\",\n            (unsigned int)a0);\n    usage(stderr @GLIBC_2.2.5, 1); /* do not return */\n  } else {\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8t0hnro5/get_int_option_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 18 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp8t0hnro5/get_int_option_name_conflict.c:18:22: error: expected ';' after top level\ndeclarator 18 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp8t0hnro5/get_int_option_name_conflict.c:32:5: error: assignment to cast is illegal,\nlvalue casts are not supported 32 |     (unsigned int)v5 = strtol(v4, NULL, 10);\n      |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp8t0hnro5/get_int_option_name_conflict.c:40:23: error: expected ')'\n   40 |         fprintf(stderr@GLIBC_2.2.5, \"\\nBad numeric option value:\n%s\\n\\n\", (unsigned int)a0); |                       ^\n/tmp/tmp8t0hnro5/get_int_option_name_conflict.c:40:16: note: to match this '('\n   40 |         fprintf(stderr@GLIBC_2.2.5, \"\\nBad numeric option value:\n%s\\n\\n\", (unsigned int)a0); |                ^\n/tmp/tmp8t0hnro5/get_int_option_name_conflict.c:41:21: error: expected ')'\n   41 |         usage(stderr@GLIBC_2.2.5, 1); /* do not return */\n|\n    ^/ tmp / tmp8t0hnro5 /\n        get_int_option_name_conflict.c : 41 : 14 : note : to match this '(' 41 |\n    usage(stderr @GLIBC_2.2.5, 1); /* do not return */\n| ^5 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static _Bool is_color_enabled(void) {\n    const char *env = getenv(\"LESS\");\n    return (env != 0 && (strstr(env, \"-r\") != 0 || strstr(env, \"-R\") != 0));\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/frugalware_frugalware-stable/source/apps/lesspipe/code2color.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v1; // r13d\n  unsigned int v3; // r12d\n  struct struct_1 *\n      *v4;  // rbp, Other Possible Types: unsigned long, unsigned long long\n  char *v5; // rbx, Other Possible Types: unsigned long\n\n  if (!argv)\n    return 4294967295;\n  v1 = a0;\n  if (!argv->field_0)\n    return 4294967295;\n  v5 = argv->field_8;\n  if (!v5)\n    return 4294967295;\n  v4 = 1;\n  v3 = 0;\n  while (true) {\n    if (v3 || (*((char *)v5) - 43 & 253) && !strchr(v5, 61)) {\n      if (v1)\n        v1 -= 1;\n      else\n        return v4;\n    }\n    if (!strcmp(v5, \"--\"))\n      v3 = 1;\n    v4 += 1;\n    v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n    if (!v5)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvrpuudtm/argindex_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmpvrpuudtm/argindex_name_conflict.c:21:8: error: declaration of anonymous struct must be\na definition /tmp/tmpvrpuudtm/argindex_name_conflict.c:33:16: error: member reference type\n'int' is not a pointer 33 |     if (!argv->field_0) |          ~~~~  ^\n/tmp/tmpvrpuudtm/argindex_name_conflict.c:35:16: error: member reference type 'int' is not a\npointer 35 |     v5 = argv->field_8; |          ~~~~  ^\n/tmp/tmpvrpuudtm/argindex_name_conflict.c:52:45: error: member reference type 'int' is not a\npointer 52 |         v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n      |                                       ~~~~  ^\n/tmp/tmpvrpuudtm/argindex_name_conflict.c:52:59: error: invalid operands to binary expression\n('int' and 'struct struct_1 **') 52 |         v5 = *((long long *)((char\n*)&argv->field_0 + 0x8 * v4)); | ~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_1 *field_ - 8;\n} struct_0;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\nextern struct_2 *argv;\n\nlong long OptNArgs_name_conflict() {\n  void *v1;     // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v2;     // rbp, Other Possible Types: unsigned long\n  struct_0 *v3; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned int v4; // r12d\n\n  v1 = 0;\n  if (!argv) {\n    return 0;\n  } else if (!argv->field_0) {\n    return 0;\n  } else {\n    v2 = argv->field_8;\n    if (!v2)\n      return 0;\n    v3 = argv + 1;\n    v4 = 0;\n    do {\n      if (v4 || (*((char *)v2) - 43 & 253) && !strchr(v2, 61))\n        v1 = (unsigned int)v1 + 1;\n      if (!strcmp(v2, \"--\"))\n        v4 = 1;\n      v3 += 8;\n      v2 = v3[1].field_ - 8;\n    } while (v2);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxcpl6pfp/OptNArgs_name_conflict.c:18:28: error: expected ';' at end of declaration\nlist 18 |     struct struct_1 *field_-8; |                            ^ | ;\n/tmp/tmpxcpl6pfp/OptNArgs_name_conflict.c:25:8: error: unknown type name 'struct_2'\n   25 | extern struct_2 *argv;\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long long a0) {\n  unsigned long long *v1; // rax\n\n  v1 = argindex(a0);\n  if ((unsigned int)v1 >= 0)\n    return *((long long *)(argv + v1 * 8));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa3dl3gvt/OptArg_name_conflict.c:26:42: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 26 |         return *((long long *)(argv + v1\n* 8)); |                                       ~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40b175;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char *v1; // rax\n  char v3;  // r13b\n  char *v5; // rbx, Other Possible Types: unsigned long\n  char v6;  // r13b\n  char *v7; // rbx, Other Possible Types: unsigned long\n  char *v8; // rbp, Other Possible Types: unsigned long\n  char *v9; // r12, Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v3 = *(v1);\n    *(v1) = 0;\n    v9 = malloc(strlen(a0) + strlen(a1) + 2);\n    if (v9)\n      sprintf(v9, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v3;\n    return v9;\n  } else {\n    v8 = getenv(\"PATH\");\n    if (!v8)\n      v8 = \".:/bin:/usr/bin\";\n    v9 = malloc(strlen(v8) + strlen(a1) + 2);\n    if (!v9)\n      return v9;\n    while (*((char *)v8)) {\n      v5 = strchr(v8, 58);\n      if (!v5)\n        v5 = v8 + strlen(v8);\n      v6 = *((char *)v5);\n      *((char *)v5) = 0;\n      sprintf(v9, \"%s/%s\", (unsigned int)v8, (unsigned int)a1);\n      *((char *)v5) = v6;\n      v7 = v5 + 1;\n      if (!v6)\n        v7 = &g_40b175;\n      v8 = v7;\n      if (!access(v9, a2))\n        return v9;\n    }\n    return v9;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 < 0) {\n    if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n      return \"signed char\";\n    if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n      return \"int\";\n    return \"short\";\n  } else if ((unsigned int)a1 <= 255) {\n    return \"unsigned char\";\n  } else {\n    return ((unsigned int)a1 <= 65534 ? \"unsigned int\" : \"unsigned short int\");\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v1; // rax\n  char *v2; // rdx, Other Possible Types: unsigned long\n\n  v1 = malloc(size);\n  if (!v1)\n    memory_error(); /* do not return */\n  v2 = v1;\n  if (size <= 0)\n    return v1;\n  do {\n    *((char *)v2) = 0;\n    v2 += 1;\n  } while (v2 != &v1[size]);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rdi\n  char v2;  // al\n\n  v1 = a0 + a1;\n  v2 = *(v1);\n  *(v1) = 1;\n  return !v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rax, Other Possible Types: unsigned long\n  void *v2; // rcx, Other Possible Types: unsigned long long, unsigned long\n\n  if (size <= 0)\n    return 0;\n  v1 = 0;\n  v2 = 0;\n  do {\n    if (*((char *)(a1 + v1)) && !*((char *)(a0 + v1))) {\n      *((char *)(a0 + v1)) = 1;\n      v2 = 1;\n    }\n  } while ((v1 += 1, (unsigned long long)size != v1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  void *v2;              // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = 0;\n  do {\n    v3 = v2 + v2 * 12;\n    a0 += 1;\n    v2 = v3 + v1;\n    v1 = *((char *)a0);\n  } while ((char)v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp__w7seno/strhash_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v3 = v2 + v2 * 12; |                   ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = Strsafe_name_conflict_find(a0);\n  if (v1)\n    return v1;\n  v1 = malloc(strlen(a0) + 1);\n  if (v1) {\n    strcpy(v1, a0);\n    Strsafe_name_conflict_insert(v1);\n    return v1;\n  }\n  memory_error(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_2 {\n  char *field_0;\n  struct struct_2 *field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_1 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned long long *v0;    // [bp-0x58]\n  unsigned long v1;          // [bp-0x50]\n  unsigned int v2;           // [bp-0x48]\n  unsigned int v3;           // [bp-0x44]\n  unsigned long v4;          // [bp-0x40]\n  unsigned long v6;          // rax\n  unsigned int v7;           // r14d\n  struct_2 *v8;              // r12, Other Possible Types: unsigned long\n  unsigned long v9;          // r14\n  unsigned long long *v10;   // rax, Other Possible Types: unsigned long\n  unsigned long long v11;    // rdx\n  unsigned long long v12;    // rcx\n  unsigned long long v13[2]; // r12, Other Possible Types: unsigned long\n  struct struct_0 **v15;     // rax\n  struct_0 *v16;             // rdx\n  struct struct_0 **v17;     // rax\n  unsigned long long v18;    // rdx\n  unsigned long long v19[3]; // rdx\n  struct_0 *v20;             // rsi\n\n  if (!x1a)\n    return 0;\n  v2 = strhash(a0);\n  v7 = x1a->field_0;\n  v8 = *((long long *)(x1a->field_10 + (v7 - 1 & v2) * 8));\n  if (v8) {\n    do {\n      (unsigned int)v6 = strcmp(*((long long *)v8), a0);\n      if (!(unsigned int)v6)\n        return v6;\n    } while ((v8 = *((long long *)(v8 + 8)), v8));\n  }\n  v3 = x1a->field_4;\n  if (v7 <= v3) {\n    v9 = v7 * 2;\n    v4 = malloc(v9 * 32);\n    if (!v4)\n      return 0;\n    v10 = v4 + v9 * 24;\n    v0 = v10;\n    if ((unsigned int)v9 > 0) {\n      v11 = &v10[v9];\n      do {\n        *((long long *)v10) = 0;\n        v10 += 8;\n      } while (v10 != v11);\n    }\n    if (x1a->field_4 > 0) {\n      v12 = v4;\n      v13 = v12 + 8;\n      v1 = -8 - v12;\n      do {\n        v15 = &v0[(unsigned int)v9 - 1 &\n                  (int)strhash(\n                      *((long long *)(v1 + v13 + (char *)x1a->field_8)))];\n        v16 = *(v15);\n        if (v16)\n          v16->field_10 = v13;\n      } while ((v8 = *((long long *)(v8 + 8)), v8));\n    }\n    free(x1a->field_8);\n    x1a->field_0 = v9;\n    x1a->field_4 = v3;\n    x1a->field_8 = v4;\n    x1a->field_10 = v0;\n  }\n  v17 = x1a->field_0 - 1 & v2;\n  v18 = x1a->field_4;\n  x1a->field_4 = (unsigned int)v18 + 1;\n  v19 = v18 * 24 + x1a->field_8;\n  v19[0] = a0;\n  v20 = *((long long *)(x1a->field_10 + v17 * 8));\n  if (v20)\n    v20->field_10 = &v19[1];\n  v19[1] = *((long long *)(x1a->field_10 + v17 * 8));\n  *((unsigned long long *[3])(x1a->field_10 + v17 * 8)) = v19;\n  v19[2] = v17 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:28:8: error: unknown type name 'struct_1'\n   28 | extern struct_1 *x1a;\n      |        ^\n/tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:61:13: error: assignment to cast is illegal,\nlvalue casts are not supported 61 |             (unsigned int)v6 =\nstrcmp(*((long long *)v8), a0); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:87:17: error: array type 'unsigned long\nlong[2]' is not assignable 87 |             v13 = v12 + 8; |             ~~~ ^\n/tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:91:88: error: invalid operands to binary\nexpression ('unsigned long long *' and 'char *') 91 |                 v15 =\n&v0[(unsigned int)v9 - 1 & (int)strhash(*((long long *)(v1 + v13 + (char\n*)x1a->field_8)))]; | ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:108:47: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 108 |     v20 = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                           ~~~ ^\n~ /tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:111:50: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 111 |     v19[1] = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                              ~~~\n^ ~ /tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:112:53: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 112 |     *((unsigned long long\n*[3])(x1a->field_10 + v17 * 8)) = v19; | ~~~ ^ ~\n/tmp/tmpiuyu8w5u/Strsafe_insert_name_conflict.c:113:18: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 113 |     v19[2] = v17 * 8 +\nx1a->field_10; |              ~~~ ^ ~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  char padding_8[8];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned long v1;     // rbx\n  struct struct_0 **v2; // rax\n\n  if (!x1a)\n    return x1a;\n  v2 = (int)x1a->field_0 - 1 & (int)strhash(a0);\n  v1 = *((long long *)(x1a->field_10 + v2 * 8));\n  if (!v1)\n    return *((long long *)(x1a->field_10 + v2 * 8));\n  while (strcmp(*((long long *)v1), a0)) {\n    v1 = *((long long *)(v1 + 8));\n    if (!v1)\n      return v1;\n  }\n  v1 = *((long long *)v1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp765niotx/Strsafe_find_name_conflict.c:34:45: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 34 |     v1 = *((long long\n*)(x1a->field_10 + v2 * 8)); |                                          ~~ ^ ~\n/tmp/tmp765niotx/Strsafe_find_name_conflict.c:36:51: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 36 |         return *((long long\n*)(x1a->field_10 + v2 * 8)); |                                                ~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if (x2a)\n    v1 = x2a->field_4;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9j8m880b/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmp9j8m880b/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmp9j8m880b/Symbol_count_name_conflict.c:27:19: error: member\nreference type 'int' is not a pointer 27 |         v1 = x2a->field_4; | ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v1; // r13d\n  unsigned int v3; // r12d\n  struct struct_1 *\n      *v4;  // rbp, Other Possible Types: unsigned long, unsigned long long\n  char *v5; // rbx, Other Possible Types: unsigned long\n\n  if (!argv)\n    return 4294967295;\n  v1 = a0;\n  if (!argv->field_0)\n    return 4294967295;\n  v5 = argv->field_8;\n  if (!v5)\n    return 4294967295;\n  v4 = 1;\n  v3 = 0;\n  while (true) {\n    if (v3 || (*((char *)v5) - 43 & 253) && !strchr(v5, 61)) {\n      if (v1)\n        v1 -= 1;\n      else\n        return v4;\n    }\n    if (!strcmp(v5, \"--\"))\n      v3 = 1;\n    v4 += 1;\n    v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n    if (!v5)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp55rrwr5b/argindex_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmp55rrwr5b/argindex_name_conflict.c:21:8: error: declaration of anonymous struct must be\na definition /tmp/tmp55rrwr5b/argindex_name_conflict.c:33:16: error: member reference type\n'int' is not a pointer 33 |     if (!argv->field_0) |          ~~~~  ^\n/tmp/tmp55rrwr5b/argindex_name_conflict.c:35:16: error: member reference type 'int' is not a\npointer 35 |     v5 = argv->field_8; |          ~~~~  ^\n/tmp/tmp55rrwr5b/argindex_name_conflict.c:52:45: error: member reference type 'int' is not a\npointer 52 |         v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n      |                                       ~~~~  ^\n/tmp/tmp55rrwr5b/argindex_name_conflict.c:52:59: error: invalid operands to binary expression\n('int' and 'struct struct_1 **') 52 |         v5 = *((long long *)((char\n*)&argv->field_0 + 0x8 * v4)); | ~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_2 {\n  struct struct_1 *field_ - 8;\n} struct_2;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  void *v1;     // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v2;     // rbp, Other Possible Types: unsigned long\n  struct_2 *v3; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned int v4; // r12d\n\n  v1 = 0;\n  if (!argv) {\n    return 0;\n  } else if (!argv->field_0) {\n    return 0;\n  } else {\n    v2 = argv->field_8;\n    if (!v2)\n      return 0;\n    v3 = argv + 1;\n    v4 = 0;\n    do {\n      if (v4 || (*((char *)v2) - 43 & 253) && !strchr(v2, 61))\n        v1 = (unsigned int)v1 + 1;\n      if (!strcmp(v2, \"--\"))\n        v4 = 1;\n      v3 += 8;\n      v2 = v3[1].field_ - 8;\n    } while (v2);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpln0arqtl/OptNArgs_name_conflict.c:18:28: error: expected ';' at end of declaration\nlist 18 |     struct struct_1 *field_-8; |                            ^ | ;\n/tmp/tmpln0arqtl/OptNArgs_name_conflict.c:25:8: error: unknown type name 'struct_0'\n   25 | extern struct_0 *argv;\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long long a0) {\n  unsigned long long *v1; // rax\n\n  v1 = argindex(a0);\n  if ((unsigned int)v1 >= 0)\n    return *((long long *)(argv + v1 * 8));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplqhxlngf/OptArg_name_conflict.c:26:42: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 26 |         return *((long long *)(argv + v1\n* 8)); |                                       ~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40b175;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char *v1; // rax\n  char v3;  // r13b\n  char *v5; // rbx, Other Possible Types: unsigned long\n  char v6;  // r13b\n  char *v7; // rbx, Other Possible Types: unsigned long\n  char *v8; // rbp, Other Possible Types: unsigned long\n  char *v9; // r12, Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v3 = *(v1);\n    *(v1) = 0;\n    v9 = malloc(strlen(a0) + strlen(a1) + 2);\n    if (v9)\n      sprintf(v9, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v3;\n    return v9;\n  } else {\n    v8 = getenv(\"PATH\");\n    if (!v8)\n      v8 = \".:/bin:/usr/bin\";\n    v9 = malloc(strlen(v8) + strlen(a1) + 2);\n    if (!v9)\n      return v9;\n    while (*((char *)v8)) {\n      v5 = strchr(v8, 58);\n      if (!v5)\n        v5 = v8 + strlen(v8);\n      v6 = *((char *)v5);\n      *((char *)v5) = 0;\n      sprintf(v9, \"%s/%s\", (unsigned int)v8, (unsigned int)a1);\n      *((char *)v5) = v6;\n      v7 = v5 + 1;\n      if (!v6)\n        v7 = &g_40b175;\n      v8 = v7;\n      if (!access(v9, a2))\n        return v9;\n    }\n    return v9;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 < 0) {\n    if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n      return \"signed char\";\n    if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n      return \"int\";\n    return \"short\";\n  } else if ((unsigned int)a1 <= 255) {\n    return \"unsigned char\";\n  } else {\n    return ((unsigned int)a1 <= 65534 ? \"unsigned int\" : \"unsigned short int\");\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v1; // rax\n  char *v2; // rdx, Other Possible Types: unsigned long\n\n  v1 = malloc(size);\n  if (!v1)\n    memory_error(); /* do not return */\n  v2 = v1;\n  if (size <= 0)\n    return v1;\n  do {\n    *((char *)v2) = 0;\n    v2 += 1;\n  } while (v2 != &v1[size]);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rdi\n  char v2;  // al\n\n  v1 = a0 + a1;\n  v2 = *(v1);\n  *(v1) = 1;\n  return !v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rax, Other Possible Types: unsigned long\n  void *v2; // rcx, Other Possible Types: unsigned long long, unsigned long\n\n  if (size <= 0)\n    return 0;\n  v1 = 0;\n  v2 = 0;\n  do {\n    if (*((char *)(a1 + v1)) && !*((char *)(a0 + v1))) {\n      *((char *)(a0 + v1)) = 1;\n      v2 = 1;\n    }\n  } while ((v1 += 1, (unsigned long long)size != v1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  void *v2;              // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = 0;\n  do {\n    v3 = v2 + v2 * 12;\n    a0 += 1;\n    v2 = v3 + v1;\n    v1 = *((char *)a0);\n  } while ((char)v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgoblr0z6/strhash_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v3 = v2 + v2 * 12; |                   ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = Strsafe_name_conflict_find(a0);\n  if (v1)\n    return v1;\n  v1 = malloc(strlen(a0) + 1);\n  if (v1) {\n    strcpy(v1, a0);\n    Strsafe_name_conflict_insert(v1);\n    return v1;\n  }\n  memory_error(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_2 {\n  char *field_0;\n  struct struct_2 *field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_1 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned long long *v0;    // [bp-0x58]\n  unsigned long v1;          // [bp-0x50]\n  unsigned int v2;           // [bp-0x48]\n  unsigned int v3;           // [bp-0x44]\n  unsigned long v4;          // [bp-0x40]\n  unsigned long v6;          // rax\n  unsigned int v7;           // r14d\n  struct_2 *v8;              // r12, Other Possible Types: unsigned long\n  unsigned long v9;          // r14\n  unsigned long long *v10;   // rax, Other Possible Types: unsigned long\n  unsigned long long v11;    // rdx\n  unsigned long long v12;    // rcx\n  unsigned long long v13[2]; // r12, Other Possible Types: unsigned long\n  struct struct_0 **v15;     // rax\n  struct_0 *v16;             // rdx\n  struct struct_0 **v17;     // rax\n  unsigned long long v18;    // rdx\n  unsigned long long v19[3]; // rdx\n  struct_0 *v20;             // rsi\n\n  if (!x1a)\n    return 0;\n  v2 = strhash(a0);\n  v7 = x1a->field_0;\n  v8 = *((long long *)(x1a->field_10 + (v7 - 1 & v2) * 8));\n  if (v8) {\n    do {\n      (unsigned int)v6 = strcmp(*((long long *)v8), a0);\n      if (!(unsigned int)v6)\n        return v6;\n    } while ((v8 = *((long long *)(v8 + 8)), v8));\n  }\n  v3 = x1a->field_4;\n  if (v7 <= v3) {\n    v9 = v7 * 2;\n    v4 = malloc(v9 * 32);\n    if (!v4)\n      return 0;\n    v10 = v4 + v9 * 24;\n    v0 = v10;\n    if ((unsigned int)v9 > 0) {\n      v11 = &v10[v9];\n      do {\n        *((long long *)v10) = 0;\n        v10 += 8;\n      } while (v10 != v11);\n    }\n    if (x1a->field_4 > 0) {\n      v12 = v4;\n      v13 = v12 + 8;\n      v1 = -8 - v12;\n      do {\n        v15 = &v0[(unsigned int)v9 - 1 &\n                  (int)strhash(\n                      *((long long *)(v1 + v13 + (char *)x1a->field_8)))];\n        v16 = *(v15);\n        if (v16)\n          v16->field_10 = v13;\n      } while ((v8 = *((long long *)(v8 + 8)), v8));\n    }\n    free(x1a->field_8);\n    x1a->field_0 = v9;\n    x1a->field_4 = v3;\n    x1a->field_8 = v4;\n    x1a->field_10 = v0;\n  }\n  v17 = x1a->field_0 - 1 & v2;\n  v18 = x1a->field_4;\n  x1a->field_4 = (unsigned int)v18 + 1;\n  v19 = v18 * 24 + x1a->field_8;\n  v19[0] = a0;\n  v20 = *((long long *)(x1a->field_10 + v17 * 8));\n  if (v20)\n    v20->field_10 = &v19[1];\n  v19[1] = *((long long *)(x1a->field_10 + v17 * 8));\n  *((unsigned long long *[3])(x1a->field_10 + v17 * 8)) = v19;\n  v19[2] = v17 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:28:8: error: unknown type name 'struct_1'\n   28 | extern struct_1 *x1a;\n      |        ^\n/tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:61:13: error: assignment to cast is illegal,\nlvalue casts are not supported 61 |             (unsigned int)v6 =\nstrcmp(*((long long *)v8), a0); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:87:17: error: array type 'unsigned long\nlong[2]' is not assignable 87 |             v13 = v12 + 8; |             ~~~ ^\n/tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:91:88: error: invalid operands to binary\nexpression ('unsigned long long *' and 'char *') 91 |                 v15 =\n&v0[(unsigned int)v9 - 1 & (int)strhash(*((long long *)(v1 + v13 + (char\n*)x1a->field_8)))]; | ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:108:47: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 108 |     v20 = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                           ~~~ ^\n~ /tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:111:50: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 111 |     v19[1] = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                              ~~~\n^ ~ /tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:112:53: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 112 |     *((unsigned long long\n*[3])(x1a->field_10 + v17 * 8)) = v19; | ~~~ ^ ~\n/tmp/tmpu828f61_/Strsafe_insert_name_conflict.c:113:18: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 113 |     v19[2] = v17 * 8 +\nx1a->field_10; |              ~~~ ^ ~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[4];\n  struct struct_0 *field_8;\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned long v1;     // rbx\n  struct struct_0 **v2; // rax\n\n  if (!x1a)\n    return x1a;\n  v2 = x1a->field_0 - 1 & (int)strhash(a0);\n  v1 = *((long long *)(x1a->field_10 + v2 * 8));\n  if (!v1)\n    return *((long long *)(x1a->field_10 + v2 * 8));\n  while (strcmp(*((long long *)v1), a0)) {\n    v1 = *((long long *)(v1 + 8));\n    if (!v1)\n      return v1;\n  }\n  v1 = *((long long *)v1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppo_rxka5/Strsafe_find_name_conflict.c:35:45: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 35 |     v1 = *((long long\n*)(x1a->field_10 + v2 * 8)); |                                          ~~ ^ ~\n/tmp/tmppo_rxka5/Strsafe_find_name_conflict.c:37:51: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 37 |         return *((long long\n*)(x1a->field_10 + v2 * 8)); |                                                ~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if (x2a)\n    v1 = x2a->field_4;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpelgsishs/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmpelgsishs/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpelgsishs/Symbol_count_name_conflict.c:27:19: error: member\nreference type 'int' is not a pointer 27 |         v1 = x2a->field_4; | ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v1; // r13d\n  unsigned int v3; // r12d\n  struct struct_1 *\n      *v4;  // rbp, Other Possible Types: unsigned long, unsigned long long\n  char *v5; // rbx, Other Possible Types: unsigned long\n\n  if (!argv)\n    return 4294967295;\n  v1 = a0;\n  if (!argv->field_0)\n    return 4294967295;\n  v5 = argv->field_8;\n  if (!v5)\n    return 4294967295;\n  v4 = 1;\n  v3 = 0;\n  while (true) {\n    if (v3 || (*((char *)v5) - 43 & 253) && !strchr(v5, 61)) {\n      if (v1)\n        v1 -= 1;\n      else\n        return v4;\n    }\n    if (!strcmp(v5, \"--\"))\n      v3 = 1;\n    v4 += 1;\n    v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n    if (!v5)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2u5xukp3/argindex_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmp2u5xukp3/argindex_name_conflict.c:21:8: error: declaration of anonymous struct must be\na definition /tmp/tmp2u5xukp3/argindex_name_conflict.c:33:16: error: member reference type\n'int' is not a pointer 33 |     if (!argv->field_0) |          ~~~~  ^\n/tmp/tmp2u5xukp3/argindex_name_conflict.c:35:16: error: member reference type 'int' is not a\npointer 35 |     v5 = argv->field_8; |          ~~~~  ^\n/tmp/tmp2u5xukp3/argindex_name_conflict.c:52:45: error: member reference type 'int' is not a\npointer 52 |         v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n      |                                       ~~~~  ^\n/tmp/tmp2u5xukp3/argindex_name_conflict.c:52:59: error: invalid operands to binary expression\n('int' and 'struct struct_1 **') 52 |         v5 = *((long long *)((char\n*)&argv->field_0 + 0x8 * v4)); | ~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  struct struct_1 *field_ - 8;\n} struct_0;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\nextern struct_2 *argv;\n\nlong long OptNArgs_name_conflict() {\n  void *v1;     // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v2;     // rbp, Other Possible Types: unsigned long\n  struct_0 *v3; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned int v4; // r12d\n\n  v1 = 0;\n  if (!argv) {\n    return 0;\n  } else if (!argv->field_0) {\n    return 0;\n  } else {\n    v2 = argv->field_8;\n    if (!v2)\n      return 0;\n    v3 = argv + 1;\n    v4 = 0;\n    do {\n      if (v4 || (*((char *)v2) - 43 & 253) && !strchr(v2, 61))\n        v1 = (unsigned int)v1 + 1;\n      if (!strcmp(v2, \"--\"))\n        v4 = 1;\n      v3 += 8;\n      v2 = v3[1].field_ - 8;\n    } while (v2);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6a6u3hya/OptNArgs_name_conflict.c:18:28: error: expected ';' at end of declaration\nlist 18 |     struct struct_1 *field_-8; |                            ^ | ;\n/tmp/tmp6a6u3hya/OptNArgs_name_conflict.c:25:8: error: unknown type name 'struct_2'\n   25 | extern struct_2 *argv;\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long long a0) {\n  unsigned long long *v1; // rax\n\n  v1 = argindex(a0);\n  if ((unsigned int)v1 >= 0)\n    return *((long long *)(argv + v1 * 8));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0zn3xbjk/OptArg_name_conflict.c:26:42: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 26 |         return *((long long *)(argv + v1\n* 8)); |                                       ~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40b175;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char *v1; // rax\n  char v3;  // r13b\n  char *v5; // rbx, Other Possible Types: unsigned long\n  char v6;  // r13b\n  char *v7; // rbx, Other Possible Types: unsigned long\n  char *v8; // rbp, Other Possible Types: unsigned long\n  char *v9; // r12, Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v3 = *(v1);\n    *(v1) = 0;\n    v9 = malloc(strlen(a0) + strlen(a1) + 2);\n    if (v9)\n      sprintf(v9, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v3;\n    return v9;\n  } else {\n    v8 = getenv(\"PATH\");\n    if (!v8)\n      v8 = \".:/bin:/usr/bin\";\n    v9 = malloc(strlen(v8) + strlen(a1) + 2);\n    if (!v9)\n      return v9;\n    while (*((char *)v8)) {\n      v5 = strchr(v8, 58);\n      if (!v5)\n        v5 = v8 + strlen(v8);\n      v6 = *((char *)v5);\n      *((char *)v5) = 0;\n      sprintf(v9, \"%s/%s\", (unsigned int)v8, (unsigned int)a1);\n      *((char *)v5) = v6;\n      v7 = v5 + 1;\n      if (!v6)\n        v7 = &g_40b175;\n      v8 = v7;\n      if (!access(v9, a2))\n        return v9;\n    }\n    return v9;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 < 0) {\n    if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n      return \"signed char\";\n    if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n      return \"int\";\n    return \"short\";\n  } else if ((unsigned int)a1 <= 255) {\n    return \"unsigned char\";\n  } else {\n    return ((unsigned int)a1 <= 65534 ? \"unsigned int\" : \"unsigned short int\");\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v1; // rax\n  char *v2; // rdx, Other Possible Types: unsigned long\n\n  v1 = malloc(size);\n  if (!v1)\n    memory_error(); /* do not return */\n  v2 = v1;\n  if (size <= 0)\n    return v1;\n  do {\n    *((char *)v2) = 0;\n    v2 += 1;\n  } while (v2 != &v1[size]);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rdi\n  char v2;  // al\n\n  v1 = a0 + a1;\n  v2 = *(v1);\n  *(v1) = 1;\n  return !v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rax, Other Possible Types: unsigned long\n  void *v2; // rcx, Other Possible Types: unsigned long, unsigned long long\n\n  if (size <= 0)\n    return 0;\n  v1 = 0;\n  v2 = 0;\n  do {\n    if (*((char *)(a1 + v1)) && !*((char *)(a0 + v1))) {\n      *((char *)(a0 + v1)) = 1;\n      v2 = 1;\n    }\n  } while ((v1 += 1, (unsigned long long)size != v1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  void *v2;              // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = 0;\n  do {\n    v3 = v2 + v2 * 12;\n    a0 += 1;\n    v2 = v3 + v1;\n    v1 = *((char *)a0);\n  } while ((char)v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpy0o5fpq_/strhash_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v3 = v2 + v2 * 12; |                   ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = Strsafe_name_conflict_find(a0);\n  if (v1)\n    return v1;\n  v1 = malloc(strlen(a0) + 1);\n  if (v1) {\n    strcpy(v1, a0);\n    Strsafe_name_conflict_insert(v1);\n    return v1;\n  }\n  memory_error(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_2 {\n  char *field_0;\n  struct struct_2 *field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_1 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned long long *v0;    // [bp-0x58]\n  unsigned long v1;          // [bp-0x50]\n  unsigned int v2;           // [bp-0x48]\n  unsigned int v3;           // [bp-0x44]\n  unsigned long v4;          // [bp-0x40]\n  unsigned long v6;          // rax\n  unsigned int v7;           // r14d\n  struct_2 *v8;              // r12, Other Possible Types: unsigned long\n  unsigned long v9;          // r14\n  unsigned long long *v10;   // rax, Other Possible Types: unsigned long\n  unsigned long long v11;    // rdx\n  unsigned long long v12;    // rcx\n  unsigned long long v13[2]; // r12, Other Possible Types: unsigned long\n  struct struct_0 **v15;     // rax\n  struct_0 *v16;             // rdx\n  struct struct_0 **v17;     // rax\n  unsigned long long v18;    // rdx\n  unsigned long long v19[3]; // rdx\n  struct_0 *v20;             // rsi\n\n  if (!x1a)\n    return 0;\n  v2 = strhash(a0);\n  v7 = x1a->field_0;\n  v8 = *((long long *)(x1a->field_10 + (v7 - 1 & v2) * 8));\n  if (v8) {\n    do {\n      (unsigned int)v6 = strcmp(*((long long *)v8), a0);\n      if (!(unsigned int)v6)\n        return v6;\n    } while ((v8 = *((long long *)(v8 + 8)), v8));\n  }\n  v3 = x1a->field_4;\n  if (v7 <= v3) {\n    v9 = v7 * 2;\n    v4 = malloc(v9 * 32);\n    if (!v4)\n      return 0;\n    v10 = v4 + v9 * 24;\n    v0 = v10;\n    if ((unsigned int)v9 > 0) {\n      v11 = &v10[v9];\n      do {\n        *((long long *)v10) = 0;\n        v10 += 8;\n      } while (v10 != v11);\n    }\n    if (x1a->field_4 > 0) {\n      v12 = v4;\n      v13 = v12 + 8;\n      v1 = -8 - v12;\n      do {\n        v15 = &v0[(unsigned int)v9 - 1 &\n                  (int)strhash(\n                      *((long long *)(v1 + v13 + (char *)x1a->field_8)))];\n        v16 = *(v15);\n        if (v16)\n          v16->field_10 = v13;\n      } while ((v8 = *((long long *)(v8 + 8)), v8));\n    }\n    free(x1a->field_8);\n    x1a->field_0 = v9;\n    x1a->field_4 = v3;\n    x1a->field_8 = v4;\n    x1a->field_10 = v0;\n  }\n  v17 = x1a->field_0 - 1 & v2;\n  v18 = x1a->field_4;\n  x1a->field_4 = (unsigned int)v18 + 1;\n  v19 = v18 * 24 + x1a->field_8;\n  v19[0] = a0;\n  v20 = *((long long *)(x1a->field_10 + v17 * 8));\n  if (v20)\n    v20->field_10 = &v19[1];\n  v19[1] = *((long long *)(x1a->field_10 + v17 * 8));\n  *((unsigned long long *[3])(x1a->field_10 + v17 * 8)) = v19;\n  v19[2] = v17 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:28:8: error: unknown type name 'struct_1'\n   28 | extern struct_1 *x1a;\n      |        ^\n/tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:61:13: error: assignment to cast is illegal,\nlvalue casts are not supported 61 |             (unsigned int)v6 =\nstrcmp(*((long long *)v8), a0); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:87:17: error: array type 'unsigned long\nlong[2]' is not assignable 87 |             v13 = v12 + 8; |             ~~~ ^\n/tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:91:88: error: invalid operands to binary\nexpression ('unsigned long long *' and 'char *') 91 |                 v15 =\n&v0[(unsigned int)v9 - 1 & (int)strhash(*((long long *)(v1 + v13 + (char\n*)x1a->field_8)))]; | ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:108:47: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 108 |     v20 = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                           ~~~ ^\n~ /tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:111:50: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 111 |     v19[1] = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                              ~~~\n^ ~ /tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:112:53: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 112 |     *((unsigned long long\n*[3])(x1a->field_10 + v17 * 8)) = v19; | ~~~ ^ ~\n/tmp/tmpa37qu9d5/Strsafe_insert_name_conflict.c:113:18: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 113 |     v19[2] = v17 * 8 +\nx1a->field_10; |              ~~~ ^ ~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n  char padding_8[8];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned long v1;     // rbx\n  struct struct_0 **v2; // rax\n\n  if (!x1a)\n    return x1a;\n  v2 = (int)x1a->field_0 - 1 & (int)strhash(a0);\n  v1 = *((long long *)(x1a->field_10 + v2 * 8));\n  if (!v1)\n    return *((long long *)(x1a->field_10 + v2 * 8));\n  while (strcmp(*((long long *)v1), a0)) {\n    v1 = *((long long *)(v1 + 8));\n    if (!v1)\n      return v1;\n  }\n  v1 = *((long long *)v1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjza0akq9/Strsafe_find_name_conflict.c:34:45: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 34 |     v1 = *((long long\n*)(x1a->field_10 + v2 * 8)); |                                          ~~ ^ ~\n/tmp/tmpjza0akq9/Strsafe_find_name_conflict.c:36:51: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 36 |         return *((long long\n*)(x1a->field_10 + v2 * 8)); |                                                ~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if (x2a)\n    v1 = x2a->field_4;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr0s4tzgx/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmpr0s4tzgx/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpr0s4tzgx/Symbol_count_name_conflict.c:27:19: error: member\nreference type 'int' is not a pointer 27 |         v1 = x2a->field_4; | ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\nint argv; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *argv;\n\nlong long argindex_name_conflict(unsigned long a0) {\n  unsigned int v1; // r13d\n  unsigned int v3; // r12d\n  struct struct_1 *\n      *v4;  // rbp, Other Possible Types: unsigned long, unsigned long long\n  char *v5; // rbx, Other Possible Types: unsigned long\n\n  if (!argv)\n    return 4294967295;\n  v1 = a0;\n  if (!argv->field_0)\n    return 4294967295;\n  v5 = argv->field_8;\n  if (!v5)\n    return 4294967295;\n  v4 = 1;\n  v3 = 0;\n  while (true) {\n    if (v3 || (*((char *)v5) - 43 & 253) && !strchr(v5, 61)) {\n      if (v1)\n        v1 -= 1;\n      else\n        return v4;\n    }\n    if (!strcmp(v5, \"--\"))\n      v3 = 1;\n    v4 += 1;\n    v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n    if (!v5)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp52lz_yi1/argindex_name_conflict.c:21:8: error: unknown type name 'struct_0'; did you\nmean 'struct'? 21 | extern struct_0 *argv; |        ^~~~~~~~ |        struct\n/tmp/tmp52lz_yi1/argindex_name_conflict.c:21:8: error: declaration of anonymous struct must be\na definition /tmp/tmp52lz_yi1/argindex_name_conflict.c:33:16: error: member reference type\n'int' is not a pointer 33 |     if (!argv->field_0) |          ~~~~  ^\n/tmp/tmp52lz_yi1/argindex_name_conflict.c:35:16: error: member reference type 'int' is not a\npointer 35 |     v5 = argv->field_8; |          ~~~~  ^\n/tmp/tmp52lz_yi1/argindex_name_conflict.c:52:45: error: member reference type 'int' is not a\npointer 52 |         v5 = *((long long *)((char *)&argv->field_0 + 0x8 * v4));\n      |                                       ~~~~  ^\n/tmp/tmp52lz_yi1/argindex_name_conflict.c:52:59: error: invalid operands to binary expression\n('int' and 'struct struct_1 **') 52 |         v5 = *((long long *)((char\n*)&argv->field_0 + 0x8 * v4)); | ~~~ ^ ~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_2 {\n  struct struct_1 *field_ - 8;\n} struct_2;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\nextern struct_0 *argv;\n\nlong long OptNArgs_name_conflict() {\n  void *v1;     // r13, Other Possible Types: unsigned long, unsigned long long\n  char *v2;     // rbp, Other Possible Types: unsigned long\n  struct_2 *v3; // rbx, Other Possible Types: unsigned long, unsigned long long\n  unsigned int v4; // r12d\n\n  v1 = 0;\n  if (!argv) {\n    return 0;\n  } else if (!argv->field_0) {\n    return 0;\n  } else {\n    v2 = argv->field_8;\n    if (!v2)\n      return 0;\n    v3 = argv + 1;\n    v4 = 0;\n    do {\n      if (v4 || (*((char *)v2) - 43 & 253) && !strchr(v2, 61))\n        v1 = (unsigned int)v1 + 1;\n      if (!strcmp(v2, \"--\"))\n        v4 = 1;\n      v3 += 8;\n      v2 = v3[1].field_ - 8;\n    } while (v2);\n    return v1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl3rew488/OptNArgs_name_conflict.c:18:28: error: expected ';' at end of declaration\nlist 18 |     struct struct_1 *field_-8; |                            ^ | ;\n/tmp/tmpl3rew488/OptNArgs_name_conflict.c:25:8: error: unknown type name 'struct_0'\n   25 | extern struct_0 *argv;\n      |        ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(argindex)(long long);\n\nextern unsigned long long argv;\n\nlong long OptArg_name_conflict(unsigned long long a0) {\n  unsigned long long *v1; // rax\n\n  v1 = argindex(a0);\n  if ((unsigned int)v1 >= 0)\n    return *((long long *)(argv + v1 * 8));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4jxmku58/OptArg_name_conflict.c:26:42: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 26 |         return *((long long *)(argv + v1\n* 8)); |                                       ~~ ^ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nint(access)(char *, int);\n\nextern char g_40b175;\n\nlong long pathsearch_name_conflict(char *a0, char *a1, unsigned long a2) {\n  char *v1; // rax\n  char v3;  // r13b\n  char *v5; // rbx, Other Possible Types: unsigned long\n  char v6;  // r13b\n  char *v7; // rbx, Other Possible Types: unsigned long\n  char *v8; // rbp, Other Possible Types: unsigned long\n  char *v9; // r12, Other Possible Types: unsigned long\n\n  v1 = strrchr(a0, 47);\n  if (v1) {\n    v3 = *(v1);\n    *(v1) = 0;\n    v9 = malloc(strlen(a0) + strlen(a1) + 2);\n    if (v9)\n      sprintf(v9, \"%s/%s\", (unsigned int)a0, (unsigned int)a1);\n    *(v1) = v3;\n    return v9;\n  } else {\n    v8 = getenv(\"PATH\");\n    if (!v8)\n      v8 = \".:/bin:/usr/bin\";\n    v9 = malloc(strlen(v8) + strlen(a1) + 2);\n    if (!v9)\n      return v9;\n    while (*((char *)v8)) {\n      v5 = strchr(v8, 58);\n      if (!v5)\n        v5 = v8 + strlen(v8);\n      v6 = *((char *)v5);\n      *((char *)v5) = 0;\n      sprintf(v9, \"%s/%s\", (unsigned int)v8, (unsigned int)a1);\n      *((char *)v5) = v6;\n      v7 = v5 + 1;\n      if (!v6)\n        v7 = &g_40b175;\n      v8 = v7;\n      if (!access(v9, a2))\n        return v9;\n    }\n    return v9;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long minimum_size_type_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 < 0) {\n    if ((unsigned int)a0 >= -127 && (unsigned int)a1 <= 127)\n      return \"signed char\";\n    if (!((unsigned int)a0 >= -32767 && (unsigned int)a1 <= 32766))\n      return \"int\";\n    return \"short\";\n  } else if ((unsigned int)a1 <= 255) {\n    return \"unsigned char\";\n  } else {\n    return ((unsigned int)a1 <= 65534 ? \"unsigned int\" : \"unsigned short int\");\n  }\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(memory_error)();\n\nextern unsigned int size;\n\nlong long SetNew_name_conflict() {\n  char *v1; // rax\n  char *v2; // rdx, Other Possible Types: unsigned long\n\n  v1 = malloc(size);\n  if (!v1)\n    memory_error(); /* do not return */\n  v2 = v1;\n  if (size <= 0)\n    return v1;\n  do {\n    *((char *)v2) = 0;\n    v2 += 1;\n  } while (v2 != &v1[size]);\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long SetAdd_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rdi\n  char v2;  // al\n\n  v1 = a0 + a1;\n  v2 = *(v1);\n  *(v1) = 1;\n  return !v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int size;\n\nlong long SetUnion_name_conflict(unsigned long a0, unsigned long a1) {\n  char *v1; // rax, Other Possible Types: unsigned long\n  void *v2; // rcx, Other Possible Types: unsigned long long, unsigned long\n\n  if (size <= 0)\n    return 0;\n  v1 = 0;\n  v2 = 0;\n  do {\n    if (*((char *)(a1 + v1)) && !*((char *)(a0 + v1))) {\n      *((char *)(a0 + v1)) = 1;\n      v2 = 1;\n    }\n  } while ((v1 += 1, (unsigned long long)size != v1));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long strhash_name_conflict(char *a0) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  void *v2;              // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = 0;\n  do {\n    v3 = v2 + v2 * 12;\n    a0 += 1;\n    v2 = v3 + v1;\n    v1 = *((char *)a0);\n  } while ((char)v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpi1cjbj_p/strhash_name_conflict.c:29:22: error: invalid operands to binary expression\n('void *' and 'int') 29 |         v3 = v2 + v2 * 12; |                   ~~ ^ ~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(Strsafe_name_conflict_find)(long long);\nlong long(memory_error)();\nlong long(Strsafe_name_conflict_insert)(long long);\n\nlong long Strsafe_name_conflict(char *a0) {\n  char *v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = Strsafe_name_conflict_find(a0);\n  if (v1)\n    return v1;\n  v1 = malloc(strlen(a0) + 1);\n  if (v1) {\n    strcpy(v1, a0);\n    Strsafe_name_conflict_insert(v1);\n    return v1;\n  }\n  memory_error(); /* do not return */\n}\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_2 {\n  char *field_0;\n  struct struct_2 *field_8;\n} struct_2;\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_1 *x1a;\n\nlong long Strsafe_insert_name_conflict(char *a0) {\n  unsigned long long *v0;    // [bp-0x58]\n  unsigned long v1;          // [bp-0x50]\n  unsigned int v2;           // [bp-0x48]\n  unsigned int v3;           // [bp-0x44]\n  unsigned long v4;          // [bp-0x40]\n  unsigned long v6;          // rax\n  unsigned int v7;           // r14d\n  struct_2 *v8;              // r12, Other Possible Types: unsigned long\n  unsigned long v9;          // r14\n  unsigned long long *v10;   // rax, Other Possible Types: unsigned long\n  unsigned long long v11;    // rdx\n  unsigned long long v12;    // rcx\n  unsigned long long v13[2]; // r12, Other Possible Types: unsigned long\n  struct struct_0 **v15;     // rax\n  struct_0 *v16;             // rdx\n  struct struct_0 **v17;     // rax\n  unsigned long long v18;    // rdx\n  unsigned long long v19[3]; // rdx\n  struct_0 *v20;             // rsi\n\n  if (!x1a)\n    return 0;\n  v2 = strhash(a0);\n  v7 = x1a->field_0;\n  v8 = *((long long *)(x1a->field_10 + (v7 - 1 & v2) * 8));\n  if (v8) {\n    do {\n      (unsigned int)v6 = strcmp(*((long long *)v8), a0);\n      if (!(unsigned int)v6)\n        return v6;\n    } while ((v8 = *((long long *)(v8 + 8)), v8));\n  }\n  v3 = x1a->field_4;\n  if (v7 <= v3) {\n    v9 = v7 * 2;\n    v4 = malloc(v9 * 32);\n    if (!v4)\n      return 0;\n    v10 = v4 + v9 * 24;\n    v0 = v10;\n    if ((unsigned int)v9 > 0) {\n      v11 = &v10[v9];\n      do {\n        *((long long *)v10) = 0;\n        v10 += 8;\n      } while (v10 != v11);\n    }\n    if (x1a->field_4 > 0) {\n      v12 = v4;\n      v13 = v12 + 8;\n      v1 = -8 - v12;\n      do {\n        v15 = &v0[(unsigned int)v9 - 1 &\n                  (int)strhash(\n                      *((long long *)(v1 + v13 + (char *)x1a->field_8)))];\n        v16 = *(v15);\n        if (v16)\n          v16->field_10 = v13;\n      } while ((v8 = *((long long *)(v8 + 8)), v8));\n    }\n    free(x1a->field_8);\n    x1a->field_0 = v9;\n    x1a->field_4 = v3;\n    x1a->field_8 = v4;\n    x1a->field_10 = v0;\n  }\n  v17 = x1a->field_0 - 1 & v2;\n  v18 = x1a->field_4;\n  x1a->field_4 = (unsigned int)v18 + 1;\n  v19 = v18 * 24 + x1a->field_8;\n  v19[0] = a0;\n  v20 = *((long long *)(x1a->field_10 + v17 * 8));\n  if (v20)\n    v20->field_10 = &v19[1];\n  v19[1] = *((long long *)(x1a->field_10 + v17 * 8));\n  *((unsigned long long *[3])(x1a->field_10 + v17 * 8)) = v19;\n  v19[2] = v17 * 8 + x1a->field_10;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:28:8: error: unknown type name 'struct_1'\n   28 | extern struct_1 *x1a;\n      |        ^\n/tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:61:13: error: assignment to cast is illegal,\nlvalue casts are not supported 61 |             (unsigned int)v6 =\nstrcmp(*((long long *)v8), a0); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:87:17: error: array type 'unsigned long\nlong[2]' is not assignable 87 |             v13 = v12 + 8; |             ~~~ ^\n/tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:91:88: error: invalid operands to binary\nexpression ('unsigned long long *' and 'char *') 91 |                 v15 =\n&v0[(unsigned int)v9 - 1 & (int)strhash(*((long long *)(v1 + v13 + (char\n*)x1a->field_8)))]; | ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:108:47: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 108 |     v20 = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                           ~~~ ^\n~ /tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:111:50: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 111 |     v19[1] = *((long long\n*)(x1a->field_10 + v17 * 8)); |                                              ~~~\n^ ~ /tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:112:53: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 112 |     *((unsigned long long\n*[3])(x1a->field_10 + v17 * 8)) = v19; | ~~~ ^ ~\n/tmp/tmpsgy9s7js/Strsafe_insert_name_conflict.c:113:18: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 113 |     v19[2] = v17 * 8 +\nx1a->field_10; |              ~~~ ^ ~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(strhash)(long long);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[4];\n  struct struct_0 *field_8;\n  unsigned long long field_10;\n} struct_0;\n\nextern struct_0 *x1a;\n\nlong long Strsafe_find_name_conflict(char *a0) {\n  unsigned long v1;     // rbx\n  struct struct_0 **v2; // rax\n\n  if (!x1a)\n    return x1a;\n  v2 = x1a->field_0 - 1 & (int)strhash(a0);\n  v1 = *((long long *)(x1a->field_10 + v2 * 8));\n  if (!v1)\n    return *((long long *)(x1a->field_10 + v2 * 8));\n  while (strcmp(*((long long *)v1), a0)) {\n    v1 = *((long long *)(v1 + 8));\n    if (!v1)\n      return v1;\n  }\n  v1 = *((long long *)v1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpp3oxl0ia/Strsafe_find_name_conflict.c:35:45: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 35 |     v1 = *((long long\n*)(x1a->field_10 + v2 * 8)); |                                          ~~ ^ ~\n/tmp/tmpp3oxl0ia/Strsafe_find_name_conflict.c:37:51: error: invalid operands to binary\nexpression ('struct struct_0 **' and 'int') 37 |         return *((long long\n*)(x1a->field_10 + v2 * 8)); |                                                ~~\n^ ~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint x2a; // add global variable by heuristics\nint x2a; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern struct_0 *x2a;\n\nlong long Symbol_count_name_conflict() {\n  void *v1; // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  if (x2a)\n    v1 = x2a->field_4;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxry85mjg/Symbol_count_name_conflict.c:19:8: error: unknown type name 'struct_0'; did\nyou mean 'struct'? 19 | extern struct_0 *x2a; |        ^~~~~~~~ |        struct\n/tmp/tmpxry85mjg/Symbol_count_name_conflict.c:19:8: error: declaration of anonymous struct\nmust be a definition /tmp/tmpxry85mjg/Symbol_count_name_conflict.c:27:19: error: member\nreference type 'int' is not a pointer 27 |         v1 = x2a->field_4; | ~~~  ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long parseHex_name_conflict(char *a0, unsigned long long *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  struct_0 *v2; // rcx, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v3; // rax\n  unsigned long long v4; // rax\n  unsigned long long v5; // rax\n  unsigned long v6;      // rax, Other Possible Types: unsigned long long\n  void *v7;              // rdi, Other Possible Types: unsigned long\n\n  *(a1) = 0;\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = a0 + 1;\n  v7 = 0;\n  while (true) {\n    if (v1 - 48 <= 9) {\n      v3 = (unsigned int)v1 - 48;\n      v6 = v3 + *(a1) * 16;\n    } else if (v1 - 65 <= 5) {\n      v4 = (unsigned int)v1 - 55;\n      v6 = v4 + *(a1) * 16;\n    } else {\n      if ((unsigned int)v1 - 97 > 5)\n        return v7;\n      v5 = (unsigned int)v1 - 87;\n      v6 = v5 + *(a1) * 16;\n    }\n    *(a1) = v6;\n    v7 = (unsigned int)v7 + 1;\n    v2 += 1;\n    v1 = v2[1].field_ - 1;\n    if (!(char)v1)\n      return v7;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjl4e5urv/parseHex_name_conflict.c:18:16: error: expected ';' at end of declaration\nlist 18 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/ucm2cp.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long parseHex_name_conflict(char *a0, unsigned long long *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  struct_0 *v2; // rcx, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v3; // rax\n  unsigned long long v4; // rax\n  unsigned long long v5; // rax\n  unsigned long v6;      // rax, Other Possible Types: unsigned long long\n  void *v7;              // rdi, Other Possible Types: unsigned long\n\n  *(a1) = 0;\n  v1 = *(a0);\n  if (!(char)v1)\n    return 0;\n  v2 = a0 + 1;\n  v7 = 0;\n  while (true) {\n    if (v1 - 48 <= 9) {\n      v3 = (unsigned int)v1 - 48;\n      v6 = v3 + *(a1) * 16;\n    } else if (v1 - 65 <= 5) {\n      v4 = (unsigned int)v1 - 55;\n      v6 = v4 + *(a1) * 16;\n    } else {\n      if ((unsigned int)v1 - 97 > 5)\n        return v7;\n      v5 = (unsigned int)v1 - 87;\n      v6 = v5 + *(a1) * 16;\n    }\n    *(a1) = v6;\n    v7 = (unsigned int)v7 + 1;\n    v2 += 1;\n    v1 = v2[1].field_ - 1;\n    if (!(char)v1)\n      return v7;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5rgcu69a/parseHex_name_conflict.c:18:16: error: expected ';' at end of declaration\nlist 18 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":0,"function":"static int createTables(void) {\n    FILE *file;\n    if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n        if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n            perror(\"jis.table\");\n            return 1;\n        }\n    }\n    writeJis(file);\n    fclose(file);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":0,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(long long, long long, long long, long long);\n\nlong long wordCount_name_conflict(unsigned long long a0, unsigned int *a1) {\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  *(a1) = CountWords(a0, 0, 0, 1000);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(char *, unsigned long long, unsigned long, unsigned long);\n\nlong long CountWords(char *a0, unsigned long long a1, unsigned long a2,\n                     unsigned long a3) {\n  unsigned long v1; // rbx\n  char v2;          // cl\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n  void *v4;         // rcx, Other Possible Types: unsigned long\n\n  if ((unsigned int)a1 < 0) {\n    puts(\"ERROR: count needs to be greater than 0.\");\n    return 1;\n  } else if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else if ((unsigned int)a2 > (unsigned int)a3) {\n    puts(\"ERROR: the start point was greater than the max size.\");\n    return 1;\n  } else if (((unsigned int)a3 | (unsigned int)a2) < 0) {\n    puts(\"ERROR: the start point or the max size were set less than zero.\");\n    return 1;\n  } else {\n    v2 = *(a0);\n    if (v2 == 32) {\n      puts(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\");\n      return 1;\n    }\n    v3 = 1;\n    if (!v2) {\n      v4 = 0;\n    } else {\n      do {\n        v4 = v3;\n        v3 += 1;\n      } while (a0[1 + v3]);\n    }\n    if (a0[a2] == 32 && a0[1 + a2] != 32)\n      a1 += (unsigned int)v4 - 1 != (unsigned int)a2;\n    if ((unsigned int)a2 == (unsigned int)v4) {\n      v1 = a1 + 1;\n      printf(\"number of words: %d\\n\", (unsigned int)v1);\n      return a1 + 1;\n    }\n    v1 = CountWords(a0, a1, (unsigned int)a2 + 1, v4);\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long wordRemove_name_conflict(char *a0, char *a1) {\n  char *v1;              // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n  char v4;               // r11b\n  unsigned int v5;       // r8d\n  unsigned long v6;      // rax, Other Possible Types: unsigned long long\n  unsigned long v7;      // rbp\n  unsigned long long v8; // rsi\n  char v9[2];            // rcx, Other Possible Types: unsigned long\n  unsigned long v10;     // edx, Other Possible Types: unsigned int\n  unsigned long v11;     // rax\n  char v12;              // cl\n  char *v13;             // rdx\n  char *v14;             // rax, Other Possible Types: unsigned long\n\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  v1 = a1;\n  if (!a1) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  v2 = 1;\n  if (!*(a0)) {\n    v4 = *(a1);\n    v5 = 0;\n    if (!v4) {\n      goto LABEL_401efc;\n    } else {\n      v6 = 1;\n      do {\n      LABEL_401e3c:\n        v8 = v6;\n        v6 += 1;\n      } while (v1[1 + v6]);\n      v7 = v8;\n    }\n  } else {\n    do {\n      v5 = v2;\n      v2 += 1;\n    } while (a0[1 + v2]);\n    v4 = *(a1);\n    if (!v4)\n      v7 = 0;\n    else\n      goto LABEL_401e3c;\n  }\n  v5 -= (unsigned int)v7;\n  if (v5 < -1) {\n    v10 = 4294967295;\n  } else {\n    v9 = a0 + 1;\n    v10 = -1;\n    do {\n    LABEL_401efc:\n      v10 = (unsigned int)v10 + 1;\n      if (*((char *)(v9 + 1)) == v4 && (unsigned int)v7 > 0) {\n        for (v11 = 1; v9[v11] == v1[1 + v11]; v11 += 1) {\n          if (v11 == v7)\n            goto LABEL_401eb4;\n        }\n      }\n    } while ((v9 += 1, v5 >= (unsigned int)v10));\n  }\nLABEL_401eb4:\n  v12 = a0[v10 + v7];\n  if (v12) {\n    v13 = (unsigned int)v10 + 1;\n    v14 = v13;\n    do {\n      a0[1 + v14] = v12;\n      v10 = v14;\n      v14 += 1;\n      v12 = a0[1 + v14 + v7];\n    } while (v12);\n  }\n  a0[v10] = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1is7iw85/wordRemove_name_conflict.c:85:12: error: array type 'char[2]' is not\nassignable 85 |         v9 = a0 + 1; |         ~~ ^\n/tmp/tmp1is7iw85/wordRemove_name_conflict.c:99:22: error: invalid operands to binary\nexpression ('char[2]' and 'int') 99 |         } while ((v9 += 1, v5 >= (unsigned\nint)v10)); |                   ~~ ^  ~ /tmp/tmp1is7iw85/wordRemove_name_conflict.c:109:15:\nerror: array subscript is not an integer 109 |             a0[1 + v14] = v12; |\n^~~~~~~~ /tmp/tmp1is7iw85/wordRemove_name_conflict.c:112:21: error: array subscript is not an\ninteger 112 |             v12 = a0[1 + v14 + v7]; | ^~~~~~~~~~~~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long vowelCheck_name_conflict(char *a0, unsigned int *a1) {\n  unsigned long long v0; // [bp-0x128]\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n  struct_0 *v3; // rdx, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v4; // rax\n\n  *(a1) = 0;\n  v2 = *(a0);\n  if ((char)v2) {\n    v3 = a0 + 1;\n    do {\n      v4 = (unsigned int)v2 - 65;\n      if ((char)v4 <= 52) {\n        v0 = 4575140898685201;\n        if (((char)(*((char *)&v0 + ((v4 & 63) >> 3)) >> (char)(v4 & 63 & 7)) &\n             1))\n          *(a1) = *(a1) + 1;\n      }\n    } while ((v3 += 1, v2 = (unsigned long long)v3[1].field_ - 1, (char)v2));\n  }\n  printf(\"No. of vowels in %s = %d\\n\", (unsigned int)a0, *(a1));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3vr_2xov/vowelCheck_name_conflict.c:18:16: error: expected ';' at end of declaration\nlist 18 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long subString_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v1; // rax\n  unsigned long v2; // r8\n  char v3;          // cl\n\n  if (!a0) {\n    return 1;\n  } else if (!*(a0)) {\n    return 0;\n  } else {\n    v1 = a1;\n    v2 = a0 - a1;\n    do {\n      v3 = 0;\n      if ((unsigned int)a2 >= (unsigned int)v1)\n        v3 = a0[v1];\n    } while ((*((char *)(v2 + v1)) = v3, v1 += 1, *((char *)(v2 + v1))));\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long concatenateStrings_name_conflict(char *a0, char *a1) {\n  char *v1;         // rbp\n  char *v2;         // rax, Other Possible Types: unsigned long\n  char *v3;         // rsi\n  char v4;          // dl\n  char *v5;         // rax, Other Possible Types: unsigned long\n  char *v6;         // rsi\n  unsigned long v7; // r12\n\n  v1 = a1;\n  if (!*(a0)) {\n    v7 = 0;\n  } else {\n    v2 = 1;\n    do {\n      v3 = v2;\n      v2 += 1;\n    } while (a0[1 + v2]);\n    v7 = v3;\n  }\n  printf(\"%d\", (unsigned int)v7);\n  v4 = *(v1);\n  if (v4) {\n    v5 = v7 + 1;\n    do {\n      a0[1 + v5] = v4;\n      v6 = v5;\n      v5 += 1;\n      v4 = v1[1 + v5 + -1 * v7];\n    } while (v4);\n    v7 = v6;\n  }\n  a0[v7] = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmtd3allx/concatenateStrings_name_conflict.c:39:20: error: array subscript is not an\ninteger 39 |         } while (a0[1 + v2]); |                    ^~~~~~~\n/tmp/tmpmtd3allx/concatenateStrings_name_conflict.c:49:15: error: array subscript is not an\ninteger 49 |             a0[1 + v5] = v4; |               ^~~~~~~\n/tmp/tmpmtd3allx/concatenateStrings_name_conflict.c:52:20: error: array subscript is not an\ninteger 52 |             v4 = v1[1 + v5 + -1 * v7]; | ^~~~~~~~~~~~~~~~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long printString_name_conflict() {\n  char v0; // [bp-0x48]\n\n  puts(\"Please type a string\\n\");\n  __isoc99_scanf(\"\\n%50[^\\n]s\");\n  return puts(&v0);\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printStringWLen_name_conflict(char *a0, unsigned int *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  unsigned int v2;  // edx\n  unsigned int v3;  // esi\n\n  v1 = 1;\n  if (!*(a0)) {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (a0[1 + v1]);\n  *(a1) = v2;\n  v3 = (unsigned int)a0;\n  printf(\"You Entered:%s\\n\", v3);\n  printf(\"The Length of the string is: %d\\n\", *(a1));\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long alphaNumeric_name_conflict(unsigned long a0) {\n  if (a0 - 48 <= 9) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  } else if (a0 - 65 <= 25) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  } else if (a0 - 97 > 25) {\n    printf(\"%c is not alphanumeric.\\n\", (char)a0);\n    return 0;\n  } else {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int testFindLength() {\n    int i, strLength, strLengthResponse = -5, returnValue;\n    for (i = 0; i < numArrays; i++) {\n        strLength = strings[i].length;\n        char *string = malloc(strLength * sizeof(char));\n        string = strings[i].value;\n        strLength = strlen(string);\n        returnValue = printStringWLen(string, &strLengthResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strLengthResponse == -5) {\n            return -2;\n        }\n        if (strLengthResponse != strLength) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(printStringWLen)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  unsigned long long field_8;\n} struct_0;\n\nextern unsigned int numArrays;\nextern struct_0 strings;\n\nlong long testFindLength_name_conflict() {\n  unsigned int v0;  // [bp-0x2c]\n  struct_0 *v2;     // rbp, Other Possible Types: unsigned long\n  unsigned long v3; // rax\n  char *v4;         // r14\n  unsigned int v6;  // edx\n\n  v0 = -5;\n  if (numArrays <= 0)\n    return 0;\n  v2 = &strings.padding_0[0];\n  while (!(unsigned int)v3) {\n    v4 = *((long long *)(v2 + 8));\n    v3 = printStringWLen(v4, &v0);\n    v6 = v0;\n    if (v6 == -5) {\n      return 4294967294;\n    } else if (v6 != (unsigned int)strlen(v4)) {\n      return 4294967295;\n    } else {\n      v2 += 16;\n      if (numArrays <= 1)\n        return v3;\n    }\n  }\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testVowels() {\n    int i, e, numVowels, strLength, strVowelResponse, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        numVowels = 0;\n        strVowelResponse = -5;\n        for (i = 0; string[i] != '\\x00'; i++) {\n            if (string[i] == 'a' || string[i] == 'e' || string[i] == 'i' || string[i] == 'o' || string[i] == 'u' || string[i] == 'A' || string[i] == 'E' || string[i] == 'I' || string[i] == 'O' || string[i] == 'U')\n                numVowels++;\n        }\n        returnValue = vowelCheck(string, &strVowelResponse);\n        printf(\"Num Vowels Response -- %d\\n\", strVowelResponse);\n        printf(\"Num Vowels -- %d\\n\", numVowels);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strVowelResponse == -5) {\n            return -2;\n        }\n        if (strVowelResponse != numVowels) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(loadArrays)();\nlong long(vowelCheck)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  struct struct_1 *field_8;\n} struct_0;\n\ntypedef struct struct_2 {\n  char field_ - 1;\n} struct_2;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\nextern unsigned int numArrays;\nextern struct_0 strings;\n\nlong long testVowels_name_conflict() {\n  unsigned int v0;  // [bp-0x3c]\n  struct_0 *v2;     // r13, Other Possible Types: unsigned long\n  unsigned long v3; // r12\n  char *v4;         // rdi\n  char v5;          // cl\n  struct_2 *v6; // rdx, Other Possible Types: unsigned long long, unsigned long\n  unsigned long v7; // rcx, Other Possible Types: unsigned long long\n  unsigned long v8; // rbx, Other Possible Types: unsigned int\n  unsigned int v9;  // eax\n\n  if (numArrays <= 0)\n    return 0;\n  v2 = &strings.padding_0[0];\n  while (true) {\n    loadArrays();\n    v4 = *((long long *)(v2 + 8));\n    v0 = -5;\n    v7 = *(v4);\n    if (!(char)v7) {\n      v8 = 0;\n    } else {\n      v6 = v4 + 1;\n      v8 = 0;\n      do {\n        v5 = (unsigned int)v7 - 65;\n        if (v5 <= 52)\n          v8 += (int)(4575140898685201 >> (v5 & 63)) & 1;\n      } while ((v6 += 1, v7 = (unsigned long long)v6[1].field_ - 1, (char)v7));\n    }\n    v3 = vowelCheck(v4, &v0);\n    printf(\"Num Vowels Response -- %d\\n\", v0);\n    printf(\"Num Vowels -- %d\\n\", (unsigned int)v8);\n    if ((unsigned int)v3)\n      return 1;\n    v9 = v0;\n    if (v9 == -5) {\n      return 4294967294;\n    } else if (v9 == (unsigned int)v8) {\n      v2 += 16;\n      if (numArrays <= 1)\n        return v3;\n    } else {\n      return 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphba5xkn9/testVowels_name_conflict.c:25:16: error: expected ';' at end of declaration\nlist 25 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testNumberWords() {\n    int i, e, numWords, strLength, strWordResponse = -5, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        string[0] = 'A';\n        numWords = 1;\n        strWordResponse = 0;\n        for (i = 1; string[i] != '\\x00'; i++) {\n            if ((string[i] == ' ' && string[i - 1] != ' ')) {\n                numWords++;\n            }\n        }\n        returnValue = wordCount(string, &strWordResponse);\n        printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", string, numWords, strWordResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strWordResponse == -5) {\n            return -2;\n        }\n        if (strWordResponse != numWords) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(loadArrays)();\nlong long(wordCount)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  struct struct_1 *field_8;\n} struct_0;\n\ntypedef struct struct_1 {\n  char field_0;\n  char field_1;\n} struct_1;\n\nextern unsigned int numArrays;\nextern struct_0 strings;\n\nlong long testNumberWords_name_conflict() {\n  unsigned int v0;  // [bp-0x3c]\n  struct_0 *v2;     // r12, Other Possible Types: unsigned long\n  unsigned long v3; // r15\n  char v4[2];       // rbp\n  char v5;          // dl\n  char v6[2];       // rax, Other Possible Types: unsigned long\n  unsigned long v7; // rbx, Other Possible Types: unsigned int\n  unsigned int v8;  // eax\n\n  v0 = -5;\n  if (numArrays <= 0)\n    return 0;\n  v2 = &strings.padding_0[0];\n  while (true) {\n    loadArrays();\n    v4 = *((long long *)(v2 + 8));\n    v4[0] = 65;\n    v0 = 0;\n    v5 = v4[1];\n    if (!v5) {\n      v7 = 1;\n    } else {\n      v6 = v4;\n      v7 = 1;\n      do {\n        if (v5 == 32)\n          v7 += *((char *)v6) != 32;\n      } while ((v6 += 1, v5 = *((char *)(v6 + 1)), v5));\n    }\n    v3 = wordCount(v4, &v0);\n    printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", (unsigned int)v4,\n           (unsigned int)v7, v0);\n    if ((unsigned int)v3)\n      return 1;\n    v8 = v0;\n    if (v8 == -5) {\n      return 4294967294;\n    } else if (v8 != (unsigned int)v7) {\n      return 4294967295;\n    } else {\n      v2 += 16;\n      if (numArrays <= 1)\n        return v3;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb2vaztk9/testNumberWords_name_conflict.c:50:12: error: array type 'char[2]' is not\nassignable 50 |         v4 = *((long long *)(v2 + 8)); |         ~~ ^\n/tmp/tmpb2vaztk9/testNumberWords_name_conflict.c:60:16: error: array type 'char[2]' is not\nassignable 60 |             v6 = v4; |             ~~ ^\n/tmp/tmpb2vaztk9/testNumberWords_name_conflict.c:66:26: error: invalid operands to binary\nexpression ('char[2]' and 'int') 66 |             } while ((v6 += 1, v5 =\n*((char *)(v6 + 1)), v5)); |                       ~~ ^  ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testAlphaNumericChar() {\n    int value;\n    int first;\n    int second;\n    int third;\n    value = alphaNumeric('n');\n    if (value == 0) {\n        first = 0;\n    }\n    if (value == 1) {\n        first = 1;\n    }\n    value = alphaNumeric('9');\n    if (value == 0) {\n        second = 0;\n    }\n    if (value == 1) {\n        second = 1;\n    }\n    value = alphaNumeric('!');\n    if (value == 0) {\n        third = 0;\n    }\n    if (value == 1) {\n        third = 1;\n    }\n    if (third == 0 && second == 0 && first == 0) {\n        return 0;\n    } else\n        return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(alphaNumeric)(long long);\n\nlong long testAlphaNumericChar(unsigned long a0, unsigned long a1,\n                               unsigned long a2, unsigned long a3) {\n  unsigned int v1;       // edx\n  char v2;               // al\n  unsigned int v3;       // eax\n  unsigned int v4;       // eax\n  unsigned long long v5; // rax\n\n  v1 = alphaNumeric(33);\n  v2 = (int)alphaNumeric(57) == 1;\n  v4 = v3 | (int)alphaNumeric(110) == 1;\n  *((char *)&v1) = v1 == 1;\n  v5 = v4 | v1;\n  return v5;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testSubString() {\n    char string[] = \"lucille\";\n    subString(string, 2, 5);\n    if (strcmp(string, \"cill\") != 0) {\n        printf(\"Testing Sub String -- %s\\n\", string);\n        return -1;\n    }\n    if (string == ((void *)0)) {\n        return -2;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(subString)(long long, long long, long long);\n\nlong long testSubString_name_conflict() {\n  char v0;          // [bp-0x10]\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  strncpy(&v0, \"lucille\", 7);\n  subString(&v0, 2, 5);\n  (unsigned int)v2 = strcmp(&v0, \"cill\");\n  if ((unsigned int)v2) {\n    printf(\"Testing Sub String -- %s\\n\", (unsigned int)&v0);\n    return 4294967295;\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpydwm7m66/testSubString_name_conflict.c:25:5: error: assignment to cast is illegal,\nlvalue casts are not supported 25 |     (unsigned int)v2 = strcmp(&v0, \"cill\");\n      |     ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testConcat() {\n    char string1[500] = \"A melancholy-looking man, he had the appearance of one \";\n    char string2[] = \"who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    char stringTotal[] = \"A melancholy-looking man, he had the appearance of one who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    int returnValue = concatenateStrings(string1, string2);\n    if (returnValue != 0) {\n        return 1;\n    }\n    int i = 0;\n    while (stringTotal[i] != '\\x00')\n        {\n            if (string1[i] != stringTotal[i]) {\n                return -2;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(concatenateStrings)(long long, long long);\n\nlong long testConcat_name_conflict() {\n  unsigned long long v0;  // [bp-0x2f8]\n  char v2;                // [bp-0x288]\n  char v3;                // [bp-0x27b]\n  char v4;                // [bp-0x268]\n  char v5;                // [bp-0x21a]\n  unsigned long long v6;  // [bp-0x208]\n  char v7;                // [bp-0x1e8]\n  char v8;                // [bp-0x1d8]\n  void *v9;               // [bp-0x1d0]\n  char v10;               // [bp-0x1c8]\n  unsigned long long v12; // r8\n  unsigned long long v13; // r9\n  unsigned long long v14; // rsi\n  void *v15;              // rdx\n  unsigned long v16;      // rcx, Other Possible Types: unsigned long long\n  unsigned long v17;      // d\n  unsigned int *v18;      // rdi, Other Possible Types: unsigned long\n  unsigned long long v19; // rdx\n  unsigned long v20;      // rax, Other Possible Types: unsigned long long\n  char v21;               // cl\n  unsigned long v22;      // rdx\n\n  v12 = 7164771175379050561;\n  v13 = 8029755603191361384;\n  strncpy(&v6, \"A melancholy-looking man, he had\", 32);\n  v14 = 2334381307593908581;\n  strncpy(&v7, \" the appearance \", 16);\n  v15 = 0;\n  strncpy(&v8, \"of one \", 7);\n  v9 = 0;\n  v18 = &v10;\n  for (v16 = 54; v16; v18 += v17 * 8) {\n    v16 -= 1;\n    *((long long *)v18) = 0;\n  }\n  *((int *)v18) = 0;\n  strncpy(&v4,\n          \"who has searched for the leak in life's gas-pipe with a lighted \"\n          \"candle - PG Wode\",\n          80);\n  strncpy(&v5, \"dehouse\", 7);\n  strncpy(&v0,\n          \"A melancholy-looking man, he had the appearance of one who has \"\n          \"searched for the leak in life's gas-pipe with a l\",\n          112);\n  v19 = 2318545003147980385;\n  strncpy(&v2, \"ighted candle - \", 16);\n  strncpy(&v3, \" - PG Wodehouse\", 15);\n  v20 = concatenateStrings(&v6, &v4);\n  if ((unsigned int)v20)\n    return 1;\n  v21 = v0;\n  if (!v21)\n    return v20;\n  v22 = 0;\n  while (*(v22 + (char *)&v6) == v21) {\n    v22 += 1;\n    v21 = *((char *)&v0 + v22);\n    if (!v21)\n      return v20;\n  }\n  return 4294967294;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testRemove() {\n    char chararray[] = \"mother hubbard\";\n    char removeword[] = \"hubbard\";\n    wordRemove(chararray, removeword);\n    if (strcmp(chararray, \"mother \") != 0) {\n        return 0;\n    }\n    if (strcmp(chararray, \"mother\") != 0) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(wordRemove)(long long, long long);\n\nlong long testRemove_name_conflict() {\n  char v0; // [bp-0x1f]\n  char v1; // [bp-0x17]\n  char v2; // [bp-0x10]\n\n  strncpy(&v1, \"mother h\", 8);\n  strncpy(&v2, \"hubbard\", 7);\n  strncpy(&v0, \"hubbard\", 7);\n  wordRemove(&v1, &v0);\n  if (!strcmp(&v1, \"mother \"))\n    return -(strcmp(&v1, \"mother\") < 1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int generateReport(char *file) {\n    FILE *outFile;\n    outFile = fopen(file, \"a\");\n    int functionResponse, i, numFunctions = 7, numErrors = 0;\n    struct TesterFunction functions[7] = {{\"Find Length Function\", &testFindLength}, {\"Find Vowels Function\", &testVowels}, {\"Find Number of Words Function\", &testNumberWords}, {\"Test if char is alpha-numeric\", &testAlphaNumericChar}, {\"Create Substring function\", &testSubString}, {\"Contatenate Function\", &testConcat}, {\"Remove Word Function\", &testRemove}};\n    addStrings(outFile, \"\\n\\nGenerall Tests ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    for (i = 0; i < numFunctions; i++) {\n        functionResponse = functions[i].function();\n        printf(\"Index %d Function %s returned %d\\n\", i, functions[i].name, functionResponse);\n        addStrings(outFile, functions[i].name);\n        switch (functionResponse) {\n          case 0:\n            addStrings(outFile, \" function ---  passed all tests.\\n\\n\");\n            break;\n          case 1:\n            addStrings(outFile, \" function ---- failed to run.\\n\\n\");\n            break;\n          case -1:\n            addStrings(outFile, \" function ---- did not return the correct result\\n\\n\");\n            break;\n          case -2:\n            addStrings(outFile, \" function ---- did not return result\\n\\n\");\n            break;\n        }\n    }\n    addStrings(outFile, \"\\n\\nExtra Targeted Testing ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    addStrings(outFile, \"ALL PASS\");\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n-----------------------------------------------------------------\\n\");\n    printf(\"REPORT HAS BEEN SAVED in file '%s' \\n\", file);\n    printf(\"Output fclose - %d\", fclose(outFile));\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint testFindLength;       // add global variable by heuristics\nint testVowels;           // add global variable by heuristics\nint testNumberWords;      // add global variable by heuristics\nint testAlphaNumericChar; // add global variable by heuristics\nint testSubString;        // add global variable by heuristics\nint testConcat;           // add global variable by heuristics\nint testRemove;           // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fputs)(\n    char *, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long generateReport_name_conflict(char *a0) {\n  char v0;                // [bp-0xb8]\n  unsigned long v1;       // [bp-0xa8]\n  struct struct_0 **v2;   // [bp-0xa0]\n  unsigned long v3;       // [bp-0x98]\n  unsigned long v4;       // [bp-0x90]\n  unsigned long v5;       // [bp-0x88]\n  unsigned long v6;       // [bp-0x80]\n  unsigned long v7;       // [bp-0x78]\n  unsigned long v8;       // [bp-0x70]\n  unsigned long v9;       // [bp-0x68]\n  unsigned long v10;      // [bp-0x60]\n  unsigned long v11;      // [bp-0x58]\n  unsigned long v12;      // [bp-0x50]\n  unsigned long v13;      // [bp-0x48]\n  unsigned long v14;      // [bp-0x40]\n  FILE_t *v16;            // r12\n  struct_1 *v17;          // rbp, Other Possible Types: unsigned long\n  unsigned long v18;      // r13\n  unsigned long long v19; // rax\n  char *v20;              // r13\n\n  v16 = fopen(a0, \"a\");\n  v1 = \"Find Length Function\";\n  v2 = &testFindLength;\n  v3 = \"Find Vowels Function\";\n  v4 = testVowels;\n  v5 = \"Find Number of Words Function\";\n  v6 = testNumberWords;\n  v7 = \"Test if char is alpha-numeric\";\n  v8 = testAlphaNumericChar;\n  v9 = \"Create Substring function\";\n  v10 = testSubString;\n  v11 = \"Contatenate Function\";\n  v12 = testConcat;\n  v13 = \"Remove Word Function\";\n  v14 = testRemove;\n  fwrite(\"\\n\\nGenerall Tests ...\\n\", 1, 21, v16);\n  fwrite(\"-----------------------------------------------------------------\\n\",\n         1, 66, v16);\n  v17 = 0;\n  do {\n    v18 = v17 * 16;\n    (unsigned int)v19 = *((long long *)&(&v0)[24 + v18])();\n    v20 = *((long long *)((char *)&v1 + v18));\n    printf(\"Index %d Function %s returned %d\\n\", (unsigned int)v17,\n           (unsigned int)v20, (unsigned int)v19);\n    fputs(v20, v16);\n    if (!(unsigned int)v19) {\n      fwrite(\" function ---  passed all tests.\\n\\n\", 1, 34, v16);\n    } else if ((unsigned int)v19 > 0) {\n      if ((unsigned int)v19 == 1)\n        fwrite(\" function ---- failed to run.\\n\\n\", 1, 31, v16);\n    } else {\n      if ((unsigned int)v19 == -2) {\n        fwrite(\" function ---- did not return result\\n\\n\", 1, 38, v16);\n      } else if ((unsigned int)v19 == -1) {\n        fwrite(\" function ---- did not return the correct result\\n\\n\", 1, 50,\n               v16);\n      }\n    }\n  } while ((v17 += 1, v17 != 7));\n  fwrite(\"\\n\\nExtra Targeted Testing ...\\n\", 1, 29, v16);\n  fwrite(\"-----------------------------------------------------------------\\n\",\n         1, 66, v16);\n  fwrite(\"ALL PASS\", 1, 8, v16);\n  puts(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n-----------------------------------------------------\"\n       \"------------\");\n  printf(\"REPORT HAS BEEN SAVED in file '%s' \\n\", (unsigned int)a0);\n  printf(\"Output fclose - %d\", fclose(v16));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:37:16: error: nested redefinition of\n'_IO_marker' 37 |         struct _IO_marker { |                ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:36:12: note: previous definition is here\n   36 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:80:13: error: declaration of anonymous union\nmust be a definition 80 |             union <anon> { |             ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:83:22: error: type name requires a specifier\nor qualifier 83 |             } __value; |                      ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:87:13: error: declaration of anonymous union\nmust be a definition 87 |             union <anon> { |             ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:90:22: error: type name requires a specifier\nor qualifier 90 |             } __value; |                      ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:23:6: error: conflicting types for 'fputs'\n   23 | int (fputs)(char *, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:655:12: note: previous declaration is here\n  655 | extern int fputs (const char *__restrict __s, FILE *__restrict\n__stream); |            ^ /tmp/tmpk7w5bzkm/generateReport_name_conflict.c:152:16: error:\nredefinition of '_IO_marker' 152 | typedef struct _IO_marker { | ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:36:12: note: previous definition is here\n   36 |     struct _IO_marker {\n      |            ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:158:16: error: redefinition of '_IO_codecvt'\n  158 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:58:12: note: previous definition is here\n   58 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:162:16: error: redefinition of '_IO_wide_data'\n  162 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:66:12: note: previous definition is here\n   66 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:185:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 185 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpk7w5bzkm/generateReport_name_conflict.c:230:19: error: invalid operands to binary\nexpression ('struct_1 *' (aka 'struct struct_1 *') and 'int') 230 |         v18\n= v17 * 16; |               ~~~ ^ ~~ /tmp/tmpk7w5bzkm/generateReport_name_conflict.c:231:61:\nerror: called object type 'long long *' is not a function or function pointer\n  231 |         (unsigned int)v19 = *((long long *)&(&v0)[24 + v18])();\n      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int generate_random_string_array(char *array, int array_length) {\n    int i;\n    if (!array) {\n        printf(\"Error: Input array was NULL\\n\");\n        return 1;\n    }\n    if (array_length < 1) {\n        printf(\"Error: required array size < 1\\n\");\n        return 1;\n    }\n    for (i = 0; i < array_length; i++) {\n        switch (rand() % 5) {\n          case 0:\n            array[i] = 'A' + (rand() % 26);\n            break;\n          case 1:\n            array[i] = ' ';\n            break;\n          default:\n            array[i] = 'a' + (rand() % 26);\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(rand)();\n\nlong long generate_random_string_array_name_conflict(char *a0, unsigned long a1) {\n  int tmp_70;            // tmp #70\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n  unsigned int v4;       // ecx\n  unsigned long long v6; // rax\n  unsigned long long v7; // rax\n\n  if (!a0) {\n    puts(\"Error: Input array was NULL\");\n    return 1;\n  } else if ((unsigned int)a1 <= 0) {\n    puts(\"Error: required array size < 1\");\n    return 1;\n  } else {\n    v1 = a0;\n    do {\n      (unsigned int)v3 = rand();\n      v4 = (unsigned int)((v3 * 1717986919 >> 33) - (v3 >> 31)) * 5;\n      tmp_70 = v3;\n      if ((int)tmp_70 == v4) {\n        (unsigned int)v6 = rand();\n        *((char *)v1) =\n            (unsigned int)(v6 - (unsigned int)((v6 * 1321528399 >> 35) -\n                                               (v6 >> 31)) *\n                                    26) +\n            65;\n      } else if ((unsigned int)v3 - v4 == 1) {\n        *((char *)v1) = 32;\n      } else {\n        (unsigned int)v7 = rand();\n        *((char *)v1) =\n            (unsigned int)(v7 - (unsigned int)((v7 * 1321528399 >> 35) -\n                                               (v7 >> 31)) *\n                                    26) +\n            97;\n      }\n    } while ((v1 += 1, v1 != a0 + a1));\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgazfdo_v/generate_random_string_array_name_conflict.c:42:13: error: assignment to cast\nis illegal, lvalue casts are not supported 42 |             (unsigned int)v3 =\nrand(); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpgazfdo_v/generate_random_string_array_name_conflict.c:47:17: error: assignment to cast\nis illegal, lvalue casts are not supported 47 |                 (unsigned int)v6\n= rand(); |                 ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpgazfdo_v/generate_random_string_array_name_conflict.c:56:17: error: assignment to cast\nis illegal, lvalue casts are not supported 56 |                 (unsigned int)v7\n= rand(); |                 ^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int loadArrays() {\n    int i, currentArrayLength = 10;\n    for (i = 0; i < numArrays; i++) {\n        char array[currentArrayLength];\n        generate_random_string_array(array, currentArrayLength);\n        strings[i].value = malloc(currentArrayLength);\n        strcpy(strings[i].value, array);\n        strings[i].length = currentArrayLength;\n        currentArrayLength *= 5;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(generate_random_string_array)(long long, long long);\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  char padding_4[4];\n  unsigned long long field_8;\n} struct_0;\n\nextern char g_401a17;\nextern unsigned int numArrays;\nextern struct_0 strings;\n\nlong long loadArrays_name_conflict() {\n  unsigned long v0;       // [bp-0x30]\n  unsigned long v1;       // [bp-0x28]\n  unsigned long v2;       // [bp-0x20]\n  unsigned long v3;       // [bp-0x18]\n  unsigned long v4;       // [bp-0x10]\n  struct_1 *v5;           // [bp-0x8]\n  char v6;                // [bp+0x0]\n  unsigned long v8;       // r15\n  unsigned long v9;       // r14\n  unsigned long v10;      // r13\n  unsigned long v11;      // r12\n  unsigned long v12;      // rbx\n  unsigned long v13;      // rax\n  char *v14;              // rax\n  struct_0 *v15;          // r12, Other Possible Types: unsigned long\n  unsigned long v16;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v17; // rbx\n  unsigned long long v18; // r12\n  unsigned long long v19; // r13\n  unsigned long long v20; // r14\n  unsigned long long v21; // r15\n\n  if (numArrays <= 0)\n    return 0;\n  v5 = &v6;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  v1 = v11;\n  v0 = v12;\n  v15 = &strings.field_0;\n  v16 = 10;\n  do {\n    v13 = (0 CONCAT v16 + 15) / m 16 * 16;\n    *((char **)((char *)&v5 - v13)) = &g_401a17;\n    generate_random_string_array(&(&v6)[-1 * v13], v16);\n    v14 = malloc(v16);\n    *((char **)(v15 + 8)) = v14;\n    strcpy(v14, &v6);\n    *((unsigned int *)v15) = v16;\n    v16 *= 5;\n    v15 += 16;\n  } while (numArrays > 1);\n  v17 = v0;\n  v18 = v1;\n  v19 = v2;\n  v20 = v3;\n  v21 = v4;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpiyw6k0ua/loadArrays_name_conflict.c:69:18: error: expected ')'\n   69 |         v13 = (0 CONCAT v16 + 15) /m 16 * 16;\n      |                  ^\n/tmp/tmpiyw6k0ua/loadArrays_name_conflict.c:69:15: note: to match this '('\n   69 |         v13 = (0 CONCAT v16 + 15) /m 16 * 16;\n      |               ^\n/tmp/tmpiyw6k0ua/loadArrays_name_conflict.c:69:37: error: expected ';' after expression\n   69 |         v13 = (0 CONCAT v16 + 15) /m 16 * 16;\n      |                                     ^\n      |                                     ;\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int wordCount_handler(char *array) {\n    int numWords = 0;\n    wordCount(array, &numWords);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(wordCount)(long long, long long);\n\nlong long wordCount_handler_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  wordCount(a0, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int wordRemove_handler(char *array) {\n    char wordToRemove[1000];\n    char sentence[1000];\n    askQuestionString(sentence, \"Enter a sentence\");\n    askQuestionString(wordToRemove, \"Enter a word to remove\");\n    wordRemove(sentence, wordToRemove);\n    printf(\"Sentence after '%s' removed -- %s\\n\", wordToRemove, sentence);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(askQuestionString)(long long);\nlong long(wordRemove)(long long, long long);\n\nlong long wordRemove_handler_name_conflict() {\n  char v0; // [bp-0x7f8]\n  char v1; // [bp-0x408]\n\n  askQuestionString(&v0);\n  askQuestionString(&v1);\n  wordRemove(&v0, &v1);\n  printf(\"Sentence after '%s' removed -- %s\\n\", (unsigned int)&v1,\n         (unsigned int)&v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int vowelCheck_handler(char *array) {\n    int vowels = 0;\n    vowelCheck(array, &vowels);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(vowelCheck)(long long, long long);\n\nlong long vowelCheck_handler_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 0;\n  vowelCheck(a0, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int subString_handler(char *array) {\n    int start = 0, end = 0;\n    if (askQuestionInt(&start, \"Input start of substring\") == 1 || askQuestionInt(&end, \"Input end of substring\") == 1) {\n        return 1;\n    }\n    subString(array, start, end);\n    printf(\"String has been modified -- new string -- %s\\n\", array);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(askQuestionInt)(long long);\nlong long(subString)(long long, long long, long long);\n\nlong long subString_handler_name_conflict(unsigned long long a0) {\n  unsigned int v0; // [bp-0x10]\n  unsigned int v1; // [bp-0xc]\n  void *v3;        // rax, Other Possible Types: unsigned long\n\n  v1 = 0;\n  v0 = 0;\n  v3 = askQuestionInt(&v1);\n  if ((unsigned int)v3 == 1)\n    return v3;\n  v3 = askQuestionInt(&v0);\n  if ((unsigned int)v3 != 1) {\n    subString(a0, v1, v0);\n    printf(\"String has been modified -- new string -- %s\\n\", (unsigned int)a0);\n    return 0;\n  }\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int concatStrings_handler(char *array) {\n    char one[100], two[100];\n    if (askQuestionString(one, \"Input first of string\") == 1 || askQuestionString(two, \"Input second of string\") == 1) {\n        return 1;\n    }\n    concatenateStrings(one, two);\n    printf(\"Concatenated Strings -- %s\\n\", one);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(askQuestionString)(long long);\nlong long(concatenateStrings)(long long, long long);\n\nlong long concatStrings_handler_name_conflict() {\n  char v0;  // [bp-0xe8]\n  char v1;  // [bp-0x78]\n  void *v3; // rax, Other Possible Types: unsigned long\n\n  v3 = askQuestionString(&v1);\n  if ((unsigned int)v3 == 1)\n    return v3;\n  v3 = askQuestionString(&v0);\n  if ((unsigned int)v3 != 1) {\n    concatenateStrings(&v1, &v0);\n    printf(\"Concatenated Strings -- %s\\n\", (unsigned int)&v1);\n    return 0;\n  }\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int printHandler(char *array) {\n    printf(\"%s\\n\", array);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printHandler_name_conflict(char *a0) {\n  puts(a0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int isAlpha_handler(char *array) {\n    char c;\n    printf(\"\\nEnter a Char :: \");\n    scanf(\" %c\", &c);\n    int isAlphaNum = alphaNumeric(c);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\nlong long(alphaNumeric)(long long);\n\nlong long isAlpha_handler_name_conflict() {\n  char v0; // [bp-0x9]\n\n  printf(\"\\nEnter a Char :: \");\n  __isoc99_scanf(\" %c\", (unsigned int)&v0);\n  alphaNumeric(v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":0,"function":"int printMenu(char **array, int arrayLength) {\n    int i;\n    printf(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\\n\");\n    for (i = 0; i < arrayLength; i++) {\n        printf(\"\\t%d for %s\\n\", i, array[i]);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printMenu_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long *v1; // rbx, Other Possible Types: unsigned long\n\n  puts(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\");\n  if ((unsigned int)a1 <= 0)\n    return 0;\n  v1 = 0;\n  do {\n    printf(\"\\t%d for %s\\n\", (unsigned int)v1,\n           (int)*((long long *)(a0 + v1 * 8)));\n    v1 += 1;\n  } while (v1 != a1);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5cbk2iw0/printMenu_name_conflict.c:27:80: error: invalid operands to binary expression\n('unsigned long long *' and 'int') 27 |         printf(\"\\t%d for %s\\n\",\n(unsigned int)v1, (int)*((long long *)(a0 + v1 * 8))); | ~~ ^ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int askQuestionInt(int *value, char *q) {\n    printf(\"\\n%s : \", q);\n    scanf(\"%d\", value);\n    if (*value == -1) {\n        return -1;\n    }\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *__TMC_END__;\n\nlong long askQuestionInt(unsigned int *a0) {\n  unsigned int v1; // esi\n\n  printf(\"\\n%s : \", v1);\n  __isoc99_scanf(\"%d\", (unsigned int)a0);\n  if (*(a0) == -1)\n    return *(a0);\n  do {\n  } while (getc(__TMC_END__) != 10);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9gfugmk8/askQuestionInt.c:31:16: error: nested redefinition of\n'_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:30:12: note: previous definition is here\n   30 |     struct _IO_marker {\n      |            ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:74:13: error: declaration of anonymous union\nmust be a definition 74 |             union <anon> { |             ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:77:22: error: type name requires a specifier\nor qualifier 77 |             } __value; |                      ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:81:13: error: declaration of anonymous union\nmust be a definition 81 |             union <anon> { |             ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:84:22: error: type name requires a specifier\nor qualifier 84 |             } __value; |                      ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:17:6: error: conflicting types for 'getc'\n   17 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp9gfugmk8/askQuestionInt.c:107:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 107 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int askQuestionString(char *value, char *q) {\n    printf(\"%s : \", q);\n    scanf(\"%[^\\t\\n]s\", value);\n    printf(\"%s\\n\", value);\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *__TMC_END__;\n\nlong long askQuestionString(char *a0) {\n  unsigned int v1; // esi\n\n  printf(\"%s : \", v1);\n  __isoc99_scanf(\"%[^\\t\\n]s\");\n  puts(a0);\n  do {\n  } while (getc(__TMC_END__) != 10);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7i4uq2sp/askQuestionString.c:31:16: error: nested redefinition of\n'_IO_marker' 31 |         struct _IO_marker { |                ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:30:12: note: previous definition is here\n   30 |     struct _IO_marker {\n      |            ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:74:13: error: declaration of anonymous\nunion must be a definition 74 |             union <anon> { |             ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:77:22: error: type name requires a\nspecifier or qualifier 77 |             } __value; |                      ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:81:13: error: declaration of anonymous\nunion must be a definition 81 |             union <anon> { |             ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:84:22: error: type name requires a\nspecifier or qualifier 84 |             } __value; |                      ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:17:6: error: conflicting types for 'getc'\n   17 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp7i4uq2sp/askQuestionString.c:107:8: error: unknown type name 'FILE_t';\ndid you mean 'FILE'? 107 | extern FILE_t *__TMC_END__; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(long long, long long, long long, long long);\n\nlong long wordCount_name_conflict(unsigned long long a0, unsigned int *a1) {\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  *(a1) = CountWords(a0, 0, 0, 1000);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(CountWords)(char *, unsigned long long, unsigned long, unsigned long);\n\nlong long CountWords(char *a0, unsigned long long a1, unsigned long a2,\n                     unsigned long a3) {\n  unsigned long v1; // rbx\n  char v2;          // cl\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n  void *v4;         // rcx, Other Possible Types: unsigned long\n\n  if ((unsigned int)a1 < 0) {\n    puts(\"ERROR: count needs to be greater than 0.\");\n    return 1;\n  } else if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  } else if ((unsigned int)a2 > (unsigned int)a3) {\n    puts(\"ERROR: the start point was greater than the max size.\");\n    return 1;\n  } else if (((unsigned int)a3 | (unsigned int)a2) < 0) {\n    puts(\"ERROR: the start point or the max size were set less than zero.\");\n    return 1;\n  } else {\n    v2 = *(a0);\n    if (v2 == 32) {\n      puts(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\");\n      return 1;\n    }\n    v3 = 1;\n    if (!v2) {\n      v4 = 0;\n    } else {\n      do {\n        v4 = v3;\n        v3 += 1;\n      } while (a0[1 + v3]);\n    }\n    if (a0[a2] == 32 && a0[1 + a2] != 32)\n      a1 += (unsigned int)v4 - 1 != (unsigned int)a2;\n    if ((unsigned int)a2 == (unsigned int)v4) {\n      v1 = a1 + 1;\n      printf(\"number of words: %d\\n\", (unsigned int)v1);\n      return a1 + 1;\n    }\n    v1 = CountWords(a0, a1, (unsigned int)a2 + 1, v4);\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long wordRemove_name_conflict(char *a0, char *a1) {\n  char *v1;              // rbx\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n  char v4;               // r11b\n  unsigned int v5;       // r8d\n  unsigned long v6;      // rax, Other Possible Types: unsigned long long\n  unsigned long v7;      // rbp\n  unsigned long long v8; // rsi\n  char v9[2];            // rcx, Other Possible Types: unsigned long\n  unsigned long v10;     // edx, Other Possible Types: unsigned int\n  unsigned long v11;     // rax\n  char v12;              // cl\n  char *v13;             // rdx\n  char *v14;             // rax, Other Possible Types: unsigned long\n\n  if (!a0) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  v1 = a1;\n  if (!a1) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  v2 = 1;\n  if (!*(a0)) {\n    v4 = *(a1);\n    v5 = 0;\n    if (!v4) {\n      goto LABEL_40170d;\n    } else {\n      v6 = 1;\n      do {\n      LABEL_40164d:\n        v8 = v6;\n        v6 += 1;\n      } while (v1[1 + v6]);\n      v7 = v8;\n    }\n  } else {\n    do {\n      v5 = v2;\n      v2 += 1;\n    } while (a0[1 + v2]);\n    v4 = *(a1);\n    if (!v4)\n      v7 = 0;\n    else\n      goto LABEL_40164d;\n  }\n  v5 -= (unsigned int)v7;\n  if (v5 < -1) {\n    v10 = 4294967295;\n  } else {\n    v9 = a0 + 1;\n    v10 = -1;\n    do {\n    LABEL_40170d:\n      v10 = (unsigned int)v10 + 1;\n      if (*((char *)(v9 + 1)) == v4 && (unsigned int)v7 > 0) {\n        for (v11 = 1; v9[v11] == v1[1 + v11]; v11 += 1) {\n          if (v11 == v7)\n            goto LABEL_4016c5;\n        }\n      }\n    } while ((v9 += 1, v5 >= (unsigned int)v10));\n  }\nLABEL_4016c5:\n  v12 = a0[v10 + v7];\n  if (v12) {\n    v13 = (unsigned int)v10 + 1;\n    v14 = v13;\n    do {\n      a0[1 + v14] = v12;\n      v10 = v14;\n      v14 += 1;\n      v12 = a0[1 + v14 + v7];\n    } while (v12);\n  }\n  a0[v10] = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3o9mqx6z/wordRemove_name_conflict.c:85:12: error: array type 'char[2]' is not\nassignable 85 |         v9 = a0 + 1; |         ~~ ^\n/tmp/tmp3o9mqx6z/wordRemove_name_conflict.c:99:22: error: invalid operands to binary\nexpression ('char[2]' and 'int') 99 |         } while ((v9 += 1, v5 >= (unsigned\nint)v10)); |                   ~~ ^  ~ /tmp/tmp3o9mqx6z/wordRemove_name_conflict.c:109:15:\nerror: array subscript is not an integer 109 |             a0[1 + v14] = v12; |\n^~~~~~~~ /tmp/tmp3o9mqx6z/wordRemove_name_conflict.c:112:21: error: array subscript is not an\ninteger 112 |             v12 = a0[1 + v14 + v7]; | ^~~~~~~~~~~~~ 4 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long vowelCheck_name_conflict(char *a0, unsigned int *a1) {\n  unsigned long long v0; // [bp-0x128]\n  unsigned long v2;      // rax, Other Possible Types: unsigned long long\n  struct_0 *v3; // rdx, Other Possible Types: unsigned long, unsigned long long\n  unsigned long long v4; // rax\n\n  *(a1) = 0;\n  v2 = *(a0);\n  if ((char)v2) {\n    v3 = a0 + 1;\n    do {\n      v4 = (unsigned int)v2 - 65;\n      if ((char)v4 <= 52) {\n        v0 = 4575140898685201;\n        if (((char)(*((char *)&v0 + ((v4 & 63) >> 3)) >> (char)(v4 & 63 & 7)) &\n             1))\n          *(a1) = *(a1) + 1;\n      }\n    } while ((v3 += 1, v2 = (unsigned long long)v3[1].field_ - 1, (char)v2));\n  }\n  printf(\"No. of vowels in %s = %d\\n\", (unsigned int)a0, *(a1));\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqdqou83d/vowelCheck_name_conflict.c:18:16: error: expected ';' at end of declaration\nlist 18 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long subString_name_conflict(char *a0, char *a1, unsigned long a2) {\n  unsigned long v1; // rax\n  unsigned long v2; // r8\n  char v3;          // cl\n\n  if (!a0) {\n    return 1;\n  } else if (!*(a0)) {\n    return 0;\n  } else {\n    v1 = a1;\n    v2 = a0 - a1;\n    do {\n      v3 = 0;\n      if ((unsigned int)a2 >= (unsigned int)v1)\n        v3 = a0[v1];\n    } while ((*((char *)(v2 + v1)) = v3, v1 += 1, *((char *)(v2 + v1))));\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long concatenateStrings_name_conflict(char *a0, char *a1) {\n  char *v1;         // rbp\n  char *v2;         // rax, Other Possible Types: unsigned long\n  char *v3;         // rsi\n  char v4;          // dl\n  char *v5;         // rax, Other Possible Types: unsigned long\n  char *v6;         // rsi\n  unsigned long v7; // r12\n\n  v1 = a1;\n  if (!*(a0)) {\n    v7 = 0;\n  } else {\n    v2 = 1;\n    do {\n      v3 = v2;\n      v2 += 1;\n    } while (a0[1 + v2]);\n    v7 = v3;\n  }\n  printf(\"%d\", (unsigned int)v7);\n  v4 = *(v1);\n  if (v4) {\n    v5 = v7 + 1;\n    do {\n      a0[1 + v5] = v4;\n      v6 = v5;\n      v5 += 1;\n      v4 = v1[1 + v5 + -1 * v7];\n    } while (v4);\n    v7 = v6;\n  }\n  a0[v7] = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5herl74h/concatenateStrings_name_conflict.c:39:20: error: array subscript is not an\ninteger 39 |         } while (a0[1 + v2]); |                    ^~~~~~~\n/tmp/tmp5herl74h/concatenateStrings_name_conflict.c:49:15: error: array subscript is not an\ninteger 49 |             a0[1 + v5] = v4; |               ^~~~~~~\n/tmp/tmp5herl74h/concatenateStrings_name_conflict.c:52:20: error: array subscript is not an\ninteger 52 |             v4 = v1[1 + v5 + -1 * v7]; | ^~~~~~~~~~~~~~~~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\nlong long printString_name_conflict() {\n  char v0; // [bp-0x48]\n\n  puts(\"Please type a string\\n\");\n  __isoc99_scanf(\"\\n%50[^\\n]s\");\n  return puts(&v0);\n}\n","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long printStringWLen_name_conflict(char *a0, unsigned int *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n  unsigned int v2;  // edx\n  unsigned int v3;  // esi\n\n  v1 = 1;\n  if (!*(a0)) {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  do {\n    v2 = v1;\n    v1 += 1;\n  } while (a0[1 + v1]);\n  *(a1) = v2;\n  v3 = (unsigned int)a0;\n  printf(\"You Entered:%s\\n\", v3);\n  printf(\"The Length of the string is: %d\\n\", *(a1));\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long alphaNumeric_name_conflict(unsigned long a0) {\n  if (a0 - 48 <= 9) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  } else if (a0 - 65 <= 25) {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  } else if (a0 - 97 > 25) {\n    printf(\"%c is not alphanumeric.\\n\", (char)a0);\n    return 0;\n  } else {\n    printf(\"|%c| is alphanumeric.\\n\", (char)a0);\n    return 0;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"static int foo1(void) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long foo1_name_conflict() { return 1; }\n","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":1,"function":"static int foo2(void) {\n    return 2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long foo2_name_conflict() { return 2; }\n","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":0,"function":"int tty_break() {\n    struct termio modmodes;\n    if (ioctl(fileno(stdin), 21509, &saved_modes) == -1) {\n        return -1;\n    }\n    have_modes = 1;\n    modmodes = saved_modes;\n    modmodes.c_lflag &= ~(2 | 8);\n    modmodes.c_cc[6] = 1;\n    modmodes.c_cc[5] = 0;\n    return ioctl(fileno(stdin), 21511, &modmodes);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint uint128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned short g_4040f0;\nextern unsigned int have_modes;\nextern uint128_t saved_modes;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long tty_break_name_conflict() {\n  int v0;            // [bp-0x28]\n  unsigned short v1; // [bp-0x22]\n  char v2;           // [bp-0x1a]\n  char v3;           // [bp-0x19]\n  unsigned short v4; // [bp-0x18]\n  unsigned long v6;  // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v6 = ioctl(fileno(stdin @GLIBC_2.2.5), 21509);\n  if ((unsigned int)v6 != -1) {\n    have_modes = 1;\n    *((uint128_t *)&v0) = saved_modes;\n    v4 = g_4040f0;\n    v1 = (short)(&v0)[6] & 65525;\n    v3 = 1;\n    v2 = 0;\n    (unsigned int)v6 = ioctl(fileno(stdin @GLIBC_2.2.5), 21511);\n    return v6;\n  }\n  return v6;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:20:8: error: unknown type name 'uint128_t'\n   20 | extern uint128_t saved_modes;\n      |        ^\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:21:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 21 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:21:21: error: expected ';' after top level\ndeclarator 21 | extern FILE_t *stdin@GLIBC_2.2.5; |                     ^ | ;\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:32:42: error: expected ')'\n   32 |     (unsigned int)v6 = ioctl(fileno(stdin@GLIBC_2.2.5), 21509);\n      |                                          ^\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:32:36: note: to match this '('\n   32 |     (unsigned int)v6 = ioctl(fileno(stdin@GLIBC_2.2.5), 21509);\n      |                                    ^\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:36:23: error: expected expression\n   36 |         *((uint128_t *)&v0) = saved_modes;\n      |                       ^\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:41:46: error: expected ')'\n   41 |         (unsigned int)v6 = ioctl(fileno(stdin@GLIBC_2.2.5), 21511);\n      |                                              ^\n/tmp/tmps8bvnx1m/tty_break_name_conflict.c:41:40: note: to match this '('\n   41 |         (unsigned int)v6 = ioctl(fileno(stdin@GLIBC_2.2.5), 21511);\n      |                                        ^\n6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"int tty_fix() {\n    if (!have_modes) {\n        return 0;\n    }\n    return ioctl(fileno(stdin), 21511, &saved_modes);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int have_modes;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long tty_fix_name_conflict() {\n  if (have_modes)\n    return ioctl(fileno(stdin @GLIBC_2.2.5), 21511);\n  return have_modes;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpidncrnlc/tty_fix_name_conflict.c:18:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 18 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpidncrnlc/tty_fix_name_conflict.c:18:21: error: expected ';' after top level declarator\n   18 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmpidncrnlc/tty_fix_name_conflict.c:23:34: error: expected ')'\n   23 |         return ioctl(fileno(stdin@GLIBC_2.2.5), 21511);\n      |                                  ^\n/tmp/tmpidncrnlc/tty_fix_name_conflict.c:23:28: note: to match this '('\n   23 |         return ioctl(fileno(stdin@GLIBC_2.2.5), 21511);\n      |                            ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"size_t fmsynth_preset_size(void) {\n    return 8 + sizeof(struct fmsynth_preset_metadata) + FMSYNTH_PARAM_END * 8 * sizeof(uint32_t) + FMSYNTH_GLOBAL_PARAM_END * sizeof(uint32_t);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fmsynth_preset_size_name_conflict() { return 1040; }\n","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"static uint32_t read_u32(const uint8_t *buffer) {\n    return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] << 0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"unsigned int fmsynth_get_version(void) {\n    return 2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fmsynth_get_version_name_conflict() { return 2; }\n","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"int User_Authonrize(struct user *list_head, struct user *login) {\n    User_Login(login);\n    list_head = list_head->next;\n    while (list_head != ((void *)0))\n        {\n            if (!strcmp(login->ID, list_head->ID)) {\n                if (!strcmp(login->Key, list_head->Key)) {\n                    memcpy(login, list_head, sizeof(struct user));\n                    return 0;\n                }\n            }\n            list_head = list_head->next;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(User_Login)(long long);\n\ntypedef struct struct_1 {\n  char padding_0[56];\n  struct struct_0 *field_38;\n} struct_1;\n\ntypedef struct struct_0 {\n  uint128_t field_0;\n  uint128_t field_10;\n  uint128_t field_20;\n  struct struct_0 *field_30;\n} struct_0;\n\nlong long User_Authonrize_name_conflict(struct_1 *a0, uint128_t a1[4]) {\n  struct_0 *v1;     // rbx, Other Possible Types: unsigned long\n  unsigned long v2; // rax\n\n  User_Login(a1);\n  v1 = a0->field_38;\n  if (!v1)\n    return 4294967295;\n  while (true) {\n    if (!strcmp(a1, v1)) {\n      (unsigned int)v2 = strcmp((char *)&a1[1] + 12, v1 + 28);\n      if (!(unsigned int)v2) {\n        a1[0] = *((int128_t *)v1);\n        a1[1] = *((int128_t *)(v1 + 16));\n        a1[2] = *((int128_t *)(v1 + 32));\n        a1[3] = *((int128_t *)(v1 + 48));\n        return v2;\n      }\n    }\n    v1 = *((long long *)(v1 + 56));\n    if (!v1)\n      return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:28:5: error: unknown type name 'uint128_t'\n   28 |     uint128_t field_0;\n      |     ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:29:5: error: unknown type name 'uint128_t'\n   29 |     uint128_t field_10;\n      |     ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:30:5: error: unknown type name 'uint128_t'\n   30 |     uint128_t field_20;\n      |     ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:34:41: error: unknown type name 'uint128_t'\n   34 | long long User_Authonrize_name_conflict(struct_1 *a0, uint128_t a1[4])\n      |                                         ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:47:13: error: assignment to cast is illegal,\nlvalue casts are not supported 47 |             (unsigned int)v2 = strcmp((char\n*)&a1[1] + 12, v1 + 28); |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:50:38: error: expected expression\n   50 |                 a1[0] = *((int128_t *)v1);\n      |                                      ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:51:38: error: expected expression\n   51 |                 a1[1] = *((int128_t *)(v1 + 16));\n      |                                      ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:52:38: error: expected expression\n   52 |                 a1[2] = *((int128_t *)(v1 + 32));\n      |                                      ^\n/tmp/tmpo79h8n6h/User_Authonrize_name_conflict.c:53:38: error: expected expression\n   53 |                 a1[3] = *((int128_t *)(v1 + 48));\n      |                                      ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/sys.c"}
{"compilable":0,"function":"int getch(void) {\n    struct termios tm, tm_bak;\n    if (tcgetattr(0, &tm) < 0) {\n        perror(\"tcgetattr\");\n        exit(-1);\n    }\n    tm_bak = tm;\n    cfmakeraw(&tm);\n    if (tcsetattr(0, 0, &tm) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    int ch = getchar();\n    if (tcsetattr(0, 0, &tm_bak) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    if (ch == 3 || ch == 4)\n        exit(0);\n    else\n        return ch;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nvoid(perror)(char *);\nvoid(cfmakeraw)(struct termios {\n  unsigned long c_iflag;\n  unsigned long c_oflag;\n  unsigned long c_cflag;\n  unsigned long c_lflag;\n  char c_cc[20];\n  long __ispeed;\n  long __ospeed;\n} *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long getch() {\n  termios v0;            // [bp-0x88]\n  int v1;                // [bp-0x78]\n  int v2;                // [bp-0x68]\n  int v3;                // [bp-0x5c]\n  termios v4;            // [bp-0x48]\n  char v5;               // [bp-0x38]\n  char v6;               // [bp-0x28]\n  int v7;                // [bp-0x1c]\n  unsigned long long v9; // rbx\n\n  if (tcgetattr(0, &v4) < 0) {\n    perror(\"tcgetattr\");\n    exit(-1); /* do not return */\n  }\n  *((int128_t *)&v0.c_iflag) = *((int128_t *)&v4.c_iflag);\n  *((int128_t *)&v1) = *((int128_t *)&v5);\n  *((int128_t *)&v2) = *((int128_t *)&v6);\n  *((int128_t *)&v3) = (int128_t)v7;\n  cfmakeraw(&v4);\n  if (tcsetattr(0, 0, &v4) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1); /* do not return */\n  }\n  v9 = getc(stdin @GLIBC_2.2.5);\n  if (tcsetattr(0, 0, &v0) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1); /* do not return */\n  } else if ((unsigned int)(v9 - 3) > 1) {\n    return v9;\n  } else {\n    exit(0); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6zia56lw/getch.c:30:7: error: conflicting types for 'perror'\n   30 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp6zia56lw/getch.c:63:16: error: nested redefinition of '_IO_marker'\n   63 |         struct _IO_marker {\n      |                ^\n/tmp/tmp6zia56lw/getch.c:62:12: note: previous definition is here\n   62 |     struct _IO_marker {\n      |            ^\n/tmp/tmp6zia56lw/getch.c:106:13: error: declaration of anonymous union must be a\ndefinition 106 |             union <anon> { |             ^\n/tmp/tmp6zia56lw/getch.c:109:22: error: type name requires a specifier or\nqualifier 109 |             } __value; |                      ^\n/tmp/tmp6zia56lw/getch.c:113:13: error: declaration of anonymous union must be a\ndefinition 113 |             union <anon> { |             ^\n/tmp/tmp6zia56lw/getch.c:116:22: error: type name requires a specifier or\nqualifier 116 |             } __value; |                      ^\n/tmp/tmp6zia56lw/getch.c:49:6: error: conflicting types for 'getc'\n   49 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmp6zia56lw/getch.c:155:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 155 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp6zia56lw/getch.c:155:21: error: expected ';' after top level declarator\n  155 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmp6zia56lw/getch.c:174:18: error: expected expression\n  174 |     *((int128_t *)&v0.c_iflag) = *((int128_t *)&v4.c_iflag);\n      |                  ^\n/tmp/tmp6zia56lw/getch.c:174:47: error: expected expression\n  174 |     *((int128_t *)&v0.c_iflag) = *((int128_t *)&v4.c_iflag);\n      |                                               ^\n/tmp/tmp6zia56lw/getch.c:175:18: error: expected expression\n  175 |     *((int128_t *)&v1) = *((int128_t *)&v5);\n      |                  ^\n/tmp/tmp6zia56lw/getch.c:175:39: error: expected expression\n  175 |     *((int128_t *)&v1) = *((int128_t *)&v5);\n      |                                       ^\n/tmp/tmp6zia56lw/getch.c:176:18: error: expected expression\n  176 |     *((int128_t *)&v2) = *((int128_t *)&v6);\n      |                  ^\n/tmp/tmp6zia56lw/getch.c:176:39: error: expected expression\n  176 |     *((int128_t *)&v2) = *((int128_t *)&v6);\n      |                                       ^\n/tmp/tmp6zia56lw/getch.c:177:18: error: expected expression\n  177 |     *((int128_t *)&v3) = (int128_t)v7;\n      |                  ^\n/tmp/tmp6zia56lw/getch.c:184:20: error: expected ')'\n  184 |     v9 = getc(stdin@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmp6zia56lw/getch.c:184:14: note: to match this '('\n  184 |     v9 = getc(stdin@GLIBC_2.2.5);\n      |              ^\n17 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/getch.c"}
{"compilable":0,"function":"int Change_User_Passwd(struct user **list_head, char *key) {\n    struct user *pcur = (*list_head)->next;\n    while (pcur != ((void *)0))\n        {\n            if (!(strcmp(pcur->ID, key) && strcmp(pcur->Name, key))) {\n                char passwd_1[20] = {0};\n                char passwd_2[20] = {0};\n                int i;\n                for (i = 0; i < 3; i++) {\n                    printf(\"New password:\");\n                    scanf(\"%s\", passwd_1);\n                    printf(\"Retype new password:\");\n                    scanf(\"%s\", passwd_2);\n                    if (!strcmp(passwd_1, passwd_2)) {\n                        strcpy(pcur->Key, passwd_1);\n                        puts(\"all authentication tokens updated successfully.\");\n                        break;\n                    } else\n                        puts(\"Sorry, passwords do not match.\");\n                }\n                if (i == 3)\n                    puts(\"Have exhausted maximum number of retries for service\");\n                break;\n            }\n            pcur = pcur->next;\n        }\n    if (pcur == ((void *)0))\n        return -1;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_scanf)(char *, ...);\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  struct struct_0 *field_38;\n} struct_0;\n\nlong long Change_User_Passwd_name_conflict(struct struct_1 **a0, char *a1) {\n  void *v0;        // [bp-0x78]\n  void *v1;        // [bp-0x70]\n  unsigned int v2; // [bp-0x68]\n  void *v3;        // [bp-0x58]\n  void *v4;        // [bp-0x50]\n  unsigned int v5; // [bp-0x48]\n  struct_0 *v7;    // rbx, Other Possible Types: unsigned long\n  unsigned int v8; // ebp\n\n  v7 = *(a0)->field_38;\n  if (!v7)\n    return -(*(a0)->field_38 < 1);\n  while (strcmp(v7, a1) && strcmp(v7 + 12, a1)) {\n    v7 = *((long long *)(v7 + 56));\n    if (!v7)\n      return -(v7 < 1);\n  }\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v8 = 0;\n  while (true) {\n    printf(\"New password:\");\n    __isoc99_scanf(\"%s\", (unsigned int)&v0);\n    printf(\"Retype new password:\");\n    __isoc99_scanf(\"%s\", (unsigned int)&v3);\n    if (!strcmp(&v0, &v3))\n      break;\n    puts(\"Sorry, passwords do not match.\");\n    v8 += 1;\n    if (v8 == 3) {\n      puts(\"Have exhausted maximum number of retries for service\");\n      return -(v7 < 1);\n    }\n  }\n  strcpy(v7 + 28, &v0);\n  puts(\"all authentication tokens updated successfully.\");\n  if (v8 == 3) {\n    puts(\"Have exhausted maximum number of retries for service\");\n    return -(v7 < 1);\n  }\n  return -(v7 < 1);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuixnbh_z/Change_User_Passwd_name_conflict.c:34:15: error: member reference base type\n'struct struct_1 *' is not a structure or union 34 |     v7 = *(a0)->field_38;\n      |           ~~~~^ ~~~~~~~~\n/tmp/tmpuixnbh_z/Change_User_Passwd_name_conflict.c:36:23: error: member reference base type\n'struct struct_1 *' is not a structure or union 36 |         return\n-(*(a0)->field_38 < 1); |                   ~~~~^ ~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/linklist.c"}
{"compilable":1,"function":"const char *memstr(const char *full_data, int full_data_len, const char *substr) {\n    if (full_data == ((void *)0) || full_data_len <= 0 || substr == ((void *)0)) {\n        return ((void *)0);\n    }\n    if (*substr == '\\x00') {\n        return ((void *)0);\n    }\n    int sublen = strlen(substr);\n    int i;\n    const char *cur = full_data;\n    int last_possible = full_data_len - sublen + 1;\n    for (i = 0; i < last_possible; i++) {\n        if (*cur == *substr) {\n            if (memcmp(cur, substr, sublen) == 0) {\n                return cur;\n            }\n        }\n        cur++;\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long memstr_name_conflict(char *a0, unsigned long a1, char *a2) {\n  char *v1;         // rbx, Other Possible Types: unsigned long\n  char v2;          // r13b\n  unsigned long v3; // rax\n\n  if ((unsigned int)a1 > 0 && a2) {\n    v1 = a0;\n    if (a0) {\n      v2 = *(a2);\n      if (!v2)\n        return 0;\n      v3 = strlen(a2);\n      if ((unsigned int)a1 - (unsigned int)v3 < 0)\n        return 0;\n      while (true) {\n        if (v2 == *((char *)v1) && !memcmp(v1, a2, v3))\n          return v1;\n        v1 += 1;\n        if ((unsigned int)a1 - (unsigned int)v3 < 1)\n          return 0;\n      }\n    }\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/qwerty258_HLSDownload_old/utils.c"}
{"compilable":0,"function":"int isdirreducable() {\n    int ndirs = (int)pow(2, directory->globle_depth);\n    for (int i = 0; i < ndirs; ++i) {\n        if (directory->dir_elem_list[i].flag == -1) {\n            if (directory->dir_elem_list[i].bucket->local_depth == directory->globle_depth) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ndouble(pow)(double, double);\n\ntypedef struct struct_0 {\n  struct struct_1 *field_0;\n  unsigned int field_8;\n} struct_0;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n} struct_1;\n\nextern struct_2 *directory;\n\nlong long isdirreducable_name_conflict() {\n  unsigned long v1;      // rbx\n  struct_0 *v2;          // rax, Other Possible Types: unsigned long\n  unsigned long long v3; // rdx\n\n  v1 = directory->field_0;\n  pow(0x4000000000000000, v1);\n  if (true)\n    return 1;\n  v2 = directory->field_8;\n  v3 = v2;\n  while (true) {\n    if (*((int *)(v2 + 8)) == -1 &&\n        (unsigned int)v1 == *((int *)*((long long *)v2)))\n      return 0;\n    v2 += 16;\n    if (v2 == v3)\n      return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpga8s2cwh/isdirreducable_name_conflict.c:27:8: error: unknown type name 'struct_2'\n   27 | extern struct_2 *directory;\n      |        ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/nilesh2014_Extendible-Hashing/hashing.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= 23) {\n        if (buffer_size >= 1) {\n            buffer[0] = value + offset;\n            return 1;\n        }\n    } else {\n        if (buffer_size >= 2) {\n            buffer[0] = 24 + offset;\n            buffer[1] = value;\n            return 2;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint8(unsigned long a0, char a1[2], unsigned long a2,\n                             unsigned long a3) {\n  unsigned long v1; // rax\n\n  if ((char)a0 > 23) {\n    v1 = 0;\n    if (a2 <= 1)\n      return v1;\n    a1[0] = (unsigned int)a3 + 24;\n    a1[1] = a0;\n    v1 = 2;\n  } else if (a2) {\n    a1[0] = (char)a3 + (char)a0;\n    return 1;\n  } else {\n    return a2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 3) {\n        buffer[0] = 25 + offset;\n        buffer[1] = (unsigned char)(value >> 8);\n        buffer[2] = (unsigned char)value;\n        return 3;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint16(unsigned long a0, char a1[3], unsigned long a2,\n                              unsigned long a3) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = 0;\n  if (a2 > 2) {\n    a1[0] = (char)a3 + 25;\n    a1[1] = (char)a0 / 0x100;\n    a1[2] = a0;\n    v1 = 3;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 5) {\n        buffer[0] = 26 + offset;\n        buffer[1] = (unsigned char)(value >> 24);\n        buffer[2] = (unsigned char)(value >> 16);\n        buffer[3] = (unsigned char)(value >> 8);\n        buffer[4] = (unsigned char)value;\n        return 5;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint ah; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint32(unsigned long a0, char a1[5], unsigned long a2,\n                              unsigned long a3) {\n  char v1;          // al\n  unsigned long v3; // rdx, Other Possible Types: unsigned long long\n\n  v1 = a0;\n  v3 = 0;\n  if (a2 > 4) {\n    a1[0] = (char)a3 + 26;\n    a1[1] = v1 / 0x1000000;\n    a1[2] = v1 / 0x10000;\n    *((int *)&a1[3]) = ah<1>;\n    a1[4] = v1;\n    v3 = 5;\n  }\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8kyzmt_h/_cbor_encode_uint32.c:30:33: error: expected expression\n   30 |         *((int *)&a1[3]) = ah<1>;\n      |                                 ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 9) {\n        buffer[0] = 27 + offset;\n        buffer[1] = (unsigned char)(value >> 56);\n        buffer[2] = (unsigned char)(value >> 48);\n        buffer[3] = (unsigned char)(value >> 40);\n        buffer[4] = (unsigned char)(value >> 32);\n        buffer[5] = (unsigned char)(value >> 24);\n        buffer[6] = (unsigned char)(value >> 16);\n        buffer[7] = (unsigned char)(value >> 8);\n        buffer[8] = (unsigned char)value;\n        return 9;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint ah; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_uint64(unsigned long a0, char a1[9], unsigned long a2,\n                              unsigned long a3) {\n  char v1;          // al\n  unsigned long v3; // rdx, Other Possible Types: unsigned long long\n\n  v1 = a0;\n  v3 = 0;\n  if (a2 <= 8)\n    return v3;\n  a1[0] = (char)a3 + 27;\n  a1[1] = v1 / 0x100000000000000;\n  a1[2] = v1 / 0x1000000000000;\n  a1[3] = v1 / 0x10000000000;\n  a1[4] = v1 / 0x100000000;\n  a1[5] = v1 / 0x1000000;\n  a1[6] = v1 / 0x10000;\n  *((int *)&a1[7]) = ah<1>;\n  a1[8] = v1;\n  v3 = 9;\n}\n\nint main_name_conflict(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvf07weqa/_cbor_encode_uint64.c:34:29: error: expected expression\n   34 |     *((int *)&a1[7]) = ah<1>;\n      |                             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= (65535))\n        if (value <= (255))\n            return _cbor_encode_uint8((uint8_t)value, buffer, buffer_size, offset);\n        else\n            return _cbor_encode_uint16((uint16_t)value, buffer, buffer_size, offset);\n    else if (value <= (4294967295U))\n        return _cbor_encode_uint32((uint32_t)value, buffer, buffer_size, offset);\n    else\n        return _cbor_encode_uint64((uint64_t)value, buffer, buffer_size, offset);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\nlong long(_cbor_encode_uint32)(long long, long long, long long, long long);\nlong long(_cbor_encode_uint64)(long long, long long, long long, long long);\n\nlong long _cbor_encode_uint(unsigned long long a0, char a1[3],\n                            unsigned long long a2, unsigned long long a3) {\n  if (a0 > 65535) {\n    if (!a0 >> 32)\n      return _cbor_encode_uint32(a0, a1, a2, a3);\n    return _cbor_encode_uint64(a0, a1, a2, a3);\n  } else {\n    if (a0 <= 255) {\n      return _cbor_encode_uint8(a0, a1, a2, a3);\n    } else if (a2 > 2) {\n      a1[0] = (unsigned int)a3 + 25;\n      a1[1] = (char)a0 / 0x100;\n      a1[2] = a0;\n      return 3;\n    } else {\n      return 0;\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint8(unsigned long long a0, unsigned long long a1,\n                            unsigned long long a2) {\n  return _cbor_encode_uint8(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint16)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint16(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint16(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint32)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint32(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint32(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint64)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint64(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint64(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_uint(unsigned long long a0, unsigned long long a1,\n                           unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 0);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint8(unsigned long long a0, unsigned long long a1,\n                              unsigned long long a2) {\n  return _cbor_encode_uint8(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint16)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint16(unsigned long long a0, unsigned long long a1,\n                               unsigned long long a2) {\n  return _cbor_encode_uint16(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint32)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint32(unsigned long long a0, unsigned long long a1,\n                               unsigned long long a2) {\n  return _cbor_encode_uint32(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint64)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint64(unsigned long long a0, unsigned long long a1,\n                               unsigned long long a2) {\n  return _cbor_encode_uint64(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 32);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_negint(unsigned long long a0, unsigned long long a1,\n                             unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 32);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bytestring_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 64);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_bytestring_start(unsigned long long a0,\n                                       unsigned long long a1,\n                                       unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 64);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t _cbor_encode_byte(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    if (buffer_size >= 1) {\n        buffer[0] = value;\n        return 1;\n    } else\n        return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _cbor_encode_byte_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a2;\n  if (a2) {\n    *(a1) = a0;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_bytestring_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(95, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_indef_bytestring_start_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 95;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_string_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 96);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_string_start(unsigned long long a0, unsigned long long a1,\n                                   unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 96);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_string_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(127, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_indef_string_start_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 127;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_array_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 128);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_array_start(unsigned long long a0, unsigned long long a1,\n                                  unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 128);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_array_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(159, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_indef_array_start_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 159;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_map_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 160);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_map_start(unsigned long long a0, unsigned long long a1,\n                                unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 160);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_map_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(191, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_indef_map_start_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 191;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_tag(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 192);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint)(long long, long long, long long, long long);\n\nlong long cbor_encode_tag(unsigned long long a0, unsigned long long a1,\n                          unsigned long long a2) {\n  return _cbor_encode_uint(a0, a1, a2, 192);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bool(bool value, unsigned char *buffer, size_t buffer_size) {\n    return value ? _cbor_encode_byte(245, buffer, buffer_size) : _cbor_encode_byte(244, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_bool_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a2;\n  if (!(char)a0) {\n    if (!a2)\n      return v1;\n    *(a1) = 244;\n    v1 = 1;\n  } else if (a2) {\n    *(a1) = 245;\n    return 1;\n  } else {\n    return a2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_null(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(246, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_null_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 246;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_undef(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(247, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_undef_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 247;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_break(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(255, buffer, buffer_size);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long cbor_encode_break_name_conflict(char *a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a1;\n  if (a1) {\n    *(a0) = 255;\n    v1 = 1;\n  }\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_ctrl(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 224);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_cbor_encode_uint8)(long long, long long, long long, long long);\n\nlong long cbor_encode_ctrl(unsigned long long a0, unsigned long long a1,\n                           unsigned long long a2) {\n  return _cbor_encode_uint8(a0, a1, a2, 224);\n}\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfpgetkj1/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":1,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpme1yel81/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpme1yel81/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpme1yel81/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpme1yel81/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpme1yel81/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpme1yel81/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpme1yel81/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpme1yel81/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpme1yel81/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpme1yel81/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpme1yel81/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpme1yel81/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpme1yel81/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpme1yel81/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpme1yel81/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpme1yel81/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpme1yel81/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpme1yel81/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpme1yel81/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpme1yel81/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpme1yel81/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpme1yel81/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9xmb4_db/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpu_85yllz/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpu_85yllz/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpu_85yllz/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpu_85yllz/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpu_85yllz/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpu_85yllz/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpu_85yllz/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpepzr6rpj/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa3pavtxg/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpa3pavtxg/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpa3pavtxg/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpa3pavtxg/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpa3pavtxg/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpa3pavtxg/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpa3pavtxg/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj30wh6bw/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptr06uop0/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmptr06uop0/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmptr06uop0/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmptr06uop0/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmptr06uop0/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmptr06uop0/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmptr06uop0/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmptr06uop0/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmptr06uop0/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmptr06uop0/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmptr06uop0/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmptr06uop0/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmptr06uop0/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmptr06uop0/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmptr06uop0/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmptr06uop0/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmptr06uop0/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmptr06uop0/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmptr06uop0/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmptr06uop0/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmptr06uop0/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmptr06uop0/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int work(long loop_count) {\n    while (loop_count-- > 0)\n        {\n            syslog(6, \"loglog\");\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(syslog)(int, char *, ...);\n\nlong long work_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v1;      // [bp-0x8]\n  unsigned long v3;      // rbx\n  unsigned long v4;      // rbx, Other Possible Types: unsigned long long\n  unsigned long long v5; // rbx\n\n  if (a0 <= 0)\n    return 0;\n  *((int *)&v1) = rbp;\n  v0 = v3;\n  v4 = a0 - 1;\n  do {\n    syslog(6, \"loglog\");\n    v4 -= 1;\n  } while (v4 != -1);\n  v5 = v0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":0,"function":"int test(long process_count, long loop_count) {\n    long i;\n    pid_t pid;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            work(loop_count);\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nlong long(work)(long long);\nint(wait)(int *);\n\nlong long test_name_conflict(unsigned long a0, unsigned long long a1) {\n  unsigned long v0;       // [bp-0x20]\n  unsigned long v1;       // [bp-0x18]\n  unsigned long v2;       // [bp-0x10]\n  unsigned long v3;       // [bp-0x8]\n  unsigned long v5;       // r13\n  unsigned long v6;       // r12\n  unsigned long v7;       // rbx\n  void *v8;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n  void *v11;              // rbp, Other Possible Types: unsigned long\n\n  if (a0 <= 0)\n    return 0;\n  v3 = v5;\n  v2 = v6;\n  *((int *)&v1) = rbp;\n  v0 = v7;\n  v8 = 0;\n  while (true) {\n    (unsigned int)v9 = fork();\n    if ((unsigned int)v9 < 0) {\n      puts(\"fork fail\");\n    } else if (!(unsigned int)v9) {\n      work(a1);\n      break;\n    }\n    if (a0 != v8) {\n      v8 += 1;\n    } else {\n      v11 = 0;\n      do {\n        wait(NULL);\n        v10 = v11;\n        v11 += 1;\n      } while (v8 != v10);\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp79933ccs/test_name_conflict.c:44:9: error: assignment to cast is illegal, lvalue casts\nare not supported 44 |         (unsigned int)v9 = fork(); | ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpd__osxhb/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpt_sknmec/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpt_sknmec/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpt_sknmec/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpt_sknmec/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpt_sknmec/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpt_sknmec/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpt_sknmec/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmfmqik82/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyepudpqw/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpyepudpqw/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpyepudpqw/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpyepudpqw/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpyepudpqw/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpyepudpqw/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpyepudpqw/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphzyek0a9/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwc4ya6io/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpwc4ya6io/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpwc4ya6io/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpwc4ya6io/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpwc4ya6io/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpwc4ya6io/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpwc4ya6io/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprpzy7o1t/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpypy_311a/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpypy_311a/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpypy_311a/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpypy_311a/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpypy_311a/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpypy_311a/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpypy_311a/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpypy_311a/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpypy_311a/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpypy_311a/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpypy_311a/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpypy_311a/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpypy_311a/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpypy_311a/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpypy_311a/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpypy_311a/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpypy_311a/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpypy_311a/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpypy_311a/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpypy_311a/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpypy_311a/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpypy_311a/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, (void *)j);\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint work; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nchar *(pthread_create)(char *, char *, char *, char *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                 // [bp-0x48]\n  struct_0 *v1;            // [bp-0x40]\n  unsigned long v2;        // [bp-0x30]\n  unsigned long v3;        // [bp-0x28]\n  unsigned long v4;        // [bp-0x20]\n  unsigned long v5;        // [bp-0x18]\n  unsigned long v6;        // [bp-0x10]\n  unsigned long v7;        // [bp-0x8]\n  char v8;                 // [bp+0x0]\n  unsigned long v9;        // [bp+0x8]\n  unsigned long v10;       // r15\n  unsigned long v11;       // r14\n  unsigned long v12;       // r13\n  unsigned long v13;       // r12\n  unsigned long v14;       // rbx\n  void *v15;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v16;  // rax\n  void *v17;               // r12, Other Possible Types: unsigned long\n  char *v18;               // r12, Other Possible Types: unsigned long\n  void *v19;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v20;  // rax\n  unsigned long long v21;  // r14\n  unsigned long long *v22; // rbx, Other Possible Types: unsigned long\n  unsigned long long *v23; // rax\n\n  if (a0 <= 0)\n    return 0;\n  v7 = &v8;\n  v6 = v10;\n  v5 = v11;\n  v4 = v12;\n  v3 = v13;\n  v2 = v14;\n  v15 = 0;\n  while (true) {\n    (unsigned int)v16 = fork();\n    if ((unsigned int)v16 < 0) {\n      puts(\"fork fail\");\n    } else if (!(unsigned int)v16) {\n      v1 = &v0;\n      if (a1 > 0) {\n        v18 = &v8;\n        v19 = 0;\n        do {\n          pthread_create(v18, NULL, work, v19);\n          v21 = v19;\n          v19 += 1;\n          v18 = &v9;\n        } while (a1 != v19);\n        v22 = 0;\n        do {\n          pthread_join(\n              *((long long *)&(&v0)[8 * v22 + -1 * (a1 * 8 + 15 & -0x10)]), 0);\n          v23 = v22;\n          v22 += 1;\n        } while (v21 != v23);\n      }\n      break;\n    }\n    if (a0 != v15) {\n      v15 += 1;\n    } else {\n      v17 = 0;\n      do {\n        wait(NULL);\n        v20 = v17;\n        v17 += 1;\n      } while (v15 != v20);\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo1d8mn88/test_name_conflict.c:63:9: error: assignment to cast is illegal, lvalue casts\nare not supported 63 |         (unsigned int)v16 = fork(); | ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpo1d8mn88/test_name_conflict.c:85:58: error: invalid operands to binary expression\n('int' and 'unsigned long long *') 85 |                     pthread_join(*((long\nlong *)&(&v0)[8 * v22 + -1 * (a1 * 8 + 15 & -0x10)]), 0); | ~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write2.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvj_z7orb/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwbs6ggii/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpwbs6ggii/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpwbs6ggii/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpwbs6ggii/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpwbs6ggii/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpwbs6ggii/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpwbs6ggii/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint work; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nchar *(pthread_create)(char *, char *, char *, char *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                 // [bp-0x48]\n  struct_0 *v1;            // [bp-0x40]\n  unsigned long v2;        // [bp-0x30]\n  unsigned long v3;        // [bp-0x28]\n  unsigned long v4;        // [bp-0x20]\n  unsigned long v5;        // [bp-0x18]\n  unsigned long v6;        // [bp-0x10]\n  unsigned long v7;        // [bp-0x8]\n  char v8;                 // [bp+0x0]\n  unsigned long v9;        // [bp+0x8]\n  unsigned long v10;       // r15\n  unsigned long v11;       // r14\n  unsigned long v12;       // r13\n  unsigned long v13;       // r12\n  unsigned long v14;       // rbx\n  void *v15;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v16;  // rax\n  void *v17;               // r12, Other Possible Types: unsigned long\n  char *v18;               // r12, Other Possible Types: unsigned long\n  void *v19;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v20;  // rax\n  unsigned long long v21;  // r14\n  unsigned long long *v22; // rbx, Other Possible Types: unsigned long\n  unsigned long long *v23; // rax\n\n  if (a0 <= 0)\n    return 0;\n  v7 = &v8;\n  v6 = v10;\n  v5 = v11;\n  v4 = v12;\n  v3 = v13;\n  v2 = v14;\n  v15 = 0;\n  while (true) {\n    (unsigned int)v16 = fork();\n    if ((unsigned int)v16 < 0) {\n      puts(\"fork fail\");\n    } else if (!(unsigned int)v16) {\n      v1 = &v0;\n      if (a1 > 0) {\n        v18 = &v8;\n        v19 = 0;\n        do {\n          pthread_create(v18, NULL, work, NULL);\n          v21 = v19;\n          v19 += 1;\n          v18 = &v9;\n        } while (a1 != v19);\n        v22 = 0;\n        do {\n          pthread_join(\n              *((long long *)&(&v0)[8 * v22 + -1 * (a1 * 8 + 15 & -0x10)]), 0);\n          v23 = v22;\n          v22 += 1;\n        } while (v21 != v23);\n      }\n      break;\n    }\n    if (a0 != v15) {\n      v15 += 1;\n    } else {\n      v17 = 0;\n      do {\n        wait(NULL);\n        v20 = v17;\n        v17 += 1;\n      } while (v15 != v20);\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmphrbf519g/test_name_conflict.c:63:9: error: assignment to cast is illegal, lvalue casts\nare not supported 63 |         (unsigned int)v16 = fork(); | ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmphrbf519g/test_name_conflict.c:85:58: error: invalid operands to binary expression\n('int' and 'unsigned long long *') 85 |                     pthread_join(*((long\nlong *)&(&v0)[8 * v22 + -1 * (a1 * 8 + 15 & -0x10)]), 0); | ~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_zlog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6awo0r3f/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp8t1yv8s5/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5d4xvoy1/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_f0sul10/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmp_f0sul10/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmp_f0sul10/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmp_f0sul10/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmp_f0sul10/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmp_f0sul10/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmp_f0sul10/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdtrxsvmh/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpihi61rjd/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpihi61rjd/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpihi61rjd/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpihi61rjd/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpihi61rjd/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpihi61rjd/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpihi61rjd/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long sgets_name_conflict(unsigned long a0, char *a1, struct struct_0 **a2) {\n  char *v1; // rbp, Other Possible Types: unsigned long\n  char *v2; // rbx, Other Possible Types: unsigned long\n  char *v3; // rax, Other Possible Types: unsigned long\n  char *v4; // rax\n  char *v5; // r14\n\n  v1 = *(a2);\n  if (!v1)\n    return v1;\n  v2 = a1;\n  v3 = strchr(v1, 10);\n  if (!v3) {\n    if (*(v1))\n      v3 = &v1[strlen(v1)];\n    else\n      return v3;\n  }\n  v4 = 1 + v3 - v1;\n  if ((unsigned int)a1 < (unsigned int)a1)\n    v2 = v4;\n  memcpy(a0, v1, v2);\n  *((char *)(a0 + v2)) = 0;\n  v5 = *(a2);\n  if (strlen(v5) == strlen(a0)) {\n    *(a2) = 0;\n    return a0;\n  }\n  *(a2) = &v5[v2];\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa9yrvebg/sgets_name_conflict.c:48:16: error: array subscript is not an integer\n   48 |     *(a2) = &v5[v2];\n      |                ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_file_cmp_name_conflict(unsigned int *a0, unsigned int *a1) {\n  return *(a1) < *(a0);\n}\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long zlog_version_name_conflict() { return \"1.2.12\"; }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nstruct FILE_t *(fopen64)(char *, char *);\nint(vfprintf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, struct va_list[1]);\nlong long(zc_time)(long long, long long);\nint(fputc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char *debug_log.1;\nextern char *error_log.0;\nextern unsigned long long init_flag.2;\n\nlong long zc_profile_inner(unsigned long a0, unsigned long a1, unsigned long a2,\n                           char *a3) {\n  char v0;           // [bp-0x108]\n  unsigned int v1;   // [bp-0xf0]\n  unsigned int v2;   // [bp-0xec]\n  unsigned long v3;  // [bp-0xe8]\n  unsigned long v4;  // [bp-0xe0]\n  char v5;           // [bp-0xd8]\n  unsigned long v6;  // [bp-0xb8]\n  unsigned long v7;  // [bp-0xb0]\n  int v8;            // [bp-0xa8]\n  int v9;            // [bp-0x98]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  unsigned long v16; // [bp+0x8]\n  unsigned long v17; // r8\n  unsigned long v18; // r9\n  char v19;          // al\n  int v20;           // xmm0\n  int v21;           // xmm1\n  int v22;           // xmm2\n  int v23;           // xmm3\n  int v24;           // xmm4\n  int v25;           // xmm5\n  int v26;           // xmm6\n  int v27;           // xmm7\n  void *v29;         // rbp, Other Possible Types: unsigned long\n\n  v6 = v17;\n  v7 = v18;\n  if (v19) {\n    v8 = v20;\n    v9 = v21;\n    v10 = v22;\n    v11 = v23;\n    v12 = v24;\n    v13 = v25;\n    v14 = v26;\n    v15 = v27;\n  }\n  if (!init_flag.2) {\n    init_flag.2 = 1;\n    debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log.0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n  if ((unsigned int)a0 == 1) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s WARN  (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else if ((unsigned int)a0 == 2) {\n    if (!error_log.0)\n      return 0;\n    v29 = fopen64(error_log.0, \"a\");\n    if (!v29)\n      return 4294967295;\n    zc_time(&v0, 21);\n    fprintf(v29, \"%s ERROR (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n            (unsigned int)a1, (unsigned int)a2);\n  } else {\n    v29 = 0;\n    if (!(unsigned int)a0) {\n      if (!debug_log.1)\n        return a0;\n      v29 = fopen64(debug_log.1, \"a\");\n      if (!v29)\n        return 4294967295;\n      zc_time(&v0, 21);\n      fprintf(v29, \"%s DEBUG (%d:%s:%ld) \", (unsigned int)&v0, getpid(),\n              (unsigned int)a1, (unsigned int)a2);\n    }\n  }\n  v1 = 32;\n  v2 = 48;\n  v3 = &v16;\n  v4 = &v5;\n  vfprintf(v29, a3, &v1);\n  fputc(10, v29);\n  fclose(v29);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbvejlzvz/zc_profile_inner.c:32:16: error: nested redefinition of\n'_IO_marker' 32 |         struct _IO_marker { |                ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:31:12: note: previous definition is here\n   31 |     struct _IO_marker {\n      |            ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:75:13: error: declaration of anonymous union\nmust be a definition 75 |             union <anon> { |             ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:78:22: error: type name requires a specifier\nor qualifier 78 |             } __value; |                      ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:82:13: error: declaration of anonymous union\nmust be a definition 82 |             union <anon> { |             ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:85:22: error: type name requires a specifier\nor qualifier 85 |             } __value; |                      ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:106:28: error: array has incomplete element\ntype 'struct va_list' 106 | } *, char *, struct va_list[1]); | ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:106:21: note: forward declaration of 'struct\nva_list' 106 | } *, char *, struct va_list[1]); |                     ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:165:13: error: declaration of anonymous\nunion must be a definition 165 |             union <anon> { |             ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:168:22: error: type name requires a\nspecifier or qualifier 168 |             } __value; |                      ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:172:13: error: declaration of anonymous\nunion must be a definition 172 |             union <anon> { |             ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:175:22: error: type name requires a\nspecifier or qualifier 175 |             } __value; |                      ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:108:6: error: conflicting types for 'fputc'\n  108 | int (fputc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:549:12: note: previous declaration is here\n  549 | extern int fputc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:198:23: error: expected ';' after top level\ndeclarator 198 | extern char *debug_log.1; |                       ^ | ;\n/tmp/tmpbvejlzvz/zc_profile_inner.c:199:23: error: expected ';' after top level\ndeclarator 199 | extern char *error_log.0; |                       ^ | ;\n/tmp/tmpbvejlzvz/zc_profile_inner.c:200:36: error: expected ';' after top level\ndeclarator 200 | extern unsigned long long init_flag.2; | ^ | ;\n/tmp/tmpbvejlzvz/zc_profile_inner.c:247:19: error: expected ')'\n  247 |     if (!init_flag.2)\n      |                   ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:247:8: note: to match this '('\n  247 |     if (!init_flag.2)\n      |        ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:249:18: error: expected ';' after expression\n  249 |         init_flag.2 = 1;\n      |                  ^\n      |                  ;\n/tmp/tmpbvejlzvz/zc_profile_inner.c:249:21: error: expression is not assignable\n  249 |         init_flag.2 = 1;\n      |                  ~~ ^\n/tmp/tmpbvejlzvz/zc_profile_inner.c:250:18: error: expected ';' after expression\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ^\n      |                  ;\n/tmp/tmpbvejlzvz/zc_profile_inner.c:250:21: error: expression is not assignable\n  250 |         debug_log.1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n      |                  ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint work; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(wait)(int *);\nchar *(pthread_create)(char *, char *, char *, char *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long test_name_conflict(unsigned long a0, unsigned long a1) {\n  char v0;                 // [bp-0x48]\n  struct_0 *v1;            // [bp-0x40]\n  unsigned long v2;        // [bp-0x30]\n  unsigned long v3;        // [bp-0x28]\n  unsigned long v4;        // [bp-0x20]\n  unsigned long v5;        // [bp-0x18]\n  unsigned long v6;        // [bp-0x10]\n  unsigned long v7;        // [bp-0x8]\n  char v8;                 // [bp+0x0]\n  unsigned long v9;        // [bp+0x8]\n  unsigned long v10;       // r15\n  unsigned long v11;       // r14\n  unsigned long v12;       // r13\n  unsigned long v13;       // r12\n  unsigned long v14;       // rbx\n  void *v15;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v16;  // rax\n  void *v17;               // r12, Other Possible Types: unsigned long\n  char *v18;               // r12, Other Possible Types: unsigned long\n  void *v19;               // rbx, Other Possible Types: unsigned long\n  unsigned long long v20;  // rax\n  unsigned long long v21;  // r14\n  unsigned long long *v22; // rbx, Other Possible Types: unsigned long\n  unsigned long long *v23; // rax\n\n  if (a0 <= 0)\n    return 0;\n  v7 = &v8;\n  v6 = v10;\n  v5 = v11;\n  v4 = v12;\n  v3 = v13;\n  v2 = v14;\n  v15 = 0;\n  while (true) {\n    (unsigned int)v16 = fork();\n    if ((unsigned int)v16 < 0) {\n      puts(\"fork fail\");\n    } else if (!(unsigned int)v16) {\n      v1 = &v0;\n      if (a1 > 0) {\n        v18 = &v8;\n        v19 = 0;\n        do {\n          pthread_create(v18, NULL, work, NULL);\n          v21 = v19;\n          v19 += 1;\n          v18 = &v9;\n        } while (a1 != v19);\n        v22 = 0;\n        do {\n          pthread_join(\n              *((long long *)&(&v0)[8 * v22 + -1 * (a1 * 8 + 15 & -0x10)]), 0);\n          v23 = v22;\n          v22 += 1;\n        } while (v21 != v23);\n      }\n      break;\n    }\n    if (a0 != v15) {\n      v15 += 1;\n    } else {\n      v17 = 0;\n      do {\n        wait(NULL);\n        v20 = v17;\n        v17 += 1;\n      } while (v15 != v20);\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptwns25ut/test_name_conflict.c:63:9: error: assignment to cast is illegal, lvalue casts\nare not supported 63 |         (unsigned int)v16 = fork(); | ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmptwns25ut/test_name_conflict.c:85:58: error: invalid operands to binary expression\n('int' and 'unsigned long long *') 85 |                     pthread_join(*((long\nlong *)&(&v0)[8 * v22 + -1 * (a1 * 8 + 15 & -0x10)]), 0); | ~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .3;\nextern unsigned int arp_sock;\nextern unsigned short buf.4;\nextern unsigned int foreground;\nextern unsigned short g_404502;\nextern char g_404504;\nextern char g_404505;\nextern unsigned short g_404506;\nextern unsigned int g_404508;\nextern unsigned short g_40450c;\nextern char g_40450e;\nextern unsigned int g_404512;\nextern unsigned short g_404516;\nextern char g_404518;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_garp(unsigned long a0, unsigned long a1, struct_0 *a2,\n                    unsigned long a3, struct_0 *a4) {\n  timeval v0;        // [bp-0x38]\n  char v1;           // [bp-0x30]\n  sockaddr v2;       // [bp-0x28]\n  unsigned short v3; // [bp-0x26]\n  unsigned int v4;   // [bp-0x24]\n  char v5;           // [bp-0x1d]\n  unsigned int v6;   // [bp-0x1c]\n  unsigned short v7; // [bp-0x18], Other Possible Types: unsigned int\n\n  buf.4 = 0x100;\n  g_404502 = 8;\n  g_404504 = 6;\n  g_404505 = 4;\n  g_404506 = 0x200;\n  g_404508 = a2->field_0;\n  g_40450c = a2->field_4;\n  *((unsigned int *)&g_40450e) = a1;\n  g_404512 = a4->field_0;\n  g_404516 = a4->field_4;\n  *((unsigned int *)&g_404518) = a3;\n  *((int128_t *)&v2.sin_family) = 0;\n  v7 = 0;\n  v3 = 1544;\n  v4 = a0;\n  v5 = 6;\n  v6 = -1;\n  v7 = 65535;\n  if (sendto(arp_sock, &buf.4, 28, 0, &v2, 20) >= 0) {\n    return 0;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .3, (unsigned int)a0,\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpc1z73gtd/send_garp.c:47:13: error: expected identifier or '('\n   47 | extern char __func__.3;\n      |             ^\n/tmp/tmpc1z73gtd/send_garp.c:49:26: error: expected ';' after top level\ndeclarator 49 | extern unsigned short buf.4; |                          ^ | ;\n/tmp/tmpc1z73gtd/send_garp.c:61:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 61 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpc1z73gtd/send_garp.c:61:22: error: expected ';' after top level\ndeclarator 61 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpc1z73gtd/send_garp.c:74:8: error: expected ';' after expression\n   74 |     buf.4 = 0x100;\n      |        ^\n      |        ;\n/tmp/tmpc1z73gtd/send_garp.c:74:11: error: expression is not assignable\n   74 |     buf.4 = 0x100;\n      |        ~~ ^\n/tmp/tmpc1z73gtd/send_garp.c:85:18: error: expected expression\n   85 |     *((int128_t *)&v2.sin_family) = 0;\n      |                  ^\n/tmp/tmpc1z73gtd/send_garp.c:92:30: error: expected ')'\n   92 |     if (sendto(arp_sock, &buf.4, 28, 0, &v2, 20) >= 0)\n      |                              ^\n/tmp/tmpc1z73gtd/send_garp.c:92:15: note: to match this '('\n   92 |     if (sendto(arp_sock, &buf.4, 28, 0, &v2, 20) >= 0)\n      |               ^\n/tmp/tmpc1z73gtd/send_garp.c:99:23: error: expected ')'\n   99 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpc1z73gtd/send_garp.c:99:16: note: to match this '('\n   99 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpc1z73gtd/send_garp.c:104:18: error: indirection requires pointer operand\n('int' invalid) 104 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\nextern char __func__ .1;\nextern unsigned int arp_sock;\nextern void buf.2;\nextern unsigned int foreground;\nextern unsigned short g_404102;\nextern char g_404104;\nextern char g_404105;\nextern unsigned short g_404106;\nextern unsigned int g_404108;\nextern unsigned short g_40410c;\nextern unsigned int g_40410e;\nextern unsigned int g_404112;\nextern unsigned short g_404116;\nextern unsigned int g_404118;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_arp(unsigned int *a0, unsigned short *a1, unsigned short *a2,\n                   unsigned int *a3, struct_0 *a4, unsigned int *a5,\n                   struct_0 *v6) {\n  timeval v0;            // [bp-0x78]\n  char v1;               // [bp-0x70]\n  unsigned int v2;       // [bp-0x5c]\n  sockaddr v3;           // [bp-0x58]\n  char v4;               // [bp-0x54]\n  char v5;               // [bp-0x4e]\n  unsigned long long v7; // rax\n  struct_0 *v9;          // rbx\n\n  v2 = 20;\n  (unsigned int)v7 = recvfrom(arp_sock, &buf.2, 0x400, 64, &v3, &v2);\n  if ((unsigned int)v7 >= 0) {\n    if ((unsigned int)v7 > 27 && !(g_404106 - 0x100 & 65279) && g_404105 == 4 &&\n        g_404102 == 8 && g_404104 == 6) {\n      *(a0) = *((int *)&v4);\n      *(a1) = v5;\n      *(a2) = __ROL__(g_404106, 8);\n      a4->field_0 = g_404108;\n      a4->field_4 = g_40410c;\n      *(a3) = g_40410e;\n      v9 = v6;\n      v9->field_0 = g_404112;\n      v9->field_4 = g_404116;\n      *(a5) = g_404118;\n      return 0;\n    }\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\");\n      return 4294967295;\n    }\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid message\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .1);\n    return 4294967295;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .1, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpddry8sw9/recv_arp.c:46:13: error: expected identifier or '('\n   46 | extern char __func__.1;\n      |             ^\n/tmp/tmpddry8sw9/recv_arp.c:48:16: error: expected ';' after top level\ndeclarator 48 | extern void buf.2; |                ^ |                ;\n/tmp/tmpddry8sw9/recv_arp.c:60:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 60 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpddry8sw9/recv_arp.c:60:22: error: expected ';' after top level\ndeclarator 60 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpddry8sw9/recv_arp.c:74:47: error: expected ')'\n   74 |     (unsigned int)v7 = recvfrom(arp_sock, &buf.2, 0x400, 64, &v3, &v2);\n      |                                               ^\n/tmp/tmpddry8sw9/recv_arp.c:74:32: note: to match this '('\n   74 |     (unsigned int)v7 = recvfrom(arp_sock, &buf.2, 0x400, 64, &v3, &v2);\n      |                                ^\n/tmp/tmpddry8sw9/recv_arp.c:97:23: error: expected ')'\n   97 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nmessage\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                       ^ /tmp/tmpddry8sw9/recv_arp.c:97:16: note:\nto match this '(' 97 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid message\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.1); |                ^ /tmp/tmpddry8sw9/recv_arp.c:103:23:\nerror: expected ')' 103 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: recvfrom %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpddry8sw9/recv_arp.c:103:16: note: to match this '('\n  103 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1,\n(unsigned int)strerror(*(__errno_location()))); |                ^\n/tmp/tmpddry8sw9/recv_arp.c:108:18: error: indirection requires pointer operand\n('int' invalid) 108 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int arp_sock;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_arp_name_conflict() {\n  timeval v0;       // [bp-0x18]\n  char v1;          // [bp-0x10]\n  unsigned long v3; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v3 = socket(17, 2, 1544);\n  arp_sock = v3;\n  if ((unsigned int)v3 >= 0) {\n    return v3;\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4rtiqk_c/open_arp_name_conflict.c:33:13: error: expected identifier or '('\n   33 | extern char __func__.0;\n      |             ^\n/tmp/tmp4rtiqk_c/open_arp_name_conflict.c:36:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 36 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp4rtiqk_c/open_arp_name_conflict.c:36:22: error: expected ';' after top level\ndeclarator 36 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp4rtiqk_c/open_arp_name_conflict.c:44:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 44 |     (unsigned int)v3 = socket(17, 2, 1544); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmp4rtiqk_c/open_arp_name_conflict.c:52:18: error: indirection\nrequires pointer operand ('int' invalid) 52 | strerror(*(__errno_location()));\n      |                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4rtiqk_c/open_arp_name_conflict.c:59:23: error: expected ')'\n   59 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmp4rtiqk_c/open_arp_name_conflict.c:59:16: note: to match this '('\n   59 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                ^ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\nvoid(syslog)(int, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nint(socket)(int, int, int);\nchar *(strerror)(int);\nint(setsockopt)(int, int, int, void *, int);\nint(close)(int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(update_mpgw)(long long, long long);\nvoid(srandom)(unsigned int);\n\ntypedef struct struct_0 {\n  uint128_t field_0;\n  uint128_t field_10;\n  uint128_t field_20;\n  uint128_t field_30;\n  unsigned long long field_40;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_1;\n\nextern char __func__ .0;\nextern char __func__ .1;\nextern char buf.2;\nextern unsigned int foreground;\nextern unsigned int mpgws[8];\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long add_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x9c]\n  unsigned short v1;      // [bp-0x98]\n  unsigned short v2;      // [bp-0x96]\n  unsigned int v3;        // [bp-0x94]\n  void *v4;               // [bp-0x90]\n  timeval v5;             // [bp-0x88]\n  char v6;                // [bp-0x80]\n  char v7;                // [bp-0x78]\n  char v8;                // [bp-0x70]\n  int v9;                 // [bp-0x68], Other Possible Types: unsigned int\n  void *v10;              // [bp-0x58]\n  char v11;               // [bp-0x48]\n  char v12;               // [bp-0x40]\n  unsigned int v15[8];    // rax, Other Possible Types: unsigned long\n  unsigned long v16;      // rbx\n  unsigned int v17[8];    // rdx, Other Possible Types: unsigned long\n  unsigned long v18;      // r13\n  unsigned int v19[8];    // rax\n  unsigned long long v20; // r14\n  unsigned long v21;      // rsi\n  unsigned int v22;       // ebp\n  struct_1 *v23;          // rax\n  unsigned int v24[8];    // r12\n  unsigned long long v26; // rcx\n  unsigned long long v27; // rax\n  unsigned long long v28; // rdx\n  unsigned long long v29; // r12\n\n  v15 = &mpgws[0];\n  v16 = 4294967295;\n  v17 = 0;\n  do {\n    if (!*((int *)(v15 + 28))) {\n      if ((unsigned int)v16 == -1)\n        v16 = v17;\n    } else {\n      if (*((int *)v15) == (unsigned int)a0 &&\n          *((int *)(v15 + 24)) == (unsigned int)a1)\n        return &mpgws[18 * v17];\n    }\n  } while ((v17 = (unsigned long long)((unsigned int)v17 + 1), v15 += 72,\n            (unsigned int)v17 != 32));\n  if ((unsigned int)v16 != -1) {\n    if ((unsigned int)clock_gettime(0x1, &v11) >= 0) {\n      v19 = v16 * 8;\n      v20 = ((char *)v19 + v16) * 8;\n      v18 = (char *)&mpgws[0] + v20;\n      *((int128_t *)v18) = 0;\n      *((int128_t *)(v18 + 16)) = 0;\n      *((int128_t *)(v18 + 32)) = 0;\n      *((int128_t *)(v18 + 48)) = 0;\n      *((long long *)(v18 + 64)) = 0;\n      v21 = (char *)v19 + v16;\n      mpgws[2 * v21] = a0;\n      mpgws[6 + 2 * v21] = a1;\n      v22 = socket(2, 2, 0);\n      if (v22 < 0) {\n        if (foreground) {\n          gettimeofday(&v7, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket sock %s\\n\",\n                  (int)*((long long *)&v7), (int)*((long long *)&v8),\n                  &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n        } else {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\");\n        }\n        return 0;\n      } else {\n        *((int128_t *)&v7) = 0;\n        *((int128_t *)&v9) = 0;\n        v10 = 0;\n        v9 = mpgws[6 + 18 * v16];\n        if (ioctl(v22, 35088)) {\n          if (foreground) {\n            gettimeofday(&v5, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\",\n                    (int)*((long long *)&v5.tv_sec), (int)*((long long *)&v6),\n                    &__func__ .0, mpgws[6 + 18 * v16],\n                    (unsigned int)strerror(*(__errno_location())));\n          } else {\n            strerror(*(__errno_location()));\n            syslog(\n                3,\n                \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\");\n          }\n        } else {\n          if (ioctl(v22, 35111)) {\n            if (foreground) {\n              gettimeofday(&v5, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\",\n                      (int)*((long long *)&v5.tv_sec), (int)*((long long *)&v6),\n                      &__func__ .0, (unsigned int)&v7,\n                      (unsigned int)strerror(*(__errno_location())));\n            } else {\n              strerror(*(__errno_location()));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR \"\n                        \"%s %s\\\"}\");\n            }\n          } else {\n            if ((short)v9 != 1) {\n              if (!foreground) {\n                syslog(\n                    3,\n                    \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\");\n              } else {\n                gettimeofday(&v5, NULL);\n                fprintf(stderr @GLIBC_2.2.5,\n                        \"%ld.%06ld [error] %s: invalid if %s\\n\",\n                        (int)*((long long *)&v5.tv_sec),\n                        (int)*((long long *)&v6), &__func__ .0,\n                        (unsigned int)&v7);\n              }\n            } else {\n              if (setsockopt(v22, 1, 25, &v7, (unsigned int)strlen(&v7) + 1) <\n                  0) {\n                if (!foreground) {\n                  strerror(*(__errno_location()));\n                  syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt \"\n                            \"%s %s\\\"}\");\n                } else {\n                  gettimeofday(&v5, NULL);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"%ld.%06ld [error] %s: setsockopt %s %s\\n\",\n                          (int)*((long long *)&v5.tv_sec),\n                          (int)*((long long *)&v6), &__func__ .0,\n                          (unsigned int)&v7,\n                          (unsigned int)strerror(*(__errno_location())));\n                }\n              } else {\n                v4 = 0;\n                v1 = 2;\n                v2 = 260;\n                v3 = mpgws[18 * v16];\n                if (connect(v22, &v1, 16) < 0) {\n                  if (foreground) {\n                    gettimeofday(&v5, NULL);\n                    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", mpgws[18 * v16],\n                             mpgws[18 * v16] >> 8,\n                             (unsigned int)(mpgws[18 * v16] >> 16),\n                             (unsigned int)(mpgws[18 * v16] >> 24));\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\",\n                            (int)*((long long *)&v5.tv_sec),\n                            (int)*((long long *)&v6), &__func__ .0, &buf.2,\n                            (unsigned int)&v7,\n                            (unsigned int)strerror(*(__errno_location())));\n                  } else {\n                    v29 = strerror(*(__errno_location()));\n                    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", mpgws[18 * v16],\n                             mpgws[18 * v16] >> 8,\n                             (unsigned int)(mpgws[18 * v16] >> 16),\n                             (unsigned int)(mpgws[18 * v16] >> 24));\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect \"\n                              \"to %s from %s %s\\\"}\");\n                  }\n                } else {\n                  v0 = 16;\n                  if (getsockname(v22, &v1, &v0) >= 0) {\n                    v23 = 16 + (char *)&mpgws[0] + v20;\n                    v23->field_0 = (int)(&v9)[2];\n                    v23->field_4 = (short)(&v9)[6];\n                    v24 = v16 * 8;\n                    *((unsigned int *)(12 + (char *)&mpgws[0] + 0x8 * v24 +\n                                       8 * v16)) = v3;\n                    close(v22);\n                    v26 = (char *)v24 + v16;\n                    v27 = *((long long *)&v11);\n                    v28 = *((long long *)&v12);\n                    *((unsigned long long *)&mpgws[8 + 2 * v26]) = v27;\n                    *((unsigned long long *)&mpgws[10 + 2 * v26]) = v28;\n                    *((unsigned long long *)&mpgws[12 + 2 * v26]) = v27;\n                    *((unsigned long long *)&mpgws[14 + 2 * v26]) = v28;\n                    update_mpgw(v18, 1);\n                    srandom(*(\n                        (int *)(12 + (char *)&mpgws[0] + 0x8 * v24 + 8 * v16)));\n                    return (char *)&mpgws[0] + v20;\n                  }\n                  if (!foreground) {\n                    strerror(*(__errno_location()));\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                              \"getsockname %s %s\\\"}\");\n                  } else {\n                    gettimeofday(&v5, NULL);\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: getsockname %s %s\\n\",\n                            (int)*((long long *)&v5.tv_sec),\n                            (int)*((long long *)&v6), &__func__ .0,\n                            (unsigned int)&v7,\n                            (unsigned int)strerror(*(__errno_location())));\n                  }\n                }\n              }\n            }\n          }\n        }\n        close(v22);\n        return 0;\n      }\n    } else if (foreground) {\n      gettimeofday(&v7, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v7), (int)*((long long *)&v8), &__func__ .1,\n              (unsigned int)strerror(*(__errno_location())));\n      return 0;\n    } else {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n      return 0;\n    }\n  } else {\n    if (foreground) {\n      gettimeofday(&v7, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: not enough memory\\n\",\n              (int)*((long long *)&v7), (int)*((long long *)&v8), &__func__ .1);\n      return 0;\n    }\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\");\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:38:6: error: conflicting types for 'snprintf'\n   38 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:43:5: error: unknown type name 'uint128_t'\n   43 |     uint128_t field_0;\n      |     ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:44:5: error: unknown type name 'uint128_t'\n   44 |     uint128_t field_10;\n      |     ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:45:5: error: unknown type name 'uint128_t'\n   45 |     uint128_t field_20;\n      |     ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:46:5: error: unknown type name 'uint128_t'\n   46 |     uint128_t field_30;\n      |     ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:61:13: error: expected identifier or '('\n   61 | extern char __func__.0;\n      |             ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:62:13: error: expected identifier or '('\n   62 | extern char __func__.1;\n      |             ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:63:16: error: expected ';' after top level\ndeclarator 63 | extern char buf.2; |                ^ |                ;\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:66:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 66 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:66:22: error: expected ';' after top level\ndeclarator 66 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:98:9: error: array type 'unsigned int[8]' is not\nassignable 98 |     v15 = &mpgws[0]; |     ~~~ ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:100:9: error: array type 'unsigned int[8]' is not\nassignable 100 |     v17 = 0; |     ~~~ ^ /tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:111:34:\nerror: invalid operands to binary expression ('int' and 'unsigned int[8]') 111 |\nreturn &mpgws[18 * v17]; |                               ~~ ^ ~~~\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:113:19: error: array type 'unsigned int[8]' is not\nassignable 113 |     } while ((v17 = (unsigned long long)((unsigned int)v17 +\n1), v15 += 72, (unsigned int)v17 != 32)); |               ~~~ ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:113:70: error: invalid operands to binary expression\n('unsigned int[8]' and 'int') 113 |     } while ((v17 = (unsigned long\nlong)((unsigned int)v17 + 1), v15 += 72, (unsigned int)v17 != 32)); | ~~~ ^  ~~\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:118:17: error: array type 'unsigned int[8]' is not\nassignable 118 |             v19 = v16 * 8; |             ~~~ ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:119:39: error: invalid operands to binary expression\n('char *' and 'int') 119 |             v20 = ((char *)v19 + v16) * 8; |\n~~~~~~~~~~~~~~~~~~~ ^ ~ /tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:121:26: error: expected\nexpression 121 |             *((int128_t *)v18) = 0; | ^\n/tmp/tmpl4sicr0s/add_mpgw_name_conflict.c:122:26: error: expected expression\n  122 |             *((int128_t *)(v18 + 16)) = 0;\n      |                          ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int mpgws[8];\n\nlong long find_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v1[8]; // rax, Other Possible Types: unsigned long\n  void *v2;           // rdx, Other Possible Types: unsigned long\n\n  v1 = &mpgws[0];\n  v2 = 0;\n  while (true) {\n    if (*((int *)(v1 + 28)) && *((int *)v1) == (unsigned int)a0 &&\n        *((int *)(v1 + 24)) == (unsigned int)a1)\n      return &mpgws[18 * v2];\n    v2 = (unsigned int)v2 + 1;\n    v1 += 72;\n    if ((unsigned int)v2 == 32)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdg_zoj32/find_mpgw_name_conflict.c:24:8: error: array type 'unsigned int[8]' is not\nassignable 24 |     v1 = &mpgws[0]; |     ~~ ^\n/tmp/tmpdg_zoj32/find_mpgw_name_conflict.c:29:30: error: invalid operands to binary expression\n('int' and 'void *') 29 |             return &mpgws[18 * v2]; | ~~ ^ ~~\n/tmp/tmpdg_zoj32/find_mpgw_name_conflict.c:31:12: error: invalid operands to binary expression\n('unsigned int[8]' and 'int') 31 |         v1 += 72; |         ~~ ^  ~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char buf.2;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long update_mpgw_name_conflict(unsigned int a0[17], unsigned long a1) {\n  timeval v0;            // [bp-0x38]\n  char v1;               // [bp-0x30]\n  unsigned long long v4; // rax\n  unsigned long long v5; // rax\n\n  if (a0[7] == (unsigned int)a1)\n    return 0;\n  if (!foreground) {\n    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8,\n             (unsigned int)(a0[0] >> 16), (unsigned int)(a0[0] >> 24));\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\");\n  } else {\n    gettimeofday(&v0, NULL);\n    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8,\n             (unsigned int)(a0[0] >> 16), (unsigned int)(a0[0] >> 24));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state %d\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &buf.2,\n            a0[6], (unsigned int)a1);\n  }\n  a0[7] = a1;\n  if ((unsigned int)a1 == 1) {\n    v5 = random();\n    a0[16] = (unsigned int)(v5 - ((v5 * 2361183241434822607 >> 64 >> 7) -\n                                  (v5 >> 63)) *\n                                     1000) +\n             1010;\n    return a1;\n  }\n  v4 = random();\n  a0[16] = (unsigned int)(v4 - ((v4 * 5037190915060954895 >> 64 >> 13) -\n                                (v4 >> 63)) *\n                                   30000) +\n           60000;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:33:16: error: expected ';' after top level\ndeclarator 33 | extern char buf.2; |                ^ |                ;\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:35:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 35 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:35:22: error: expected ';' after top level\ndeclarator 35 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:48:22: error: expected ')'\n   48 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                      ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:48:17: note: to match this '('\n   48 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                 ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:54:22: error: expected ')'\n   54 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                      ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:54:17: note: to match this '('\n   54 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                 ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:55:23: error: expected ')'\n   55 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &buf.2, a0[6],\n(unsigned int)a1); |                       ^\n/tmp/tmpf52wybnn/update_mpgw_name_conflict.c:55:16: note: to match this '('\n   55 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &buf.2, a0[6],\n(unsigned int)a1); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint eax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rta_find(unsigned short a0[2], unsigned long long a1,\n                   unsigned long a2) {\n  unsigned long long v1; // rcx\n  unsigned long long v3; // rcx\n  unsigned long long v4; // rax\n\n  if ((unsigned int)a1 <= 3)\n    return 0;\n  while ((unsigned short)v1 << 48 > 0x3000000000000) {\n    v1 = *((short *)a0);\n    if ((unsigned short)v1 > eax<4>) {\n      return 0;\n    } else if (*((short *)(a0 + 2)) == (unsigned int)a2) {\n      return a0;\n    } else {\n      v3 = (unsigned int)v1 + 3 & -0x4;\n      v4 = a1 - v3;\n      a1 = v4;\n      a0 += v3;\n      if ((unsigned int)v4 <= 3)\n        return 0;\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpifneb87j/rta_find.c:29:40: error: expected expression\n   29 |         if ((unsigned short)v1 > eax<4>)\n      |                                        ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(reset_mpgws)();\nlong(send)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong(recv)(int, void *, unsigned long, int);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(rta_find)(long long, long long, long long);\nlong long(add_mpgw)(long long, long long);\n\ntypedef struct struct_2 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char padding_6[2];\n  unsigned int field_8;\n  char padding_c[4];\n  unsigned int field_10;\n  char padding_14[2];\n  char field_16;\n} struct_2;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_3 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_3;\n\ntypedef struct struct_1 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_1;\n\nextern char __func__ .3;\nextern char __func__ .4;\nextern unsigned int foreground;\nextern struct_0 recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long get_nhs_name_conflict() {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  unsigned int v2;        // [bp-0x58]\n  unsigned short v3;      // [bp-0x54]\n  unsigned short v4;      // [bp-0x52]\n  unsigned int v5;        // [bp-0x50]\n  void *v6;               // [bp-0x4c]\n  char v7;                // [bp-0x48]\n  unsigned long v9;       // rdx, Other Possible Types: unsigned long long\n  unsigned int *v10;      // rax\n  unsigned int v11;       // edi\n  unsigned int v12;       // eax\n  unsigned short v13;     // cx\n  unsigned long long v14; // rax\n  unsigned short *v15;    // rax\n  unsigned int v16;       // esi\n  struct_1 *v17;          // rax\n  unsigned long long v18; // rax\n  unsigned long v19;      // r13, Other Possible Types: unsigned long long\n  struct_3 *v20;          // r12, Other Possible Types: unsigned long\n  unsigned long long v21; // rax\n  struct_2 *v22;          // rbx, Other Possible Types: unsigned long\n  unsigned int v24;       // edx\n\n  reset_mpgws();\n  v6 = 0;\n  v2 = 20;\n  v3 = 26;\n  v4 = 257;\n  talk_seq = talk_seq + 1;\n  v5 = talk_seq;\n  v7 = 2;\n  if (send(talk_sock, &v2, 20, 0) >= 0) {\n    do {\n      while (true) {\n        v9 = recv(talk_sock, &recv_buf.field_0, 0x4000, 0);\n        if ((unsigned int)v9 >= 0) {\n          if (!(unsigned int)v9) {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .4);\n              return 4294967295;\n            }\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n            return 4294967295;\n          } else {\n            if ((unsigned int)v9 > 15) {\n              v22 = &recv_buf.field_0;\n              while (true) {\n                v12 = *((int *)v22);\n                if (!(v12 > 15) || !((unsigned int)v9 >= v12))\n                  break;\n                if (*((int *)(v22 + 8)) != talk_seq) {\n                  if (foreground) {\n                    gettimeofday(&v0, NULL);\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                            (int)*((long long *)&v0.tv_sec),\n                            (int)*((long long *)&v1), &__func__ .4,\n                            *((int *)(v22 + 8)));\n                  } else {\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid \"\n                              \"seq %d\\\"}\");\n                  }\n                } else {\n                  v13 = *((short *)(v22 + 4));\n                  if (v13 == 3)\n                    return 0;\n                  if (v13 == 2) {\n                    if (v12 <= 35) {\n                      if (!foreground) {\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                  \"nlerr msg truncated\\\"}\");\n                        return 4294967295;\n                      }\n                      gettimeofday(&v0, NULL);\n                      fprintf(stderr @GLIBC_2.2.5,\n                              \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                              (int)*((long long *)&v0.tv_sec),\n                              (int)*((long long *)&v1), &__func__ .4);\n                      return 4294967295;\n                    } else {\n                      v24 = *((int *)(v22 + 16));\n                      if (!v24)\n                        return 4294967295;\n                      if (!foreground) {\n                        strerror(-(v24));\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                  \"nlerr %s\\\"}\");\n                        return 4294967295;\n                      }\n                      gettimeofday(&v0, NULL);\n                      fprintf(stderr @GLIBC_2.2.5,\n                              \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                              (int)*((long long *)&v0.tv_sec),\n                              (int)*((long long *)&v1), &__func__ .4,\n                              (unsigned int)strerror(-(*((int *)(v22 + 16)))));\n                      return 4294967295;\n                    }\n                  } else {\n                    if (v13 != 24) {\n                      if (foreground) {\n                        gettimeofday(&v0, NULL);\n                        fprintf(stderr @GLIBC_2.2.5,\n                                \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                                (int)*((long long *)&v0.tv_sec),\n                                (int)*((long long *)&v1), &__func__ .4,\n                                *((short *)(v22 + 4)));\n                      } else {\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                  \"invalid type %d\\\"}\");\n                      }\n                    } else {\n                      v14 = v12 - 28;\n                      if ((unsigned int)(v14 - 28) < 0) {\n                        if (foreground) {\n                          gettimeofday(&v0, NULL);\n                          fprintf(\n                              stderr @GLIBC_2.2.5,\n                              \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\",\n                              (int)*((long long *)&v0.tv_sec),\n                              (int)*((long long *)&v1), &__func__ .3,\n                              (unsigned int)v14);\n                        } else {\n                          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                    \"invalid nlmsg_len %d\\\"}\");\n                        }\n                        return 4294967295;\n                      } else {\n                        if (*((char *)(v22 + 16)) == 2 &&\n                            *((char *)(v22 + 22)) <= 252) {\n                          v15 = rta_find(v22 + 28, v14, 9);\n                          if (v15) {\n                            v19 = *(v15)-4;\n                            v20 = v15 + 2;\n                            if ((unsigned int)v19 > 7) {\n                              while (true) {\n                                v16 = *((short *)v20);\n                                if ((unsigned int)v19 < v16)\n                                  break;\n                                v17 = rta_find(v20 + 8, v16 - 8, 5);\n                                if (v17) {\n                                  if (!add_mpgw(v17->field_4,\n                                                *((int *)(v20 + 4))))\n                                    return 4294967295;\n                                  v18 = *((short *)v20) + 3 & 0xfffffffc;\n                                  v19 -= v18;\n                                  v20 += v18;\n                                  if ((unsigned int)v19 <= 7)\n                                    break;\n                                } else {\n                                  if (!foreground) {\n                                    syslog(3,\n                                           \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \"\n                                           \"\\\"%s no gateway in nh info\\\"}\");\n                                    break;\n                                  } else {\n                                    gettimeofday(&v0, NULL);\n                                    fprintf(stderr @GLIBC_2.2.5,\n                                            \"%ld.%06ld [error] %s: no gateway \"\n                                            \"in nh info\\n\",\n                                            (int)*((long long *)&v0.tv_sec),\n                                            (int)*((long long *)&v1),\n                                            &__func__ .3);\n                                    break;\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n                v21 = *((int *)v22) + 3 & -0x4;\n                v9 -= v21;\n                v22 += v21;\n                if ((unsigned int)v9 <= 15)\n                  break;\n              }\n            }\n          }\n        } else {\n          v10 = __errno_location();\n          v11 = *(v10);\n          if (v11 != 4)\n            break;\n        }\n      }\n    } while (v11 == 11);\n    if (!foreground) {\n      strerror(v11);\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n      return 4294967295;\n    }\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .4, (unsigned int)strerror(*(v10)));\n    return 4294967295;\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .4, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:59:13: error: expected identifier or '('\n   59 | extern char __func__.3;\n      |             ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:60:13: error: expected identifier or '('\n   60 | extern char __func__.4;\n      |             ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:62:8: error: unknown type name 'struct_0'\n   62 | extern struct_0 recv_buf;\n      |        ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:63:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 63 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:63:22: error: expected ';' after top level declarator\n   63 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:115:43: error: expected ')'\n  115 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: recv len == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                                           ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:115:36: note: to match this '('\n  115 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: recv len == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                                    ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:136:55: error: expected ')'\n  136 |                                         fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, *((int *)(v22 + 8))); | ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:136:48: note: to match this '('\n  136 |                                         fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, *((int *)(v22 + 8))); | ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:158:59: error: expected ')'\n  158 |                                             fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4); | ^ /tmp/tmpm19jx_m3/get_nhs_name_conflict.c:158:52:\nnote: to match this '(' 158 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nnlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                                                    ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:173:59: error: expected ')'\n  173 |                                             fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, (unsigned int)strerror(-(*((int *)(v22 +\n16))))); |                                                           ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:173:52: note: to match this '('\n  173 |                                             fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, (unsigned int)strerror(-(*((int *)(v22 +\n16))))); |                                                    ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:184:63: error: expected ')'\n  184 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid type %d\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4, *((short\n*)(v22 + 4))); |                                                               ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:184:56: note: to match this '('\n  184 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid type %d\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4, *((short\n*)(v22 + 4))); |                                                        ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:199:67: error: expected ')'\n  199 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid nlmsg_len\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)v14); | ^ /tmp/tmpm19jx_m3/get_nhs_name_conflict.c:199:60: note: to match this\n'(' 199 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid nlmsg_len\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)v14); | ^ /tmp/tmpm19jx_m3/get_nhs_name_conflict.c:244:87: error: expected ')'\n  244 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: no gateway in nh\ninfo\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.3); | ^ /tmp/tmpm19jx_m3/get_nhs_name_conflict.c:244:80: note: to match this '(' 244\n| fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: no gateway in nh info\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3); | ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:281:23: error: expected ')'\n  281 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(v10))); |                       ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:281:16: note: to match this '('\n  281 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(v10))); |                ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:286:18: error: indirection requires pointer operand\n('int' invalid) 286 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpm19jx_m3/get_nhs_name_conflict.c:293:23: error: expected ')' 293\n|         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmpm19jx_m3/get_nhs_name_conflict.c:293:16: note: to match this '('\n  293 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(__errno_location()))); |                ^ 15 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong(recv)(int, void *, unsigned long, int);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .2;\nextern unsigned int foreground;\nextern unsigned short g_406104;\nextern unsigned int g_406108;\nextern unsigned int g_406110;\nextern unsigned int recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long update_neigh(unsigned long a0, unsigned long a1, struct_0 *a2,\n                       unsigned long a3) {\n  timeval v0;             // [bp-0x58]\n  char v1;                // [bp-0x50]\n  unsigned int v2;        // [bp-0x48]\n  unsigned short v3;      // [bp-0x44]\n  unsigned short v4;      // [bp-0x42]\n  unsigned int v5;        // [bp-0x40]\n  int v6;                 // [bp-0x3c]\n  char v7;                // [bp-0x38]\n  unsigned int v8;        // [bp-0x34]\n  unsigned short v9;      // [bp-0x30]\n  unsigned short v10;     // [bp-0x2c]\n  unsigned short v11;     // [bp-0x2a]\n  unsigned int v12;       // [bp-0x28]\n  unsigned short v13;     // [bp-0x24]\n  unsigned short v14;     // [bp-0x22]\n  unsigned int v15;       // [bp-0x20]\n  unsigned short v16;     // [bp-0x1c], Other Possible Types: unsigned int\n  unsigned long long v18; // rax\n  unsigned int *v19;      // rax\n  unsigned int v20;       // edi\n\n  *((int128_t *)&v6) = 0;\n  v16 = 0;\n  v2 = 48;\n  v3 = 28;\n  talk_seq = talk_seq + 1;\n  v5 = talk_seq;\n  v4 = 1285;\n  v7 = 2;\n  v8 = a0;\n  v9 = (-((unsigned int)a3 < 1) & 30) + 2;\n  v10 = 8;\n  v11 = 1;\n  v12 = a1;\n  v13 = 10;\n  v14 = 2;\n  v15 = a2->field_0;\n  v16 = a2->field_4;\n  if (send(talk_sock, &v2, 48, 0) >= 0) {\n    while (true) {\n      (unsigned int)v18 = recv(talk_sock, &recv_buf, 0x4000, 0);\n      if ((unsigned int)v18 >= 0)\n        break;\n      v19 = __errno_location();\n      v20 = *(v19);\n      if (v20 == 4)\n        continue;\n      if (v20 != 11) {\n        if (!foreground) {\n          strerror(v20);\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n          return 4294967295;\n        }\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .2, (unsigned int)strerror(*(v19)));\n        return 4294967295;\n      }\n    }\n    if ((unsigned int)v18) {\n      if ((unsigned int)v18 > 15 && recv_buf > 15 &&\n          (unsigned int)v18 >= recv_buf) {\n        if (g_406108 == talk_seq) {\n          if (g_406104 == 2) {\n            if (recv_buf > 35) {\n              if (!g_406110)\n                return g_406110;\n              if (foreground) {\n                gettimeofday(&v0, NULL);\n                fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                        (int)*((long long *)&v0.tv_sec),\n                        (int)*((long long *)&v1), &__func__ .2,\n                        (unsigned int)strerror(-(g_406110)));\n                return 0;\n              }\n              strerror(-(g_406110));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n              return foreground;\n            } else {\n              if (foreground) {\n                gettimeofday(&v0, NULL);\n                fprintf(stderr @GLIBC_2.2.5,\n                        \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                        (int)*((long long *)&v0.tv_sec),\n                        (int)*((long long *)&v1), &__func__ .2);\n                return 0;\n              }\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg \"\n                        \"truncated\\\"}\");\n              return foreground;\n            }\n          } else {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .2, g_406104);\n              return 4294967295;\n            }\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\");\n            return 4294967295;\n          }\n        } else {\n          if (foreground) {\n            gettimeofday(&v0, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                    (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                    &__func__ .2, g_406108);\n            return 4294967295;\n          }\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\");\n          return 4294967295;\n        }\n      }\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\");\n        return 4294967295;\n      }\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid len %d\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .2, (unsigned int)v18);\n      return 4294967295;\n    } else {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .2);\n        return 4294967295;\n      }\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n      return 4294967295;\n    }\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .2, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmnc_9uq1/update_neigh.c:40:13: error: expected identifier or '('\n   40 | extern char __func__.2;\n      |             ^\n/tmp/tmpmnc_9uq1/update_neigh.c:46:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpmnc_9uq1/update_neigh.c:46:22: error: expected ';' after top level\ndeclarator 46 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpmnc_9uq1/update_neigh.c:73:18: error: expected expression\n   73 |     *((int128_t *)&v6) = 0;\n      |                  ^\n/tmp/tmpmnc_9uq1/update_neigh.c:94:13: error: assignment to cast is illegal,\nlvalue casts are not supported 94 |             (unsigned int)v18 =\nrecv(talk_sock, &recv_buf, 0x4000, 0); |             ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpmnc_9uq1/update_neigh.c:110:31: error: expected ')'\n  110 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.2,\n(unsigned int)strerror(*(v19))); |                               ^\n/tmp/tmpmnc_9uq1/update_neigh.c:110:24: note: to match this '('\n  110 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.2,\n(unsigned int)strerror(*(v19))); |                        ^\n/tmp/tmpmnc_9uq1/update_neigh.c:129:47: error: expected ')'\n  129 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, (unsigned int)strerror(-(g_406110))); | ^\n/tmp/tmpmnc_9uq1/update_neigh.c:129:40: note: to match this '('\n  129 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, (unsigned int)strerror(-(g_406110))); | ^\n/tmp/tmpmnc_9uq1/update_neigh.c:141:47: error: expected ')'\n  141 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.2); | ^\n/tmp/tmpmnc_9uq1/update_neigh.c:141:40: note: to match this '('\n  141 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.2); | ^\n/tmp/tmpmnc_9uq1/update_neigh.c:153:43: error: expected ')'\n  153 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid type %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.2, g_406104); | ^ /tmp/tmpmnc_9uq1/update_neigh.c:153:36:\nnote: to match this '(' 153 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, g_406104); |                                    ^\n/tmp/tmpmnc_9uq1/update_neigh.c:165:39: error: expected ')'\n  165 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, g_406108); |                                       ^\n/tmp/tmpmnc_9uq1/update_neigh.c:165:32: note: to match this '('\n  165 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, g_406108); |                                ^\n/tmp/tmpmnc_9uq1/update_neigh.c:178:27: error: expected ')'\n  178 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nlen %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)v18); |                           ^\n/tmp/tmpmnc_9uq1/update_neigh.c:178:20: note: to match this '('\n  178 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nlen %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)v18); |                    ^\n/tmp/tmpmnc_9uq1/update_neigh.c:186:31: error: expected ')'\n  186 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2); |                               ^\n/tmp/tmpmnc_9uq1/update_neigh.c:186:24: note: to match this '('\n  186 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2); |                        ^ /tmp/tmpmnc_9uq1/update_neigh.c:195:18:\nerror: indirection requires pointer operand ('int' invalid) 195 |\nstrerror(*(__errno_location())); |                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmnc_9uq1/update_neigh.c:202:23: error: expected ')'\n  202 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.2,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmpmnc_9uq1/update_neigh.c:202:16: note: to match this '('\n  202 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.2,\n(unsigned int)strerror(*(__errno_location()))); |                ^ 14 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(get_nhs)();\nvoid(syslog)(int, char *, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern void recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_nl_name_conflict() {\n  timeval v0;      // [bp-0x28]\n  char v1;         // [bp-0x20]\n  unsigned int v2; // [bp-0x18]\n  sockaddr v3;     // [bp-0x14]\n  char v4;         // [bp-0x10]\n\n  v2 = 12;\n  if (recvfrom(poll_sock, &recv_buf, 0x4000, 64, &v3, &v2) < 0) {\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1, (unsigned int)strerror(*(__errno_location())));\n      return 0;\n    }\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    return foreground;\n  } else {\n    if (v2 != 12) {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .1);\n        return 0;\n      }\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\");\n      return foreground;\n    } else {\n      if (*((int *)&v4))\n        return 0;\n      get_nhs();\n      return 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:42:13: error: expected identifier or '('\n   42 | extern char __func__.1;\n      |             ^\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:46:22: error: expected ';' after top level declarator\n   46 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:62:27: error: expected ')'\n   62 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1,\n(unsigned int)strerror(*(__errno_location()))); |                           ^\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:62:20: note: to match this '('\n   62 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1,\n(unsigned int)strerror(*(__errno_location()))); |                    ^\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:65:18: error: indirection requires pointer operand\n('int' invalid) 65 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp1rw3grj7/recv_nl_name_conflict.c:76:31: error: expected ')' 76 |\nfprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1); | ^\n/tmp/tmp1rw3grj7/recv_nl_name_conflict.c:76:24: note: to match this '('\n   76 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid addr len\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                        ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\nint(close)(int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(get_nhs)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long open_nl_name_conflict() {\n  timeval v0;        // [bp-0x28]\n  char v1;           // [bp-0x20]\n  unsigned int v2;   // [bp-0x18]\n  unsigned short v3; // [bp-0x14]\n  void *v4;          // [bp-0x12], Other Possible Types: unsigned int\n  unsigned short v5; // [bp-0xe]\n  unsigned int v6;   // [bp-0xc]\n  unsigned short v7; // [bp-0xa]\n\n  v2 = 12;\n  v4 = 0;\n  v7 = 0;\n  v3 = 16;\n  talk_sock = socket(16, 3, 0);\n  if (talk_sock >= 0) {\n    if (connect(talk_sock, &v3, 12) < 0) {\n      if (!foreground) {\n        strerror(*(__errno_location()));\n        syslog(\n            3,\n            \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\");\n      } else {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: connect talk_sock %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n      }\n    } else {\n      if (getsockname(talk_sock, &v3, &v2) < 0) {\n        if (!foreground) {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname \"\n                    \"talk_sock %s\\\"}\");\n        } else {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n        }\n      } else {\n        talk_seq = random();\n        v4 = 0;\n        v5 = 0;\n        v3 = 16;\n        v6 = 64;\n        poll_sock = socket(16, 3, 0);\n        if (poll_sock < 0) {\n          if (foreground) {\n            gettimeofday(&v0, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: socket poll_sock %s\\n\",\n                    (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                    &__func__ .0,\n                    (unsigned int)strerror(*(__errno_location())));\n          } else {\n            strerror(*(__errno_location()));\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock \"\n                      \"%s\\\"}\");\n          }\n        } else {\n          if (bind(poll_sock, &v3, 12) < 0) {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: bind poll_sock %s\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .0,\n                      (unsigned int)strerror(*(__errno_location())));\n            } else {\n              strerror(*(__errno_location()));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock \"\n                        \"%s\\\"}\");\n            }\n          } else {\n            if ((int)get_nhs() >= 0)\n              return poll_sock;\n          }\n          close(poll_sock);\n        }\n      }\n    }\n    close(talk_sock);\n    return 4294967295;\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:48:13: error: expected identifier or '('\n   48 | extern char __func__.0;\n      |             ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:51:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:51:22: error: expected ';' after top level declarator\n   51 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:77:26: error: indirection requires pointer operand\n('int' invalid) 77 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmprf8d9yd4/open_nl_name_conflict.c:83:31: error: expected ')' 83 |\nfprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:83:24: note: to match this '('\n   83 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nconnect talk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:92:30: error: indirection requires pointer operand\n('int' invalid) 92 |                     strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmprf8d9yd4/open_nl_name_conflict.c:98:35: error: expected ')' 98 |\nfprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:98:28: note: to match this '('\n   98 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ngetsockname talk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:114:39: error: expected ')'\n  114 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: socket poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:114:32: note: to match this '('\n  114 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: socket poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:118:34: error: indirection requires pointer operand\n('int' invalid) 118 |                         strerror(*(__errno_location()));\n      |                                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:129:43: error: expected ')'\n  129 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:129:36: note: to match this '('\n  129 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:133:38: error: indirection requires pointer operand\n('int' invalid) 133 | strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:151:18: error: indirection requires pointer operand\n('int' invalid) 151 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmprf8d9yd4/open_nl_name_conflict.c:158:23: error: expected ')' 158\n|         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket talk_sock\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmprf8d9yd4/open_nl_name_conflict.c:158:16: note: to match this '('\n  158 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.0, (unsigned int)strerror(*(__errno_location()))); |                ^\n13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned short field_ - 2;\n  char field_0;\n} struct_0;\n\nlong long in_cksum_name_conflict(struct_0 *a0, unsigned int a1) {\n  unsigned long long v1; // r8\n  struct_0 *v2;          // rcx, Other Possible Types: unsigned long\n  void *v4;              // rax, Other Possible Types: unsigned long\n  unsigned int v5;       // edx\n\n  if (a1 <= 1) {\n    v2 = a0;\n    v4 = 0;\n  } else {\n    v1 = a1 - 2 >> 1;\n    v2 = &(&a0->field_0)[2 * v1];\n    v4 = 0;\n    do {\n      a0 += 2;\n      v4 += *((short *)(a0 - 2));\n    } while (a0 != v2);\n    a1 = a1 + -((unsigned int)v1) * 2 - 2;\n  }\n  if ((unsigned int)a1 == 1)\n    v4 += *((char *)v2);\n  v5 = (v4 >> 16) + v4;\n  return ~(v5 / 0x10000 + v5);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1iuiat0h/in_cksum_name_conflict.c:18:26: error: expected ';' at end of declaration\nlist 18 |     unsigned short field_-2; |                          ^ | ;\n/tmp/tmp1iuiat0h/in_cksum_name_conflict.c:48:14: error: invalid operands to binary expression\n('void *' and 'int') 48 |     v5 = (v4 >> 16) + v4; |           ~~ ^  ~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(in_cksum)(long long, long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nint(snprintf)(char *, unsigned long, char *, ...);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .6;\nextern char buf.10;\nextern char buf.4;\nextern unsigned int foreground;\nextern unsigned int g_4040f0;\nextern unsigned int g_404104;\nextern char g_4047d1;\nextern unsigned short g_4047d2;\nextern unsigned short g_4047d4;\nextern unsigned short g_4047d6;\nextern unsigned int g_4047d8;\nextern char g_4047dc;\nextern unsigned long long msg.7;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_ping_name_conflict(unsigned long a0, unsigned long a1) {\n  timeval v0; // [bp-0x28]\n  char v1;    // [bp-0x20]\n\n  g_404104 = a1;\n  g_4040f0 = a0;\n  buf.10 = 8;\n  g_4047d1 = 0;\n  g_4047d4 = ping_id;\n  g_4047d6 = 0;\n  g_4047d2 = 0;\n  g_4047d8 = a0;\n  strncpy(&g_4047dc, \"WGPM\", 4);\n  g_4047d2 = in_cksum(&buf.10, 16);\n  if (sendmsg(ping_sock, &msg.7, 4) >= 0) {\n    return 0;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1,\n             (unsigned int)a1 / 0x100, (unsigned int)a1 / 0x10000,\n             (unsigned int)a1 / 0x1000000);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .6, (unsigned int)a0, &buf.4,\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1,\n             (unsigned int)a1 / 0x100, (unsigned int)a1 / 0x10000,\n             (unsigned int)a1 / 0x1000000);\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:25:6: error: conflicting types for 'snprintf'\n   25 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:34:13: error: expected identifier or '('\n   34 | extern char __func__.6;\n      |             ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:35:16: error: expected ';' after top level\ndeclarator 35 | extern char buf.10; |                ^ |                ;\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:36:16: error: expected ';' after top level\ndeclarator 36 | extern char buf.4; |                ^ |                ;\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:46:30: error: expected ';' after top level\ndeclarator 46 | extern unsigned long long msg.7; | ^ | ;\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:49:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 49 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:49:22: error: expected ';' after top level\ndeclarator 49 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:58:8: error: expected ';' after expression\n   58 |     buf.10 = 8;\n      |        ^\n      |        ;\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:58:12: error: expression is not assignable\n   58 |     buf.10 = 8;\n      |        ~~~ ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:65:29: error: expected ')'\n   65 |     g_4047d2 = in_cksum(&buf.10, 16);\n      |                             ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:65:24: note: to match this '('\n   65 |     g_4047d2 = in_cksum(&buf.10, 16);\n      |                        ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:66:32: error: expected ')'\n   66 |     if (sendmsg(ping_sock, &msg.7, 4) >= 0)\n      |                                ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:66:16: note: to match this '('\n   66 |     if (sendmsg(ping_sock, &msg.7, 4) >= 0)\n      |                ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:73:22: error: expected ')'\n   73 |         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned\nint)a1 / 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:73:17: note: to match this '('\n   73 |         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned\nint)a1 / 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:74:23: error: expected ')'\n   74 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, &buf.4, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:74:16: note: to match this '('\n   74 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, &buf.4, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:79:18: error: indirection requires pointer operand\n('int' invalid) 79 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp8c2p534u/send_ping_name_conflict.c:80:22: error: expected ')' 80\n|         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned int)a1\n/ 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n/tmp/tmp8c2p534u/send_ping_name_conflict.c:80:17: note: to match this '('\n   80 |         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned\nint)a1 / 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(in_cksum)(long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern void buf.3;\nextern unsigned int foreground;\nextern unsigned int g_4041c4;\nextern char g_4041f4;\nextern char g_4041f5;\nextern unsigned short g_4041f8;\nextern unsigned short g_4041fa;\nextern unsigned int g_4041fc;\nextern unsigned int g_404200;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern sockaddr src.2;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_ping_name_conflict(unsigned int *a0, unsigned int *a1) {\n  timeval v0;            // [bp-0x48]\n  char v1;               // [bp-0x40]\n  unsigned int v2;       // [bp-0x2c]\n  unsigned long long v4; // rbx\n\n  v2 = 16;\n  v4 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v2);\n  if ((unsigned int)v4 > 27) {\n    if (src.2.sin_family != 2) {\n      return 4294967295;\n    } else if (g_4041f8 != ping_id) {\n      return 4294967295;\n    } else if (g_4041fa) {\n      return 4294967295;\n    } else if (!(!g_4041f4) || !(!g_4041f5)) {\n      return 4294967295;\n    } else if ((unsigned int)v4 > 35) {\n      if ((short)in_cksum(&buf.3, v4)) {\n        if (foreground) {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: checksum error\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .1);\n          return 4294967295;\n        }\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\");\n        return 4294967295;\n      } else {\n        if (g_404200 == 1297106775) {\n          *(a0) = g_4041fc;\n          *(a1) = g_4041c4;\n          return 0;\n        } else if (foreground) {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: signature error\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .1);\n          return 4294967295;\n        } else {\n          syslog(3,\n                 \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\");\n          return 4294967295;\n        }\n      }\n    } else {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg too small\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .1);\n        return 4294967295;\n      }\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\");\n      return 4294967295;\n    }\n  } else {\n    if (!foreground) {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\");\n      return 4294967295;\n    }\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .1, (unsigned int)v4,\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:37:13: error: expected identifier or '('\n   37 | extern char __func__.1;\n      |             ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:38:16: error: expected ';' after top level\ndeclarator 38 | extern void buf.3; |                ^ |                ;\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:49:8: error: unknown type name 'sockaddr'\n   49 | extern sockaddr src.2;\n      |        ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:49:20: error: expected ';' after top level\ndeclarator 49 | extern sockaddr src.2; |                    ^ | ;\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:50:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 50 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:50:22: error: expected ';' after top level\ndeclarator 50 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:60:34: error: expected ')'\n   60 |     v4 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v2);\n      |                                  ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:60:18: note: to match this '('\n   60 |     v4 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v2);\n      |                  ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:63:16: error: expected ')'\n   63 |         if (src.2.sin_family != 2)\n      |                ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:63:12: note: to match this '('\n   63 |         if (src.2.sin_family != 2)\n      |            ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:81:37: error: expected ')'\n   81 |             if ((short)in_cksum(&buf.3, v4))\n      |                                     ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:81:32: note: to match this '('\n   81 |             if ((short)in_cksum(&buf.3, v4))\n      |                                ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:86:35: error: expected ')'\n   86 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                                   ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:86:28: note: to match this '('\n   86 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                            ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:103:35: error: expected ')'\n  103 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsignature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                                   ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:103:28: note: to match this '('\n  103 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsignature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                            ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:118:31: error: expected ')'\n  118 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                               ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:118:24: note: to match this '('\n  118 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                        ^ /tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:129:22:\nerror: indirection requires pointer operand ('int' invalid) 129 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:134:23: error: expected ')'\n  134 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len\n%d %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)v4, (unsigned int)strerror(*(__errno_location())));\n      |                       ^\n/tmp/tmp8_zcbm0f/recv_ping_name_conflict.c:134:16: note: to match this '('\n  134 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len\n%d %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)v4, (unsigned int)strerror(*(__errno_location())));\n      |                ^\n14 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(setsockopt)(int, int, int, void *, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nint(close)(int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_ping_name_conflict() {\n  timeval v0;      // [bp-0x28]\n  char v1;         // [bp-0x20]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 1;\n  ping_sock = socket(2, 3, 1);\n  if (ping_sock >= 0) {\n    if (setsockopt(ping_sock, 0, 2, &v2, 4) < 0) {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n      } else {\n        strerror(*(__errno_location()));\n        syslog(\n            3,\n            \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\");\n      }\n    } else {\n      if (setsockopt(ping_sock, 0, 8, &v2, 4) >= 0) {\n        ping_id = __ROL__((short)getpid(), 8);\n        return ping_sock;\n      }\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n      } else {\n        strerror(*(__errno_location()));\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt \"\n                  \"IP_PKTINFO %s\\\"}\");\n      }\n    }\n    close(ping_sock);\n    return 4294967295;\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:35:13: error: expected identifier or '('\n   35 | extern char __func__.0;\n      |             ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:39:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 39 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:39:22: error: expected ';' after top level\ndeclarator 39 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:56:31: error: expected ')'\n   56 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:56:24: note: to match this '('\n   56 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:60:26: error: indirection requires pointer operand\n('int' invalid) 60 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpjzyvg9j8/open_ping_name_conflict.c:74:31: error: expected ')' 74\n|                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: setsockopt\nIP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:74:24: note: to match this '('\n   74 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:78:26: error: indirection requires pointer operand\n('int' invalid) 78 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpjzyvg9j8/open_ping_name_conflict.c:87:18: error: indirection\nrequires pointer operand ('int' invalid) 87 | strerror(*(__errno_location()));\n      |                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:94:23: error: expected ')'\n   94 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmpjzyvg9j8/open_ping_name_conflict.c:94:16: note: to match this '('\n   94 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                ^ 9 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .3;\nextern unsigned int arp_sock;\nextern unsigned short buf.4;\nextern unsigned int foreground;\nextern unsigned short g_408642;\nextern char g_408644;\nextern char g_408645;\nextern unsigned short g_408646;\nextern unsigned int g_408648;\nextern unsigned short g_40864c;\nextern char g_40864e;\nextern unsigned int g_408652;\nextern unsigned short g_408656;\nextern char g_408658;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_garp(unsigned long a0, unsigned long a1, struct_0 *a2,\n                    unsigned long a3, struct_0 *a4) {\n  timeval v0;        // [bp-0x38]\n  char v1;           // [bp-0x30]\n  sockaddr v2;       // [bp-0x28]\n  unsigned short v3; // [bp-0x26]\n  unsigned int v4;   // [bp-0x24]\n  char v5;           // [bp-0x1d]\n  unsigned int v6;   // [bp-0x1c]\n  unsigned short v7; // [bp-0x18], Other Possible Types: unsigned int\n\n  buf.4 = 0x100;\n  g_408642 = 8;\n  g_408644 = 6;\n  g_408645 = 4;\n  g_408646 = 0x200;\n  g_408648 = a2->field_0;\n  g_40864c = a2->field_4;\n  *((unsigned int *)&g_40864e) = a1;\n  g_408652 = a4->field_0;\n  g_408656 = a4->field_4;\n  *((unsigned int *)&g_408658) = a3;\n  *((int128_t *)&v2.sin_family) = 0;\n  v7 = 0;\n  v3 = 1544;\n  v4 = a0;\n  v5 = 6;\n  v6 = -1;\n  v7 = 65535;\n  if (sendto(arp_sock, &buf.4, 28, 0, &v2, 20) >= 0) {\n    return 0;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .3, (unsigned int)a0,\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_549nv3t/send_garp.c:47:13: error: expected identifier or '('\n   47 | extern char __func__.3;\n      |             ^\n/tmp/tmp_549nv3t/send_garp.c:49:26: error: expected ';' after top level\ndeclarator 49 | extern unsigned short buf.4; |                          ^ | ;\n/tmp/tmp_549nv3t/send_garp.c:61:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 61 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp_549nv3t/send_garp.c:61:22: error: expected ';' after top level\ndeclarator 61 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp_549nv3t/send_garp.c:74:8: error: expected ';' after expression\n   74 |     buf.4 = 0x100;\n      |        ^\n      |        ;\n/tmp/tmp_549nv3t/send_garp.c:74:11: error: expression is not assignable\n   74 |     buf.4 = 0x100;\n      |        ~~ ^\n/tmp/tmp_549nv3t/send_garp.c:85:18: error: expected expression\n   85 |     *((int128_t *)&v2.sin_family) = 0;\n      |                  ^\n/tmp/tmp_549nv3t/send_garp.c:92:30: error: expected ')'\n   92 |     if (sendto(arp_sock, &buf.4, 28, 0, &v2, 20) >= 0)\n      |                              ^\n/tmp/tmp_549nv3t/send_garp.c:92:15: note: to match this '('\n   92 |     if (sendto(arp_sock, &buf.4, 28, 0, &v2, 20) >= 0)\n      |               ^\n/tmp/tmp_549nv3t/send_garp.c:99:23: error: expected ')'\n   99 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp_549nv3t/send_garp.c:99:16: note: to match this '('\n   99 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendto if %d\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)a0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp_549nv3t/send_garp.c:104:18: error: indirection requires pointer operand\n('int' invalid) 104 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\nextern char __func__ .1;\nextern unsigned int arp_sock;\nextern void buf.2;\nextern unsigned int foreground;\nextern unsigned short g_408242;\nextern char g_408244;\nextern char g_408245;\nextern unsigned short g_408246;\nextern unsigned int g_408248;\nextern unsigned short g_40824c;\nextern unsigned int g_40824e;\nextern unsigned int g_408252;\nextern unsigned short g_408256;\nextern unsigned int g_408258;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_arp(unsigned int *a0, unsigned short *a1, unsigned short *a2,\n                   unsigned int *a3, struct_0 *a4, unsigned int *a5,\n                   struct_0 *v6) {\n  timeval v0;            // [bp-0x78]\n  char v1;               // [bp-0x70]\n  unsigned int v2;       // [bp-0x5c]\n  sockaddr v3;           // [bp-0x58]\n  char v4;               // [bp-0x54]\n  char v5;               // [bp-0x4e]\n  unsigned long long v7; // rax\n  struct_0 *v9;          // rbx\n\n  v2 = 20;\n  (unsigned int)v7 = recvfrom(arp_sock, &buf.2, 0x400, 64, &v3, &v2);\n  if ((unsigned int)v7 >= 0) {\n    if ((unsigned int)v7 > 27 && !(g_408246 - 0x100 & 65279) && g_408245 == 4 &&\n        g_408242 == 8 && g_408244 == 6) {\n      *(a0) = *((int *)&v4);\n      *(a1) = v5;\n      *(a2) = __ROL__(g_408246, 8);\n      a4->field_0 = g_408248;\n      a4->field_4 = g_40824c;\n      *(a3) = g_40824e;\n      v9 = v6;\n      v9->field_0 = g_408252;\n      v9->field_4 = g_408256;\n      *(a5) = g_408258;\n      return 0;\n    }\n    if (!foreground) {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\");\n      return 4294967295;\n    }\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid message\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .1);\n    return 4294967295;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .1, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp26kx1ue9/recv_arp.c:46:13: error: expected identifier or '('\n   46 | extern char __func__.1;\n      |             ^\n/tmp/tmp26kx1ue9/recv_arp.c:48:16: error: expected ';' after top level\ndeclarator 48 | extern void buf.2; |                ^ |                ;\n/tmp/tmp26kx1ue9/recv_arp.c:60:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 60 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp26kx1ue9/recv_arp.c:60:22: error: expected ';' after top level\ndeclarator 60 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp26kx1ue9/recv_arp.c:74:47: error: expected ')'\n   74 |     (unsigned int)v7 = recvfrom(arp_sock, &buf.2, 0x400, 64, &v3, &v2);\n      |                                               ^\n/tmp/tmp26kx1ue9/recv_arp.c:74:32: note: to match this '('\n   74 |     (unsigned int)v7 = recvfrom(arp_sock, &buf.2, 0x400, 64, &v3, &v2);\n      |                                ^\n/tmp/tmp26kx1ue9/recv_arp.c:97:23: error: expected ')'\n   97 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nmessage\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                       ^ /tmp/tmp26kx1ue9/recv_arp.c:97:16: note:\nto match this '(' 97 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid message\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.1); |                ^ /tmp/tmp26kx1ue9/recv_arp.c:103:23:\nerror: expected ')' 103 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: recvfrom %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp26kx1ue9/recv_arp.c:103:16: note: to match this '('\n  103 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1,\n(unsigned int)strerror(*(__errno_location()))); |                ^\n/tmp/tmp26kx1ue9/recv_arp.c:108:18: error: indirection requires pointer operand\n('int' invalid) 108 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 8 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int arp_sock;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_arp_name_conflict() {\n  timeval v0;            // [bp-0x18]\n  char v1;               // [bp-0x10]\n  unsigned long long v3; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v3 = socket(17, 2, 1544);\n  arp_sock = v3;\n  if ((unsigned int)v3 >= 0) {\n    return v3;\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpabv8jyky/open_arp_name_conflict.c:33:13: error: expected identifier or '('\n   33 | extern char __func__.0;\n      |             ^\n/tmp/tmpabv8jyky/open_arp_name_conflict.c:36:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 36 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpabv8jyky/open_arp_name_conflict.c:36:22: error: expected ';' after top level\ndeclarator 36 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpabv8jyky/open_arp_name_conflict.c:44:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 44 |     (unsigned int)v3 = socket(17, 2, 1544); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpabv8jyky/open_arp_name_conflict.c:52:18: error: indirection\nrequires pointer operand ('int' invalid) 52 | strerror(*(__errno_location()));\n      |                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpabv8jyky/open_arp_name_conflict.c:59:23: error: expected ')'\n   59 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmpabv8jyky/open_arp_name_conflict.c:59:16: note: to match this '('\n   59 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                ^ 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned short field_ - 2;\n  char field_0;\n} struct_0;\n\nlong long in_cksum_name_conflict(struct_0 *a0, unsigned int a1) {\n  unsigned long long v1; // r8\n  struct_0 *v2;          // rcx, Other Possible Types: unsigned long\n  void *v4;              // rax, Other Possible Types: unsigned long\n  unsigned int v5;       // edx\n\n  if (a1 <= 1) {\n    v2 = a0;\n    v4 = 0;\n  } else {\n    v1 = a1 - 2 >> 1;\n    v2 = &(&a0->field_0)[2 * v1];\n    v4 = 0;\n    do {\n      a0 += 2;\n      v4 += *((short *)(a0 - 2));\n    } while (a0 != v2);\n    a1 = a1 + -((unsigned int)v1) * 2 - 2;\n  }\n  if ((unsigned int)a1 == 1)\n    v4 += *((char *)v2);\n  v5 = (v4 >> 16) + v4;\n  return ~(v5 / 0x10000 + v5);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcij9zwyf/in_cksum_name_conflict.c:18:26: error: expected ';' at end of declaration\nlist 18 |     unsigned short field_-2; |                          ^ | ;\n/tmp/tmpcij9zwyf/in_cksum_name_conflict.c:48:14: error: invalid operands to binary expression\n('void *' and 'int') 48 |     v5 = (v4 >> 16) + v4; |           ~~ ^  ~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(in_cksum)(long long, long long);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nint(snprintf)(char *, unsigned long, char *, ...);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .6;\nextern char buf.10;\nextern char buf.4;\nextern unsigned int foreground;\nextern unsigned int g_408130;\nextern unsigned int g_408144;\nextern char g_40a5f1;\nextern unsigned short g_40a5f2;\nextern unsigned short g_40a5f4;\nextern unsigned short g_40a5f6;\nextern unsigned int g_40a5f8;\nextern char g_40a5fc;\nextern unsigned long long msg.7;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long send_ping_name_conflict(unsigned long a0, unsigned long a1) {\n  timeval v0; // [bp-0x28]\n  char v1;    // [bp-0x20]\n\n  g_408144 = a1;\n  g_408130 = a0;\n  buf.10 = 8;\n  g_40a5f1 = 0;\n  g_40a5f4 = ping_id;\n  g_40a5f6 = 0;\n  g_40a5f2 = 0;\n  g_40a5f8 = a0;\n  strncpy(&g_40a5fc, \"WGPM\", 4);\n  g_40a5f2 = in_cksum(&buf.10, 16);\n  if (sendmsg(ping_sock, &msg.7, 4) >= 0) {\n    return 0;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1,\n             (unsigned int)a1 / 0x100, (unsigned int)a1 / 0x10000,\n             (unsigned int)a1 / 0x1000000);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .6, (unsigned int)a0, &buf.4,\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1,\n             (unsigned int)a1 / 0x100, (unsigned int)a1 / 0x10000,\n             (unsigned int)a1 / 0x1000000);\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:25:6: error: conflicting types for 'snprintf'\n   25 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:34:13: error: expected identifier or '('\n   34 | extern char __func__.6;\n      |             ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:35:16: error: expected ';' after top level\ndeclarator 35 | extern char buf.10; |                ^ |                ;\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:36:16: error: expected ';' after top level\ndeclarator 36 | extern char buf.4; |                ^ |                ;\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:46:30: error: expected ';' after top level\ndeclarator 46 | extern unsigned long long msg.7; | ^ | ;\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:49:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 49 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:49:22: error: expected ';' after top level\ndeclarator 49 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:58:8: error: expected ';' after expression\n   58 |     buf.10 = 8;\n      |        ^\n      |        ;\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:58:12: error: expression is not assignable\n   58 |     buf.10 = 8;\n      |        ~~~ ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:65:29: error: expected ')'\n   65 |     g_40a5f2 = in_cksum(&buf.10, 16);\n      |                             ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:65:24: note: to match this '('\n   65 |     g_40a5f2 = in_cksum(&buf.10, 16);\n      |                        ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:66:32: error: expected ')'\n   66 |     if (sendmsg(ping_sock, &msg.7, 4) >= 0)\n      |                                ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:66:16: note: to match this '('\n   66 |     if (sendmsg(ping_sock, &msg.7, 4) >= 0)\n      |                ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:73:22: error: expected ')'\n   73 |         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned\nint)a1 / 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:73:17: note: to match this '('\n   73 |         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned\nint)a1 / 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:74:23: error: expected ')'\n   74 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, &buf.4, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:74:16: note: to match this '('\n   74 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: sendmsg %d %s\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.6,\n(unsigned int)a0, &buf.4, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:79:18: error: indirection requires pointer operand\n('int' invalid) 79 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp1qz8gkdj/send_ping_name_conflict.c:80:22: error: expected ')' 80\n|         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned int)a1\n/ 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n/tmp/tmp1qz8gkdj/send_ping_name_conflict.c:80:17: note: to match this '('\n   80 |         snprintf(&buf.4, 16, \"%d.%d.%d.%d\", (unsigned int)a1, (unsigned\nint)a1 / 0x100, (unsigned int)a1 / 0x10000, (unsigned int)a1 / 0x1000000); | ^\n15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(in_cksum)(long long, long long);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern void buf.3;\nextern unsigned int foreground;\nextern unsigned int g_409fe4;\nextern char g_40a014;\nextern char g_40a015;\nextern unsigned short g_40a018;\nextern unsigned short g_40a01a;\nextern unsigned int g_40a01c;\nextern unsigned int g_40a020;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern sockaddr src.2;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_ping_name_conflict(unsigned int *a0, unsigned int *a1) {\n  timeval v0;            // [bp-0x48]\n  char v1;               // [bp-0x40]\n  unsigned int v2;       // [bp-0x2c]\n  unsigned long long v4; // rbx\n\n  v2 = 16;\n  v4 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v2);\n  if ((unsigned int)v4 > 27) {\n    if (src.2.sin_family != 2) {\n      return 4294967295;\n    } else if (g_40a018 != ping_id) {\n      return 4294967295;\n    } else if (g_40a01a) {\n      return 4294967295;\n    } else if (!(!g_40a014) || !(!g_40a015)) {\n      return 4294967295;\n    } else if ((unsigned int)v4 > 35) {\n      if ((short)in_cksum(&buf.3, v4)) {\n        if (foreground) {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: checksum error\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .1);\n          return 4294967295;\n        }\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\");\n        return 4294967295;\n      } else {\n        if (g_40a020 == 1297106775) {\n          *(a0) = g_40a01c;\n          *(a1) = g_409fe4;\n          return 0;\n        } else if (foreground) {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: signature error\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .1);\n          return 4294967295;\n        } else {\n          syslog(3,\n                 \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\");\n          return 4294967295;\n        }\n      }\n    } else {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg too small\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .1);\n        return 4294967295;\n      }\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\");\n      return 4294967295;\n    }\n  } else {\n    if (!foreground) {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\");\n      return 4294967295;\n    }\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .1, (unsigned int)v4,\n            (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:37:13: error: expected identifier or '('\n   37 | extern char __func__.1;\n      |             ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:38:16: error: expected ';' after top level\ndeclarator 38 | extern void buf.3; |                ^ |                ;\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:49:8: error: unknown type name 'sockaddr'\n   49 | extern sockaddr src.2;\n      |        ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:49:20: error: expected ';' after top level\ndeclarator 49 | extern sockaddr src.2; |                    ^ | ;\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:50:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 50 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:50:22: error: expected ';' after top level\ndeclarator 50 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:60:34: error: expected ')'\n   60 |     v4 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v2);\n      |                                  ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:60:18: note: to match this '('\n   60 |     v4 = recvfrom(ping_sock, &buf.3, 1500, 64, &src.2.sin_family, &v2);\n      |                  ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:63:16: error: expected ')'\n   63 |         if (src.2.sin_family != 2)\n      |                ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:63:12: note: to match this '('\n   63 |         if (src.2.sin_family != 2)\n      |            ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:81:37: error: expected ')'\n   81 |             if ((short)in_cksum(&buf.3, v4))\n      |                                     ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:81:32: note: to match this '('\n   81 |             if ((short)in_cksum(&buf.3, v4))\n      |                                ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:86:35: error: expected ')'\n   86 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                                   ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:86:28: note: to match this '('\n   86 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nchecksum error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                            ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:103:35: error: expected ')'\n  103 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsignature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                                   ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:103:28: note: to match this '('\n  103 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsignature error\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                            ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:118:31: error: expected ')'\n  118 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                               ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:118:24: note: to match this '('\n  118 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: msg\ntoo small\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                        ^ /tmp/tmp64a7uano/recv_ping_name_conflict.c:129:22:\nerror: indirection requires pointer operand ('int' invalid) 129 |\nstrerror(*(__errno_location())); |                      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:134:23: error: expected ')'\n  134 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len\n%d %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)v4, (unsigned int)strerror(*(__errno_location())));\n      |                       ^\n/tmp/tmp64a7uano/recv_ping_name_conflict.c:134:16: note: to match this '('\n  134 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvmsg len\n%d %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1, (unsigned int)v4, (unsigned int)strerror(*(__errno_location())));\n      |                ^\n14 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(setsockopt)(int, int, int, void *, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nint(close)(int);\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned short ping_id;\nextern unsigned int ping_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long open_ping_name_conflict() {\n  timeval v0;      // [bp-0x28]\n  char v1;         // [bp-0x20]\n  unsigned int v2; // [bp-0xc]\n\n  v2 = 1;\n  ping_sock = socket(2, 3, 1);\n  if (ping_sock >= 0) {\n    if (setsockopt(ping_sock, 0, 2, &v2, 4) < 0) {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n      } else {\n        strerror(*(__errno_location()));\n        syslog(\n            3,\n            \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\");\n      }\n    } else {\n      if (setsockopt(ping_sock, 0, 8, &v2, 4) >= 0) {\n        ping_id = __ROL__((short)getpid(), 8);\n        return ping_sock;\n      }\n      if (!foreground) {\n        strerror(*(__errno_location()));\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt \"\n                  \"IP_PKTINFO %s\\\"}\");\n      } else {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n      }\n    }\n    close(ping_sock);\n    return 4294967295;\n  } else if (!foreground) {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\");\n    return 4294967295;\n  } else {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:35:13: error: expected identifier or '('\n   35 | extern char __func__.0;\n      |             ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:39:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 39 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:39:22: error: expected ';' after top level\ndeclarator 39 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:56:31: error: expected ')'\n   56 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:56:24: note: to match this '('\n   56 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_TTL %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:60:26: error: indirection requires pointer operand\n('int' invalid) 60 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpb1qrbfi9/open_ping_name_conflict.c:73:26: error: indirection\nrequires pointer operand ('int' invalid) 73 | strerror(*(__errno_location()));\n      |                          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:79:31: error: expected ')'\n   79 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:79:24: note: to match this '('\n   79 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nsetsockopt IP_PKTINFO %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:87:18: error: indirection requires pointer operand\n('int' invalid) 87 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpb1qrbfi9/open_ping_name_conflict.c:94:23: error: expected ')' 94\n|         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmpb1qrbfi9/open_ping_name_conflict.c:94:16: note: to match this '('\n   94 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); |                ^ 9 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\nvoid(syslog)(int, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nint(socket)(int, int, int);\nchar *(strerror)(int);\nint(setsockopt)(int, int, int, void *, int);\nint(close)(int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(update_mpgw)(long long, long long);\nvoid(srandom)(unsigned int);\n\ntypedef struct struct_0 {\n  uint128_t field_0;\n  uint128_t field_10;\n  uint128_t field_20;\n  uint128_t field_30;\n  unsigned long long field_40;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_1;\n\nextern char __func__ .0;\nextern char __func__ .1;\nextern char buf.2;\nextern unsigned int foreground;\nextern unsigned int mpgws[8];\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long add_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x9c]\n  unsigned short v1;      // [bp-0x98]\n  unsigned short v2;      // [bp-0x96]\n  unsigned int v3;        // [bp-0x94]\n  void *v4;               // [bp-0x90]\n  timeval v5;             // [bp-0x88]\n  char v6;                // [bp-0x80]\n  char v7;                // [bp-0x78]\n  char v8;                // [bp-0x70]\n  int v9;                 // [bp-0x68], Other Possible Types: unsigned int\n  void *v10;              // [bp-0x58]\n  char v11;               // [bp-0x48]\n  char v12;               // [bp-0x40]\n  unsigned int v15[8];    // rax, Other Possible Types: unsigned long\n  unsigned long v16;      // rbx\n  unsigned int v17[8];    // rdx, Other Possible Types: unsigned long\n  unsigned long v18;      // r13\n  unsigned int v19[8];    // rax\n  unsigned long long v20; // r14\n  unsigned long v21;      // rsi\n  unsigned int v22;       // ebp\n  struct_1 *v23;          // rax\n  unsigned int v24[8];    // r12\n  unsigned long long v25; // rcx\n  unsigned long long v26; // rax\n  unsigned long long v27; // rdx\n\n  v15 = &mpgws[0];\n  v16 = 4294967295;\n  v17 = 0;\n  do {\n    if (!*((int *)(v15 + 28))) {\n      if ((unsigned int)v16 == -1)\n        v16 = v17;\n    } else {\n      if (*((int *)v15) == (unsigned int)a0 &&\n          *((int *)(v15 + 24)) == (unsigned int)a1)\n        return &mpgws[18 * v17];\n    }\n  } while ((v17 = (unsigned long long)((unsigned int)v17 + 1), v15 += 72,\n            (unsigned int)v17 != 32));\n  if ((unsigned int)v16 != -1) {\n    if ((unsigned int)clock_gettime(0x1, &v11) >= 0) {\n      v19 = v16 * 8;\n      v20 = ((char *)v19 + v16) * 8;\n      v18 = (char *)&mpgws[0] + v20;\n      *((int128_t *)v18) = 0;\n      *((int128_t *)(v18 + 16)) = 0;\n      *((int128_t *)(v18 + 32)) = 0;\n      *((int128_t *)(v18 + 48)) = 0;\n      *((long long *)(v18 + 64)) = 0;\n      v21 = (char *)v19 + v16;\n      mpgws[2 * v21] = a0;\n      mpgws[6 + 2 * v21] = a1;\n      v22 = socket(2, 2, 0);\n      if (v22 < 0) {\n        if (foreground) {\n          gettimeofday(&v7, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket sock %s\\n\",\n                  (int)*((long long *)&v7), (int)*((long long *)&v8),\n                  &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n        } else {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\");\n        }\n        return 0;\n      } else {\n        *((int128_t *)&v7) = 0;\n        *((int128_t *)&v9) = 0;\n        v10 = 0;\n        v9 = mpgws[6 + 18 * v16];\n        if (ioctl(v22, 35088)) {\n          if (!foreground) {\n            strerror(*(__errno_location()));\n            syslog(\n                3,\n                \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\");\n          } else {\n            gettimeofday(&v5, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\",\n                    (int)*((long long *)&v5.tv_sec), (int)*((long long *)&v6),\n                    &__func__ .0, mpgws[6 + 18 * v16],\n                    (unsigned int)strerror(*(__errno_location())));\n          }\n        } else {\n          if (ioctl(v22, 35111)) {\n            if (foreground) {\n              gettimeofday(&v5, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\",\n                      (int)*((long long *)&v5.tv_sec), (int)*((long long *)&v6),\n                      &__func__ .0, (unsigned int)&v7,\n                      (unsigned int)strerror(*(__errno_location())));\n            } else {\n              strerror(*(__errno_location()));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR \"\n                        \"%s %s\\\"}\");\n            }\n          } else {\n            if ((short)v9 != 1) {\n              if (!foreground) {\n                syslog(\n                    3,\n                    \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\");\n              } else {\n                gettimeofday(&v5, NULL);\n                fprintf(stderr @GLIBC_2.2.5,\n                        \"%ld.%06ld [error] %s: invalid if %s\\n\",\n                        (int)*((long long *)&v5.tv_sec),\n                        (int)*((long long *)&v6), &__func__ .0,\n                        (unsigned int)&v7);\n              }\n            } else {\n              if (setsockopt(v22, 1, 25, &v7, (unsigned int)strlen(&v7) + 1) <\n                  0) {\n                if (!foreground) {\n                  strerror(*(__errno_location()));\n                  syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt \"\n                            \"%s %s\\\"}\");\n                } else {\n                  gettimeofday(&v5, NULL);\n                  fprintf(stderr @GLIBC_2.2.5,\n                          \"%ld.%06ld [error] %s: setsockopt %s %s\\n\",\n                          (int)*((long long *)&v5.tv_sec),\n                          (int)*((long long *)&v6), &__func__ .0,\n                          (unsigned int)&v7,\n                          (unsigned int)strerror(*(__errno_location())));\n                }\n              } else {\n                v4 = 0;\n                v1 = 2;\n                v2 = 260;\n                v3 = mpgws[18 * v16];\n                if (connect(v22, &v1, 16) < 0) {\n                  if (!foreground) {\n                    strerror(*(__errno_location()));\n                    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", mpgws[18 * v16],\n                             mpgws[18 * v16] >> 8,\n                             (unsigned int)(mpgws[18 * v16] >> 16),\n                             (unsigned int)(mpgws[18 * v16] >> 24));\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect \"\n                              \"to %s from %s %s\\\"}\");\n                  } else {\n                    gettimeofday(&v5, NULL);\n                    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", mpgws[18 * v16],\n                             mpgws[18 * v16] >> 8,\n                             (unsigned int)(mpgws[18 * v16] >> 16),\n                             (unsigned int)(mpgws[18 * v16] >> 24));\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\",\n                            (int)*((long long *)&v5.tv_sec),\n                            (int)*((long long *)&v6), &__func__ .0, &buf.2,\n                            (unsigned int)&v7,\n                            (unsigned int)strerror(*(__errno_location())));\n                  }\n                } else {\n                  v0 = 16;\n                  if (getsockname(v22, &v1, &v0) >= 0) {\n                    v23 = 16 + (char *)&mpgws[0] + v20;\n                    v23->field_0 = (int)(&v9)[2];\n                    v23->field_4 = (short)(&v9)[6];\n                    v24 = v16 * 8;\n                    *((unsigned int *)(12 + (char *)&mpgws[0] + 0x8 * v24 +\n                                       8 * v16)) = v3;\n                    close(v22);\n                    v25 = (char *)v24 + v16;\n                    v26 = *((long long *)&v11);\n                    v27 = *((long long *)&v12);\n                    *((unsigned long long *)&mpgws[8 + 2 * v25]) = v26;\n                    *((unsigned long long *)&mpgws[10 + 2 * v25]) = v27;\n                    *((unsigned long long *)&mpgws[12 + 2 * v25]) = v26;\n                    *((unsigned long long *)&mpgws[14 + 2 * v25]) = v27;\n                    update_mpgw(v18, 1);\n                    srandom(*(\n                        (int *)(12 + (char *)&mpgws[0] + 0x8 * v24 + 8 * v16)));\n                    return (char *)&mpgws[0] + v20;\n                  }\n                  if (foreground) {\n                    gettimeofday(&v5, NULL);\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: getsockname %s %s\\n\",\n                            (int)*((long long *)&v5.tv_sec),\n                            (int)*((long long *)&v6), &__func__ .0,\n                            (unsigned int)&v7,\n                            (unsigned int)strerror(*(__errno_location())));\n                  } else {\n                    strerror(*(__errno_location()));\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                              \"getsockname %s %s\\\"}\");\n                  }\n                }\n              }\n            }\n          }\n        }\n        close(v22);\n        return 0;\n      }\n    } else if (!foreground) {\n      strerror(*(__errno_location()));\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\");\n      return 0;\n    } else {\n      gettimeofday(&v7, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (int)*((long long *)&v7), (int)*((long long *)&v8), &__func__ .1,\n              (unsigned int)strerror(*(__errno_location())));\n      return 0;\n    }\n  } else {\n    if (foreground) {\n      gettimeofday(&v7, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: not enough memory\\n\",\n              (int)*((long long *)&v7), (int)*((long long *)&v8), &__func__ .1);\n      return 0;\n    }\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\");\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:38:6: error: conflicting types for 'snprintf'\n   38 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:43:5: error: unknown type name 'uint128_t'\n   43 |     uint128_t field_0;\n      |     ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:44:5: error: unknown type name 'uint128_t'\n   44 |     uint128_t field_10;\n      |     ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:45:5: error: unknown type name 'uint128_t'\n   45 |     uint128_t field_20;\n      |     ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:46:5: error: unknown type name 'uint128_t'\n   46 |     uint128_t field_30;\n      |     ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:61:13: error: expected identifier or '('\n   61 | extern char __func__.0;\n      |             ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:62:13: error: expected identifier or '('\n   62 | extern char __func__.1;\n      |             ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:63:16: error: expected ';' after top level\ndeclarator 63 | extern char buf.2; |                ^ |                ;\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:66:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 66 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:66:22: error: expected ';' after top level\ndeclarator 66 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:97:9: error: array type 'unsigned int[8]' is not\nassignable 97 |     v15 = &mpgws[0]; |     ~~~ ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:99:9: error: array type 'unsigned int[8]' is not\nassignable 99 |     v17 = 0; |     ~~~ ^ /tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:110:34:\nerror: invalid operands to binary expression ('int' and 'unsigned int[8]') 110 |\nreturn &mpgws[18 * v17]; |                               ~~ ^ ~~~\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:112:19: error: array type 'unsigned int[8]' is not\nassignable 112 |     } while ((v17 = (unsigned long long)((unsigned int)v17 +\n1), v15 += 72, (unsigned int)v17 != 32)); |               ~~~ ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:112:70: error: invalid operands to binary expression\n('unsigned int[8]' and 'int') 112 |     } while ((v17 = (unsigned long\nlong)((unsigned int)v17 + 1), v15 += 72, (unsigned int)v17 != 32)); | ~~~ ^  ~~\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:117:17: error: array type 'unsigned int[8]' is not\nassignable 117 |             v19 = v16 * 8; |             ~~~ ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:118:39: error: invalid operands to binary expression\n('char *' and 'int') 118 |             v20 = ((char *)v19 + v16) * 8; |\n~~~~~~~~~~~~~~~~~~~ ^ ~ /tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:120:26: error: expected\nexpression 120 |             *((int128_t *)v18) = 0; | ^\n/tmp/tmp5wf7x5y6/add_mpgw_name_conflict.c:121:26: error: expected expression\n  121 |             *((int128_t *)(v18 + 16)) = 0;\n      |                          ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned int mpgws[8];\n\nlong long find_mpgw_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v1[8]; // rax, Other Possible Types: unsigned long\n  void *v2;           // rdx, Other Possible Types: unsigned long\n\n  v1 = &mpgws[0];\n  v2 = 0;\n  while (true) {\n    if (*((int *)(v1 + 28)) && *((int *)v1) == (unsigned int)a0 &&\n        *((int *)(v1 + 24)) == (unsigned int)a1)\n      return &mpgws[18 * v2];\n    v2 = (unsigned int)v2 + 1;\n    v1 += 72;\n    if ((unsigned int)v2 == 32)\n      return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9by3akyw/find_mpgw_name_conflict.c:24:8: error: array type 'unsigned int[8]' is not\nassignable 24 |     v1 = &mpgws[0]; |     ~~ ^\n/tmp/tmp9by3akyw/find_mpgw_name_conflict.c:29:30: error: invalid operands to binary expression\n('int' and 'void *') 29 |             return &mpgws[18 * v2]; | ~~ ^ ~~\n/tmp/tmp9by3akyw/find_mpgw_name_conflict.c:31:12: error: invalid operands to binary expression\n('unsigned int[8]' and 'int') 31 |         v1 += 72; |         ~~ ^  ~~ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char buf.2;\nextern unsigned int foreground;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long update_mpgw_name_conflict(unsigned int a0[17], unsigned long a1) {\n  timeval v0;            // [bp-0x38]\n  char v1;               // [bp-0x30]\n  unsigned long long v4; // rax\n  unsigned long long v5; // rax\n\n  if (a0[7] == (unsigned int)a1)\n    return 0;\n  if (!foreground) {\n    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8,\n             (unsigned int)(a0[0] >> 16), (unsigned int)(a0[0] >> 24));\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\");\n  } else {\n    gettimeofday(&v0, NULL);\n    snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8,\n             (unsigned int)(a0[0] >> 16), (unsigned int)(a0[0] >> 24));\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state %d\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &buf.2,\n            a0[6], (unsigned int)a1);\n  }\n  a0[7] = a1;\n  if ((unsigned int)a1 == 1) {\n    v5 = random();\n    a0[16] = (unsigned int)(v5 - ((v5 * 2361183241434822607 >> 64 >> 7) -\n                                  (v5 >> 63)) *\n                                     1000) +\n             1010;\n    return a1;\n  }\n  v4 = random();\n  a0[16] = (unsigned int)(v4 - ((v4 * 5037190915060954895 >> 64 >> 13) -\n                                (v4 >> 63)) *\n                                   30000) +\n           60000;\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:16:6: error: conflicting types for 'snprintf'\n   16 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:33:16: error: expected ';' after top level\ndeclarator 33 | extern char buf.2; |                ^ |                ;\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:35:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 35 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:35:22: error: expected ';' after top level\ndeclarator 35 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:48:22: error: expected ')'\n   48 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                      ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:48:17: note: to match this '('\n   48 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                 ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:54:22: error: expected ')'\n   54 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                      ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:54:17: note: to match this '('\n   54 |         snprintf(&buf.2, 16, \"%d.%d.%d.%d\", a0[0], a0[0] >> 8, (unsigned\nint)(a0[0] >> 16), (unsigned int)(a0[0] >> 24)); |                 ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:55:23: error: expected ')'\n   55 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &buf.2, a0[6],\n(unsigned int)a1); |                       ^\n/tmp/tmpym5ro6ak/update_mpgw_name_conflict.c:55:16: note: to match this '('\n   55 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [info] %s if %d state\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &buf.2, a0[6],\n(unsigned int)a1); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static int process_ping(void) {\n    int ifindex;\n    __be32 addr;\n    struct mpgw *gw;\n    if (recv_ping(&ifindex, &addr) < 0)\n        return 0;\n    if ((gw = find_mpgw(addr, ifindex)) == ((void *)0))\n        return 0;\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (memcmp(gw->gw_hw, \"\\000\\000\\000\\000\\000\\000\", 6) == 0)\n        return 1;\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (gratuitous_arp)\n        send_garp(gw->if_id, gw->gw_ip, gw->gw_hw, gw->if_ip, gw->if_hw);\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int process_arp(void) {\n    int ifindex;\n    __u16 type, op;\n    __be32 sip, tip;\n    char sha[6], tha[6];\n    struct mpgw *gw;\n    if (recv_arp(&ifindex, &type, &op, &sip, sha, &tip, tha) < 0)\n        return 0;\n    if ((gw = find_mpgw(sip, ifindex)) == ((void *)0))\n        return 0;\n    if (tip == gw->if_ip && type == 1 && op == 2)\n        return 0;\n    if (memcmp(gw->gw_hw, sha, 6)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [info] gw %s on if %d changed mac to %s\\n\", tv.tv_sec, tv.tv_usec, ip2str(sip), ifindex, hw2str(sha));\n            } else\n                syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": gw %s on if %d changed mac to %s\\\"}\", ip2str(sip), ifindex, hw2str(sha));\n        });\n        memcpy(gw->gw_hw, sha, 6);\n    }\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (master_election && type == 1 && op == 2) {\n        if (tip < gw->if_ip)\n            gw->timeout = (1000 + 10 + random() % (1000));\n        else\n            gw->timeout = 1000;\n    }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int refresh(void) {\n    int i, diff, timeout = 1000;\n    struct timespec now;\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return timeout;\n    }\n    for (i = 0; i < 32; i++) {\n        struct mpgw *gw = &mpgws[i];\n        if (gw->state == MPGW_S_UNUSED)\n            continue;\n        diff = (((&now)->tv_sec - (&gw->last_rcvd)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_rcvd)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            if (gw->timeout != 1000)\n                continue;\n        }\n        if (gw->state == MPGW_S_PROBE && diff > 3 * gw->timeout && update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 0) == 0) {\n            update_mpgw(gw, MPGW_S_FAILED);\n            memset(&gw->gw_hw, 0, sizeof (6));\n        }\n        diff = (((&now)->tv_sec - (&gw->last_sent)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_sent)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            continue;\n        }\n        send_ping(gw->if_id, gw->gw_ip);\n        gw->last_sent = now;\n        if (timeout > gw->timeout)\n            timeout = gw->timeout;\n    }\n    return timeout;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint eax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long rta_find(unsigned short a0[2], unsigned long long a1,\n                   unsigned long a2) {\n  unsigned long long v1; // rcx\n  unsigned long long v3; // rcx\n  unsigned long long v4; // rax\n\n  if ((unsigned int)a1 <= 3)\n    return 0;\n  while ((unsigned short)v1 << 48 > 0x3000000000000) {\n    v1 = *((short *)a0);\n    if ((unsigned short)v1 > eax<4>) {\n      return 0;\n    } else if (*((short *)(a0 + 2)) == (unsigned int)a2) {\n      return a0;\n    } else {\n      v3 = (unsigned int)v1 + 3 & -0x4;\n      v4 = a1 - v3;\n      a1 = v4;\n      a0 += v3;\n      if ((unsigned int)v4 <= 3)\n        return 0;\n    }\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2rcr73i4/rta_find.c:29:40: error: expected expression\n   29 |         if ((unsigned short)v1 > eax<4>)\n      |                                        ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(reset_mpgws)();\nlong(send)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong(recv)(int, void *, unsigned long, int);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\nlong long(rta_find)(long long, long long, long long);\nlong long(add_mpgw)(long long, long long);\n\ntypedef struct struct_3 {\n  unsigned int field_0;\n  unsigned short field_4;\n  char padding_6[2];\n  unsigned int field_8;\n  char padding_c[4];\n  unsigned int field_10;\n  char padding_14[2];\n  char field_16;\n} struct_3;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n} struct_0;\n\ntypedef struct struct_2 {\n  char padding_0[4];\n  unsigned int field_4;\n} struct_2;\n\nextern char __func__ .3;\nextern char __func__ .4;\nextern unsigned int foreground;\nextern struct_1 recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long get_nhs_name_conflict() {\n  timeval v0;             // [bp-0x68]\n  char v1;                // [bp-0x60]\n  unsigned int v2;        // [bp-0x58]\n  unsigned short v3;      // [bp-0x54]\n  unsigned short v4;      // [bp-0x52]\n  unsigned int v5;        // [bp-0x50]\n  void *v6;               // [bp-0x4c]\n  char v7;                // [bp-0x48]\n  unsigned long v9;       // rdx, Other Possible Types: unsigned long long\n  unsigned int *v10;      // rax\n  unsigned int v11;       // edi\n  unsigned int v12;       // eax\n  unsigned short v13;     // cx\n  unsigned long long v14; // rax\n  unsigned short *v15;    // rax\n  unsigned int v16;       // esi\n  struct_2 *v17;          // rax\n  unsigned long long v18; // rax\n  unsigned long v19;      // r13, Other Possible Types: unsigned long long\n  struct_0 *v20;          // r12, Other Possible Types: unsigned long\n  unsigned long long v21; // rax\n  struct_3 *v22;          // rbx, Other Possible Types: unsigned long\n  unsigned int v24;       // edx\n\n  reset_mpgws();\n  v6 = 0;\n  v2 = 20;\n  v3 = 26;\n  v4 = 257;\n  talk_seq = talk_seq + 1;\n  v5 = talk_seq;\n  v7 = 2;\n  if (send(talk_sock, &v2, 20, 0) >= 0) {\n    do {\n      while (true) {\n        v9 = recv(talk_sock, &recv_buf.field_0, 0x4000, 0);\n        if ((unsigned int)v9 >= 0) {\n          if ((unsigned int)v9) {\n            if ((unsigned int)v9 > 15) {\n              v22 = &recv_buf.field_0;\n              while (true) {\n                v12 = *((int *)v22);\n                if (!(v12 > 15) || !((unsigned int)v9 >= v12))\n                  break;\n                if (*((int *)(v22 + 8)) != talk_seq) {\n                  if (foreground) {\n                    gettimeofday(&v0, NULL);\n                    fprintf(stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                            (int)*((long long *)&v0.tv_sec),\n                            (int)*((long long *)&v1), &__func__ .4,\n                            *((int *)(v22 + 8)));\n                  } else {\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid \"\n                              \"seq %d\\\"}\");\n                  }\n                } else {\n                  v13 = *((short *)(v22 + 4));\n                  if (v13 == 3)\n                    return 0;\n                  if (v13 == 2) {\n                    if (v12 > 35) {\n                      v24 = *((int *)(v22 + 16));\n                      if (!v24)\n                        return 4294967295;\n                      if (foreground) {\n                        gettimeofday(&v0, NULL);\n                        fprintf(\n                            stderr @GLIBC_2.2.5,\n                            \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                            (int)*((long long *)&v0.tv_sec),\n                            (int)*((long long *)&v1), &__func__ .4,\n                            (unsigned int)strerror(-(*((int *)(v22 + 16)))));\n                        return 4294967295;\n                      }\n                      strerror(-(v24));\n                      syslog(\n                          3,\n                          \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n                      return 4294967295;\n                    } else {\n                      if (!foreground) {\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                  \"nlerr msg truncated\\\"}\");\n                        return 4294967295;\n                      }\n                      gettimeofday(&v0, NULL);\n                      fprintf(stderr @GLIBC_2.2.5,\n                              \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                              (int)*((long long *)&v0.tv_sec),\n                              (int)*((long long *)&v1), &__func__ .4);\n                      return 4294967295;\n                    }\n                  } else {\n                    if (v13 != 24) {\n                      if (foreground) {\n                        gettimeofday(&v0, NULL);\n                        fprintf(stderr @GLIBC_2.2.5,\n                                \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                                (int)*((long long *)&v0.tv_sec),\n                                (int)*((long long *)&v1), &__func__ .4,\n                                *((short *)(v22 + 4)));\n                      } else {\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                  \"invalid type %d\\\"}\");\n                      }\n                    } else {\n                      v14 = v12 - 28;\n                      if ((unsigned int)(v14 - 28) < 0) {\n                        if (foreground) {\n                          gettimeofday(&v0, NULL);\n                          fprintf(\n                              stderr @GLIBC_2.2.5,\n                              \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\",\n                              (int)*((long long *)&v0.tv_sec),\n                              (int)*((long long *)&v1), &__func__ .3,\n                              (unsigned int)v14);\n                        } else {\n                          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n                                    \"invalid nlmsg_len %d\\\"}\");\n                        }\n                        return 4294967295;\n                      } else {\n                        if (*((char *)(v22 + 16)) == 2 &&\n                            *((char *)(v22 + 22)) <= 252) {\n                          v15 = rta_find(v22 + 28, v14, 9);\n                          if (v15) {\n                            v19 = *(v15)-4;\n                            v20 = v15 + 2;\n                            if ((unsigned int)v19 > 7) {\n                              while (true) {\n                                v16 = *((short *)v20);\n                                if ((unsigned int)v19 < v16)\n                                  break;\n                                v17 = rta_find(v20 + 8, v16 - 8, 5);\n                                if (!v17) {\n                                  if (foreground) {\n                                    gettimeofday(&v0, NULL);\n                                    fprintf(stderr @GLIBC_2.2.5,\n                                            \"%ld.%06ld [error] %s: no gateway \"\n                                            \"in nh info\\n\",\n                                            (int)*((long long *)&v0.tv_sec),\n                                            (int)*((long long *)&v1),\n                                            &__func__ .3);\n                                    break;\n                                  } else {\n                                    syslog(3,\n                                           \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \"\n                                           \"\\\"%s no gateway in nh info\\\"}\");\n                                    break;\n                                  }\n                                } else {\n                                  if (!add_mpgw(v17->field_4,\n                                                *((int *)(v20 + 4))))\n                                    return 4294967295;\n                                  v18 = *((short *)v20) + 3 & 0xfffffffc;\n                                  v19 -= v18;\n                                  v20 += v18;\n                                  if ((unsigned int)v19 <= 7)\n                                    break;\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n                v21 = *((int *)v22) + 3 & -0x4;\n                v9 -= v21;\n                v22 += v21;\n                if ((unsigned int)v9 <= 15)\n                  break;\n              }\n            }\n          } else {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .4);\n              return 4294967295;\n            }\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n            return 4294967295;\n          }\n        } else {\n          v10 = __errno_location();\n          v11 = *(v10);\n          if (v11 != 4)\n            break;\n        }\n      }\n    } while (v11 == 11);\n    if (!foreground) {\n      strerror(v11);\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n      return 4294967295;\n    }\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .4, (unsigned int)strerror(*(v10)));\n    return 4294967295;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .4, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:59:13: error: expected identifier or '('\n   59 | extern char __func__.3;\n      |             ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:60:13: error: expected identifier or '('\n   60 | extern char __func__.4;\n      |             ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:62:8: error: unknown type name 'struct_1'\n   62 | extern struct_1 recv_buf;\n      |        ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:63:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 63 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:63:22: error: expected ';' after top level declarator\n   63 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:125:55: error: expected ')'\n  125 |                                         fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, *((int *)(v22 + 8))); | ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:125:48: note: to match this '('\n  125 |                                         fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4, *((int *)(v22 + 8))); | ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:147:63: error: expected ')'\n  147 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(-(*((int *)(v22 + 16))))); | ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:147:56: note: to match this '('\n  147 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(-(*((int *)(v22 + 16))))); | ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:162:59: error: expected ')'\n  162 |                                             fprintf(stderr@GLIBC_2.2.5,\n\"%ld.%06ld [error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.4); | ^ /tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:162:52:\nnote: to match this '(' 162 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nnlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                                                    ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:173:63: error: expected ')'\n  173 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid type %d\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4, *((short\n*)(v22 + 4))); |                                                               ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:173:56: note: to match this '('\n  173 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid type %d\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4, *((short\n*)(v22 + 4))); |                                                        ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:188:67: error: expected ')'\n  188 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid nlmsg_len\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)v14); | ^ /tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:188:60: note: to match this\n'(' 188 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid nlmsg_len\n%d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3,\n(unsigned int)v14); | ^ /tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:218:87: error: expected ')'\n  218 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: no gateway in nh\ninfo\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.3); | ^ /tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:218:80: note: to match this '(' 218\n| fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: no gateway in nh info\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.3); | ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:258:43: error: expected ')'\n  258 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: recv len == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                                           ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:258:36: note: to match this '('\n  258 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: recv len == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.4); |                                    ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:281:23: error: expected ')'\n  281 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(v10))); |                       ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:281:16: note: to match this '('\n  281 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(v10))); |                ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:287:23: error: expected ')'\n  287 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:287:16: note: to match this '('\n  287 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.4,\n(unsigned int)strerror(*(__errno_location()))); |                ^\n/tmp/tmpxwdi0h5_/get_nhs_name_conflict.c:292:18: error: indirection requires pointer operand\n('int' invalid) 292 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 15 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nlong(recv)(int, void *, unsigned long, int);\nchar *(strerror)(int);\nvoid(syslog)(int, char *, ...);\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .2;\nextern unsigned int foreground;\nextern unsigned short g_40a624;\nextern unsigned int g_40a628;\nextern unsigned int g_40a630;\nextern unsigned int recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long update_neigh(unsigned long a0, unsigned long a1, struct_0 *a2,\n                       unsigned long a3) {\n  timeval v0;             // [bp-0x58]\n  char v1;                // [bp-0x50]\n  unsigned int v2;        // [bp-0x48]\n  unsigned short v3;      // [bp-0x44]\n  unsigned short v4;      // [bp-0x42]\n  unsigned int v5;        // [bp-0x40]\n  int v6;                 // [bp-0x3c]\n  char v7;                // [bp-0x38]\n  unsigned int v8;        // [bp-0x34]\n  unsigned short v9;      // [bp-0x30]\n  unsigned short v10;     // [bp-0x2c]\n  unsigned short v11;     // [bp-0x2a]\n  unsigned int v12;       // [bp-0x28]\n  unsigned short v13;     // [bp-0x24]\n  unsigned short v14;     // [bp-0x22]\n  unsigned int v15;       // [bp-0x20]\n  unsigned int v16;       // [bp-0x1c], Other Possible Types: unsigned short\n  unsigned long long v18; // rax\n  unsigned int *v19;      // rax\n  unsigned int v20;       // edi\n\n  *((int128_t *)&v6) = 0;\n  v16 = 0;\n  v2 = 48;\n  v3 = 28;\n  talk_seq = talk_seq + 1;\n  v5 = talk_seq;\n  v4 = 1285;\n  v7 = 2;\n  v8 = a0;\n  v9 = (-((unsigned int)a3 < 1) & 30) + 2;\n  v10 = 8;\n  v11 = 1;\n  v12 = a1;\n  v13 = 10;\n  v14 = 2;\n  v15 = a2->field_0;\n  v16 = a2->field_4;\n  if (send(talk_sock, &v2, 48, 0) >= 0) {\n    while (true) {\n      (unsigned int)v18 = recv(talk_sock, &recv_buf, 0x4000, 0);\n      if ((unsigned int)v18 >= 0)\n        break;\n      v19 = __errno_location();\n      v20 = *(v19);\n      if (v20 == 4)\n        continue;\n      if (v20 != 11) {\n        if (foreground) {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv %s\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .2, (unsigned int)strerror(*(v19)));\n          return 4294967295;\n        }\n        strerror(v20);\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\");\n        return 4294967295;\n      }\n    }\n    if ((unsigned int)v18) {\n      if ((unsigned int)v18 > 15 && recv_buf > 15 &&\n          (unsigned int)v18 >= recv_buf) {\n        if (g_40a628 == talk_seq) {\n          if (g_40a624 == 2) {\n            if (recv_buf > 35) {\n              if (!g_40a630)\n                return g_40a630;\n              if (foreground) {\n                gettimeofday(&v0, NULL);\n                fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: nlerr %s\\n\",\n                        (int)*((long long *)&v0.tv_sec),\n                        (int)*((long long *)&v1), &__func__ .2,\n                        (unsigned int)strerror(-(g_40a630)));\n                return 0;\n              }\n              strerror(-(g_40a630));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\");\n              return foreground;\n            } else {\n              if (foreground) {\n                gettimeofday(&v0, NULL);\n                fprintf(stderr @GLIBC_2.2.5,\n                        \"%ld.%06ld [error] %s: nlerr msg truncated\\n\",\n                        (int)*((long long *)&v0.tv_sec),\n                        (int)*((long long *)&v1), &__func__ .2);\n                return 0;\n              }\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg \"\n                        \"truncated\\\"}\");\n              return foreground;\n            }\n          } else {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: invalid type %d\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .2, g_40a624);\n              return 4294967295;\n            }\n            syslog(3,\n                   \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\");\n            return 4294967295;\n          }\n        } else {\n          if (foreground) {\n            gettimeofday(&v0, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: invalid seq %d\\n\",\n                    (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                    &__func__ .2, g_40a628);\n            return 4294967295;\n          }\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\");\n          return 4294967295;\n        }\n      }\n      if (!foreground) {\n        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\");\n        return 4294967295;\n      }\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid len %d\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .2, (unsigned int)v18);\n      return 4294967295;\n    } else {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv len == 0\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .2);\n        return 4294967295;\n      }\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\");\n      return 4294967295;\n    }\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .2, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl9lwpdn1/update_neigh.c:40:13: error: expected identifier or '('\n   40 | extern char __func__.2;\n      |             ^\n/tmp/tmpl9lwpdn1/update_neigh.c:46:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpl9lwpdn1/update_neigh.c:46:22: error: expected ';' after top level\ndeclarator 46 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpl9lwpdn1/update_neigh.c:73:18: error: expected expression\n   73 |     *((int128_t *)&v6) = 0;\n      |                  ^\n/tmp/tmpl9lwpdn1/update_neigh.c:94:13: error: assignment to cast is illegal,\nlvalue casts are not supported 94 |             (unsigned int)v18 =\nrecv(talk_sock, &recv_buf, 0x4000, 0); |             ^~~~~~~~~~~~~~~~~ ~\n/tmp/tmpl9lwpdn1/update_neigh.c:106:35: error: expected ')'\n  106 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(*(v19))); | ^\n/tmp/tmpl9lwpdn1/update_neigh.c:106:28: note: to match this '('\n  106 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nrecv %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(*(v19))); |                            ^\n/tmp/tmpl9lwpdn1/update_neigh.c:129:47: error: expected ')'\n  129 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, (unsigned int)strerror(-(g_40a630))); | ^\n/tmp/tmpl9lwpdn1/update_neigh.c:129:40: note: to match this '('\n  129 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, (unsigned int)strerror(-(g_40a630))); | ^\n/tmp/tmpl9lwpdn1/update_neigh.c:141:47: error: expected ')'\n  141 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.2); | ^\n/tmp/tmpl9lwpdn1/update_neigh.c:141:40: note: to match this '('\n  141 |                                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: nlerr msg truncated\\n\", (int)*((long long *)&v0.tv_sec),\n(int)*((long long *)&v1), &__func__.2); | ^\n/tmp/tmpl9lwpdn1/update_neigh.c:153:43: error: expected ')'\n  153 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: invalid type %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.2, g_40a624); | ^ /tmp/tmpl9lwpdn1/update_neigh.c:153:36:\nnote: to match this '(' 153 | fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid type %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, g_40a624); |                                    ^\n/tmp/tmpl9lwpdn1/update_neigh.c:165:39: error: expected ')'\n  165 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, g_40a628); |                                       ^\n/tmp/tmpl9lwpdn1/update_neigh.c:165:32: note: to match this '('\n  165 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: invalid seq %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.2, g_40a628); |                                ^\n/tmp/tmpl9lwpdn1/update_neigh.c:178:27: error: expected ')'\n  178 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nlen %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)v18); |                           ^\n/tmp/tmpl9lwpdn1/update_neigh.c:178:20: note: to match this '('\n  178 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid\nlen %d\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)v18); |                    ^\n/tmp/tmpl9lwpdn1/update_neigh.c:186:31: error: expected ')'\n  186 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2); |                               ^\n/tmp/tmpl9lwpdn1/update_neigh.c:186:24: note: to match this '('\n  186 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recv\nlen == 0\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2); |                        ^ /tmp/tmpl9lwpdn1/update_neigh.c:196:23:\nerror: expected ')' 196 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: send %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.2, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpl9lwpdn1/update_neigh.c:196:16: note: to match this '('\n  196 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: send %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.2,\n(unsigned int)strerror(*(__errno_location()))); |                ^\n/tmp/tmpl9lwpdn1/update_neigh.c:201:18: error: indirection requires pointer\noperand ('int' invalid) 201 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 14 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recvfrom)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nlong long(get_nhs)();\nvoid(syslog)(int, char *, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .1;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern void recv_buf;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long recv_nl_name_conflict() {\n  timeval v0;      // [bp-0x28]\n  char v1;         // [bp-0x20]\n  unsigned int v2; // [bp-0x18]\n  sockaddr v3;     // [bp-0x14]\n  char v4;         // [bp-0x10]\n\n  v2 = 12;\n  if (recvfrom(poll_sock, &recv_buf, 0x4000, 64, &v3, &v2) < 0) {\n    if (foreground) {\n      gettimeofday(&v0, NULL);\n      fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom %s\\n\",\n              (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n              &__func__ .1, (unsigned int)strerror(*(__errno_location())));\n      return 0;\n    }\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\");\n    return foreground;\n  } else {\n    if (v2 != 12) {\n      if (foreground) {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .1);\n        return 0;\n      }\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\");\n      return foreground;\n    } else {\n      if (*((int *)&v4))\n        return 0;\n      get_nhs();\n      return 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:42:13: error: expected identifier or '('\n   42 | extern char __func__.1;\n      |             ^\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:46:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 46 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:46:22: error: expected ';' after top level declarator\n   46 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:62:27: error: expected ')'\n   62 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1,\n(unsigned int)strerror(*(__errno_location()))); |                           ^\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:62:20: note: to match this '('\n   62 |             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: recvfrom\n%s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1,\n(unsigned int)strerror(*(__errno_location()))); |                    ^\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:65:18: error: indirection requires pointer operand\n('int' invalid) 65 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpj1cdsimw/recv_nl_name_conflict.c:76:31: error: expected ')' 76 |\nfprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.1); | ^\n/tmp/tmpj1cdsimw/recv_nl_name_conflict.c:76:24: note: to match this '('\n   76 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ninvalid addr len\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.1); |                        ^ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(gettimeofday)(\n    struct timeval {\n      long tv_sec;\n      int64_t tv_usec;\n    } *,\n    struct timezone {\n      int tz_minuteswest;\n      int tz_dsttime;\n    } *);\nchar *(strerror)(int);\nint(getsockname)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nvoid(syslog)(int, char *, ...);\nlong(random)();\nint(close)(int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(get_nhs)();\n\ntypedef struct timeval {\n  unsigned int tv_sec;\n  char padding_4[4];\n  char tv_usec;\n} timeval;\n\nextern char __func__ .0;\nextern unsigned int foreground;\nextern unsigned int poll_sock;\nextern FILE_t *stderr @GLIBC_2.2.5;\nextern unsigned int talk_seq;\nextern unsigned int talk_sock;\n\nlong long open_nl_name_conflict() {\n  timeval v0;        // [bp-0x28]\n  char v1;           // [bp-0x20]\n  unsigned int v2;   // [bp-0x18]\n  unsigned short v3; // [bp-0x14]\n  void *v4;          // [bp-0x12], Other Possible Types: unsigned int\n  unsigned short v5; // [bp-0xe]\n  unsigned int v6;   // [bp-0xc]\n  unsigned short v7; // [bp-0xa]\n\n  v2 = 12;\n  v4 = 0;\n  v7 = 0;\n  v3 = 16;\n  talk_sock = socket(16, 3, 0);\n  if (talk_sock >= 0) {\n    if (connect(talk_sock, &v3, 12) < 0) {\n      if (!foreground) {\n        strerror(*(__errno_location()));\n        syslog(\n            3,\n            \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\");\n      } else {\n        gettimeofday(&v0, NULL);\n        fprintf(stderr @GLIBC_2.2.5,\n                \"%ld.%06ld [error] %s: connect talk_sock %s\\n\",\n                (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n      }\n    } else {\n      if (getsockname(talk_sock, &v3, &v2) < 0) {\n        if (!foreground) {\n          strerror(*(__errno_location()));\n          syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname \"\n                    \"talk_sock %s\\\"}\");\n        } else {\n          gettimeofday(&v0, NULL);\n          fprintf(stderr @GLIBC_2.2.5,\n                  \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\",\n                  (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                  &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n        }\n      } else {\n        talk_seq = random();\n        v4 = 0;\n        v5 = 0;\n        v3 = 16;\n        v6 = 64;\n        poll_sock = socket(16, 3, 0);\n        if (poll_sock < 0) {\n          if (foreground) {\n            gettimeofday(&v0, NULL);\n            fprintf(stderr @GLIBC_2.2.5,\n                    \"%ld.%06ld [error] %s: socket poll_sock %s\\n\",\n                    (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                    &__func__ .0,\n                    (unsigned int)strerror(*(__errno_location())));\n          } else {\n            strerror(*(__errno_location()));\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock \"\n                      \"%s\\\"}\");\n          }\n        } else {\n          if (bind(poll_sock, &v3, 12) < 0) {\n            if (foreground) {\n              gettimeofday(&v0, NULL);\n              fprintf(stderr @GLIBC_2.2.5,\n                      \"%ld.%06ld [error] %s: bind poll_sock %s\\n\",\n                      (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n                      &__func__ .0,\n                      (unsigned int)strerror(*(__errno_location())));\n            } else {\n              strerror(*(__errno_location()));\n              syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock \"\n                        \"%s\\\"}\");\n            }\n          } else {\n            if ((int)get_nhs() >= 0)\n              return poll_sock;\n          }\n          close(poll_sock);\n        }\n      }\n    }\n    close(talk_sock);\n    return 4294967295;\n  } else if (foreground) {\n    gettimeofday(&v0, NULL);\n    fprintf(stderr @GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\",\n            (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n            &__func__ .0, (unsigned int)strerror(*(__errno_location())));\n    return 4294967295;\n  } else {\n    strerror(*(__errno_location()));\n    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\");\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:48:13: error: expected identifier or '('\n   48 | extern char __func__.0;\n      |             ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:51:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 51 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:51:22: error: expected ';' after top level declarator\n   51 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:77:26: error: indirection requires pointer operand\n('int' invalid) 77 |                 strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpnhckq_ho/open_nl_name_conflict.c:83:31: error: expected ')' 83 |\nfprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:83:24: note: to match this '('\n   83 |                 fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\nconnect talk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:92:30: error: indirection requires pointer operand\n('int' invalid) 92 |                     strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpnhckq_ho/open_nl_name_conflict.c:98:35: error: expected ')' 98 |\nfprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\",\n(int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1), &__func__.0,\n(unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:98:28: note: to match this '('\n   98 |                     fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s:\ngetsockname talk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:114:39: error: expected ')'\n  114 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: socket poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:114:32: note: to match this '('\n  114 |                         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error]\n%s: socket poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long\n*)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:118:34: error: indirection requires pointer operand\n('int' invalid) 118 |                         strerror(*(__errno_location()));\n      |                                  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:129:43: error: expected ')'\n  129 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:129:36: note: to match this '('\n  129 |                             fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld\n[error] %s: bind poll_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long\nlong *)&v1), &__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:133:38: error: indirection requires pointer operand\n('int' invalid) 133 | strerror(*(__errno_location())); | ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:152:23: error: expected ')'\n  152 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.0, (unsigned int)strerror(*(__errno_location()))); | ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:152:16: note: to match this '('\n  152 |         fprintf(stderr@GLIBC_2.2.5, \"%ld.%06ld [error] %s: socket\ntalk_sock %s\\n\", (int)*((long long *)&v0.tv_sec), (int)*((long long *)&v1),\n&__func__.0, (unsigned int)strerror(*(__errno_location()))); |                ^\n/tmp/tmpnhckq_ho/open_nl_name_conflict.c:157:18: error: indirection requires pointer operand\n('int' invalid) 157 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 13 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_device(char *devname, long sig) {\n    struct sigaction sa = {.__sigaction_handler.sa_handler = sigio};\n    int fd;\n    printf(\"device file = %s\\n\", devname);\n    fd = open(devname, 0);\n    if (fd < 0) {\n        perror(\"open\");\n        return fd;\n    }\n    sigaction(sig, &sa, ((void *)0));\n    if (fcntl(fd, 8, getpid()) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 10, sig) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 4, 8192) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint sigio; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nchar *(sigaction)(char *, char *, char *);\nint(fcntl)(int, int, ...);\n\nlong long open_device_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  char v0;                // [bp-0xb8]\n  char v1;                // [bp-0xb0]\n  char *v3;               // rbx\n  unsigned long long *v4; // rdi, Other Possible Types: unsigned long\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  unsigned long v6;       // d\n  unsigned long long v7;  // rbx\n\n  v3 = a0;\n  v4 = &v1;\n  for (v5 = 18; v5; v4 += v6 * 8) {\n    v5 -= 1;\n    *((long long *)v4) = 0;\n  }\n  *((void **)&v0) = sigio;\n  printf(\"device file = %s\\n\", (unsigned int)v3);\n  v7 = open(v3, 0, a2);\n  if ((unsigned int)v7 < 0) {\n    perror(\"open\");\n    return v7;\n  }\n  sigaction(a1, &v0, NULL);\n  getpid();\n  if (fcntl(v7, 8) < 0) {\n    perror(\"fcntl\");\n    exit(1); /* do not return */\n  } else if (fcntl(v7, 10) < 0) {\n    perror(\"fcntl\");\n    exit(1); /* do not return */\n  } else if (fcntl(v7, 4) >= 0) {\n    return v7;\n  } else {\n    perror(\"fcntl\");\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9m6a96md/open_device_name_conflict.c:18:7: error: conflicting types for 'perror'\n   18 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/NeoCat_YUREX-driver-for-Linux/sample/timing-game.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long parson_strndup_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax\n\n  v1 = ::libc.so.0 ::malloc(a1 + 1);\n  if (v1) {\n    a1[v1] = 0;\n    strncpy(v1, a0, a1);\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpey7x0vlo/parson_strndup_name_conflict.c:22:10: error: expected expression\n   22 |     v1 = ::libc.so.0::malloc(a1 + 1);\n      |          ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_char_to_int_name_conflict(unsigned long a0) {\n  if (a0 - 48 <= 9) {\n    return a0 - 48;\n  } else if (a0 - 97 <= 5) {\n    return a0 - 87;\n  } else if (6 <= (a0 - 65 & 255)) {\n    return 4294967295;\n  } else {\n    return (char)a0 - 55;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(hex_char_to_int)(long long);\n\nlong long parse_utf16_hex_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned long v0;       // [bp-0x28]\n  unsigned long v1;       // [bp-0x20]\n  unsigned long v2;       // [bp-0x18]\n  unsigned long v3;       // [bp-0x10]\n  unsigned long v4;       // [bp-0x8]\n  unsigned long long v6;  // rdx\n  unsigned long v7;       // rax, Other Possible Types: unsigned long long\n  unsigned long v8;       // r14\n  unsigned long v9;       // r13\n  unsigned long v10;      // r12\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rbp\n  unsigned long long v13; // r12\n  unsigned long long v14; // r13\n  unsigned int v15;       // r14d\n  unsigned int v16;       // ebp\n  unsigned int v17;       // r12d\n  unsigned long long v18; // rax\n\n  v6 = a0[0];\n  v7 = 0;\n  if (!(char)v6)\n    return 0;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  v12 = a0[1];\n  if (!(char)v12)\n    return v7;\n  v13 = a0[2];\n  if ((char)v13) {\n    v14 = a0[3];\n    if ((char)v14) {\n      v15 = hex_char_to_int((char)v6);\n      v16 = hex_char_to_int((char)v12);\n      if (v15 == -1 || v16 == -1) {\n        v7 = 0;\n      } else {\n        v17 = hex_char_to_int((char)v13);\n        (unsigned int)v18 = hex_char_to_int((char)v14);\n        if (v17 == -1 || (unsigned int)v18 == -1) {\n          v7 = 0;\n        } else {\n          *(a1) = v15 * 0x1000 | v16 * 0x100 | (unsigned int)v18 | v17 * 16;\n          v7 = 1;\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2b9msu7b/parse_utf16_hex_name_conflict.c:67:17: error: assignment to cast is illegal,\nlvalue casts are not supported 67 |                 (unsigned int)v18 =\nhex_char_to_int((char)v14); |                 ^~~~~~~~~~~~~~~~~ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nvoid(rewind)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_file(char *a0) {\n  FILE_t *v1;       // rax\n  FILE_t *v2;       // rbx\n  unsigned long v3; // rbp\n  unsigned long v4; // r12\n  unsigned long v5; // r12\n\n  v1 = fopen(a0, \"r\");\n  v2 = v1;\n  if (!v1)\n    return v1;\n  fseek(v1, 0, 2);\n  v4 = ftell(v1);\n  if (v4 < 0) {\n    fclose(v2);\n    return 0;\n  }\n  rewind(v2);\n  v3 = ::libc.so.0 ::malloc(v4 + 1);\n  if (!v3) {\n    fclose(v2);\n    return v3;\n  }\n  v5 = fread(v3, 1, v4, v2);\n  if (v5 && !ferror(v2)) {\n    fclose(v2);\n    *((char *)(v3 + v5)) = 0;\n    return v3;\n  }\n  fclose(v2);\n  ::libc.so.0 ::free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6_7vt32u/read_file.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp6_7vt32u/read_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp6_7vt32u/read_file.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp6_7vt32u/read_file.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp6_7vt32u/read_file.c:251:13: error: declaration of anonymous union must\nbe a definition 251 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:254:22: error: type name requires a specifier or\nqualifier 254 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:258:13: error: declaration of anonymous union must\nbe a definition 258 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:261:22: error: type name requires a specifier or\nqualifier 261 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:194:7: error: conflicting types for 'rewind'\n  194 | void (rewind)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:723:13: note: previous declaration is here\n  723 | extern void rewind (FILE *__stream);\n      |             ^\n/tmp/tmp6_7vt32u/read_file.c:340:13: error: declaration of anonymous union must\nbe a definition 340 |             union <anon> { |             ^\n/tmp/tmp6_7vt32u/read_file.c:343:22: error: type name requires a specifier or\nqualifier 343 |             } __value; |                      ^\n/tmp/tmp6_7vt32u/read_file.c:347:13: error: declaration of anonymous union must\nbe a definition 347 |             union <anon> { |             ^ fatal error:\ntoo many errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16_hex)(long long, long long);\n\nlong long get_quoted_string_name_conflict(struct struct_0 **a0) {\n  char v5[2];             // r12\n  char v6[8];             // rbp\n  char v7;                // al\n  char v8[2];             // rax\n  char v9[8];             // rdx, Other Possible Types: unsigned long\n  char v11[8];            // rdx\n  unsigned long long v12; // rdx\n  char v14[4];            // rax\n  char v17[4];            // rbx, Other Possible Types: unsigned long\n\n  v5 = *(a0);\n  if (v5[0] != 34)\n    return 0;\n  v6 = &v5[1];\n  *(a0) = &v6[0];\n  v7 = v5[1];\n  if (v7 == 34) {\n    v9 = v6;\n  } else {\n    v9 = v6;\n    do {\n      if (!(v7) || !(v7 != 92) && !(!((*(a0) = (struct struct_0 *)(v9 + 1),\n                                       !*((char *)(v9 + 1))))))\n        return 0;\n    } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct struct_0 *)v9,\n              v7 = v8[1], v7 != 34));\n  }\n  v11 = v9 + 1;\n  *(a0) = &v11[0];\n  v12 = v11 - v5;\n  v14 = ::libc.so.0 ::malloc(v12 - 1);\n  if (!v14) {\n    ::libc.so.0 ::free(v14);\n    return 0;\n  } else if (!v5[1]) {\n    v17 = v14;\n  } else if (!v12 - 2) {\n    v17 = v14;\n  } else {\n    v17 = v14;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:30:8: error: array type 'char[2]' is not\nassignable 30 |     v5 = *(a0); |     ~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:33:8: error: array type 'char[8]' is not\nassignable 33 |     v6 = &v5[1]; |     ~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:38:12: error: array type 'char[8]' is not\nassignable 38 |         v9 = v6; |         ~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:42:12: error: array type 'char[8]' is not\nassignable 42 |         v9 = v6; |         ~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:47:22: error: array type 'char[2]' is not\nassignable 47 |         } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct\nstruct_0 *)v9, v7 = v8[1], v7 != 34)); |                   ~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:47:34: error: array type 'char[8]' is not\nassignable 47 |         } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct\nstruct_0 *)v9, v7 = v8[1], v7 != 34)); |                               ~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:49:9: error: array type 'char[8]' is not\nassignable 49 |     v11 = v9 + 1; |     ~~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:52:11: error: expected expression\n   52 |     v14 = ::libc.so.0::malloc(v12 - 1);\n      |           ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:55:9: error: expected expression\n   55 |         ::libc.so.0::free(v14);\n      |         ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:60:13: error: array type 'char[4]' is not\nassignable 60 |         v17 = v14; |         ~~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:64:13: error: array type 'char[4]' is not\nassignable 64 |         v17 = v14; |         ~~~ ^\n/tmp/tmpw809s_o0/get_quoted_string_name_conflict.c:68:13: error: array type 'char[4]' is not\nassignable 68 |         v17 = v14; |         ~~~ ^ 12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long json_serialize_string_name_conflict(char *a0, char *a1) {\n  char *v1; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned long long v2;  // r13\n  unsigned long long v3;  // rax\n  char v5;                // dl\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rax\n  unsigned long long v8;  // rax\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n  unsigned long long v11; // rax\n  unsigned long long v12; // rax\n  unsigned long long v13; // rax\n  unsigned long long v14; // rax\n  unsigned long long v15; // rax\n  unsigned long long v16; // rax\n  unsigned long long v17; // rax\n  unsigned long long v18; // rax\n  unsigned long long v19; // rax\n  unsigned long long v20; // rax\n  unsigned long long v21; // rax\n  unsigned long long v22; // rax\n  unsigned long long v23; // rax\n  unsigned long long v24; // rax\n  unsigned long long v25; // rax\n  unsigned long long v26; // rax\n  unsigned long long v27; // rax\n  unsigned long long v28; // rax\n  unsigned long long v29; // rax\n  unsigned long long v30; // rax\n  unsigned long long v31; // rax\n  unsigned long long v32; // rax\n  unsigned long long v33; // rax\n  unsigned long long v34; // rax\n  unsigned long long v35; // rax\n  unsigned long long v36; // rax\n  unsigned long long v37; // rax\n  unsigned long long v38; // rax\n  unsigned long long v39; // rax\n  unsigned long long v40; // rax\n  unsigned long v41;      // r12, Other Possible Types: unsigned long long\n  char *v42;              // rbp, Other Possible Types: unsigned long\n  unsigned long v43;      // rax\n  unsigned long long v44; // rax\n\n  v1 = a1;\n  v2 = strlen(a0);\n  v3 = append_string(a1, \"\\\"\");\n  if ((unsigned int)v3 < 0)\n    return 4294967295;\n  v41 = v3;\n  if (a1)\n    v1 = &a1[v3];\n  if (v2) {\n    v42 = a0;\n    do {\n      v5 = *((char *)v42);\n      switch (v5) {\n      case 0:\n        v14 = append_string(v1, \"\\\\u0000\");\n        if ((unsigned int)v14 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v14 + v1;\n        v41 += v14;\n        break;\n      case 1:\n        v15 = append_string(v1, \"\\\\u0001\");\n        if ((unsigned int)v15 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v15 + v1;\n        v41 += v15;\n        break;\n      case 2:\n        v16 = append_string(v1, \"\\\\u0002\");\n        if ((unsigned int)v16 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v16 + v1;\n        v41 += v16;\n        break;\n      case 3:\n        v17 = append_string(v1, \"\\\\u0003\");\n        if ((unsigned int)v17 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v17 + v1;\n        v41 += v17;\n        break;\n      case 4:\n        v18 = append_string(v1, \"\\\\u0004\");\n        if ((unsigned int)v18 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v18 + v1;\n        v41 += v18;\n        break;\n      case 5:\n        v19 = append_string(v1, \"\\\\u0005\");\n        if ((unsigned int)v19 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v19 + v1;\n        v41 += v19;\n        break;\n      case 6:\n        v20 = append_string(v1, \"\\\\u0006\");\n        if ((unsigned int)v20 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v20 + v1;\n        v41 += v20;\n        break;\n      case 7:\n        v21 = append_string(v1, \"\\\\u0007\");\n        if ((unsigned int)v21 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v21 + v1;\n        v41 += v21;\n        break;\n      case 8:\n        v9 = append_string(v1, \"\\\\b\");\n        if ((unsigned int)v9 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v9 + v1;\n        v41 += v9;\n        break;\n      case 9:\n        v13 = append_string(v1, \"\\\\t\");\n        if ((unsigned int)v13 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v13 + v1;\n        v41 += v13;\n        break;\n      case 10:\n        v11 = append_string(v1, \"\\\\n\");\n        if ((unsigned int)v11 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v11 + v1;\n        v41 += v11;\n        break;\n      case 11:\n        v22 = append_string(v1, \"\\\\u000b\");\n        if ((unsigned int)v22 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v22 + v1;\n        v41 += v22;\n        break;\n      case 12:\n        v10 = append_string(v1, \"\\\\f\");\n        if ((unsigned int)v10 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v10 + v1;\n        v41 += v10;\n        break;\n      case 13:\n        v12 = append_string(v1, \"\\\\r\");\n        if ((unsigned int)v12 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v12 + v1;\n        v41 += v12;\n        break;\n      case 14:\n        v23 = append_string(v1, \"\\\\u000e\");\n        if ((unsigned int)v23 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v23 + v1;\n        v41 += v23;\n        break;\n      case 15:\n        v24 = append_string(v1, \"\\\\u000f\");\n        if ((unsigned int)v24 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v24 + v1;\n        v41 += v24;\n        break;\n      case 16:\n        v25 = append_string(v1, \"\\\\u0010\");\n        if ((unsigned int)v25 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v25 + v1;\n        v41 += v25;\n        break;\n      case 17:\n        v26 = append_string(v1, \"\\\\u0011\");\n        if ((unsigned int)v26 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v26 + v1;\n        v41 += v26;\n        break;\n      case 18:\n        v27 = append_string(v1, \"\\\\u0012\");\n        if ((unsigned int)v27 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v27 + v1;\n        v41 += v27;\n        break;\n      case 19:\n        v28 = append_string(v1, \"\\\\u0013\");\n        if ((unsigned int)v28 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v28 + v1;\n        v41 += v28;\n        break;\n      case 20:\n        v29 = append_string(v1, \"\\\\u0014\");\n        if ((unsigned int)v29 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v29 + v1;\n        v41 += v29;\n        break;\n      case 21:\n        v30 = append_string(v1, \"\\\\u0015\");\n        if ((unsigned int)v30 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v30 + v1;\n        v41 += v30;\n        break;\n      case 22:\n        v31 = append_string(v1, \"\\\\u0016\");\n        if ((unsigned int)v31 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v31 + v1;\n        v41 += v31;\n        break;\n      case 23:\n        v32 = append_string(v1, \"\\\\u0017\");\n        if ((unsigned int)v32 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v32 + v1;\n        v41 += v32;\n        break;\n      case 24:\n        v33 = append_string(v1, \"\\\\u0018\");\n        if ((unsigned int)v33 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v33 + v1;\n        v41 += v33;\n        break;\n      case 25:\n        v34 = append_string(v1, \"\\\\u0019\");\n        if ((unsigned int)v34 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v34 + v1;\n        v41 += v34;\n        break;\n      case 26:\n        v35 = append_string(v1, \"\\\\u001a\");\n        if ((unsigned int)v35 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v35 + v1;\n        v41 += v35;\n        break;\n      case 27:\n        v36 = append_string(v1, \"\\\\u001b\");\n        if ((unsigned int)v36 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v36 + v1;\n        v41 += v36;\n        break;\n      case 28:\n        v37 = append_string(v1, \"\\\\u001c\");\n        if ((unsigned int)v37 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v37 + v1;\n        v41 += v37;\n        break;\n      case 29:\n        v38 = append_string(v1, \"\\\\u001d\");\n        if ((unsigned int)v38 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v38 + v1;\n        v41 += v38;\n        break;\n      case 30:\n        v39 = append_string(v1, \"\\\\u001e\");\n        if ((unsigned int)v39 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v39 + v1;\n        v41 += v39;\n        break;\n      case 31:\n        v40 = append_string(v1, \"\\\\u001f\");\n        if ((unsigned int)v40 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v40 + v1;\n        v41 += v40;\n        break;\n      case 34:\n        v6 = append_string(v1, \"\\\\\\\"\");\n        if ((unsigned int)v6 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v6 + v1;\n        v41 += v6;\n        break;\n      case 47:\n        v8 = append_string(v1, \"\\\\/\");\n        if ((unsigned int)v8 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v8 + v1;\n        v41 += v8;\n        break;\n      case 92:\n        v7 = append_string(v1, \"\\\\\\\\\");\n        if ((unsigned int)v7 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v7 + v1;\n        v41 += v7;\n        break;\n      default:\n        if (v1) {\n          *((char *)v1) = v5;\n          v1 += 1;\n        }\n        v41 = (unsigned int)v41 + 1;\n        break;\n      }\n      v42 += 1;\n    } while (&a0[v2] != v42);\n  }\n  v44 = append_string(v1, \"\\\"\");\n  v43 = ((unsigned int)v44 < 0 ? v44 + v41 : 4294967295);\n  return v43;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long append_indent_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n  void *v2;              // r12, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  if ((unsigned int)a1 <= 0)\n    return 0;\n  v1 = a0;\n  v2 = 0;\n  while (true) {\n    v3 = append_string(v1, \"    \");\n    if ((unsigned int)v3 < 0)\n      return 4294967295;\n    if (v1)\n      v1 = v3 + v1;\n    v2 += v3;\n    if ((unsigned int)a1 == 1)\n      return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long append_string_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0) {\n    (unsigned int)v1 = sprintf(a0, \"%s\", (unsigned int)a1);\n    return v1;\n  }\n  v1 = strlen(a1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbllsy7eq/append_string_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = sprintf(a0, \"%s\",\n(unsigned int)a1); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long parson_strndup_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax\n\n  v1 = ::libc.so.0 ::malloc(a1 + 1);\n  if (v1) {\n    a1[v1] = 0;\n    strncpy(v1, a0, a1);\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0govdsjg/parson_strndup_name_conflict.c:22:10: error: expected expression\n   22 |     v1 = ::libc.so.0::malloc(a1 + 1);\n      |          ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_char_to_int_name_conflict(unsigned long a0) {\n  if (a0 - 48 <= 9) {\n    return a0 - 48;\n  } else if (a0 - 97 <= 5) {\n    return a0 - 87;\n  } else if (6 <= (a0 - 65 & 255)) {\n    return 4294967295;\n  } else {\n    return (char)a0 - 55;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(hex_char_to_int)(long long);\n\nlong long parse_utf16_hex_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned long v0;       // [bp-0x28]\n  unsigned long v1;       // [bp-0x20]\n  unsigned long v2;       // [bp-0x18]\n  unsigned long v3;       // [bp-0x10]\n  unsigned long v4;       // [bp-0x8]\n  unsigned long long v6;  // rdx\n  unsigned long v7;       // rax, Other Possible Types: unsigned long long\n  unsigned long v8;       // r14\n  unsigned long v9;       // r13\n  unsigned long v10;      // r12\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rbp\n  unsigned long long v13; // r12\n  unsigned long long v14; // r13\n  unsigned int v15;       // r14d\n  unsigned int v16;       // ebp\n  unsigned int v17;       // r12d\n  unsigned long long v18; // rax\n\n  v6 = a0[0];\n  v7 = 0;\n  if (!(char)v6)\n    return 0;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  v12 = a0[1];\n  if (!(char)v12)\n    return v7;\n  v13 = a0[2];\n  if ((char)v13) {\n    v14 = a0[3];\n    if ((char)v14) {\n      v15 = hex_char_to_int((char)v6);\n      v16 = hex_char_to_int((char)v12);\n      if (v15 == -1 || v16 == -1) {\n        v7 = 0;\n      } else {\n        v17 = hex_char_to_int((char)v13);\n        (unsigned int)v18 = hex_char_to_int((char)v14);\n        if (v17 == -1 || (unsigned int)v18 == -1) {\n          v7 = 0;\n        } else {\n          *(a1) = v15 * 0x1000 | v16 * 0x100 | (unsigned int)v18 | v17 * 16;\n          v7 = 1;\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg25qqn3z/parse_utf16_hex_name_conflict.c:67:17: error: assignment to cast is illegal,\nlvalue casts are not supported 67 |                 (unsigned int)v18 =\nhex_char_to_int((char)v14); |                 ^~~~~~~~~~~~~~~~~ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nvoid(rewind)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_file(char *a0) {\n  FILE_t *v1;       // rax\n  FILE_t *v2;       // rbx\n  unsigned long v3; // rbp\n  unsigned long v4; // r12\n  unsigned long v5; // r12\n\n  v1 = fopen(a0, \"r\");\n  v2 = v1;\n  if (!v1)\n    return v1;\n  fseek(v1, 0, 2);\n  v4 = ftell(v1);\n  if (v4 < 0) {\n    fclose(v2);\n    return 0;\n  }\n  rewind(v2);\n  v3 = ::libc.so.0 ::malloc(v4 + 1);\n  if (!v3) {\n    fclose(v2);\n    return v3;\n  }\n  v5 = fread(v3, 1, v4, v2);\n  if (v5 && !ferror(v2)) {\n    fclose(v2);\n    *((char *)(v3 + v5)) = 0;\n    return v3;\n  }\n  fclose(v2);\n  ::libc.so.0 ::free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4v5m1lmo/read_file.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp4v5m1lmo/read_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp4v5m1lmo/read_file.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp4v5m1lmo/read_file.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp4v5m1lmo/read_file.c:251:13: error: declaration of anonymous union must\nbe a definition 251 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:254:22: error: type name requires a specifier or\nqualifier 254 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:258:13: error: declaration of anonymous union must\nbe a definition 258 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:261:22: error: type name requires a specifier or\nqualifier 261 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:194:7: error: conflicting types for 'rewind'\n  194 | void (rewind)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:723:13: note: previous declaration is here\n  723 | extern void rewind (FILE *__stream);\n      |             ^\n/tmp/tmp4v5m1lmo/read_file.c:340:13: error: declaration of anonymous union must\nbe a definition 340 |             union <anon> { |             ^\n/tmp/tmp4v5m1lmo/read_file.c:343:22: error: type name requires a specifier or\nqualifier 343 |             } __value; |                      ^\n/tmp/tmp4v5m1lmo/read_file.c:347:13: error: declaration of anonymous union must\nbe a definition 347 |             union <anon> { |             ^ fatal error:\ntoo many errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16_hex)(long long, long long);\n\nlong long get_quoted_string_name_conflict(struct struct_0 **a0) {\n  char v5[2];             // r12\n  char v6[8];             // rbp\n  char v7;                // al\n  char v8[2];             // rax\n  char v9[8];             // rdx, Other Possible Types: unsigned long\n  unsigned long long v11; // rdx\n  unsigned long long v12; // rdx\n  char v14[4];            // rax\n  char v17[4];            // rbx, Other Possible Types: unsigned long\n\n  v5 = *(a0);\n  if (v5[0] != 34)\n    return 0;\n  v6 = &v5[1];\n  *(a0) = &v6[0];\n  v7 = v5[1];\n  if (v7 == 34) {\n    v9 = v6;\n  } else {\n    v9 = v6;\n    do {\n      if (!(v7) || !(v7 != 92) && !(!((*(a0) = (struct struct_0 *)(v9 + 1),\n                                       !*((char *)(v9 + 1))))))\n        return 0;\n    } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct struct_0 *)v9,\n              v7 = v8[1], v7 != 34));\n  }\n  v11 = v9 + 1;\n  *(a0) = v11;\n  v12 = v11 - (char *)v5;\n  v14 = ::libc.so.0 ::malloc(v12 - 1);\n  if (!v14) {\n    ::libc.so.0 ::free(v14);\n    return 0;\n  } else if (!v5[1]) {\n    v17 = v14;\n  } else if (!v12 - 2) {\n    v17 = v14;\n  } else {\n    v17 = v14;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:30:8: error: array type 'char[2]' is not\nassignable 30 |     v5 = *(a0); |     ~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:33:8: error: array type 'char[8]' is not\nassignable 33 |     v6 = &v5[1]; |     ~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:38:12: error: array type 'char[8]' is not\nassignable 38 |         v9 = v6; |         ~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:42:12: error: array type 'char[8]' is not\nassignable 42 |         v9 = v6; |         ~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:47:22: error: array type 'char[2]' is not\nassignable 47 |         } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct\nstruct_0 *)v9, v7 = v8[1], v7 != 34)); |                   ~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:47:34: error: array type 'char[8]' is not\nassignable 47 |         } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct\nstruct_0 *)v9, v7 = v8[1], v7 != 34)); |                               ~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:51:15: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 51 |     v12 = v11 - (char *)v5;\n      |           ~~~ ^ ~~~~~~~~~~\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:52:11: error: expected expression\n   52 |     v14 = ::libc.so.0::malloc(v12 - 1);\n      |           ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:55:9: error: expected expression\n   55 |         ::libc.so.0::free(v14);\n      |         ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:60:13: error: array type 'char[4]' is not\nassignable 60 |         v17 = v14; |         ~~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:64:13: error: array type 'char[4]' is not\nassignable 64 |         v17 = v14; |         ~~~ ^\n/tmp/tmpmxyk0yua/get_quoted_string_name_conflict.c:68:13: error: array type 'char[4]' is not\nassignable 68 |         v17 = v14; |         ~~~ ^ 12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long json_serialize_string_name_conflict(char *a0, char *a1) {\n  char *v1; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned long long v2;  // r13\n  unsigned long long v3;  // rax\n  char v5;                // dl\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rax\n  unsigned long long v8;  // rax\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n  unsigned long long v11; // rax\n  unsigned long long v12; // rax\n  unsigned long long v13; // rax\n  unsigned long long v14; // rax\n  unsigned long long v15; // rax\n  unsigned long long v16; // rax\n  unsigned long long v17; // rax\n  unsigned long long v18; // rax\n  unsigned long long v19; // rax\n  unsigned long long v20; // rax\n  unsigned long long v21; // rax\n  unsigned long long v22; // rax\n  unsigned long long v23; // rax\n  unsigned long long v24; // rax\n  unsigned long long v25; // rax\n  unsigned long long v26; // rax\n  unsigned long long v27; // rax\n  unsigned long long v28; // rax\n  unsigned long long v29; // rax\n  unsigned long long v30; // rax\n  unsigned long long v31; // rax\n  unsigned long long v32; // rax\n  unsigned long long v33; // rax\n  unsigned long long v34; // rax\n  unsigned long long v35; // rax\n  unsigned long long v36; // rax\n  unsigned long long v37; // rax\n  unsigned long long v38; // rax\n  unsigned long long v39; // rax\n  unsigned long long v40; // rax\n  unsigned long v41;      // r12, Other Possible Types: unsigned long long\n  char *v42;              // rbp, Other Possible Types: unsigned long\n  unsigned long v43;      // rax\n  unsigned long long v44; // rax\n\n  v1 = a1;\n  v2 = strlen(a0);\n  v3 = append_string(a1, \"\\\"\");\n  if ((unsigned int)v3 < 0)\n    return 4294967295;\n  v41 = v3;\n  if (a1)\n    v1 = &a1[v3];\n  if (v2) {\n    v42 = a0;\n    do {\n      v5 = *((char *)v42);\n      switch (v5) {\n      case 0:\n        v14 = append_string(v1, \"\\\\u0000\");\n        if ((unsigned int)v14 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v14 + v1;\n        v41 += v14;\n        break;\n      case 1:\n        v15 = append_string(v1, \"\\\\u0001\");\n        if ((unsigned int)v15 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v15 + v1;\n        v41 += v15;\n        break;\n      case 2:\n        v16 = append_string(v1, \"\\\\u0002\");\n        if ((unsigned int)v16 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v16 + v1;\n        v41 += v16;\n        break;\n      case 3:\n        v17 = append_string(v1, \"\\\\u0003\");\n        if ((unsigned int)v17 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v17 + v1;\n        v41 += v17;\n        break;\n      case 4:\n        v18 = append_string(v1, \"\\\\u0004\");\n        if ((unsigned int)v18 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v18 + v1;\n        v41 += v18;\n        break;\n      case 5:\n        v19 = append_string(v1, \"\\\\u0005\");\n        if ((unsigned int)v19 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v19 + v1;\n        v41 += v19;\n        break;\n      case 6:\n        v20 = append_string(v1, \"\\\\u0006\");\n        if ((unsigned int)v20 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v20 + v1;\n        v41 += v20;\n        break;\n      case 7:\n        v21 = append_string(v1, \"\\\\u0007\");\n        if ((unsigned int)v21 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v21 + v1;\n        v41 += v21;\n        break;\n      case 8:\n        v9 = append_string(v1, \"\\\\b\");\n        if ((unsigned int)v9 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v9 + v1;\n        v41 += v9;\n        break;\n      case 9:\n        v13 = append_string(v1, \"\\\\t\");\n        if ((unsigned int)v13 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v13 + v1;\n        v41 += v13;\n        break;\n      case 10:\n        v11 = append_string(v1, \"\\\\n\");\n        if ((unsigned int)v11 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v11 + v1;\n        v41 += v11;\n        break;\n      case 11:\n        v22 = append_string(v1, \"\\\\u000b\");\n        if ((unsigned int)v22 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v22 + v1;\n        v41 += v22;\n        break;\n      case 12:\n        v10 = append_string(v1, \"\\\\f\");\n        if ((unsigned int)v10 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v10 + v1;\n        v41 += v10;\n        break;\n      case 13:\n        v12 = append_string(v1, \"\\\\r\");\n        if ((unsigned int)v12 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v12 + v1;\n        v41 += v12;\n        break;\n      case 14:\n        v23 = append_string(v1, \"\\\\u000e\");\n        if ((unsigned int)v23 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v23 + v1;\n        v41 += v23;\n        break;\n      case 15:\n        v24 = append_string(v1, \"\\\\u000f\");\n        if ((unsigned int)v24 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v24 + v1;\n        v41 += v24;\n        break;\n      case 16:\n        v25 = append_string(v1, \"\\\\u0010\");\n        if ((unsigned int)v25 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v25 + v1;\n        v41 += v25;\n        break;\n      case 17:\n        v26 = append_string(v1, \"\\\\u0011\");\n        if ((unsigned int)v26 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v26 + v1;\n        v41 += v26;\n        break;\n      case 18:\n        v27 = append_string(v1, \"\\\\u0012\");\n        if ((unsigned int)v27 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v27 + v1;\n        v41 += v27;\n        break;\n      case 19:\n        v28 = append_string(v1, \"\\\\u0013\");\n        if ((unsigned int)v28 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v28 + v1;\n        v41 += v28;\n        break;\n      case 20:\n        v29 = append_string(v1, \"\\\\u0014\");\n        if ((unsigned int)v29 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v29 + v1;\n        v41 += v29;\n        break;\n      case 21:\n        v30 = append_string(v1, \"\\\\u0015\");\n        if ((unsigned int)v30 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v30 + v1;\n        v41 += v30;\n        break;\n      case 22:\n        v31 = append_string(v1, \"\\\\u0016\");\n        if ((unsigned int)v31 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v31 + v1;\n        v41 += v31;\n        break;\n      case 23:\n        v32 = append_string(v1, \"\\\\u0017\");\n        if ((unsigned int)v32 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v32 + v1;\n        v41 += v32;\n        break;\n      case 24:\n        v33 = append_string(v1, \"\\\\u0018\");\n        if ((unsigned int)v33 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v33 + v1;\n        v41 += v33;\n        break;\n      case 25:\n        v34 = append_string(v1, \"\\\\u0019\");\n        if ((unsigned int)v34 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v34 + v1;\n        v41 += v34;\n        break;\n      case 26:\n        v35 = append_string(v1, \"\\\\u001a\");\n        if ((unsigned int)v35 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v35 + v1;\n        v41 += v35;\n        break;\n      case 27:\n        v36 = append_string(v1, \"\\\\u001b\");\n        if ((unsigned int)v36 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v36 + v1;\n        v41 += v36;\n        break;\n      case 28:\n        v37 = append_string(v1, \"\\\\u001c\");\n        if ((unsigned int)v37 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v37 + v1;\n        v41 += v37;\n        break;\n      case 29:\n        v38 = append_string(v1, \"\\\\u001d\");\n        if ((unsigned int)v38 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v38 + v1;\n        v41 += v38;\n        break;\n      case 30:\n        v39 = append_string(v1, \"\\\\u001e\");\n        if ((unsigned int)v39 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v39 + v1;\n        v41 += v39;\n        break;\n      case 31:\n        v40 = append_string(v1, \"\\\\u001f\");\n        if ((unsigned int)v40 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v40 + v1;\n        v41 += v40;\n        break;\n      case 34:\n        v6 = append_string(v1, \"\\\\\\\"\");\n        if ((unsigned int)v6 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v6 + v1;\n        v41 += v6;\n        break;\n      case 47:\n        v8 = append_string(v1, \"\\\\/\");\n        if ((unsigned int)v8 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v8 + v1;\n        v41 += v8;\n        break;\n      case 92:\n        v7 = append_string(v1, \"\\\\\\\\\");\n        if ((unsigned int)v7 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v7 + v1;\n        v41 += v7;\n        break;\n      default:\n        if (v1) {\n          *((char *)v1) = v5;\n          v1 += 1;\n        }\n        v41 = (unsigned int)v41 + 1;\n        break;\n      }\n      v42 += 1;\n    } while (&a0[v2] != v42);\n  }\n  v44 = append_string(v1, \"\\\"\");\n  v43 = ((unsigned int)v44 < 0 ? v44 + v41 : 4294967295);\n  return v43;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long append_indent_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n  void *v2;              // r12, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  if ((unsigned int)a1 <= 0)\n    return 0;\n  v1 = a0;\n  v2 = 0;\n  while (true) {\n    v3 = append_string(v1, \"    \");\n    if ((unsigned int)v3 < 0)\n      return 4294967295;\n    if (v1)\n      v1 = v3 + v1;\n    v2 += v3;\n    if ((unsigned int)a1 == 1)\n      return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long append_string_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0) {\n    (unsigned int)v1 = sprintf(a0, \"%s\", (unsigned int)a1);\n    return v1;\n  }\n  v1 = strlen(a1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_fwl9rxz/append_string_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = sprintf(a0, \"%s\",\n(unsigned int)a1); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\n\nlong long parson_strndup_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax\n\n  v1 = ::libc.so.0 ::malloc(a1 + 1);\n  if (v1) {\n    a1[v1] = 0;\n    strncpy(v1, a0, a1);\n    return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1ls1cyp5/parson_strndup_name_conflict.c:22:10: error: expected expression\n   22 |     v1 = ::libc.so.0::malloc(a1 + 1);\n      |          ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long hex_char_to_int_name_conflict(unsigned long a0) {\n  if (a0 - 48 <= 9) {\n    return a0 - 48;\n  } else if (a0 - 97 <= 5) {\n    return a0 - 87;\n  } else if (6 <= (a0 - 65 & 255)) {\n    return 4294967295;\n  } else {\n    return (char)a0 - 55;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(hex_char_to_int)(long long);\n\nlong long parse_utf16_hex_name_conflict(char a0[4], unsigned int *a1) {\n  unsigned long v0;       // [bp-0x28]\n  unsigned long v1;       // [bp-0x20]\n  unsigned long v2;       // [bp-0x18]\n  unsigned long v3;       // [bp-0x10]\n  unsigned long v4;       // [bp-0x8]\n  unsigned long long v6;  // rdx\n  unsigned long v7;       // rax, Other Possible Types: unsigned long long\n  unsigned long v8;       // r14\n  unsigned long v9;       // r13\n  unsigned long v10;      // r12\n  unsigned long v11;      // rbx\n  unsigned long long v12; // rbp\n  unsigned long long v13; // r12\n  unsigned long long v14; // r13\n  unsigned int v15;       // r14d\n  unsigned int v16;       // ebp\n  unsigned int v17;       // r12d\n  unsigned long long v18; // rax\n\n  v6 = a0[0];\n  v7 = 0;\n  if (!(char)v6)\n    return 0;\n  v4 = v8;\n  v3 = v9;\n  v2 = v10;\n  *((int *)&v1) = rbp;\n  v0 = v11;\n  v12 = a0[1];\n  if (!(char)v12)\n    return v7;\n  v13 = a0[2];\n  if ((char)v13) {\n    v14 = a0[3];\n    if ((char)v14) {\n      v15 = hex_char_to_int((char)v6);\n      v16 = hex_char_to_int((char)v12);\n      if (v15 == -1 || v16 == -1) {\n        v7 = 0;\n      } else {\n        v17 = hex_char_to_int((char)v13);\n        (unsigned int)v18 = hex_char_to_int((char)v14);\n        if (v17 == -1 || (unsigned int)v18 == -1) {\n          v7 = 0;\n        } else {\n          *(a1) = v15 * 0x1000 | v16 * 0x100 | (unsigned int)v18 | v17 * 16;\n          v7 = 1;\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpisclmutv/parse_utf16_hex_name_conflict.c:67:17: error: assignment to cast is illegal,\nlvalue casts are not supported 67 |                 (unsigned int)v18 =\nhex_char_to_int((char)v14); |                 ^~~~~~~~~~~~~~~~~ ~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fseek)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    long, int);\nlong(ftell)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nvoid(rewind)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\nunsigned long(fread)(\n    void *, unsigned long, unsigned long, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\nint(ferror)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_file(char *a0) {\n  FILE_t *v1;       // rax\n  FILE_t *v2;       // rbx\n  unsigned long v3; // rbp\n  unsigned long v4; // r12\n  unsigned long v5; // r12\n\n  v1 = fopen(a0, \"r\");\n  v2 = v1;\n  if (!v1)\n    return v1;\n  fseek(v1, 0, 2);\n  v4 = ftell(v1);\n  if (v4 < 0) {\n    fclose(v2);\n    return 0;\n  }\n  rewind(v2);\n  v3 = ::libc.so.0 ::malloc(v4 + 1);\n  if (!v3) {\n    fclose(v2);\n    return v3;\n  }\n  v5 = fread(v3, 1, v4, v2);\n  if (v5 && !ferror(v2)) {\n    fclose(v2);\n    *((char *)(v3 + v5)) = 0;\n    return v3;\n  }\n  fclose(v2);\n  ::libc.so.0 ::free(v3);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2if81vdu/read_file.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmp2if81vdu/read_file.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmp2if81vdu/read_file.c:73:13: error: declaration of anonymous union must\nbe a definition 73 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:80:13: error: declaration of anonymous union must\nbe a definition 80 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:16:6: error: conflicting types for 'fseek'\n   16 | int (fseek)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:713:12: note: previous declaration is here\n  713 | extern int fseek (FILE *__stream, long int __off, int __whence);\n      |            ^\n/tmp/tmp2if81vdu/read_file.c:162:13: error: declaration of anonymous union must\nbe a definition 162 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:165:22: error: type name requires a specifier or\nqualifier 165 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:169:13: error: declaration of anonymous union must\nbe a definition 169 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:172:22: error: type name requires a specifier or\nqualifier 172 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:105:7: error: conflicting types for 'ftell'\n  105 | long (ftell)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:718:17: note: previous declaration is here\n  718 | extern long int ftell (FILE *__stream) __wur;\n      |                 ^\n/tmp/tmp2if81vdu/read_file.c:251:13: error: declaration of anonymous union must\nbe a definition 251 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:254:22: error: type name requires a specifier or\nqualifier 254 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:258:13: error: declaration of anonymous union must\nbe a definition 258 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:261:22: error: type name requires a specifier or\nqualifier 261 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:194:7: error: conflicting types for 'rewind'\n  194 | void (rewind)(struct FILE_t {\n      |       ^\n/usr/include/stdio.h:723:13: note: previous declaration is here\n  723 | extern void rewind (FILE *__stream);\n      |             ^\n/tmp/tmp2if81vdu/read_file.c:340:13: error: declaration of anonymous union must\nbe a definition 340 |             union <anon> { |             ^\n/tmp/tmp2if81vdu/read_file.c:343:22: error: type name requires a specifier or\nqualifier 343 |             } __value; |                      ^\n/tmp/tmp2if81vdu/read_file.c:347:13: error: declaration of anonymous union must\nbe a definition 347 |             union <anon> { |             ^ fatal error:\ntoo many errors emitted, stopping now [-ferror-limit=] 20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(parse_utf16_hex)(long long, long long);\n\nlong long get_quoted_string_name_conflict(struct struct_0 **a0) {\n  char v5[2];             // r12\n  char v6[8];             // rbp\n  char v7;                // al\n  char v8[2];             // rax\n  char v9[8];             // rdx, Other Possible Types: unsigned long\n  char v11[8];            // rdx\n  unsigned long long v12; // rdx\n  char v14[4];            // rax\n  char v17[4];            // rbx, Other Possible Types: unsigned long\n\n  v5 = *(a0);\n  if (v5[0] != 34)\n    return 0;\n  v6 = &v5[1];\n  *(a0) = &v6[0];\n  v7 = v5[1];\n  if (v7 == 34) {\n    v9 = v6;\n  } else {\n    v9 = v6;\n    do {\n      if (!(v7) || !(v7 != 92) && !(!((*(a0) = (struct struct_0 *)(v9 + 1),\n                                       !*((char *)(v9 + 1))))))\n        return 0;\n    } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct struct_0 *)v9,\n              v7 = v8[1], v7 != 34));\n  }\n  v11 = v9 + 1;\n  *(a0) = &v11[0];\n  v12 = v11 - v5;\n  v14 = ::libc.so.0 ::malloc(v12 - 1);\n  if (!v14) {\n    ::libc.so.0 ::free(v14);\n    return 0;\n  } else if (!v5[1]) {\n    v17 = v14;\n  } else if (!v12 - 2) {\n    v17 = v14;\n  } else {\n    v17 = v14;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:30:8: error: array type 'char[2]' is not\nassignable 30 |     v5 = *(a0); |     ~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:33:8: error: array type 'char[8]' is not\nassignable 33 |     v6 = &v5[1]; |     ~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:38:12: error: array type 'char[8]' is not\nassignable 38 |         v9 = v6; |         ~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:42:12: error: array type 'char[8]' is not\nassignable 42 |         v9 = v6; |         ~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:47:22: error: array type 'char[2]' is not\nassignable 47 |         } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct\nstruct_0 *)v9, v7 = v8[1], v7 != 34)); |                   ~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:47:34: error: array type 'char[8]' is not\nassignable 47 |         } while ((v8 = *(a0), v9 = v8 + 1, *(a0) = (struct\nstruct_0 *)v9, v7 = v8[1], v7 != 34)); |                               ~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:49:9: error: array type 'char[8]' is not\nassignable 49 |     v11 = v9 + 1; |     ~~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:52:11: error: expected expression\n   52 |     v14 = ::libc.so.0::malloc(v12 - 1);\n      |           ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:55:9: error: expected expression\n   55 |         ::libc.so.0::free(v14);\n      |         ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:60:13: error: array type 'char[4]' is not\nassignable 60 |         v17 = v14; |         ~~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:64:13: error: array type 'char[4]' is not\nassignable 64 |         v17 = v14; |         ~~~ ^\n/tmp/tmpr83b3pr2/get_quoted_string_name_conflict.c:68:13: error: array type 'char[4]' is not\nassignable 68 |         v17 = v14; |         ~~~ ^ 12 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long json_serialize_string_name_conflict(char *a0, char *a1) {\n  char *v1; // rbx, Other Possible Types: unsigned long long, unsigned long\n  unsigned long long v2;  // r13\n  unsigned long long v3;  // rax\n  char v5;                // dl\n  unsigned long long v6;  // rax\n  unsigned long long v7;  // rax\n  unsigned long long v8;  // rax\n  unsigned long long v9;  // rax\n  unsigned long long v10; // rax\n  unsigned long long v11; // rax\n  unsigned long long v12; // rax\n  unsigned long long v13; // rax\n  unsigned long long v14; // rax\n  unsigned long long v15; // rax\n  unsigned long long v16; // rax\n  unsigned long long v17; // rax\n  unsigned long long v18; // rax\n  unsigned long long v19; // rax\n  unsigned long long v20; // rax\n  unsigned long long v21; // rax\n  unsigned long long v22; // rax\n  unsigned long long v23; // rax\n  unsigned long long v24; // rax\n  unsigned long long v25; // rax\n  unsigned long long v26; // rax\n  unsigned long long v27; // rax\n  unsigned long long v28; // rax\n  unsigned long long v29; // rax\n  unsigned long long v30; // rax\n  unsigned long long v31; // rax\n  unsigned long long v32; // rax\n  unsigned long long v33; // rax\n  unsigned long long v34; // rax\n  unsigned long long v35; // rax\n  unsigned long long v36; // rax\n  unsigned long long v37; // rax\n  unsigned long long v38; // rax\n  unsigned long long v39; // rax\n  unsigned long long v40; // rax\n  unsigned long long v41; // r12, Other Possible Types: unsigned long\n  char *v42;              // rbp, Other Possible Types: unsigned long\n  unsigned long v43;      // rax\n  unsigned long long v44; // rax\n\n  v1 = a1;\n  v2 = strlen(a0);\n  v3 = append_string(a1, \"\\\"\");\n  if ((unsigned int)v3 < 0)\n    return 4294967295;\n  v41 = v3;\n  if (a1)\n    v1 = &a1[v3];\n  if (v2) {\n    v42 = a0;\n    do {\n      v5 = *((char *)v42);\n      switch (v5) {\n      case 0:\n        v14 = append_string(v1, \"\\\\u0000\");\n        if ((unsigned int)v14 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v14 + v1;\n        v41 += v14;\n        break;\n      case 1:\n        v15 = append_string(v1, \"\\\\u0001\");\n        if ((unsigned int)v15 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v15 + v1;\n        v41 += v15;\n        break;\n      case 2:\n        v16 = append_string(v1, \"\\\\u0002\");\n        if ((unsigned int)v16 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v16 + v1;\n        v41 += v16;\n        break;\n      case 3:\n        v17 = append_string(v1, \"\\\\u0003\");\n        if ((unsigned int)v17 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v17 + v1;\n        v41 += v17;\n        break;\n      case 4:\n        v18 = append_string(v1, \"\\\\u0004\");\n        if ((unsigned int)v18 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v18 + v1;\n        v41 += v18;\n        break;\n      case 5:\n        v19 = append_string(v1, \"\\\\u0005\");\n        if ((unsigned int)v19 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v19 + v1;\n        v41 += v19;\n        break;\n      case 6:\n        v20 = append_string(v1, \"\\\\u0006\");\n        if ((unsigned int)v20 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v20 + v1;\n        v41 += v20;\n        break;\n      case 7:\n        v21 = append_string(v1, \"\\\\u0007\");\n        if ((unsigned int)v21 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v21 + v1;\n        v41 += v21;\n        break;\n      case 8:\n        v9 = append_string(v1, \"\\\\b\");\n        if ((unsigned int)v9 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v9 + v1;\n        v41 += v9;\n        break;\n      case 9:\n        v13 = append_string(v1, \"\\\\t\");\n        if ((unsigned int)v13 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v13 + v1;\n        v41 += v13;\n        break;\n      case 10:\n        v11 = append_string(v1, \"\\\\n\");\n        if ((unsigned int)v11 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v11 + v1;\n        v41 += v11;\n        break;\n      case 11:\n        v22 = append_string(v1, \"\\\\u000b\");\n        if ((unsigned int)v22 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v22 + v1;\n        v41 += v22;\n        break;\n      case 12:\n        v10 = append_string(v1, \"\\\\f\");\n        if ((unsigned int)v10 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v10 + v1;\n        v41 += v10;\n        break;\n      case 13:\n        v12 = append_string(v1, \"\\\\r\");\n        if ((unsigned int)v12 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v12 + v1;\n        v41 += v12;\n        break;\n      case 14:\n        v23 = append_string(v1, \"\\\\u000e\");\n        if ((unsigned int)v23 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v23 + v1;\n        v41 += v23;\n        break;\n      case 15:\n        v24 = append_string(v1, \"\\\\u000f\");\n        if ((unsigned int)v24 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v24 + v1;\n        v41 += v24;\n        break;\n      case 16:\n        v25 = append_string(v1, \"\\\\u0010\");\n        if ((unsigned int)v25 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v25 + v1;\n        v41 += v25;\n        break;\n      case 17:\n        v26 = append_string(v1, \"\\\\u0011\");\n        if ((unsigned int)v26 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v26 + v1;\n        v41 += v26;\n        break;\n      case 18:\n        v27 = append_string(v1, \"\\\\u0012\");\n        if ((unsigned int)v27 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v27 + v1;\n        v41 += v27;\n        break;\n      case 19:\n        v28 = append_string(v1, \"\\\\u0013\");\n        if ((unsigned int)v28 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v28 + v1;\n        v41 += v28;\n        break;\n      case 20:\n        v29 = append_string(v1, \"\\\\u0014\");\n        if ((unsigned int)v29 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v29 + v1;\n        v41 += v29;\n        break;\n      case 21:\n        v30 = append_string(v1, \"\\\\u0015\");\n        if ((unsigned int)v30 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v30 + v1;\n        v41 += v30;\n        break;\n      case 22:\n        v31 = append_string(v1, \"\\\\u0016\");\n        if ((unsigned int)v31 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v31 + v1;\n        v41 += v31;\n        break;\n      case 23:\n        v32 = append_string(v1, \"\\\\u0017\");\n        if ((unsigned int)v32 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v32 + v1;\n        v41 += v32;\n        break;\n      case 24:\n        v33 = append_string(v1, \"\\\\u0018\");\n        if ((unsigned int)v33 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v33 + v1;\n        v41 += v33;\n        break;\n      case 25:\n        v34 = append_string(v1, \"\\\\u0019\");\n        if ((unsigned int)v34 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v34 + v1;\n        v41 += v34;\n        break;\n      case 26:\n        v35 = append_string(v1, \"\\\\u001a\");\n        if ((unsigned int)v35 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v35 + v1;\n        v41 += v35;\n        break;\n      case 27:\n        v36 = append_string(v1, \"\\\\u001b\");\n        if ((unsigned int)v36 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v36 + v1;\n        v41 += v36;\n        break;\n      case 28:\n        v37 = append_string(v1, \"\\\\u001c\");\n        if ((unsigned int)v37 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v37 + v1;\n        v41 += v37;\n        break;\n      case 29:\n        v38 = append_string(v1, \"\\\\u001d\");\n        if ((unsigned int)v38 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v38 + v1;\n        v41 += v38;\n        break;\n      case 30:\n        v39 = append_string(v1, \"\\\\u001e\");\n        if ((unsigned int)v39 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v39 + v1;\n        v41 += v39;\n        break;\n      case 31:\n        v40 = append_string(v1, \"\\\\u001f\");\n        if ((unsigned int)v40 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v40 + v1;\n        v41 += v40;\n        break;\n      case 34:\n        v6 = append_string(v1, \"\\\\\\\"\");\n        if ((unsigned int)v6 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v6 + v1;\n        v41 += v6;\n        break;\n      case 47:\n        v8 = append_string(v1, \"\\\\/\");\n        if ((unsigned int)v8 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v8 + v1;\n        v41 += v8;\n        break;\n      case 92:\n        v7 = append_string(v1, \"\\\\\\\\\");\n        if ((unsigned int)v7 < 0)\n          return 4294967295;\n        if (v1)\n          v1 = v7 + v1;\n        v41 += v7;\n        break;\n      default:\n        if (v1) {\n          *((char *)v1) = v5;\n          v1 += 1;\n        }\n        v41 = (unsigned int)v41 + 1;\n        break;\n      }\n      v42 += 1;\n    } while (&a0[v2] != v42);\n  }\n  v44 = append_string(v1, \"\\\"\");\n  v43 = ((unsigned int)v44 < 0 ? v44 + v41 : 4294967295);\n  return v43;\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(append_string)(long long, long long);\n\nlong long append_indent_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n  void *v2;              // r12, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n\n  if ((unsigned int)a1 <= 0)\n    return 0;\n  v1 = a0;\n  v2 = 0;\n  while (true) {\n    v3 = append_string(v1, \"    \");\n    if ((unsigned int)v3 < 0)\n      return 4294967295;\n    if (v1)\n      v1 = v3 + v1;\n    v2 += v3;\n    if ((unsigned int)a1 == 1)\n      return v2;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long append_string_name_conflict(char *a0, char *a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  if (a0) {\n    (unsigned int)v1 = sprintf(a0, \"%s\", (unsigned int)a1);\n    return v1;\n  }\n  v1 = strlen(a1);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvngdquq7/append_string_name_conflict.c:23:9: error: assignment to cast is illegal,\nlvalue casts are not supported 23 |         (unsigned int)v1 = sprintf(a0, \"%s\",\n(unsigned int)a1); |         ^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"int io_signal(int fd, int sig) {\n    int flags;\n    if (fcntl(fd, 10, sig) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set signal %d on fd %d: %s\\n\", __func__, 11, sig, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 8, getpid()) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set process as owner of fd %d: %s\\n\", __func__, 15, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    flags = fcntl(fd, 3);\n    if (flags == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to get flags of fd %d: %s\\n\", __func__, 20, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 4, flags | 8192 | 2048) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to enable I/O signaling for fd %d: %s\\n\", __func__, 24, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\nchar *(strerror)(int);\n\nextern char __func__ .1;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long io_signal_name_conflict(unsigned long a0, unsigned long a1) {\n  if (fcntl(a0, 10) == -1) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to set signal %d on fd %d: %s\\n\", &__func__ .1,\n            10, (unsigned int)a1, (unsigned int)a0,\n            (unsigned int)strerror(*(__errno_location())));\n    return 1;\n  }\n  getpid();\n  if (fcntl(a0, 8) == -1) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to set process as owner of fd %d: %s\\n\",\n            &__func__ .1, 14, (unsigned int)a0,\n            (unsigned int)strerror(*(__errno_location())));\n    return 1;\n  } else if (fcntl(a0, 3) == -1) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to get flags of fd %d: %s\\n\", &__func__ .1, 19,\n            (unsigned int)a0, (unsigned int)strerror(*(__errno_location())));\n    return 1;\n  } else if (fcntl(a0, 4) != -1) {\n    return 0;\n  } else {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"ERROR %s:%d: failed to enable I/O signaling for fd %d: %s\\n\",\n            &__func__ .1, 23, (unsigned int)a0,\n            (unsigned int)strerror(*(__errno_location())));\n    return 1;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:19:13: error: expected identifier or '('\n   19 | extern char __func__.1;\n      |             ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 20 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:20:22: error: expected ';' after top level\ndeclarator 20 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:26:23: error: expected ')'\n   26 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set signal\n%d on fd %d: %s\\n\", &__func__.1, 10, (unsigned int)a1, (unsigned int)a0,\n(unsigned int)strerror(*(__errno_location()))); |                       ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:26:16: note: to match this '('\n   26 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set signal\n%d on fd %d: %s\\n\", &__func__.1, 10, (unsigned int)a1, (unsigned int)a0,\n(unsigned int)strerror(*(__errno_location()))); |                ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:32:23: error: expected ')'\n   32 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set process\nas owner of fd %d: %s\\n\", &__func__.1, 14, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); |                       ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:32:16: note: to match this '('\n   32 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to set process\nas owner of fd %d: %s\\n\", &__func__.1, 14, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); |                ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:37:23: error: expected ')'\n   37 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to get flags of\nfd %d: %s\\n\", &__func__.1, 19, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); |                       ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:37:16: note: to match this '('\n   37 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to get flags of\nfd %d: %s\\n\", &__func__.1, 19, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); |                ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:46:23: error: expected ')'\n   46 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to enable I/O\nsignaling for fd %d: %s\\n\", &__func__.1, 23, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); |                       ^\n/tmp/tmp_qy2hbgw/io_signal_name_conflict.c:46:16: note: to match this '('\n   46 |         fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: failed to enable I/O\nsignaling for fd %d: %s\\n\", &__func__.1, 23, (unsigned int)a0, (unsigned\nint)strerror(*(__errno_location()))); |                ^ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static ssize_t read_nonblock(int fd, char *buf, size_t size) {\n    ssize_t nr;\n    nr = read(fd, buf, size);\n    if (nr == -1) {\n        if ((*__errno_location()) == 11) {\n            return 0;\n        }\n        fprintf(stderr, \"ERROR %s:%d: read from %d: %s\\n\", __func__, 38, fd, strerror((*__errno_location())));\n        return -1;\n    }\n    return nr;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"int io_readline(int fd, char *buffer, size_t size) {\n    int nr = 0;\n    char c;\n    while (nr < size && read_nonblock(fd, &c, 1) > 0 && c != '\\n')\n        buffer[nr++] = c;\n    return nr;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nchar *(strerror)(int);\n\nextern char __func__ .0;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long io_readline_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  char v0;               // [bp-0x29]\n  char *v2;              // rbx, Other Possible Types: unsigned long\n  void *v3;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v4; // rax\n  char v5;               // al\n  unsigned int v6;       // edi\n\n  if (!a2)\n    return 0;\n  v2 = a1;\n  v3 = 0;\n  while (true) {\n    v4 = read(a0, &v0, 1);\n    if (v4 == -1)\n      break;\n    if (!(v4 > 0) || !(v5 != 10) ||\n        !((v3 = (unsigned long long)((unsigned int)v3 + 1), *((char *)v2) = v5,\n           v2 += 1, v2 != a1 + a2)))\n      return v3;\n  }\n  v6 = *(__errno_location());\n  if (v6 == 11)\n    return v3;\n  fprintf(stderr @GLIBC_2.2.5, \"ERROR %s:%d: read from %d: %s\\n\", &__func__ .0,\n          37, (unsigned int)a0, (unsigned int)strerror(v6));\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpj54yywtr/io_readline_name_conflict.c:19:13: error: expected identifier or '('\n   19 | extern char __func__.0;\n      |             ^\n/tmp/tmpj54yywtr/io_readline_name_conflict.c:20:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 20 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpj54yywtr/io_readline_name_conflict.c:20:22: error: expected ';' after top level\ndeclarator 20 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpj54yywtr/io_readline_name_conflict.c:43:10: error: indirection requires pointer\noperand ('int' invalid) 43 |     v6 = *(__errno_location()); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpj54yywtr/io_readline_name_conflict.c:46:19: error: expected ')'\n   46 |     fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: read from %d: %s\\n\",\n&__func__.0, 37, (unsigned int)a0, (unsigned int)strerror(v6)); | ^\n/tmp/tmpj54yywtr/io_readline_name_conflict.c:46:12: note: to match this '('\n   46 |     fprintf(stderr@GLIBC_2.2.5, \"ERROR %s:%d: read from %d: %s\\n\",\n&__func__.0, 37, (unsigned int)a0, (unsigned int)strerror(v6)); |            ^\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static inline bool is_number(const char *str) {\n    char *end;\n    strtoul(str, &end, 10);\n    return !(*str == 0 || *end != 0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/json.c"}
{"compilable":0,"function":"static int parse_section(const char *line, char *name, unsigned int size) {\n    char *closing = strchr(line, ']');\n    const int len = strlen(line);\n    if (!closing || line + len - 1 != closing) {\n        fprintf(stderr, \"ERROR %s:%d: malformated section \\\"%s\\\"\\n\", __func__, 33, line);\n        return 1;\n    }\n    if (size - 1 < len - 2) {\n        fprintf(stderr, \"ERROR %s:%d: section name too long \\\"%s\\\"\\n\", __func__, 37, line);\n        return 1;\n    }\n    memcpy(name, line + 1, len - 2);\n    name[len - 2] = '\\x00';\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int parse_property(const char *line, struct properties *props, bool strict) {\n    char *equal = strchr(line, '=');\n    const char *key, *value;\n    if (!equal) {\n        fprintf(stderr, \"ERROR %s:%d: malformated property, should be a key=value pair\\n\", __func__, 50);\n        return 1;\n    }\n    *equal = '\\x00';\n    key = line;\n    value = equal + 1;\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"full_text\") == 0) {\n        strncpy(props->full_text, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"short_text\") == 0) {\n        strncpy(props->short_text, value, 512 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"color\") == 0) {\n        strncpy(props->color, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2 | 4) & 1) && strcmp(key, \"min_width\") == 0) {\n        strncpy(props->min_width, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"align\") == 0) {\n        strncpy(props->align, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"name\") == 0) {\n        strncpy(props->name, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"instance\") == 0) {\n        strncpy(props->instance, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"urgent\") == 0) {\n        strncpy(props->urgent, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"separator\") == 0) {\n        strncpy(props->separator, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 4) & 1) && strcmp(key, \"separator_block_width\") == 0) {\n        strncpy(props->separator_block_width, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"markup\") == 0) {\n        strncpy(props->markup, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"command\") == 0) {\n        strncpy(props->command, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"interval\") == 0) {\n        strncpy(props->interval, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (4) & 1) && strcmp(key, \"signal\") == 0) {\n        strncpy(props->signal, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"label\") == 0) {\n        strncpy(props->label, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"format\") == 0) {\n        strncpy(props->format, value, 8 - 1);\n        return 0;\n    }\n    ;\n    fprintf(stderr, \"ERROR %s:%d: unknown key: \\\"%s\\\"\\n\", __func__, 63, key);\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int gcd(int a, int b) {\n    while (b != 0)\n        a %= b , a ^= b , b ^= a , a ^= b;\n    return a;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":0,"function":"static int setup_signals(void) {\n    if (sigemptyset(&sigset) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigemptyset: %s\\n\", __func__, 59, strerror((*__errno_location())));\n        return 1;\n    }\n    if (sigaddset(&sigset, 15) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 64, 15, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 2) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 65, 2, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 14) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 66, 14, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 17) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 67, 17, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 10) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 68, 10, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 12) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 69, 12, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 29) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 70, 29, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, (__libc_current_sigrtmin())) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 71, (__libc_current_sigrtmin()), strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    for (int sig = (__libc_current_sigrtmin()) + 1; sig <= (__libc_current_sigrtmax()); ++sig) {\n        if (log_level >= LOG_DEBUG) {\n            fprintf(stderr, \"DEBUG %s:%d: provide signal %d (%s)\\n\", __func__, 73, sig, strsignal(sig));\n        }\n        ;\n        if (sigaddset(&sigset, sig) == -1) {\n            fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 74, sig, strerror((*__errno_location())));\n            return 1;\n        }\n        ;\n    }\n    if (sigprocmask(2, &sigset, ((void *)0)) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigprocmask: %s\\n\", __func__, 78, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":1,"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    while (low < high)\n        {\n            mid = (low + high) / 2;\n            if (x <= v[mid])\n                high = mid;\n            else\n                low = mid + 1;\n        }\n    return x == v[low] ? low : -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long binsearch_name_conflict(unsigned long a0, unsigned int *a1, unsigned long a2) {\n  unsigned long v1;      // rdx, Other Possible Types: unsigned long long\n  unsigned long v2;      // r8, Other Possible Types: unsigned long long\n  unsigned long long v3; // rax\n\n  v1 = (unsigned int)a2 - 1;\n  v2 = 0;\n  while ((unsigned int)v1 > (unsigned int)v2) {\n    v3 = (v1 + v2 >> 31) + v1 + v2 >> 1;\n    if (a1[v3] < (unsigned int)a0)\n      v2 = v3 + 1;\n    else\n      v1 = v3;\n  }\n  if (a1[v2] == (unsigned int)a0)\n    return v2;\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch3/bsearch.c"}
{"compilable":0,"function":"static int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":0,"function":"static int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern unsigned int buffer;\nextern unsigned int bufp;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long getch() {\n  if (bufp <= 0)\n    return getc(stdin @GLIBC_2.2.5);\n  bufp = bufp - 1;\n  return (&buffer)[bufp];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkqei7zt5/getch.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpkqei7zt5/getch.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpkqei7zt5/getch.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpkqei7zt5/getch.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpkqei7zt5/getch.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpkqei7zt5/getch.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpkqei7zt5/getch.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpkqei7zt5/getch.c:108:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 108 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpkqei7zt5/getch.c:108:21: error: expected ';' after top level declarator\n  108 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmpkqei7zt5/getch.c:113:26: error: expected ')'\n  113 |         return getc(stdin@GLIBC_2.2.5);\n      |                          ^\n/tmp/tmpkqei7zt5/getch.c:113:20: note: to match this '('\n  113 |         return getc(stdin@GLIBC_2.2.5);\n      |                    ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":0,"function":"int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern unsigned int buffer;\nextern unsigned int bufp;\nextern FILE_t *stdin @GLIBC_2.2.5;\n\nlong long getch() {\n  if (bufp <= 0)\n    return getc(stdin @GLIBC_2.2.5);\n  bufp = bufp - 1;\n  return (&buffer)[bufp];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcu2ktxf6/getch.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpcu2ktxf6/getch.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpcu2ktxf6/getch.c:73:13: error: declaration of anonymous union must be a\ndefinition 73 |             union <anon> { |             ^\n/tmp/tmpcu2ktxf6/getch.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpcu2ktxf6/getch.c:80:13: error: declaration of anonymous union must be a\ndefinition 80 |             union <anon> { |             ^\n/tmp/tmpcu2ktxf6/getch.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpcu2ktxf6/getch.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpcu2ktxf6/getch.c:108:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 108 | extern FILE_t *stdin@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpcu2ktxf6/getch.c:108:21: error: expected ';' after top level declarator\n  108 | extern FILE_t *stdin@GLIBC_2.2.5;\n      |                     ^\n      |                     ;\n/tmp/tmpcu2ktxf6/getch.c:113:26: error: expected ')'\n  113 |         return getc(stdin@GLIBC_2.2.5);\n      |                          ^\n/tmp/tmpcu2ktxf6/getch.c:113:20: note: to match this '('\n  113 |         return getc(stdin@GLIBC_2.2.5);\n      |                    ^\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(getch)();\nlong long(ungetch)(long long);\n\nlong long getword_name_conflict(char *a0, unsigned long a1) {\n  char *v1;              // rbx, Other Possible Types: unsigned long\n  struct struct_0 **v2;  // rbp\n  char *v3;              // r13\n  unsigned long long v4; // rax\n  char *v5;              // r12, Other Possible Types: unsigned long\n  void *v6;              // rax, Other Possible Types: unsigned long\n\n  v1 = a0;\n  v2 = __ctype_b_loc();\n  do {\n    v6 = getch();\n  } while ((*(1 + &*(v2)->field_0 + 0x2 * v6) & 32));\n  if ((unsigned int)v6 != -1) {\n    *(a0) = (char)v6;\n    v1 = a0 + 1;\n  }\n  if (!(*(1 + &*(v2)->field_0 + 0x2 * v6) & 4)) {\n    *((char *)v1) = 0;\n    return v6;\n  }\n  v5 = v1 + a1 - 2 + 1;\n  if ((unsigned int)a1 <= 1) {\n    v5 = v1;\n  } else {\n    do {\n      v3 = *(v2);\n      v4 = getch();\n      *((char *)v1) = v4;\n      if (!(v3[2 * (char)v4] & 8)) {\n        ungetch((char)v4);\n        v5 = v1;\n        break;\n      }\n    } while ((v1 += 1, v1 != v5));\n  }\n  *((char *)v5) = 0;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9dctujzn/getword_name_conflict.c:33:27: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 33 |     } while ((*(1 + &*(v2)->field_0\n+ 0x2 * v6) & 32)); |                       ~~~~^ ~~~~~~~\n/tmp/tmp9dctujzn/getword_name_conflict.c:33:43: error: invalid operands to binary expression\n('int' and 'void *') 33 |     } while ((*(1 + &*(v2)->field_0 + 0x2 * v6) &\n32)); |                                       ~~~ ^ ~~\n/tmp/tmp9dctujzn/getword_name_conflict.c:39:23: error: member reference base type 'struct\nstruct_0 *' is not a structure or union 39 |     if (!(*(1 + &*(v2)->field_0 +\n0x2 * v6) & 4)) |                   ~~~~^ ~~~~~~~\n/tmp/tmp9dctujzn/getword_name_conflict.c:39:39: error: invalid operands to binary expression\n('int' and 'void *') 39 |     if (!(*(1 + &*(v2)->field_0 + 0x2 * v6) & 4)) |\n~~~ ^ ~~ 4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"char *_strdup(char *word) {\n    char *p = (char *)malloc(strlen(word) + 1);\n    p = strcpy(p, word);\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long _strdup_name_conflict(char *a0) { return strcpy(malloc(strlen(a0) + 1), a0); }\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *__TMC_END__;\n\nlong long get_line(char *a0, unsigned long a1) {\n  char *v1;              // rbp, Other Possible Types: unsigned long\n  char *v2;              // r12\n  unsigned long long v3; // rax\n  unsigned long v4;      // rbx\n\n  if ((unsigned int)a1 <= 1) {\n    v4 = 0;\n  } else {\n    v1 = a0;\n    v2 = a1 - 1;\n    v4 = 0;\n    while (true) {\n      (unsigned int)v3 = getc(__TMC_END__);\n      if (!((unsigned int)v3 != 10) || !((unsigned int)v3 != -1))\n        break;\n      *((char *)v1) = v3;\n      v4 = (unsigned int)v4 + 1;\n      v1 += 1;\n      if ((unsigned int)v4 == (unsigned int)v2) {\n      LABEL_40118c:\n        *((char *)(a0 + v2)) = 0;\n        return v2;\n      }\n    }\n  }\n  if ((unsigned int)v3 == 10) {\n    a0[v4] = 10;\n    v4 += 1;\n    goto LABEL_40118c;\n  }\n  a0[v4] = 0;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv4zt505u/get_line.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpv4zt505u/get_line.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpv4zt505u/get_line.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmpv4zt505u/get_line.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpv4zt505u/get_line.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmpv4zt505u/get_line.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpv4zt505u/get_line.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpv4zt505u/get_line.c:106:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 106 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpv4zt505u/get_line.c:126:13: error: assignment to cast is illegal, lvalue\ncasts are not supported 126 |             (unsigned int)v3 = getc(__TMC_END__);\n      |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpv4zt505u/get_line.c:135:31: error: invalid operands to binary expression\n('char *' and 'char *') 135 |                 *((char *)(a0 + v2)) = 0; | ~~ ^\n~~ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/116.c"}
{"compilable":0,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *__TMC_END__;\n\nlong long get_line(char *a0, unsigned long a1) {\n  char *v1;              // rbp, Other Possible Types: unsigned long\n  char *v2;              // r12\n  unsigned long long v3; // rax\n  unsigned long v4;      // rbx\n\n  if ((unsigned int)a1 <= 1) {\n    v4 = 0;\n  } else {\n    v1 = a0;\n    v2 = a1 - 1;\n    v4 = 0;\n    while (true) {\n      (unsigned int)v3 = getc(__TMC_END__);\n      if (!((unsigned int)v3 != 10) || !((unsigned int)v3 != -1))\n        break;\n      *((char *)v1) = v3;\n      v4 = (unsigned int)v4 + 1;\n      v1 += 1;\n      if ((unsigned int)v4 == (unsigned int)v2) {\n      LABEL_40118c:\n        *((char *)(a0 + v2)) = 0;\n        return v2;\n      }\n    }\n  }\n  if ((unsigned int)v3 == 10) {\n    a0[v4] = 10;\n    v4 += 1;\n    goto LABEL_40118c;\n  }\n  a0[v4] = 0;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfg5b9jao/get_line.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpfg5b9jao/get_line.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpfg5b9jao/get_line.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmpfg5b9jao/get_line.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpfg5b9jao/get_line.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmpfg5b9jao/get_line.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpfg5b9jao/get_line.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpfg5b9jao/get_line.c:106:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 106 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpfg5b9jao/get_line.c:126:13: error: assignment to cast is illegal, lvalue\ncasts are not supported 126 |             (unsigned int)v3 = getc(__TMC_END__);\n      |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpfg5b9jao/get_line.c:135:31: error: invalid operands to binary expression\n('char *' and 'char *') 135 |                 *((char *)(a0 + v2)) = 0; | ~~ ^\n~~ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/get_line.c"}
{"compilable":0,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(getc)(struct FILE_t {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker {\n    struct _IO_marker {\n\n    } *_next;\n    struct FILE {\n\n    } *_sbuf;\n    int _pos;\n  } *_markers;\n  struct _IO_FILE {\n\n  } *_chain;\n  int _fileno;\n  int _flags2;\n  long _old_offset;\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  struct pthread_mutex_t {\n\n  } *_lock;\n  long long _offset;\n  struct _IO_codecvt {\n    struct _IO_iconv_t {\n\n    } __cd_in;\n    struct _IO_iconv_t {\n\n    } __cd_out;\n  } *_codecvt;\n  struct _IO_wide_data {\n    short *_IO_read_ptr;\n    short *_IO_read_end;\n    short *_IO_read_base;\n    short *_IO_write_base;\n    short *_IO_write_ptr;\n    short *_IO_write_end;\n    short *_IO_buf_base;\n    short *_IO_buf_end;\n    short *_IO_save_base;\n    short *_IO_backup_base;\n    short *_IO_save_end;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_state;\n    struct __mbstate_t {\n      int __count;\n      union<anon> {\n        unsigned int __wch;\n        char __wchb[4];\n      } __value;\n    } _IO_last_state;\n    struct _IO_codecvt {\n      struct _IO_iconv_t {\n\n      } __cd_in;\n      struct _IO_iconv_t {\n\n      } __cd_out;\n    } _codecvt;\n    short _shortbuf[1];\n    struct _IO_jump_t {\n\n    } _wide_vtable;\n  } *_wide_data;\n  struct _IO_FILE {\n\n  } *_freeres_list;\n  unsigned long __pad5;\n  int _mode;\n  char _unused2[20];\n} *);\n\nextern FILE_t *__TMC_END__;\n\nlong long get_line(char *a0, unsigned long a1) {\n  char *v1;              // rbp, Other Possible Types: unsigned long\n  char *v2;              // r12\n  unsigned long long v3; // rax\n  unsigned long v4;      // rbx\n\n  if ((unsigned int)a1 <= 1) {\n    v4 = 0;\n  } else {\n    v1 = a0;\n    v2 = a1 - 1;\n    v4 = 0;\n    while (true) {\n      (unsigned int)v3 = getc(__TMC_END__);\n      if (!((unsigned int)v3 != 10) || !((unsigned int)v3 != -1))\n        break;\n      *((char *)v1) = v3;\n      v4 = (unsigned int)v4 + 1;\n      v1 += 1;\n      if ((unsigned int)v4 == (unsigned int)v2) {\n      LABEL_40118c:\n        *((char *)(a0 + v2)) = 0;\n        return v2;\n      }\n    }\n  }\n  if ((unsigned int)v3 == 10) {\n    a0[v4] = 10;\n    v4 += 1;\n    goto LABEL_40118c;\n  }\n  a0[v4] = 0;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyfz6jgfu/get_line.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpyfz6jgfu/get_line.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpyfz6jgfu/get_line.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmpyfz6jgfu/get_line.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpyfz6jgfu/get_line.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmpyfz6jgfu/get_line.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpyfz6jgfu/get_line.c:16:6: error: conflicting types for 'getc'\n   16 | int (getc)(struct FILE_t {\n      |      ^\n/usr/include/stdio.h:514:12: note: previous declaration is here\n  514 | extern int getc (FILE *__stream);\n      |            ^\n/tmp/tmpyfz6jgfu/get_line.c:106:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 106 | extern FILE_t *__TMC_END__; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpyfz6jgfu/get_line.c:126:13: error: assignment to cast is illegal, lvalue\ncasts are not supported 126 |             (unsigned int)v3 = getc(__TMC_END__);\n      |             ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpyfz6jgfu/get_line.c:135:31: error: invalid operands to binary expression\n('char *' and 'char *') 135 |                 *((char *)(a0 + v2)) = 0; | ~~ ^\n~~ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/117.c"}
{"compilable":0,"function":"static int test(int argc, char **argv, int t) {\n    static struct iovec iov[1024];\n    const int bs = 4 << 10;\n    const ssize_t s = bs * 1024;\n    char *p = (char *)mmap(0, bs * 1024, 1 | 2, 2 | 32, -1, 0);\n    int i;\n    for (i = 1024 - 1; i >= 0; i--) {\n        iov[i].iov_base = p;\n        iov[i].iov_len = bs;\n        *p = i;\n        p += bs;\n    }\n    for (i = 1; i < argc; i++) {\n        const char *nm = \"none\";\n        const double cs = (double)sysconf(_SC_CLK_TCK);\n        struct tms ptms, ctms;\n        clock_t pt, ct;\n        int l = 1 << 8;\n        int k = l;\n        const int fd = open(argv[i], 2 | 64 | 16384 | 262144, 438);\n        if (fd < 0) {\n            perror(argv[i]);\n            return 1;\n        }\n        pt = times(&ptms);\n        while (k-- > 0)\n            {\n                ssize_t n;\n                switch (t) {\n                  case 0:\n                    nm = \"write\";\n                    n = write(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 1:\n                    nm = \"writev\";\n                    n = writev(fd, iov, 1024);\n                    break;\n                  case 2:\n                    nm = \"read\";\n                    n = read(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 3:\n                    nm = \"readv\";\n                    n = readv(fd, iov, 1024);\n                    break;\n                  default:\n                    n = 0;\n                    break;\n                }\n                if (n != s) {\n                    perror(argv[i]);\n                    return 1;\n                }\n                if ((k & 63) == 0) {\n                    lseek(fd, 0, 0);\n                }\n            }\n        ct = times(&ctms);\n        {\n            const double d = (ct != pt) ? ct - pt : 1.0000000000000001E-9;\n            printf(\"u: %6.2f%% s: %6.2f%% w: %6.2f s %6.2f MB/s %s\\n\", (ctms.tms_utime - ptms.tms_utime) / d * 100, (ctms.tms_stime - ptms.tms_stime) / d * 100, d / cs, cs * l * s / ((1 << 20) * d), nm);\n        }\n        close(fd);\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/sumedhsakdeo_zynx/src/cc/qcdio/iovperf.c"}
{"compilable":0,"function":"static int print_dirlist(char *filename) {\n    struct dirent *de;\n    char c;\n    DIR *d;\n    fprintf(stdout, \"<br><br>--------<pre>Directory listing for %s:\\n\\n\", filename);\n    d = opendir(filename);\n    if (!d) {\n        fprintf(stdout, \"No such directory\\n</pre>\");\n        return -1;\n    }\n    while (de = readdir(d))\n        {\n            if (de->d_type == DT_DIR)\n                fprintf(stdout, \"%s/\\n\", de->d_name);\n            else\n                fprintf(stdout, \"%s\\n\", de->d_name);\n        }\n    closedir(d);\n    fprintf(stdout, \"</pre>\");\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int write_to_file(char *filename, char *writeval) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"w\");\n    if (!fp)\n        return -1;\n    fprintf(stdout, \"<br><br>--------<pre>Writing %s to file %s:\\n\\n\", writeval, filename);\n    if (fwrite(writeval, strlen(writeval), 1, fp) < strlen(writeval))\n        fprintf(stdout, \"Write failed\\n\");\n    else\n        fprintf(stdout, \"Write succeeded\\n\");\n    fprintf(stdout, \"</pre>\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int cat_file(char *filename) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"r\");\n    if (!fp) {\n        fprintf(stdout, \"No such file or directory\\n</pre>\");\n        return -1;\n    }\n    fprintf(stdout, \"<br><br>--------<pre>Contents of file %s:\\n\\n\", filename);\n    while (getline(&line, &len, fp) != -1)\n        fprintf(stdout, \"%s\", line);\n    fprintf(stdout, \"</pre>\");\n    free(line);\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int test(int do_exit) {\n    pthread_t t;\n    pthread_create(&t, ((void *)0), thread1_func, (void *)do_exit);\n    pthread_join(t, ((void *)0));\n    if (g_ok1 != +1) {\n        if (g_ok1 == 0) {\n            fprintf(stderr, \"cleanup1 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup1 called with wrong argument\\n\");\n        }\n        exit(1);\n    } else if (g_ok2 != +1) {\n        if (g_ok2 == 0)\n            fprintf(stderr, \"cleanup2 not called !!\\n\");\n        else\n            fprintf(stderr, \"cleanup2 called with wrong argument\\n\");\n        exit(2);\n    } else if (do_exit && g_ok3 != +1) {\n        if (g_ok3 == 0) {\n            fprintf(stderr, \"cleanup3 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 called with bad argument !!\\n\");\n        }\n        exit(3);\n    } else if (!do_exit && g_ok3 != 0) {\n        if (g_ok3 == 1) {\n            fprintf(stderr, \"cleanup3 wrongly called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 wrongly called with bad argument !!\\n\");\n        }\n        exit(3);\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint thread1_func; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(pthread_create)(char *, char *, char *, char *);\n\nextern unsigned int g_ok1;\nextern unsigned int g_ok2;\nextern unsigned int g_ok3;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long test_name_conflict(char *a0) {\n  char v0; // [bp-0x10]\n\n  pthread_create(&v0, NULL, thread1_func, a0);\n  pthread_join(*((long long *)&v0), 0);\n  if (g_ok1 != 1) {\n    if (!g_ok1)\n      fwrite(\"cleanup1 not called !!\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    else\n      fwrite(\"cleanup1 called with wrong argument\\n\", 1, 36,\n             stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  } else if (g_ok2 != 1) {\n    if (!g_ok2)\n      fwrite(\"cleanup2 not called !!\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    else\n      fwrite(\"cleanup2 called with wrong argument\\n\", 1, 36,\n             stderr @GLIBC_2.2.5);\n    exit(2); /* do not return */\n  } else if ((unsigned int)a0) {\n    if (g_ok3 == 1)\n      return 0;\n    if (!g_ok3)\n      fwrite(\"cleanup3 not called !!\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    else\n      fwrite(\"cleanup3 called with bad argument !!\\n\", 1, 37,\n             stderr @GLIBC_2.2.5);\n    exit(3); /* do not return */\n  } else {\n    if (!g_ok3)\n      return 0;\n    if (g_ok3 != 1)\n      fwrite(\"cleanup3 wrongly called with bad argument !!\\n\", 1, 45,\n             stderr @GLIBC_2.2.5);\n    else\n      fwrite(\"cleanup3 wrongly called !!\\n\", 1, 27, stderr @GLIBC_2.2.5);\n    exit(3); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp0_0t4a4m/test_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp0_0t4a4m/test_name_conflict.c:22:22: error: expected ';' after top level declarator\n   22 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmp0_0t4a4m/test_name_conflict.c:33:61: error: expected ')'\n   33 |             fwrite(\"cleanup1 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:33:19: note: to match this '('\n   33 |             fwrite(\"cleanup1 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:35:74: error:\nexpected ')' 35 |             fwrite(\"cleanup1 called with wrong argument\\n\", 1,\n36, stderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:35:19: note: to match this\n'(' 35 |             fwrite(\"cleanup1 called with wrong argument\\n\", 1, 36,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:41:61: error:\nexpected ')' 41 |             fwrite(\"cleanup2 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:41:19: note: to match this '('\n   41 |             fwrite(\"cleanup2 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:43:74: error:\nexpected ')' 43 |             fwrite(\"cleanup2 called with wrong argument\\n\", 1,\n36, stderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:43:19: note: to match this\n'(' 43 |             fwrite(\"cleanup2 called with wrong argument\\n\", 1, 36,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:51:61: error:\nexpected ')' 51 |             fwrite(\"cleanup3 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:51:19: note: to match this '('\n   51 |             fwrite(\"cleanup3 not called !!\\n\", 1, 23,\nstderr@GLIBC_2.2.5); |                   ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:53:75: error:\nexpected ')' 53 |             fwrite(\"cleanup3 called with bad argument !!\\n\",\n1, 37, stderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:53:19: note: to match\nthis '(' 53 |             fwrite(\"cleanup3 called with bad argument !!\\n\", 1,\n37, stderr@GLIBC_2.2.5); |                   ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:61:83:\nerror: expected ')' 61 |             fwrite(\"cleanup3 wrongly called with bad\nargument !!\\n\", 1, 45, stderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:61:19:\nnote: to match this '(' 61 |             fwrite(\"cleanup3 wrongly called with\nbad argument !!\\n\", 1, 45, stderr@GLIBC_2.2.5); |                   ^\n/tmp/tmp0_0t4a4m/test_name_conflict.c:63:65: error: expected ')'\n   63 |             fwrite(\"cleanup3 wrongly called !!\\n\", 1, 27,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp0_0t4a4m/test_name_conflict.c:63:19: note: to match this '('\n   63 |             fwrite(\"cleanup3 wrongly called !!\\n\", 1, 27,\nstderr@GLIBC_2.2.5); |                   ^ 10 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/common/test_pthread_cleanup_push.c"}
{"compilable":0,"function":"static int check_library(const char *libname) {\n    void *lib = dlopen(libname, 2);\n    int *to_x;\n    void (*set_y)(int *);\n    int y = 0;\n    if (lib == ((void *)0)) {\n        fprintf(stderr, \"Could not load shared library %s: %s\\n\", libname, dlerror());\n        return 1;\n    }\n    fprintf(stderr, \"%s loaded.\\n\", libname);\n    to_x = dlsym(lib, \"x\");\n    if (to_x == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL variable (x) in %s: %s\\n\", libname, dlerror());\n        return 10;\n    }\n    if (*to_x != 1) {\n        fprintf(stderr, \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", libname);\n        return 11;\n    }\n    set_y = dlsym(lib, \"set_y\");\n    if (set_y == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL function (set_y) in %s: %s\\n\", libname, dlerror());\n        return 12;\n    }\n    y = 0;\n    (*set_y)(&y);\n    if (dlclose(lib) < 0) {\n        fprintf(stderr, \"Could not unload shared library %s: %s\\n\", libname, dlerror());\n        return 2;\n    }\n    fprintf(stderr, \"%s unloaded.\\n\", libname);\n    if (y != 2) {\n        fprintf(stderr, \"Static destructors was not called on dlclose()!\\n\");\n        return 2;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long check_library_name_conflict(unsigned long a0) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned long long v2; // rax\n  unsigned long long v3; // rbp\n  unsigned int *v4;      // rax\n  struct struct_0 **v5;  // rax\n\n  (unsigned int)v2 = dlopen();\n  v0 = 0;\n  if (!v2) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not load shared library %s: %s\\n\",\n            (unsigned int)a0, dlerror());\n    return 1;\n  }\n  v3 = v2;\n  fprintf(stderr @GLIBC_2.2.5, \"%s loaded.\\n\", (unsigned int)a0);\n  (unsigned int)v4 = dlsym(v2, \"x\");\n  if (!v4) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not access global DLL variable (x) in %s: %s\\n\",\n            (unsigned int)a0, dlerror());\n    return 10;\n  } else if (*(v4) != 1) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", (unsigned int)a0);\n    return 11;\n  } else if (!dlsym(v3, \"set_y\")) {\n    fprintf(stderr @GLIBC_2.2.5,\n            \"Could not access global DLL function (set_y) in %s: %s\\n\",\n            (unsigned int)a0, dlerror());\n    return 12;\n  } else {\n    v0 = 0;\n    v5(&v0);\n    if (dlclose(v3) < 0) {\n      fprintf(stderr @GLIBC_2.2.5, \"Could not unload shared library %s: %s\\n\",\n              (unsigned int)a0, dlerror());\n      return 2;\n    }\n    fprintf(stderr @GLIBC_2.2.5, \"%s unloaded.\\n\", (unsigned int)a0);\n    if (v0 != 2) {\n      fwrite(\"Static destructors was not called on dlclose()!\\n\", 1, 48,\n             stderr @GLIBC_2.2.5);\n      return 2;\n    }\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did\nyou mean 'FILE'? 17 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:27:5: error: assignment to cast is illegal,\nlvalue casts are not supported 27 |     (unsigned int)v2 = dlopen(); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpo5wj2dxe/check_library_name_conflict.c:31:23: error: expected ')'\n   31 |         fprintf(stderr@GLIBC_2.2.5, \"Could not load shared library %s:\n%s\\n\", (unsigned int)a0, dlerror()); |                       ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:31:16: note: to match this '('\n   31 |         fprintf(stderr@GLIBC_2.2.5, \"Could not load shared library %s:\n%s\\n\", (unsigned int)a0, dlerror()); |                ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:35:19: error: expected ')'\n   35 |     fprintf(stderr@GLIBC_2.2.5, \"%s loaded.\\n\", (unsigned int)a0);\n      |                   ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:35:12: note: to match this '('\n   35 |     fprintf(stderr@GLIBC_2.2.5, \"%s loaded.\\n\", (unsigned int)a0);\n      |            ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:36:5: error: assignment to cast is illegal,\nlvalue casts are not supported 36 |     (unsigned int)v4 = dlsym(v2, \"x\"); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpo5wj2dxe/check_library_name_conflict.c:39:23: error: expected ')'\n   39 |         fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nvariable (x) in %s: %s\\n\", (unsigned int)a0, dlerror()); | ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:39:16: note: to match this '('\n   39 |         fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nvariable (x) in %s: %s\\n\", (unsigned int)a0, dlerror()); |                ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:44:23: error: expected ')'\n   44 |         fprintf(stderr@GLIBC_2.2.5, \"Constructor was not run on\ndlopen(\\\"%s\\\") !\\n\", (unsigned int)a0); |                       ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:44:16: note: to match this '('\n   44 |         fprintf(stderr@GLIBC_2.2.5, \"Constructor was not run on\ndlopen(\\\"%s\\\") !\\n\", (unsigned int)a0); |                ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:49:23: error: expected ')'\n   49 |         fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nfunction (set_y) in %s: %s\\n\", (unsigned int)a0, dlerror()); | ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:49:16: note: to match this '('\n   49 |         fprintf(stderr@GLIBC_2.2.5, \"Could not access global DLL\nfunction (set_y) in %s: %s\\n\", (unsigned int)a0, dlerror()); |                ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:55:11: error: called object type 'struct\nstruct_0 **' is not a function or function pointer 55 |         v5(&v0); | ~~^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:58:27: error: expected ')'\n   58 |             fprintf(stderr@GLIBC_2.2.5, \"Could not unload shared library\n%s: %s\\n\", (unsigned int)a0, dlerror()); |                           ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:58:20: note: to match this '('\n   58 |             fprintf(stderr@GLIBC_2.2.5, \"Could not unload shared library\n%s: %s\\n\", (unsigned int)a0, dlerror()); |                    ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:61:23: error: expected ')'\n   61 |         fprintf(stderr@GLIBC_2.2.5, \"%s unloaded.\\n\", (unsigned int)a0);\n      |                       ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:61:16: note: to match this '('\n   61 |         fprintf(stderr@GLIBC_2.2.5, \"%s unloaded.\\n\", (unsigned int)a0);\n      |                ^\n/tmp/tmpo5wj2dxe/check_library_name_conflict.c:64:86: error: expected ')'\n   64 |             fwrite(\"Static destructors was not called on dlclose()!\\n\",\n1, 48, stderr@GLIBC_2.2.5); | ^ /tmp/tmpo5wj2dxe/check_library_name_conflict.c:64:19: note: to\nmatch this '(' 64 |             fwrite(\"Static destructors was not called on\ndlclose()!\\n\", 1, 48, stderr@GLIBC_2.2.5); |                   ^ 13 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/bionic/test_dlclose_destruction.c"}
{"compilable":0,"function":"static unsigned long long stop_watch() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return t.tv_sec * 1000000000ULL + t.tv_nsec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long stop_watch_name_conflict() {\n  void *v0; // [bp-0x18]\n  void *v1; // [bp-0x10]\n\n  v1 = 0;\n  v0 = 0;\n  clock_gettime(0x1, &v0);\n  return v0 * 0x3b9aca00 + v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoi7sywx5/stop_watch_name_conflict.c:26:15: error: invalid operands to binary\nexpression ('void *' and 'int') 26 |     return v0 * 0x3b9aca00 + v1; | ~~ ^\n~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/pftest/pftest.c"}
{"compilable":0,"function":"int64_t systemTime() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return (int64_t)(t.tv_sec) * 1000000000LL + t.tv_nsec;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(clock_gettime)(char *, char *);\n\nlong long systemTime_name_conflict() {\n  void *v0; // [bp-0x18]\n  void *v1; // [bp-0x10]\n\n  v1 = 0;\n  v0 = 0;\n  clock_gettime(0x1, &v0);\n  return v0 * 0x3b9aca00 + v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7bsxydfn/systemTime_name_conflict.c:26:15: error: invalid operands to binary\nexpression ('void *' and 'int') 26 |     return v0 * 0x3b9aca00 + v1; | ~~ ^\n~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/framebuffer/refresh.c"}
{"compilable":0,"function":"static u64 get_block_device_size(int fd) {\n    u64 size = 0;\n    int ret;\n    ret = ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((114)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &size);\n    if (ret)\n        return 0;\n    return size;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static int wipe_block_device(int fd, u64 len, int secure) {\n    u64 range[2];\n    int ret;\n    int req;\n    range[0] = 0;\n    range[1] = len;\n    if (secure) {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((125)) << 0) | ((0) << ((0 + 8) + 8)));\n    } else {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((119)) << 0) | ((0) << ((0 + 8) + 8)));\n    }\n    ret = ioctl(fd, req, &range);\n    if (ret < 0) {\n        fprintf(stderr, \"%s discard failed, errno = %d\\n\", secure ? \"Secure\" : \"Nonsecure\", (*__errno_location()));\n    }\n    return ret;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static uid_t str2uid(char *str, int line_num) {\n    struct passwd *pw;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(pw = getpwnam(str))) {\n        printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return pw->pw_uid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct passwd *(getpwnam)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long str2uid_name_conflict(char *a0, unsigned long a1) {\n  struct_0 *v1;     // rax\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  if ((*((char *)(*((long long *)&__ctype_b_loc()) + (*(a0) << 1) + 1)) & 8)) {\n    v2 = strtol(a0, NULL, 10);\n    return v2;\n  }\n  v1 = getpwnam(a0);\n  if (v1) {\n    v2 = v1->field_10;\n    return v2;\n  }\n  printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", (unsigned int)a0,\n         (unsigned int)a1);\n  exit(255); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjmk8dyod/str2uid_name_conflict.c:28:36: error: cannot take the address of an rvalue of\ntype 'int' 28 |     if ((*((char *)(*((long long *)&__ctype_b_loc()) + (*(a0) <<\n1) + 1)) & 8)) |                                    ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static gid_t str2gid(char *str, int line_num) {\n    struct group *gr;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(gr = getgrnam(str))) {\n        printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return gr->gr_gid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nstruct group *(getgrnam)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[16];\n  unsigned int field_10;\n} struct_0;\n\nlong long str2gid_name_conflict(char *a0, unsigned long a1) {\n  struct_0 *v1;     // rax\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  if ((*((char *)(*((long long *)&__ctype_b_loc()) + (*(a0) << 1) + 1)) & 8)) {\n    v2 = strtol(a0, NULL, 10);\n    return v2;\n  }\n  v1 = getgrnam(a0);\n  if (v1) {\n    v2 = v1->field_10;\n    return v2;\n  }\n  printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", (unsigned int)a0,\n         (unsigned int)a1);\n  exit(255); /* do not return */\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgai6z4an/str2gid_name_conflict.c:28:36: error: cannot take the address of an rvalue of\ntype 'int' 28 |     if ((*((char *)(*((long long *)&__ctype_b_loc()) + (*(a0) <<\n1) + 1)) & 8)) |                                    ^~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_file(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for file: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[WILDCARD];\n    while (pr != ((void *)0))\n        {\n            if ((strstr(name, pr->spec) == name) && (!strchr(name + strlen(pr->spec), '/'))) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_link(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for link: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_dir(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_DIR];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for directory: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int check_path(const char *name) {\n    char namebuf[4097];\n    char tmp[4097];\n    DIR *d;\n    struct dirent *de;\n    struct stat s;\n    int err;\n    int retval = 0;\n    err = lstat(name, &s);\n    if (err < 0) {\n        if ((*__errno_location()) != 2) {\n            perror(name);\n            return 1;\n        }\n        return 0;\n    }\n    if (((((s.st_mode)) & 61440) == (16384))) {\n        if (name[strlen(name) - 1] != '/')\n            snprintf(namebuf, sizeof (namebuf), \"%s/\", name);\n        else\n            snprintf(namebuf, sizeof (namebuf), \"%s\", name);\n        retval |= validate_dir(namebuf, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n        d = opendir(namebuf);\n        if (d == 0) {\n            printf(\"%s : opendir failed: %s\\n\", namebuf, strerror((*__errno_location())));\n            return 1;\n        }\n        while ((de = readdir(d)) != 0)\n            {\n                if (!strcmp(de->d_name, \".\") || !strcmp(de->d_name, \"..\"))\n                    continue;\n                snprintf(tmp, sizeof (tmp), \"%s%s\", namebuf, de->d_name);\n                retval |= check_path(tmp);\n            }\n        closedir(d);\n        return retval;\n    } else if (((((s.st_mode)) & 61440) == (40960))) {\n        return validate_link(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    } else {\n        return validate_file(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(lstat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nvoid(perror)(char *);\nint(snprintf)(char *, unsigned long, char *, ...);\nlong long(pass_rule)(long long, long long, long long, long long);\nchar *(opendir)(char *);\nlong long(print_new_rule)(long long, long long, long long, long long);\nchar *(strerror)(int);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nlong long(check_path_name_conflict)(char *);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[16];\n  char *field_10;\n  char padding_18[32];\n  struct struct_1 *field_38;\n} struct_1;\n\ntypedef struct struct_2 {\n  char padding_0[16];\n  unsigned long long field_10;\n  char padding_18[32];\n  struct struct_2 *field_38;\n} struct_2;\n\nextern char g_40204b;\nextern struct_2 *g_404128;\nextern struct_2 *g_404130;\nextern struct_2 *g_404138;\nextern struct_2 *rules;\n\nlong long check_path_name_conflict(char *a0) {\n  struct_0 *v0;           // [bp-0x20f8], Other Possible Types: unsigned int\n  struct_0 *v1;           // [bp-0x20ec], Other Possible Types: unsigned int\n  stat v2;                // [bp-0x20e8]\n  char v3;                // [bp-0x20d0]\n  char v4;                // [bp-0x20cc]\n  char v5;                // [bp-0x20c8]\n  char v6;                // [bp-0x2058]\n  char v7;                // [bp-0x1048]\n  struct_0 *v9;           // r13d\n  struct_0 *v10;          // eax\n  unsigned long long v11; // r14\n  unsigned long long v12; // r15\n  unsigned long long v13; // r15\n  unsigned long long v14; // r14\n  unsigned long long v15; // r13\n  unsigned long v16;      // rbp, Other Possible Types: unsigned long long\n  void *v17;              // r13, Other Possible Types: unsigned long\n  struct_1 *v18;          // r12, Other Possible Types: unsigned long\n  struct_1 *v19;          // r12, Other Possible Types: unsigned long\n  unsigned long long v20; // r15\n  unsigned long long v21; // r14\n  unsigned long long v22; // r13\n  struct_1 *v23;          // rbx, Other Possible Types: unsigned long\n  struct_2 *v24;          // r12, Other Possible Types: unsigned long\n  struct_1 *v25;          // r12, Other Possible Types: unsigned long\n  char *v26;              // r13\n  struct_1 *v27;          // rbx, Other Possible Types: unsigned long\n  char *v28;              // r12\n  char *v30;              // rbx\n\n  if (lstat(a0, &v2) < 0) {\n    if (*(__errno_location()) == 2)\n      return 0;\n    perror(a0);\n    return 1;\n  }\n  v9 = *((int *)&v3);\n  v10 = v9 & 0xf000;\n  if (v10 == 0x4000) {\n    if (a0[1 + strlen(a0)] != 47)\n      snprintf(&v7, 4097, \"%s/\", (unsigned int)a0);\n    else\n      snprintf(&v7, 4097, \"%s\", (unsigned int)a0);\n    v20 = *((int *)&v5);\n    v21 = *((int *)&v4);\n    v22 = *((int *)&v3) & -61441;\n    v23 = g_404128;\n    if (!g_404128) {\n      v16 = 0;\n    LABEL_401905:\n      if ((unsigned int)v16) {\n        v16 = 0;\n      } else {\n        v27 = g_404138;\n        if (g_404138) {\n          *((unsigned int *)&v0) = v16;\n          do {\n            if (&v7 == strstr(&v7, *((long long *)(v27 + 16)))) {\n              if ((int)pass_rule(v27, v22, v21, v20))\n                v0 = (int)v0 + 1;\n              else\n                v16 = (unsigned int)v16 + 1;\n            }\n          } while ((v27 = *((long long *)(v27 + 56)), v27));\n          if (!(!v0))\n            goto LABEL_4019a5;\n        }\n        v16 = (unsigned int)v16 + 1;\n      LABEL_4019a5:\n        if ((unsigned int)v16)\n          print_new_rule(&v7, v22, v21, v20);\n      }\n    } else {\n      v16 = 0;\n      *((int *)&v0) = 0;\n      do {\n        if (!strcmp(&v7, *((long long *)(v23 + 16)))) {\n          if (!(int)pass_rule(v23, v22, v21, v20))\n            v0 = (int)v0 + 1;\n          else\n            v16 = (unsigned int)v16 + 1;\n        }\n      } while ((v27 = *((long long *)(v27 + 56)), v27));\n      if ((unsigned int)(v0 + v16) > 1)\n        printf(\"# WARNING # Multiple exact rules for directory: %s\\n\",\n               (unsigned int)&v7);\n      if (!v0)\n        goto LABEL_401905;\n      print_new_rule(&v7, v22, v21, v20);\n      v16 = v0;\n    }\n    v28 = opendir(&v7);\n    if (!v28) {\n      printf(\"%s : opendir failed: %s\\n\", (unsigned int)&v7,\n             (unsigned int)strerror(*(__errno_location())));\n      return 1;\n    }\n    v0 = &v7;\n    while (true) {\n      do {\n        do {\n          if (!readdir(v28)) {\n            closedir(v28);\n            return v16;\n          }\n        } while ((v27 = *((long long *)(v27 + 56)), v27));\n      } while (!strcmp(v30, \"..\"));\n      snprintf(&v6, 4097, \"%s%s\", (unsigned int)v0, (unsigned int)v30);\n      v16 = (unsigned int)v16 | (int)check_path_name_conflict(&v6);\n    }\n  } else if (v10 != 0xa000) {\n    v11 = *((int *)&v5);\n    v12 = *((int *)&v4);\n    v0 = v9 & -61441;\n    v18 = rules;\n    if (!rules) {\n      v16 = 0;\n    } else {\n      v16 = 0;\n      v17 = 0;\n      do {\n        if (!strcmp(a0, *((long long *)(v18 + 16)))) {\n          if ((int)pass_rule(v18, v0, v12, v11))\n            v16 = (unsigned int)v16 + 1;\n          else\n            v17 = (unsigned int)v17 + 1;\n        }\n      } while ((v27 = *((long long *)(v27 + 56)), v27));\n      if ((unsigned int)(v16 + v17) > 1)\n        printf(\"# WARNING # Multiple exact rules for file: %s\\n\",\n               (unsigned int)a0);\n      if ((unsigned int)v17) {\n        print_new_rule(a0, v0, v12, v11);\n        return v17;\n      }\n    }\n    if ((unsigned int)v16)\n      return 0;\n    v24 = g_404130;\n    if (!g_404130) {\n      v25 = g_404138;\n      v1 = v16;\n      if (!g_404138)\n        goto LABEL_401c54;\n    } else {\n      *((unsigned int *)&v1) = v16;\n      do {\n        v26 = *((long long *)(v24 + 16));\n        if (a0 == strstr(a0, v26) && !strchr(&a0[strlen(v26)], 47)) {\n          if ((int)pass_rule(v24, v0, v12, v11))\n            *((unsigned int *)&v1) = v1 + 1;\n          else\n            v16 = (unsigned int)v16 + 1;\n        }\n      } while ((v27 = *((long long *)(v27 + 56)), v27));\n      v25 = g_404138;\n      if (!g_404138)\n        goto LABEL_401c4a;\n    }\n    do {\n      if (a0 == strstr(a0, *((long long *)(v25 + 16)))) {\n        if ((int)pass_rule(v25, v0, v12, v11))\n          *((unsigned int *)&v1) = v1 + 1;\n        else\n          v16 = (unsigned int)v16 + 1;\n      }\n    } while ((v27 = *((long long *)(v27 + 56)), v27));\n  LABEL_401c4a:\n    if (!v1)\n      v16 = (unsigned int)v16 + 1;\n  LABEL_401c54:\n    if ((unsigned int)v16) {\n      print_new_rule(a0, v0, v12, v11);\n      return v16;\n    }\n    return v16;\n  } else {\n    v13 = *((int *)&v5);\n    v14 = *((int *)&v4);\n    v15 = v9 & -61441;\n    v19 = rules;\n    if (!rules)\n      return 0;\n    *((int *)&v0) = 0;\n    v16 = 0;\n    do {\n      if (!strcmp(a0, *((long long *)(v19 + 16)))) {\n        if (!(int)pass_rule(v19, v15, v14, v13))\n          v16 = (unsigned int)v16 + 1;\n        else\n          v0 = (int)v0 + 1;\n      }\n    } while ((v27 = *((long long *)(v27 + 56)), v27));\n    if ((unsigned int)(v0 + v16) > 1)\n      printf(\"# WARNING # Multiple exact rules for link: %s\\n\",\n             (unsigned int)a0);\n    if ((unsigned int)v16) {\n      print_new_rule(a0, v15, v14, v13);\n      return v16;\n    }\n    return v16;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdkbkvayj/check_path_name_conflict.c:28:7: error: conflicting types for 'perror'\n   28 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpdkbkvayj/check_path_name_conflict.c:29:6: error: conflicting types for 'snprintf'\n   29 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpdkbkvayj/check_path_name_conflict.c:116:13: error: indirection requires pointer\noperand ('int' invalid) 116 |         if (*(__errno_location()) == 2) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpdkbkvayj/check_path_name_conflict.c:122:14: error: invalid\noperands to binary expression ('struct_0 *' (aka 'struct struct_0 *') and 'int')\n  122 |     v10 = v9 & 0xf000;\n      |           ~~ ^ ~~~~~~\n/tmp/tmpdkbkvayj/check_path_name_conflict.c:190:91: error: indirection requires pointer\noperand ('int' invalid) 190 |             printf(\"%s : opendir failed: %s\\n\",\n(unsigned int)&v7, (unsigned int)strerror(*(__errno_location()))); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpdkbkvayj/check_path_name_conflict.c:215:17: error: invalid\noperands to binary expression ('struct_0 *' (aka 'struct struct_0 *') and 'int')\n  215 |         v0 = v9 & -61441;\n      |              ~~ ^ ~~~~~~\n/tmp/tmpdkbkvayj/check_path_name_conflict.c:296:18: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'int') 296 |         v15\n= v9 & -61441; |               ~~ ^ ~~~~~~ 7 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int get_cpu_count() {\n    int cpu_count = get_cpu_count_from_file(\"/sys/devices/system/cpu/present\");\n    if (cpu_count != get_cpu_count_from_file(\"/sys/devices/system/cpu/online\")) {\n        {\n            fprintf(stderr, \"present cpus != online cpus\\n\");\n            exit(1);\n        }\n        ;\n    }\n    return cpu_count;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static int get_cpu_count_from_file(char *filename) {\n    FILE *file;\n    char line[64];\n    int cpu_count;\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    if (!fgets(line, 64, file)) {\n        fprintf(stderr, \"Could not get %s contents\\n\", filename);\n        exit(1);\n    }\n    ;\n    fclose(file);\n    if (strcmp(line, \"0\\n\") == 0) {\n        return 1;\n    }\n    if (1 == sscanf(line, \"0-%d\\n\", &cpu_count)) {\n        return cpu_count + 1;\n    }\n    {\n        fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", filename, line);\n        exit(1);\n    }\n    ;\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(fgets)(char *, int, struct FILE_t {\n    int _flags;\n    char *_IO_read_ptr;\n    char *_IO_read_end;\n    char *_IO_read_base;\n    char *_IO_write_base;\n    char *_IO_write_ptr;\n    char *_IO_write_end;\n    char *_IO_buf_base;\n    char *_IO_buf_end;\n    char *_IO_save_base;\n    char *_IO_backup_base;\n    char *_IO_save_end;\n    struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n    } *_markers;\n    struct _IO_FILE {\n\n    } *_chain;\n    int _fileno;\n    int _flags2;\n    long _old_offset;\n    unsigned short _cur_column;\n    char _vtable_offset;\n    char _shortbuf[1];\n    struct pthread_mutex_t {\n\n    } *_lock;\n    long long _offset;\n    struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n    } *_codecvt;\n    struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_state;\n        struct __mbstate_t {\n            int __count;\n            union <anon> {\n                unsigned int __wch;\n                char __wchb[4];\n            } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n            struct _IO_iconv_t {\n\n            } __cd_in;\n            struct _IO_iconv_t {\n\n            } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n    } *_wide_data;\n    struct _IO_FILE {\n\n    } *_freeres_list;\n    unsigned long __pad5;\n    int _mode;\n    char _unused2[20];\n} *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long get_cpu_count_from_file(char *a0) {\n  char v0;         // [bp-0x5c]\n  char v1;         // [bp-0x58]\n  unsigned int v3; // ebp\n  FILE_t *v4;      // rax\n\n  v3 = (unsigned int)a0;\n  v4 = fopen(a0, \"r\");\n  if (!v4) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", v3);\n    exit(1); /* do not return */\n  } else if (!fgets(&v1, 64, v4)) {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not get %s contents\\n\", v3);\n    exit(1); /* do not return */\n  } else {\n    fclose(v4);\n    if (!strcmp(&v1, \"0\\n\")) {\n      return 1;\n    } else if (__isoc99_sscanf(&v1, \"0-%d\\n\", (unsigned int)&v0) != 1) {\n      fprintf(stderr @GLIBC_2.2.5, \"Unexpected input in file %s (%s).\\n\", v3,\n              (unsigned int)&v1);\n      exit(1); /* do not return */\n    } else {\n      return *((int *)&v0) + 1;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:30:16: error: nested redefinition of\n'_IO_marker' 30 |         struct _IO_marker { |                ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:73:13: error: declaration of\nanonymous union must be a definition 73 |             union <anon> { | ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:76:22: error: type name requires a\nspecifier or qualifier 76 |             } __value; |                      ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:80:13: error: declaration of\nanonymous union must be a definition 80 |             union <anon> { | ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:83:22: error: type name requires a\nspecifier or qualifier 83 |             } __value; |                      ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:16:8: error: conflicting types for\n'fgets' 16 | char *(fgets)(char *, int, struct FILE_t { |        ^\n/usr/include/stdio.h:592:14: note: previous declaration is here\n  592 | extern char *fgets (char *__restrict __s, int __n, FILE *__restrict\n__stream) |              ^ /tmp/tmppjj9v64n/get_cpu_count_from_file.c:142:16:\nerror: redefinition of '_IO_marker' 142 | typedef struct _IO_marker { | ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:29:12: note: previous definition is\nhere 29 |     struct _IO_marker { |            ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:148:16: error: redefinition of\n'_IO_codecvt' 148 | typedef struct _IO_codecvt { |                ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:51:12: note: previous definition is\nhere 51 |     struct _IO_codecvt { |            ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:152:16: error: redefinition of\n'_IO_wide_data' 152 | typedef struct _IO_wide_data { |                ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:59:12: note: previous definition is\nhere 59 |     struct _IO_wide_data { |            ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:175:3: error: typedef redefinition\nwith different types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 175 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmppjj9v64n/get_cpu_count_from_file.c:177:16: error: redeclaration of\n'stderr' with a different type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *'\n(aka 'struct _IO_FILE *') 177 | extern FILE_t *stderr@GLIBC_2.2.5; | ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 177 : 22 : error\n    : expected ';' after top level declarator 177 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 190 : 23 : error : expected ')' 190 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", v3);\n|\n    ^/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 190 : 16 : note : to match this '(' 190 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s\\n\", v3);\n|\n    ^/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 195 : 23 : error : expected ')' 195 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not get %s contents\\n\", v3);\n|\n    ^/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 195 : 16 : note : to match this '(' 195 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not get %s contents\\n\", v3);\n|\n    ^/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 207 : 27 : error : expected ')' 207 |\n    fprintf(stderr @GLIBC_2.2.5, \"Unexpected input in file %s (%s).\\n\", v3,\n            (unsigned int)&v1);\n|\n    ^/ tmp / tmppjj9v64n /\n        get_cpu_count_from_file.c : 207 : 20 : note : to match this '(' 207 |\n    fprintf(stderr @GLIBC_2.2.5, \"Unexpected input in file %s (%s).\\n\", v3,\n            (unsigned int)&v1);\n| ^15 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static int get_freq_scales_count(int cpu) {\n    FILE *file;\n    char filename[64];\n    unsigned long freq;\n    int count = 0;\n    sprintf(filename, \"/sys/devices/system/cpu/cpu%d/cpufreq/stats/time_in_state\", cpu);\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    do {\n        freq = 0;\n        fscanf(file, \"%lu %*d\\n\", &freq);\n        if (freq)\n            count++;\n    } while (freq);\n    fclose(file);\n    return count;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_print_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].time - old_cpus[i].freqs[j].time != new_cpus[0].freqs[j].time - old_cpus[0].freqs[j].time) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_aggregate_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        if (new_cpus[i].freq_count != new_cpus[0].freq_count) {\n            return 0;\n        }\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].freq != new_cpus[0].freqs[j].freq) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static struct slab_info *get_slabinfo(struct slab_stat *stats) {\n    struct slab_info *head = ((void *)0), *p = ((void *)0), *prev = ((void *)0);\n    FILE *slabfile;\n    char line[512];\n    unsigned int major, minor;\n    slabfile = fopen(\"/proc/slabinfo\", \"r\");\n    if (!slabfile) {\n        perror(\"fopen\");\n        return ((void *)0);\n    }\n    if (!fgets(line, 512, slabfile)) {\n        fprintf(stderr, \"cannot read from /proc/slabinfo\\n\");\n        return ((void *)0);\n    }\n    if (sscanf(line, \"slabinfo - version: %u.%u\", &major, &minor) != 2) {\n        fprintf(stderr, \"unable to parse slabinfo version!\\n\");\n        return ((void *)0);\n    }\n    if (major != 2 || minor > 1) {\n        fprintf(stderr, \"we only support slabinfo 2.0 and 2.1!\\n\");\n        return ((void *)0);\n    }\n    stats->min_obj_size = 2147483647;\n    while (fgets(line, 512, slabfile))\n        {\n            unsigned long nr_active_slabs, pages_per_slab;\n            int ret;\n            if (line[0] == '#')\n                continue;\n            p = malloc(sizeof(struct slab_info));\n            if (!p) {\n                perror(\"malloc\");\n                head = ((void *)0);\n                break;\n            }\n            if (stats->nr_caches++ == 0)\n                head = prev = p;\n            ret = sscanf(line, \"%32s %lu %lu %lu %lu %lu : tunables %*d %*d %*d :         slabdata %lu %lu %*d\", p->name, &p->nr_active_objs, &p->nr_objs, &p->obj_size, &p->objs_per_slab, &pages_per_slab, &nr_active_slabs, &p->nr_slabs);\n            if (ret != 8) {\n                fprintf(stderr, \"unrecognizable data in slabinfo!\\n\");\n                head = ((void *)0);\n                break;\n            }\n            if (p->obj_size < stats->min_obj_size)\n                stats->min_obj_size = p->obj_size;\n            if (p->obj_size > stats->max_obj_size)\n                stats->max_obj_size = p->obj_size;\n            p->nr_pages = p->nr_slabs * pages_per_slab;\n            if (p->nr_objs) {\n                p->use = 100 * p->nr_active_objs / p->nr_objs;\n                stats->nr_active_caches++;\n            } else\n                p->use = 0;\n            stats->nr_objs += p->nr_objs;\n            stats->nr_active_objs += p->nr_active_objs;\n            stats->total_size += p->nr_objs * p->obj_size;\n            stats->active_size += p->nr_active_objs * p->obj_size;\n            stats->nr_slabs += p->nr_slabs;\n            stats->nr_active_slabs += nr_active_slabs;\n            prev->next = p;\n            prev = p;\n        }\n    if (fclose(slabfile))\n        perror(\"fclose\");\n    if (p)\n        p->next = ((void *)0);\n    if (stats->nr_objs)\n        stats->avg_obj_size = stats->total_size / stats->nr_objs;\n    return head;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *merge_objs(struct slab_info *a, struct slab_info *b) {\n    struct slab_info list;\n    struct slab_info *p = &list;\n    while (a && b)\n        {\n            if (sort_func(a, b)) {\n                p->next = a;\n                p = a;\n                a = a->next;\n            } else {\n                p->next = b;\n                p = b;\n                b = b->next;\n            }\n        }\n    p->next = (a == ((void *)0)) ? b : a;\n    return list.next;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *slabsort(struct slab_info *list) {\n    struct slab_info *a, *b;\n    if (!list || !list->next)\n        return list;\n    a = list;\n    b = list->next;\n    while (b && b->next)\n        {\n            list = list->next;\n            b = b->next->next;\n        }\n    b = list->next;\n    list->next = ((void *)0);\n    return merge_objs(slabsort(a), slabsort(b));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(slabsort_name_conflict)(unsigned long);\n\nlong long slabsort_name_conflict(unsigned long a0) {\n  char v0;          // [bp-0x78]\n  unsigned long v1; // [bp-0x58]\n  unsigned long v3; // rax\n  unsigned long v5; // rax\n  unsigned long v6; // rdx\n  unsigned long v7; // rbp\n  unsigned long v8; // rbx\n  unsigned long v9; // r12\n\n  if (!a0)\n    return a0;\n  v3 = *((long long *)(a0 + 32));\n  if (!v3)\n    return a0;\n  v6 = a0;\n  do {\n    v5 = *((long long *)(v3 + 32));\n  } while (v5 && (v6 = *((long long *)(v6 + 32)),\n                  v3 = *((long long *)(v5 + 32)), v3));\n  *((long long *)(v6 + 32)) = 0;\n  v7 = slabsort_name_conflict(*((long long *)(v6 + 32)));\n  v8 = slabsort_name_conflict(a0);\n  if (!v8 || !v7) {\n    v9 = &v0;\n  } else {\n    v9 = &v0;\n    do {\n      if (sort_func(v8, v7)) {\n        *((unsigned long *)(v9 + 32)) = v8;\n        v9 = v8;\n        v8 = *((long long *)(v8 + 32));\n      } else {\n        *((unsigned long *)(v9 + 32)) = v7;\n        v9 = v7;\n        v7 = *((long long *)(v7 + 32));\n      }\n    } while (v8 && v7);\n  }\n  if (!v8)\n    v8 = v7;\n  *((unsigned long *)(v9 + 32)) = v8;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"int wav_play(const char *fn) {\n    struct wav_header hdr;\n    unsigned int rate, channels;\n    int fd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        fprintf(stderr, \"playwav: cannot open '%s'\\n\", fn);\n        return -1;\n    }\n    if (read(fd, &hdr, sizeof (hdr)) != sizeof (hdr)) {\n        fprintf(stderr, \"playwav: cannot read header\\n\");\n        return -1;\n    }\n    fprintf(stderr, \"playwav: %d ch, %d hz, %d bit, %s\\n\", hdr.num_channels, hdr.sample_rate, hdr.bits_per_sample, hdr.audio_format == 1 ? \"PCM\" : \"unknown\");\n    if ((hdr.riff_id != 1179011410) || (hdr.riff_fmt != 1163280727) || (hdr.fmt_id != 544501094)) {\n        fprintf(stderr, \"playwav: '%s' is not a riff/wave file\\n\", fn);\n        return -1;\n    }\n    if ((hdr.audio_format != 1) || (hdr.fmt_sz != 16)) {\n        fprintf(stderr, \"playwav: '%s' is not pcm format\\n\", fn);\n        return -1;\n    }\n    if (hdr.bits_per_sample != 16) {\n        fprintf(stderr, \"playwav: '%s' is not 16bit per sample\\n\", fn);\n        return -1;\n    }\n    play_file(hdr.sample_rate, hdr.num_channels, fd, hdr.data_sz);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nlong(read)(int, void *, unsigned long);\nlong long(play_file)(long long, long long, long long, long long);\n\nextern char g_40208e;\nextern char g_402092;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long wav_play_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;                // [bp-0x48]\n  char v1;                // [bp-0x40]\n  char v2;                // [bp-0x3c]\n  char v3;                // [bp-0x38]\n  char v4;                // [bp-0x34]\n  char v5;                // [bp-0x32]\n  char v6;                // [bp-0x30]\n  char v7;                // [bp-0x26]\n  char v8;                // [bp-0x20]\n  unsigned int v10;       // ebp\n  unsigned long long v11; // rax\n\n  v10 = (unsigned int)a0;\n  (unsigned int)v11 = open(a0, 0, a2);\n  if ((unsigned int)v11 < 0) {\n    fprintf(stderr @GLIBC_2.2.5, \"playwav: cannot open '%s'\\n\", v10);\n    return 4294967295;\n  } else if ((int)read(v11, &v0, 44) != 44) {\n    fwrite(\"playwav: cannot read header\\n\", 1, 28, stderr @GLIBC_2.2.5);\n    return 4294967295;\n  } else {\n    fprintf(stderr @GLIBC_2.2.5, \"playwav: %d ch, %d hz, %d bit, %s\\n\",\n            *((short *)&v5), *((int *)&v6), *((short *)&v7),\n            (*((short *)&v4) == 1 ? &g_402092 : &g_40208e));\n    if (*((int *)&v0) == 1179011410 && *((int *)&v1) == 1163280727 &&\n        *((int *)&v2) == 544501094) {\n      if (*((short *)&v4) == 1 && *((int *)&v3) == 16) {\n        if (*((short *)&v7) == 16) {\n          play_file(*((int *)&v6), *((short *)&v5), v11, *((int *)&v8));\n          return 0;\n        }\n        fprintf(stderr @GLIBC_2.2.5, \"playwav: '%s' is not 16bit per sample\\n\",\n                v10);\n        return 4294967295;\n      }\n      fprintf(stderr @GLIBC_2.2.5, \"playwav: '%s' is not pcm format\\n\", v10);\n      return 4294967295;\n    }\n    fprintf(stderr @GLIBC_2.2.5, \"playwav: '%s' is not a riff/wave file\\n\",\n            v10);\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:39:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 39 |     (unsigned int)v11 = open(a0, 0, a2); |\n^~~~~~~~~~~~~~~~~ ~ /tmp/tmp1sw3embj/wav_play_name_conflict.c:42:23: error: expected ')' 42 |\nfprintf(stderr@GLIBC_2.2.5, \"playwav: cannot open '%s'\\n\", v10); | ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:42:16: note: to match this '('\n   42 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: cannot open '%s'\\n\", v10);\n      |                ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:47:62: error: expected ')'\n   47 |         fwrite(\"playwav: cannot read header\\n\", 1, 28,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmp1sw3embj/wav_play_name_conflict.c:47:15: note: to match this\n'(' 47 |         fwrite(\"playwav: cannot read header\\n\", 1, 28,\nstderr@GLIBC_2.2.5); |               ^ /tmp/tmp1sw3embj/wav_play_name_conflict.c:52:23: error:\nexpected ')' 52 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: %d ch, %d hz, %d\nbit, %s\\n\", *((short *)&v5), *((int *)&v6), *((short *)&v7), (*((short *)&v4) ==\n1 ? &g_402092 : &g_40208e)); |                       ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:52:16: note: to match this '('\n   52 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: %d ch, %d hz, %d bit,\n%s\\n\", *((short *)&v5), *((int *)&v6), *((short *)&v7), (*((short *)&v4) == 1 ?\n&g_402092 : &g_40208e)); |                ^ /tmp/tmp1sw3embj/wav_play_name_conflict.c:62:31:\nerror: expected ')' 62 |                 fprintf(stderr@GLIBC_2.2.5, \"playwav:\n'%s' is not 16bit per sample\\n\", v10); |                               ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:62:24: note: to match this '('\n   62 |                 fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not 16bit\nper sample\\n\", v10); |                        ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:65:27: error: expected ')'\n   65 |             fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not pcm\nformat\\n\", v10); |                           ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:65:20: note: to match this '('\n   65 |             fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not pcm\nformat\\n\", v10); |                    ^ /tmp/tmp1sw3embj/wav_play_name_conflict.c:68:23:\nerror: expected ')' 68 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is\nnot a riff/wave file\\n\", v10); |                       ^\n/tmp/tmp1sw3embj/wav_play_name_conflict.c:68:16: note: to match this '('\n   68 |         fprintf(stderr@GLIBC_2.2.5, \"playwav: '%s' is not a riff/wave\nfile\\n\", v10); |                ^ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"int wav_rec(const char *fn, unsigned int channels, unsigned int rate) {\n    struct wav_header hdr;\n    unsigned char buf[8192];\n    struct msm_audio_config cfg;\n    unsigned int sz, n;\n    int fd, afd;\n    unsigned int total = 0;\n    unsigned char tmp;\n    hdr.riff_id = 1179011410;\n    hdr.riff_sz = 0;\n    hdr.riff_fmt = 1163280727;\n    hdr.fmt_id = 544501094;\n    hdr.fmt_sz = 16;\n    hdr.audio_format = 1;\n    hdr.num_channels = channels;\n    hdr.sample_rate = rate;\n    hdr.byte_rate = hdr.sample_rate * hdr.num_channels * 2;\n    hdr.block_align = hdr.num_channels * 2;\n    hdr.bits_per_sample = 16;\n    hdr.data_id = 1635017060;\n    hdr.data_sz = 0;\n    fd = open(fn, 64 | 2, 438);\n    if (fd < 0) {\n        perror(\"cannot open output file\");\n        return -1;\n    }\n    write(fd, &hdr, sizeof (hdr));\n    afd = open(\"/dev/msm_pcm_in\", 2);\n    if (afd < 0) {\n        perror(\"cannot open msm_pcm_in\");\n        close(fd);\n        return -1;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    cfg.channel_count = hdr.num_channels;\n    cfg.sample_rate = hdr.sample_rate;\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot write audio config\");\n        goto fail;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    sz = cfg.buffer_size;\n    fprintf(stderr, \"buffer size %d x %d\\n\", sz, cfg.buffer_count);\n    if (sz > sizeof (buf)) {\n        fprintf(stderr, \"buffer size %d too large\\n\", sz);\n        goto fail;\n    }\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0)) {\n        perror(\"cannot start audio\");\n        goto fail;\n    }\n    fcntl(0, 4, 2048);\n    fprintf(stderr, \"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\");\n    for (;;) {\n        while (read(0, &tmp, 1) == 1)\n            {\n                if ((tmp == 13) || (tmp == 10))\n                    goto done;\n            }\n        if (read(afd, buf, sz) != sz) {\n            perror(\"cannot read buffer\");\n            goto fail;\n        }\n        if (write(fd, buf, sz) != sz) {\n            perror(\"cannot write buffer\");\n            goto fail;\n        }\n        total += sz;\n    }\n  done:\n    close(afd);\n    hdr.data_sz = total;\n    hdr.riff_sz = total + 8 + 16 + 8;\n    lseek(fd, 0, 0);\n    write(fd, &hdr, sizeof (hdr));\n    close(fd);\n    return 0;\n  fail:\n    close(afd);\n    close(fd);\n    unlink(fn);\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nlong(write)(int, void *, unsigned long);\nint(close)(int);\nint(unlink)(char *);\nint(fcntl)(int, int, ...);\nlong(read)(int, void *, unsigned long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long wav_rec_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;                // [bp-0x2089]\n  char v1;                // [bp-0x2088]\n  char v2;                // [bp-0x2084]\n  unsigned int v3;        // [bp-0x2080]\n  unsigned int v4;        // [bp-0x207c]\n  char v5;                // [bp-0x2068]\n  char v6;                // [bp-0x68]\n  unsigned int v7;        // [bp-0x64]\n  char v8;                // [bp-0x60]\n  unsigned int v9;        // [bp-0x58]\n  unsigned short v10;     // [bp-0x54]\n  unsigned short v11;     // [bp-0x52]\n  unsigned int v12;       // [bp-0x4c]\n  unsigned short v13;     // [bp-0x48]\n  unsigned short v14;     // [bp-0x46]\n  char v15;               // [bp-0x44]\n  unsigned int v16;       // [bp-0x40]\n  unsigned long long v19; // rax\n  unsigned int v20;       // r14d\n  unsigned int v21;       // r13d\n  unsigned long v22;      // rbx\n  void *v24;              // r12, Other Possible Types: unsigned long\n  unsigned long v25;      // r15\n\n  strncpy(&v6, \"RIFF\", 4);\n  v7 = 0;\n  strncpy(&v8, \"WAVEfmt \", 8);\n  v9 = 16;\n  v10 = 1;\n  v11 = a1;\n  v12 = (unsigned int)a2 * (unsigned short)a1 * 2;\n  *((unsigned long long *)&v13) = (unsigned int)a1 * 2;\n  v14 = 16;\n  strncpy(&v15, \"data\", 4);\n  v16 = 0;\n  (unsigned int)v19 = open(a0, 66, 438);\n  if ((unsigned int)v19 < 0) {\n    perror(\"cannot open output file\");\n    return 4294967295;\n  }\n  v20 = v19;\n  write(v19, &v6, 44);\n  v21 = open(\"/dev/msm_pcm_in\", 2, 44);\n  if (v21 < 0) {\n    perror(\"cannot open msm_pcm_in\");\n    close(v20);\n    return 4294967295;\n  }\n  if (ioctl(v21, 2147770627)) {\n    perror(\"cannot read audio config\");\n  } else {\n    v3 = v11;\n    v4 = a2;\n    if (ioctl(v21, 1074028804)) {\n      perror(\"cannot write audio config\");\n    } else if (ioctl(v21, 2147770627)) {\n      perror(\"cannot read audio config\");\n    } else {\n      v22 = *((int *)&v1);\n      fprintf(stderr @GLIBC_2.2.5, \"buffer size %d x %d\\n\", (unsigned int)v22,\n              *((int *)&v2));\n      if ((unsigned int)v22 > 0x2000) {\n        fprintf(stderr @GLIBC_2.2.5, \"buffer size %d too large\\n\",\n                (unsigned int)v22);\n      } else {\n        v25 = ioctl(v21, 0x40046100);\n        if ((unsigned int)v25) {\n          perror(\"cannot start audio\");\n        } else {\n          fcntl(0, 4);\n          fwrite(\"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\", 1, 39,\n                 stderr @GLIBC_2.2.5);\n          v24 = 0;\n          while (true) {\n            while ((int)read(0, &v0, 1) == 1) {\n              if (!(v0 != 13) || !(v0 != 10)) {\n                close(v21);\n                v16 = v24;\n                v7 = (unsigned int)v24 + 32;\n                lseek(v20, 0, 0);\n                write(v20, &v6, 44);\n                close(v20);\n                return v25;\n              }\n            }\n            if ((int)read(v21, &v5, v22) != (unsigned int)v22) {\n              perror(\"cannot read buffer\");\n              break;\n            } else if ((int)write(v20, &v5, v22) == (unsigned int)v22) {\n              v24 += v22;\n            } else {\n              perror(\"cannot write buffer\");\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  close(v21);\n  close(v20);\n  unlink(a0);\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:24:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 24 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:24:22: error: expected ';' after top level declarator\n   24 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:63:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 63 |     (unsigned int)v19 = open(a0, 66, 438); |\n^~~~~~~~~~~~~~~~~ ~ /tmp/tmpuokbw2lj/wav_rec_name_conflict.c:97:27: error: expected ')' 97 |\nfprintf(stderr@GLIBC_2.2.5, \"buffer size %d x %d\\n\", (unsigned int)v22, *((int\n*)&v2)); |                           ^ /tmp/tmpuokbw2lj/wav_rec_name_conflict.c:97:20: note:\nto match this '(' 97 |             fprintf(stderr@GLIBC_2.2.5, \"buffer size %d x\n%d\\n\", (unsigned int)v22, *((int *)&v2)); |                    ^\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:100:31: error: expected ')'\n  100 |                 fprintf(stderr@GLIBC_2.2.5, \"buffer size %d too\nlarge\\n\", (unsigned int)v22); |                               ^\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:100:24: note: to match this '('\n  100 |                 fprintf(stderr@GLIBC_2.2.5, \"buffer size %d too\nlarge\\n\", (unsigned int)v22); |                        ^\n/tmp/tmpuokbw2lj/wav_rec_name_conflict.c:112:86: error: expected ')'\n  112 |                     fwrite(\"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\",\n1, 39, stderr@GLIBC_2.2.5); | ^ /tmp/tmpuokbw2lj/wav_rec_name_conflict.c:112:27: note: to\nmatch this '(' 112 |                     fwrite(\"\\n*** RECORDING * HIT ENTER TO\nSTOP ***\\n\", 1, 39, stderr@GLIBC_2.2.5); |                           ^ 7 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"int mp3_play(const char *fn) {\n    char buf[65536];\n    int r;\n    int fd, afd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        perror(\"cannot open mp3 file\");\n        return -1;\n    }\n    afd = open(\"/dev/msm_mp3\", 2);\n    if (afd < 0) {\n        close(fd);\n        perror(\"cannot open mp3 output device\");\n        return -1;\n    }\n    fprintf(stderr, \"MP3 PLAY\\n\");\n    ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0);\n    for (;;) {\n        r = read(fd, buf, 64 * 1024);\n        if (r <= 0)\n            break;\n        r = write(afd, buf, r);\n        if (r < 0)\n            break;\n    }\n    close(fd);\n    close(afd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(open)(char *, int, unsigned short);\nvoid(perror)(char *);\nint(close)(int);\nlong(read)(int, void *, unsigned long);\nlong(write)(int, void *, unsigned long);\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long mp3_play_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  char v0;               // [bp-0x10018]\n  unsigned long long v2; // rax\n  unsigned int v3;       // r12d\n  unsigned long long v4; // rax\n  unsigned int v5;       // ebp\n  unsigned long v7;      // rax\n\n  (unsigned int)v2 = open(a0, 0, a2);\n  if ((unsigned int)v2 < 0) {\n    perror(\"cannot open mp3 file\");\n    return 4294967295;\n  }\n  v3 = v2;\n  (unsigned int)v4 = open(\"/dev/msm_mp3\", 2, a2);\n  v5 = v4;\n  if ((unsigned int)v4 < 0) {\n    close(v3);\n    perror(\"cannot open mp3 output device\");\n    return 4294967295;\n  }\n  fwrite(\"MP3 PLAY\\n\", 1, 9, stderr @GLIBC_2.2.5);\n  ioctl(v4, 0x40046100);\n  do {\n    v7 = read(v3, &v0, 0x10000);\n  } while ((unsigned int)v7 > 0 && (int)write(v5, &v0, v7) >= 0);\n  close(v3);\n  close(v5);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbq5js2d2/mp3_play_name_conflict.c:17:7: error: conflicting types for 'perror'\n   17 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpbq5js2d2/mp3_play_name_conflict.c:22:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 22 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpbq5js2d2/mp3_play_name_conflict.c:22:22: error: expected ';' after top level\ndeclarator 22 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpbq5js2d2/mp3_play_name_conflict.c:33:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 33 |     (unsigned int)v2 = open(a0, 0, a2); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpbq5js2d2/mp3_play_name_conflict.c:40:5: error: assignment to cast\nis illegal, lvalue casts are not supported 40 |     (unsigned int)v4 =\nopen(\"/dev/msm_mp3\", 2, a2); |     ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpbq5js2d2/mp3_play_name_conflict.c:48:38: error: expected ')'\n   48 |     fwrite(\"MP3 PLAY\\n\", 1, 9, stderr@GLIBC_2.2.5);\n      |                                      ^\n/tmp/tmpbq5js2d2/mp3_play_name_conflict.c:48:11: note: to match this '('\n   48 |     fwrite(\"MP3 PLAY\\n\", 1, 9, stderr@GLIBC_2.2.5);\n      |           ^\n6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"static struct latency_entry *read_global_stats(struct latency_entry *list, int erase) {\n    FILE *f;\n    struct latency_entry *e;\n    if (erase) {\n        f = fopen(GLOBAL_STATS_FILE, \"w\");\n        if (!f) {\n            fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n        exit(1);\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_process_stats(struct latency_entry *list, int erase, int pid) {\n    char dirname[64];\n    DIR *dir;\n    struct dirent *ent;\n    struct latency_entry *e;\n    int tid;\n    sprintf(dirname, \"/proc/%d/task\", pid);\n    dir = opendir(dirname);\n    if (!dir) {\n        fprintf(stderr, \"Could not open task dir for process %d.\\n\", pid);\n        fprintf(stderr, \"Perhaps the process has terminated?\\n\");\n        exit(1);\n    }\n    e = list;\n    while ((ent = readdir(dir)))\n        {\n            if (!((*__ctype_b_loc())[(int)((ent->d_name[0]))] & (unsigned short)_ISdigit))\n                continue;\n            tid = atoi(ent->d_name);\n            e = read_thread_stats(e, erase, pid, tid, 0);\n        }\n    closedir(dir);\n    return e;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_thread_stats(struct latency_entry *list, int erase, int pid, int tid, int fatal) {\n    char filename[64];\n    FILE *f;\n    struct latency_entry *e;\n    sprintf(filename, THREAD_STATS_FILE_FORMAT, pid, tid);\n    if (erase) {\n        f = fopen(filename, \"w\");\n        if (!f) {\n            if (fatal) {\n                fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n                fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n                exit(1);\n            } else {\n                return list;\n            }\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        if (fatal) {\n            fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n            fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n            exit(1);\n        } else {\n            return list;\n        }\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(read_latency_file)(long long, long long);\nchar *(strerror)(int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nextern char *GLOBAL_STATS_FILE;\nextern char *THREAD_STATS_FILE_FORMAT;\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long read_thread_stats(unsigned long long a0, unsigned long a1,\n                            unsigned long a2, unsigned long a3,\n                            unsigned long a4) {\n  char v0;    // [bp-0x58]\n  FILE_t *v3; // rax\n  FILE_t *v4; // rbp\n\n  sprintf(&v0, THREAD_STATS_FILE_FORMAT);\n  if ((unsigned int)a1) {\n    v3 = fopen(&v0, \"w\");\n    if (v3) {\n      fwrite(\"erase\\n\", 1, 6, v3);\n      fclose(v3);\n    } else if (!(unsigned int)a4) {\n      return a0;\n    } else {\n      fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v0,\n              (unsigned int)strerror(*(__errno_location())));\n      fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n             stderr @GLIBC_2.2.5);\n      exit(1); /* do not return */\n    }\n  }\n  v4 = fopen(GLOBAL_STATS_FILE, \"r\");\n  if (v4) {\n    fclose(v4);\n    return read_latency_file(v4, a0);\n  } else if (!(unsigned int)a4) {\n    return a0;\n  } else {\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v0,\n            (unsigned int)strerror(*(__errno_location())));\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq917m3ot/read_thread_stats.c:87:3: error: typedef redefinition with\ndifferent types ('struct __mbstate_t' vs 'struct __mbstate_t' (aka\n'__mbstate_t')) 87 | } __mbstate_t; |   ^\n/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3: note: previous\ndefinition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpq917m3ot/read_thread_stats.c:91:16: error: redeclaration of 'stderr'\nwith a different type: 'FILE_t *' (aka 'struct FILE_t *') vs 'FILE *' (aka\n'struct _IO_FILE *') 91 | extern FILE_t *stderr@GLIBC_2.2.5; |                ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 91 : 22 : error\n    : expected ';' after top level declarator 91 |\n    extern FILE_t *stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 114 : 27 : error : expected ')' 114 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v0,\n            (unsigned int)strerror(*(__errno_location())));\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 114 : 20 : note : to match this '(' 114 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v0,\n            (unsigned int)strerror(*(__errno_location())));\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 115 : 84 : error : expected ')' 115 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 115 : 19 : note : to match this '(' 115 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 131 : 23 : error : expected ')' 131 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v0,\n            (unsigned int)strerror(*(__errno_location())));\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 131 : 16 : note : to match this '(' 131 |\n    fprintf(stderr @GLIBC_2.2.5, \"Could not open %s: %s\\n\", (unsigned int)&v0,\n            (unsigned int)strerror(*(__errno_location())));\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 132 : 80 : error : expected ')' 132 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n|\n    ^/ tmp / tmpq917m3ot /\n        read_thread_stats.c : 132 : 15 : note : to match this '(' 132 |\n    fwrite(\"Perhaps the process or thread has terminated?\\n\", 1, 46,\n           stderr @GLIBC_2.2.5);\n| ^7 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *alloc_latency_entry(void) {\n    struct latency_entry *e;\n    if (free_entries) {\n        e = free_entries;\n        free_entries = free_entries->next;\n    } else {\n        e = calloc(1, sizeof(struct latency_entry));\n        if (!e) {\n            fprintf(stderr, \"Could not allocate latency entry: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n    }\n    return e;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *find_latency_entry(struct latency_entry *head, char *reason) {\n    struct latency_entry *e;\n    e = head;\n    while (e)\n        {\n            if (!strcmp(e->reason, reason))\n                return e;\n            e = e->next;\n        }\n    return ((void *)0);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static int numcmp(const long long a, const long long b) {\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static const char *next_line(const char *b) {\n    while (1)\n        {\n            switch (*b) {\n              case '\\n':\n                return b + 1;\n              case '\\x00':\n                return ((void *)0);\n            }\n            b++;\n        }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int print() {\n    int i;\n    printf(\"CPU  yield() schedule() switch idle   ttwu() local  cpu_time wait_time timeslices\\n\");\n    for (i = 0; i < 2; i++) {\n        printf(\" %2d  %7u %10u %6u %4u %8u %5u %9llu %9llu %10lu\\n\", i, cpu_delta[i].yld_count, cpu_delta[i].sched_count, cpu_delta[i].sched_switch, cpu_delta[i].sched_goidle, cpu_delta[i].ttwu_count, cpu_delta[i].ttwu_local, cpu_delta[i].cpu_time / 1000000, cpu_delta[i].run_delay / 1000000, cpu_delta[i].pcount);\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse_cpu_v15(const char *b) {\n    int cpu;\n    if (sscanf(b, \"cpu%d %u %u %u %u %u %u %llu %llu %lu\\n\", &cpu, &tmp.yld_count, &tmp.sched_switch, &tmp.sched_count, &tmp.sched_goidle, &tmp.ttwu_count, &tmp.ttwu_local, &tmp.cpu_time, &tmp.run_delay, &tmp.pcount) != 10) {\n        printf(\"Could not parse %s\\n\", b);\n        return -1;\n    }\n    cpu_delta[cpu].yld_count = tmp.yld_count - cpu_prev[cpu].yld_count;\n    cpu_delta[cpu].sched_switch = tmp.sched_switch - cpu_prev[cpu].sched_switch;\n    cpu_delta[cpu].sched_count = tmp.sched_count - cpu_prev[cpu].sched_count;\n    cpu_delta[cpu].sched_goidle = tmp.sched_goidle - cpu_prev[cpu].sched_goidle;\n    cpu_delta[cpu].ttwu_count = tmp.ttwu_count - cpu_prev[cpu].ttwu_count;\n    cpu_delta[cpu].ttwu_local = tmp.ttwu_local - cpu_prev[cpu].ttwu_local;\n    cpu_delta[cpu].cpu_time = tmp.cpu_time - cpu_prev[cpu].cpu_time;\n    cpu_delta[cpu].run_delay = tmp.run_delay - cpu_prev[cpu].run_delay;\n    cpu_delta[cpu].pcount = tmp.pcount - cpu_prev[cpu].pcount;\n    cpu_prev[cpu] = tmp;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse(const char *b) {\n    unsigned int version;\n    unsigned long long ts;\n    if (sscanf(b, \"version %u\\n\", &version) != 1) {\n        printf(\"Could not parse version\\n\");\n        return -1;\n    }\n    switch (version) {\n      case 15:\n        b = next_line(b);\n        if (!b || sscanf(b, \"timestamp %llu\\n\", &ts) != 1) {\n            printf(\"Could not parse timestamp\\n\");\n            return -1;\n        }\n        while (1)\n            {\n                b = next_line(b);\n                if (!b)\n                    break;\n                if (b[0] == 'c') {\n                    if (parse_cpu_v15(b))\n                        return -1;\n                }\n            }\n        break;\n      default:\n        printf(\"Can not handle version %u\\n\", version);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/Malvineous_buildroot-openipcam/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"char *path_filename_ext(const char *path) {\n    char *fname = __xpg_basename((char *)path);\n    char *dot = strrchr(fname, '.');\n    if (!dot || dot == fname)\n        return (\"\");\n    return (dot);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern char g_40203f;\n\nlong long path_filename_ext_name_conflict() {\n  char *v1;              // rbx\n  unsigned long long v2; // rax, Other Possible Types: unsigned long\n\n  v1 = __xpg_basename();\n  v2 = strrchr(v1, 46);\n  if (v2 && v1 != v2)\n    return v2;\n  return &g_40203f;\n}\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_filename_ext.c"}
{"compilable":0,"function":"int path_isdir(const char *path) {\n    struct stat *sb = calloc(1, sizeof(struct stat));\n    int s = stat(path, sb);\n    if (s == -1) {\n        log_perror(\"stat error\");\n        free(sb);\n        return (-1);\n    }\n    mode_t m = sb->st_mode;\n    free(sb);\n    return (((((m)) & 61440) == (16384)));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(log_perror)(long long, ...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long path_isdir_name_conflict(char *a0) {\n  stat *v1;              // rbp\n  unsigned long long v2; // rax\n\n  v1 = calloc(1, 144);\n  (unsigned int)v2 = stat(a0, v1);\n  if ((unsigned int)v2 != -1) {\n    free(v1);\n    return (v1->st_nlink & 0xf000) == 0x4000;\n  }\n  log_perror(\"stat error\");\n  free(v1);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpe3qkyqxd/path_isdir_name_conflict.c:48:3: error: redefinition of 'stat' as different\nkind of symbol 48 | } stat; |   ^ /tmp/tmpe3qkyqxd/path_isdir_name_conflict.c:16:6: note:\nprevious definition is here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpe3qkyqxd/path_isdir_name_conflict.c:52:5: error: must use 'struct' tag to refer to\ntype 'stat' 52 |     stat *v1;  // rbp |     ^ |     struct\n/tmp/tmpe3qkyqxd/path_isdir_name_conflict.c:16:6: note: struct 'stat' is hidden by a non-type\ndeclaration of 'stat' here 16 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpe3qkyqxd/path_isdir_name_conflict.c:56:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 56 |     (unsigned int)v2 = stat(a0, v1); |\n^~~~~~~~~~~~~~~~ ~ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_isdir.c"}
{"compilable":0,"function":"int path_exists(const char *path) {\n    int ret = access(path, 0);\n    if (ret == 0)\n        return (1);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(access)(char *, int);\n\nlong long path_exists_name_conflict(char *a0) { return !access(a0, 0); }\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_exists.c"}
{"compilable":0,"function":"int log_perror(char *fmt, ...) {\n    perror(\"\");\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"ERR\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nvoid(perror)(char *);\nlong long(_logfp)(long long, long long, long long, long long);\n\nextern char g_40203f;\nextern unsigned long long stderr @GLIBC_2.2.5;\n\nlong long log_perror_name_conflict(unsigned long long a0) {\n  unsigned int v0;   // [bp-0xd0]\n  unsigned int v1;   // [bp-0xcc]\n  unsigned long v2;  // [bp-0xc8]\n  unsigned long v3;  // [bp-0xc0]\n  char v4;           // [bp-0xb8]\n  unsigned long v5;  // [bp-0xb0]\n  unsigned long v6;  // [bp-0xa8]\n  unsigned long v7;  // [bp-0xa0]\n  unsigned long v8;  // [bp-0x98]\n  unsigned long v9;  // [bp-0x90]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  int v16;           // [bp-0x28]\n  int v17;           // [bp-0x18]\n  unsigned long v18; // [bp+0x8]\n  unsigned long v19; // rsi\n  unsigned long v20; // rdx\n  unsigned long v21; // rcx\n  unsigned long v22; // r8\n  unsigned long v23; // r9\n  char v24;          // al\n  int v25;           // xmm0\n  int v26;           // xmm1\n  int v27;           // xmm2\n  int v28;           // xmm3\n  int v29;           // xmm4\n  int v30;           // xmm5\n  int v31;           // xmm6\n  int v32;           // xmm7\n\n  v5 = v19;\n  v6 = v20;\n  v7 = v21;\n  v8 = v22;\n  v9 = v23;\n  if (v24) {\n    v10 = v25;\n    v11 = v26;\n    v12 = v27;\n    v13 = v28;\n    v14 = v29;\n    v15 = v30;\n    v16 = v31;\n    v17 = v32;\n  }\n  perror(&g_40203f);\n  v0 = 8;\n  v1 = 48;\n  v2 = &v18;\n  v3 = &v4;\n  return _logfp(stderr @GLIBC_2.2.5, \"ERR\", a0, &v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1b_y0gvw/log_perror_name_conflict.c:16:7: error: conflicting types for 'perror'\n   16 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmp1b_y0gvw/log_perror_name_conflict.c:20:27: error: redeclaration of 'stderr' with a\ndifferent type: 'unsigned long long' vs 'FILE *' (aka 'struct _IO_FILE *') 20 |\nextern unsigned long long stderr@GLIBC_2.2.5; |                           ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmp1b_y0gvw /\n        log_perror_name_conflict.c : 20 : 33 : error\n    : expected ';' after top level declarator 20 |\n    extern unsigned long long stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmp1b_y0gvw / log_perror_name_conflict.c : 79 : 25 : error : expected ')' 79 |\n    return _logfp(stderr @GLIBC_2.2.5, \"ERR\", a0, &v0);\n| ^/ tmp / tmp1b_y0gvw / log_perror_name_conflict.c : 79 : 18 : note : to match this '(' 79 |\n    return _logfp(stderr @GLIBC_2.2.5, \"ERR\", a0, &v0);\n| ^4 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_perror.c"}
{"compilable":0,"function":"int log_warn(char *fmt, ...) {\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"WARN\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(_logfp)(long long, long long, long long, long long);\n\nextern unsigned long long stderr @GLIBC_2.2.5;\n\nlong long log_warn_name_conflict(unsigned long long a0) {\n  unsigned int v0;   // [bp-0xd0]\n  unsigned int v1;   // [bp-0xcc]\n  unsigned long v2;  // [bp-0xc8]\n  unsigned long v3;  // [bp-0xc0]\n  char v4;           // [bp-0xb8]\n  unsigned long v5;  // [bp-0xb0]\n  unsigned long v6;  // [bp-0xa8]\n  unsigned long v7;  // [bp-0xa0]\n  unsigned long v8;  // [bp-0x98]\n  unsigned long v9;  // [bp-0x90]\n  int v10;           // [bp-0x88]\n  int v11;           // [bp-0x78]\n  int v12;           // [bp-0x68]\n  int v13;           // [bp-0x58]\n  int v14;           // [bp-0x48]\n  int v15;           // [bp-0x38]\n  int v16;           // [bp-0x28]\n  int v17;           // [bp-0x18]\n  unsigned long v18; // [bp+0x8]\n  unsigned long v19; // rsi\n  unsigned long v20; // rdx\n  unsigned long v21; // rcx\n  unsigned long v22; // r8\n  unsigned long v23; // r9\n  char v24;          // al\n  int v25;           // xmm0\n  int v26;           // xmm1\n  int v27;           // xmm2\n  int v28;           // xmm3\n  int v29;           // xmm4\n  int v30;           // xmm5\n  int v31;           // xmm6\n  int v32;           // xmm7\n\n  v5 = v19;\n  v6 = v20;\n  v7 = v21;\n  v8 = v22;\n  v9 = v23;\n  if (v24) {\n    v10 = v25;\n    v11 = v26;\n    v12 = v27;\n    v13 = v28;\n    v14 = v29;\n    v15 = v30;\n    v16 = v31;\n    v17 = v32;\n  }\n  v0 = 8;\n  v1 = 48;\n  v2 = &v18;\n  v3 = &v4;\n  return _logfp(stderr @GLIBC_2.2.5, \"WARN\", a0, &v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp948os7i0/log_warn_name_conflict.c:18:27: error: redeclaration of 'stderr' with a\ndifferent type: 'unsigned long long' vs 'FILE *' (aka 'struct _IO_FILE *') 18 |\nextern unsigned long long stderr@GLIBC_2.2.5; |                           ^\n/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'\n  149 | #define stderr stderr\n      |                ^\n/usr/include/stdio.h:145:14: note: previous declaration is here\n  145 | extern FILE *stderr;            /* Standard error output stream.  */\n|\n    ^/ tmp / tmp948os7i0 /\n        log_warn_name_conflict.c : 18 : 33 : error\n    : expected ';' after top level declarator 18 |\n    extern unsigned long long stderr @GLIBC_2.2.5;\n| ^| ;\n/ tmp / tmp948os7i0 / log_warn_name_conflict.c : 76 : 25 : error : expected ')' 76 |\n    return _logfp(stderr @GLIBC_2.2.5, \"WARN\", a0, &v0);\n| ^/ tmp / tmp948os7i0 / log_warn_name_conflict.c : 76 : 18 : note : to match this '(' 76 |\n    return _logfp(stderr @GLIBC_2.2.5, \"WARN\", a0, &v0);\n| ^3 errors generated.\n\n            * /\n","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_warn.c"}
{"compilable":0,"function":"char *currTime(const char *format) {\n    static char buf[1000];\n    time_t t;\n    size_t s;\n    struct tm *tm;\n    t = time(((void *)0));\n    tm = localtime(&t);\n    if (tm == ((void *)0))\n        return ((void *)0);\n    s = strftime(buf, 1000, (format != ((void *)0)) ? format : \"%c\", tm);\n    return (s == 0) ? ((void *)0) : buf;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(localtime)(long *);\n\ntypedef struct tm {\n  unsigned int tm_sec;\n  unsigned int tm_min;\n  unsigned int tm_hour;\n  unsigned int tm_mday;\n  unsigned int tm_mon;\n  unsigned int tm_year;\n  unsigned int tm_wday;\n  unsigned int tm_yday;\n  unsigned int tm_isdst;\n  char padding_24[4];\n  unsigned int tm_gmtoff;\n  char padding_2c[4];\n  char *tm_zone;\n} tm;\n\nextern char buf.0;\n\nlong long currTime_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0x10]\n  char *v2;        // rbx, Other Possible Types: unsigned long\n  tm *v3;          // rax, Other Possible Types: unsigned long\n\n  v2 = a0;\n  *((long *)&v0) = time(NULL);\n  v3 = localtime(&v0);\n  if (!v3)\n    return v3;\n  if (!a0)\n    v2 = \"%c\";\n  v3 = (!strftime(&buf.0, 1000, v2, v3) ? &buf.0 : 0);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2mij3elm/currTime_name_conflict.c:35:16: error: expected ';' after top level\ndeclarator 35 | extern char buf.0; |                ^ |                ;\n/tmp/tmp2mij3elm/currTime_name_conflict.c:50:25: error: expected ')'\n   50 |     v3 = (!strftime(&buf.0, 1000, v2, v3) ? &buf.0 : 0);\n      |                         ^\n/tmp/tmp2mij3elm/currTime_name_conflict.c:50:20: note: to match this '('\n   50 |     v3 = (!strftime(&buf.0, 1000, v2, v3) ? &buf.0 : 0);\n      |                    ^\n/tmp/tmp2mij3elm/currTime_name_conflict.c:50:49: error: expected ':'\n   50 |     v3 = (!strftime(&buf.0, 1000, v2, v3) ? &buf.0 : 0);\n      |                                                 ^\n      |                                                 :\n/tmp/tmp2mij3elm/currTime_name_conflict.c:50:43: note: to match this '?'\n   50 |     v3 = (!strftime(&buf.0, 1000, v2, v3) ? &buf.0 : 0);\n      |                                           ^\n3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":1,"function":"bool isValidMacAddrStr(char *str) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long isValidMacAddrStr_name_conflict() { return 1; }\n","pass":1,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":0,"function":"size_t addst(size_t x, size_t y) {\n    if ((18446744073709551615UL) - x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x + y;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fatal)(...);\n\nlong long addst_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((char)__CFADD__(a0, a1))\n    fatal(); /* do not return */\n  return a0 + a1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps449hx7g/addst_name_conflict.c:16:19: error: ISO C requires a named parameter before\n'...' 16 | long long (fatal)(...); |                   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"size_t mulst(size_t x, size_t y) {\n    if (x == 0 || y == 0) {\n        return 0;\n    }\n    if ((18446744073709551615UL) / x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x * y;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fatal)(...);\n\nlong long mulst_name_conflict(unsigned long a0, unsigned long a1) {\n  if (!a0) {\n    return 0;\n  } else if (!a1) {\n    return 0;\n  } else if (!((char)[D] amd64g_calculate_condition(0x0 < 64 >, 0x30 < 64 >,\n                                                    rdi, rsi, cc_ndep))) {\n    return a1 * a0;\n  } else {\n    fatal(); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsizbwyje/mulst_name_conflict.c:16:19: error: ISO C requires a named parameter before\n'...' 16 | long long (fatal)(...); |                   ^\n/tmp/tmpsizbwyje/mulst_name_conflict.c:28:22: error: expected expression\n   28 |     else if (!((char)[D] amd64g_calculate_condition(0x0<64>, 0x30<64>,\nrdi, rsi, cc_ndep))) |                      ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *result = strdup(s);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(fatal)(...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  unsigned long long v1; // rax\n\n  v1 = strdup(a0);\n  if (!v1)\n    fatal(); /* do not return */\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpskov5jss/xstrdup_name_conflict.c:17:19: error: ISO C requires a named parameter before\n'...' 17 | long long (fatal)(...); |                   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrndup(const char *s, size_t size) {\n    char *result = strndup(s, size);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strndup)(char *, unsigned long);\nlong long(fatal)(...);\n\nlong long xstrndup_name_conflict(char *a0, unsigned int a1) {\n  unsigned long long v1; // rax\n\n  v1 = strndup(a0, a1);\n  if (!v1)\n    fatal(); /* do not return */\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplzndh65n/xstrndup_name_conflict.c:17:19: error: ISO C requires a named parameter\nbefore '...' 17 | long long (fatal)(...); |                   ^ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int xasprintf(char **s, const char *template, ...) {\n    va_list a;\n    __builtin_va_start(a, template);\n    int result = vasprintf(s, template, a);\n    __builtin_va_end(a);\n    if (result < 0) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(vasprintf)(char **, char *, struct va_list[1]);\nlong long(fatal)(...);\n\nlong long xasprintf_name_conflict(char **a0, char *a1) {\n  unsigned int v0;        // [bp-0xd0]\n  unsigned int v1;        // [bp-0xcc]\n  unsigned long v2;       // [bp-0xc8]\n  unsigned long v3;       // [bp-0xc0]\n  char v4;                // [bp-0xb8]\n  unsigned long v5;       // [bp-0xa8]\n  unsigned long v6;       // [bp-0xa0]\n  unsigned long v7;       // [bp-0x98]\n  unsigned long v8;       // [bp-0x90]\n  int v9;                 // [bp-0x88]\n  int v10;                // [bp-0x78]\n  int v11;                // [bp-0x68]\n  int v12;                // [bp-0x58]\n  int v13;                // [bp-0x48]\n  int v14;                // [bp-0x38]\n  int v15;                // [bp-0x28]\n  int v16;                // [bp-0x18]\n  unsigned long v17;      // [bp+0x8]\n  unsigned long v18;      // rdx\n  unsigned long v19;      // rcx\n  unsigned long v20;      // r8\n  unsigned long v21;      // r9\n  char v22;               // al\n  int v23;                // xmm0\n  int v24;                // xmm1\n  int v25;                // xmm2\n  int v26;                // xmm3\n  int v27;                // xmm4\n  int v28;                // xmm5\n  int v29;                // xmm6\n  int v30;                // xmm7\n  unsigned long long v31; // rax\n\n  v5 = v18;\n  v6 = v19;\n  v7 = v20;\n  v8 = v21;\n  if (v22) {\n    v9 = v23;\n    v10 = v24;\n    v11 = v25;\n    v12 = v26;\n    v13 = v27;\n    v14 = v28;\n    v15 = v29;\n    v16 = v30;\n  }\n  v0 = 16;\n  v1 = 48;\n  v2 = &v17;\n  v3 = &v4;\n  (unsigned int)v31 = vasprintf(a0, a1, &v0);\n  if ((unsigned int)v31 < 0)\n    fatal(); /* do not return */\n  return v31;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqzmlp2al/xasprintf_name_conflict.c:16:48: error: array has incomplete element type\n'struct va_list' 16 | int (vasprintf)(char **, char *, struct va_list[1]); | ^\n/tmp/tmpqzmlp2al/xasprintf_name_conflict.c:16:41: note: forward declaration of 'struct\nva_list' 16 | int (vasprintf)(char **, char *, struct va_list[1]); | ^\n/tmp/tmpqzmlp2al/xasprintf_name_conflict.c:17:19: error: ISO C requires a named parameter\nbefore '...' 17 | long long (fatal)(...); |                   ^ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xgetcwd(void) {\n    char *result = getcwd(((void *)0), 0);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getcwd)(char *, unsigned long);\nlong long(fatal)(...);\n\nlong long xgetcwd_name_conflict() {\n  unsigned long long v1; // rax\n\n  v1 = getcwd(NULL, 0);\n  if (!v1)\n    fatal(); /* do not return */\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4fc651e6/xgetcwd_name_conflict.c:17:19: error: ISO C requires a named parameter before\n'...' 17 | long long (fatal)(...); |                   ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_starts_with(const char *string, const char *prefix) {\n    const char *string_ptr = string;\n    const char *prefix_ptr = prefix;\n    while (*string_ptr != '\\x00' && *prefix_ptr != '\\x00')\n        {\n            if (*string_ptr != *prefix_ptr) {\n                return 0;\n            }\n            string_ptr++;\n            prefix_ptr++;\n        }\n    if (*string_ptr == '\\x00' && *prefix_ptr != '\\x00') {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long str_starts_with_name_conflict(char *a0, char *a1) {\n  char v1; // al\n  char v2; // dl\n\n  v1 = *(a0);\n  if (!v1)\n    return !*((char *)a1);\n  while (true) {\n    v2 = *((char *)a1);\n    if (!v2)\n      break;\n    if (v2 != v1)\n      return 0;\n    a0 += 1;\n    a1 += 1;\n    v1 = *((char *)a0);\n    if (!v1)\n      return !*((char *)a1);\n  }\n  if (!v1)\n    return !*((char *)a1);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_ends_with(const char *string, const char *suffix) {\n    size_t string_length = strlen(string);\n    size_t suffix_length = strlen(suffix);\n    if (string_length < suffix_length) {\n        return 0;\n    }\n    return strcmp(string + string_length - suffix_length, suffix) == 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long str_ends_with_name_conflict(char *a0, char *a1) {\n  unsigned long long v1; // rbp\n  unsigned long long v2; // rax\n  void *v3;              // rdx\n\n  v1 = strlen(a0);\n  v2 = strlen(a1);\n  v3 = 0;\n  if (v1 >= v2) {\n    *((char *)&v3) = !strcmp(&a0[v1 + -1 * v2], a1);\n    return v3;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_path(const char *parent, const char *relative_path) {\n    size_t parent_length = strlen(parent);\n    size_t relative_path_length = strlen(relative_path);\n    size_t result_length = addst(parent_length, relative_path_length);\n    result_length = addst(result_length, 2);\n    char *result = xmalloc(result_length);\n    strcpy(result, parent);\n    result[parent_length] = '/';\n    strcpy(result + parent_length + 1, relative_path);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(addst)(long long, long long);\nlong long(xmalloc)(long long);\n\nlong long make_path_name_conflict(char *a0, char *a1) {\n  char *v1;         // rbp\n  unsigned long v2; // rax\n\n  v1 = strlen(a0);\n  v2 = xmalloc(addst(addst(v1, strlen(a1)), 2));\n  strcpy(v2, a0);\n  v1[v2] = 47;\n  strcpy(&v1[v2 + 1], a1);\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_canonical_path(const char *relative_path) {\n    char *original_directory = xgetcwd();\n    char *base = make_basename(relative_path);\n    char *dir = make_dirname(relative_path);\n    xchdir(dir);\n    char *canonical_dir = xgetcwd();\n    char *result = make_path(canonical_dir, base);\n    free(canonical_dir);\n    free(base);\n    free(dir);\n    xchdir(original_directory);\n    free(original_directory);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xgetcwd)();\nlong long(make_basename)(long long);\nlong long(make_dirname)(long long);\nlong long(xchdir)(long long);\nlong long(make_path)(long long, long long);\n\nlong long make_canonical_path_name_conflict(unsigned long long a0) {\n  void *v1; // rbx\n  void *v2; // r12\n  void *v3; // rbp\n  void *v4; // r13\n\n  v1 = xgetcwd();\n  v2 = make_basename(a0);\n  v3 = make_dirname(a0);\n  xchdir(v3);\n  v4 = xgetcwd();\n  free(v4);\n  free(v2);\n  free(v3);\n  xchdir(v1);\n  free(v1);\n  return make_path(v4, v2);\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_basename(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(__xpg_basename(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\n\nlong long make_basename_name_conflict(unsigned long long a0) {\n  void *v1; // rbx\n\n  v1 = xstrdup(a0);\n  free(v1);\n  return xstrdup(__xpg_basename(v1));\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_dirname(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(dirname(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xstrdup)(long long);\nchar *(dirname)(char *);\n\nlong long make_dirname_name_conflict(unsigned long long a0) {\n  void *v1; // rbx\n\n  v1 = xstrdup(a0);\n  free(v1);\n  return xstrdup(dirname(v1));\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int is_same_file(const char *file1, const char *file2) {\n    if (strcmp(file1, file2) == 0) {\n        return 1;\n    }\n    char *canonical1 = make_canonical_path(file1);\n    char *canonical2 = make_canonical_path(file2);\n    int cmp = strcmp(canonical1, canonical2);\n    free(canonical1);\n    free(canonical2);\n    if (cmp == 0) {\n        return 1;\n    }\n    struct stat buf1;\n    if (stat(file1, &buf1) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file1);\n        }\n    }\n    struct stat buf2;\n    if (stat(file2, &buf2) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file2);\n        }\n    }\n    if (buf1.st_dev == buf2.st_dev && buf1.st_ino == buf2.st_ino) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(make_canonical_path)(long long);\nint(stat)(\n    char *, struct stat {\n      unsigned int st_mode;\n      unsigned long st_ino;\n      uint64_t st_dev;\n      unsigned int st_nlink;\n      unsigned int st_uid;\n      unsigned int st_gid;\n      long st_size;\n      long st_atime;\n      long st_mtime;\n      long st_ctime;\n    } *);\nlong long(fatal)(...);\n\ntypedef struct stat {\n  unsigned int st_mode;\n  char padding_4[4];\n  unsigned int st_ino;\n  char padding_c[4];\n  char st_dev;\n  char padding_11[7];\n  unsigned int st_nlink;\n  unsigned int st_uid;\n  unsigned int st_gid;\n  char padding_24[4];\n  unsigned int st_size;\n  char padding_2c[4];\n  unsigned int st_atime;\n  char padding_34[4];\n  unsigned int st_mtime;\n  char padding_3c[4];\n  unsigned int st_ctime;\n} stat;\n\nlong long is_same_file_name_conflict(char *a0, char *a1) {\n  stat v0;          // [bp-0x148]\n  char v1;          // [bp-0x140]\n  stat v2;          // [bp-0xb8]\n  char v3;          // [bp-0xb0]\n  unsigned long v5; // rax\n  void *v6;         // r13\n  char *v7;         // rax\n\n  if (!strcmp(a0, a1))\n    return 1;\n  v6 = make_canonical_path(a0);\n  v7 = make_canonical_path(a1);\n  free(v6);\n  free(v7);\n  if (!strcmp(v6, v7)) {\n    return 1;\n  } else if (stat(a0, &v2) != -1) {\n    if (stat(a1, &v0) != -1) {\n      v5 = 0;\n      if (*((long long *)&v2.st_mode) != *((long long *)&v0.st_mode))\n        return v5;\n      v5 = *((long long *)&v3) == *((long long *)&v1);\n    } else if (*(__errno_location()) != 2) {\n      fatal(); /* do not return */\n    } else {\n      return 0;\n    }\n  } else {\n    if (*(__errno_location()) != 2)\n      fatal(); /* do not return */\n    return 0;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:29:19: error: ISO C requires a named parameter\nbefore '...' 29 | long long (fatal)(...); |                   ^\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:49:3: error: redefinition of 'stat' as different\nkind of symbol 49 | } stat; |   ^ /tmp/tmpcdyaanm0/is_same_file_name_conflict.c:17:6: note:\nprevious definition is here 17 | int (stat)(char *, struct stat { |      ^\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:53:5: error: must use 'struct' tag to refer to\ntype 'stat' 53 |     stat v0;  // [bp-0x148] |     ^ |     struct\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:17:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:55:5: error: must use 'struct' tag to refer to\ntype 'stat' 55 |     stat v2;  // [bp-0xb8] |     ^ |     struct\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:17:6: note: struct 'stat' is hidden by a\nnon-type declaration of 'stat' here 17 | int (stat)(char *, struct stat { | ^\n/tmp/tmpcdyaanm0/is_same_file_name_conflict.c:80:18: error: indirection requires pointer\noperand ('int' invalid) 80 |         else if (*(__errno_location()) != 2) |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpcdyaanm0/is_same_file_name_conflict.c:91:13: error: indirection\nrequires pointer operand ('int' invalid) 91 |         if (*(__errno_location())\n!= 2) |             ^~~~~~~~~~~~~~~~~~~~~ 6 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int contains_file(const char *file1, const char *file2) {\n    int result = 0;\n    char *ancestor = make_canonical_path(file1);\n    char *d = make_canonical_path(file2);\n    char *parent = make_dirname(d);\n    while (strcmp(d, parent) != 0)\n        {\n            if (is_same_file(ancestor, parent)) {\n                result = 1;\n                break;\n            }\n            free(d);\n            d = parent;\n            parent = make_dirname(d);\n        }\n    free(d);\n    free(parent);\n    free(ancestor);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(make_canonical_path)(long long);\nlong long(make_dirname)(long long);\nlong long(is_same_file)(long long, long long);\n\nlong long contains_file_name_conflict(unsigned long long a0, unsigned long long a1) {\n  void *v1;         // r13\n  char *v2;         // r12, Other Possible Types: unsigned long\n  void *v3;         // rbx, Other Possible Types: unsigned long\n  unsigned long v4; // rbp, Other Possible Types: unsigned long long\n\n  v1 = make_canonical_path(a0);\n  v2 = make_canonical_path(a1);\n  v3 = make_dirname(v2);\n  while (true) {\n    v4 = strcmp(v2, v3);\n    if (!(unsigned int)v4)\n      break;\n    if (!(int)is_same_file(v1, v3)) {\n      free(v2);\n      v2 = v3;\n      v3 = make_dirname(v3);\n    } else {\n      v4 = 1;\n      break;\n    }\n  }\n  free(v2);\n  free(v3);\n  free(v1);\n  return v4;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool directory_is_empty(const char *directory) {\n    bool result = 1;\n    DIR *dir = xopendir(directory);\n    struct dirent *e;\n    while ((e = readdir(dir)) != ((void *)0))\n        {\n            if (strcmp(e->d_name, \".\") != 0 && strcmp(e->d_name, \"..\") != 0) {\n                result = 0;\n                break;\n            }\n        }\n    closedir(dir);\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(xopendir)(long long);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\n\nlong long directory_is_empty_name_conflict(unsigned long long a0) {\n  char *v1;              // rbp\n  unsigned long long v2; // rax\n  char *v3;              // rbx\n\n  v1 = xopendir(a0);\n  do {\n    do {\n      v2 = readdir(v1);\n      if (!v2) {\n        closedir(v1);\n        return 1;\n      }\n    } while ((v3 = v2 + 19, !strcmp(v3, \".\")));\n  } while (!strcmp(v3, \"..\"));\n  closedir(v1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int verify_values(char **values, char **expected, int n) {\n    int i = 0;\n    while (i < n)\n        {\n            if (0 != strcmp(values[i], expected[i])) {\n                return -1;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long verify_values(unsigned long long *a0, unsigned long long *a1,\n                        unsigned long a2) {\n  unsigned long v0;        // [bp-0x18]\n  unsigned long v1;        // [bp-0x10]\n  unsigned long v2;        // [bp-0x8]\n  unsigned long v4;        // r12\n  unsigned long v5;        // rbx\n  char *v7;                // rsi\n  char *v8;                // rdi\n  unsigned long long *v9;  // rbx, Other Possible Types: unsigned long\n  unsigned long long *v10; // rbp, Other Possible Types: unsigned long\n  unsigned long v11;       // rax, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a2 <= 0)\n    return 0;\n  v2 = v4;\n  *((int *)&v1) = rbp;\n  v0 = v5;\n  v9 = a1;\n  v10 = a0;\n  do {\n    v7 = *((long long *)v9);\n    v8 = *((long long *)v10);\n    (unsigned int)v11 = strcmp(v8, v7);\n    if ((unsigned int)v11) {\n      v11 = 4294967295;\n      break;\n    }\n  } while ((v9 += 8, v10 += 8, v9 != a1 + a2 * 8));\n  return v11;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpyto0ty4m/verify_values.c:42:9: error: assignment to cast is illegal,\nlvalue casts are not supported 42 |         (unsigned int)v11 = strcmp(v8, v7);\n      |         ^~~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_split_string_by_comma_ok() {\n    int rv;\n    char *test_str;\n    char *values[24];\n    test_str = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(4 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values\", \"\\033[0m\");\n            return \"should return the correct number of values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values\", \"\\033[0m\");\n    } while (0);\n    char *expected[] = {\"JACK\", \"ENGQVIST\", \"JOHANSSON\", \"89\"};\n    do {\n        if (!(0 == verify_values(values, expected, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n            return \"should be able to split a comma seperated string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\",SOME,EMPTY,VALUES,,\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(6 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n            return \"should return the correct number of values even when there is empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    char *expected2[] = {\"\", \"SOME\", \"EMPTY\", \"VALUES\", \"\", \"\"};\n    do {\n        if (!(0 == verify_values(values, expected2, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n            return \"should be able to split empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint g_402008; // add global variable by heuristics\nint g_402008; // add global variable by heuristics\nint g_402038; // add global variable by heuristics\nint g_402038; // add global variable by heuristics\nint g_402070; // add global variable by heuristics\nint g_402070; // add global variable by heuristics\nint g_4020c0; // add global variable by heuristics\nint g_4020c0; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strdup)(char *);\nlong long(_split_string_by_comma)(long long, long long, long long);\nlong long(verify_values)(long long, long long, long long);\n\nextern char g_402275;\nextern char g_40227a;\nextern char g_402285;\nextern char g_402290;\nextern char g_402291;\nextern char g_402297;\n\nlong long test_split_string_by_comma_ok_name_conflict() {\n  unsigned long v0; // [bp-0x118]\n  unsigned long v1; // [bp-0x110]\n  unsigned long v2; // [bp-0x108]\n  unsigned long v3; // [bp-0x100]\n  unsigned long v4; // [bp-0xf8]\n  unsigned long v5; // [bp-0xf0]\n  unsigned long v6; // [bp-0xe8]\n  unsigned long v7; // [bp-0xe0]\n  unsigned long v8; // [bp-0xd8]\n  unsigned long v9; // [bp-0xd0]\n  char v10;         // [bp-0xc8]\n  void *v12;        // rbx\n  void *v14;        // rbx\n\n  v12 = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n  if ((int)_split_string_by_comma(v12, &v10, 24) != 4) {\n    printf(&g_402285, &g_40227a, &g_402008, &g_402275);\n    return \"should return the correct number of values\";\n  }\n  printf(&g_402297, &g_402291, &g_402008, &g_402275);\n  v6 = \"JACK\";\n  v7 = \"ENGQVIST\";\n  v8 = \"JOHANSSON\";\n  v9 = \"89\";\n  if ((int)verify_values(&v10, &v6, 4)) {\n    printf(&g_402285, &g_40227a, &g_402038, &g_402275);\n    return \"should be able to split a comma seperated string\";\n  }\n  printf(&g_402297, &g_402291, &g_402038, &g_402275);\n  free(v12);\n  v14 = strdup(\",SOME,EMPTY,VALUES,,\");\n  if ((int)_split_string_by_comma(v14, &v10, 24) != 6) {\n    printf(&g_402285, &g_40227a, &g_402070, &g_402275);\n    return \"should return the correct number of values even when there is \"\n           \"empty values (,,)\";\n  }\n  printf(&g_402297, &g_402291, &g_402070, &g_402275);\n  v0 = &g_402290;\n  v1 = \"SOME\";\n  v2 = \"EMPTY\";\n  v3 = \"VALUES\";\n  v4 = &g_402290;\n  v5 = &g_402290;\n  if (!(int)verify_values(&v10, &v0, 6)) {\n    printf(&g_402297, &g_402291, &g_4020c0, &g_402275);\n    free(v14);\n    return 0;\n  }\n  printf(&g_402285, &g_40227a, &g_4020c0, &g_402275);\n  return \"should be able to split empty values (,,)\";\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_crop_sentence_ok() {\n    char *rv;\n    char *test_str;\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89*D1\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string\", \"\\033[0m\");\n            return \"should return a cropped string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n            return \"should return a cropped string without checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values\", \"\\033[0m\");\n            return \"should work with empty values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,*1D\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values and checksum\", \"\\033[0m\");\n            return \"should work with empty values and checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values and checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_is_value_set() {\n    int rv;\n    rv = _is_value_set(\"JACK\");\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when there is a value\", \"\\033[0m\");\n            return \"should return 0 when there is a value\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when there is a value\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(\"\");\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n            return \"should return -1 when the string is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(((void *)0));\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_split_string_by_comma()\", \"\\033[0m\");\n    do {\n        char *message = test_split_string_by_comma_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_crop_sentence()\", \"\\033[0m\");\n    do {\n        char *message = test_crop_sentence_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_is_value_set()\", \"\\033[0m\");\n    do {\n        char *message = test_is_value_set();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nlong long(nmea_init_parser)(long long);\nchar *(strcat)(char *, char *);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[19];\n  char field_13;\n} struct_1;\n\nextern unsigned int n_parsers;\nextern void *parsers;\n\nlong long nmea_load_parsers_name_conflict() {\n  void *v0;              // [bp-0x838]\n  char *v2;              // r13, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n  char *v4;              // rbp\n  struct_1 *v5;          // rax\n  char *v6;              // rbx\n  unsigned long long v7; // rax\n  char *v8;              // rax\n  struct_0 *v9;      // r12, Other Possible Types: unsigned long, unsigned int\n  struct_0 *v10;     // rbx\n  unsigned long v12; // rbx\n  unsigned long long v13; // r13\n  void *v14;              // r12\n  unsigned long long v15; // rax\n\n  v2 = getenv(\"NMEA_PARSER_PATH\");\n  if (!v2)\n    v2 = \"/usr/lib/nmea/\";\n  v3 = opendir(v2);\n  if (v3) {\n    v4 = v3;\n    v9 = 0;\n    while (true) {\n      do {\n        do {\n          v5 = readdir(v4);\n          if (!v5) {\n            closedir(v4);\n            n_parsers = v9;\n            if ((unsigned int)v9 <= 0)\n              return 4294967295;\n            v10 = v9 * 8;\n            parsers = malloc(v10);\n            if (!parsers)\n              return 4294967295;\n            memset(parsers, 0, v10);\n            v12 = v10 + 8;\n            v13 = (v9 - (v9 - 1)) * 8 - 16;\n            while (v15) {\n              v14 = *((long long *)((char *)&v0 + v12));\n              v15 = nmea_init_parser(v14);\n              free(v14);\n              *((unsigned long long *)((char *)parsers + v12)) = v15;\n              v12 -= 8;\n              if (v12 == v13)\n                return n_parsers;\n            }\n            return 4294967295;\n          }\n        } while (v5->field_13 == 46);\n      } while ((v6 = v5 + 19, v7 = strlen(v6),\n                !(v7 > 2) || !(!strncmp(v6 + v7 - 3, \".so\", 3))));\n      v8 = malloc(255);\n      if (!v8)\n        break;\n      strcpy(v8, v2);\n      strcat(v8, v6);\n      (&v0)[v9] = v8;\n      v9 += 1;\n    }\n    if ((unsigned int)v9 > 0) {\n      do {\n        free(v0);\n        v9 = (unsigned int)v9 + 1;\n      } while (v9 != 0x80000000);\n    }\n    closedir(v4);\n  }\n  n_parsers = -1;\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpgyy_5uzk/nmea_load_parsers_name_conflict.c:73:34: error: invalid operands to binary\nexpression ('struct_0 *' (aka 'struct struct_0 *') and 'int') 73 | v10 = v9 * 8;\n      |                               ~~ ^ ~\n/tmp/tmpgyy_5uzk/nmea_load_parsers_name_conflict.c:99:18: error: array subscript is not an\ninteger 99 |             (&v0)[v9] = v8; |                  ^~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"static char *test_position_parse_ok() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"12311.12\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(123 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(11.119999999999999 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"2621.44\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(26 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21.440000000000001 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.01\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1.01 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1. == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    free(pos);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_position_parse_fail() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"123\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on failure\", \"\\033[0m\");\n            return \"should return return -1 on failure\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on failure\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on empty string\", \"\\033[0m\");\n            return \"should return return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    res = nmea_position_parse(((void *)0), pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on NULL\", \"\\033[0m\");\n            return \"should return return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    free(pos);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_ok() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"N\");\n    do {\n        if (!((nmea_cardinal_t)'N' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"E\");\n    do {\n        if (!((nmea_cardinal_t)'E' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"S\");\n    do {\n        if (!((nmea_cardinal_t)'S' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"W\");\n    do {\n        if (!((nmea_cardinal_t)'W' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_fail() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(((void *)0));\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"J\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"n\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_ok() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"171521\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n            return \"t.tm_sec should be 21\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(15 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 15\", \"\\033[0m\");\n            return \"t.tm_min should be 15\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 15\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(17 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n            return \"t.tm_hour should be 17\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"090801\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n            return \"t.tm_sec should be 1\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(8 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 8\", \"\\033[0m\");\n            return \"t.tm_min should be 8\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 8\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n            return \"t.tm_hour should be 9\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_fail() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"240000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n            return \"should return -1 when hours is over 23\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"006000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n            return \"should return -1 when minutes is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"000062\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n            return \"should return -1 when seconds is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on too short string\", \"\\033[0m\");\n            return \"should return -1 on too short string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on too short string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345XX\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n            return \"should return -1 on invalid characters\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on empty string\", \"\\033[0m\");\n            return \"should return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(((void *)0), &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_position_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_position_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_position_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_cardinal_dir_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_cardinal_dir_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_cardinal_dir_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_time_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_time_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_time_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":1,"function":"nmea_cardinal_t nmea_cardinal_direction_parse(char *s) {\n    if (((void *)0) == s || '\\x00' == *s) {\n        return (nmea_cardinal_t)'\\x00';\n    }\n    switch (*s) {\n      case (nmea_cardinal_t)'N':\n        return (nmea_cardinal_t)'N';\n      case (nmea_cardinal_t)'E':\n        return (nmea_cardinal_t)'E';\n      case (nmea_cardinal_t)'S':\n        return (nmea_cardinal_t)'S';\n      case (nmea_cardinal_t)'W':\n        return (nmea_cardinal_t)'W';\n      default:\n        break;\n    }\n    return (nmea_cardinal_t)'\\x00';\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nmea_cardinal_direction_parse_name_conflict(char *a0) {\n  void *v1; // rax\n\n  if (!a0)\n    return 0;\n  v1 = *(a0);\n  if (!(char)v1) {\n    return *(a0);\n  } else if ((char)v1 == 83) {\n    return *(a0);\n  } else if ((char)v1 > 83) {\n    if ((char)v1 != 87)\n      return 0;\n    return *(a0);\n  } else {\n    if ((char)v1 == 69) {\n      return *(a0);\n    } else if ((char)v1 != 78) {\n      return 0;\n    } else {\n      return *(a0);\n    }\n  }\n}\n","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/src/parsers/parse.c"}
{"compilable":0,"function":"static char *test_get_type_ok() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGLL == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n            return \"should return correct type (GPGLL)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGGA,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGGA == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n            return \"should return correct type (GPGGA)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_type_unknown() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"THISISWRONG\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$UNKNOWN\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n            return \"should return nmea_unknown on empty sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_without_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_yes() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*1D\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n            return \"should return 0 when sentence has a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_no() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n            return \"should return -1 when sentence does not have a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_without_crc() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*FF\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 0);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n            return \"should return 0 when check_checksum is 0 and crc is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_type() {\n    char *sentence = strdup(\"$GPgll,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence type is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_start() {\n    char *sentence = strdup(\"\\302\\243GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence start is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_end() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence ending is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GP\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n            return \"should return -1 when sentence is too short\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_empty() {\n    char *sentence = strdup(\"\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n            return \"should return -1 when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_ok() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 0);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_unknown() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$JACK1,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n            return \"should return NULL when sentence type is unknown\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_invalid() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n            return \"should return NULL when checksum is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n            return \"should return NULL when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"invalid\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n            return \"should return NULL when sentence is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    res = nmea_parse(((void *)0), 0, 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n            return \"should return NULL when sentence is NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n    } while (0);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_type()\", \"\\033[0m\");\n    do {\n        char *message = test_get_type_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_type_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_get_checksum_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_checksum_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_has_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_has_checksum_yes();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_has_checksum_no();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_validate()\", \"\\033[0m\");\n    do {\n        char *message = test_validate_ok_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_ok_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_type();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_start();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_end();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_empty();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_invalid();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static int _is_value_set(const char *value) {\n    if (((void *)0) == value || '\\x00' == *value) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static char *_crop_sentence(char *sentence, size_t length) {\n    sentence += 5 + 2;\n    sentence[length - 9] = '\\x00';\n    if ('*' == sentence[length - 12]) {\n        sentence[length - 12] = '\\x00';\n    }\n    return sentence;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _split_string_by_comma(char *string, char **values, int max_values) {\n    int i = 0;\n    values[i++] = string;\n    while (i < max_values && ((void *)0) != (string = strchr(string, ',')))\n        {\n            *string = '\\x00';\n            values[i++] = ++string;\n        }\n    return i;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_t nmea_get_type(const char *sentence) {\n    if (((void *)0) == sentence) {\n        return NMEA_UNKNOWN;\n    }\n    nmea_parser_module_s *parser = nmea_get_parser_by_sentence(sentence);\n    if (((void *)0) == parser) {\n        return NMEA_UNKNOWN;\n    }\n    return parser->parser.type;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_get_parser_by_sentence)(long long);\n\nlong long nmea_get_type_name_conflict(unsigned long long a0) {\n  unsigned int *v1; // rax\n\n  if (a0) {\n    v1 = nmea_get_parser_by_sentence(a0);\n    return (!v1 ? *(v1) : 0);\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"uint8_t nmea_get_checksum(const char *sentence) {\n    const char *n = sentence + 1;\n    uint8_t chk = 0;\n    while ('*' != *n && '\\r' != *n && '\\x00' != *n)\n        {\n            chk ^= (uint8_t)*n;\n            n++;\n        }\n    return chk;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long nmea_get_checksum_name_conflict(struct_0 *a0) {\n  unsigned long long v0; // [bp-0x120]\n  char *v2;              // rdx\n  unsigned long v4;      // rcx, Other Possible Types: unsigned int\n\n  v2 = &a0->field_1;\n  if (a0->field_1 > 42) {\n    v4 = 0;\n  } else {\n    v4 = 0;\n    v0 = 4398046519297;\n    if (((char)(*((char *)&v0 + ((a0->field_1 & 63) >> 3)) >>\n                (a0->field_1 & 63 & 7)) &\n         1))\n      return 0;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_has_checksum(const char *sentence, size_t length) {\n    if ('*' == sentence[length - 5]) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nmea_has_checksum_name_conflict(unsigned long a0, unsigned long a1) {\n  return -(*((char *)(a0 + a1 - 5)) != 42);\n}\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_validate(const char *sentence, size_t length, int check_checksum) {\n    const char *n;\n    if (9 > length) {\n        return -1;\n    }\n    if (82 < length) {\n        return -1;\n    }\n    if ('$' != *sentence) {\n        return -1;\n    }\n    if ('\\n' != sentence[length - 1] || '\\r' != sentence[length - 2]) {\n        return -1;\n    }\n    n = sentence;\n    while (++n < sentence + 6)\n        {\n            if (*n < 'A' || *n > 'Z') {\n                return -1;\n            }\n        }\n    if (',' != sentence[6]) {\n        return -1;\n    }\n    if (1 == check_checksum && 0 == nmea_has_checksum(sentence, length)) {\n        uint8_t actual_chk;\n        uint8_t expected_chk;\n        char checksum[3];\n        checksum[0] = sentence[length - 4];\n        checksum[1] = sentence[length - 3];\n        checksum[2] = '\\x00';\n        actual_chk = nmea_get_checksum(sentence);\n        expected_chk = (uint8_t)strtol(checksum, ((void *)0), 16);\n        if (expected_chk != actual_chk) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_has_checksum)(long long, long long);\nlong long(nmea_get_checksum)(long long);\n\nlong long nmea_validate_name_conflict(char a0[7], unsigned long long a1, unsigned long a2) {\n  char v0;               // [bp-0x1b]\n  char v1;               // [bp-0x1a]\n  char v2;               // [bp-0x19]\n  unsigned long long v4; // r12, Other Possible Types: unsigned long\n  char v5[7];            // rax, Other Possible Types: unsigned long\n\n  if (a1 - 9 > 73) {\n    return 4294967295;\n  } else if (a0[0] != 36) {\n    return 4294967295;\n  } else if (a0[1 + a1] != 10) {\n    return 4294967295;\n  } else if (a0[2 + a1] != 13) {\n    return 4294967295;\n  } else {\n    v5 = a0;\n    while (true) {\n      v5 += 1;\n      if (v5 == &a0[6])\n        break;\n      if (*((char *)v5) - 65 > 25)\n        return 4294967295;\n    }\n    if (a0[6] != 44) {\n      return 4294967295;\n    } else if ((unsigned int)a2 != 1) {\n      return 0;\n    } else {\n      v4 = nmea_has_checksum(a0, a1);\n      if ((unsigned int)v4)\n        return 0;\n      v0 = a0[4 + a1];\n      v1 = a0[3 + a1];\n      v2 = 0;\n      if ((char)nmea_get_checksum(a0) == (char)strtol(&v0, NULL, 16))\n        return v4;\n      v4 = 4294967295;\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpaepfxvy1/nmea_validate_name_conflict.c:45:12: error: array type 'char[7]' is not\nassignable 45 |         v5 = a0; |         ~~ ^\n/tmp/tmpaepfxvy1/nmea_validate_name_conflict.c:48:16: error: invalid operands to binary\nexpression ('char[7]' and 'int') 48 |             v5 += 1; |             ~~ ^  ~\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_s *nmea_parse(char *sentence, size_t length, int check_checksum) {\n    unsigned int n_vals, val_index;\n    char *value, *val_string;\n    char *values[255];\n    nmea_parser_module_s *parser;\n    nmea_t type;\n    if (-1 == nmea_validate(sentence, length, check_checksum)) {\n        return (nmea_s *)((void *)0);\n    }\n    type = nmea_get_type(sentence);\n    if (NMEA_UNKNOWN == type) {\n        return (nmea_s *)((void *)0);\n    }\n    val_string = _crop_sentence(sentence, length);\n    if (((void *)0) == val_string) {\n        return (nmea_s *)((void *)0);\n    }\n    n_vals = _split_string_by_comma(val_string, values, (sizeof values / sizeof (values[0])));\n    if (0 == n_vals) {\n        return (nmea_s *)((void *)0);\n    }\n    parser = nmea_get_parser_by_type(type);\n    if (((void *)0) == parser) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->allocate_data((nmea_parser_s *)parser);\n    if (((void *)0) == parser->parser.data) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->set_default((nmea_parser_s *)parser);\n    parser->errors = 0;\n    for (val_index = 0; val_index < n_vals; val_index++) {\n        value = values[val_index];\n        if (-1 == _is_value_set(value)) {\n            continue;\n        }\n        if (-1 == parser->parse((nmea_parser_s *)parser, value, val_index)) {\n            parser->errors++;\n        }\n    }\n    parser->parser.data->type = type;\n    parser->parser.data->errors = parser->errors;\n    return parser->parser.data;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nmea_validate)(long long, long long, long long);\nlong long(nmea_get_type)(long long);\nlong long(nmea_get_parser_by_type)(long long);\n\ntypedef struct struct_1 {\n  unsigned int field_0;\n  unsigned int field_4;\n  char padding_8[8];\n  struct struct_1 *field_10;\n  unsigned int field_18;\n  char padding_1c[12];\n  struct struct_0 *field_28;\n  struct struct_0 *field_30;\n  char padding_38[8];\n  struct struct_0 *field_40;\n} struct_1;\n\ntypedef struct struct_0 {\n  struct struct_0 *field_0;\n} struct_0;\n\nlong long nmea_parse(unsigned long long a0, unsigned long long a1,\n                     unsigned long long a2) {\n  char *v0;               // [bp-0x828]\n  unsigned long v3;       // r12\n  unsigned long long v4;  // rbp\n  char *v5;               // rax\n  struct struct_2 **v6;   // r12\n  char *v7;               // rax\n  unsigned long v8;       // rbx\n  char *v9;               // rdi, Other Possible Types: unsigned long\n  struct_1 *v10;          // rax\n  struct_1 *v11;          // rax\n  unsigned long long v12; // r13\n  unsigned long v13;      // rbx\n  char *v14;              // rsi\n\n  if ((int)nmea_validate(a0, a1, a2) == -1)\n    return 0;\n  v4 = nmea_get_type(a0);\n  if (!(unsigned int)v4)\n    return 0;\n  v9 = a0 + 7;\n  v9[9 + a1] = 0;\n  v5 = &v9[a1 + 12];\n  if (*(v5) == 42)\n    *(v5) = 0;\n  v0 = v9;\n  v8 = 1;\n  do {\n    v6 = v8;\n    v7 = strchr(v9, 44);\n    if (!v7) {\n    LABEL_402638:\n      if (!(unsigned int)v8)\n        return 0;\n      v10 = nmea_get_parser_by_type(v4);\n      v3 = v10;\n      if (!v10)\n        return v10;\n      v10->field_28(v10);\n      v11 = v10->field_10;\n      if (!v3)\n        return v11;\n      *((long long *)(v3 + 48))(v3);\n      *((int *)(v3 + 24)) = 0;\n      v12 = v8 - 1;\n      v13 = 0;\n      while (true) {\n        v14 = (&v0)[v13];\n        if (v14 && *(v14) && *((long long *)(v3 + 64))(v3) == -1)\n          *((int *)(v3 + 24)) = *((int *)(v3 + 24)) + 1;\n        if (v13 == v12)\n          break;\n        v13 += 1;\n      }\n      *((unsigned int *)*((long long *)(v3 + 16))) = v4;\n      *((int *)(*((long long *)(v3 + 16)) + 4)) = *((int *)(v3 + 24));\n      v3 = *((long long *)(v3 + 16));\n      return v3;\n    }\n  } while (\n      (*(v7) = 0, v9 = v7 + 1, (&v0)[v8] = (char *)v9, v8 += 1, v8 != 255));\n  v8 = (char *)v6 + 1;\n  goto LABEL_402638;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2oc_n53d/nmea_parse.c:78:26: error: called object type 'struct struct_0\n*' is not a function or function pointer 78 |             v10->field_28(v10); |\n~~~~~~~~~~~~~^ /tmp/tmp2oc_n53d/nmea_parse.c:82:38: error: called object type\n'long long *' is not a function or function pointer 82 |             *((long\nlong *)(v3 + 48))(v3); |              ~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmp2oc_n53d/nmea_parse.c:89:63: error: called object type 'long long *' is\nnot a function or function pointer 89 |                 if (v14 && *(v14) &&\n*((long long *)(v3 + 64))(v3) == -1) | ~~~~~~~~~~~~~~~~~~~~~~~~^ 3 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(getenv)(char *);\nchar *(opendir)(char *);\nchar *(readdir)(char *);\nchar *(closedir)(char *);\nlong long(nmea_init_parser)(long long);\nchar *(strcat)(char *, char *);\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[19];\n  char field_13;\n} struct_0;\n\nextern unsigned int n_parsers;\nextern void *parsers;\n\nlong long nmea_load_parsers_name_conflict() {\n  void *v0;              // [bp-0x838]\n  char *v2;              // r13, Other Possible Types: unsigned long\n  unsigned long long v3; // rax\n  char *v4;              // rbp\n  struct_0 *v5;          // rax\n  char *v6;              // rbx\n  unsigned long long v7; // rax\n  char *v8;              // rax\n  struct_1 *v9;      // r12, Other Possible Types: unsigned long, unsigned int\n  struct_1 *v10;     // rbx\n  unsigned long v12; // rbx\n  unsigned long long v13; // r13\n  void *v14;              // r12\n  unsigned long long v15; // rax\n\n  v2 = getenv(\"NMEA_PARSER_PATH\");\n  if (!v2)\n    v2 = \"/usr/lib/nmea/\";\n  v3 = opendir(v2);\n  if (v3) {\n    v4 = v3;\n    v9 = 0;\n    while (true) {\n      do {\n        do {\n          v5 = readdir(v4);\n          if (!v5) {\n            closedir(v4);\n            n_parsers = v9;\n            if ((unsigned int)v9 <= 0)\n              return 4294967295;\n            v10 = v9 * 8;\n            parsers = malloc(v10);\n            if (!parsers)\n              return 4294967295;\n            memset(parsers, 0, v10);\n            v12 = v10 + 8;\n            v13 = (v9 - (v9 - 1)) * 8 - 16;\n            while (v15) {\n              v14 = *((long long *)((char *)&v0 + v12));\n              v15 = nmea_init_parser(v14);\n              free(v14);\n              *((unsigned long long *)((char *)parsers + v12)) = v15;\n              v12 -= 8;\n              if (v12 == v13)\n                return n_parsers;\n            }\n            return 4294967295;\n          }\n        } while (v5->field_13 == 46);\n      } while ((v6 = v5 + 19, v7 = strlen(v6),\n                !(v7 > 2) || !(!strncmp(v6 + v7 - 3, \".so\", 3))));\n      v8 = malloc(255);\n      if (!v8)\n        break;\n      strcpy(v8, v2);\n      strcat(v8, v6);\n      (&v0)[v9] = v8;\n      v9 += 1;\n    }\n    if ((unsigned int)v9 > 0) {\n      do {\n        free(v0);\n        v9 = (unsigned int)v9 + 1;\n      } while (v9 != 0x80000000);\n    }\n    closedir(v4);\n  }\n  n_parsers = -1;\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuwxfgp33/nmea_load_parsers_name_conflict.c:73:34: error: invalid operands to binary\nexpression ('struct_1 *' (aka 'struct struct_1 *') and 'int') 73 | v10 = v9 * 8;\n      |                               ~~ ^ ~\n/tmp/tmpuwxfgp33/nmea_load_parsers_name_conflict.c:99:18: error: array subscript is not an\ninteger 99 |             (&v0)[v9] = v8; |                  ^~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long usart_recv_name_conflict(struct_0 *a0) { return a0->field_1; }\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(usart_wait_recv_ready)(long long);\n\nlong long usart_recv_blocking_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  v1 = (unsigned short)a0;\n  usart_wait_recv_ready(v1);\n  return *((char *)((unsigned int)v1 + 1));\n}\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long usart_recv_name_conflict(struct_0 *a0) { return a0->field_1; }\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(usart_wait_recv_ready)(long long);\n\nlong long usart_recv_blocking_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  v1 = (unsigned short)a0;\n  usart_wait_recv_ready(v1);\n  return *((char *)((unsigned int)v1 + 1));\n}\n","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"char *replace_str(char *str, char *orig, char *rep) {\n    static char buffer[4096];\n    char *p;\n    int i = 0;\n    while (str[i])\n        {\n            if (!(p = strstr(str + i, orig)))\n                return str;\n            strncpy(buffer + strlen(buffer), str + i, (p - str) - i);\n            buffer[p - str] = '\\x00';\n            strcat(buffer, rep);\n            printf(\"STR:%s\\n\", buffer);\n            i = (p - str) + strlen(orig);\n        }\n    return buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strncpy)(char *, char *, unsigned long);\nchar *(strcat)(char *, char *);\n\nextern char buffer.0;\n\nlong long replace_str_name_conflict(char *a0, char *a1, char *a2) {\n  char *v2;              // r12, Other Possible Types: unsigned long\n  void *v3;              // rbp, Other Possible Types: unsigned long\n  unsigned long long v4; // rax\n  unsigned long v5;      // rbx\n\n  if (!*(a0))\n    return &buffer.0;\n  v2 = a0;\n  v3 = 0;\n  while (v4) {\n    v4 = strstr(v2, a1);\n    v5 = v4 - a0;\n    strncpy(&(&buffer.0)[strlen(&buffer.0)], v2, v5 - v3);\n    (&buffer.0)[v5] = 0;\n    strcat(&buffer.0, a2);\n    printf(\"STR:%s\\n\", &buffer.0);\n    v3 = v5 + strlen(a1);\n    v2 = &a0[v3];\n    if (!*((char *)v2))\n      return &buffer.0;\n  }\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:19:19: error: expected ';' after top level\ndeclarator 19 | extern char buffer.0; |                   ^ | ;\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:29:23: error: expected ';' after return statement\n   29 |         return &buffer.0;\n      |                       ^\n      |                       ;\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:35:17: error: invalid operands to binary\nexpression ('unsigned long long' and 'char *') 35 |         v5 = v4 - a0; | ~~ ^\n~~ /tmp/tmpjioyb5zd/replace_str_name_conflict.c:36:26: error: expected ')' 36 |\nstrncpy(&(&buffer.0)[strlen(&buffer.0)], v2, v5 - v3); | ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:36:18: note: to match this '('\n   36 |         strncpy(&(&buffer.0)[strlen(&buffer.0)], v2, v5 - v3);\n      |                  ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:36:44: error: expected ')'\n   36 |         strncpy(&(&buffer.0)[strlen(&buffer.0)], v2, v5 - v3);\n      |                                            ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:36:36: note: to match this '('\n   36 |         strncpy(&(&buffer.0)[strlen(&buffer.0)], v2, v5 - v3);\n      |                                    ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:36:57: error: invalid operands to binary\nexpression ('unsigned long' and 'void *') 36 |\nstrncpy(&(&buffer.0)[strlen(&buffer.0)], v2, v5 - v3); | ~~ ^ ~~\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:37:17: error: expected ')'\n   37 |         (&buffer.0)[v5] = 0;\n      |                 ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:37:9: note: to match this '('\n   37 |         (&buffer.0)[v5] = 0;\n      |         ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:38:23: error: expected ')'\n   38 |         strcat(&buffer.0, a2);\n      |                       ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:38:15: note: to match this '('\n   38 |         strcat(&buffer.0, a2);\n      |               ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:39:35: error: expected ')'\n   39 |         printf(\"STR:%s\\n\", &buffer.0);\n      |                                   ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:39:15: note: to match this '('\n   39 |         printf(\"STR:%s\\n\", &buffer.0);\n      |               ^\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:41:17: error: array subscript is not an integer\n   41 |         v2 = &a0[v3];\n      |                 ^~~\n/tmp/tmpjioyb5zd/replace_str_name_conflict.c:43:27: error: expected ';' after return statement\n   43 |             return &buffer.0;\n      |                           ^\n      |                           ;\n11 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cwkx_cgim/prc/cg_prc.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  char *v4;         // rax\n\n  for (v2 = 1; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 0x100) * 19342813113834067 >> 64 >> 11) * 0x1dcd6500;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 << 4) + 8)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4ub_4_g_/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmp4ub_4_g_/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmp4ub_4_g_/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500; | ~~~~~~ ^  ~\n/tmp/tmp4ub_4_g_/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmp4ub_4_g_/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[2]; // rbx\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *((long long *)&vocab_size) * 16 + vocab;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (60 < (unsigned int)v2)\n    v2 = 60;\n  v3 = calloc(v2, 1);\n  v1[1] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkzwyov9_/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[2]' is not assignable 33 |     v1 = *((long long *)&vocab_size) * 16 +\nvocab; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  void *v2; // rcx, Other Possible Types: unsigned long\n  char *v4; // rax\n\n  for (v2 = 0; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz77n6gey/GetWordHash_name_conflict.c:27:22: error: invalid operands to binary\nexpression ('void *' and 'int') 27 |         v2 = v2 + v2 * 0x100 + *((char\n*)rax); |                   ~~ ^ ~~~~~ /tmp/tmpz77n6gey/GetWordHash_name_conflict.c:29:22:\nerror: invalid operands to binary expression ('void *' and 'int') 29 | return v2\n- ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000; | ~~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 + (v4 << 2) << 3) + 16)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx7v_cqzh/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpx7v_cqzh/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpx7v_cqzh/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000; | ~~~~~~ ^  ~\n/tmp/tmpx7v_cqzh/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpx7v_cqzh/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[3]; // rbp\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = vocab + *((long long *)&vocab_size) * 40;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (100 < (unsigned int)v2)\n    v2 = 100;\n  v3 = calloc(v2, 1);\n  v1[2] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 7) * 18764999 >> 42) * 30000000;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl8gi752y/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[3]' is not assignable 33 |     v1 = vocab + *((long long *)&vocab_size) *\n40; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":0,"function":"int read_pid(char *pidfile) {\n    FILE *f;\n    int pid;\n    if (!(f = fopen(pidfile, \"r\")))\n        return 0;\n    fscanf(f, \"%d\", &pid);\n    fclose(f);\n    return pid;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_fscanf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, ...);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long read_pid_name_conflict(char *a0) {\n  char v0;    // [bp-0xc]\n  FILE_t *v2; // rax\n\n  v2 = fopen(a0, \"r\");\n  if (!v2)\n    return 0;\n  __isoc99_fscanf(v2, \"%d\", (unsigned int)&v0);\n  fclose(v2);\n  return *((int *)&v0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa129401h/read_pid_name_conflict.c:30:16: error: nested redefinition of '_IO_marker'\n   30 |         struct _IO_marker {\n      |                ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:73:13: error: declaration of anonymous union must be\na definition 73 |             union <anon> { |             ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:76:22: error: type name requires a specifier or\nqualifier 76 |             } __value; |                      ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:80:13: error: declaration of anonymous union must be\na definition 80 |             union <anon> { |             ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:83:22: error: type name requires a specifier or\nqualifier 83 |             } __value; |                      ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:141:16: error: redefinition of '_IO_marker'\n  141 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:29:12: note: previous definition is here\n   29 |     struct _IO_marker {\n      |            ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:147:16: error: redefinition of '_IO_codecvt'\n  147 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:51:12: note: previous definition is here\n   51 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:151:16: error: redefinition of '_IO_wide_data'\n  151 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:59:12: note: previous definition is here\n   59 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpa129401h/read_pid_name_conflict.c:174:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 174 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^ 9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"int get_usage(const pid_t pid, struct pstat *result) {\n    char pid_s[20];\n    snprintf(pid_s, sizeof (pid_s), \"%d\", pid);\n    char stat_filepath[30] = \"/proc/\";\n    strncat(stat_filepath, pid_s, sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    strncat(stat_filepath, \"/stat\", sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    FILE *fpstat = fopen(stat_filepath, \"r\");\n    if (fpstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        return -1;\n    }\n    FILE *fstat = fopen(\"/proc/stat\", \"r\");\n    if (fstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        fclose(fstat);\n        return -1;\n    }\n    memset(result, 0, sizeof(struct pstat));\n    long rss;\n    if (fscanf(fpstat, \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\", &result->utime_ticks, &result->stime_ticks, &result->cutime_ticks, &result->cstime_ticks, &result->vsize, &rss) == (-1)) {\n        fclose(fpstat);\n        return -1;\n    }\n    fclose(fpstat);\n    result->rss = rss * sysconf(_SC_PAGESIZE);\n    unsigned long cpu_time[10];\n    memset(cpu_time, 0, sizeof (cpu_time));\n    if (fscanf(fstat, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &cpu_time[0], &cpu_time[1], &cpu_time[2], &cpu_time[3], &cpu_time[4], &cpu_time[5], &cpu_time[6], &cpu_time[7], &cpu_time[8], &cpu_time[9]) == (-1)) {\n        fclose(fstat);\n        return -1;\n    }\n    fclose(fstat);\n    for (int i = 0; i < 10; i++)\n        result->cpu_total_time += cpu_time[i];\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(snprintf)(char *, unsigned long, char *, ...);\nchar *(strncat)(char *, char *, unsigned long);\nvoid(perror)(char *);\nint(__isoc99_fscanf)(\n    struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *,\n    char *, ...);\nlong(sysconf)(int);\n\ntypedef struct FILE_t {\n  unsigned int _flags;\n  char padding_4[4];\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  struct _IO_marker *_markers;\n  struct _IO_marker *_chain;\n  unsigned int _fileno;\n  unsigned int _flags2;\n  unsigned int _old_offset;\n  char padding_7c[4];\n  unsigned short _cur_column;\n  char _vtable_offset;\n  char _shortbuf[1];\n  char padding_84[4];\n  struct _IO_marker *_lock;\n  unsigned long long _offset;\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  void *_freeres_list;\n  char __pad5;\n  char padding_b1[7];\n  unsigned int _mode;\n  char _unused2[20];\n} FILE_t;\n\ntypedef struct struct_0 {\n  uint128_t field_0;\n  uint128_t field_10;\n  uint128_t field_20;\n  unsigned long long field_30;\n} struct_0;\n\ntypedef struct struct_1 {\n  char field_0;\n} struct_1;\n\ntypedef struct _IO_marker {\n  struct _IO_marker *_next;\n  struct _IO_marker *_sbuf;\n  unsigned int _pos;\n} _IO_marker;\n\ntypedef struct _IO_codecvt {\n  char __cd_out;\n} _IO_codecvt;\n\ntypedef struct _IO_wide_data {\n  unsigned short *_IO_read_ptr;\n  unsigned short *_IO_read_end;\n  unsigned short *_IO_read_base;\n  unsigned short *_IO_write_base;\n  unsigned short *_IO_write_ptr;\n  unsigned short *_IO_write_end;\n  unsigned short *_IO_buf_base;\n  unsigned short *_IO_buf_end;\n  unsigned short *_IO_save_base;\n  unsigned short *_IO_backup_base;\n  unsigned short *_IO_save_end;\n  __mbstate_t _IO_state;\n  char padding_5d[3];\n  char _IO_last_state;\n  char padding_61[7];\n  unsigned short _shortbuf[1];\n  _IO_marker _wide_vtable;\n} _IO_wide_data;\n\ntypedef struct __mbstate_t {\n  unsigned int __count;\n  char __value;\n} __mbstate_t;\n\nlong long get_usage_name_conflict(unsigned long a0, struct_0 *a1) {\n  int v0;                 // [bp-0xc8]\n  int v1;                 // [bp-0xb8]\n  int v2;                 // [bp-0xa8]\n  int v3;                 // [bp-0x98]\n  int v4;                 // [bp-0x88]\n  char v5;                // [bp-0x78]\n  char v6;                // [bp-0x70]\n  char v7;                // [bp-0x68]\n  void *v8;               // [bp-0x60]\n  void *v9;               // [bp-0x5a]\n  void *v10;              // [bp-0x52]\n  char v11;               // [bp-0x48]\n  unsigned int v13;       // ecx\n  unsigned long long v14; // rax\n  FILE_t *v15;            // r12\n  FILE_t *v16;            // r13\n  unsigned long v17;      // rdx, Other Possible Types: unsigned long long\n  struct_1 *v18;          // rax, Other Possible Types: unsigned long\n  unsigned long v19;      // rbp\n\n  v13 = a0;\n  snprintf(&v11, 20, \"%d\", (unsigned int)a0);\n  strncpy(&v7, \"/proc/\", 6);\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  strncat(&v7, &v11, 29 - strlen(&v7));\n  strncat(&v7, \"/stat\", 29 - strlen(&v7));\n  v14 = fopen(&v7, \"r\");\n  if (!v14) {\n    perror(\"FOPEN ERROR \");\n    return 4294967295;\n  }\n  v15 = v14;\n  v16 = fopen(\"/proc/stat\", \"r\");\n  if (!v16) {\n    perror(\"FOPEN ERROR \");\n    fclose(NULL);\n    return 4294967295;\n  }\n  a1->field_0 = 0;\n  a1->field_10 = 0;\n  a1->field_20 = 0;\n  a1->field_30 = 0;\n  v19 = __isoc99_fscanf(v15,\n                        \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \"\n                        \"%lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\",\n                        (unsigned int)a1, (unsigned int)a1 + 16,\n                        (unsigned int)a1 + 8, (unsigned int)a1 + 24,\n                        (unsigned int)a1 + 32, (unsigned int)&v6);\n  if ((unsigned int)v19 == -1) {\n    fclose(v15);\n    return v19;\n  }\n  fclose(v15);\n  *((long *)((char *)&a1->field_20 + 8)) = *((long long *)&v6) * sysconf(30);\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v1) = 0;\n  *((int128_t *)&v2) = 0;\n  *((int128_t *)&v3) = 0;\n  *((int128_t *)&v4) = 0;\n  v19 = __isoc99_fscanf(v16, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\",\n                        (unsigned int)&v0, (unsigned int)&v0, (unsigned int)&v1,\n                        (unsigned int)&v1, (unsigned int)&v2, (unsigned int)&v2,\n                        (unsigned int)&v3, (unsigned int)&v3, (unsigned int)&v4,\n                        (unsigned int)&v4);\n  if ((unsigned int)v19 == -1) {\n    fclose(v16);\n    return v19;\n  }\n  fclose(v16);\n  v17 = a1->field_30;\n  v18 = &v0;\n  do {\n    v17 += *((long long *)v18);\n    v18 = &v0;\n  } while (v18 != &v5);\n  a1->field_30 = v17;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:20:7: error: conflicting types for 'perror'\n   20 | void (perror)(char *);\n      |       ^\n/usr/include/stdio.h:804:13: note: previous declaration is here\n  804 | extern void perror (const char *__s);\n      |             ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:35:16: error: nested redefinition of '_IO_marker'\n   35 |         struct _IO_marker {\n      |                ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:34:12: note: previous definition is here\n   34 |     struct _IO_marker {\n      |            ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:78:13: error: declaration of anonymous union must\nbe a definition 78 |             union <anon> { |             ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:81:22: error: type name requires a specifier or\nqualifier 81 |             } __value; |                      ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:85:13: error: declaration of anonymous union must\nbe a definition 85 |             union <anon> { |             ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:88:22: error: type name requires a specifier or\nqualifier 88 |             } __value; |                      ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:148:5: error: unknown type name 'uint128_t'\n  148 |     uint128_t field_0;\n      |     ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:149:5: error: unknown type name 'uint128_t'\n  149 |     uint128_t field_10;\n      |     ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:150:5: error: unknown type name 'uint128_t'\n  150 |     uint128_t field_20;\n      |     ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:158:16: error: redefinition of '_IO_marker'\n  158 | typedef struct _IO_marker {\n      |                ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:34:12: note: previous definition is here\n   34 |     struct _IO_marker {\n      |            ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:164:16: error: redefinition of '_IO_codecvt'\n  164 | typedef struct _IO_codecvt {\n      |                ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:56:12: note: previous definition is here\n   56 |     struct _IO_codecvt {\n      |            ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:168:16: error: redefinition of '_IO_wide_data'\n  168 | typedef struct _IO_wide_data {\n      |                ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:64:12: note: previous definition is here\n   64 |     struct _IO_wide_data {\n      |            ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:191:3: error: typedef redefinition with different\ntypes ('struct __mbstate_t' vs 'struct __mbstate_t' (aka '__mbstate_t')) 191 | }\n__mbstate_t; |   ^ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h:21:3:\nnote: previous definition is here 21 | } __mbstate_t; |   ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:249:18: error: expected expression\n  249 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:250:18: error: expected expression\n  250 |     *((int128_t *)&v1) = 0;\n      |                  ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:251:18: error: expected expression\n  251 |     *((int128_t *)&v2) = 0;\n      |                  ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:252:18: error: expected expression\n  252 |     *((int128_t *)&v3) = 0;\n      |                  ^\n/tmp/tmpz0gx1nii/get_usage_name_conflict.c:253:18: error: expected expression\n  253 |     *((int128_t *)&v4) = 0;\n      |                  ^\n19 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"pid_t launch(int argc, char **argv) {\n    int pid = fork();\n    if (pid != 0) {\n        if (pid < 0) {\n            die(\"fork\");\n        }\n        return pid;\n    }\n    sigset_t set;\n    sigfillset(&set);\n    sigprocmask(1, &set, 0);\n    setsid();\n    setpgid(0, 0);\n    char **argvn = __builtin_alloca(sizeof (argv[0]) * (argc + 1));\n    memcpy(argvn, argv, sizeof (argv[0]) * argc);\n    argvn[argc] = ((void *)0);\n    if (putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\")) {\n        die(\"putenv\");\n    }\n    execvpe(argvn[0], argvn, (char **)default_envp);\n    die2(\"execvpe\", argvn[0]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fork)();\nint(sigfillset)(int *);\nint(sigprocmask)(int, int *, int *);\nlong long(die)();\nint(setsid)();\nint(setpgid)(int, int);\nint(putenv)(char *);\nint(execvpe)(char *, char *[0], char *[0]);\nlong long(die2)();\n\nextern char *default_envp[0];\nextern char g_4027f4;\n\nlong long launch_name_conflict(unsigned long a0, void *a1) {\n  char v0;               // [bp-0xb0]\n  unsigned int v1;       // [bp-0xa8]\n  char v2;               // [bp-0x99]\n  unsigned long long v4; // rax\n  unsigned long long v5; // rbx\n  unsigned long long v6; // rax\n  char **v7;             // r13\n\n  (unsigned int)v4 = fork();\n  if (!(unsigned int)v4) {\n    sigfillset(&v1);\n    sigprocmask(1, &v1, NULL);\n    setsid();\n    setpgid(0, 0);\n    v5 = ((unsigned int)a0 + 1) * 8;\n    v6 = v5 + 23 & -0x10;\n    v7 = &(&v2)[-1 * v6] & -0x10;\n    *((char **)&(&v0)[-1 * v6]) = &g_4027f4;\n    memcpy(v7, a1, v5 - 8);\n    *((long long *)(-8 + (char *)v7 + v5)) = 0;\n    if (!putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\")) {\n      execvpe(*(v7), v7, default_envp);\n      die2(); /* do not return */\n    }\n    die(); /* do not return */\n  } else if ((unsigned int)v4 >= 0) {\n    return v4;\n  } else {\n    die(); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1kxyrkf_/launch_name_conflict.c:39:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 39 |     (unsigned int)v4 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp1kxyrkf_/launch_name_conflict.c:48:30: error: invalid operands to binary expression\n('char *' and 'int') 48 |         v7 = &(&v2)[-1 * v6] & -0x10; |\n~~~~~~~~~~~~~~~ ^ ~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":0,"function":"int reap_until(pid_t until_pid) {\n    for (;;) {\n        int status;\n        pid_t pid = wait(&status);\n        if (pid < 0) {\n            die(\"wait\");\n        }\n        if (pid == until_pid) {\n            if ((((status) & 127) == 0)) {\n                if ((((status) & 65280) >> 8) != 0) {\n                    fputs(\"child exited with error\\n\", stderr);\n                }\n                return (((status) & 65280) >> 8);\n            }\n            fputs(\"child exited by signal\\n\", stderr);\n            return 128 + ((status) & 127);\n        }\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(wait)(int *);\nlong long(die)();\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long reap_until_name_conflict(unsigned long a0) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned long long v2; // rax\n  unsigned long v3;      // rax, Other Possible Types: unsigned long long\n\n  do {\n    (unsigned int)v2 = wait(&v0);\n    if ((unsigned int)v2 < 0)\n      die(); /* do not return */\n  } while ((unsigned int)v2 != (unsigned int)a0);\n  if (((char)v0 & 127)) {\n    fwrite(\"child exited by signal\\n\", 1, 23, stderr @GLIBC_2.2.5);\n    v3 = (v0 & 127) - -128;\n    return v3;\n  }\n  if ((char)v2)\n    fwrite(\"child exited with error\\n\", 1, 24, stderr @GLIBC_2.2.5);\n  v3 = *((char *)&v0 + 1);\n  return v3;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpwazjiu12/reap_until_name_conflict.c:19:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 19 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpwazjiu12/reap_until_name_conflict.c:19:22: error: expected ';' after top level\ndeclarator 19 | extern FILE_t *stderr@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmpwazjiu12/reap_until_name_conflict.c:29:9: error: assignment to cast is illegal, lvalue\ncasts are not supported 29 |         (unsigned int)v2 = wait(&v0); |\n^~~~~~~~~~~~~~~~ ~ /tmp/tmpwazjiu12/reap_until_name_conflict.c:35:57: error: expected ')' 35 |\nfwrite(\"child exited by signal\\n\", 1, 23, stderr@GLIBC_2.2.5); | ^\n/tmp/tmpwazjiu12/reap_until_name_conflict.c:35:15: note: to match this '('\n   35 |         fwrite(\"child exited by signal\\n\", 1, 23, stderr@GLIBC_2.2.5);\n      |               ^\n/tmp/tmpwazjiu12/reap_until_name_conflict.c:40:58: error: expected ')'\n   40 |         fwrite(\"child exited with error\\n\", 1, 24, stderr@GLIBC_2.2.5);\n      |                                                          ^\n/tmp/tmpwazjiu12/reap_until_name_conflict.c:40:15: note: to match this '('\n   40 |         fwrite(\"child exited with error\\n\", 1, 24, stderr@GLIBC_2.2.5);\n      |               ^\n5 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":0,"function":"static int openvsock(unsigned int cid, unsigned int port) {\n    int s = socket(40, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_VSOCK\");\n        return -1;\n    }\n    struct sockaddr_vm addr = {0};\n    addr.svm_family = 40;\n    addr.svm_port = port;\n    addr.svm_cid = cid;\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":0,"function":"static int opentcp(unsigned short port) {\n    int s = socket(2, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_INET\");\n        return -1;\n    }\n    struct sockaddr_in addr = {0};\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = htonl(((in_addr_t)2130706433));\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\\n\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":0,"function":"int fib_rec(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        result = fib_rec(n - 1) + fib_rec(n - 2);\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(fib_rec_name_conflict)(unsigned long);\n\nlong long fib_rec_name_conflict(unsigned long a0) {\n  unsigned long v0;      // [bp-0x10]\n  unsigned long v1;      // [bp-0x8]\n  unsigned long v3;      // rbx\n  unsigned long long v5; // rbx\n\n  if ((unsigned int)a0 > 1) {\n    *((int *)&v1) = rbp;\n    v0 = v3;\n    v5 = v0;\n    return fib_rec_name_conflict(a0 - 2) + fib_rec_name_conflict(a0 - 1);\n  }\n  return 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":1,"function":"int fib_it(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        int a = 1, b = 1, c = 1;\n        for (int i = 1; i < n; i++) {\n            a = b;\n            b = c;\n            c = a + b;\n        }\n        result = c;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long fib_it_name_conflict(unsigned long a0) {\n  unsigned long v1;      // rax, Other Possible Types: unsigned long long\n  unsigned int v2;       // edx\n  unsigned long v3;      // rcx, Other Possible Types: unsigned long long\n  unsigned long long v4; // rsi\n\n  v1 = 1;\n  if ((unsigned int)a0 <= 1)\n    return 1;\n  v2 = 1;\n  v3 = 1;\n  do {\n    v4 = v1;\n    v1 += v3;\n    v2 += 1;\n    v3 = v4;\n  } while ((unsigned int)a0 != v2);\n  return v1;\n}\n","pass":1,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  char *v4;         // rax\n\n  for (v2 = 1; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 0x100) * 19342813113834067 >> 64 >> 11) * 0x1dcd6500;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 << 4) + 8)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfqx6kjg4/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpfqx6kjg4/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpfqx6kjg4/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500; | ~~~~~~ ^  ~\n/tmp/tmpfqx6kjg4/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpfqx6kjg4/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[2]; // rbx\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *((long long *)&vocab_size) * 16 + vocab;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (60 < (unsigned int)v2)\n    v2 = 60;\n  v3 = calloc(v2, 1);\n  v1[1] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_m1eexhm/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[2]' is not assignable 33 |     v1 = *((long long *)&vocab_size) * 16 +\nvocab; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  void *v2; // rcx, Other Possible Types: unsigned long\n  char *v4; // rax\n\n  for (v2 = 0; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn2xmyr3l/GetWordHash_name_conflict.c:27:22: error: invalid operands to binary\nexpression ('void *' and 'int') 27 |         v2 = v2 + v2 * 0x100 + *((char\n*)rax); |                   ~~ ^ ~~~~~ /tmp/tmpn2xmyr3l/GetWordHash_name_conflict.c:29:22:\nerror: invalid operands to binary expression ('void *' and 'int') 29 | return v2\n- ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000; | ~~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 + (v4 << 2) << 3) + 16)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpkgv5vws8/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpkgv5vws8/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpkgv5vws8/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000; | ~~~~~~ ^  ~\n/tmp/tmpkgv5vws8/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpkgv5vws8/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[3]; // rbp\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = vocab + *((long long *)&vocab_size) * 40;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (100 < (unsigned int)v2)\n    v2 = 100;\n  v3 = calloc(v2, 1);\n  v1[2] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 7) * 18764999 >> 42) * 30000000;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpic2hw8fb/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[3]' is not assignable 33 |     v1 = vocab + *((long long *)&vocab_size) *\n40; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"static char *xstrdup(const char *s) {\n    char *p = xmalloc(strlen(s) + 1);\n    strcpy(p, s);\n    return p;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int writen(int fd, const char *buffer, size_t length) {\n    while (length)\n        {\n            int nwritten = write(fd, buffer, length);\n            if (nwritten < 0) {\n                if ((*__errno_location()) == 4)\n                    continue;\n                return -1;\n            }\n            length -= nwritten;\n            buffer += nwritten;\n        }\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *read_assuan(int fd) {\n    static char pending[2048];\n    static size_t pending_len;\n    size_t nleft = sizeof recv_line;\n    char *buf = recv_line;\n    char *p;\n    while (nleft > 0)\n        {\n            int n;\n            if (pending_len) {\n                if (pending_len >= nleft)\n                    (die)(\"%s: received line too large\", __func__);\n                memcpy(buf, pending, pending_len);\n                n = pending_len;\n                pending_len = 0;\n            } else {\n                do {\n                    n = read(fd, buf, nleft);\n                } while (n < 0 && (*__errno_location()) == 4);\n            }\n            if (opt_verbose && n >= 0) {\n                int i;\n                printf(\"%s: read \\\"\", __func__);\n                for (i = 0; i < n; i++)\n                    putc(buf[i], stdout);\n                printf(\"\\\"\\n\");\n            }\n            if (n < 0)\n                (die)(\"%s: reading fd %d failed: %s\", __func__, (fd), (strerror((*__errno_location()))));\n            else if (!n)\n                (die)(\"%s: received incomplete line on fd %d\", __func__, (fd));\n            p = buf;\n            nleft -= n;\n            buf += n;\n            for (; n && *p != '\\n'; n-- , p++)\n                ;\n            if (n) {\n                if (n > 1) {\n                    n--;\n                    memcpy(pending, p + 1, n);\n                    pending_len = n;\n                }\n                *p = '\\x00';\n                break;\n            }\n        }\n    if (!nleft)\n        (die)(\"%s: received line too large\", __func__);\n    p = recv_line;\n    if (p[0] == 'O' && p[1] == 'K' && (p[2] == ' ' || !p[2])) {\n        recv_type = LINE_OK;\n        p += 3;\n    } else if (p[0] == 'E' && p[1] == 'R' && p[2] == 'R' && (p[3] == ' ' || !p[3])) {\n        recv_type = LINE_ERR;\n        p += 4;\n    } else if (p[0] == 'S' && (p[1] == ' ' || !p[1])) {\n        recv_type = LINE_STAT;\n        p += 2;\n    } else if (p[0] == 'D' && p[1] == ' ') {\n        recv_type = LINE_DATA;\n        p += 2;\n    } else if (p[0] == 'E' && p[1] == 'N' && p[2] == 'D' && !p[3]) {\n        recv_type = LINE_END;\n        p += 3;\n    } else\n        (die)(\"%s: invalid line type (%.5s)\", __func__, (p));\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(die)(...);\nchar *(strerror)(int);\nint(putc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\nextern char __func__ .7;\nextern char g_4069c1;\nextern char g_4069c2;\nextern char g_4069c3;\nextern char g_4069c4;\nextern unsigned int opt_verbose;\nextern void pending.6;\nextern void *pending_len.8;\nextern char recv_line;\nextern unsigned int recv_type;\nextern FILE_t *stdout @GLIBC_2.2.5;\n\nlong long read_assuan_name_conflict(unsigned long a0) {\n  int tmp_8;             // tmp #8\n  char *v1;              // rbp, Other Possible Types: unsigned long\n  unsigned long v2;      // r13, Other Possible Types: unsigned long long\n  char *v3;              // r12, Other Possible Types: unsigned long\n  char *v4;              // r14\n  unsigned long v5;      // rbx, Other Possible Types: unsigned long long\n  char *v6;              // rax\n  unsigned long long v7; // rbx\n\n  v1 = &recv_line;\n  v2 = 0x800;\n  while (true) {\n    if (!pending_len.8) {\n      while (true) {\n        v5 = read(a0, v1, v2);\n        if ((unsigned int)v5 >= 0)\n          break;\n      }\n      if (opt_verbose)\n        printf(\"%s: read \\\"\", &__func__ .7);\n    } else {\n      if (pending_len.8 >= v2)\n        die(); /* do not return */\n      memcpy(v1, &pending.6, pending_len.8);\n      v5 = pending_len.8;\n      pending_len.8 = 0;\n      if (opt_verbose) {\n        if ((unsigned int)pending_len.8 >= 0) {\n          printf(\"%s: read \\\"\", &__func__ .7);\n          if ((unsigned int)pending_len.8 > 0) {\n            v3 = v1;\n            v4 = pending_len.8 + v1;\n            do {\n              putc(*((char *)v3), stdout @GLIBC_2.2.5);\n              v3 += 1;\n            } while (v4 != v3);\n          }\n          puts(\"\\\"\");\n          goto LABEL_402e1c;\n        }\n        goto LABEL_402e1c;\n      }\n    }\n    if ((unsigned int)v5 < 0) {\n      strerror(*(__errno_location()));\n      die(); /* do not return */\n    }\n  LABEL_402e1c:\n    if (!(unsigned int)v5)\n      die(); /* do not return */\n    v2 -= v5;\n    v6 = v5 + v1;\n    do {\n      if (*((char *)v1) == 10) {\n        if ((unsigned int)v5) {\n          if ((unsigned int)v5 > 1) {\n            v7 = (unsigned int)v5 - 1;\n            memcpy(&pending.6, v1 + 1, pending_len.8);\n            pending_len.8 = v7;\n          }\n          *((char *)v1) = 0;\n          if (!v2)\n            die(); /* do not return */\n          if (recv_line == 79) {\n            if (g_4069c1 == 75 && !(g_4069c2 & 223)) {\n              recv_type = 0;\n              return &g_4069c3;\n            }\n          } else {\n            if (recv_line == 69) {\n              if (g_4069c1 == 82) {\n                if (g_4069c2 == 82 && !(g_4069c3 & 223)) {\n                  recv_type = 1;\n                  return &g_4069c4;\n                }\n              } else {\n                if (g_4069c1 == 78 && g_4069c2 == 68 && !g_4069c3) {\n                  recv_type = 4;\n                  return &g_4069c3;\n                }\n              }\n            } else {\n              if (recv_line != 83) {\n                if (recv_line == 68 && g_4069c1 == 32) {\n                  recv_type = 3;\n                  return &g_4069c2;\n                }\n              } else {\n                if (!(g_4069c1 & 223)) {\n                  recv_type = 2;\n                  return &g_4069c2;\n                }\n              }\n            }\n          }\n          die(); /* do not return */\n        }\n        break;\n      }\n    } while ((v1 += 1, tmp_8 = v5,\n              v5 = (unsigned long long)((unsigned int)v5 - 1),\n              (int)tmp_8 != 1));\n    if (v2)\n      v1 = v6;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:17:17: error: ISO C requires a named parameter\nbefore '...' 17 | long long (die)(...); |                 ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:33:16: error: nested redefinition of '_IO_marker'\n   33 |         struct _IO_marker {\n      |                ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:32:12: note: previous definition is here\n   32 |     struct _IO_marker {\n      |            ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:76:13: error: declaration of anonymous union must\nbe a definition 76 |             union <anon> { |             ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:79:22: error: type name requires a specifier or\nqualifier 79 |             } __value; |                      ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:83:13: error: declaration of anonymous union must\nbe a definition 83 |             union <anon> { |             ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:86:22: error: type name requires a specifier or\nqualifier 86 |             } __value; |                      ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:19:6: error: conflicting types for 'putc'\n   19 | int (putc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:550:12: note: previous declaration is here\n  550 | extern int putc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:109:13: error: expected identifier or '('\n  109 | extern char __func__.7;\n      |             ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:115:20: error: expected ';' after top level\ndeclarator 115 | extern void pending.6; |                    ^ | ;\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:116:25: error: expected ';' after top level\ndeclarator 116 | extern void* pending_len.8; |                         ^ | ;\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:119:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 119 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:119:22: error: expected ';' after top level\ndeclarator 119 | extern FILE_t *stdout@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:136:25: error: expected ')'\n  136 |         if (!pending_len.8)\n      |                         ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:136:12: note: to match this '('\n  136 |         if (!pending_len.8)\n      |            ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:145:48: error: expected ')'\n  145 |                 printf(\"%s: read \\\"\", &__func__.7);\n      |                                                ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:145:23: note: to match this '('\n  145 |                 printf(\"%s: read \\\"\", &__func__.7);\n      |                       ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:149:28: error: expected ')'\n  149 |             if (pending_len.8 >= v2)\n      |                            ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:149:16: note: to match this '('\n  149 |             if (pending_len.8 >= v2)\n      |                ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:151:32: error: expected ')'\n  151 |             memcpy(v1, &pending.6, pending_len.8);\n      |                                ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:151:19: note: to match this '('\n  151 |             memcpy(v1, &pending.6, pending_len.8);\n      |                   ^\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:152:29: error: expected ';' after expression\n  152 |             v5 = pending_len.8;\n      |                             ^\n      |                             ;\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:153:24: error: expected ';' after expression\n  153 |             pending_len.8 = 0;\n      |                        ^\n      |                        ;\n/tmp/tmprpc2tk2h/read_assuan_name_conflict.c:153:27: error: expression is not assignable\n  153 |             pending_len.8 = 0;\n      |                        ~~ ^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n20 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static const char *get_var(const char *name) {\n    VARIABLE var;\n    for (var = variable_list; var && strcmp(var->name, name); var = var->next)\n        ;\n    if (!var)\n        return ((void *)0);\n    if (var->type == VARTYPE_COUNTER && var->value) {\n        char *p = var->value + strlen(var->value) + 1;\n        sprintf(p, \"%u\", var->count);\n        return p;\n    } else\n        return var->value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  unsigned int field_8;\n  unsigned int field_c;\n  struct struct_0 *field_10;\n} struct_0;\n\nextern struct_0 *variable_list;\n\nlong long get_var_name_conflict(char *a0) {\n  struct_0 *v1; // rbx, Other Possible Types: unsigned long\n  struct_0 *v2; // rbp\n\n  v1 = variable_list;\n  if (!variable_list)\n    return variable_list;\n  while (strcmp(v1 + 24, a0)) {\n    v1 = *((long long *)v1);\n    if (!v1)\n      return v1;\n  }\n  if (!v1)\n    return v1;\n  if (*((int *)(v1 + 8)) == 2) {\n    v2 = *((long long *)(v1 + 16));\n    if (v2) {\n      sprintf(v1, \"%u\", *((int *)(v1 + 12)));\n      return &v2->padding_0[strlen(v2) + 1];\n    }\n  }\n  v1 = *((long long *)(v1 + 16));\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *expand_line(char *buffer) {\n    char *line = buffer;\n    char *p, *pend;\n    const char *value;\n    size_t valuelen, n;\n    char *result = ((void *)0);\n    while (*line)\n        {\n            p = strchr(line, '$');\n            if (!p)\n                return result;\n            if (p[1] == '$') {\n                memmove(p, p + 1, strlen(p + 1) + 1);\n                line = p + 1;\n                continue;\n            }\n            for (pend = p + 1; *pend && !(*(pend) == ' ' || *(pend) == '\\t') && *pend != '$' && *pend != '/'; pend++)\n                ;\n            if (*pend) {\n                int save = *pend;\n                *pend = 0;\n                value = get_var(p + 1);\n                *pend = save;\n            } else\n                value = get_var(p + 1);\n            if (!value)\n                value = \"\";\n            valuelen = strlen(value);\n            if (valuelen <= pend - p) {\n                memcpy(p, value, valuelen);\n                p += valuelen;\n                n = pend - p;\n                if (n)\n                    memmove(p, p + n, strlen(p + n) + 1);\n                line = p;\n            } else {\n                char *src = result ? result : buffer;\n                char *dst;\n                dst = xmalloc(strlen(src) + valuelen + 1);\n                n = p - src;\n                memcpy(dst, src, n);\n                memcpy(dst + n, value, valuelen);\n                n += valuelen;\n                strcpy(dst + n, pend);\n                line = dst + n;\n                free(result);\n                result = dst;\n            }\n        }\n    return result;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int eval_boolean(const char *cond) {\n    int true = 1;\n    for (; *cond == '!'; cond++)\n        true = !true;\n    if (!*cond || (*cond == '0' && !cond[1]))\n        return !true;\n    return true;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long eval_boolean_name_conflict(char a0[2]) {\n  char v1;          // al\n  unsigned long v2; // edx, Other Possible Types: unsigned int\n\n  v1 = a0[0];\n  if (v1 != 33) {\n    v2 = 1;\n  } else {\n    v2 = 1;\n    do {\n      v2 = (unsigned int)v2 ^ 1;\n      a0 += 1;\n      v1 = *((char *)a0);\n    } while (v1 == 33);\n  }\n  if (v1) {\n    if (v1 != 48) {\n      return v2;\n    } else if (*((char *)(a0 + 1))) {\n      return v2;\n    }\n  }\n  v2 = (unsigned int)v2 ^ 1;\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int interpreter(char *line) {\n    static struct {\n        const char *name;\n        void (*fnc)(const char *, char *);\n    } cmdtbl[] = {{\"let\", cmd_let}, {\"echo\", cmd_echo}, {\"send\", cmd_send}, {\"expect-ok\", cmd_expect_ok}, {\"expect-err\", cmd_expect_err}, {\"count-status\", cmd_count_status}, {\"openfile\", cmd_openfile}, {\"createfile\", cmd_createfile}, {\"pipeserver\", cmd_pipeserver}, {\"quit\", ((void *)0)}, {\"quit-if\", cmd_quit_if}, {\"fail-if\", cmd_fail_if}, {\"cmpfiles\", cmd_cmpfiles}, {\"getenv\", cmd_getenv}, {((void *)0)}};\n    char *p, *save_p;\n    int i, save_c;\n    char *stmt = ((void *)0);\n    char *assign_to = ((void *)0);\n    char *must_free = ((void *)0);\n    for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n        ;\n    if (!*line || *line == '#')\n        return 0;\n    p = expand_line(line);\n    if (p) {\n        must_free = p;\n        line = p;\n        for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n            ;\n        if (!*line || *line == '#') {\n            free(must_free);\n            return 0;\n        }\n    }\n    for (p = line; *p && !(*(p) == ' ' || *(p) == '\\t') && *p != '='; p++)\n        ;\n    if (*p == '=') {\n        *p = 0;\n        assign_to = line;\n    } else if (*p) {\n        for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p == '=')\n            assign_to = line;\n    }\n    if (!*line)\n        (die)(\"%s: syntax error\", __func__);\n    stmt = line;\n    save_c = 0;\n    save_p = ((void *)0);\n    if (assign_to) {\n        for (p++; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (!*p) {\n            unset_var(assign_to);\n            free(must_free);\n            return 0;\n        }\n        stmt = p;\n        for (; *p && !(*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p) {\n            save_p = p;\n            save_c = *p;\n            for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n                ;\n        }\n    }\n    for (i = 0; cmdtbl[i].name && strcmp(stmt, cmdtbl[i].name); i++)\n        ;\n    if (!cmdtbl[i].name) {\n        if (!assign_to)\n            (die)(\"%s: invalid statement '%s'\\n\", __func__, (stmt));\n        if (save_p)\n            *save_p = save_c;\n        set_var(assign_to, stmt);\n        free(must_free);\n        return 0;\n    }\n    if (cmdtbl[i].fnc)\n        cmdtbl[i].fnc(assign_to, p);\n    free(must_free);\n    return cmdtbl[i].fnc ? 0 : 1;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *xstrdup(const char *string) {\n    void *p = malloc(strlen(string) + 1);\n    if (!p)\n        die(\"out of core: %s\", strerror((*__errno_location())));\n    strcpy(p, string);\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\nlong long(die)(...);\n\nlong long xstrdup_name_conflict(char *a0) {\n  char *v1; // rax\n\n  v1 = malloc(strlen(a0) + 1);\n  if (!v1) {\n    strerror(*(__errno_location()));\n    die(); /* do not return */\n  }\n  return strcpy(v1, a0);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpzyqh62hu/xstrdup_name_conflict.c:17:17: error: ISO C requires a named parameter before\n'...' 17 | long long (die)(...); |                 ^\n/tmp/tmpzyqh62hu/xstrdup_name_conflict.c:26:18: error: indirection requires pointer operand\n('int' invalid) 26 |         strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static char *ascii_strupr(char *string) {\n    char *p;\n    for (p = string; *p; p++)\n        if (!(*p & 128))\n            *p = toupper(*p);\n    return string;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(__ctype_toupper_loc)();\n\nlong long ascii_strupr_name_conflict(char *a0) {\n  unsigned long v1; // rbx, Other Possible Types: unsigned long long\n  char *v2;         // rbp, Other Possible Types: unsigned long\n\n  v1 = *(a0);\n  if (!(char)v1)\n    return a0;\n  v2 = a0;\n  do {\n    if ((char)v1 >= 0)\n      *((char *)v2) =\n          *((int *)(*((long long *)&__ctype_toupper_loc()) + (char)v1 * 4));\n  } while ((v2 += 1, v1 = (unsigned long long)(char)*((char *)v2), (char)v1));\n  return a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprmzlnkjt/ascii_strupr_name_conflict.c:30:54: error: cannot take the address of an\nrvalue of type 'char *' 30 |             *((char *)v2) = *((int *)(*((long long\n*)&__ctype_toupper_loc()) + (char)v1 * 4)); | ^~~~~~~~~~~~~~~~~~~~~~ 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"const char *isodatestring(void) {\n    static char buffer[16];\n    struct tm *tp;\n    time_t atime = time(((void *)0));\n    if (atime < 0)\n        strcpy(buffer, \"????-??-??\");\n    else {\n        tp = gmtime(&atime);\n        sprintf(buffer, \"%04d-%02d-%02d\", 1900 + tp->tm_year, tp->tm_mon + 1, tp->tm_mday);\n    }\n    return buffer;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(time)(long *);\nstruct tm *(gmtime)(long *);\n\nextern char buffer.4;\nextern unsigned int g_408157;\n\nlong long isodatestring_name_conflict() {\n  unsigned int v0;    // [bp-0x10]\n  unsigned int v2[6]; // rax\n\n  *((long *)&v0) = time(NULL);\n  if (*((long long *)&v0) < 0) {\n    strncpy(&buffer.4, \"????-??-\", 8);\n    g_408157 = 4144941;\n    return &buffer.4;\n  }\n  v2 = gmtime(&v0);\n  sprintf(&buffer.4, \"%04d-%02d-%02d\", v2[5] + 1900, v2[4] + 1, v2[3]);\n  return &buffer.4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptbzhdl7k/isodatestring_name_conflict.c:19:19: error: expected ';' after top level\ndeclarator 19 | extern char buffer.4; |                   ^ | ;\n/tmp/tmptbzhdl7k/isodatestring_name_conflict.c:30:24: error: expected ')'\n   30 |         strncpy(&buffer.4, \"????-??-\", 8);\n      |                        ^\n/tmp/tmptbzhdl7k/isodatestring_name_conflict.c:30:16: note: to match this '('\n   30 |         strncpy(&buffer.4, \"????-??-\", 8);\n      |                ^\n/tmp/tmptbzhdl7k/isodatestring_name_conflict.c:32:23: error: expected ';' after return\nstatement 32 |         return &buffer.4; |                       ^ | ;\n/tmp/tmptbzhdl7k/isodatestring_name_conflict.c:34:8: error: array type 'unsigned int[6]' is\nnot assignable 34 |     v2 = gmtime(&v0); |     ~~ ^\n/tmp/tmptbzhdl7k/isodatestring_name_conflict.c:35:20: error: expected ')'\n   35 |     sprintf(&buffer.4, \"%04d-%02d-%02d\", v2[5] + 1900, v2[4] + 1,\nv2[3]); |                    ^ /tmp/tmptbzhdl7k/isodatestring_name_conflict.c:35:12: note: to\nmatch this '(' 35 |     sprintf(&buffer.4, \"%04d-%02d-%02d\", v2[5] + 1900, v2[4]\n+ 1, v2[3]); |            ^ /tmp/tmptbzhdl7k/isodatestring_name_conflict.c:36:19: error:\nexpected ';' after return statement 36 |     return &buffer.4; | ^ | ; 6 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static int is_standard_section(const char *name) {\n    int i;\n    const char *s;\n    for (i = 0; (s = standard_sections[i]); i++)\n        if (!strcmp(s, name))\n            return 1;\n    return 0;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":1,"function":"static const char *pcsc_error_string(long err) {\n    const char *s;\n    if (!err)\n        return \"okay\";\n    if ((err & 2148532224U) != 2148532224U)\n        return \"invalid PC/SC error code\";\n    err &= 65535;\n    switch (err) {\n      case 2:\n        s = \"cancelled\";\n        break;\n      case 14:\n        s = \"can't dispose\";\n        break;\n      case 8:\n        s = \"insufficient buffer\";\n        break;\n      case 21:\n        s = \"invalid ATR\";\n        break;\n      case 3:\n        s = \"invalid handle\";\n        break;\n      case 4:\n        s = \"invalid parameter\";\n        break;\n      case 5:\n        s = \"invalid target\";\n        break;\n      case 17:\n        s = \"invalid value\";\n        break;\n      case 6:\n        s = \"no memory\";\n        break;\n      case 19:\n        s = \"comm error\";\n        break;\n      case 1:\n        s = \"internal error\";\n        break;\n      case 20:\n        s = \"unknown error\";\n        break;\n      case 7:\n        s = \"waited too long\";\n        break;\n      case 9:\n        s = \"unknown reader\";\n        break;\n      case 10:\n        s = \"timeout\";\n        break;\n      case 11:\n        s = \"sharing violation\";\n        break;\n      case 12:\n        s = \"no smartcard\";\n        break;\n      case 13:\n        s = \"unknown card\";\n        break;\n      case 15:\n        s = \"proto mismatch\";\n        break;\n      case 16:\n        s = \"not ready\";\n        break;\n      case 18:\n        s = \"system cancelled\";\n        break;\n      case 22:\n        s = \"not transacted\";\n        break;\n      case 23:\n        s = \"reader unavailable\";\n        break;\n      case 101:\n        s = \"unsupported card\";\n        break;\n      case 102:\n        s = \"unresponsive card\";\n        break;\n      case 103:\n        s = \"unpowered card\";\n        break;\n      case 104:\n        s = \"reset card\";\n        break;\n      case 105:\n        s = \"removed card\";\n        break;\n      case 106:\n        s = \"inserted card\";\n        break;\n      case 31:\n        s = \"unsupported feature\";\n        break;\n      case 25:\n        s = \"PCI too small\";\n        break;\n      case 26:\n        s = \"reader unsupported\";\n        break;\n      case 27:\n        s = \"duplicate reader\";\n        break;\n      case 28:\n        s = \"card unsupported\";\n        break;\n      case 29:\n        s = \"no service\";\n        break;\n      case 30:\n        s = \"service stopped\";\n        break;\n      default:\n        s = \"unknown PC/SC error code\";\n        break;\n    }\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pcsc_error_string_name_conflict(unsigned long a0) {\n  if (!a0) {\n    return \"okay\";\n  } else if (((unsigned int)a0 & 0x80100000) != 0x80100000) {\n    return \"invalid PC/SC error code\";\n  } else {\n    switch ((unsigned short)a0 << 48) {\n    case 1:\n      return \"internal error\";\n    case 2:\n      return \"cancelled\";\n    case 3:\n      return \"invalid handle\";\n    case 4:\n      return \"invalid parameter\";\n    case 5:\n      return \"invalid target\";\n    case 6:\n      return \"no memory\";\n    case 7:\n      return \"waited too long\";\n    case 8:\n      return \"insufficient buffer\";\n    case 9:\n      return \"unknown reader\";\n    case 10:\n      return \"timeout\";\n    case 11:\n      return \"sharing violation\";\n    case 12:\n      return \"no smartcard\";\n    case 13:\n      return \"unknown card\";\n    case 14:\n      return \"can't dispose\";\n    case 15:\n      return \"proto mismatch\";\n    case 16:\n      return \"not ready\";\n    case 17:\n      return \"invalid value\";\n    case 18:\n      return \"system cancelled\";\n    case 19:\n      return \"comm error\";\n    case 20:\n      return \"unknown error\";\n    case 21:\n      return \"invalid ATR\";\n    case 22:\n      return \"not transacted\";\n    case 23:\n      return \"reader unavailable\";\n    case 25:\n      return \"PCI too small\";\n    case 26:\n      return \"reader unsupported\";\n    case 27:\n      return \"duplicate reader\";\n    case 28:\n      return \"card unsupported\";\n    case 29:\n      return \"no service\";\n    case 30:\n      return \"service stopped\";\n    case 31:\n      return \"unsupported feature\";\n    case 101:\n      return \"unsupported card\";\n    case 102:\n      return \"unresponsive card\";\n    case 103:\n      return \"unpowered card\";\n    case 104:\n      return \"reset card\";\n    case 105:\n      return \"removed card\";\n    case 106:\n      return \"inserted card\";\n    default:\n      return \"unknown PC/SC error code\";\n    }\n  }\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/scd/pcsc-wrapper.c"}
{"compilable":1,"function":"static unsigned int convert_le_u32(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long convert_le_u32_name_conflict(char a0[4]) {\n  return a0[1] * 0x100 | a0[2] * 0x10000 | a0[0] | a0[3] * 0x1000000;\n}\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"static unsigned int convert_le_u16(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8);\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_version_name_conflict() { return 131074; }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_wrapper_enabled_name_conflict(unsigned long a0) {\n  return (unsigned int)a0 == 4;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pl_supported_resources_dummy)();\n\nlong long libplayer_wrapper_supported_res_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 == 4)\n    return pl_supported_resources_dummy();\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pl_supported_resources_dummy_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mrl_metadata_dvd_title_new_name_conflict() { return calloc(1, 24); }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    if (!n)\n        return 0;\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(tcgetattr)(\n    int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nint(tcsetattr)(\n    int, int, struct termios {\n      unsigned long c_iflag;\n      unsigned long c_oflag;\n      unsigned long c_cflag;\n      unsigned long c_lflag;\n      char c_cc[20];\n      long __ispeed;\n      long __ospeed;\n    } *);\nlong(read)(int, void *, unsigned long);\nint(putc)(\n    int, struct FILE_t {\n      int _flags;\n      char *_IO_read_ptr;\n      char *_IO_read_end;\n      char *_IO_read_base;\n      char *_IO_write_base;\n      char *_IO_write_ptr;\n      char *_IO_write_end;\n      char *_IO_buf_base;\n      char *_IO_buf_end;\n      char *_IO_save_base;\n      char *_IO_backup_base;\n      char *_IO_save_end;\n      struct _IO_marker {\n        struct _IO_marker {\n\n        } *_next;\n        struct FILE {\n\n        } *_sbuf;\n        int _pos;\n      } *_markers;\n      struct _IO_FILE {\n\n      } *_chain;\n      int _fileno;\n      int _flags2;\n      long _old_offset;\n      unsigned short _cur_column;\n      char _vtable_offset;\n      char _shortbuf[1];\n      struct pthread_mutex_t {\n\n      } *_lock;\n      long long _offset;\n      struct _IO_codecvt {\n        struct _IO_iconv_t {\n\n        } __cd_in;\n        struct _IO_iconv_t {\n\n        } __cd_out;\n      } *_codecvt;\n      struct _IO_wide_data {\n        short *_IO_read_ptr;\n        short *_IO_read_end;\n        short *_IO_read_base;\n        short *_IO_write_base;\n        short *_IO_write_ptr;\n        short *_IO_write_end;\n        short *_IO_buf_base;\n        short *_IO_buf_end;\n        short *_IO_save_base;\n        short *_IO_backup_base;\n        short *_IO_save_end;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_state;\n        struct __mbstate_t {\n          int __count;\n          union<anon> {\n            unsigned int __wch;\n            char __wchb[4];\n          } __value;\n        } _IO_last_state;\n        struct _IO_codecvt {\n          struct _IO_iconv_t {\n\n          } __cd_in;\n          struct _IO_iconv_t {\n\n          } __cd_out;\n        } _codecvt;\n        short _shortbuf[1];\n        struct _IO_jump_t {\n\n        } _wide_vtable;\n      } *_wide_data;\n      struct _IO_FILE {\n\n      } *_freeres_list;\n      unsigned long __pad5;\n      int _mode;\n      char _unused2[20];\n    } *);\n\ntypedef struct termios {\n  unsigned int c_iflag;\n  char padding_4[4];\n  unsigned int c_oflag;\n  char padding_c[4];\n  unsigned int c_cflag;\n  char padding_14[4];\n  unsigned int c_lflag;\n  char padding_1c[4];\n  char c_cc[20];\n  char padding_34[4];\n  unsigned int __ispeed;\n  char padding_3c[4];\n  unsigned int __ospeed;\n} termios;\n\nextern FILE_t *stdout @GLIBC_2.2.5;\n\nlong long getch_name_conflict() {\n  unsigned int v0; // [bp-0x8c]\n  termios v1;      // [bp-0x88]\n  unsigned int v2; // [bp-0x7c]\n  int v3;          // [bp-0x78]\n  int v4;          // [bp-0x68]\n  int v5;          // [bp-0x5c]\n  termios v6;      // [bp-0x48]\n  char v7;         // [bp-0x38]\n  char v8;         // [bp-0x28]\n  int v9;          // [bp-0x1c]\n  void *v11; // rbx, Other Possible Types: unsigned long, unsigned long long\n  unsigned long v12; // rax, Other Possible Types: unsigned long long\n\n  v0 = 0;\n  tcgetattr(0, &v6);\n  *((int128_t *)&v1.c_iflag) = *((int128_t *)&v6.c_iflag);\n  *((int128_t *)&v3) = *((int128_t *)&v7);\n  *((int128_t *)&v4) = *((int128_t *)&v8);\n  *((int128_t *)&v5) = (int128_t)v9;\n  *((char[4]) & v2) = v1.padding_c & -11;\n  tcsetattr(0, 0, &v1);\n  v11 = 0;\n  if (!(int)read(0, &v0, 4))\n    return 0;\n  putc(10, stdout @GLIBC_2.2.5);\n  v12 = v0;\n  if (!(unsigned int)v12) {\n    v11 = v12;\n  } else {\n    do {\n      v11 = (unsigned int)v11 * 0x100 + (char)v12;\n      v12 /= 0x100;\n    } while ((unsigned int)v12);\n    v0 = 0;\n  }\n  tcsetattr(0, 0, &v6);\n  return v11;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpc92qiik9/getch_name_conflict.c:54:16: error: nested redefinition of '_IO_marker'\n   54 |         struct _IO_marker {\n      |                ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:53:12: note: previous definition is here\n   53 |     struct _IO_marker {\n      |            ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:97:13: error: declaration of anonymous union must be a\ndefinition 97 |             union <anon> { |             ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:100:22: error: type name requires a specifier or\nqualifier 100 |             } __value; |                      ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:104:13: error: declaration of anonymous union must be a\ndefinition 104 |             union <anon> { |             ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:107:22: error: type name requires a specifier or\nqualifier 107 |             } __value; |                      ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:40:6: error: conflicting types for 'putc'\n   40 | int (putc)(int, struct FILE_t {\n      |      ^\n/usr/include/stdio.h:550:12: note: previous declaration is here\n  550 | extern int putc (int __c, FILE *__stream);\n      |            ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:146:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 146 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:146:22: error: expected ';' after top level declarator\n  146 | extern FILE_t *stdout@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmpc92qiik9/getch_name_conflict.c:165:18: error: expected expression\n  165 |     *((int128_t *)&v1.c_iflag) = *((int128_t *)&v6.c_iflag);\n      |                  ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:165:47: error: expected expression\n  165 |     *((int128_t *)&v1.c_iflag) = *((int128_t *)&v6.c_iflag);\n      |                                               ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:166:18: error: expected expression\n  166 |     *((int128_t *)&v3) = *((int128_t *)&v7);\n      |                  ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:166:39: error: expected expression\n  166 |     *((int128_t *)&v3) = *((int128_t *)&v7);\n      |                                       ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:167:18: error: expected expression\n  167 |     *((int128_t *)&v4) = *((int128_t *)&v8);\n      |                  ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:167:39: error: expected expression\n  167 |     *((int128_t *)&v4) = *((int128_t *)&v8);\n      |                                       ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:168:18: error: expected expression\n  168 |     *((int128_t *)&v5) = (int128_t)v9;\n      |                  ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:169:7: error: used type 'char[4]' where arithmetic or\npointer type is required 169 |     *((char [4])&v2) = v1.padding_c & -11; | ^\n~~~ /tmp/tmpc92qiik9/getch_name_conflict.c:169:37: error: invalid operands to binary\nexpression ('char[4]' and 'int') 169 |     *((char [4])&v2) = v1.padding_c &\n-11; |                        ~~~~~~~~~~~~ ^ ~~~\n/tmp/tmpc92qiik9/getch_name_conflict.c:174:20: error: expected ')'\n  174 |     putc(10, stdout@GLIBC_2.2.5);\n      |                    ^\n/tmp/tmpc92qiik9/getch_name_conflict.c:174:9: note: to match this '('\n  174 |     putc(10, stdout@GLIBC_2.2.5);\n      |         ^\n18 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-test.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_version_name_conflict() { return 131074; }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long libplayer_wrapper_enabled_name_conflict(unsigned long a0) {\n  return (unsigned int)a0 == 4;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(pl_supported_resources_dummy)();\n\nlong long libplayer_wrapper_supported_res_name_conflict(unsigned long a0, unsigned long a1) {\n  if ((unsigned int)a0 == 4)\n    return pl_supported_resources_dummy();\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long pl_supported_resources_dummy_name_conflict() { return 1; }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long mrl_metadata_dvd_title_new_name_conflict() { return calloc(1, 24); }\n","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-testvdr.c"}
{"compilable":0,"function":"int f(int u, int v) {\n    if (v > 0)\n        return 5 * u + 3 * v;\n    return u;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef_name_conflict unsigned int BOT;\ntypedef_name_conflict unsigned int uint;\ntypedef_name_conflict unsigned long ulong;\n\nlong long f_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  v1 = a0;\n  if_name_conflict ((unsigned int)a1 > 0)\n    v1 = a0 * 5 + a1 * 3;\n  return v1;\n}\n","pass":0,"source_file":"C_COMPILE/andrewburger_c-and-c-plus-plus/hw9f02.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  unsigned long v2; // rcx, Other Possible Types: unsigned long long\n  char *v4;         // rax\n\n  for (v2 = 1; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 0x100) * 19342813113834067 >> 64 >> 11) * 0x1dcd6500;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 << 4) + 8)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_6o8nbkb/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmp_6o8nbkb/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmp_6o8nbkb/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500; | ~~~~~~ ^  ~\n/tmp/tmp_6o8nbkb/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmp_6o8nbkb/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[2]; // rbx\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = *((long long *)&vocab_size) * 16 + vocab;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (60 < (unsigned int)v2)\n    v2 = 60;\n  v3 = calloc(v2, 1);\n  v1[1] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 10000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 16);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 8) * 18014399 >> 45) * 0x1dcd6500;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1fsc0i33/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[2]' is not assignable 33 |     v1 = *((long long *)&vocab_size) * 16 +\nvocab; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":0,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\nint rax; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long GetWordHash_name_conflict(char *a0) {\n  void *v2; // rcx, Other Possible Types: unsigned long\n  char *v4; // rax\n\n  for (v2 = 0; rax != &a0[strlen(a0)]; v4 = rax + 1) {\n    v2 = v2 + v2 * 0x100 + *((char *)rax);\n  }\n  return v2 - ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppyy7qv92/GetWordHash_name_conflict.c:27:22: error: invalid operands to binary\nexpression ('void *' and 'int') 27 |         v2 = v2 + v2 * 0x100 + *((char\n*)rax); |                   ~~ ^ ~~~~~ /tmp/tmppyy7qv92/GetWordHash_name_conflict.c:29:22:\nerror: invalid operands to binary expression ('void *' and 'int') 29 | return v2\n- ((v2 / 128) * 161190109281950557 >> 64 >> 11) * 30000000; | ~~ ^ ~~~ 2 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\n\nextern unsigned long long vocab;\nextern unsigned long long vocab_hash;\n\nlong long SearchVocab_name_conflict(char *a0) {\n  unsigned int *v1; // rax\n  unsigned int *v2; // rbx, Other Possible Types: unsigned long\n  unsigned int *v3; // rax\n  unsigned long v4; // r14, Other Possible Types: unsigned long long\n\n  v1 = GetWordHash(a0);\n  v2 = v1;\n  v4 = *((int *)(vocab_hash + v1 * 4));\n  if ((unsigned int)v4 == -1)\n    return *((int *)(vocab_hash + v1 * 4));\n  while (strcmp(a0, *((long long *)(vocab + (v4 + (v4 << 2) << 3) + 16)))) {\n    v3 = v2 + 1 - (unsigned int)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000;\n    v2 = v3;\n    v4 = *((int *)(vocab_hash + v3 * 4));\n    if ((unsigned int)v4 == -1)\n      return *((int *)(vocab_hash + v3 * 4));\n  }\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfsfjac_v/SearchVocab_name_conflict.c:30:36: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 30 |     v4 = *((int *)(vocab_hash + v1\n* 4)); |                                 ~~ ^ ~\n/tmp/tmpfsfjac_v/SearchVocab_name_conflict.c:32:42: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 32 |         return *((int *)(vocab_hash\n+ v1 * 4)); |                                       ~~ ^ ~\n/tmp/tmpfsfjac_v/SearchVocab_name_conflict.c:35:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 35 |         v3 = v2 + 1 - (unsigned\nint)((v2 + 1 >> 7) * 18764999 >> 42) * 30000000; | ~~~~~~ ^  ~\n/tmp/tmpfsfjac_v/SearchVocab_name_conflict.c:37:40: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 37 |         v4 = *((int *)(vocab_hash +\nv3 * 4)); |                                     ~~ ^ ~\n/tmp/tmpfsfjac_v/SearchVocab_name_conflict.c:39:46: error: invalid operands to binary\nexpression ('unsigned int *' and 'int') 39 |             return *((int\n*)(vocab_hash + v3 * 4)); |                                           ~~ ^ ~ 5\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(GetWordHash)(long long);\nvoid *(realloc)(void *, unsigned long);\n\nextern void *vocab;\nextern unsigned long long vocab_hash;\nextern unsigned int vocab_max_size;\nextern unsigned int vocab_size;\n\nlong long AddWordToVocab_name_conflict(char *a0) {\n  unsigned long long v1[3]; // rbp\n  unsigned long v2;         // rax, Other Possible Types: unsigned long long\n  char *v3;                 // rax\n  unsigned long long v4;    // rax\n  unsigned long v5;         // rax, Other Possible Types: unsigned long long\n  unsigned int *v6;         // rdx, Other Possible Types: unsigned long\n\n  v1 = vocab + *((long long *)&vocab_size) * 40;\n  v2 = (unsigned int)strlen(a0) + 1;\n  if (100 < (unsigned int)v2)\n    v2 = 100;\n  v3 = calloc(v2, 1);\n  v1[2] = v3;\n  strcpy(v3, a0);\n  v1[0] = 0;\n  v4 = *((long long *)&vocab_size);\n  *((long long *)&vocab_size) = *((long long *)&vocab_size) + 1;\n  if (v4 + 3 >= *((long long *)&vocab_max_size)) {\n    *((long long *)&vocab_max_size) = *((long long *)&vocab_max_size) + 1000;\n    vocab = realloc(vocab, *((long long *)&vocab_max_size) * 40);\n  }\n  v5 = GetWordHash(a0);\n  v6 = vocab_hash + v5 * 4;\n  if (*(v6) != -1) {\n    do {\n      v5 = v5 + 1 - (unsigned int)((v5 + 1 >> 7) * 18764999 >> 42) * 30000000;\n      v6 = vocab_hash + v5 * 4;\n    } while (*((int *)v6) != -1);\n  }\n  *((unsigned int *)v6) = vocab_size - 1;\n  return vocab_size - 1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbsd3r_ax/AddWordToVocab_name_conflict.c:33:8: error: array type 'unsigned long\nlong[3]' is not assignable 33 |     v1 = vocab + *((long long *)&vocab_size) *\n40; |     ~~ ^ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ArgPos_name_conflict(char *a0, unsigned long a1, char *a2[2]) {\n  unsigned long v0;  // [bp-0x28]\n  unsigned long v1;  // [bp-0x20]\n  unsigned long v2;  // [bp-0x18]\n  unsigned long v3;  // [bp-0x10]\n  unsigned long v4;  // [bp-0x8]\n  unsigned long v6;  // r14\n  unsigned long v7;  // r13\n  unsigned long v8;  // r12\n  unsigned long v9;  // rbx\n  unsigned long v10; // rbx, Other Possible Types: unsigned long long\n\n  if ((unsigned int)a1 <= 1)\n    return 4294967295;\n  v4 = v6;\n  v3 = v7;\n  v2 = v8;\n  *((int *)&v1) = rbp;\n  v0 = v9;\n  v10 = 1;\n  while (strcmp(a0, a2[v10])) {\n    v10 += 1;\n    if (v10 == a1)\n      return 4294967295;\n  }\n  if ((unsigned int)a1 - 1 == (unsigned int)v10) {\n    printf(\"Argument missing for %s\\n\", (unsigned int)a0);\n    exit(1); /* do not return */\n  }\n  return v10;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"WinMsgTokState *wmtok_init(WinMsgTokState *st) {\n    if (st == ((void *)0)) {\n        st = malloc(sizeof(WinMsgTokState));\n        st->_dofree = 1;\n    }\n    return st;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[1];\n  char field_1;\n} struct_0;\n\nlong long wmtok_init_name_conflict(unsigned long a0) {\n  struct_0 *v1; // rax\n\n  if (!a0) {\n    v1 = malloc(2);\n    v1->field_1 = 1;\n    return v1;\n  }\n  return a0;\n}\n","pass":0,"source_file":"C_COMPILE/swegener_screen/src/winmsgtok.c"}
{"compilable":0,"function":"int parsemac(char *str, unsigned char *mac) {\n    char *s;\n    while ((s = strsep(&str, \":\")) != ((void *)0))\n        {\n            unsigned int byte;\n            if (sscanf(s, \"%x\", &byte) != 1 || byte > 255)\n                return -1;\n            *mac++ = byte;\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strsep)(char **, char *);\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long parsemac_name_conflict(unsigned long a0, struct_0 *a1) {\n  char *v0;              // [bp-0x40]\n  char v1;               // [bp-0x2c]\n  struct_0 *v3;          // rbx, Other Possible Types: unsigned long\n  char *v4;              // rax\n  unsigned long long v5; // rax\n\n  v0 = a0;\n  v3 = a1;\n  while (true) {\n    v4 = strsep(&v0, \":\");\n    if (!v4)\n      return 0;\n    if (!(__isoc99_sscanf(v4, \"%x\", (unsigned int)&v1) == 1) ||\n        !((v5 = (unsigned long long)(unsigned int)*((int *)&v1),\n           (unsigned int)v5 <= 255)))\n      break;\n    v3 += 1;\n    *((char *)(v3 - 1)) = v5;\n  }\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpnadn2frr/parsemac_name_conflict.c:20:16: error: expected ';' at end of declaration\nlist 20 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int setname(char *oldname, char *newname) {\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, oldname);\n    strcpy(ifr.ifr_ifru.ifru_newname, newname);\n    return ioctl(ctl_sk, 35107, &ifr);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(opensock)();\n\nextern unsigned int ctl_sk;\n\nlong long setname_name_conflict(char *a0, char *a1) {\n  char v0;  // [bp-0x48]\n  char v1;  // [bp-0x38]\n  void *v2; // [bp-0x28]\n\n  opensock();\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v1) = 0;\n  v2 = 0;\n  strcpy(&v0, a0);\n  strcpy(&v1, a1);\n  return ioctl(ctl_sk, 35107);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp5shw3_px/setname_name_conflict.c:29:18: error: expected expression\n   29 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmp5shw3_px/setname_name_conflict.c:30:18: error: expected expression\n   30 |     *((int128_t *)&v1) = 0;\n      |                  ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int getmac(char *name, unsigned char *mac) {\n    int r;\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, name);\n    r = ioctl(ctl_sk, 35111, &ifr);\n    memcpy(mac, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    return r;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint int128_t; // add global variable by heuristics\nint int128_t; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(opensock)();\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned short field_4;\n} struct_0;\n\nextern unsigned int ctl_sk;\n\nlong long getmac_name_conflict(char *a0, struct_0 *a1) {\n  char v0;  // [bp-0x48]\n  int v1;   // [bp-0x38]\n  void *v2; // [bp-0x28]\n\n  opensock();\n  *((int128_t *)&v0) = 0;\n  *((int128_t *)&v1) = 0;\n  v2 = 0;\n  strcpy(&v0, a0);\n  a1->field_0 = (int)(&v1)[2];\n  a1->field_4 = (short)(&v1)[6];\n  return ioctl(ctl_sk, 35111);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8uou1qpo/getmac_name_conflict.c:34:18: error: expected expression\n   34 |     *((int128_t *)&v0) = 0;\n      |                  ^\n/tmp/tmp8uou1qpo/getmac_name_conflict.c:35:18: error: expected expression\n   35 |     *((int128_t *)&v1) = 0;\n      |                  ^\n2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"char *MakeCRC(char *BitString) {\n    static char Res[6];\n    char CRC[5];\n    int i;\n    char DoInvert;\n    for (i = 0; i < 5; ++i)\n        CRC[i] = 0;\n    for (i = 0; i < strlen(BitString); ++i) {\n        DoInvert = ('1' == BitString[i]) ^ CRC[4];\n        printf(\"%i %i %i\\t\", i, ('1' == BitString[i]), DoInvert);\n        CRC[4] = CRC[3];\n        CRC[3] = CRC[2];\n        CRC[2] = CRC[1] ^ DoInvert;\n        CRC[1] = CRC[0];\n        CRC[0] = DoInvert;\n        printf(\"%i %i %i %i %i\\n\", CRC[0], CRC[1], CRC[2], CRC[3], CRC[4]);\n    }\n    for (i = 0; i < 5; ++i)\n        Res[4 - i] = CRC[i] ? '1' : '0';\n    Res[5] = 0;\n    return (Res);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint bpl; // add global variable by heuristics\nint bpl; // add global variable by heuristics\nint bpl; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\ntypedef struct struct_1 {\n  char padding_0[4];\n  char field_4;\n} struct_1;\n\nextern struct_1 Res.0;\nextern char g_40401c;\nextern char g_404026;\n\nlong long MakeCRC_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  char v0;         // [bp-0x3d]\n  int tmp_4;       // tmp #4\n  char v1;         // [bp-0x3c]\n  char v2;         // [bp-0x3b]\n  char v3;         // [bp-0x3a]\n  char v4;         // [bp-0x39]\n  char *v6;        // rbx, Other Possible Types: unsigned long\n  unsigned int v7; // r12d\n  struct_1 *v9;    // rax, Other Possible Types: unsigned long\n  struct_0 *v10;   // rcx, Other Possible Types: unsigned long\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  for (v6 = 0; v6 < strlen(a0); v6 += 1) {\n    v7 = *((char *)(a0 + v6)) == 49 ^ v4;\n    printf(\"%i %i %i\\t\", (unsigned int)v6, *((char *)(a0 + v6)) == 49, v7);\n    v4 = v3;\n    v3 = v2;\n    tmp_4 = bpl<1> ^ v1;\n    *((int *)&v2) = bpl<1> ^ v1;\n    v1 = v0;\n    *((int *)&v0) = bpl<1>;\n    printf(\"%i %i %i %i %i\\n\", v7, v1, tmp_4, v3, v4);\n  }\n  v10 = &v0;\n  v9 = &Res.0.padding_0 [0];\n  do {\n    *((char *)(v9 + 4)) = 49 - (*((char *)v10) < 1);\n    v10 = &v1;\n    v9 -= 1;\n  } while (v9 != 4210716);\n  g_404026 = 0;\n  return &Res.0.padding_0 [0];\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:29:20: error: expected ';' after top level declarator\n   29 | extern struct_1 Res.0;\n      |                    ^\n      |                    ;\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:57:26: error: type name requires a specifier or\nqualifier 57 |         tmp_4 = bpl<1> ^ v1; |                          ^\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:57:26: error: expected expression\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:58:34: error: type name requires a specifier or\nqualifier 58 |         *((int *)&v2) = bpl<1> ^ v1; | ^\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:58:34: error: expected expression\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:60:31: error: expected expression\n   60 |         *((int *)&v0) = bpl<1>;\n      |                               ^\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:64:14: error: expected ';' after expression\n   64 |     v9 = &Res.0.padding_0[0];\n      |              ^\n      |              ;\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:64:16: error: invalid suffix '.padding_0' on floating\nconstant 64 |     v9 = &Res.0.padding_0[0]; |                ^\n/tmp/tmpoxnnvs35/MakeCRC_name_conflict.c:72:16: error: expected ';' after return statement\n   72 |     return &Res.0.padding_0[0];\n      |                ^\n      |                ;\n9 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/aeburriel_tetrapol-kit/misc/crc.c"}
{"compilable":0,"function":"uint8_t ReadUint8(void) {\n    uint8_t temp;\n    int data_read = read(0, &temp, 1);\n    if (data_read != 1) {\n        exit(-1);\n    }\n    return temp;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\n\nlong long ReadUint8_name_conflict() {\n  char v0; // [bp-0x9]\n\n  if ((int)read(0, &v0, 1) != 1)\n    exit(-1); /* do not return */\n  return v0;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint8_t IntToHexChar(uint8_t val) {\n    if (val < 10)\n        return '0' + val;\n    else\n        return 'a' + (val - 10);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long IntToHexChar_name_conflict(unsigned long a0) {\n  if ((char)a0 > 9)\n    return a0 + 87;\n  return a0 + 48;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"char *ConvertDataBytes(char *pszData, uint8_t foodTotal, uint8_t maxConvert) {\n    uint32_t outIdx = 0;\n    uint32_t i;\n    int bTruncated = 0;\n    if (foodTotal > maxConvert) {\n        bTruncated = 1;\n        foodTotal = maxConvert;\n    }\n    for (i = 0; i < maxConvert; i++) {\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i] >> 4) & 15);\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i]) & 15);\n    }\n    g_displayFoodString[outIdx] = '\\x00';\n    if (bTruncated)\n        strcpy(g_displayFoodString + outIdx, \"...\");\n    return g_displayFoodString;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(IntToHexChar)(long long);\n\nextern char g_4040c1[1];\nextern char g_displayFoodString;\n\nlong long ConvertDataBytes_name_conflict(char *a0, unsigned long a1, unsigned long a2) {\n  unsigned long v1; // r14\n  char *v2;         // rbx, Other Possible Types: unsigned long\n  char v3[1];       // rbp, Other Possible Types: unsigned long\n  char *v4;         // r14, Other Possible Types: unsigned long\n\n  if (!(char)a2) {\n    v4 = 0;\n  } else {\n    v1 = (char)a2;\n    v2 = a0;\n    v3 = &g_4040c1[0];\n    do {\n      *((char *)(v3 - 1)) = IntToHexChar(*((char *)v2) >> 4);\n      *((char *)v3) = IntToHexChar(*((char *)v2) & 15);\n      v2 += 1;\n      v3 += 2;\n    } while (v2 != &a0[1 + v1 + 1]);\n    v4 = (unsigned int)v1 * 2;\n  }\n  (&g_displayFoodString)[v4] = 0;\n  if (a2 < a1)\n    *((int *)&(&g_displayFoodString)[v4]) = 3026478;\n  return &g_displayFoodString;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpva2fhebq/ConvertDataBytes_name_conflict.c:36:12: error: array type 'char[1]' is not\nassignable 36 |         v3 = &g_4040c1[0]; |         ~~ ^\n/tmp/tmpva2fhebq/ConvertDataBytes_name_conflict.c:42:16: error: invalid operands to binary\nexpression ('char[1]' and 'int') 42 |             v3 += 2; |             ~~ ^  ~\n/tmp/tmpva2fhebq/ConvertDataBytes_name_conflict.c:46:27: error: array subscript is not an\ninteger 46 |     (&g_displayFoodString)[v4] = 0; |                           ^~~\n/tmp/tmpva2fhebq/ConvertDataBytes_name_conflict.c:48:41: error: array subscript is not an\ninteger 48 |         *((int *)&(&g_displayFoodString)[v4]) = 3026478; | ^~~ 4\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"uint8_t GetFood(void) {\n    char szEchoData[32];\n    uint8_t foodTotal;\n    printf(\"FEED ME!\\n\");\n    foodTotal = ReadUint8();\n    ReadData(szEchoData, foodTotal);\n    printf(\"ATE %s\\n\", ConvertDataBytes(szEchoData, foodTotal, 16));\n    return foodTotal;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ReadUint8)();\nlong long(ReadData)(long long, long long);\nlong long(ConvertDataBytes)(long long, long long, long long);\n\nlong long GetFood_name_conflict() {\n  char v0;               // [bp-0x38]\n  unsigned long long v2; // rax\n  unsigned long long v3; // r12\n\n  puts(\"FEED ME!\");\n  v2 = ReadUint8();\n  v3 = (char)v2;\n  ReadData(&v0, v3);\n  printf(\"ATE %s\\n\", (int)ConvertDataBytes(&v0, v3, 16));\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint64_t exp_l(uint64_t base, uint64_t power) {\n    int i = 0;\n    uint64_t j = base;\n    if (power == 0) {\n        return 1;\n    }\n    for (i = 0; i < power - 1; i++) {\n        j *= base;\n    }\n    return j;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long exp_l_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1; // rdx\n\n  if (!a1) {\n    return 1;\n  } else if (a1 == 1) {\n    return a0;\n  } else {\n    v1 = a0;\n    do {\n      v1 = a0 * v1;\n    } while ((unsigned int)a1 - 1 != 1);\n    return v1;\n  }\n}\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t xor(uint64_t a, uint64_t b) {\n    return a ^ b;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long xor_name_conflict (unsigned long a0, unsigned long a1) { return a0 ^ a1; }\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t shla(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    high = a << dabits;\n    low = a >> (64 - dabits);\n    return high | low;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shla_name_conflict(unsigned long a0, unsigned long a1) {\n  return (((char)a1 & 63 & 63)\n              ? a0 << ((char)a1 & 63 & 63) | a0 >> 64 - ((char)a1 & 63 & 63)\n              : a0 << ((char)a1 & 63 & 63) | a0 >> 64 - ((char)a1 & 63 & 63));\n}\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t shra(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    low = a >> dabits;\n    high = a << (64 - dabits);\n    return high | low;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long shra_name_conflict(unsigned long a0, unsigned long a1) {\n  return (((char)a1 & 63 & 63)\n              ? a0 >> ((char)a1 & 63 & 63) | a0 << 64 - ((char)a1 & 63 & 63)\n              : a0 >> ((char)a1 & 63 & 63) | a0 << 64 - ((char)a1 & 63 & 63));\n}\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t swap_bytes(uint64_t value) {\n    uint64_t final = 0;\n    final |= ((value & 255) << 24);\n    final |= ((value & 65280) << 24);\n    final |= ((value & 16711680) << 40);\n    final |= ((value & 4278190080U) << 16);\n    final |= ((value & 1095216660480L) >> 16);\n    final |= ((value & 280375465082880L) >> 40);\n    final |= ((value & 71776119061217280L) >> 40);\n    final |= ((value & 18374686479671623680UL) >> 8);\n    return final;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long swap_bytes_name_conflict(unsigned long a0) {\n  return a0 / 0x100 & 0xff000000000000 |\n         (unsigned int)a0 / 0x10000000000 & 0xff00 |\n         (unsigned int)a0 / 0x10000 & 0xff0000 | a0 * 0x10000 & 0xff0000000000 |\n         a0 * 0x10000000000 & -0x100000000000000 |\n         a0 * 0x1000000 & 1099511627775 | a0 / 0x10000000000;\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t swap_two(uint64_t value, uint64_t one, uint64_t two) {\n    uint64_t t_one = 0;\n    uint64_t t_two = 0;\n    uint64_t mask_one = 255;\n    uint64_t mask_two = 255;\n    mask_one <<= one * 8;\n    mask_two <<= two * 8;\n    mask_one ^= 18446744073709551615UL;\n    mask_two ^= 18446744073709551615UL;\n    t_one = (value >> (one * 8)) & 255;\n    t_two = (value >> (two * 8)) & 255;\n    value &= (mask_one & mask_two);\n    value |= (t_two << (one * 8));\n    value |= (t_one << (two * 8));\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long swap_two_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  return ~(255 << ((char)a1 * 8 & 63) | 255 << ((char)a2 * 8 & 63)) & a0 |\n         a0 >> ((char)a2 * 8 & 63) << ((char)a1 * 8 & 63) |\n         a0 >> ((char)a1 * 8 & 63) << ((char)a2 * 8 & 63);\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t xor_neighbor(uint64_t value) {\n    int i = 0;\n    uint64_t t = 0;\n    t |= ((value & 18374686479671623680UL) >> 8) ^ (value & 71776119061217280L);\n    t |= ((value & 71776119061217280L) >> 8) ^ (value & 280375465082880L);\n    t |= ((value & 280375465082880L) >> 8) ^ (value & 1095216660480L);\n    t |= ((value & 1095216660480L) >> 8) ^ (value & 4278190080U);\n    t |= ((value & 4278190080U) >> 8) ^ (value & 16711680);\n    t |= ((value & 16711680) >> 8) ^ (value & 65280);\n    t |= ((value & 65280) >> 8) ^ (value & 255);\n    t |= ((value & 255) << 56) ^ (value & 18374686479671623680UL);\n    return t;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long xor_neighbor_name_conflict(unsigned long a0) {\n  return a0 * 0x100000000000000 ^ a0 & -0x100000000000000 |\n         (a0 / 0x100 ^ a0) & 72057594037927935;\n}\n","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_one(uint64_t value) {\n    value = xor(value, 3861390726976975706L);\n    value = swap_two(value, 2, 0);\n    value = xor(value, 9943296405002333681UL);\n    value = xor(value, 16857834378267756394UL);\n    value = swap_two(value, 2, 3);\n    value = xor(value, 13674338511762446054UL);\n    value = shla(value, 16);\n    value = shla(value, 35);\n    value = shra(value, 19);\n    value = xor_neighbor(value);\n    value = shla(value, 36);\n    value = shra(value, 40);\n    value = swap_two(value, 1, 0);\n    value = xor(value, 6765015749217278743L);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 1);\n    value = xor(value, 7686949068708848117L);\n    value = swap_two(value, 3, 0);\n    value = swap_bytes(value);\n    value = xor(value, 6401935715922169987L);\n    value = shra(value, 22);\n    value = xor_neighbor(value);\n    value = xor(value, 5166993816397978483L);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 5);\n    value = shla(value, 59);\n    value = swap_two(value, 5, 2);\n    value = swap_two(value, 2, 3);\n    value = shla(value, 12);\n    value = xor(value, 12476431667104729879UL);\n    value = xor(value, 5234710379464860866L);\n    value = shla(value, 6);\n    value = swap_two(value, 6, 5);\n    value = shra(value, 11);\n    value = swap_bytes(value);\n    value = xor(value, 9697206415216557238UL);\n    value = swap_bytes(value);\n    value = shra(value, 2);\n    value = xor(value, 4649309708712362587L);\n    value = shla(value, 35);\n    value = shla(value, 9);\n    value = xor_neighbor(value);\n    value = shla(value, 7);\n    value = shla(value, 38);\n    value = xor_neighbor(value);\n    value = xor(value, 16065139371609640475UL);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 7);\n    value = shra(value, 51);\n    value = swap_bytes(value);\n    value = shra(value, 19);\n    value = xor(value, 10799149603522670113UL);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 16);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(swap_two)(long long, long long, long long);\nlong long(xor_neighbor)(long long);\nlong long(swap_bytes)(long long);\n\nlong long munge_one_name_conflict(unsigned long a0) {\n  return __ROR__(\n      swap_bytes(xor_neighbor(\n          __ROR__(\n              swap_bytes(__ROL__(\n                  swap_two(\n                      swap_bytes(swap_bytes(\n                          xor_neighbor(__ROR__(\n                              xor_neighbor(__ROR__(\n                                  __ROR__(\n                                      swap_bytes(\n                                          swap_bytes(__ROR__(\n                                              swap_two(\n                                                  __ROL__(\n                                                      __ROL__(\n                                                          swap_two(\n                                                              swap_two(\n                                                                  __ROR__(\n                                                                      swap_two(\n                                                                          xor_neighbor(xor_neighbor(\n                                                                              xor_neighbor(__ROR__(\n                                                                                  swap_bytes(swap_two(\n                                                                                      swap_two(\n                                                                                          swap_bytes(swap_bytes(\n                                                                                              swap_two(\n                                                                                                  __ROR__(\n                                                                                                      xor_neighbor(__ROL__(\n                                                                                                          swap_two(\n                                                                                                              swap_two(\n                                                                                                                  a0 ^\n                                                                                                                      3861390726976975706,\n                                                                                                                  2,\n                                                                                                                  0) ^\n                                                                                                                  6921646058259983003,\n                                                                                                              2,\n                                                                                                              3) ^\n                                                                                                              13674338511762446054,\n                                                                                                          32)),\n                                                                                                      4),\n                                                                                                  1,\n                                                                                                  0) ^\n                                                                                              6765015749217278743)),\n                                                                                          2,\n                                                                                          1) ^\n                                                                                          7686949068708848117,\n                                                                                      3,\n                                                                                      0)) ^\n                                                                                      6401935715922169987,\n                                                                                  22)) ^\n                                                                              5166993816397978483)),\n                                                                          6, 5),\n                                                                      5),\n                                                                  5, 2),\n                                                              2, 3),\n                                                          12) ^\n                                                          16537320247082610645,\n                                                      6),\n                                                  6, 5),\n                                              11)) ^\n                                          9697206415216557238),\n                                      2) ^\n                                      4649309708712362587,\n                                  20)),\n                              19)) ^\n                          16065139371609640475)),\n                      2, 7),\n                  13)),\n              19) ^\n          10799149603522670113)),\n      16);\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_two(uint64_t value) {\n    value = shla(value, 22);\n    value = swap_bytes(value);\n    value = swap_two(value, 4, 1);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 2, 6);\n    value = xor(value, 9271198935367831530UL);\n    value = shla(value, 3);\n    value = swap_two(value, 0, 1);\n    value = swap_two(value, 1, 2);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 1);\n    value = shra(value, 24);\n    value = shla(value, 39);\n    value = swap_two(value, 2, 4);\n    value = xor(value, 7462025471038891063L);\n    value = swap_two(value, 4, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 62);\n    value = swap_bytes(value);\n    value = swap_two(value, 7, 6);\n    value = swap_two(value, 2, 6);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 2);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 7);\n    value = xor(value, 4749710960471120103L);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 4);\n    value = shla(value, 10);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = shra(value, 24);\n    value = swap_two(value, 0, 4);\n    value = shra(value, 61);\n    value = swap_two(value, 3, 4);\n    value = shra(value, 35);\n    value = shla(value, 55);\n    value = shla(value, 34);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = shra(value, 23);\n    value = shla(value, 59);\n    value = shra(value, 20);\n    value = shla(value, 28);\n    value = xor(value, 14007489205149181901UL);\n    value = xor_neighbor(value);\n    value = shra(value, 13);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(swap_bytes)(long long);\nlong long(swap_two)(long long, long long, long long);\nlong long(xor_neighbor)(long long);\n\nlong long munge_two_name_conflict(unsigned long long a0) {\n  return __ROR__(\n      xor_neighbor(\n          __ROR__(\n              xor_neighbor(xor_neighbor(__ROR__(\n                  swap_two(\n                      __ROL__(\n                          swap_two(\n                              __ROR__(\n                                  swap_bytes(swap_bytes(__ROL__(\n                                      swap_two(\n                                          xor_neighbor(swap_bytes(\n                                              swap_two(\n                                                  xor_neighbor(swap_two(\n                                                      xor_neighbor(swap_bytes(swap_two(\n                                                          swap_two(\n                                                              swap_bytes(__ROR__(\n                                                                  swap_two(\n                                                                      swap_two(\n                                                                          swap_two(\n                                                                              __ROL__(\n                                                                                  swap_two(\n                                                                                      xor_neighbor(swap_bytes(swap_two(\n                                                                                          swap_two(\n                                                                                              __ROL__(\n                                                                                                  swap_two(\n                                                                                                      __ROR__(\n                                                                                                          xor_neighbor(swap_bytes(swap_two(\n                                                                                                              swap_bytes(__ROL__(\n                                                                                                                  a0,\n                                                                                                                  22)),\n                                                                                                              4,\n                                                                                                              1))),\n                                                                                                          29),\n                                                                                                      2,\n                                                                                                      6) ^\n                                                                                                      9271198935367831530,\n                                                                                                  3),\n                                                                                              0,\n                                                                                              1),\n                                                                                          1,\n                                                                                          2))),\n                                                                                      5,\n                                                                                      1),\n                                                                                  15),\n                                                                              2,\n                                                                              4) ^\n                                                                              7462025471038891063,\n                                                                          4, 3),\n                                                                      0, 7),\n                                                                  2)),\n                                                              7, 6),\n                                                          2, 6))),\n                                                      5, 2)),\n                                                  1, 7) ^\n                                              4749710960471120103)),\n                                          1, 4),\n                                      10))),\n                                  24),\n                              0, 4),\n                          3),\n                      3, 4),\n                  10))),\n              20) ^\n          14007489205149181901),\n      13);\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_three(uint64_t value) {\n    value = shla(value, 18);\n    value = shla(value, 29);\n    value = swap_two(value, 5, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 18);\n    value = xor(value, 14531814500985747629UL);\n    value = shra(value, 33);\n    value = swap_two(value, 0, 4);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 2);\n    value = shra(value, 13);\n    value = shra(value, 20);\n    value = xor(value, 6368261268581873766L);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 46);\n    value = swap_two(value, 2, 3);\n    value = shra(value, 44);\n    value = shra(value, 3);\n    value = swap_two(value, 4, 3);\n    value = xor_neighbor(value);\n    value = swap_two(value, 7, 6);\n    value = shra(value, 59);\n    value = shra(value, 38);\n    value = swap_bytes(value);\n    value = swap_two(value, 1, 5);\n    value = swap_bytes(value);\n    value = shla(value, 27);\n    value = xor(value, 13751028607104816751UL);\n    value = shra(value, 14);\n    value = shla(value, 7);\n    value = shla(value, 18);\n    value = shla(value, 57);\n    value = xor(value, 12989550924262916891UL);\n    value = xor(value, 929788566303591270L);\n    value = xor(value, 10714451137995436577UL);\n    value = xor(value, 9637405481907436618UL);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 20);\n    value = shla(value, 24);\n    value = shra(value, 46);\n    value = shra(value, 13);\n    value = xor(value, 14510136432192624501UL);\n    value = shla(value, 7);\n    value = xor(value, 641209893495219690L);\n    value = xor(value, 6473287570272602621L);\n    value = xor_neighbor(value);\n    value = swap_two(value, 4, 7);\n    value = xor_neighbor(value);\n    value = shra(value, 22);\n    value = shra(value, 50);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(swap_two)(long long, long long, long long);\nlong long(xor_neighbor)(long long);\nlong long(swap_bytes)(long long);\n\nlong long munge_three_name_conflict(unsigned long a0) {\n  return xor_neighbor(__ROR__(\n      xor_neighbor(swap_two(\n          xor_neighbor(\n              __ROL__(\n                  __ROR__(\n                      swap_two(\n                          __ROL__(\n                              __ROL__(\n                                  swap_bytes(swap_two(\n                                      swap_bytes(__ROL__(\n                                          swap_two(\n                                              xor_neighbor(swap_two(\n                                                  __ROL__(\n                                                      swap_two(\n                                                          __ROL__(\n                                                              swap_bytes(xor_neighbor(\n                                                                  __ROL__(\n                                                                      swap_two(\n                                                                          xor_neighbor(swap_two(\n                                                                              __ROL__(\n                                                                                  __ROL__(\n                                                                                      swap_two(\n                                                                                          swap_two(\n                                                                                              __ROR__(\n                                                                                                  a0,\n                                                                                                  17),\n                                                                                              5,\n                                                                                              3),\n                                                                                          0,\n                                                                                          7),\n                                                                                      18) ^\n                                                                                      14531814500985747629,\n                                                                                  31),\n                                                                              0,\n                                                                              4)),\n                                                                          6, 2),\n                                                                      31) ^\n                                                                  6368261268581873766)),\n                                                              18),\n                                                          2, 3),\n                                                      17),\n                                                  4, 3)),\n                                              7, 6),\n                                          31)),\n                                      1, 5)),\n                                  27) ^\n                                  13751028607104816751,\n                              4) ^\n                              12226415143624820246,\n                          5, 1),\n                      15) ^\n                      14510136432192624501,\n                  7) ^\n              5851220175834278935),\n          4, 7)),\n      8));\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_four(uint64_t value) {\n    value = swap_two(value, 1, 7);\n    value = shla(value, 6);\n    value = swap_two(value, 2, 5);\n    value = shra(value, 57);\n    value = xor(value, 902179681853661902L);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 1);\n    value = xor_neighbor(value);\n    value = xor(value, 6764338754798371998L);\n    value = xor_neighbor(value);\n    value = shla(value, 6);\n    value = xor_neighbor(value);\n    value = shla(value, 33);\n    value = shra(value, 25);\n    value = xor_neighbor(value);\n    value = xor(value, 762415417889401952L);\n    value = swap_two(value, 6, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 14722425112553694635UL);\n    value = xor(value, 9800422926138268860UL);\n    value = xor_neighbor(value);\n    value = xor(value, 9644430456772077073UL);\n    value = shra(value, 8);\n    value = shra(value, 43);\n    value = xor(value, 7150187182015826299L);\n    value = swap_two(value, 3, 1);\n    value = swap_two(value, 5, 7);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shra(value, 59);\n    value = shra(value, 10);\n    value = xor_neighbor(value);\n    value = swap_two(value, 2, 1);\n    value = swap_two(value, 7, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 7246290916701591349L);\n    value = xor(value, 18203423676804128435UL);\n    value = xor(value, 18403139030640123059UL);\n    value = swap_two(value, 2, 4);\n    value = swap_two(value, 5, 4);\n    value = shra(value, 11);\n    value = xor_neighbor(value);\n    value = shla(value, 39);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = xor(value, 14382479493256805148UL);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 3, 5);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(swap_two)(long long, long long, long long);\nlong long(xor_neighbor)(long long);\nlong long(swap_bytes)(long long);\n\nlong long munge_four_name_conflict(unsigned long long a0) {\n  return xor_neighbor(swap_bytes(xor_neighbor(swap_two(\n      __ROR__(\n          xor_neighbor(swap_bytes(\n              xor_neighbor(swap_bytes(__ROR__(\n                  xor_neighbor(__ROR__(\n                      swap_two(\n                          swap_two(\n                              xor_neighbor(swap_two(\n                                  swap_two(\n                                      xor_neighbor(__ROR__(\n                                          xor_neighbor(swap_bytes(swap_two(\n                                              swap_two(\n                                                  __ROL__(\n                                                      xor_neighbor(\n                                                          xor_neighbor(swap_two(\n                                                              xor_neighbor(__ROL__(\n                                                                  xor_neighbor(__ROL__(\n                                                                      xor_neighbor(\n                                                                          xor_neighbor(__ROL__(\n                                                                              swap_two(\n                                                                                  __ROL__(\n                                                                                      swap_two(\n                                                                                          __ROL__(\n                                                                                              swap_two(\n                                                                                                  a0,\n                                                                                                  1,\n                                                                                                  7),\n                                                                                              6),\n                                                                                          2,\n                                                                                          5),\n                                                                                      7) ^\n                                                                                      902179681853661902,\n                                                                                  5,\n                                                                                  1),\n                                                                              1)) ^\n                                                                          6764338754798371998),\n                                                                      6)),\n                                                                  8)) ^\n                                                                  762415417889401952,\n                                                              6, 2)) ^\n                                                          4923163484404676887) ^\n                                                          9644430456772077073,\n                                                      13) ^\n                                                      7150187182015826299,\n                                                  3, 1),\n                                              5, 7))),\n                                          5)),\n                                      2, 1),\n                                  7, 2)) ^\n                                  7454978148062811445,\n                              2, 4),\n                          5, 4),\n                      11)),\n                  25))) ^\n              14382479493256805148)),\n          29),\n      3, 5))));\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"int munge_all(unsigned char *data) {\n    int i = 0;\n    uint64_t *base = ((void *)0);\n    uint64_t one;\n    uint64_t two;\n    uint64_t thr;\n    uint64_t fou;\n    read(0, data, 32);\n    for (i = 0; i < 32; i++) {\n        if (((data[i] < 65) || (122 < data[i])) && (data[i] != 32)) {\n            return 0;\n        } else if (data[i] == ']') {\n            return 0;\n        } else if (data[i] == '\\\\') {\n            return 0;\n        } else if (data[i] == '^') {\n            return 0;\n        } else if (data[i] == '`') {\n            return 0;\n        } else if (data[i] == '[') {\n            return 0;\n        }\n    }\n    base = (uint64_t *)data;\n    one = munge_one(base[0]);\n    two = munge_two(base[1]);\n    thr = munge_three(base[2]);\n    fou = munge_four(base[3]);\n    one = one ^ two ^ thr ^ fou;\n    if (one == 12754495720971571466UL) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(read)(int, void *, unsigned long);\nlong long(munge_one)(long long);\nlong long(munge_two)(long long);\nlong long(munge_three)(long long);\nlong long(munge_four)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[7];\n  unsigned long long field_8;\n  unsigned long long field_10;\n  unsigned long long field_18;\n} struct_0;\n\nlong long munge_all_name_conflict(unsigned long long a0[4]) {\n  struct_0 *v1;          // rdx, Other Possible Types: unsigned long\n  unsigned long long v2; // rax\n\n  read(0, a0, 32);\n  v1 = a0;\n  while (true) {\n    v2 = *((char *)v1);\n    if (v2 - 65 > 57 && (char)v2 != 32)\n      return 0;\n    if ((char)v2 <= 94) {\n      if ((char)v2 > 90)\n        return 0;\n    } else {\n      if ((char)v2 == 96)\n        return 0;\n    }\n    v1 += 1;\n    if (v1 == a0 + 1)\n      return (munge_one(a0[0]) ^ munge_two(a0[1]) ^ munge_three(a0[2]) ^\n              munge_four(a0[3])) == 12754495720971571466;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"int countLiveNeighbors(int x, int y) {\n    int ret = 0;\n    int bit = ((y * 110) + x);\n    if (y > 0) {\n        if ((bit_field[(bit - 110) / 8] & (1 << (7 - ((bit - 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit - 110) - 1) / 8] & (1 << (7 - (((bit - 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit - 110) + 1) / 8] & (1 << (7 - (((bit - 110) + 1) % 8)))))\n            ret++;\n    }\n    if ((x > 0) && (bit_field[(bit - 1) / 8] & (1 << (7 - ((bit - 1) % 8)))))\n        ret++;\n    if ((x < (110 - 1)) && (bit_field[(bit + 1) / 8] & (1 << (7 - ((bit + 1) % 8)))))\n        ret++;\n    if (y < (110 - 1)) {\n        if ((bit_field[(bit + 110) / 8] & (1 << (7 - ((bit + 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit + 110) - 1) / 8] & (1 << (7 - (((bit + 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit + 110) + 1) / 8] & (1 << (7 - (((bit + 110) + 1) % 8)))))\n            ret++;\n    }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern unsigned long long bit_field;\n\nlong long countLiveNeighbors_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0;        // [bp-0x120]\n  int tmp_62;             // tmp #62\n  unsigned long long v2;  // rax\n  unsigned int v4;        // ecx\n  unsigned long long v5;  // r8\n  unsigned int v7;        // r11d\n  unsigned long long v8;  // r10\n  unsigned long long v10; // r8\n  void *v12; // rdx, Other Possible Types: unsigned long, unsigned int, unsigned\n             // long long\n  unsigned long long v13; // rcx\n  unsigned int v15;       // r9d\n  unsigned long long v16; // r8\n  unsigned long long v18; // rcx\n  unsigned long long v20; // rcx\n  unsigned int v22;       // r9d\n  unsigned long long v23; // r8\n  unsigned long long v25; // rcx\n  void *v26;              // cc_ndep\n  unsigned long long v27; // rcx\n  unsigned int v29;       // r9d\n  unsigned long long v30; // r8\n  unsigned long long v32; // rcx\n  unsigned long long v34; // rcx\n  unsigned int v36;       // r9d\n  unsigned long long v37; // r8\n  unsigned long long v39; // rcx\n  void *v40;              // cc_ndep\n  unsigned long long v41; // rcx\n  unsigned int v43;       // r9d\n  unsigned long long v44; // r8\n  unsigned long long v46; // rcx\n  void *v47;              // cc_ndep\n  unsigned long v48;      // r8\n  unsigned int v49;       // r9d\n  unsigned long v50;      // cc_ndep\n  unsigned int v52;       // r9d\n  unsigned long v53;      // cc_ndep\n  unsigned int v55;       // r9d\n  unsigned long v56;      // cc_ndep\n  unsigned long long v58; // rax\n  unsigned long v59;      // rcx\n\n  v2 = (unsigned int)a1 * 110 + a0;\n  if ((unsigned int)a1 <= 0) {\n    v12 = 0;\n  } else {\n    v4 = (unsigned int)(*((char *)(bit_field +\n                                   ((!(v2 - 110 >> 31 & 1)\n                                         ? (unsigned int)v2 - 110\n                                         : (unsigned int)(v2 - 103)) >>\n                                    3))) >>\n                        ((char)((unsigned int)v2 - 110 >> 31 >> 29) -\n                             (char)((unsigned int)((unsigned int)v2 - 110 +\n                                                   ((unsigned int)v2 - 110 >>\n                                                    31 >> 29)) &\n                                    7) +\n                             7 &\n                         31)) &\n         1;\n    v12 = v4;\n    if ((unsigned int)a0 <= 0) {\n      v13 = (unsigned int)v2 - 109;\n      v15 = *((char *)(bit_field +\n                       ((!(v2 - 109 >> 31 & 1) ? (unsigned int)v13\n                                               : (unsigned int)(v2 - 102)) >>\n                        3)));\n      v16 = v13 >> 31 >> 29;\n      v18 = v16 - ((unsigned int)(v13 + v16) & 7) + 7;\n      v0 = v15;\n      if (((char)(*((char *)&v0 + ((v18 & 31) >> 3)) >> (char)(v18 & 31 & 7)) &\n           1)) {\n        v12 = (unsigned int)v12 + 1;\n      } else {\n        v48 = ((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x3 < 64 >, rax,\n                                                    0x1 < 64 >, 0x0 < 64 >)\n                   ? (unsigned int)v2 + 1\n                   : (unsigned int)(v2 + 8));\n        v49 = (unsigned int)(*((char *)(bit_field + (v48 >> 3))) >>\n                             ((char)((unsigned int)v2 + 1 >> 31 >> 29) -\n                                  (char)((unsigned int)((unsigned int)v2 + 1 +\n                                                        ((unsigned int)v2 + 1 >>\n                                                         31 >> 29)) &\n                                         7) +\n                                  7 &\n                              31)) &\n              1;\n        goto LABEL_401371;\n      }\n    } else {\n      v5 = (unsigned int)v2 - 111;\n      v7 = *((char *)(bit_field +\n                      ((!(v2 - 111 >> 31 & 1) ? (unsigned int)v5\n                                              : (unsigned int)(v2 - 104)) >>\n                       3)));\n      v8 = v5 >> 31 >> 29;\n      v10 = v8 - ((unsigned int)(v5 + v8) & 7) + 7;\n      v0 = v7;\n      v12 =\n          ((*((char *)&v0 + ((v10 & 31) >> 3)) >> (char)(v10 & 31 & 7) & 1 & 1)\n               ? v4 + 1\n               : v12);\n      if ((unsigned int)a0 <= 108) {\n        v27 = (unsigned int)v2 - 109;\n        v29 = *((char *)(bit_field +\n                         ((!(v2 - 109 >> 31 & 1) ? (unsigned int)v27\n                                                 : (unsigned int)(v2 - 102)) >>\n                          3)));\n        v30 = v27 >> 31 >> 29;\n        v32 = v30 - ((unsigned int)(v27 + v30) & 7) + 7;\n        v0 = v29;\n        if (!((char)(*((char *)&v0 + ((v32 & 31) >> 3)) >>\n                     (char)(v32 & 31 & 7)) &\n              1)) {\n          v34 = (unsigned int)v2 - 1;\n          v36 = *((char *)(bit_field +\n                           ((!(v2 - 1 >> 31 & 1) ? (unsigned int)v34\n                                                 : (unsigned int)(v2 + 6)) >>\n                            3)));\n          v37 = v34 >> 31 >> 29;\n          v39 = v37 - ((unsigned int)(v34 + v37) & 7) + 7;\n          v0 = v36;\n          v40 = 0;\n          if (!((char)(*((char *)&v0 + ((v39 & 31) >> 3)) >>\n                       (char)(v39 & 31 & 7)) &\n                1)) {\n            v48 = ((char)[D] amd64g_calculate_condition(\n                       0x9 < 64 >, 0x3 < 64 >, rax, 0x1 < 64 >, 0x0 < 64 >)\n                       ? (unsigned int)v2 + 1\n                       : (unsigned int)(v2 + 8));\n            v49 =\n                (unsigned int)(*((char *)(bit_field + (v48 >> 3))) >>\n                               ((char)((unsigned int)v2 + 1 >> 31 >> 29) -\n                                    (char)((unsigned int)((unsigned int)v2 + 1 +\n                                                          ((unsigned int)v2 +\n                                                               1 >>\n                                                           31 >> 29)) &\n                                           7) +\n                                    7 &\n                                31)) &\n                1;\n            goto LABEL_401371;\n          }\n        }\n      } else {\n        v20 = (unsigned int)v2 - 1;\n        v22 = *((char *)(bit_field +\n                         ((!(v2 - 1 >> 31 & 1) ? (unsigned int)v20\n                                               : (unsigned int)(v2 + 6)) >>\n                          3)));\n        v23 = v20 >> 31 >> 29;\n        v25 = v23 - ((unsigned int)(v20 + v23) & 7) + 7;\n        v0 = v22;\n        v26 = 0;\n        if (!((*((char *)&v0 + ((v25 & 31) >> 3)) >> (char)(v25 & 31 & 7) & 1 &\n               1)))\n          goto LABEL_401371;\n        goto LABEL_401323;\n      }\n    }\n  }\n  if ((unsigned int)a0 <= 0) {\n    v48 = ((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x3 < 64 >, rax,\n                                                0x1 < 64 >, 0x0 < 64 >)\n               ? (unsigned int)v2 + 1\n               : (unsigned int)(v2 + 8));\n    v49 = ...;\n    goto LABEL_401371;\n  }\n  v41 = (unsigned int)v2 - 1;\n  v43 =\n      *((char *)(bit_field + ((!(v2 - 1 >> 31 & 1) ? (unsigned int)v41\n                                                   : (unsigned int)(v2 + 6)) >>\n                              3)));\n  v44 = v41 >> 31 >> 29;\n  v46 = v44 - ((unsigned int)(v41 + v44) & 7) + 7;\n  v0 = v43;\n  v47 = 0;\n  if (!((*((char *)&v0 + ((v46 & 31) >> 3)) >> (char)(v46 & 31 & 7) & 1 & 1)))\n    goto LABEL_401326;\nLABEL_401323:\n  v12 = (unsigned int)v12 + 1;\nLABEL_401326:\n  if ((unsigned int)a0 <= 108) {\n    v48 = ((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x3 < 64 >, rax,\n                                                0x1 < 64 >, 0x0 < 64 >)\n               ? (unsigned int)v2 + 1\n               : (unsigned int)(v2 + 8));\n    v49 = ...;\n    v50 = v49 < 1;\n    v12 = (unsigned int)v12 - -1 - (v49 < 1);\n  }\nLABEL_401371:\n  if ((unsigned int)a1 > 108)\n    return v12;\n  v52 = (unsigned int)(*((char *)(bit_field +\n                                  (((char)[D] amd64g_calculate_condition(\n                                        0x9 < 64 >, 0x3 < 64 >, rax,\n                                        0x6e < 64 >, cc_ndep)\n                                        ? (unsigned int)v2 + 110\n                                        : (unsigned int)(v2 + 117)) >>\n                                   3))) >>\n                       ((char)((unsigned int)v2 + 110 >> 31 >> 29) -\n                            (char)((unsigned int)((unsigned int)v2 + 110 +\n                                                  ((unsigned int)v2 + 110 >>\n                                                   31 >> 29)) &\n                                   7) +\n                            7 &\n                        31)) &\n        1;\n  v53 = v52 < 1;\n  v12 = (unsigned int)v12 - -1 - (v52 < 1);\n  if ((unsigned int)a0 > 0) {\n    v55 =\n        (unsigned int)(*((char *)(bit_field +\n                                  (((char)[D] amd64g_calculate_condition(\n                                        0x9 < 64 >, 0x3 < 64 >, rax, 0x6d < 64 >\n                                        , Conv(1->64, (r9d<4><0x1 < 32>)))\n                                        ? (unsigned int)v2 + 109\n                                        : (unsigned int)(v2 + 116)) >>\n                                   3))) >>\n                       ((char)((unsigned int)v2 + 109 >> 31 >> 29) -\n                            (char)((unsigned int)((unsigned int)v2 + 109 +\n                                                  ((unsigned int)v2 + 109 >>\n                                                   31 >> 29)) &\n                                   7) +\n                            7 &\n                        31)) &\n        1;\n    v56 = v55 < 1;\n    v12 = v12 - -1 - (v55 < 1);\n    if ((unsigned int)a0 > 108)\n      return v12;\n  }\n  tmp_62 = v2;\n  v58 = (unsigned int)v2 + 111;\n  v59 = ((char)[D] amd64g_calculate_condition(0x9 < 64 >, 0x3 < 64 >, t62,\n                                              0x6f < 64 >, cc_ndep)\n             ? (unsigned int)v58\n             : (unsigned int)v2 + 118);\n  v12 = (unsigned int)v12 - -1 -\n        (((unsigned int)(*((char *)(bit_field + (v59 >> 3))) >>\n                         ((char)(v58 >> 31 >> 29) -\n                              (char)((unsigned int)(v58 + (v58 >> 31 >> 29)) &\n                                     7) +\n                              7 &\n                          31)) &\n          1) < 1);\n  return v12;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:85:30: error: expected expression\n   85 |                 v48 = ((char)[D] amd64g_calculate_condition(0x9<64>,\n0x3<64>, rax, 0x1<64>, 0x0<64>) ? (unsigned int)v2 + 1 : (unsigned int)(v2 +\n8)); |                              ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:115:38: error: expected expression\n  115 |                         v48 = ((char)[D]\namd64g_calculate_condition(0x9<64>, 0x3<64>, rax, 0x1<64>, 0x0<64>) ? (unsigned\nint)v2 + 1 : (unsigned int)(v2 + 8)); |                                      ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:137:22: error: expected expression\n  137 |         v48 = ((char)[D] amd64g_calculate_condition(0x9<64>, 0x3<64>,\nrax, 0x1<64>, 0x0<64>) ? (unsigned int)v2 + 1 : (unsigned int)(v2 + 8)); | ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:138:14: error: expected ';' after\nexpression 138 |         v49 = ...; |              ^ |              ;\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:138:13: error: expected expression\n  138 |         v49 = ...;\n      |             ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:154:22: error: expected expression\n  154 |         v48 = ((char)[D] amd64g_calculate_condition(0x9<64>, 0x3<64>,\nrax, 0x1<64>, 0x0<64>) ? (unsigned int)v2 + 1 : (unsigned int)(v2 + 8)); | ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:155:14: error: expected ';' after\nexpression 155 |         v49 = ...; |              ^ |              ;\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:155:13: error: expected expression\n  155 |         v49 = ...;\n      |             ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:162:57: error: expected expression\n  162 |     v52 = (unsigned int)(*((char *)(bit_field + (((char)[D]\namd64g_calculate_condition(0x9<64>, 0x3<64>, rax, 0x6e<64>, cc_ndep) ? (unsigned\nint)v2 + 110 : (unsigned int)(v2 + 117)) >> 3))) >> ((char)((unsigned int)v2 +\n110 >> 31 >> 29) - (char)((unsigned int)((unsigned int)v2 + 110 + ((unsigned\nint)v2 + 110 >> 31 >> 29)) & 7) + 7 & 31)) & 1; | ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:167:61: error: expected expression\n  167 |         v55 = (unsigned int)(*((char *)(bit_field + (((char)[D]\namd64g_calculate_condition(0x9<64>, 0x3<64>, rax, 0x6d<64>, Conv(1->64, (r9d<4>\n< 0x1<32>))) ? (unsigned int)v2 + 109 : (unsigned int)(v2 + 116)) >> 3))) >>\n((char)((unsigned int)v2 + 109 >> 31 >> 29) - (char)((unsigned int)((unsigned\nint)v2 + 109 + ((unsigned int)v2 + 109 >> 31 >> 29)) & 7) + 7 & 31)) & 1; | ^\n/tmp/tmp30e29pta/countLiveNeighbors_name_conflict.c:175:18: error: expected expression\n  175 |     v59 = ((char)[D] amd64g_calculate_condition(0x9<64>, 0x3<64>, t62,\n0x6f<64>, cc_ndep) ? (unsigned int)v58 : (unsigned int)v2 + 118); | ^ 11 errors\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":0,"function":"int processCoord(int x, int y) {\n    int ret;\n    if (x < 0 || y < 0) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    if ((x >= 110) || (y >= 110)) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    ret = (y * 110) + x;\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern FILE_t *stdout @GLIBC_2.2.5;\n\nlong long processCoord_name_conflict(unsigned long a0, unsigned long a1) {\n  if (((unsigned int)a0 | (unsigned int)a1) < 0) {\n    puts(\"Illegal Coordinate!\");\n    fflush(stdout @GLIBC_2.2.5);\n    exit(-1); /* do not return */\n  }\n  if (!((unsigned int)a0 <= 109 && (unsigned int)a1 <= 109)) {\n    puts(\"Illegal Coordinate!\");\n    fflush(stdout @GLIBC_2.2.5);\n    exit(-1); /* do not return */\n  }\n  return (unsigned int)a1 * 110 + a0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptvh3n37q/processCoord_name_conflict.c:17:8: error: unknown type name 'FILE_t'; did you\nmean 'FILE'? 17 | extern FILE_t *stdout@GLIBC_2.2.5; |        ^~~~~~ | FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmptvh3n37q/processCoord_name_conflict.c:17:22: error: expected ';' after top level\ndeclarator 17 | extern FILE_t *stdout@GLIBC_2.2.5; |                      ^ | ;\n/tmp/tmptvh3n37q/processCoord_name_conflict.c:24:22: error: expected ')'\n   24 |         fflush(stdout@GLIBC_2.2.5);\n      |                      ^\n/tmp/tmptvh3n37q/processCoord_name_conflict.c:24:15: note: to match this '('\n   24 |         fflush(stdout@GLIBC_2.2.5);\n      |               ^\n/tmp/tmptvh3n37q/processCoord_name_conflict.c:30:22: error: expected ')'\n   30 |         fflush(stdout@GLIBC_2.2.5);\n      |                      ^\n/tmp/tmptvh3n37q/processCoord_name_conflict.c:30:15: note: to match this '('\n   30 |         fflush(stdout@GLIBC_2.2.5);\n      |               ^\n4 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":0,"function":"unsigned int FindRoot(unsigned int *set, unsigned int node) {\n    if (set[node] == node)\n        return node;\n    else\n        return FindRoot(set, set[node]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(FindRoot_name_conflict)(unsigned long, unsigned int *);\n\nlong long FindRoot_name_conflict(unsigned long a0, unsigned int *a1) {\n  unsigned int *v1;      // rax\n  unsigned long long v2; // rsi\n\n  v1 = a1;\n  v2 = *((int *)(a0 + a1 * 4));\n  if ((unsigned int)v2 != (unsigned int)v1)\n    return FindRoot_name_conflict(a0, v2);\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp83x0q2tm/FindRoot_name_conflict.c:24:28: error: invalid operands to binary expression\n('unsigned int *' and 'int') 24 |     v2 = *((int *)(a0 + a1 * 4)); | ~~ ^ ~ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/arnikz_netclust/src/netclust.c"}
{"compilable":0,"function":"int udp_epoll_add(int epollfd, int fd, U32 u32flag) {\n    int ret = -1;\n    int block_opt = 0;\n    struct epoll_event event;\n    if (epollfd == 0 || fd == 0) {\n        ;\n        return (-1);\n    }\n    event.data.fd = fd;\n    event.events = u32flag;\n    ret = epoll_ctl(epollfd, 1, fd, &event);\n    if (ret < 0) {\n        ;\n        return (-1);\n    }\n    block_opt = fcntl(fd, 3) | 2048;\n    fcntl(fd, 4, block_opt);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long udp_epoll_add_name_conflict(unsigned long a0, unsigned long a1, unsigned long a2) {\n  unsigned int v0;  // [bp-0x14]\n  unsigned int v1;  // [bp-0x10]\n  unsigned long v2; // [bp-0x8]\n  unsigned long v4; // rbx\n  char v6;          // ah\n\n  if (!(unsigned int)a0)\n    return 4294967295;\n  v2 = v4;\n  if (!(unsigned int)a1)\n    return 4294967295;\n  v1 = a1;\n  v0 = a2;\n  if (epoll_ctl() < 0)\n    return 4294967295;\n  v6 = (char)fcntl(a1, 3) | 8;\n  fcntl(a1, 4);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_setup(INSTANCE_T *pinst) {\n    int ret = -1;\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    pinst->epollfd = epoll_create(5);\n    if (pinst->epollfd == -1) {\n        ;\n        return (-1);\n    }\n    ret = socketpair(1, SOCK_STREAM, 0, pinst->pipefd);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    ret |= udp_epoll_add(pinst->epollfd, pinst->pipefd[0], EPOLLIN | EPOLLET);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    int block_opt = fcntl(pinst->pipefd[1], 3) | 2048;\n    fcntl(pinst->pipefd[1], 4, block_opt);\n    g_sig_fd = pinst->pipefd[1];\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socketpair)(int, int, int, int(32 bits)[2]);\nlong long(udp_epoll_add)(long long, long long, long long);\nint(fcntl)(int, int, ...);\n\nextern unsigned int g_sig_fd;\n\nlong long udp_epoll_setup_name_conflict(unsigned int a0[8]) {\n  unsigned long v1; // rbp\n  char v2;          // ah\n\n  if (!a0)\n    return 4294967295;\n  v1 = epoll_create(5);\n  a0[5] = v1;\n  if ((unsigned int)v1 == -1) {\n    return v1;\n  } else if (!socketpair(1, 1, 0, (unsigned int[8]) & a0[6])) {\n    v1 = udp_epoll_add(a0[5], a0[6], 2147483649);\n    if ((unsigned int)v1)\n      return 4294967295;\n    v2 = (char)fcntl(a0[7], 3) | 8;\n    fcntl(a0[7], 4);\n    g_sig_fd = a0[7];\n    return v1;\n  } else {\n    return 4294967295;\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpm92xk89m/udp_epoll_setup_name_conflict.c:16:38: error: expected ')'\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                      ^\n/tmp/tmpm92xk89m/udp_epoll_setup_name_conflict.c:16:37: note: to match this '('\n   16 | int (socketpair)(int, int, int, int (32 bits)[2]);\n      |                                     ^\n/tmp/tmpm92xk89m/udp_epoll_setup_name_conflict.c:35:35: error: used type 'unsigned int[8]'\nwhere arithmetic or pointer type is required 35 |     else if (!socketpair(1, 1,\n0, (unsigned int [8])&a0[6])) |                                   ^ ~~~~~~ 2\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_shutdown(const INSTANCE_T *pinst) {\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    close(pinst->pipefd[0]);\n    close(pinst->pipefd[1]);\n    close(pinst->epollfd);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\ntypedef struct struct_0 {\n  char padding_0[24];\n  unsigned int field_18;\n} struct_0;\n\nlong long udp_epoll_shutdown_name_conflict(struct_0 *a0) {\n  unsigned long v0;      // [bp-0x8]\n  unsigned long v2;      // rbx\n  unsigned int v3;       // edi\n  unsigned long long v4; // rbx\n\n  if (a0) {\n    v0 = v2;\n    v3 = a0->field_18;\n    close(v3);\n    close(*((int *)(*((unsigned long long *)&v3) + 28)));\n    close(*((int *)(*((unsigned long long *)&v3) + 20)));\n    v4 = v0;\n    return 0;\n  }\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_listen(INSTANCE_T *pinst) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    struct sockaddr_in lsn_addr = {0};\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    pinst->lsn_fd = socket(2, SOCK_DGRAM, 0);\n    if (pinst->lsn_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = setsockopt(pinst->lsn_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    memset(&lsn_addr, 0, sizeof (lsn_addr));\n    lsn_addr.sin_family = 2;\n    lsn_addr.sin_port = pinst->task.nlsn_port;\n    lsn_addr.sin_addr.s_addr = pinst->task.u32lsn_ip;\n    ret = bind(pinst->lsn_fd, (struct sockaddr *)&lsn_addr, sizeof(struct sockaddr_in));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    goto _S0;\n  _E2:\n    close(pinst->lsn_fd);\n  _E1:\n    pinst->lsn_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(setsockopt)(int, int, int, void *, int);\nint(close)(int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  char padding_2[2];\n  unsigned int field_4;\n  char padding_8[8];\n  unsigned int field_10;\n} struct_0;\n\nlong long udp_core_listen_name_conflict(struct_0 *a0) {\n  void *v0;              // [bp-0x28], Other Possible Types: unsigned short\n  unsigned short v1;     // [bp-0x26]\n  unsigned int v2;       // [bp-0x24]\n  void *v3;              // [bp-0x20]\n  unsigned int v4;       // [bp-0xc]\n  unsigned long long v6; // rax\n\n  v4 = 1;\n  v0 = 0;\n  v3 = 0;\n  if (a0) {\n    (unsigned int)v6 = socket(2, 2, 0);\n    a0->field_10 = v6;\n    if ((unsigned int)v6 >= 0) {\n      if (setsockopt(v6, 1, 2, &v4, 4) >= 0) {\n        v3 = 0;\n        v0 = 2;\n        v1 = a0->field_0;\n        v2 = a0->field_4;\n        if (bind(a0->field_10, &v0, 16) >= 0)\n          return 0;\n      }\n      close(a0->field_10);\n    }\n  }\n  a0->field_10 = 0;\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuza_w52e/udp_core_listen_name_conflict.c:46:9: error: assignment to cast is illegal,\nlvalue casts are not supported 46 |         (unsigned int)v6 = socket(2, 2, 0);\n      |         ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_connect(struct sockaddr_in *psrv_addr, struct sockaddr_in *plcl_addr, int *psrv_fd) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    socklen_t socklen = sizeof(struct sockaddr_in);\n    if (!psrv_addr || !plcl_addr) {\n        ;\n        goto _E1;\n    }\n    *psrv_fd = socket(2, SOCK_DGRAM, 0);\n    if (*psrv_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = bind(*psrv_fd, (struct sockaddr *)plcl_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = setsockopt(*psrv_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = connect(*psrv_fd, (struct sockaddr *)psrv_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    int block_opt = fcntl(*psrv_fd, 3) | 2048;\n    fcntl(*psrv_fd, 4, block_opt);\n    goto _S0;\n  _E2:\n    close(*psrv_fd);\n  _E1:\n    *psrv_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(close)(int);\nint(setsockopt)(int, int, int, void *, int);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nint(fcntl)(int, int, ...);\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long udp_core_connect_name_conflict(sockaddr *a0, sockaddr *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x1c]\n  unsigned long long v2; // rax\n\n  v0 = 1;\n  if (a0 && a1) {\n    (unsigned int)v2 = socket(2, 2, 0);\n    *(a2) = v2;\n    if ((unsigned int)v2 >= 0) {\n      if (bind(v2, a1, 16) >= 0 && setsockopt(*(a2), 1, 2, &v0, 4) >= 0 &&\n          connect(*(a2), a0, 16) >= 0) {\n        *((char *)&v2) = (char)fcntl(*(a2), 3) | 8;\n        fcntl(*(a2), 4);\n        return 0;\n      }\n      close(*(a2));\n    }\n  }\n  *(a2) = 0;\n  return 4294967295;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpk7ni0k6b/udp_core_connect_name_conflict.c:42:9: error: assignment to cast is illegal,\nlvalue casts are not supported 42 |         (unsigned int)v2 = socket(2, 2, 0);\n      |         ^~~~~~~~~~~~~~~~ ~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_send_nonblock(int fd, const char *pbuf, size_t bufsize) {\n    int ret = (-1);\n    if (!pbuf) {\n        ;\n        return (-1);\n    }\n    while (ret < 0)\n        {\n            ret = send(fd, pbuf, bufsize, 0);\n            if (ret < 0) {\n                if ((*__errno_location()) == 11) {\n                    ;\n                    usleep(10);\n                    continue;\n                } else {\n                    return (-1);\n                }\n            }\n        }\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(send)(int, void *, unsigned long, int);\nchar *(usleep)(char *);\n\nlong long udp_send_nonblock_name_conflict(unsigned long a0, void *a1, unsigned long a2) {\n  unsigned long v2; // rdx, Other Possible Types: unsigned long long\n\n  if (!a1)\n    return 4294967295;\n  while ((unsigned int)v2 < 0) {\n    v2 = send(a0, a1, a2, 0);\n    if (*(__errno_location()) != 11)\n      return 4294967295;\n    usleep(0xa);\n  }\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprony3nxy/udp_send_nonblock_name_conflict.c:28:13: error: indirection requires pointer\noperand ('int' invalid) 28 |         if (*(__errno_location()) != 11) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_add(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    snprintf(cmd, sizeof (cmd), \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n    ;\n    system(cmd);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(ip_ntoa)(long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\nint(system)(char *);\n\ntypedef struct struct_0 {\n  char padding_0[2];\n  unsigned short field_2;\n  unsigned short field_4;\n  char padding_6[10];\n  unsigned int field_10;\n  unsigned int field_14;\n} struct_0;\n\nlong long udp_snat_add_name_conflict(struct_0 *a0) {\n  void *v0;               // [bp-0x248]\n  void *v1;               // [bp-0x240]\n  void *v2;               // [bp-0x238]\n  void *v3;               // [bp-0x230]\n  void *v4;               // [bp-0x228]\n  void *v5;               // [bp-0x220]\n  char v6;                // [bp-0x218]\n  struct_0 *v8;           // rbx\n  unsigned long long *v9; // rdi, Other Possible Types: unsigned long\n  unsigned long v10;      // rcx, Other Possible Types: unsigned long long\n  unsigned long v11;      // d\n  unsigned long long v12; // rbp\n\n  v8 = a0;\n  v4 = 0;\n  v5 = 0;\n  v9 = &v6;\n  for (v10 = 62; v10; v9 += v11 * 8) {\n    v10 -= 1;\n    *((long long *)v9) = 0;\n  }\n  v2 = 0;\n  v3 = 0;\n  v0 = 0;\n  v1 = 0;\n  if (!v8)\n    return 4294967295;\n  v12 = v8->field_4;\n  *((unsigned short *)&v12) = __ROL__((unsigned short)v12, 8);\n  snprintf(&v4, 0x200,\n           \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n           \"--to %s:%u\",\n           (int)ip_ntoa(v8->field_14, &v2), __ROL__(v8->field_2, 8),\n           (int)ip_ntoa(v8->field_10, &v0), (unsigned int)v12);\n  system(&v4);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprdvu46q7/udp_snat_add_name_conflict.c:17:6: error: conflicting types for 'snprintf'\n   17 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_del(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    if (proxy_app->udp_type & UDP_TYPE_CLIENT) {\n        snprintf(cmd, sizeof (cmd), \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n        ;\n    }\n    system(cmd);\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(system)(char *);\nlong long(ip_ntoa)(long long, long long);\nint(snprintf)(char *, unsigned long, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[1];\n  unsigned short field_2;\n  unsigned short field_4;\n  char padding_6[10];\n  unsigned int field_10;\n  unsigned int field_14;\n} struct_0;\n\nlong long udp_snat_del_name_conflict(struct_0 *a0) {\n  void *v0;               // [bp-0x248]\n  void *v1;               // [bp-0x240]\n  void *v2;               // [bp-0x238]\n  void *v3;               // [bp-0x230]\n  void *v4;               // [bp-0x228]\n  void *v5;               // [bp-0x220]\n  char v6;                // [bp-0x218]\n  struct_0 *v8;           // rbx\n  unsigned long long *v9; // rdi, Other Possible Types: unsigned long\n  unsigned long v10;      // rcx, Other Possible Types: unsigned long long\n  unsigned long v11;      // d\n  unsigned long long v12; // rbp\n\n  v8 = a0;\n  v4 = 0;\n  v5 = 0;\n  v9 = &v6;\n  for (v10 = 62; v10; v9 += v11 * 8) {\n    v10 -= 1;\n    *((long long *)v9) = 0;\n  }\n  v2 = 0;\n  v3 = 0;\n  v0 = 0;\n  v1 = 0;\n  if (!v8)\n    return 4294967295;\n  if ((v8->field_0 & 8)) {\n    v12 = v8->field_4;\n    *((unsigned short *)&v12) = __ROL__((unsigned short)v12, 8);\n    snprintf(&v4, 0x200,\n             \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n             \"--to %s:%u\",\n             (int)ip_ntoa(v8->field_14, &v2), __ROL__(v8->field_2, 8),\n             (int)ip_ntoa(v8->field_10, &v0), (unsigned int)v12);\n  }\n  system(&v4);\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpv13_m1bq/udp_snat_del_name_conflict.c:18:6: error: conflicting types for 'snprintf'\n   18 | int (snprintf)(char *, unsigned long, char *, ...);\n      |      ^\n/usr/include/stdio.h:378:12: note: previous declaration is here\n  378 | extern int snprintf (char *__restrict __s, size_t __maxlen,\n      |            ^\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_request(const INSTANCE_T *pinst, char *pbuf) {\n    int ret = 0;\n    int srv_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    char debug[16] = {0};\n    char *pdata = ((void *)0);\n    UDP_HEAD *phead = ((void *)0);\n    TIMER_T *ptimer = ((void *)0);\n    struct sockaddr_in clt_addr = {0};\n    socklen_t clt_len = sizeof (clt_addr);\n    dsp_time(385, \"\");\n    if (!pbuf) {\n        ;\n        goto _E1;\n    }\n    phead = (UDP_HEAD *)pbuf;\n    pdata = pbuf + sizeof(UDP_HEAD);\n    memset(phead, 0, sizeof(UDP_HEAD));\n    if (recv_byte < 0) {\n        ;\n        goto _E1;\n    }\n    ;\n    ptimer = time_wheel_search_by_addr(clt_addr);\n    if (!ptimer) {\n        ptimer = udp_connection_setup(pinst, phead, &clt_addr, &srv_fd);\n        if (!ptimer) {\n            ;\n            goto _E1;\n        }\n        dsp_time(417, \"udp_connection_setup\");\n    } else {\n        srv_fd = ptimer->proxy_app.srv_fd;\n        ret = time_wheel_refresh(ptimer, 2);\n        if (!ptimer) {\n            ;\n            goto _E2;\n        }\n        dsp_time(426, \"time_wheel_refresh\");\n    }\n    if (send_byte < 0) {\n        ;\n        goto _E2;\n    }\n    dsp_time(443, \"udp_epoll_handler_request\");\n    goto _S0;\n  _E2:\n    time_wheel_del(&ptimer);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(dsp_time)();\nlong long(time_wheel_search_by_addr)(long long, long long);\nlong long(udp_connection_setup)(long long, long long, long long, long long);\nlong long(time_wheel_refresh)(long long, long long);\nlong long(time_wheel_del)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  unsigned int field_8;\n} struct_0;\n\nlong long udp_epoll_handler_request_name_conflict(unsigned long long a0, uint128_t *a1) {\n  void *v0;        // [bp-0x38]\n  void *v1;        // [bp-0x30]\n  struct_0 *v2;    // [bp-0x28]\n  unsigned int v3; // [bp-0x1c]\n\n  v3 = 0;\n  v2 = 0;\n  v0 = 0;\n  v1 = 0;\n  dsp_time();\n  if (!a1)\n    return 4294967295;\n  *(a1) = 0;\n  v2 = time_wheel_search_by_addr(v0, v1);\n  if (!v2) {\n    v2 = udp_connection_setup(a0, a1, &v0, &v3);\n    if (!v2)\n      return 4294967295;\n    dsp_time();\n  } else {\n    v3 = v2->field_8;\n    time_wheel_refresh(v2, 2);\n    if (!v2) {\n      time_wheel_del(&v2);\n      return 4294967295;\n    }\n    dsp_time();\n  }\n  dsp_time();\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqlzek0vr/udp_epoll_handler_request_name_conflict.c:27:60: error: unknown type name\n'uint128_t' 27 | long long udp_epoll_handler_request_name_conflict(unsigned long long a0,\nuint128_t *a1) |                                                            ^ 1\nerror generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_respone(const INSTANCE_T *pinst, int srv_fd, char *pbuf) {\n    int ret = 0;\n    int clt_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    struct sockaddr_in srv_addr = {0};\n    socklen_t clt_len = sizeof(struct sockaddr_in);\n    TIMER_T *ptimer = ((void *)0);\n    recv_byte = recv(srv_fd, pbuf, 65535, 0);\n    if (recv_byte <= 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    ptimer = time_wheel_search_by_fd(srv_fd);\n    if (!ptimer) {\n        ;\n        goto _E2;\n    }\n    ret = time_wheel_refresh(ptimer, 2);\n    if (!ptimer) {\n        ;\n        goto _E3;\n    }\n    clt_fd = ptimer->proxy_app.clt_fd;\n    send_byte = sendto(clt_fd, pbuf, recv_byte, 0, (struct sockaddr *)&ptimer->proxy_app.clt_addr, clt_len);\n    if (send_byte <= 0) {\n        ;\n        goto _E3;\n    }\n    goto _S0;\n  _E3:\n    time_wheel_del(&ptimer);\n  _E2:\n    close(srv_fd);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\nint(close)(int);\nlong long(time_wheel_search_by_fd)(long long);\nlong long(time_wheel_refresh)(long long, long long);\nlong long(time_wheel_del)(long long);\nlong(sendto)(\n    int, void *, unsigned long, int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\n\ntypedef struct struct_0 {\n  char padding_0[12];\n  unsigned int field_c;\n} struct_0;\n\nlong long udp_epoll_handler_respone(unsigned long a0, unsigned long long a1,\n                                    void *a2) {\n  struct_0 *v0;          // [bp-0x20]\n  unsigned long long v2; // rax\n  struct_0 *v4;          // rax\n\n  v0 = 0;\n  v2 = recv(a1, a2, 65535, 0);\n  if ((unsigned int)v2 > 0) {\n    v0 = time_wheel_search_by_fd(a1);\n    if (v0) {\n      time_wheel_refresh(v0, 2);\n      v4 = v0;\n      if (v4 &&\n          (int)sendto(v4->field_c, a2, v2, 0, &v4[1].padding_0[8], 16) > 0)\n        return 0;\n      time_wheel_del(&v0);\n    }\n  }\n  close(a1);\n  return 4294967295;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_signal(int pipefd) {\n    int ret = 0;\n    int sig = 0;\n    int jx = 0;\n    char signals[1024];\n    ret = recv(pipefd, signals, sizeof (signals), 0);\n    if (ret <= 0) {\n        ;\n        return (-1);\n    } else {\n        for (jx = 0; jx < ret; jx++) {\n            switch (signals[jx]) {\n              case 14:\n                g_timeout = 1;\n                break;\n              case 2:\n              case 15:\n                ;\n                g_enable = 0;\n                break;\n              default:\n                break;\n            }\n        }\n    }\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(recv)(int, void *, unsigned long, int);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nextern unsigned int g_enable;\nextern unsigned int g_timeout;\n\nlong long udp_epoll_handler_signal_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x408]\n  char v1;               // [bp-0x407]\n  unsigned long long v3; // rax\n  struct_0 *v4;          // rdx, Other Possible Types: unsigned long\n  char v6;               // al\n  char v7;               // cl\n  char v8;               // r8b\n\n  v3 = recv(a0, &v0, 0x400, 0);\n  if ((unsigned int)v3 <= 0)\n    return 4294967295;\n  v4 = &v0;\n  v7 = 0;\n  v8 = 0;\n  do {\n    v6 = *((char *)v4);\n    if (v6 == 14) {\n      v8 = 1;\n    } else if (v6 == 15) {\n      v7 = 1;\n    } else if (v6 == 2) {\n      v7 = 1;\n    }\n  } while ((v4 = &v1, &v0 + v3 != v4));\n  if (v7)\n    g_enable = 0;\n  if (!v8)\n    return 0;\n  g_timeout = 1;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler(const INSTANCE_T *pinst) {\n    char *buffer = ((void *)0);\n    int ret = 0;\n    int ix = 0;\n    int sockfd = 0;\n    int timeout = 0;\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    buffer = (char *)malloc(sizeof(char) * 65535);\n    if (!buffer) {\n        ;\n        goto _E1;\n    }\n    int epoll_num = 0;\n    struct epoll_event events[65535] = {0};\n    while (g_enable)\n        {\n            epoll_num = epoll_wait(pinst->epollfd, events, 65535, -1);\n            if (epoll_num < 0 && (*__errno_location()) != 4) {\n                ;\n                goto _E2;\n            }\n            for (ix = 0; ix < epoll_num; ix++) {\n                sockfd = events[ix].data.fd;\n                if (sockfd == pinst->lsn_fd) {\n                    ret = udp_epoll_handler_request(pinst, buffer);\n                    if (ret != (0)) {\n                        ;\n                    }\n                } else if (sockfd == pinst->pipefd[0]) {\n                    ret = udp_epoll_handler_signal(pinst->pipefd[0]);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else if (events[ix].events & EPOLLIN) {\n                    ret = udp_epoll_handler_respone(pinst, sockfd, buffer);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else {\n                }\n                if (g_timeout) {\n                    time_wheel_tick();\n                    alarm(10);\n                    g_timeout = 0;\n                    continue;\n                }\n            }\n        }\n    goto _S0;\n  _E2:\n    free(buffer);\n    buffer = ((void *)0);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint rbp; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(udp_epoll_handler_name_conflict_request)(long long, long long);\nlong long(udp_epoll_handler_name_conflict_signal)(long long);\nlong long(time_wheel_tick)();\nlong long(udp_epoll_handler_name_conflict_respone)(long long, long long, long long);\nunsigned int(alarm)(unsigned int);\n\ntypedef struct struct_0 {\n  char field_0;\n  char padding_1[3];\n  unsigned int field_4;\n} struct_0;\n\nextern unsigned int g_enable;\nextern unsigned int g_timeout;\n\nlong long udp_epoll_handler_name_conflict(unsigned int a0[7]) {\n  char v0;                // [bp-0xc0028]\n  char v2;                // [bp-0xc001c]\n  unsigned long v3;       // [bp-0x28]\n  unsigned long v4;       // [bp-0x20]\n  unsigned long v5;       // [bp-0x18]\n  unsigned long v6;       // [bp-0x10]\n  unsigned long v7;       // [bp-0x8]\n  unsigned long v9;       // r14\n  unsigned long v10;      // r13\n  unsigned long v11;      // r12\n  unsigned long v12;      // rbx\n  unsigned int v13[7];    // rbp\n  void *v14;              // r13\n  unsigned long long v15; // rax\n  unsigned long long v16; // rsi\n  unsigned long long v17; // rdi\n  struct_0 *v18;          // rbx, Other Possible Types: unsigned long\n  unsigned long v19;      // rax, Other Possible Types: unsigned long long\n\n  if (!a0)\n    return 4294967295;\n  v7 = v9;\n  v6 = v10;\n  v5 = v11;\n  *((int *)&v4) = rbp;\n  v3 = v12;\n  v13 = a0;\n  v14 = malloc(65535);\n  if (!v14) {\n    v19 = 4294967295;\n  } else {\n    memset(&v0, 0, 786420);\n    v19 = g_enable;\n    if (g_enable) {\n      do {\n        (unsigned int)v15 = epoll_wait(v13[5], &v0, 65535, 4294967295);\n        if ((unsigned int)v15 < 0) {\n          if (*(__errno_location()) == 4)\n            continue;\n        LABEL_401c46:\n          free(v14);\n          v19 = 4294967295;\n          break;\n        } else if ((unsigned int)v15 > 0) {\n          v18 = &v0;\n          do {\n            v16 = *((int *)(v18 + 4));\n            if (v13[4] == (unsigned int)v16) {\n              udp_epoll_handler_name_conflict_request(v13, v14);\n            } else {\n              v17 = v13[6];\n              if ((unsigned int)v17 == (unsigned int)v16) {\n                if (!(int)udp_epoll_handler_name_conflict_signal(v17))\n                  goto LABEL_401c11;\n                else\n                  goto LABEL_401c46;\n              } else if (!(*((char *)v18) & 1) ||\n                         !(int)udp_epoll_handler_name_conflict_respone(v13, v16, v14)) {\n                continue;\n              }\n            }\n          LABEL_401c11:\n            if (g_timeout) {\n              time_wheel_tick();\n              alarm(10);\n              g_timeout = 0;\n            }\n            v18 = &v2;\n          } while (v18 != &(&v0)[8 * v15 + 4 * v15]);\n        }\n      } while ((v19 = (unsigned long long)g_enable, g_enable));\n    }\n  }\n  return v19;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmprd9x052w/udp_epoll_handler_name_conflict.c:60:9: error: array type 'unsigned int[7]'\nis not assignable 60 |     v13 = a0; |     ~~~ ^\n/tmp/tmprd9x052w/udp_epoll_handler_name_conflict.c:74:17: error: assignment to cast is\nillegal, lvalue casts are not supported 74 |                 (unsigned int)v15 =\nepoll_wait(v13[5], &v0, 65535, 4294967295); |                 ^~~~~~~~~~~~~~~~~\n~ /tmp/tmprd9x052w/udp_epoll_handler_name_conflict.c:77:25: error: indirection requires\npointer operand ('int' invalid) 77 |                     if\n(*(__errno_location()) == 4) |                         ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int ip_aton(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[3], &val[2], &val[1], &val[0]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long ip_aton_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0xc]\n  char v1;          // [bp-0x8]\n  unsigned long v3; // rax, Other Possible Types: unsigned int\n  struct_0 *v4;     // r9, Other Possible Types: unsigned long\n\n  v0 = 0;\n  if (!a0)\n    return 0;\n  __isoc99_sscanf(a0, \"%hhu.%hhu.%hhu.%hhu\", (unsigned int)&v0,\n                  (unsigned int)&v0, (unsigned int)&v0, (unsigned int)&v0);\n  v4 = &v0;\n  v3 = 0;\n  do {\n    v3 = (unsigned int)v3 * 0x100 | *((char *)v4);\n    v4 = &v0;\n  } while (v4 != &v1);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":0,"function":"int ip_atoh(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[0], &val[1], &val[2], &val[3]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(__isoc99_sscanf)(char *, char *, ...);\n\ntypedef struct struct_0 {\n  char field_0;\n} struct_0;\n\nlong long ip_atoh_name_conflict(char *a0) {\n  unsigned int v0;  // [bp-0xc]\n  char v1;          // [bp-0x8]\n  unsigned long v3; // rax, Other Possible Types: unsigned int\n  struct_0 *v4;     // rdx, Other Possible Types: unsigned long\n\n  v0 = 0;\n  if (!a0)\n    return 0;\n  __isoc99_sscanf(a0, \"%hhu.%hhu.%hhu.%hhu\", (unsigned int)&v0,\n                  (unsigned int)&v0, (unsigned int)&v0, (unsigned int)&v0);\n  v4 = &v0;\n  v3 = 0;\n  do {\n    v3 = (unsigned int)v3 * 0x100 | *((char *)v4);\n    v4 = &v0;\n  } while (v4 != &v1);\n  return v3;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_htoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip >> 24 & 255, sip >> 16 & 255, sip >> 8 & 255, sip & 255);\n    return rvip;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ip_htoa_name_conflict(unsigned long a0, char *a1) {\n  if (a1)\n    sprintf(a1, \"%d.%d.%d.%d\", (unsigned int)a0 / 0x1000000,\n            (unsigned int)(a0 >> 16), (unsigned int)a0 / 0x100, (char)a0);\n  return a1;\n}\n","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_ntoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip & 255, sip >> 8 & 255, sip >> 16 & 255, sip >> 24 & 255);\n    return rvip;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long ip_ntoa_name_conflict(unsigned long a0, char *a1) {\n  if (a1)\n    sprintf(a1, \"%d.%d.%d.%d\", (char)a0, (unsigned int)a0 / 0x100,\n            (unsigned int)(a0 >> 16), (unsigned int)a0 / 0x1000000);\n  return a1;\n}\n","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":0,"function":"int time_wheel_create() {\n    int i;\n    g_cur_slot = 0;\n    for (i = 0; i < 4; i++) {\n        gp_slots[i] = ((void *)0);\n    }\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nextern void *g_405148;\nextern void *g_405150;\nextern void *g_405158;\nextern unsigned int g_cur_slot;\nextern void *gp_slots;\n\nlong long time_wheel_create_name_conflict() {\n  g_cur_slot = 0;\n  gp_slots = 0;\n  g_405148 = 0;\n  g_405150 = 0;\n  g_405158 = 0;\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_destroy() {\n    int i;\n    TIMER_T *pt = ((void *)0);\n    for (i = 0; i < 4; i++) {\n        pt = gp_slots[i];\n        while (pt)\n            {\n                gp_slots[i] = pt->next;\n                free(pt);\n                pt = gp_slots[i];\n            }\n    }\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  struct struct_0 *field_38;\n} struct_0;\n\nextern struct_0 *gp_slots;\n\nlong long time_wheel_destroy_name_conflict() {\n  struct struct_0 **v1; // r12, Other Possible Types: unsigned long\n  struct struct_0 **v2; // rbp\n  struct_0 *v3;         // rbx, Other Possible Types: unsigned long\n  struct_0 *v4;         // rdi\n\n  v1 = &gp_slots;\n  do {\n    v2 = v1;\n    v3 = *((long long *)v1);\n    if (v3) {\n      do {\n        v4 = v3;\n        v3 = *((long long *)(v3 + 56));\n        *(v2) = v3;\n        free(v4);\n      } while (v3);\n    }\n  } while ((v1 += 8, v1 != 4215136));\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_tick() {\n    TIMER_T *pt = gp_slots[g_cur_slot];\n    TIMER_T *pn = ((void *)0);\n    ;\n    while (pt)\n        {\n            ;\n            if (pt->rotation > 0) {\n                pt->rotation--;\n                pt = pt->next;\n            } else {\n                ;\n                pt->cb_func(&pt->proxy_app);\n                if (pt == gp_slots[g_cur_slot]) {\n                    gp_slots[g_cur_slot] = pt->next;\n                    free(pt);\n                    if (gp_slots[g_cur_slot]) {\n                        gp_slots[g_cur_slot]->prev = ((void *)0);\n                    }\n                    pt = gp_slots[g_cur_slot];\n                } else {\n                    pt->prev->next = pt->next;\n                    if (pt->next) {\n                        pt->next->prev = pt->prev;\n                    }\n                    pn = pt->next;\n                    free(pt);\n                    pt = pn;\n                }\n            }\n        }\n    g_cur_slot = ++g_cur_slot % 4;\n    return (0);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_2 {\n  char padding_0[40];\n  unsigned int field_28;\n  char padding_2c[4];\n  struct struct_1 *field_30;\n  struct struct_2 *field_38;\n  struct struct_0 *field_40;\n} struct_2;\n\ntypedef struct struct_1 {\n  struct struct_1 *field_0;\n} struct_1;\n\ntypedef struct struct_0 {\n  char padding_0[56];\n  unsigned long long field_38;\n} struct_0;\n\nextern unsigned int g_cur_slot;\nextern struct_3 gp_slots;\n\nlong long time_wheel_tick_name_conflict() {\n  struct_2 *v1;    // rbx, Other Possible Types: unsigned long\n  unsigned int v2; // eax\n  struct_2 *v3;    // rax\n  unsigned int v4; // eax\n  unsigned int v5; // edx\n\n  v1 = (&gp_slots.field_0)[g_cur_slot];\n  if (!v1) {\n    v4 = g_cur_slot + 1;\n    v5 = v4 >> 31 >> 30;\n    g_cur_slot = (v4 + v5 & 3) - v5;\n    return 0;\n  }\n  while (true) {\n    v2 = *((int *)(v1 + 40));\n    if (v2 > 0) {\n      *((unsigned int *)(v1 + 40)) = v2 - 1;\n      goto LABEL_40232d;\n    } else {\n      *((long long *)(v1 + 48))(v1);\n      if ((&gp_slots.field_0)[g_cur_slot] == v1) {\n        (&gp_slots.field_0)[g_cur_slot] = *((long long *)(v1 + 56));\n        free(v1);\n        v1 = (&gp_slots.field_0)[g_cur_slot];\n        if (!v1)\n          break;\n        *((long long *)(v1 + 64)) = 0;\n      } else {\n        v3 = *((long long *)(v1 + 56));\n        *((struct_2 **)(*((long long *)(v1 + 64)) + 56)) = v3;\n        if (v3)\n          v3->field_40 = *((long long *)(v1 + 64));\n        free(v1);\n      LABEL_40232d:\n        v1 = *((long long *)(v1 + 56));\n        if (!v1)\n          break;\n      }\n    }\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxnb62hrq/time_wheel_tick_name_conflict.c:36:8: error: unknown type name 'struct_3'\n   36 | extern struct_3 gp_slots;\n      |        ^\n/tmp/tmpxnb62hrq/time_wheel_tick_name_conflict.c:64:38: error: called object type 'long long\n*' is not a function or function pointer 64 |             *((long long *)(v1 +\n48))(v1); |              ~~~~~~~~~~~~~~~~~~~~~~~~^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":1,"function":"int *make(int rows, int cols) {\n    return (int *)malloc(rows * cols * sizeof(int));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long make_name_conflict(unsigned long a0, unsigned long a1) {\n  return malloc((unsigned int)a1 * (unsigned int)a0 * 4);\n}\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"int penalty(int *lhs, int *rhs, int mwidth, int *individuum) {\n    int *l = make(mwidth, mwidth);\n    eval(lhs, mwidth, individuum, l);\n    int *r = make(mwidth, mwidth);\n    eval(rhs, mwidth, individuum, r);\n    int s = 0;\n    for (int row = 0; row < mwidth; row++) {\n        for (int col = 0; col < mwidth; col++) {\n            int x = l[row * mwidth + col];\n            int y = r[row * mwidth + col];\n            int p = 0;\n            if ((row == 0) && (col == mwidth - 1)) {\n                p = (x > y) ? 0 : 10000 * (y - x + 1);\n            } else {\n                p = (x >= y) ? 0 : y * y - x * x;\n            }\n            if (p > 1000000)\n                p = 1000000;\n            s += p;\n        }\n    }\n    free(l);\n    free(r);\n    return s;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(make)(long long, long long);\nlong long(eval)(long long, long long, long long, long long);\n\nlong long penalty(unsigned long long a0, unsigned long long a1,\n                  unsigned long long a2, unsigned long long a3) {\n  unsigned long long v1;  // rbp\n  unsigned int *v2;       // r13\n  unsigned int *v3;       // rax\n  unsigned long long v5;  // r11\n  unsigned int *v6;       // rdi\n  unsigned long v7;       // rsi\n  void *v8;               // rcx\n  unsigned long v9;       // rdx\n  unsigned int v10;       // r14d\n  unsigned int v11;       // eax\n  void *v12;              // r15, Other Possible Types: unsigned long\n  unsigned long v13;      // rax, Other Possible Types: unsigned long long\n  void *v16;              // rbx, Other Possible Types: unsigned long\n  unsigned long long v18; // rdi\n  unsigned long long v19; // rsi\n\n  v1 = a2;\n  v2 = make(a2, a2);\n  eval(a0, a2, a3, v2);\n  v3 = make(v1, v1);\n  eval(a1, a2, a3, v3);\n  if ((unsigned int)a2 <= 0) {\n    v16 = 0;\n  } else {\n    v5 = a2 * 4;\n    v6 = v2;\n    v7 = v3;\n    v8 = 0;\n    v16 = 0;\n    do {\n      v9 = 0;\n      do {\n        v10 = v6[v9];\n        v11 = *((int *)(v7 + v9 * 4));\n        if (!(!(unsigned int)v8) ||\n            !((unsigned int)(v1 - 1) == (unsigned int)v9)) {\n          v12 = 0;\n          if (!(v10 < v11))\n            continue;\n          v13 = v11 * (unsigned int)*((unsigned long long *)&v11) - v10 * v10;\n        } else {\n          v12 = v8;\n          if (!(v10 <= v11))\n            continue;\n          v13 = (v11 - v10 + 1) * 10000;\n        }\n        v12 = ((unsigned int)v13 <= 1000000 ? 1000000 : v13);\n      } while ((v16 += v12, v9 += 1, v9 != v1));\n      v18 = (char *)v6 + v5;\n      v19 = v7 + v5;\n    } while ((unsigned int)v1 != (unsigned int)v8 + 1);\n  }\n  free(v2);\n  free(v3);\n  return v16;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7m018c68/penalty.c:75:27: error: invalid operands to binary expression\n('void *' and 'void *') 75 |             } while ((v16 += v12, v9 += 1, v9 !=\nv1)); |                       ~~~ ^  ~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"int anneal(int total, int *lhs, int *rhs, int mcount, int mwidth, int *individuum) {\n    int best = penalty(lhs, rhs, mwidth, individuum);\n    if (0 == best)\n        return 0;\n    size_t s = mcount * mwidth * mwidth * sizeof(int);\n    int *candidate = malloc(s);\n    for (int steps = 0; steps < total; steps++) {\n        memcpy(candidate, individuum, s);\n        mutate(mcount, mwidth, candidate);\n        int p = penalty(lhs, rhs, mwidth, candidate);\n        int luck = 0 == random() % total;\n        if (p <= best || luck) {\n            memcpy(individuum, candidate, s);\n            best = p;\n        }\n    }\n    free(candidate);\n    return best;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint m; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(penalty)(long long, long long, long long, long long);\nlong long(mutate)(long long, long long, long long);\nlong(random)();\n\nlong long anneal(unsigned long a0, unsigned long long a1, unsigned long long a2,\n                 unsigned long a3, unsigned long long a4, void *a5) {\n  unsigned int v0;       // [bp-0x60]\n  unsigned long long v2; // r14, Other Possible Types: unsigned long\n  void *v3;              // rbp\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rax\n\n  v2 = penalty(a1, a2, a4, a5);\n  if (!(unsigned int)v2)\n    return v2;\n  *((unsigned long long *)&v0) =\n      (unsigned int)a4 * (unsigned int)a4 * (unsigned int)a3 * 4;\n  v3 = malloc(*((long long *)&v0));\n  if ((unsigned int)a0 > 0) {\n    do {\n      memcpy(v3, a5, *((long long *)&v0));\n      mutate((unsigned int)a3, a4, v3);\n      v4 = penalty(a1, a2, a4, v3);\n      v5 = random();\n      if (!(v5 >> 63 CONCAT v5) / m a0 >> 64 ||\n          (unsigned int)v4 <= (unsigned int)v2) {\n        memcpy(a5, v3, *((long long *)&v0));\n        v2 = v4;\n      }\n    } while ((unsigned int)a0 != 1);\n  }\n  free(v3);\n  return v2;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1ie1_d6s/anneal.c:42:28: error: expected ')'\n   42 |             if (!(v5 >> 63 CONCAT v5) /m a0 >> 64 || (unsigned int)v4 <=\n(unsigned int)v2) |                            ^\n/tmp/tmp1ie1_d6s/anneal.c:42:18: note: to match this '('\n   42 |             if (!(v5 >> 63 CONCAT v5) /m a0 >> 64 || (unsigned int)v4 <=\n(unsigned int)v2) |                  ^ /tmp/tmp1ie1_d6s/anneal.c:42:42: error:\nexpected ')' 42 |             if (!(v5 >> 63 CONCAT v5) /m a0 >> 64 || (unsigned\nint)v4 <= (unsigned int)v2) |                                          ^\n/tmp/tmp1ie1_d6s/anneal.c:42:16: note: to match this '('\n   42 |             if (!(v5 >> 63 CONCAT v5) /m a0 >> 64 || (unsigned int)v4 <=\n(unsigned int)v2) |                ^ 2 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int bits(int x) {\n    int c = 0;\n    while (x > 0)\n        {\n            x >>= 1;\n            c++;\n        }\n    return c;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long bits_name_conflict(unsigned long long a0) {\n  if ((unsigned int)a0 <= 0)\n    return 0;\n  do {\n    a0 >>= 1;\n  } while ((unsigned int)a0 > 0);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"static inline int timespec_subtract(struct timespec *result, struct timespec *after, struct timespec *before) {\n    result->tv_nsec = after->tv_nsec - before->tv_nsec;\n    if (result->tv_nsec < 0) {\n        result->tv_nsec += 1000000000;\n        result->tv_sec = after->tv_sec - before->tv_sec - 1;\n        return 1;\n    } else {\n        result->tv_sec = after->tv_sec - before->tv_sec;\n        return 0;\n    }\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"char control_letter(size_t rest) {\n    const char sequence[] = \"TRWAGMYFPDXBNJZSQVHLCKE\";\n    if (rest >= sizeof (sequence)) {\n        return '.';\n    } else {\n        return sequence[rest];\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long control_letter_name_conflict(unsigned long a0) {\n  char v0;               // [bp-0x28]\n  unsigned long long v2; // rdx\n  unsigned long v3;      // rax, Other Possible Types: unsigned long long\n\n  v2 = 6006194753032963152;\n  strncpy(&v0, \"TRWAGMYFPDXBNJZSQVHLCKE\", 23);\n  v3 = 46;\n  if (a0 <= 23)\n    v3 = (&v0)[a0];\n  return v3;\n}\n","pass":1,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"int nif_detect_type(const char *nif) {\n    char pos_zero = nif[0];\n    if (((*__ctype_b_loc())[(int)((pos_zero))] & (unsigned short)_ISdigit)) {\n        return 10;\n    } else if (pos_zero == 'X' || pos_zero == 'Y' || pos_zero == 'Z') {\n        return 20;\n    } else {\n        return -20;\n    }\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nif_detect_type_name_conflict(char *a0) {\n  unsigned long long v1; // rbx\n\n  v1 = *(a0);\n  if (!(*((char *)(*((long long *)&__ctype_b_loc()) + ((char)v1 << 1) + 1)) &\n        8))\n    return (-((char)((unsigned int)v1 - 88) < 3) & 40) - 20;\n  return 10;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpn1c4wona/nif_detect_type_name_conflict.c:22:37: error: cannot take the address of an\nrvalue of type 'int' 22 |     if (!(*((char *)(*((long long *)&__ctype_b_loc())\n+ ((char)v1 << 1) + 1)) & 8)) | ^~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"char nie_convert_init_letter(const char *nie) {\n    char ret_val = -1;\n    switch (nie[0]) {\n      case 'X':\n        ret_val = '0';\n        break;\n      case 'Y':\n        ret_val = '1';\n        break;\n      case 'Z':\n        ret_val = '2';\n        break;\n      default:\n        break;\n    }\n    return ret_val;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long nie_convert_init_letter_name_conflict(char *a0) {\n  char v1;          // dl\n  unsigned long v2; // rax, Other Possible Types: unsigned long long\n\n  v1 = *(a0);\n  v2 = 49;\n  if (v1 != 89) {\n    v2 = 50;\n    if (v1 != 90)\n      v2 = (v1 != 88 ? 48 : 4294967295);\n  }\n  return v2;\n}\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"long prepare_nif(const char *nif) {\n    char buf_nif_no_letter[9];\n    memset(buf_nif_no_letter, 0, sizeof (buf_nif_no_letter));\n    for (size_t i = 0; i < sizeof (buf_nif_no_letter) - 1; ++i) {\n        buf_nif_no_letter[i] = nif[i];\n    }\n    int nif_type = nif_detect_type(nif);\n    if (nif_type == 20) {\n        buf_nif_no_letter[0] = nie_convert_init_letter(nif);\n    }\n    char *error_str;\n    long result = strtol(buf_nif_no_letter, &error_str, 10);\n    if (error_str[0]) {\n        result = -20;\n    }\n    return result;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(nif_detect_type)(long long);\nlong long(nie_convert_init_letter)(long long);\n\nlong long prepare_nif_name_conflict(unsigned long a0) {\n  char *v0;         // [bp-0x20]\n  void *v1;         // [bp-0x11], Other Possible Types: char\n  char v2;          // [bp-0x9]\n  unsigned long v3; // [bp-0x8]\n  unsigned long v5; // rbx\n  unsigned long v6; // rax\n\n  v3 = v5;\n  v1 = 0;\n  v2 = 0;\n  v6 = 0;\n  do {\n    (&v1)[v6] = *((char *)(a0 + v6));\n    v6 += 1;\n  } while (v6 != 8);\n  if ((int)nif_detect_type(a0) == 20)\n    v1 = nie_convert_init_letter(a0);\n  if (!*(v0))\n    return strtol(&v1, &v0, 10);\n  return -20;\n}\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"int nif_check_integrity(const char *nif) {\n    size_t nif_size = strlen(nif);\n    if (nif_size != 9) {\n        return -10;\n    }\n    long num_nif = prepare_nif(nif);\n    if (num_nif == -20) {\n        return -20;\n    }\n    int rest = num_nif % 23;\n    return nif[8] == control_letter(rest) ? 1 : 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(prepare_nif)(long long);\nlong long(control_letter)(long long);\n\ntypedef struct struct_0 {\n  char padding_0[8];\n  char field_8;\n} struct_0;\n\nlong long nif_check_integrity_name_conflict(struct_0 *a0) {\n  unsigned long long v1; // rax\n  unsigned long long v3; // rdx\n\n  if (strlen(a0) != 9)\n    return 4294967286;\n  v1 = prepare_nif(a0);\n  if (v1 == -20)\n    return 4294967276;\n  v3 = ((v1 * 12832517616493601125 >> 64) + v1 >> 4) - (v1 >> 63);\n  return a0->field_8 == (char)control_letter(v1 - (v3 * 24 - v3));\n}\n","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"struct Node *newNode(struct Node *sentinel) {\n    struct Node *p;\n    p = (struct Node *)malloc(sizeof(struct Node));\n    if (p == ((void *)0)) {\n        fprintf(stderr, \"Memory allocation error...\\n\");\n        exit(1);\n    }\n    p->label = 0;\n    p->data = 0;\n    p->leftSon = sentinel;\n    p->rightSon = sentinel;\n    p->father = sentinel;\n    p->colour = 0;\n    return p;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  unsigned int field_0;\n  unsigned int field_4;\n  unsigned int field_8;\n  char padding_c[4];\n  unsigned long long field_10;\n  unsigned long long field_18;\n  unsigned long long field_20;\n} struct_0;\n\nextern FILE_t *stderr @GLIBC_2.2.5;\n\nlong long newNode_name_conflict(unsigned long a0) {\n  struct_0 *v1; // rax\n\n  v1 = malloc(40);\n  if (!v1) {\n    fwrite(\"Memory allocation error...\\n\", 1, 27, stderr @GLIBC_2.2.5);\n    exit(1); /* do not return */\n  }\n  v1->field_0 = 0;\n  v1->field_4 = 0;\n  v1->field_18 = a0;\n  v1->field_20 = a0;\n  v1->field_10 = a0;\n  v1->field_8 = 0;\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmptf16c6b9/newNode_name_conflict.c:27:8: error: unknown type name 'FILE_t'; did you mean\n'FILE'? 27 | extern FILE_t *stderr@GLIBC_2.2.5; |        ^~~~~~ |        FILE\n/usr/include/x86_64-linux-gnu/bits/types/FILE.h:7:25: note: 'FILE' declared here\n    7 | typedef struct _IO_FILE FILE;\n      |                         ^\n/tmp/tmptf16c6b9/newNode_name_conflict.c:27:22: error: expected ';' after top level declarator\n   27 | extern FILE_t *stderr@GLIBC_2.2.5;\n      |                      ^\n      |                      ;\n/tmp/tmptf16c6b9/newNode_name_conflict.c:36:61: error: expected ')'\n   36 |         fwrite(\"Memory allocation error...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); | ^ /tmp/tmptf16c6b9/newNode_name_conflict.c:36:15: note: to match this\n'(' 36 |         fwrite(\"Memory allocation error...\\n\", 1, 27,\nstderr@GLIBC_2.2.5); |               ^ 3 errors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/akrzemi1_Mach7/code/msvc/RedBlackTree/AnotherRBTree.c"}
{"compilable":0,"function":"cpu_t init_cpu(uint8_t *opcodes, uint16_t size, uint16_t start_address) {\n    cpu_t cpu = {};\n    int i = 0;\n    cpu.memory_pointer = start_address;\n    while (cpu.memory_pointer < start_address + size && cpu.memory_pointer < 65535)\n        {\n            cpu.memory[cpu.memory_pointer++] = opcodes[i++];\n        }\n    cpu.memory_pointer = start_address;\n    return cpu;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long init_cpu(unsigned long a0, char *a1, unsigned long a2,\n                   unsigned long a3) {\n  char v0;               // [bp-0x20048]\n  char v1;               // [bp-0x2003b]\n  unsigned short v2;     // [bp-0x34]\n  unsigned long long v4; // rbx\n  char *v5;              // rax, Other Possible Types: unsigned long\n  unsigned int v6;       // edi\n  char *v7;              // rcx, Other Possible Types: unsigned long\n  unsigned long v8;      // rdx, Other Possible Types: unsigned int\n\n  v4 = a3;\n  memset(&v0, 0, 131096);\n  v5 = (unsigned short)v4;\n  v6 = (unsigned int)a2 + (unsigned int)v5;\n  if ((unsigned short)v4 != 65535 && (unsigned int)v5 < v6) {\n    v7 = a1;\n    v8 = v4;\n    do {\n      v8 = (unsigned int)v8 + 1;\n      (&v1)[v5] = *((char *)v7);\n      v5 = (unsigned short)v8;\n      v7 += 1;\n    } while ((unsigned short)v8 != 65535 && (unsigned int)v5 < v6);\n  }\n  v2 = v4;\n  return memcpy(*((unsigned long long *)&v6), &v0, 131096);\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpdzjo4646/init_cpu.c:39:18: error: array subscript is not an integer\n   39 |             (&v1)[v5] = *((char *)v7);\n      |                  ^~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint16_t concat_numbers(uint8_t arg1, uint8_t arg2) {\n    return (arg1 << 8) + arg2;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long concat_numbers_name_conflict(unsigned long a0, unsigned long a1) {\n  return a0 * 0x100 + a1;\n}\n","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint16_t get_address_from_registers(cpu_t *cpu, register_t r1, register_t r2) {\n    return concat_numbers(cpu->registers[r1], cpu->registers[r2]);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint get_address_from_registers_name_conflict() {\n  unsigned long long v1; // rdi\n  unsigned long long v2; // rsi\n  unsigned long long v3; // rdx\n\n  sub_40136a(v1, v2, v3); /* do not return */\n}\n","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint8_t pop_stack(cpu_t *cpu) {\n    return cpu->stack[cpu->stack_pointer--];\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\ntypedef struct struct_0 {\n  char padding_0[131086];\n  unsigned short field_2000e;\n} struct_0;\n\nlong long pop_stack_name_conflict(struct_0 *a0) {\n  unsigned long long v1; // rax\n\n  v1 = a0->field_2000e;\n  a0->field_2000e = (unsigned short)v1 - 1;\n  return a0->padding_0[65548 + v1];\n}\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int execute_command(cpu_t *cpu, code_t command) {\n    uint16_t b_address = get_address_from_registers(cpu, REG_C, REG_B);\n    uint16_t d_address = get_address_from_registers(cpu, REG_E, REG_D);\n    uint16_t h_address = get_address_from_registers(cpu, REG_L, REG_H);\n    uint8_t next_byte = cpu->memory[cpu->memory_pointer + 1];\n    switch (command) {\n      case ADD_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A];\n        break;\n      case ADD_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B];\n        break;\n      case ADD_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C];\n        break;\n      case ADD_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D];\n        break;\n      case ADD_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E];\n        break;\n      case ADD_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H];\n        break;\n      case ADD_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L];\n        break;\n      case ADD_M:\n        cpu->registers[REG_A] += cpu->memory[h_address];\n        break;\n      case ADI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer];\n        break;\n      case ADC_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_M:\n        cpu->registers[REG_A] += cpu->memory[h_address] + cpu->flags[CARRY_FLAG];\n        break;\n      case ACI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer] + cpu->flags[CARRY_FLAG];\n        break;\n      case ANA_A:\n        cpu->registers[REG_A] &= cpu->registers[REG_A];\n        break;\n      case ANA_B:\n        cpu->registers[REG_A] &= cpu->registers[REG_B];\n        break;\n      case ANA_C:\n        cpu->registers[REG_A] &= cpu->registers[REG_C];\n        break;\n      case ANA_D:\n        cpu->registers[REG_A] &= cpu->registers[REG_D];\n        break;\n      case ANA_E:\n        cpu->registers[REG_A] &= cpu->registers[REG_E];\n        break;\n      case ANA_H:\n        cpu->registers[REG_A] &= cpu->registers[REG_H];\n        break;\n      case ANA_L:\n        cpu->registers[REG_A] &= cpu->registers[REG_L];\n        break;\n      case ANA_M:\n        cpu->registers[REG_A] &= cpu->memory[h_address];\n        break;\n      case ANI_D8:\n        cpu->registers[REG_A] &= cpu->memory[++cpu->memory_pointer];\n        break;\n      case CALL_A16:\n        break;\n      case CZ_A16:\n        break;\n      case CNZ_A16:\n        break;\n      case CP_A16:\n        break;\n      case CM_A16:\n        break;\n      case CC_A16:\n        break;\n      case CNC_A16:\n        break;\n      case CPE_A16:\n        break;\n      case CPO_A16:\n        break;\n      case CMA:\n        cpu->registers[REG_A] = ~cpu->registers[REG_A];\n        break;\n      case CMC:\n        cpu->flags[CARRY_FLAG] = ~cpu->flags[CARRY_FLAG];\n        break;\n      case CMP_A:\n        set_flag(cpu, ZERO_FLAG, 1);\n        break;\n      case CMP_B:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_B] - cpu->registers[REG_A]));\n        break;\n      case CMP_C:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_D:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_D] - cpu->registers[REG_A]));\n        break;\n      case CMP_E:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_H:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_H] - cpu->registers[REG_A]));\n        break;\n      case CMP_L:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_L] - cpu->registers[REG_A]));\n        break;\n      case CMP_M:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[h_address] - cpu->registers[REG_A]));\n        break;\n      case CPI_D8:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[++cpu->memory_pointer] - cpu->registers[REG_A]));\n        break;\n      case DAA:\n        break;\n      case DAD_B:\n        b_address += h_address;\n        break;\n      case DAD_D:\n        d_address += h_address;\n        break;\n      case DAD_H:\n        h_address += h_address;\n        break;\n      case DAD_SP:\n        cpu->stack_pointer += h_address;\n        break;\n      case DCR_A:\n        cpu->registers[REG_A]--;\n        break;\n      case DCR_B:\n        cpu->registers[REG_B]--;\n        break;\n      case DCR_C:\n        cpu->registers[REG_C]--;\n        break;\n      case DCR_D:\n        cpu->registers[REG_D]--;\n        break;\n      case DCR_E:\n        cpu->registers[REG_E]--;\n        break;\n      case DCR_H:\n        cpu->registers[REG_H]--;\n        break;\n      case DCR_L:\n        cpu->registers[REG_L]--;\n        break;\n      case DCR_M:\n        cpu->memory[h_address]--;\n        break;\n      case DCX_B:\n        b_address--;\n        break;\n      case DCX_D:\n        d_address--;\n        break;\n      case DCX_H:\n        h_address--;\n        break;\n      case DCX_SP:\n        cpu->stack_pointer--;\n        break;\n      case DI:\n        cpu->interrupts_enabled = 0;\n        break;\n      case EI:\n        cpu->interrupts_enabled = 1;\n        break;\n      case IN_PP:\n        break;\n      case INR_A:\n        cpu->registers[REG_A]++;\n        break;\n      case INR_B:\n        cpu->registers[REG_B]++;\n        break;\n      case INR_C:\n        cpu->registers[REG_C]++;\n        break;\n      case INR_D:\n        cpu->registers[REG_D]++;\n        break;\n      case INR_E:\n        cpu->registers[REG_E]++;\n        break;\n      case INR_H:\n        cpu->registers[REG_H]++;\n        break;\n      case INR_L:\n        cpu->registers[REG_L]++;\n        break;\n      case INR_M:\n        cpu->memory[h_address]++;\n        break;\n      case INX_B:\n        b_address++;\n        break;\n      case INX_D:\n        d_address++;\n        break;\n      case INX_H:\n        h_address++;\n        break;\n      case INX_SP:\n        cpu->stack_pointer++;\n        break;\n      case JMP_A16:\n        cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JZ_A16:\n        if (cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNZ_A16:\n        if (!cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JP_A16:\n        break;\n      case JM_A16:\n        break;\n      case JC_A16:\n        if (cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNC_A16:\n        if (!cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPE_A16:\n        if (cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPO_A16:\n        if (!cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case LDA_A16:\n        cpu->registers[REG_A] = cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])];\n        break;\n      case LDAX_B:\n        cpu->registers[REG_A] = cpu->memory[b_address];\n        break;\n      case LDAX_D:\n        cpu->registers[REG_A] = cpu->memory[d_address];\n        break;\n      case LHLD_A16:\n        cpu->registers[REG_L] = (uint8_t)(cpu->memory[h_address] & 255);\n        cpu->registers[REG_H] = (uint8_t)(cpu->memory[h_address] >> 8);\n        break;\n      case LXI_B_D16:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_H_D16:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_SP_D16:\n        cpu->stack_pointer = concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer]);\n        break;\n      case MOV_A_A:\n        cpu->registers[REG_A] = cpu->registers[REG_A];\n        break;\n      case MOV_A_B:\n        cpu->registers[REG_A] = cpu->registers[REG_B];\n        break;\n      case MOV_A_C:\n        cpu->registers[REG_A] = cpu->registers[REG_C];\n        break;\n      case MOV_A_D:\n        cpu->registers[REG_A] = cpu->registers[REG_D];\n        break;\n      case MOV_A_E:\n        cpu->registers[REG_A] = cpu->registers[REG_E];\n        break;\n      case MOV_A_H:\n        cpu->registers[REG_A] = cpu->registers[REG_H];\n        break;\n      case MOV_A_L:\n        cpu->registers[REG_A] = cpu->registers[REG_L];\n        break;\n      case MOV_A_M:\n        cpu->registers[REG_A] = cpu->memory[h_address];\n        break;\n      case MOV_B_A:\n        cpu->registers[REG_B] = cpu->registers[REG_A];\n        break;\n      case MOV_B_B:\n        cpu->registers[REG_B] = cpu->registers[REG_B];\n        break;\n      case MOV_B_C:\n        cpu->registers[REG_B] = cpu->registers[REG_C];\n        break;\n      case MOV_B_D:\n        cpu->registers[REG_B] = cpu->registers[REG_D];\n        break;\n      case MOV_B_E:\n        cpu->registers[REG_B] = cpu->registers[REG_E];\n        break;\n      case MOV_B_H:\n        cpu->registers[REG_B] = cpu->registers[REG_H];\n        break;\n      case MOV_B_L:\n        cpu->registers[REG_B] = cpu->registers[REG_L];\n        break;\n      case MOV_B_M:\n        cpu->registers[REG_B] = cpu->memory[h_address];\n        break;\n      case MOV_C_A:\n        cpu->registers[REG_C] = cpu->registers[REG_A];\n        break;\n      case MOV_C_B:\n        cpu->registers[REG_C] = cpu->registers[REG_B];\n        break;\n      case MOV_C_C:\n        cpu->registers[REG_C] = cpu->registers[REG_C];\n        break;\n      case MOV_C_D:\n        cpu->registers[REG_C] = cpu->registers[REG_D];\n        break;\n      case MOV_C_E:\n        cpu->registers[REG_C] = cpu->registers[REG_E];\n        break;\n      case MOV_C_H:\n        cpu->registers[REG_C] = cpu->registers[REG_H];\n        break;\n      case MOV_C_L:\n        cpu->registers[REG_C] = cpu->registers[REG_L];\n        break;\n      case MOV_C_M:\n        cpu->registers[REG_C] = cpu->memory[h_address];\n        break;\n      case MOV_D_A:\n        cpu->registers[REG_D] = cpu->registers[REG_A];\n        break;\n      case MOV_D_B:\n        cpu->registers[REG_D] = cpu->registers[REG_B];\n        break;\n      case MOV_D_C:\n        cpu->registers[REG_D] = cpu->registers[REG_C];\n        break;\n      case MOV_D_D:\n        cpu->registers[REG_D] = cpu->registers[REG_D];\n        break;\n      case MOV_D_E:\n        cpu->registers[REG_D] = cpu->registers[REG_E];\n        break;\n      case MOV_D_H:\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        break;\n      case MOV_D_L:\n        cpu->registers[REG_D] = cpu->registers[REG_L];\n        break;\n      case MOV_D_M:\n        cpu->registers[REG_D] = cpu->memory[h_address];\n        break;\n      case MOV_E_A:\n        cpu->registers[REG_E] = cpu->registers[REG_A];\n        break;\n      case MOV_E_B:\n        cpu->registers[REG_E] = cpu->registers[REG_B];\n        break;\n      case MOV_E_C:\n        cpu->registers[REG_E] = cpu->registers[REG_C];\n        break;\n      case MOV_E_D:\n        cpu->registers[REG_E] = cpu->registers[REG_D];\n        break;\n      case MOV_E_E:\n        cpu->registers[REG_E] = cpu->registers[REG_E];\n        break;\n      case MOV_E_H:\n        cpu->registers[REG_E] = cpu->registers[REG_H];\n        break;\n      case MOV_E_L:\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        break;\n      case MOV_E_M:\n        cpu->registers[REG_E] = cpu->memory[h_address];\n        break;\n      case MOV_H_A:\n        cpu->registers[REG_H] = cpu->registers[REG_A];\n        break;\n      case MOV_H_B:\n        cpu->registers[REG_H] = cpu->registers[REG_B];\n        break;\n      case MOV_H_C:\n        cpu->registers[REG_H] = cpu->registers[REG_C];\n        break;\n      case MOV_H_D:\n        cpu->registers[REG_H] = cpu->registers[REG_D];\n        break;\n      case MOV_H_E:\n        cpu->registers[REG_H] = cpu->registers[REG_E];\n        break;\n      case MOV_H_H:\n        cpu->registers[REG_H] = cpu->registers[REG_H];\n        break;\n      case MOV_H_L:\n        cpu->registers[REG_H] = cpu->registers[REG_L];\n        break;\n      case MOV_H_M:\n        cpu->registers[REG_H] = cpu->memory[h_address];\n        break;\n      case MOV_L_A:\n        cpu->registers[REG_L] = cpu->registers[REG_A];\n        break;\n      case MOV_L_B:\n        cpu->registers[REG_L] = cpu->registers[REG_B];\n        break;\n      case MOV_L_C:\n        cpu->registers[REG_L] = cpu->registers[REG_C];\n        break;\n      case MOV_L_D:\n        cpu->registers[REG_L] = cpu->registers[REG_D];\n        break;\n      case MOV_L_E:\n        cpu->registers[REG_L] = cpu->registers[REG_E];\n        break;\n      case MOV_L_H:\n        cpu->registers[REG_L] = cpu->registers[REG_H];\n        break;\n      case MOV_L_L:\n        cpu->registers[REG_L] = cpu->registers[REG_L];\n        break;\n      case MOV_L_M:\n        cpu->registers[REG_L] = cpu->memory[h_address];\n        break;\n      case MOV_M_A:\n        cpu->memory[h_address] = cpu->registers[REG_A];\n        break;\n      case MOV_M_B:\n        cpu->memory[h_address] = cpu->registers[REG_B];\n        break;\n      case MOV_M_C:\n        cpu->memory[h_address] = cpu->registers[REG_C];\n        break;\n      case MOV_M_D:\n        cpu->memory[h_address] = cpu->registers[REG_D];\n        break;\n      case MOV_M_E:\n        cpu->memory[h_address] = cpu->registers[REG_E];\n        break;\n      case MOV_M_H:\n        cpu->memory[h_address] = cpu->registers[REG_H];\n        break;\n      case MOV_M_L:\n        cpu->memory[h_address] = cpu->registers[REG_L];\n        break;\n      case MVI_A_D8:\n        cpu->registers[REG_A] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_B_D8:\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_C_D8:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_D_D8:\n        cpu->registers[REG_D] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_E_D8:\n        cpu->registers[REG_E] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_H_D8:\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_L_D8:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_M_D8:\n        cpu->memory[h_address] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case ORA_A:\n        cpu->registers[REG_A] |= cpu->registers[REG_A];\n        break;\n      case ORA_B:\n        cpu->registers[REG_A] |= cpu->registers[REG_B];\n        break;\n      case ORA_C:\n        cpu->registers[REG_A] |= cpu->registers[REG_C];\n        break;\n      case ORA_D:\n        cpu->registers[REG_A] |= cpu->registers[REG_D];\n        break;\n      case ORA_E:\n        cpu->registers[REG_A] |= cpu->registers[REG_E];\n        break;\n      case ORA_H:\n        cpu->registers[REG_A] |= cpu->registers[REG_H];\n        break;\n      case ORA_L:\n        cpu->registers[REG_A] |= cpu->registers[REG_L];\n        break;\n      case ORA_M:\n        cpu->registers[REG_A] |= cpu->memory[h_address];\n        break;\n      case ORI_D8:\n        cpu->registers[REG_A] |= cpu->memory[++cpu->memory_pointer];\n        break;\n      case OUT_PP:\n        break;\n      case PCHL:\n        break;\n      case POP_B:\n        break;\n      case POP_D:\n        break;\n      case POP_H:\n        break;\n      case POP_PSW:\n        break;\n      case PUSH_B:\n        break;\n      case PUSH_D:\n        break;\n      case PUSH_H:\n        break;\n      case PUSH_PSW:\n        break;\n      case RAL:\n        break;\n      case RAR:\n        break;\n      case RLC:\n        break;\n      case RRC:\n        break;\n      case RIM:\n        break;\n      case RET:\n        break;\n      case RZ:\n        break;\n      case RNZ:\n        break;\n      case RP:\n        break;\n      case RM:\n        break;\n      case RC:\n        break;\n      case RNC:\n        break;\n      case RPE:\n        break;\n      case RPO:\n        break;\n      case RST_0:\n        break;\n      case RST_1:\n        break;\n      case RST_2:\n        break;\n      case RST_3:\n        break;\n      case RST_4:\n        break;\n      case RST_5:\n        break;\n      case RST_6:\n        break;\n      case RST_7:\n        break;\n      case SIM:\n        break;\n      case SPHL:\n        cpu->stack_pointer = h_address;\n        break;\n      case SHLD_A16:\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_L];\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_H];\n        break;\n      case STA_A16:\n        cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])] = cpu->registers[REG_A];\n        break;\n      case STAX_B:\n        cpu->memory[b_address] = cpu->registers[REG_A];\n        break;\n      case STAX_D:\n        cpu->memory[d_address] = cpu->registers[REG_A];\n        break;\n      case STC:\n        set_flag(cpu, CARRY_FLAG, 1);\n        break;\n      case SUB_A:\n        cpu->registers[REG_A] -= cpu->registers[REG_A];\n        break;\n      case SUB_B:\n        cpu->registers[REG_A] -= cpu->registers[REG_B];\n        break;\n      case SUB_C:\n        cpu->registers[REG_A] -= cpu->registers[REG_C];\n        break;\n      case SUB_D:\n        cpu->registers[REG_A] -= cpu->registers[REG_D];\n        break;\n      case SUB_E:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_H:\n        cpu->registers[REG_A] -= cpu->registers[REG_H];\n        break;\n      case SUB_L:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_M:\n        cpu->registers[REG_A] -= cpu->memory[h_address];\n        break;\n      case SUI_D8:\n        cpu->registers[REG_A] -= cpu->memory[++cpu->memory_pointer];\n        break;\n      case SBB_A:\n        break;\n      case SBB_B:\n        break;\n      case SBB_C:\n        break;\n      case SBB_D:\n        break;\n      case SBB_E:\n        break;\n      case SBB_H:\n        break;\n      case SBB_L:\n        break;\n      case SBB_M:\n        break;\n      case SBI_D8:\n        break;\n      case XCHG:\n        push_stack(cpu, cpu->registers[REG_E]);\n        push_stack(cpu, cpu->registers[REG_D]);\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        cpu->registers[REG_L] = pop_stack(cpu);\n        cpu->registers[REG_H] = pop_stack(cpu);\n        break;\n      case XTHL:\n        break;\n      case XRA_A:\n        cpu->registers[REG_A] ^= cpu->registers[REG_A];\n        break;\n      case XRA_B:\n        cpu->registers[REG_A] ^= cpu->registers[REG_B];\n        break;\n      case XRA_C:\n        cpu->registers[REG_A] ^= cpu->registers[REG_C];\n        break;\n      case XRA_D:\n        cpu->registers[REG_A] ^= cpu->registers[REG_D];\n        break;\n      case XRA_E:\n        cpu->registers[REG_A] ^= cpu->registers[REG_E];\n        break;\n      case XRA_H:\n        cpu->registers[REG_A] ^= cpu->registers[REG_H];\n        break;\n      case XRA_L:\n        cpu->registers[REG_A] ^= cpu->registers[REG_L];\n        break;\n      case XRA_M:\n        cpu->registers[REG_A] ^= cpu->memory[h_address];\n        break;\n      case XRI_D8:\n        cpu->registers[REG_A] ^= cpu->memory[++cpu->memory_pointer];\n        break;\n      case NOP:\n      case HLT:\n        return 0;\n    }\n    cpu->program_counter = cpu->memory_pointer++;\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(push_stack)(long long, long long);\nlong long(pop_stack)(long long);\n\ntypedef struct struct_0 {\n  char field_0;\n  char field_1;\n  char field_2;\n  char field_3;\n  char field_4;\n  char field_5;\n  char field_6;\n  char padding_7[1];\n  char field_8;\n  char field_9;\n  char padding_a[1];\n  char field_b;\n  char padding_c[131072];\n  unsigned short field_2000c;\n  unsigned short field_2000e;\n  char padding_20010[4];\n  unsigned short field_20014;\n  char field_20016;\n} struct_0;\n\nlong long execute_command_name_conflict(struct_0 *a0, unsigned long a1) {\n  unsigned short v0;      // [bp-0x32]\n  struct_0 *v2;           // rbx\n  unsigned long long v3;  // r11\n  unsigned long long v4;  // r10\n  unsigned long v5;       // rcx\n  unsigned long long v6;  // rbp\n  unsigned long long v7;  // r9\n  unsigned long long v8;  // r12\n  unsigned long long v9;  // r13\n  unsigned long v10;      // rdx\n  unsigned long long v11; // rdi\n  unsigned long v12;      // r14\n  unsigned long long v13; // r8\n  unsigned long long v14; // r15\n  unsigned long long v15; // rdx\n  unsigned long long v16; // rdi\n  unsigned long long v17; // rdi\n  unsigned long long v18; // rdi\n  unsigned short v19;     // dx\n  unsigned long long v20; // rdi\n  unsigned long long v21; // rdi\n  unsigned long long v22; // rdx\n  unsigned long long v23; // rdi\n  unsigned short v24;     // ax\n\n  v2 = a0;\n  v3 = a0->field_1;\n  v4 = a0->field_2;\n  v5 = (unsigned int)v4 * 0x100 + (char)v3;\n  v6 = a0->field_3;\n  v7 = a0->field_4;\n  v0 = v7 * 0x100 + (char)v6;\n  v8 = a0->field_5;\n  v9 = a0->field_6;\n  v10 = (unsigned int)v9 * 0x100 + (char)v8;\n  v11 = a0->field_20014;\n  v12 = (unsigned short)v11;\n  v13 = v12 + 1;\n  v14 = v2->padding_c[1 + v13];\n  switch ((unsigned int)a1) {\n  case 2:\n    v2->padding_c[1 + v5] = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 4:\n    v2->field_1 = (unsigned int)v3 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 5:\n    v2->field_1 = (unsigned int)v3 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 6:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_1 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 10:\n    v2->field_0 = v2->padding_c[1 + v5];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 12:\n    v2->field_2 = (unsigned int)v4 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 13:\n    v2->field_2 = (unsigned int)v4 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 14:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_2 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 18:\n    v2->padding_c[1 + v0] = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 20:\n    v2->field_3 = (unsigned int)v6 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 21:\n    v2->field_3 = (unsigned int)v6 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 22:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_3 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 26:\n    v2->field_0 = v2->padding_c[1 + v0];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 28:\n    v2->field_4 = (unsigned int)v7 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 29:\n    v2->field_4 = (unsigned int)v7 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 30:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_4 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 33:\n    v2->field_6 = v2->padding_c[1 + v13];\n    v18 = (unsigned int)v11 + 2;\n    v2->field_20014 = v18;\n    v2->field_5 = v2->padding_c[1 + v18];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 34:\n    v2->padding_c[1 + v13] = v9;\n    v21 = (unsigned int)v11 + 2;\n    v2->field_20014 = v21;\n    v2->padding_c[1 + v21] = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 36:\n    v2->field_5 = (unsigned int)v8 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 37:\n    v2->field_5 = (unsigned int)v8 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 38:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_5 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 42:\n    v2->field_6 = v2->padding_c[1 + v10];\n    v2->field_5 = 0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 44:\n    v2->field_6 = (unsigned int)v9 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 45:\n    v2->field_6 = (unsigned int)v9 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 46:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_6 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 47:\n    v2->field_0 = ~(v2->field_0);\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 49:\n    v19 = v2->padding_c[1 + v13];\n    v20 = (unsigned int)v11 + 2;\n    v2->field_20014 = v20;\n    v2->field_2000e = (unsigned short)(v2->padding_c[1 + v20] * 0x100) + v19;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 50:\n    v22 = v2->padding_c[1 + v13];\n    v23 = (unsigned int)v11 + 2;\n    v2->field_20014 = v23;\n    v2->padding_c[1 + 0x100 * v2->padding_c[1 + v23] + v22] = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 51:\n    v2->field_2000e = v2->field_2000e + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 52:\n    v2->padding_c[1 + v10] = v2->padding_c[1 + v10] + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 53:\n    v2->padding_c[1 + v10] = v2->padding_c[1 + v10] - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 54:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->padding_c[1 + v10] = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 55:\n    v2->field_8 = 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 57:\n    v2->field_2000e = v2->field_2000e + (unsigned short)v10;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 58:\n    v15 = v2->padding_c[1 + v13];\n    v16 = (unsigned int)v11 + 2;\n    v2->field_20014 = v16;\n    v2->field_0 = v2->padding_c[1 + 0x100 * v2->padding_c[1 + v16] + v15];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 59:\n    v2->field_2000e = v2->field_2000e - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 60:\n    v2->field_0 = v2->field_0 + 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 61:\n    v2->field_0 = v2->field_0 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 62:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 63:\n    v2->field_8 = 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 65:\n    v2->field_1 = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 66:\n    v2->field_1 = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 67:\n    v2->field_1 = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 68:\n    v2->field_1 = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 69:\n    v2->field_1 = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 70:\n    v2->field_1 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 71:\n    v2->field_1 = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 72:\n    v2->field_2 = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 74:\n    v2->field_2 = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 75:\n    v2->field_2 = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 76:\n    v2->field_2 = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 77:\n    v2->field_2 = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 78:\n    v2->field_2 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 79:\n    v2->field_2 = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 80:\n    v2->field_3 = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 81:\n    v2->field_3 = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 83:\n    v2->field_3 = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 84:\n    v2->field_3 = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 85:\n    v2->field_3 = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 86:\n    v2->field_3 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 87:\n    v2->field_3 = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 88:\n    v2->field_4 = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 89:\n    v2->field_4 = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 90:\n    v2->field_4 = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 92:\n    v2->field_4 = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 93:\n    v2->field_4 = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 94:\n    v2->field_4 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 95:\n    v2->field_4 = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 96:\n    v2->field_5 = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 97:\n    v2->field_5 = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 98:\n    v2->field_5 = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 99:\n    v2->field_5 = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 101:\n    v2->field_5 = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 102:\n    v2->field_5 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 103:\n    v2->field_5 = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 104:\n    v2->field_6 = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 105:\n    v2->field_6 = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 106:\n    v2->field_6 = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 107:\n    v2->field_6 = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 108:\n    v2->field_6 = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 110:\n    v2->field_6 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 111:\n    v2->field_6 = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 112:\n    v2->padding_c[1 + v10] = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 113:\n    v2->padding_c[1 + v10] = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 114:\n    v2->padding_c[1 + v10] = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 115:\n    v2->padding_c[1 + v10] = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 116:\n    v2->padding_c[1 + v10] = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 117:\n    v2->padding_c[1 + v10] = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 119:\n    v2->padding_c[1 + v10] = v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 120:\n    v2->field_0 = v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 121:\n    v2->field_0 = v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 122:\n    v2->field_0 = v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 123:\n    v2->field_0 = v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 124:\n    v2->field_0 = v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 125:\n    v2->field_0 = v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 126:\n    v2->field_0 = v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 128:\n    v2->field_0 = v2->field_0 + (char)v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 129:\n    v2->field_0 = v2->field_0 + (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 130:\n    v2->field_0 = v2->field_0 + (char)v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 131:\n    v2->field_0 = v2->field_0 + (char)v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 132:\n    v2->field_0 = v2->field_0 + (char)v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 133:\n    v2->field_0 = v2->field_0 + (char)v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 134:\n    v2->field_0 = v2->field_0 + v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 135:\n    v2->field_0 = v2->field_0 * 2;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 136:\n    v2->field_0 = v2->field_0 + (char)v3 + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 137:\n    v2->field_0 = v2->field_0 + (char)v4 + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 138:\n    v2->field_0 = v2->field_0 + (char)v6 + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 139:\n    v2->field_0 = v2->field_0 + (char)v7 + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 140:\n    v2->field_0 = v2->field_0 + (char)v8 + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 141:\n    v2->field_0 = v2->field_0 + (char)v9 + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 142:\n    v2->field_0 = v2->field_8 + v2->field_0 + v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 143:\n    v2->field_0 = v2->field_8 + v2->field_0 * 2;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 144:\n    v2->field_0 = v2->field_0 - (char)v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 145:\n    v2->field_0 = v2->field_0 - (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 146:\n    v2->field_0 = v2->field_0 - (char)v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 147:\n    v2->field_0 = v2->field_0 - (char)v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 148:\n    v2->field_0 = v2->field_0 - (char)v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 149:\n    v2->field_0 = v2->field_0 - (char)v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 150:\n    v2->field_0 = v2->field_0 - v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 151:\n    v2->field_0 = 0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 160:\n    v2->field_0 = v2->field_0 & (char)v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 161:\n    v2->field_0 = v2->field_0 & (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 162:\n    v2->field_0 = v2->field_0 & (char)v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 163:\n    v2->field_0 = v2->field_0 & (char)v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 164:\n    v2->field_0 = v2->field_0 & (char)v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 165:\n    v2->field_0 = v2->field_0 & (char)v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 166:\n    v2->field_0 = v2->field_0 & v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 168:\n    v2->field_0 = v2->field_0 ^ (char)v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 169:\n    v2->field_0 = v2->field_0 ^ (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 170:\n    v2->field_0 = v2->field_0 ^ (char)v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 171:\n    v2->field_0 = v2->field_0 ^ (char)v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 172:\n    v2->field_0 = v2->field_0 ^ (char)v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 173:\n    v2->field_0 = v2->field_0 ^ (char)v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 174:\n    v2->field_0 = v2->field_0 ^ v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 175:\n    v2->field_0 = 0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 176:\n    v2->field_0 = v2->field_0 | (char)v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 177:\n    v2->field_0 = v2->field_0 | (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 178:\n    v2->field_0 = v2->field_0 | (char)v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 179:\n    v2->field_0 = v2->field_0 | (char)v7;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 180:\n    v2->field_0 = v2->field_0 | (char)v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 181:\n    v2->field_0 = v2->field_0 | (char)v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 182:\n    v2->field_0 = v2->field_0 | v2->padding_c[1 + v10];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 184:\n    v2->field_b = v2->field_0 != (char)v3;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 185:\n    v2->field_b = v2->field_0 != (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 186:\n    v2->field_b = v2->field_0 != (char)v6;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 187:\n    v2->field_b = v2->field_0 != (char)v4;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 188:\n    v2->field_b = v2->field_0 != (char)v8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 189:\n    v2->field_b = v2->field_0 != (char)v9;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 190:\n    v2->field_b = v2->padding_c[1 + v10] != v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 191:\n    v2->field_b = 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 194:\n    if (!v2->field_b) {\n      v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n      v24 = v2->field_20014;\n      v2->field_20014 = v24 + 1;\n      v2->field_2000c = v24;\n      break;\n    }\n  case 195:\n    v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 198:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->field_0 + v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 202:\n    if (v2->field_b) {\n      v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n      v24 = v2->field_20014;\n      v2->field_20014 = v24 + 1;\n      v2->field_2000c = v24;\n      break;\n    }\n  case 206:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->field_0 + v2->padding_c[1 + v13] + v2->field_8;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 210:\n    if (!v2->field_8) {\n      v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n      v24 = v2->field_20014;\n      v2->field_20014 = v24 + 1;\n      v2->field_2000c = v24;\n      break;\n    }\n  case 214:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->field_0 - v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 218:\n    if (v2->field_8) {\n      v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n      v24 = v2->field_20014;\n      v2->field_20014 = v24 + 1;\n      v2->field_2000c = v24;\n      break;\n    }\n  case 226:\n    if (!v2->field_9) {\n      v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n      v24 = v2->field_20014;\n      v2->field_20014 = v24 + 1;\n      v2->field_2000c = v24;\n      break;\n    }\n  case 230:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->field_0 & v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 234:\n    if (v2->field_9) {\n      v2->field_20014 = v2->padding_c[3 + v12] * 0x100 + v14 - 1;\n      v24 = v2->field_20014;\n      v2->field_20014 = v24 + 1;\n      v2->field_2000c = v24;\n      break;\n    }\n  case 235:\n    push_stack(v2, (char)v7);\n    push_stack(v2, (char)v6);\n    v2->field_4 = v9;\n    v2->field_3 = v8;\n    v2->field_6 = pop_stack(v2);\n    v2->field_5 = pop_stack(v2);\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 238:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->field_0 ^ v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 243:\n    v2->field_20016 = 0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 246:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_0 = v2->field_0 | v2->padding_c[1 + v13];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 249:\n    v2->field_2000e = v10;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 251:\n    v2->field_20016 = 1;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 254:\n    v2->field_20014 = (unsigned int)v11 + 1;\n    v2->field_b = v2->padding_c[1 + v13] != v2->field_0;\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  case 1:\n    v2->field_2 = v2->padding_c[1 + v13];\n    v17 = (unsigned int)v11 + 2;\n    v2->field_20014 = v17;\n    v2->field_1 = v2->padding_c[1 + v17];\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n  case 0:\n  case 118:\n    return 0;\n  default:\n    v24 = v2->field_20014;\n    v2->field_20014 = v24 + 1;\n    v2->field_2000c = v24;\n    break;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"int execute(cpu_t *cpu) {\n    while (cpu->memory[cpu->memory_pointer] != HLT && cpu->memory_pointer < 65535)\n        {\n            execute_command(cpu, (code_t)cpu->memory[cpu->memory_pointer]);\n        }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(execute_name_conflict_command)(long long, long long);\n\ntypedef struct struct_0 {\n  char padding_0[131092];\n  unsigned short field_20014;\n} struct_0;\n\nlong long execute_name_conflict(struct_0 *a0) {\n  unsigned long v0;      // [bp-0x8]\n  unsigned long long v2; // rax\n  unsigned long v3;      // rsi, Other Possible Types: unsigned long long\n  unsigned long v4;      // rbx\n  unsigned long long v5; // rax\n\n  v2 = a0->field_20014;\n  v3 = a0->padding_0[13 + (unsigned short)v2];\n  if ((unsigned short)v2 == 65535)\n    return 0;\n  v0 = v4;\n  if ((char)v3 == 118)\n    return 0;\n  while ((unsigned short)v5 != 65535) {\n    execute_name_conflict_command(a0, v3);\n    v5 = a0->field_20014;\n    v3 = a0->padding_0[13 + (unsigned short)v5];\n    if ((char)v3 == 118)\n      return 0;\n  }\n  return 0;\n}\n","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxnail9l9/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() { return strerror(*(__errno_location())); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpmhbpumhb/k_strerr_name_conflict.c:20:21: error: indirection requires pointer operand\n('int' invalid) 20 |     return strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long k_chbindir_name_conflict() {\n  void *v0;               // [bp-0x108]\n  int tmp_17;             // tmp #17\n  void *v1;               // [bp-0x100]\n  void *v2;               // [bp-0xf8]\n  void *v3;               // [bp-0xf0]\n  void *v4;               // [bp-0xe8]\n  void *v5;               // [bp-0xe0]\n  void *v6;               // [bp-0xd8]\n  void *v7;               // [bp-0xd0]\n  void *v8;               // [bp-0xc8]\n  void *v9;               // [bp-0xc0]\n  void *v10;              // [bp-0xb8]\n  void *v11;              // [bp-0xb0]\n  void *v12;              // [bp-0xa8]\n  void *v13;              // [bp-0xa0]\n  void *v14;              // [bp-0x98]\n  void *v15;              // [bp-0x90]\n  void *v16;              // [bp-0x88]\n  void *v17;              // [bp-0x80]\n  void *v18;              // [bp-0x78]\n  void *v19;              // [bp-0x70]\n  void *v20;              // [bp-0x68]\n  void *v21;              // [bp-0x60]\n  void *v22;              // [bp-0x58]\n  void *v23;              // [bp-0x50]\n  void *v24;              // [bp-0x48]\n  void *v25;              // [bp-0x40]\n  void *v26;              // [bp-0x38]\n  void *v27;              // [bp-0x30]\n  void *v28;              // [bp-0x28]\n  void *v29;              // [bp-0x20]\n  void *v30;              // [bp-0x18]\n  void *v31;              // [bp-0x10]\n  unsigned long long v33; // rax\n  struct_0 *v35;          // rax, Other Possible Types: unsigned long\n  unsigned long v36;      // rdx\n  char v37;               // cl\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v33 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if ((unsigned int)v33 <= 0)\n    return 1;\n  v36 = v33 - 1;\n  v37 = *((char *)&v0 + v36);\n  if ((unsigned int)v36 && v37 != 47) {\n    v35 = (char *)&v0 + v33;\n    do {\n      *((char *)(v35 - 1)) = 0;\n      v37 = *((char *)(v35 - 2));\n      v35 -= 1;\n      tmp_17 = v36;\n      v36 = (unsigned int)v36 - 1;\n    } while ((int)tmp_17 != 1 && v37 != 47);\n  }\n  if (v37 != 47)\n    return 1;\n  if (!(unsigned int)v36)\n    return chdir(&v0);\n  *((char *)&v0 + v36) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps8sbvumy/k_chbindir_name_conflict.c:20:16: error: expected ';' at end of declaration\nlist 20 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xb8]\n  unsigned int v1;       // [bp-0xb0]\n  unsigned int v2;       // [bp-0x30]\n  unsigned long long v3; // [bp-0x18]\n  unsigned long long v4; // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  v3 = -1;\n  setrlimit(4, &v3);\n  getrlimit(6, &v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;               // [bp-0xa8]\n  unsigned int v1;       // [bp-0xa0]\n  unsigned int v2;       // [bp-0x20]\n  unsigned long long v4; // rax\n\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  (unsigned int)v4 = fork();\n  if ((unsigned int)v4 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if ((unsigned int)v4 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    if (setsid() >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuvz8kl0o/k_demon_name_conflict.c:35:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 35 |     (unsigned int)v4 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpuvz8kl0o/k_demon_name_conflict.c:38:29: error: indirection requires pointer operand\n('int' invalid) 38 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpuvz8kl0o/k_demon_name_conflict.c:54:31: error: indirection\nrequires pointer operand ('int' invalid) 54 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned long long v0;  // [bp-0xb8]\n  unsigned long long v1;  // [bp-0xb0]\n  unsigned long long v2;  // [bp-0xa8]\n  char v3;                // [bp-0xa0]\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v6; // rdi, Other Possible Types: unsigned long\n  unsigned long v7;       // d\n\n  v5 = 18;\n  for (v6 = &v3; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  v0 = 0x2800;\n  setrlimit(7, &v0);\n  getrlimit(7, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  while ((unsigned int)v1 == -1) {\n    v1 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpfjvcwnl1/ksock_close_name_conflict.c:25:13: error: indirection requires pointer\noperand ('int' invalid) 25 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long v1; // rax, Other Possible Types: unsigned long long\n\n  (unsigned int)v1 = ioctl(a0, a1);\n  if ((unsigned int)v1) {\n    printf(\"ioctl :%s\\n\", (int)k_strerr());\n    return 1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpvfzkqlil/ksock_ioctl_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v1 = ioctl(a0, a1); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v1; // rbx\n\n  strcpy(a2, inet_ntoa());\n  v1 = a0 / 0x10000;\n  *((unsigned short *)&v1) = __ROL__((unsigned short)v1, 8);\n  *(a3) = v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp3lp2s54d/ksock_from_addr.c:24:26: error: too few arguments to function\ncall, expected 1, have 0 24 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp3lp2s54d/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = __ROL__((unsigned short)a2, 8);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 1;\n  if (setsockopt(a0, 1, 2, &v0, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &v0, 4) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x24]\n  unsigned int v1; // [bp-0x20]\n  unsigned int v2; // [bp-0x1c]\n  unsigned int v3; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v3 = 1;\n  if (setsockopt(a0, 1, 9, &v3, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 4, &a1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 5, &v1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 6, &v0, 4) != -1) {\n    return 0;\n  } else {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = socket(2, 1, 0);\n  if ((unsigned int)v1 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return v1;\n  } else if ((int)ksock_set_reuse(v1)) {\n    return 4294967295;\n  } else {\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) != -1) {\n    return 0;\n  } else {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  sockaddr v1;           // [bp-0x38]\n  char v2;               // [bp-0x36]\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rax\n\n  v0 = 16;\n  v4 = accept(a0, &v1, &v0);\n  if ((unsigned int)v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), (unsigned int)a0);\n    return v4;\n  }\n  strcpy(a1, inet_ntoa());\n  v5 = *((short *)&v2);\n  *((unsigned short *)&v5) = __ROL__((unsigned short)v5, 8);\n  *(a2) = v5;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpw7rym53w/ksock_accept.c:45:26: error: too few arguments to function\ncall, expected 1, have 0 45 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpw7rym53w/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a2, 8);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) == -1) {\n    printf(\"connect :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpqoabamoz/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() { return strerror(*(__errno_location())); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpq25btpa0/k_strerr_name_conflict.c:20:21: error: indirection requires pointer operand\n('int' invalid) 20 |     return strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\ntypedef struct struct_0 {\n  char field_ - 2;\n} struct_0;\n\nlong long k_chbindir_name_conflict() {\n  void *v0;               // [bp-0x108]\n  int tmp_17;             // tmp #17\n  void *v1;               // [bp-0x100]\n  void *v2;               // [bp-0xf8]\n  void *v3;               // [bp-0xf0]\n  void *v4;               // [bp-0xe8]\n  void *v5;               // [bp-0xe0]\n  void *v6;               // [bp-0xd8]\n  void *v7;               // [bp-0xd0]\n  void *v8;               // [bp-0xc8]\n  void *v9;               // [bp-0xc0]\n  void *v10;              // [bp-0xb8]\n  void *v11;              // [bp-0xb0]\n  void *v12;              // [bp-0xa8]\n  void *v13;              // [bp-0xa0]\n  void *v14;              // [bp-0x98]\n  void *v15;              // [bp-0x90]\n  void *v16;              // [bp-0x88]\n  void *v17;              // [bp-0x80]\n  void *v18;              // [bp-0x78]\n  void *v19;              // [bp-0x70]\n  void *v20;              // [bp-0x68]\n  void *v21;              // [bp-0x60]\n  void *v22;              // [bp-0x58]\n  void *v23;              // [bp-0x50]\n  void *v24;              // [bp-0x48]\n  void *v25;              // [bp-0x40]\n  void *v26;              // [bp-0x38]\n  void *v27;              // [bp-0x30]\n  void *v28;              // [bp-0x28]\n  void *v29;              // [bp-0x20]\n  void *v30;              // [bp-0x18]\n  void *v31;              // [bp-0x10]\n  unsigned long long v33; // rax\n  struct_0 *v35;          // rax, Other Possible Types: unsigned long\n  unsigned long v36;      // rdx\n  char v37;               // cl\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v33 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if ((unsigned int)v33 <= 0)\n    return 1;\n  v36 = v33 - 1;\n  v37 = *((char *)&v0 + v36);\n  if ((unsigned int)v36 && v37 != 47) {\n    v35 = (char *)&v0 + v33;\n    do {\n      *((char *)(v35 - 1)) = 0;\n      v37 = *((char *)(v35 - 2));\n      v35 -= 1;\n      tmp_17 = v36;\n      v36 = (unsigned int)v36 - 1;\n    } while ((int)tmp_17 != 1 && v37 != 47);\n  }\n  if (v37 != 47)\n    return 1;\n  if (!(unsigned int)v36)\n    return chdir(&v0);\n  *((char *)&v0 + v36) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpg6tri9at/k_chbindir_name_conflict.c:20:16: error: expected ';' at end of declaration\nlist 20 |     char field_-2; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xb8]\n  unsigned int v1;       // [bp-0xb0]\n  unsigned int v2;       // [bp-0x30]\n  unsigned long long v3; // [bp-0x18]\n  unsigned long long v4; // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  v3 = -1;\n  setrlimit(4, &v3);\n  getrlimit(6, &v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;               // [bp-0xa8]\n  unsigned int v1;       // [bp-0xa0]\n  unsigned int v2;       // [bp-0x20]\n  unsigned long long v4; // rax\n\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  (unsigned int)v4 = fork();\n  if ((unsigned int)v4 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if ((unsigned int)v4 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    if (setsid() >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_dylec2w/k_demon_name_conflict.c:35:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 35 |     (unsigned int)v4 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp_dylec2w/k_demon_name_conflict.c:38:29: error: indirection requires pointer operand\n('int' invalid) 38 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp_dylec2w/k_demon_name_conflict.c:54:31: error: indirection\nrequires pointer operand ('int' invalid) 54 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned long long v0;  // [bp-0xb8]\n  unsigned long long v1;  // [bp-0xb0]\n  unsigned long long v2;  // [bp-0xa8]\n  char v3;                // [bp-0xa0]\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v6; // rdi, Other Possible Types: unsigned long\n  unsigned long v7;       // d\n\n  v5 = 18;\n  for (v6 = &v3; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  v0 = 0x2800;\n  setrlimit(7, &v0);\n  getrlimit(7, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  while ((unsigned int)v1 == -1) {\n    v1 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpoeo1yfi4/ksock_close_name_conflict.c:25:13: error: indirection requires pointer\noperand ('int' invalid) 25 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = ioctl(a0, a1);\n  if ((unsigned int)v1) {\n    printf(\"ioctl :%s\\n\", (int)k_strerr());\n    return 1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp80_tibtw/ksock_ioctl_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v1 = ioctl(a0, a1); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v1; // rbx\n\n  strcpy(a2, inet_ntoa());\n  v1 = a0 / 0x10000;\n  *((unsigned short *)&v1) = __ROL__((unsigned short)v1, 8);\n  *(a3) = v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpuaan5xcv/ksock_from_addr.c:24:26: error: too few arguments to function\ncall, expected 1, have 0 24 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpuaan5xcv/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = __ROL__((unsigned short)a2, 8);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 1;\n  if (setsockopt(a0, 1, 2, &v0, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &a1, 4) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x24]\n  unsigned int v1; // [bp-0x20]\n  unsigned int v2; // [bp-0x1c]\n  unsigned int v3; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v3 = 1;\n  if (setsockopt(a0, 1, 9, &v3, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 4, &v2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 5, &v1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 6, &v0, 4) != -1) {\n    return 0;\n  } else {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned long v1; // rbx, Other Possible Types: unsigned long long\n\n  v1 = socket(2, 1, 0);\n  if ((unsigned int)v1 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return v1;\n  } else if ((int)ksock_set_reuse(v1)) {\n    return 4294967295;\n  } else {\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) != -1) {\n    return 0;\n  } else {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  sockaddr v1;           // [bp-0x38]\n  char v2;               // [bp-0x36]\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rax\n\n  v0 = 16;\n  v4 = accept(a0, &v1, &v0);\n  if ((unsigned int)v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), (unsigned int)a0);\n    return v4;\n  }\n  strcpy(a1, inet_ntoa());\n  v5 = *((short *)&v2);\n  *((unsigned short *)&v5) = __ROL__((unsigned short)v5, 8);\n  *(a2) = v5;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp_fgz9nbr/ksock_accept.c:45:26: error: too few arguments to function\ncall, expected 1, have 0 45 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp_fgz9nbr/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a2, 8);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) == -1) {\n    printf(\"connect :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp1xo0oj6r/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() { return strerror(*(__errno_location())); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpl72nbkxm/k_strerr_name_conflict.c:20:21: error: indirection requires pointer operand\n('int' invalid) 20 |     return strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long k_chbindir_name_conflict() {\n  void *v0;               // [bp-0x108]\n  int tmp_17;             // tmp #17\n  void *v1;               // [bp-0x100]\n  void *v2;               // [bp-0xf8]\n  void *v3;               // [bp-0xf0]\n  void *v4;               // [bp-0xe8]\n  void *v5;               // [bp-0xe0]\n  void *v6;               // [bp-0xd8]\n  void *v7;               // [bp-0xd0]\n  void *v8;               // [bp-0xc8]\n  void *v9;               // [bp-0xc0]\n  void *v10;              // [bp-0xb8]\n  void *v11;              // [bp-0xb0]\n  void *v12;              // [bp-0xa8]\n  void *v13;              // [bp-0xa0]\n  void *v14;              // [bp-0x98]\n  void *v15;              // [bp-0x90]\n  void *v16;              // [bp-0x88]\n  void *v17;              // [bp-0x80]\n  void *v18;              // [bp-0x78]\n  void *v19;              // [bp-0x70]\n  void *v20;              // [bp-0x68]\n  void *v21;              // [bp-0x60]\n  void *v22;              // [bp-0x58]\n  void *v23;              // [bp-0x50]\n  void *v24;              // [bp-0x48]\n  void *v25;              // [bp-0x40]\n  void *v26;              // [bp-0x38]\n  void *v27;              // [bp-0x30]\n  void *v28;              // [bp-0x28]\n  void *v29;              // [bp-0x20]\n  void *v30;              // [bp-0x18]\n  void *v31;              // [bp-0x10]\n  unsigned long long v33; // rax\n  struct_0 *v35;          // rax, Other Possible Types: unsigned long\n  unsigned long v36;      // rdx\n  char v37;               // cl\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v33 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if ((unsigned int)v33 <= 0)\n    return 1;\n  v36 = v33 - 1;\n  v37 = *((char *)&v0 + v36);\n  if ((unsigned int)v36 && v37 != 47) {\n    v35 = (char *)&v0 + v33;\n    do {\n      *((char *)(v35 - 1)) = 0;\n      v37 = *((char *)(v35 - 2));\n      v35 -= 1;\n      tmp_17 = v36;\n      v36 = (unsigned int)v36 - 1;\n    } while ((int)tmp_17 != 1 && v37 != 47);\n  }\n  if (v37 != 47)\n    return 1;\n  if (!(unsigned int)v36)\n    return chdir(&v0);\n  *((char *)&v0 + v36) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2xepd32o/k_chbindir_name_conflict.c:20:16: error: expected ';' at end of declaration\nlist 20 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xb8]\n  unsigned int v1;       // [bp-0xb0]\n  unsigned int v2;       // [bp-0x30]\n  unsigned long long v3; // [bp-0x18]\n  unsigned long long v4; // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  v3 = -1;\n  setrlimit(4, &v3);\n  getrlimit(6, &v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;               // [bp-0xa8]\n  unsigned int v1;       // [bp-0xa0]\n  unsigned int v2;       // [bp-0x20]\n  unsigned long long v4; // rax\n\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  (unsigned int)v4 = fork();\n  if ((unsigned int)v4 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if ((unsigned int)v4 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    if (setsid() >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6q0sfse5/k_demon_name_conflict.c:35:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 35 |     (unsigned int)v4 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmp6q0sfse5/k_demon_name_conflict.c:38:29: error: indirection requires pointer operand\n('int' invalid) 38 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmp6q0sfse5/k_demon_name_conflict.c:54:31: error: indirection\nrequires pointer operand ('int' invalid) 54 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned long long v0;  // [bp-0xb8]\n  unsigned long long v1;  // [bp-0xb0]\n  unsigned long long v2;  // [bp-0xa8]\n  char v3;                // [bp-0xa0]\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v6; // rdi, Other Possible Types: unsigned long\n  unsigned long v7;       // d\n\n  v5 = 18;\n  for (v6 = &v3; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  v0 = 0x2800;\n  setrlimit(7, &v0);\n  getrlimit(7, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  while ((unsigned int)v1 == -1) {\n    v1 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpjk4dlay0/ksock_close_name_conflict.c:25:13: error: indirection requires pointer\noperand ('int' invalid) 25 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = ioctl(a0, a1);\n  if ((unsigned int)v1) {\n    printf(\"ioctl :%s\\n\", (int)k_strerr());\n    return 1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmppjc4pofn/ksock_ioctl_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v1 = ioctl(a0, a1); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v1; // rbx\n\n  strcpy(a2, inet_ntoa());\n  v1 = a0 / 0x10000;\n  *((unsigned short *)&v1) = __ROL__((unsigned short)v1, 8);\n  *(a3) = v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp9tprblcm/ksock_from_addr.c:24:26: error: too few arguments to function\ncall, expected 1, have 0 24 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp9tprblcm/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = __ROL__((unsigned short)a2, 8);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 1;\n  if (setsockopt(a0, 1, 2, &v0, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &v0, 4) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x24]\n  unsigned int v1; // [bp-0x20]\n  unsigned int v2; // [bp-0x1c]\n  unsigned int v3; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v3 = 1;\n  if (setsockopt(a0, 1, 9, &v3, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 4, &v2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 5, &a2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 6, &v0, 4) != -1) {\n    return 0;\n  } else {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = socket(2, 1, 0);\n  if ((unsigned int)v1 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return v1;\n  } else if ((int)ksock_set_reuse(v1)) {\n    return 4294967295;\n  } else {\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) != -1) {\n    return 0;\n  } else {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  sockaddr v1;           // [bp-0x38]\n  char v2;               // [bp-0x36]\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rax\n\n  v0 = 16;\n  v4 = accept(a0, &v1, &v0);\n  if ((unsigned int)v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), (unsigned int)a0);\n    return v4;\n  }\n  strcpy(a1, inet_ntoa());\n  v5 = *((short *)&v2);\n  *((unsigned short *)&v5) = __ROL__((unsigned short)v5, 8);\n  *(a2) = v5;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpa2hhnxcz/ksock_accept.c:45:26: error: too few arguments to function\ncall, expected 1, have 0 45 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpa2hhnxcz/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a2, 8);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) == -1) {\n    printf(\"connect :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp8w3dnyw7/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() { return strerror(*(__errno_location())); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpustpptv4/k_strerr_name_conflict.c:20:21: error: indirection requires pointer operand\n('int' invalid) 20 |     return strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long k_chbindir_name_conflict() {\n  void *v0;               // [bp-0x108]\n  int tmp_17;             // tmp #17\n  void *v1;               // [bp-0x100]\n  void *v2;               // [bp-0xf8]\n  void *v3;               // [bp-0xf0]\n  void *v4;               // [bp-0xe8]\n  void *v5;               // [bp-0xe0]\n  void *v6;               // [bp-0xd8]\n  void *v7;               // [bp-0xd0]\n  void *v8;               // [bp-0xc8]\n  void *v9;               // [bp-0xc0]\n  void *v10;              // [bp-0xb8]\n  void *v11;              // [bp-0xb0]\n  void *v12;              // [bp-0xa8]\n  void *v13;              // [bp-0xa0]\n  void *v14;              // [bp-0x98]\n  void *v15;              // [bp-0x90]\n  void *v16;              // [bp-0x88]\n  void *v17;              // [bp-0x80]\n  void *v18;              // [bp-0x78]\n  void *v19;              // [bp-0x70]\n  void *v20;              // [bp-0x68]\n  void *v21;              // [bp-0x60]\n  void *v22;              // [bp-0x58]\n  void *v23;              // [bp-0x50]\n  void *v24;              // [bp-0x48]\n  void *v25;              // [bp-0x40]\n  void *v26;              // [bp-0x38]\n  void *v27;              // [bp-0x30]\n  void *v28;              // [bp-0x28]\n  void *v29;              // [bp-0x20]\n  void *v30;              // [bp-0x18]\n  void *v31;              // [bp-0x10]\n  unsigned long long v33; // rax\n  struct_0 *v35;          // rax, Other Possible Types: unsigned long\n  unsigned long v36;      // rdx\n  char v37;               // cl\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v33 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if ((unsigned int)v33 <= 0)\n    return 1;\n  v36 = v33 - 1;\n  v37 = *((char *)&v0 + v36);\n  if ((unsigned int)v36 && v37 != 47) {\n    v35 = (char *)&v0 + v33;\n    do {\n      *((char *)(v35 - 1)) = 0;\n      v37 = *((char *)(v35 - 2));\n      v35 -= 1;\n      tmp_17 = v36;\n      v36 = (unsigned int)v36 - 1;\n    } while ((int)tmp_17 != 1 && v37 != 47);\n  }\n  if (v37 != 47)\n    return 1;\n  if (!(unsigned int)v36)\n    return chdir(&v0);\n  *((char *)&v0 + v36) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpcv7vv5kw/k_chbindir_name_conflict.c:20:16: error: expected ';' at end of declaration\nlist 20 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xb8]\n  unsigned int v1;       // [bp-0xb0]\n  unsigned int v2;       // [bp-0x30]\n  unsigned long long v3; // [bp-0x18]\n  unsigned long long v4; // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  v3 = -1;\n  setrlimit(4, &v3);\n  getrlimit(6, &v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;               // [bp-0xa8]\n  unsigned int v1;       // [bp-0xa0]\n  unsigned int v2;       // [bp-0x20]\n  unsigned long long v4; // rax\n\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  (unsigned int)v4 = fork();\n  if ((unsigned int)v4 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if ((unsigned int)v4 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    if (setsid() >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpbkev0cxn/k_demon_name_conflict.c:35:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 35 |     (unsigned int)v4 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmpbkev0cxn/k_demon_name_conflict.c:38:29: error: indirection requires pointer operand\n('int' invalid) 38 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmpbkev0cxn/k_demon_name_conflict.c:54:31: error: indirection\nrequires pointer operand ('int' invalid) 54 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned long long v0;  // [bp-0xb8]\n  unsigned long long v1;  // [bp-0xb0]\n  unsigned long long v2;  // [bp-0xa8]\n  char v3;                // [bp-0xa0]\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v6; // rdi, Other Possible Types: unsigned long\n  unsigned long v7;       // d\n\n  v5 = 18;\n  for (v6 = &v3; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  v0 = 0x2800;\n  setrlimit(7, &v0);\n  getrlimit(7, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  while ((unsigned int)v1 == -1) {\n    v1 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpsu3flx49/ksock_close_name_conflict.c:25:13: error: indirection requires pointer\noperand ('int' invalid) 25 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = ioctl(a0, a1);\n  if ((unsigned int)v1) {\n    printf(\"ioctl :%s\\n\", (int)k_strerr());\n    return 1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2rodh6zd/ksock_ioctl_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v1 = ioctl(a0, a1); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v1; // rbx\n\n  strcpy(a2, inet_ntoa());\n  v1 = a0 / 0x10000;\n  *((unsigned short *)&v1) = __ROL__((unsigned short)v1, 8);\n  *(a3) = v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpir_dhccy/ksock_from_addr.c:24:26: error: too few arguments to function\ncall, expected 1, have 0 24 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpir_dhccy/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = __ROL__((unsigned short)a2, 8);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 1;\n  if (setsockopt(a0, 1, 2, &v0, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &a1, 4) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x24]\n  unsigned int v1; // [bp-0x20]\n  unsigned int v2; // [bp-0x1c]\n  unsigned int v3; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v3 = 1;\n  if (setsockopt(a0, 1, 9, &v3, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 4, &v2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 5, &v1, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 6, &v0, 4) != -1) {\n    return 0;\n  } else {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = socket(2, 1, 0);\n  if ((unsigned int)v1 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return v1;\n  } else if ((int)ksock_set_reuse(v1)) {\n    return 4294967295;\n  } else {\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) != -1) {\n    return 0;\n  } else {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  sockaddr v1;           // [bp-0x38]\n  char v2;               // [bp-0x36]\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rax\n\n  v0 = 16;\n  v4 = accept(a0, &v1, &v0);\n  if ((unsigned int)v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), (unsigned int)a0);\n    return v4;\n  }\n  strcpy(a1, inet_ntoa());\n  v5 = *((short *)&v2);\n  *((unsigned short *)&v5) = __ROL__((unsigned short)v5, 8);\n  *(a2) = v5;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpxgkkt305/ksock_accept.c:45:26: error: too few arguments to function\ncall, expected 1, have 0 45 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmpxgkkt305/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a2, 8);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) == -1) {\n    printf(\"connect :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long k_errno_name_conflict() { return *(__errno_location()); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp7ubmrlj5/k_errno_name_conflict.c:19:12: error: indirection requires pointer operand\n('int' invalid) 19 |     return *(__errno_location()); | ^~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(strerror)(int);\n\nlong long k_strerr_name_conflict() { return strerror(*(__errno_location())); }\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmps26_u5cv/k_strerr_name_conflict.c:20:21: error: indirection requires pointer operand\n('int' invalid) 20 |     return strerror(*(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong(readlink)(char *, char *, unsigned long);\nint(chdir)(char *);\n\ntypedef struct struct_0 {\n  char field_ - 1;\n} struct_0;\n\nlong long k_chbindir_name_conflict() {\n  void *v0;               // [bp-0x108]\n  int tmp_17;             // tmp #17\n  void *v1;               // [bp-0x100]\n  void *v2;               // [bp-0xf8]\n  void *v3;               // [bp-0xf0]\n  void *v4;               // [bp-0xe8]\n  void *v5;               // [bp-0xe0]\n  void *v6;               // [bp-0xd8]\n  void *v7;               // [bp-0xd0]\n  void *v8;               // [bp-0xc8]\n  void *v9;               // [bp-0xc0]\n  void *v10;              // [bp-0xb8]\n  void *v11;              // [bp-0xb0]\n  void *v12;              // [bp-0xa8]\n  void *v13;              // [bp-0xa0]\n  void *v14;              // [bp-0x98]\n  void *v15;              // [bp-0x90]\n  void *v16;              // [bp-0x88]\n  void *v17;              // [bp-0x80]\n  void *v18;              // [bp-0x78]\n  void *v19;              // [bp-0x70]\n  void *v20;              // [bp-0x68]\n  void *v21;              // [bp-0x60]\n  void *v22;              // [bp-0x58]\n  void *v23;              // [bp-0x50]\n  void *v24;              // [bp-0x48]\n  void *v25;              // [bp-0x40]\n  void *v26;              // [bp-0x38]\n  void *v27;              // [bp-0x30]\n  void *v28;              // [bp-0x28]\n  void *v29;              // [bp-0x20]\n  void *v30;              // [bp-0x18]\n  void *v31;              // [bp-0x10]\n  unsigned long long v33; // rax\n  struct_0 *v35;          // rax, Other Possible Types: unsigned long\n  unsigned long v36;      // rdx\n  char v37;               // cl\n\n  v0 = 0;\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  v20 = 0;\n  v21 = 0;\n  v22 = 0;\n  v23 = 0;\n  v24 = 0;\n  v25 = 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v30 = 0;\n  v31 = 0;\n  v33 = readlink(\"/proc/self/exe\", &v0, 0x100);\n  if ((unsigned int)v33 <= 0)\n    return 1;\n  v36 = v33 - 1;\n  v37 = *((char *)&v0 + v36);\n  if ((unsigned int)v36 && v37 != 47) {\n    v35 = (char *)&v0 + v33;\n    do {\n      *((char *)(v35 - 1)) = 0;\n      v37 = *((char *)(v35 - 2));\n      v35 -= 1;\n      tmp_17 = v36;\n      v36 = (unsigned int)v36 - 1;\n    } while ((int)tmp_17 != 1 && v37 != 47);\n  }\n  if (v37 != 47)\n    return 1;\n  if (!(unsigned int)v36)\n    return chdir(&v0);\n  *((char *)&v0 + v36) = 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmpx7n_8rqn/k_chbindir_name_conflict.c:20:16: error: expected ';' at end of declaration\nlist 20 |     char field_-1; |                ^ |                ; 1 error\ngenerated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_core_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_chbindir)();\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(system)(char *);\n\nlong long k_core_dump_name_conflict() {\n  char v0;               // [bp-0xb8]\n  unsigned int v1;       // [bp-0xb0]\n  unsigned int v2;       // [bp-0x30]\n  unsigned long long v3; // [bp-0x18]\n  unsigned long long v4; // [bp-0x10]\n\n  k_chbindir();\n  v4 = -1;\n  v3 = -1;\n  setrlimit(4, &v3);\n  getrlimit(6, &v3);\n  v2 = 0x80000000;\n  *((void **)&v0) = k_core_handler;\n  sigemptyset(&v1);\n  sigaction(0x8, &v0, NULL);\n  sigaction(0xb, &v0, NULL);\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\nint k_demon_name_conflict_handler; // add global variable by heuristics\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(sigemptyset)(int *);\nchar *(sigaction)(char *, char *, char *);\nint(fork)();\nunsigned short(umask)(unsigned short);\nint(setsid)();\nint(close)(int);\n\nlong long k_demon_name_conflict() {\n  char v0;               // [bp-0xa8]\n  unsigned int v1;       // [bp-0xa0]\n  unsigned int v2;       // [bp-0x20]\n  unsigned long long v4; // rax\n\n  v2 = 0x80000000;\n  *((void **)&v0) = k_demon_name_conflict_handler;\n  sigemptyset(&v1);\n  sigaction(0xf, &v0, NULL);\n  (unsigned int)v4 = fork();\n  if ((unsigned int)v4 < 0) {\n    printf(\"fork %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  } else if ((unsigned int)v4 > 0) {\n    exit(0); /* do not return */\n  } else {\n    umask(0);\n    if (setsid() >= 0) {\n      close(0);\n      close(2);\n      return 0;\n    }\n    printf(\"setsid %d\\n\", *(__errno_location()));\n    exit(1); /* do not return */\n  }\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmplfrx93f0/k_demon_name_conflict.c:35:5: error: assignment to cast is illegal, lvalue\ncasts are not supported 35 |     (unsigned int)v4 = fork(); | ^~~~~~~~~~~~~~~~ ~\n/tmp/tmplfrx93f0/k_demon_name_conflict.c:38:29: error: indirection requires pointer operand\n('int' invalid) 38 |         printf(\"fork %d\\n\", *(__errno_location())); |\n^~~~~~~~~~~~~~~~~~~~~ /tmp/tmplfrx93f0/k_demon_name_conflict.c:54:31: error: indirection\nrequires pointer operand ('int' invalid) 54 |         printf(\"setsid %d\\n\",\n*(__errno_location())); |                               ^~~~~~~~~~~~~~~~~~~~~ 3\nerrors generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(sigaction)(char *, char *, char *);\nint(setrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\nint(getrlimit)(\n    int, struct rlimit {\n      unsigned long rlim_cur;\n      unsigned long rlim_max;\n    } *);\n\nlong long ksock_init_name_conflict() {\n  unsigned long long v0;  // [bp-0xb8]\n  unsigned long long v1;  // [bp-0xb0]\n  unsigned long long v2;  // [bp-0xa8]\n  char v3;                // [bp-0xa0]\n  unsigned long v5;       // rcx, Other Possible Types: unsigned long long\n  unsigned long long *v6; // rdi, Other Possible Types: unsigned long\n  unsigned long v7;       // d\n\n  v5 = 18;\n  for (v6 = &v3; v5; v6 += v7 * 8) {\n    v5 -= 1;\n    *((long long *)v6) = 0;\n  }\n  v2 = 1;\n  sigaction(0xd, &v2, NULL);\n  v1 = 0x2800;\n  v0 = 0x2800;\n  setrlimit(7, &v0);\n  getrlimit(7, &v0);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_non_blocking_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(fcntl)(int, int, ...);\n\nlong long ksock_set_close_onexec_name_conflict(unsigned long a0) {\n  if (fcntl(a0, 3) != -1)\n    return fcntl(a0, 4);\n  return 1;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(shutdown)(int, int);\n\nlong long ksock_shutdown_name_conflict(unsigned long a0, unsigned long a1) {\n  return shutdown(a0, a1);\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(close)(int);\n\nlong long ksock_close_name_conflict(unsigned long a0) {\n  unsigned long long v1; // rbx\n\n  while ((unsigned int)v1 == -1) {\n    v1 = close(a0);\n    if (*(__errno_location()) != 4)\n      return v1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp2000vlsu/ksock_close_name_conflict.c:25:13: error: indirection requires pointer\noperand ('int' invalid) 25 |         if (*(__errno_location()) != 4) |\n^~~~~~~~~~~~~~~~~~~~~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nlong long(k_strerr)();\n\nlong long ksock_ioctl_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned long long v1; // rax, Other Possible Types: unsigned long\n\n  (unsigned int)v1 = ioctl(a0, a1);\n  if ((unsigned int)v1) {\n    printf(\"ioctl :%s\\n\", (int)k_strerr());\n    return 1;\n  }\n  return v1;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp4t9cae49/ksock_ioctl_name_conflict.c:22:5: error: assignment to cast is illegal,\nlvalue casts are not supported 22 |     (unsigned int)v1 = ioctl(a0, a1); |\n^~~~~~~~~~~~~~~~ ~ 1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\nlong long ksock_from_addr(unsigned long a0, unsigned long a1, char *a2,\n                          unsigned int *a3) {\n  unsigned long v1; // rbx\n\n  strcpy(a2, inet_ntoa());\n  v1 = a0 / 0x10000;\n  *((unsigned short *)&v1) = __ROL__((unsigned short)v1, 8);\n  *(a3) = v1;\n  return 0;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp6ujfadui/ksock_from_addr.c:24:26: error: too few arguments to function\ncall, expected 1, have 0 24 |     strcpy(a2, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp6ujfadui/ksock_from_addr.c:16:8: note: 'inet_ntoa' declared here\n   16 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\n\ntypedef struct struct_0 {\n  unsigned short field_0;\n  unsigned short field_2;\n  unsigned int field_4;\n} struct_0;\n\nlong long ksock_to_addr_name_conflict(struct_0 *a0, char *a1, unsigned long a2) {\n  a0->field_0 = 2;\n  a0->field_2 = __ROL__((unsigned short)a2, 8);\n  a0->field_4 = inet_addr(a1);\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_reuse_name_conflict(unsigned long a0) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = 1;\n  if (setsockopt(a0, 1, 2, &v0, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_sendbuf_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned int v0; // [bp-0xc]\n\n  v0 = a1;\n  if (setsockopt(a0, 1, 7, &a1, 4) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(setsockopt)(int, int, int, void *, int);\nlong long(k_errno)();\n\nlong long ksock_set_alive(unsigned long a0, unsigned long a1, unsigned long a2,\n                          unsigned long a3) {\n  unsigned int v0; // [bp-0x24]\n  unsigned int v1; // [bp-0x20]\n  unsigned int v2; // [bp-0x1c]\n  unsigned int v3; // [bp-0xc]\n\n  v2 = a1;\n  v1 = a2;\n  v0 = a3;\n  v3 = 1;\n  if (setsockopt(a0, 1, 9, &v3, 4) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 4, &v2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 5, &a2, 4) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  } else if (setsockopt(a0, 6, 6, &a3, 4) != -1) {\n    return 0;\n  } else {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", (int)k_errno(),\n           (unsigned int)a0);\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(socket)(int, int, int);\nlong long(k_errno)();\nlong long(ksock_set_reuse)(long long);\n\nlong long ksock_init_fd_name_conflict() {\n  unsigned long long v1; // rbx, Other Possible Types: unsigned long\n\n  v1 = socket(2, 1, 0);\n  if ((unsigned int)v1 == -1) {\n    printf(\"socket :%d\\n\", (int)k_errno());\n    return v1;\n  } else if ((int)ksock_set_reuse(v1)) {\n    return 4294967295;\n  } else {\n    return v1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_bind_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(bind)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\nint(listen)(int, int);\n\nlong long ksock_listen_at_name_conflict(unsigned long a0, unsigned long a1) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a1, 8);\n  v2 = 0;\n  if (bind(a0, &v0, 16) == -1) {\n    printf(\"bind :%d\\n\", (int)k_errno());\n    return 1;\n  } else if (listen(a0, 0x1000) != -1) {\n    return 0;\n  } else {\n    printf(\"listen :%d\\n\", (int)k_errno());\n    return 1;\n  }\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nint(accept)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int *);\nlong long(k_errno)();\nchar *(inet_ntoa)(struct in_addr { uint32_t s_addr; });\n\ntypedef struct sockaddr {\n  unsigned short sin_family;\n  char sa_data[14];\n} sockaddr;\n\nlong long ksock_accept(unsigned long a0, char *a1, unsigned int *a2) {\n  unsigned int v0;       // [bp-0x3c]\n  sockaddr v1;           // [bp-0x38]\n  char v2;               // [bp-0x36]\n  unsigned long long v4; // rbx\n  unsigned long long v5; // rax\n\n  v0 = 16;\n  v4 = accept(a0, &v1, &v0);\n  if ((unsigned int)v4 == -1) {\n    printf(\"accept :%d, fd:%d\\n\", (int)k_errno(), (unsigned int)a0);\n    return v4;\n  }\n  strcpy(a1, inet_ntoa());\n  v5 = *((short *)&v2);\n  *((unsigned short *)&v5) = __ROL__((unsigned short)v5, 8);\n  *(a2) = v5;\n  return v4;\n}\n\nint main(int argc, char **argv) { return 0; }\n\n/* --- clang still complains after heuristic fixes ---\n/tmp/tmp439eyd8b/ksock_accept.c:45:26: error: too few arguments to function\ncall, expected 1, have 0 45 |     strcpy(a1, inet_ntoa()); | ~~~~~~~~~ ^\n/tmp/tmp439eyd8b/ksock_accept.c:21:8: note: 'inet_ntoa' declared here\n   21 | char *(inet_ntoa)(struct in_addr {\n      |        ^          ~~~~~~~~~~~~~~\n1 error generated.\n\n*/\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef unsigned int BOT;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\nunsigned int(inet_addr)(char *);\nint(connect)(\n    int,\n    struct sockaddr {\n      unsigned short sin_family;\n      char sa_data[14];\n    } *,\n    int);\nlong long(k_errno)();\n\nlong long ksock_connect_name_conflict(unsigned long a0, char *a1, unsigned long a2) {\n  unsigned short v0; // [bp-0x18]\n  unsigned short v1; // [bp-0x16]\n  unsigned int v2;   // [bp-0x14]\n\n  v0 = 2;\n  v1 = __ROL__((unsigned short)a2, 8);\n  v2 = inet_addr(a1);\n  if (connect(a0, &v0, 16) == -1) {\n    printf(\"connect :%d\\n\", (int)k_errno());\n    return 1;\n  }\n  return 0;\n}\n","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
